{"idx": 5266, "func": "CERT *ssl_cert_dup(CERT *cert)\n\t{\n\tCERT *ret;\n\tint i;\n\n\tret = (CERT *)Malloc(sizeof(CERT));\n\tif (ret == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_MALLOC_FAILURE);\n\t\treturn(NULL);\n\t\t}\n\n\tmemset(ret, 0, sizeof(CERT));\n\n\tret->key = &ret->pkeys[cert->key - &cert->pkeys[0]];\n\t/* or ret->key = ret->pkeys + (cert->key - cert->pkeys),\n\t * if you find that more readable */\n\n\tret->valid = cert->valid;\n\tret->mask = cert->mask;\n\tret->export_mask = cert->export_mask;\n\n#ifndef NO_RSA\n\tif (cert->rsa_tmp != NULL)\n\t\t{\n\t\tret->rsa_tmp = cert->rsa_tmp;\n\t\tCRYPTO_add(&ret->rsa_tmp->references, 1, CRYPTO_LOCK_RSA);\n\t\t}\n\tret->rsa_tmp_cb = cert->rsa_tmp_cb;\n#endif\n\n#ifndef NO_DH\n\tif (cert->dh_tmp != NULL)\n\t\t{\n\t\t/* DH parameters don't have a reference count */\n\t\tret->dh_tmp = DHparams_dup(cert->dh_tmp);\n\t\tif (ret->dh_tmp == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_CERT_NEW, ERR_R_DH_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (cert->dh_tmp->priv_key)\n\t\t\t{\n\t\t\tBIGNUM *b = BN_dup(cert->dh_tmp->priv_key);\n\t\t\tif (!b)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL_CERT_NEW, ERR_R_BN_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tret->dh_tmp->priv_key = b;\n\t\t\t}\n\t\tif (cert->dh_tmp->pub_key)\n\t\t\t{\n\t\t\tBIGNUM *b = BN_dup(cert->dh_tmp->pub_key);\n\t\t\tif (!b)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL_CERT_NEW, ERR_R_BN_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tret->dh_tmp->pub_key = b;\n\t\t\t}\n\t\t}\n\tret->dh_tmp_cb = cert->dh_tmp_cb;\n#endif\n\n\tfor (i = 0; i < SSL_PKEY_NUM; i++)\n\t\t{\n\t\tif (cert->pkeys[i].x509 != NULL)\n\t\t\t{\n\t\t\tret->pkeys[i].x509 = cert->pkeys[i].x509;\n\t\t\tCRYPTO_add(&ret->pkeys[i].x509->references, 1,\n\t\t\t\tCRYPTO_LOCK_X509);\n\t\t\t}\n\t\t\n\t\tif (cert->pkeys[i].privatekey != NULL)\n\t\t\t{\n\t\t\tret->pkeys[i].privatekey = cert->pkeys[i].privatekey;\n\t\t\tCRYPTO_add(&ret->pkeys[i].privatekey->references, 1,\n\t\t\t\tCRYPTO_LOCK_EVP_PKEY);\n\n\t\t\tswitch(i) \n\t\t\t\t{\n\t\t\t\t/* If there was anything special to do for\n\t\t\t\t * certain types of keys, we'd do it here.\n\t\t\t\t * (Nothing at the moment, I think.) */\n\n\t\t\tcase SSL_PKEY_RSA_ENC:\n\t\t\tcase SSL_PKEY_RSA_SIGN:\n\t\t\t\t/* We have an RSA key. */\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase SSL_PKEY_DSA_SIGN:\n\t\t\t\t/* We have a DSA key. */\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase SSL_PKEY_DH_RSA:\n\t\t\tcase SSL_PKEY_DH_DSA:\n\t\t\t\t/* We have a DH key. */\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\t/* Can't happen. */\n\t\t\t\tSSLerr(SSL_F_SSL_CERT_DUP, SSL_R_LIBRARY_BUG);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t/* ret->extra_certs *should* exist, but currently the own certificate\n\t * chain is held inside SSL_CTX */\n\n\tret->references=1;\n\n\treturn(ret);\n\t\nerr:\n#ifndef NO_RSA\n\tif (ret->rsa_tmp != NULL)\n\t\tRSA_free(ret->rsa_tmp);\n#endif\n#ifndef NO_DH\n\tif (ret->dh_tmp != NULL)\n\t\tDH_free(ret->dh_tmp);\n#endif\n\n\tfor (i = 0; i < SSL_PKEY_NUM; i++)\n\t\t{\n\t\tif (ret->pkeys[i].x509 != NULL)\n\t\t\tX509_free(ret->pkeys[i].x509);\n\t\tif (ret->pkeys[i].privatekey != NULL)\n\t\t\tEVP_PKEY_free(ret->pkeys[i].privatekey);\n\t\t}\n\n\treturn NULL;\n\t}", "target": 0}
{"idx": 5267, "func": "int ff_intrax8_decode_picture(IntraX8Context *w, Picture *pict,\n                              GetBitContext *gb, int *mb_x, int *mb_y,\n                              int dquant, int quant_offset,\n                              int loopfilter, int lowdelay)\n{\n    int mb_xy;\n\n    w->gb     = gb;\n    w->dquant = dquant;\n    w->quant  = dquant >> 1;\n    w->qsum   = quant_offset;\n    w->frame  = pict->f;\n    w->loopfilter = loopfilter;\n    w->use_quant_matrix = get_bits1(w->gb);\n\n    w->mb_x = *mb_x;\n    w->mb_y = *mb_y;\n\n    w->divide_quant_dc_luma = ((1 << 16) + (w->quant >> 1)) / w->quant;\n    if (w->quant < 5) {\n        w->quant_dc_chroma        = w->quant;\n        w->divide_quant_dc_chroma = w->divide_quant_dc_luma;\n    } else {\n        w->quant_dc_chroma        = w->quant + ((w->quant + 3) >> 3);\n        w->divide_quant_dc_chroma = ((1 << 16) + (w->quant_dc_chroma >> 1)) / w->quant_dc_chroma;\n    }\n    x8_reset_vlc_tables(w);\n\n    for (w->mb_y = 0; w->mb_y < w->mb_height * 2; w->mb_y++) {\n        x8_init_block_index(w, w->frame);\n        mb_xy = (w->mb_y >> 1) * (w->mb_width + 1);\n        for (w->mb_x = 0; w->mb_x < w->mb_width * 2; w->mb_x++) {\n            x8_get_prediction(w);\n            if (x8_setup_spatial_predictor(w, 0))\n                goto error;\n            if (x8_decode_intra_mb(w, 0))\n                goto error;\n\n            if (w->mb_x & w->mb_y & 1) {\n                x8_get_prediction_chroma(w);\n\n                /* when setting up chroma, no vlc is read,\n                 * so no error condition can be reached */\n                x8_setup_spatial_predictor(w, 1);\n                if (x8_decode_intra_mb(w, 1))\n                    goto error;\n\n                x8_setup_spatial_predictor(w, 2);\n                if (x8_decode_intra_mb(w, 2))\n                    goto error;\n\n                w->dest[1] += 8;\n                w->dest[2] += 8;\n\n                pict->qscale_table[mb_xy] = w->quant;\n                mb_xy++;\n            }\n            w->dest[0] += 8;\n        }\n        if (w->mb_y & 1)\n            ff_draw_horiz_band(w->avctx, w->frame, w->frame,\n                               (w->mb_y - 1) * 8, 16,\n                               PICT_FRAME, 0, lowdelay);\n    }\n\nerror:\n    *mb_x = w->mb_x;\n    *mb_y = w->mb_y;\n\n    return 0;\n}", "target": 1}
{"idx": 5268, "func": "static void *APR_THREAD_FUNC start_threads(apr_thread_t * thd, void *dummy)\n{\n    thread_starter *ts = dummy;\n    apr_thread_t **threads = ts->threads;\n    apr_threadattr_t *thread_attr = ts->threadattr;\n    int child_num_arg = ts->child_num_arg;\n    int my_child_num = child_num_arg;\n    proc_info *my_info;\n    apr_status_t rv;\n    int i;\n    int threads_created = 0;\n    int listener_started = 0;\n    int loops;\n    int prev_threads_created;\n    int max_recycled_pools = -1;\n\n    /* We must create the fd queues before we start up the listener\n     * and worker threads. */\n    worker_queue = apr_pcalloc(pchild, sizeof(*worker_queue));\n    rv = ap_queue_init(worker_queue, threads_per_child, pchild);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,\n                     \"ap_queue_init() failed\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    if (ap_max_mem_free != APR_ALLOCATOR_MAX_FREE_UNLIMITED) {\n        /* If we want to conserve memory, let's not keep an unlimited number of\n         * pools & allocators.\n         * XXX: This should probably be a separate config directive\n         */\n        max_recycled_pools = threads_per_child * 3 / 4 ;\n    }\n    rv = ap_queue_info_create(&worker_queue_info, pchild,\n                              threads_per_child, max_recycled_pools);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,\n                     \"ap_queue_info_create() failed\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    /* Create the main pollset */\n    rv = apr_pollset_create(&event_pollset,\n                            threads_per_child, /* XXX don't we need more, to handle\n                                                * connections in K-A or lingering\n                                                * close?\n                                                */\n                            pchild, APR_POLLSET_WAKEABLE|APR_POLLSET_NOCOPY);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,\n                     \"apr_pollset_create failed; check system or user limits\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    worker_sockets = apr_pcalloc(pchild, threads_per_child\n                                 * sizeof(apr_socket_t *));\n\n    worker_equeues = apr_palloc(pchild, threads_per_child * sizeof(ap_equeue_t*));\n\n    for (i = 0; i < threads_per_child; i++) {\n        ap_equeue_t* eq = NULL;\n        /* TODO: research/test optimal size of queue here */\n        ap_equeue_create(pchild, 16, sizeof(pollset_op_t), &eq);\n        /* same as thread ID */\n        worker_equeues[i] = eq;\n    }\n\n    loops = prev_threads_created = 0;\n    while (1) {\n        /* threads_per_child does not include the listener thread */\n        for (i = 0; i < threads_per_child; i++) {\n            int status =\n                ap_scoreboard_image->servers[child_num_arg][i].status;\n\n            if (status != SERVER_GRACEFUL && status != SERVER_DEAD) {\n                continue;\n            }\n\n            my_info = (proc_info *) ap_malloc(sizeof(proc_info));\n            my_info->pid = my_child_num;\n            my_info->tid = i;\n            my_info->sd = 0;\n\n            /* We are creating threads right now */\n            ap_update_child_status_from_indexes(my_child_num, i,\n                                                SERVER_STARTING, NULL);\n            /* We let each thread update its own scoreboard entry.  This is\n             * done because it lets us deal with tid better.\n             */\n            rv = apr_thread_create(&threads[i], thread_attr,\n                                   worker_thread, my_info, pchild);\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,\n                             \"apr_thread_create: unable to create worker thread\");\n                /* let the parent decide how bad this really is */\n                clean_child_exit(APEXIT_CHILDSICK);\n            }\n            threads_created++;\n        }\n\n        /* Start the listener only when there are workers available */\n        if (!listener_started && threads_created) {\n            create_listener_thread(ts);\n            listener_started = 1;\n        }\n\n\n        if (start_thread_may_exit || threads_created == threads_per_child) {\n            break;\n        }\n        /* wait for previous generation to clean up an entry */\n        apr_sleep(apr_time_from_sec(1));\n        ++loops;\n        if (loops % 120 == 0) { /* every couple of minutes */\n            if (prev_threads_created == threads_created) {\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,\n                             \"child %\" APR_PID_T_FMT \" isn't taking over \"\n                             \"slots very quickly (%d of %d)\",\n                             ap_my_pid, threads_created,\n                             threads_per_child);\n            }\n            prev_threads_created = threads_created;\n        }\n    }\n\n    /* What state should this child_main process be listed as in the\n     * scoreboard...?\n     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING,\n     *                                      (request_rec *) NULL);\n     *\n     *  This state should be listed separately in the scoreboard, in some kind\n     *  of process_status, not mixed in with the worker threads' status.\n     *  \"life_status\" is almost right, but it's in the worker's structure, and\n     *  the name could be clearer.   gla\n     */\n    apr_thread_exit(thd, APR_SUCCESS);\n    return NULL;\n}", "target": 0}
{"idx": 5269, "func": "static int init_pass2(MpegEncContext *s)\n{\n    RateControlContext *rcc = &s->rc_context;\n    AVCodecContext *a       = s->avctx;\n    int i, toobig;\n    double fps             = get_fps(s->avctx);\n    double complexity[5]   = { 0 }; // approximate bits at quant=1\n    uint64_t const_bits[5] = { 0 }; // quantizer independent bits\n    uint64_t all_const_bits;\n    uint64_t all_available_bits = (uint64_t)(s->bit_rate *\n                                             (double)rcc->num_entries / fps);\n    double rate_factor          = 0;\n    double step;\n    const int filter_size = (int)(a->qblur * 4) | 1;\n    double expected_bits = 0; // init to silence gcc warning\n    double *qscale, *blurred_qscale, qscale_sum;\n\n    /* find complexity & const_bits & decide the pict_types */\n    for (i = 0; i < rcc->num_entries; i++) {\n        RateControlEntry *rce = &rcc->entry[i];\n\n        rce->new_pict_type                = rce->pict_type;\n        rcc->i_cplx_sum[rce->pict_type]  += rce->i_tex_bits * rce->qscale;\n        rcc->p_cplx_sum[rce->pict_type]  += rce->p_tex_bits * rce->qscale;\n        rcc->mv_bits_sum[rce->pict_type] += rce->mv_bits;\n        rcc->frame_count[rce->pict_type]++;\n\n        complexity[rce->new_pict_type] += (rce->i_tex_bits + rce->p_tex_bits) *\n                                          (double)rce->qscale;\n        const_bits[rce->new_pict_type] += rce->mv_bits + rce->misc_bits;\n    }\n\n    all_const_bits = const_bits[AV_PICTURE_TYPE_I] +\n                     const_bits[AV_PICTURE_TYPE_P] +\n                     const_bits[AV_PICTURE_TYPE_B];\n\n    if (all_available_bits < all_const_bits) {\n        av_log(s->avctx, AV_LOG_ERROR, \"requested bitrate is too low\\n\");\n        return -1;\n    }\n\n    qscale         = av_malloc(sizeof(double) * rcc->num_entries);\n    blurred_qscale = av_malloc(sizeof(double) * rcc->num_entries);\n    toobig = 0;\n\n    for (step = 256 * 256; step > 0.0000001; step *= 0.5) {\n        expected_bits = 0;\n        rate_factor  += step;\n\n        rcc->buffer_index = s->avctx->rc_buffer_size / 2;\n\n        /* find qscale */\n        for (i = 0; i < rcc->num_entries; i++) {\n            RateControlEntry *rce = &rcc->entry[i];\n\n            qscale[i] = get_qscale(s, &rcc->entry[i], rate_factor, i);\n            rcc->last_qscale_for[rce->pict_type] = qscale[i];\n        }\n        assert(filter_size % 2 == 1);\n\n        /* fixed I/B QP relative to P mode */\n        for (i = FFMAX(0, rcc->num_entries - 300); i < rcc->num_entries; i++) {\n            RateControlEntry *rce = &rcc->entry[i];\n\n            qscale[i] = get_diff_limited_q(s, rce, qscale[i]);\n        }\n\n        for (i = rcc->num_entries - 1; i >= 0; i--) {\n            RateControlEntry *rce = &rcc->entry[i];\n\n            qscale[i] = get_diff_limited_q(s, rce, qscale[i]);\n        }\n\n        /* smooth curve */\n        for (i = 0; i < rcc->num_entries; i++) {\n            RateControlEntry *rce = &rcc->entry[i];\n            const int pict_type   = rce->new_pict_type;\n            int j;\n            double q = 0.0, sum = 0.0;\n\n            for (j = 0; j < filter_size; j++) {\n                int index    = i + j - filter_size / 2;\n                double d     = index - i;\n                double coeff = a->qblur == 0 ? 1.0 : exp(-d * d / (a->qblur * a->qblur));\n\n                if (index < 0 || index >= rcc->num_entries)\n                    continue;\n                if (pict_type != rcc->entry[index].new_pict_type)\n                    continue;\n                q   += qscale[index] * coeff;\n                sum += coeff;\n            }\n            blurred_qscale[i] = q / sum;\n        }\n\n        /* find expected bits */\n        for (i = 0; i < rcc->num_entries; i++) {\n            RateControlEntry *rce = &rcc->entry[i];\n            double bits;\n\n            rce->new_qscale = modify_qscale(s, rce, blurred_qscale[i], i);\n\n            bits  = qp2bits(rce, rce->new_qscale) + rce->mv_bits + rce->misc_bits;\n            bits += 8 * ff_vbv_update(s, bits);\n\n            rce->expected_bits = expected_bits;\n            expected_bits     += bits;\n        }\n\n        av_dlog(s->avctx,\n                \"expected_bits: %f all_available_bits: %d rate_factor: %f\\n\",\n                expected_bits, (int)all_available_bits, rate_factor);\n        if (expected_bits > all_available_bits) {\n            rate_factor -= step;\n            ++toobig;\n        }\n    }\n    av_free(qscale);\n    av_free(blurred_qscale);\n\n    /* check bitrate calculations and print info */\n    qscale_sum = 0.0;\n    for (i = 0; i < rcc->num_entries; i++) {\n        av_dlog(s, \"[lavc rc] entry[%d].new_qscale = %.3f  qp = %.3f\\n\",\n                i,\n                rcc->entry[i].new_qscale,\n                rcc->entry[i].new_qscale / FF_QP2LAMBDA);\n        qscale_sum += av_clip(rcc->entry[i].new_qscale / FF_QP2LAMBDA,\n                              s->avctx->qmin, s->avctx->qmax);\n    }\n    assert(toobig <= 40);\n    av_log(s->avctx, AV_LOG_DEBUG,\n           \"[lavc rc] requested bitrate: %d bps  expected bitrate: %d bps\\n\",\n           s->bit_rate,\n           (int)(expected_bits / ((double)all_available_bits / s->bit_rate)));\n    av_log(s->avctx, AV_LOG_DEBUG,\n           \"[lavc rc] estimated target average qp: %.3f\\n\",\n           (float)qscale_sum / rcc->num_entries);\n    if (toobig == 0) {\n        av_log(s->avctx, AV_LOG_INFO,\n               \"[lavc rc] Using all of requested bitrate is not \"\n               \"necessary for this video with these parameters.\\n\");\n    } else if (toobig == 40) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"[lavc rc] Error: bitrate too low for this video \"\n               \"with these parameters.\\n\");\n        return -1;\n    } else if (fabs(expected_bits / all_available_bits - 1.0) > 0.01) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"[lavc rc] Error: 2pass curve failed to converge\\n\");\n        return -1;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5270, "func": "static void apply_unsharp(      uint8_t *dst, int dst_stride,\n                          const uint8_t *src, int src_stride,\n                          int width, int height, FilterParam *fp)\n{\n    uint32_t **sc = fp->sc;\n    uint32_t sr[(MAX_SIZE * MAX_SIZE) - 1], tmp1, tmp2;\n\n    int32_t res;\n    int x, y, z;\n    const uint8_t *src2 = NULL;  //silence a warning\n\n    if (!fp->amount) {\n        if (dst_stride == src_stride)\n            memcpy(dst, src, src_stride * height);\n        else\n            for (y = 0; y < height; y++, dst += dst_stride, src += src_stride)\n                memcpy(dst, src, width);\n        return;\n    }\n\n    for (y = 0; y < 2 * fp->steps_y; y++)\n        memset(sc[y], 0, sizeof(sc[y][0]) * (width + 2 * fp->steps_x));\n\n    for (y = -fp->steps_y; y < height + fp->steps_y; y++) {\n        if (y < height)\n            src2 = src;\n\n        memset(sr, 0, sizeof(sr[0]) * (2 * fp->steps_x - 1));\n        for (x = -fp->steps_x; x < width + fp->steps_x; x++) {\n            tmp1 = x <= 0 ? src2[0] : x >= width ? src2[width-1] : src2[x];\n            for (z = 0; z < fp->steps_x * 2; z += 2) {\n                tmp2 = sr[z + 0] + tmp1; sr[z + 0] = tmp1;\n                tmp1 = sr[z + 1] + tmp2; sr[z + 1] = tmp2;\n            }\n            for (z = 0; z < fp->steps_y * 2; z += 2) {\n                tmp2 = sc[z + 0][x + fp->steps_x] + tmp1; sc[z + 0][x + fp->steps_x] = tmp1;\n                tmp1 = sc[z + 1][x + fp->steps_x] + tmp2; sc[z + 1][x + fp->steps_x] = tmp2;\n            }\n            if (x >= fp->steps_x && y >= fp->steps_y) {\n                const uint8_t *srx = src - fp->steps_y * src_stride + x - fp->steps_x;\n                uint8_t       *dsx = dst - fp->steps_y * dst_stride + x - fp->steps_x;\n\n                res = (int32_t)*srx + ((((int32_t) * srx - (int32_t)((tmp1 + fp->halfscale) >> fp->scalebits)) * fp->amount) >> 16);\n                *dsx = av_clip_uint8(res);\n            }\n        }\n        if (y >= 0) {\n            dst += dst_stride;\n            src += src_stride;\n        }\n    }\n}", "target": 0}
{"idx": 5271, "func": "void\nngx_close_connection(ngx_connection_t *c)\n{\n    ngx_err_t     err;\n    ngx_uint_t    log_error, level;\n    ngx_socket_t  fd;\n\n    if (c->fd == -1) {\n        ngx_log_error(NGX_LOG_ALERT, c->log, 0, \"connection already closed\");\n        return;\n    }\n\n    if (c->read->timer_set) {\n        ngx_del_timer(c->read);\n    }\n\n    if (c->write->timer_set) {\n        ngx_del_timer(c->write);\n    }\n\n    if (ngx_del_conn) {\n        ngx_del_conn(c, NGX_CLOSE_EVENT);\n\n    } else {\n        if (c->read->active || c->read->disabled) {\n            ngx_del_event(c->read, NGX_READ_EVENT, NGX_CLOSE_EVENT);\n        }\n\n        if (c->write->active || c->write->disabled) {\n            ngx_del_event(c->write, NGX_WRITE_EVENT, NGX_CLOSE_EVENT);\n        }\n    }\n\n#if (NGX_THREADS)\n\n    /*\n     * we have to clean the connection information before the closing\n     * because another thread may reopen the same file descriptor\n     * before we clean the connection\n     */\n\n    ngx_mutex_lock(ngx_posted_events_mutex);\n\n    if (c->read->prev) {\n        ngx_delete_posted_event(c->read);\n    }\n\n    if (c->write->prev) {\n        ngx_delete_posted_event(c->write);\n    }\n\n    c->read->closed = 1;\n    c->write->closed = 1;\n\n    if (c->single_connection) {\n        ngx_unlock(&c->lock);\n        c->read->locked = 0;\n        c->write->locked = 0;\n    }\n\n    ngx_mutex_unlock(ngx_posted_events_mutex);\n\n#else\n\n    if (c->read->prev) {\n        ngx_delete_posted_event(c->read);\n    }\n\n    if (c->write->prev) {\n        ngx_delete_posted_event(c->write);\n    }\n\n    c->read->closed = 1;\n    c->write->closed = 1;\n\n#endif\n\n    ngx_reusable_connection(c, 0);\n\n    log_error = c->log_error;\n\n    ngx_free_connection(c);\n\n    fd = c->fd;\n    c->fd = (ngx_socket_t) -1;\n\n    if (ngx_close_socket(fd) == -1) {\n\n        err = ngx_socket_errno;\n\n        if (err == NGX_ECONNRESET || err == NGX_ENOTCONN) {\n\n            switch (log_error) {\n\n            case NGX_ERROR_INFO:\n                level = NGX_LOG_INFO;\n                break;\n\n            case NGX_ERROR_ERR:\n                level = NGX_LOG_ERR;\n                break;\n\n            default:\n                level = NGX_LOG_CRIT;\n            }\n\n        } else {\n            level = NGX_LOG_CRIT;\n        }\n\n        /* we use ngx_cycle->log because c->log was in c->pool */\n\n        ngx_log_error(level, ngx_cycle->log, err,\n                      ngx_close_socket_n \" %d failed\", fd);\n    }\n}", "target": 1}
{"idx": 5272, "func": "static ossl_inline int compute_growth(int target, int current)\n{\n    const int limit = (max_nodes / 3) * 2 + (max_nodes % 3 ? 1 : 0);\n\n    while (current < target) {\n        /* Check to see if we're at the hard limit */\n        if (current >= max_nodes)\n            return 0;\n\n        /* Expand the size by a factor of 3/2 if it is within range */\n        current = current < limit ? current + current / 2 : max_nodes;\n    }\n    return current;\n}", "target": 0}
{"idx": 5273, "func": "static void encode_exponents_blk_ch(uint8_t *exp,\n                                    int nb_exps, int exp_strategy,\n                                    uint8_t *num_exp_groups)\n{\n    int group_size, nb_groups, i, j, k, exp_min;\n\n    group_size = exp_strategy + (exp_strategy == EXP_D45);\n    *num_exp_groups = (nb_exps + (group_size * 3) - 4) / (3 * group_size);\n    nb_groups = *num_exp_groups * 3;\n\n    /* for each group, compute the minimum exponent */\n    if (exp_strategy > EXP_D15) {\n    k = 1;\n    for (i = 1; i <= nb_groups; i++) {\n        exp_min = exp[k];\n        assert(exp_min >= 0 && exp_min <= 24);\n        for (j = 1; j < group_size; j++) {\n            if (exp[k+j] < exp_min)\n                exp_min = exp[k+j];\n        }\n        exp[i] = exp_min;\n        k += group_size;\n    }\n    }\n\n    /* constraint for DC exponent */\n    if (exp[0] > 15)\n        exp[0] = 15;\n\n    /* decrease the delta between each groups to within 2 so that they can be\n       differentially encoded */\n    for (i = 1; i <= nb_groups; i++)\n        exp[i] = FFMIN(exp[i], exp[i-1] + 2);\n    for (i = nb_groups-1; i >= 0; i--)\n        exp[i] = FFMIN(exp[i], exp[i+1] + 2);\n\n    /* now we have the exponent values the decoder will see */\n    if (exp_strategy > EXP_D15) {\n    k = nb_groups * group_size;\n    for (i = nb_groups; i > 0; i--) {\n        for (j = 0; j < group_size; j++)\n            exp[k-j] = exp[i];\n        k -= group_size;\n    }\n    }\n}", "target": 1}
{"idx": 5274, "func": "static inline double bits2qp(RateControlEntry *rce, double bits)\n{\n    if (bits < 0.9) {\n        av_log(NULL, AV_LOG_ERROR, \"bits<0.9\\n\");\n    }\n    return rce->qscale * (double)(rce->i_tex_bits + rce->p_tex_bits + 1) / bits;\n}", "target": 0}
{"idx": 5275, "func": "static int test_int_lhash(void)\n{\n    static struct {\n        int data;\n        int null;\n    } dels[] = {\n        { 65537,    0 },\n        { 173,      0 },\n        { 999,      1 },\n        { 37,       0 },\n        { 1,        0 },\n        { 34,       1 }\n    };\n    const unsigned int n_dels = OSSL_NELEM(dels);\n    LHASH_OF(int) *h = lh_int_new(&int_hash, &int_cmp);\n    unsigned int i;\n    int testresult = 0, j, *p;\n\n    if (!TEST_ptr(h))\n        goto end;\n\n    /* insert */\n    for (i = 0; i < n_int_tests; i++)\n        if (!TEST_ptr_null(lh_int_insert(h, int_tests + i))) {\n            TEST_info(\"int insert %d\", i);\n            goto end;\n        }\n\n    /* num_items */\n    if (!TEST_int_eq(lh_int_num_items(h), n_int_tests))\n        goto end;\n\n    /* retrieve */\n    for (i = 0; i < n_int_tests; i++)\n        if (!TEST_int_eq(*lh_int_retrieve(h, int_tests + i), int_tests[i])) {\n            TEST_info(\"lhash int retrieve value %d\", i);\n            goto end;\n        }\n    for (i = 0; i < n_int_tests; i++)\n        if (!TEST_ptr_eq(lh_int_retrieve(h, int_tests + i), int_tests + i)) {\n            TEST_info(\"lhash int retrieve address %d\", i);\n            goto end;\n        }\n    j = 1;\n    if (!TEST_ptr_eq(lh_int_retrieve(h, &j), int_tests + 2))\n        goto end;\n\n    /* replace */\n    j = 13;\n    if (!TEST_ptr(p = lh_int_insert(h, &j)))\n        goto end;\n    if (!TEST_ptr_eq(p, int_tests + 1))\n        goto end;\n    if (!TEST_ptr_eq(lh_int_retrieve(h, int_tests + 1), &j))\n        goto end;\n\n    /* do_all */\n    memset(int_found, 0, sizeof(int_found));\n    lh_int_doall(h, &int_doall);\n    for (i = 0; i < n_int_tests; i++)\n        if (!TEST_int_eq(int_found[i], 1)) {\n            TEST_info(\"lhash int doall %d\", i);\n            goto end;\n        }\n\n    /* do_all_arg */\n    memset(int_found, 0, sizeof(int_found));\n    lh_int_doall_short(h, int_doall_arg, int_found);\n    for (i = 0; i < n_int_tests; i++)\n        if (!TEST_int_eq(int_found[i], 1)) {\n            TEST_info(\"lhash int doall arg %d\", i);\n            goto end;\n        }\n\n    /* delete */\n    for (i = 0; i < n_dels; i++) {\n        const int b = lh_int_delete(h, &dels[i].data) == NULL;\n        if (!TEST_int_eq(b ^ dels[i].null,  0)) {\n            TEST_info(\"lhash int delete %d\", i);\n            goto end;\n        }\n    }\n\n    /* error */\n    if (!TEST_int_eq(lh_int_error(h), 0))\n        goto end;\n\n    testresult = 1;\nend:\n    lh_int_free(h);\n    return testresult;\n}", "target": 1}
{"idx": 5276, "func": "static int gif_read_packet(AVFormatContext * s1,\n                           AVPacket * pkt)\n{\n    GifState *s = s1->priv_data;\n    int ret;\n\n    ret = gif_parse_next_image(s);\n    if (ret < 0)\n        return ret;\n\n    /* XXX: avoid copying */\n    if (av_new_packet(pkt, s->screen_width * s->screen_height * 3)) {\n        return AVERROR(EIO);\n    }\n    pkt->stream_index = 0;\n    memcpy(pkt->data, s->image_buf, s->screen_width * s->screen_height * 3);\n    return 0;\n}", "target": 1}
{"idx": 5277, "func": "static int decode_nal_units(HEVCContext *s, const uint8_t *buf, int length)\n{\n    int i, ret = 0;\n\n    s->ref = NULL;\n    s->last_eos = s->eos;\n    s->eos = 0;\n\n    /* split the input packet into NAL units, so we know the upper bound on the\n     * number of slices in the frame */\n    ret = ff_h2645_packet_split(&s->pkt, buf, length, s->avctx, s->is_nalff,\n                                s->nal_length_size, s->avctx->codec_id, 1);\n    if (ret < 0) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Error splitting the input into NAL units.\\n\");\n        return ret;\n    }\n\n    for (i = 0; i < s->pkt.nb_nals; i++) {\n        if (s->pkt.nals[i].type == NAL_EOB_NUT ||\n            s->pkt.nals[i].type == NAL_EOS_NUT)\n            s->eos = 1;\n    }\n\n    /* decode the NAL units */\n    for (i = 0; i < s->pkt.nb_nals; i++) {\n        ret = decode_nal_unit(s, &s->pkt.nals[i]);\n        if (ret < 0) {\n            av_log(s->avctx, AV_LOG_WARNING,\n                   \"Error parsing NAL unit #%d.\\n\", i);\n            goto fail;\n        }\n    }\n\nfail:\n    if (s->ref && s->threads_type == FF_THREAD_FRAME)\n        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);\n\n    return ret;\n}", "target": 0}
{"idx": 5278, "func": "static void list_type(FUNC_TYPE ft, int one)\n{\n    FUNCTION *fp;\n    int i = 0;\n    DISPLAY_COLUMNS dc;\n\n    if (!one)\n        calculate_columns(&dc);\n\n    for (fp = functions; fp->name != NULL; fp++) {\n        if (fp->type != ft)\n            continue;\n        if (one) {\n            BIO_printf(bio_out, \"%s\\n\", fp->name);\n        } else {\n            if (i % dc.columns == 0 && i > 0)\n                BIO_printf(bio_out, \"\\n\");\n            BIO_printf(bio_out, \"%-*s\", dc.width, fp->name);\n            i++;\n        }\n    }\n    if (!one)\n        BIO_printf(bio_out, \"\\n\\n\");\n}", "target": 1}
{"idx": 5279, "func": "ssize_t\nngx_write_chain_to_file(ngx_file_t *file, ngx_chain_t *cl, off_t offset,\n    ngx_pool_t *pool)\n{\n    u_char        *prev;\n    size_t         size;\n    ssize_t        total, n;\n    ngx_array_t    vec;\n    struct iovec  *iov, iovs[NGX_IOVS];\n\n    /* use pwrite() if there is the only buf in a chain */\n\n    if (cl->next == NULL) {\n        return ngx_write_file(file, cl->buf->pos,\n                              (size_t) (cl->buf->last - cl->buf->pos),\n                              offset);\n    }\n\n    total = 0;\n\n    vec.elts = iovs;\n    vec.size = sizeof(struct iovec);\n    vec.nalloc = NGX_IOVS;\n    vec.pool = pool;\n\n    do {\n        prev = NULL;\n        iov = NULL;\n        size = 0;\n\n        vec.nelts = 0;\n\n        /* create the iovec and coalesce the neighbouring bufs */\n\n        while (cl && vec.nelts < IOV_MAX) {\n            if (prev == cl->buf->pos) {\n                iov->iov_len += cl->buf->last - cl->buf->pos;\n\n            } else {\n                iov = ngx_array_push(&vec);\n                if (iov == NULL) {\n                    return NGX_ERROR;\n                }\n\n                iov->iov_base = (void *) cl->buf->pos;\n                iov->iov_len = cl->buf->last - cl->buf->pos;\n            }\n\n            size += cl->buf->last - cl->buf->pos;\n            prev = cl->buf->last;\n            cl = cl->next;\n        }\n\n        /* use pwrite() if there is the only iovec buffer */\n\n        if (vec.nelts == 1) {\n            iov = vec.elts;\n\n            n = ngx_write_file(file, (u_char *) iov[0].iov_base,\n                               iov[0].iov_len, offset);\n\n            if (n == NGX_ERROR) {\n                return n;\n            }\n\n            return total + n;\n        }\n\n        n = ngx_writev_file(file, &vec, size, offset);\n\n        if (n == NGX_ERROR) {\n            return n;\n        }\n\n        offset += n;\n        total += n;\n\n    } while (cl);\n\n    return total;\n}", "target": 1}
{"idx": 5280, "func": "static void test_fail_memory_message(const char *prefix, const char *file,\n                                     int line, const char *type,\n                                     const char *left, const char *right,\n                                     const char *op,\n                                     const unsigned char *m1, size_t l1,\n                                     const unsigned char *m2, size_t l2)\n{\n    const int indent = subtest_level();\n    const size_t bytes = (MAX_STRING_WIDTH - 9) / 17 * 8;\n    char b1[MAX_STRING_WIDTH + 1], b2[MAX_STRING_WIDTH + 1];\n    char *p, bdiff[MAX_STRING_WIDTH + 1];\n    size_t n1, n2, i;\n    unsigned int cnt = 0, diff;\n\n    test_fail_message_prefix(prefix, file, line, type, left, right, op);\n    if (m1 == NULL)\n        l1 = 0;\n    if (m2 == NULL)\n        l2 = 0;\n    if (l1 == 0 && l2 == 0) {\n        if ((m1 == NULL) == (m2 == NULL)) {\n            test_memory_null_empty(m1, indent, ' ');\n        } else {\n            test_diff_header(left, right);\n            test_memory_null_empty(m1, indent, '-');\n            test_memory_null_empty(m2, indent, '+');\n        }\n        goto fin;\n    }\n\n    if (l1 != l2 || memcmp(m1, m2, l1) != 0)\n        test_diff_header(left, right);\n\n    while (l1 > 0 || l2 > 0) {\n        n1 = n2 = 0;\n        if (l1 > 0) {\n            n1 = l1 > bytes ? bytes : l1;\n            hex_convert_memory(m1, n1, b1, 8);\n        }\n        if (l2 > 0) {\n            n2 = l2 > bytes ? bytes : l2;\n            hex_convert_memory(m2, n2, b2, 8);\n        }\n\n        diff = 0;\n        i = 0;\n        p = bdiff;\n        if (n1 > 0 && n2 > 0) {\n            const size_t j = n1 < n2 ? n1 : n2;\n\n            for (; i < j; i++) {\n                if (m1[i] == m2[i]) {\n                    *p++ = ' ';\n                    *p++ = ' ';\n                } else {\n                    *p++ = '^';\n                    *p++ = '^';\n                    diff = 1;\n                }\n                if (i % 8 == 7 && i != j - 1)\n                    *p++ = ' ';\n            }\n            *p++ = '\\0';\n        }\n\n        if (n1 == n2 && !diff) {\n            test_printf_stderr(\"%*s# %04x: %s\\n\", indent, \"\", cnt, b1);\n        } else {\n            if (cnt == 0 && (m1 == NULL || l1 == 0))\n                test_memory_null_empty(m1, indent, '-');\n            else if (n1 > 0)\n                test_printf_stderr(\"%*s# %04x:-%s\\n\", indent, \"\", cnt, b1);\n            if (cnt == 0 && (m2 == NULL || l2 == 0))\n                test_memory_null_empty(m2, indent, '+');\n            else if (n2 > 0)\n                test_printf_stderr(\"%*s# %04x:+%s\\n\", indent, \"\", cnt, b2);\n            if (diff && i > 0)\n                test_printf_stderr(\"%*s# % 4s  %s\\n\", indent, \"\", \"\", bdiff);\n        }\n        m1 += n1;\n        m2 += n2;\n        l1 -= n1;\n        l2 -= n2;\n        cnt += bytes;\n    }\nfin:\n    test_printf_stderr(\"\\n\");\n    test_flush_stderr();\n}", "target": 1}
{"idx": 5281, "func": "static int add_candidate_ref(HEVCContext *s, RefPicList *list,\n                             int poc, int ref_flag)\n{\n    HEVCFrame *ref = find_ref_idx(s, poc);\n\n    if (ref == s->ref || list->nb_refs >= HEVC_MAX_REFS)\n        return AVERROR_INVALIDDATA;\n\n    if (!ref) {\n        ref = generate_missing_ref(s, poc);\n        if (!ref)\n            return AVERROR(ENOMEM);\n    }\n\n    list->list[list->nb_refs] = ref->poc;\n    list->ref[list->nb_refs]  = ref;\n    list->nb_refs++;\n\n    mark_ref(ref, ref_flag);\n    return 0;\n}", "target": 0}
{"idx": 5282, "func": "enum AVCodecID ff_fmt_v4l2codec(uint32_t v4l2_fmt)\n{\n    int i;\n\n    for (i = 0; ff_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {\n        if (ff_fmt_conversion_table[i].v4l2_fmt == v4l2_fmt) {\n            return ff_fmt_conversion_table[i].codec_id;\n        }\n    }\n\n    return AV_CODEC_ID_NONE;\n}", "target": 0}
{"idx": 5283, "func": "static int open_input_stream(HTTPContext *c, const char *info)\n{\n    char buf[128];\n    char input_filename[1024];\n    AVFormatContext *s;\n    int buf_size, i, ret;\n    int64_t stream_pos;\n\n    /* find file name */\n    if (c->stream->feed) {\n        strcpy(input_filename, c->stream->feed->feed_filename);\n        buf_size = FFM_PACKET_SIZE;\n        /* compute position (absolute time) */\n        if (find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            stream_pos = parse_date(buf, 0);\n            if (stream_pos == INT64_MIN)\n                return -1;\n        } else if (find_info_tag(buf, sizeof(buf), \"buffer\", info)) {\n            int prebuffer = strtol(buf, 0, 10);\n            stream_pos = av_gettime() - prebuffer * (int64_t)1000000;\n        } else\n            stream_pos = av_gettime() - c->stream->prebuffer * (int64_t)1000;\n    } else {\n        strcpy(input_filename, c->stream->feed_filename);\n        buf_size = 0;\n        /* compute position (relative time) */\n        if (find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            stream_pos = parse_date(buf, 1);\n            if (stream_pos == INT64_MIN)\n                return -1;\n        } else\n            stream_pos = 0;\n    }\n    if (input_filename[0] == '\\0')\n        return -1;\n\n#if 0\n    { time_t when = stream_pos / 1000000;\n    http_log(\"Stream pos = %\"PRId64\", time=%s\", stream_pos, ctime(&when));\n    }\n#endif\n\n    /* open stream */\n    if ((ret = av_open_input_file(&s, input_filename, c->stream->ifmt,\n                                  buf_size, c->stream->ap_in)) < 0) {\n        http_log(\"could not open %s: %d\\n\", input_filename, ret);\n        return -1;\n    }\n    s->flags |= AVFMT_FLAG_GENPTS;\n    c->fmt_in = s;\n    if (av_find_stream_info(c->fmt_in) < 0) {\n        http_log(\"Could not find stream info '%s'\\n\", input_filename);\n        av_close_input_file(s);\n        return -1;\n    }\n\n    /* open each parser */\n    for(i=0;i<s->nb_streams;i++)\n        open_parser(s, i);\n\n    /* choose stream as clock source (we favorize video stream if\n       present) for packet sending */\n    c->pts_stream_index = 0;\n    for(i=0;i<c->stream->nb_streams;i++) {\n        if (c->pts_stream_index == 0 &&\n            c->stream->streams[i]->codec->codec_type == CODEC_TYPE_VIDEO) {\n            c->pts_stream_index = i;\n        }\n    }\n\n#if 1\n    if (c->fmt_in->iformat->read_seek)\n        av_seek_frame(c->fmt_in, -1, stream_pos, 0);\n#endif\n    /* set the start time (needed for maxtime and RTP packet timing) */\n    c->start_time = cur_time;\n    c->first_pts = AV_NOPTS_VALUE;\n    return 0;\n}", "target": 0}
{"idx": 5284, "func": "static int query_formats(AVFilterGraph *graph, AVClass *log_ctx)\n{\n    int i, j, ret;\n    int scaler_count = 0, resampler_count = 0;\n\n    for (j = 0; j < 2; j++) {\n    /* ask all the sub-filters for their supported media formats */\n    for (i = 0; i < graph->nb_filters; i++) {\n        /* Call query_formats on sources first.\n           This is a temporary workaround for amerge,\n           until format renegociation is implemented. */\n        if (!graph->filters[i]->nb_inputs == j)\n            continue;\n        if (graph->filters[i]->filter->query_formats)\n            ret = filter_query_formats(graph->filters[i]);\n        else\n            ret = ff_default_query_formats(graph->filters[i]);\n        if (ret < 0)\n            return ret;\n    }\n    }\n\n    /* go through and merge as many format lists as possible */\n    for (i = 0; i < graph->nb_filters; i++) {\n        AVFilterContext *filter = graph->filters[i];\n\n        for (j = 0; j < filter->nb_inputs; j++) {\n            AVFilterLink *link = filter->inputs[j];\n            int convert_needed = 0;\n\n            if (!link)\n                continue;\n\n            if (link->in_formats != link->out_formats &&\n                !ff_merge_formats(link->in_formats, link->out_formats,\n                                  link->type))\n                convert_needed = 1;\n            if (link->type == AVMEDIA_TYPE_AUDIO) {\n                if (link->in_channel_layouts != link->out_channel_layouts &&\n                    !ff_merge_channel_layouts(link->in_channel_layouts,\n                                              link->out_channel_layouts))\n                    convert_needed = 1;\n                if (link->in_samplerates != link->out_samplerates &&\n                    !ff_merge_samplerates(link->in_samplerates,\n                                          link->out_samplerates))\n                    convert_needed = 1;\n            }\n\n            if (convert_needed) {\n                AVFilterContext *convert;\n                AVFilter *filter;\n                AVFilterLink *inlink, *outlink;\n                char scale_args[256];\n                char inst_name[30];\n\n                /* couldn't merge format lists. auto-insert conversion filter */\n                switch (link->type) {\n                case AVMEDIA_TYPE_VIDEO:\n                    if (!(filter = avfilter_get_by_name(\"scale\"))) {\n                        av_log(log_ctx, AV_LOG_ERROR, \"'scale' filter \"\n                               \"not present, cannot convert pixel formats.\\n\");\n                        return AVERROR(EINVAL);\n                    }\n\n                    snprintf(inst_name, sizeof(inst_name), \"auto-inserted scaler %d\",\n                             scaler_count++);\n                    if (graph->scale_sws_opts)\n                        snprintf(scale_args, sizeof(scale_args), \"0:0:%s\", graph->scale_sws_opts);\n                    else\n                        snprintf(scale_args, sizeof(scale_args), \"0:0\");\n\n                    if ((ret = avfilter_graph_create_filter(&convert, filter,\n                                                            inst_name, scale_args, NULL,\n                                                            graph)) < 0)\n                        return ret;\n                    break;\n                case AVMEDIA_TYPE_AUDIO:\n                    if (!(filter = avfilter_get_by_name(\"aresample\"))) {\n                        av_log(log_ctx, AV_LOG_ERROR, \"'aresample' filter \"\n                               \"not present, cannot convert audio formats.\\n\");\n                        return AVERROR(EINVAL);\n                    }\n\n                    snprintf(inst_name, sizeof(inst_name), \"auto-inserted resampler %d\",\n                             resampler_count++);\n                    scale_args[0] = '\\0';\n                    if (graph->aresample_swr_opts)\n                        snprintf(scale_args, sizeof(scale_args), \"%s\",\n                                 graph->aresample_swr_opts);\n                    if ((ret = avfilter_graph_create_filter(&convert, filter,\n                                                            inst_name, graph->aresample_swr_opts,\n                                                            NULL, graph)) < 0)\n                        return ret;\n                    break;\n                default:\n                    return AVERROR(EINVAL);\n                }\n\n                if ((ret = avfilter_insert_filter(link, convert, 0, 0)) < 0)\n                    return ret;\n\n                filter_query_formats(convert);\n                inlink  = convert->inputs[0];\n                outlink = convert->outputs[0];\n                if (!ff_merge_formats( inlink->in_formats,  inlink->out_formats,  inlink->type) ||\n                    !ff_merge_formats(outlink->in_formats, outlink->out_formats, outlink->type))\n                    ret |= AVERROR(ENOSYS);\n                if (inlink->type == AVMEDIA_TYPE_AUDIO &&\n                    (!ff_merge_samplerates(inlink->in_samplerates,\n                                           inlink->out_samplerates) ||\n                     !ff_merge_channel_layouts(inlink->in_channel_layouts,\n                                               inlink->out_channel_layouts)))\n                    ret |= AVERROR(ENOSYS);\n                if (outlink->type == AVMEDIA_TYPE_AUDIO &&\n                    (!ff_merge_samplerates(outlink->in_samplerates,\n                                           outlink->out_samplerates) ||\n                     !ff_merge_channel_layouts(outlink->in_channel_layouts,\n                                               outlink->out_channel_layouts)))\n                    ret |= AVERROR(ENOSYS);\n\n                if (ret < 0) {\n                    av_log(log_ctx, AV_LOG_ERROR,\n                           \"Impossible to convert between the formats supported by the filter \"\n                           \"'%s' and the filter '%s'\\n\", link->src->name, link->dst->name);\n                    return ret;\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5285, "func": "static int parse_tonal(DCALbrDecoder *s, int group)\n{\n    unsigned int amp[DCA_LBR_CHANNELS_TOTAL];\n    unsigned int phs[DCA_LBR_CHANNELS_TOTAL];\n    unsigned int diff, main_amp, shift;\n    int sf, sf_idx, ch, main_ch, freq;\n    int ch_nbits = av_ceil_log2(s->nchannels_total);\n\n    // Parse subframes for this group\n    for (sf = 0; sf < 1 << group; sf += diff ? 8 : 1) {\n        sf_idx = ((s->framenum << group) + sf) & 31;\n        s->tonal_bounds[group][sf_idx][0] = s->ntones;\n\n        // Parse tones for this subframe\n        for (freq = 1;; freq++) {\n            if (get_bits_left(&s->gb) < 1) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Tonal group chunk too short\\n\");\n                return -1;\n            }\n\n            diff = parse_vlc(&s->gb, &ff_dca_vlc_tnl_grp[group], 2);\n            if (diff >= FF_ARRAY_ELEMS(ff_dca_fst_amp)) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Invalid tonal frequency diff\\n\");\n                return -1;\n            }\n\n            diff = get_bitsz(&s->gb, diff >> 2) + ff_dca_fst_amp[diff];\n            if (diff <= 1)\n                break;  // End of subframe\n\n            freq += diff - 2;\n            if (freq >> (5 - group) > s->nsubbands * 4 - 5) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Invalid spectral line offset\\n\");\n                return -1;\n            }\n\n            // Main channel\n            main_ch = get_bitsz(&s->gb, ch_nbits);\n            main_amp = parse_vlc(&s->gb, &ff_dca_vlc_tnl_scf, 2)\n                + s->tonal_scf[ff_dca_freq_to_sb[freq >> (7 - group)]]\n                + s->limited_range - 2;\n            amp[main_ch] = main_amp < AMP_MAX ? main_amp : 0;\n            phs[main_ch] = get_bits(&s->gb, 3);\n\n            // Secondary channels\n            for (ch = 0; ch < s->nchannels_total; ch++) {\n                if (ch == main_ch)\n                    continue;\n                if (get_bits1(&s->gb)) {\n                    amp[ch] = amp[main_ch] - parse_vlc(&s->gb, &ff_dca_vlc_damp, 1);\n                    phs[ch] = phs[main_ch] - parse_vlc(&s->gb, &ff_dca_vlc_dph,  1);\n                } else {\n                    amp[ch] = 0;\n                    phs[ch] = 0;\n                }\n            }\n\n            if (amp[main_ch]) {\n                // Allocate new tone\n                DCALbrTone *t = &s->tones[s->ntones];\n                s->ntones = (s->ntones + 1) & (DCA_LBR_TONES - 1);\n\n                t->x_freq = freq >> (5 - group);\n                t->f_delt = (freq & ((1 << (5 - group)) - 1)) << group;\n                t->ph_rot = 256 - (t->x_freq & 1) * 128 - t->f_delt * 4;\n\n                shift = ff_dca_ph0_shift[(t->x_freq & 3) * 2 + (freq & 1)]\n                    - ((t->ph_rot << (5 - group)) - t->ph_rot);\n\n                for (ch = 0; ch < s->nchannels; ch++) {\n                    t->amp[ch] = amp[ch] < AMP_MAX ? amp[ch] : 0;\n                    t->phs[ch] = 128 - phs[ch] * 32 + shift;\n                }\n            }\n        }\n\n        s->tonal_bounds[group][sf_idx][1] = s->ntones;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5286, "func": "AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key,\n                               const AVDictionaryEntry *prev, int flags)\n{\n    unsigned int i, j;\n\n    if (!m)\n        return NULL;\n\n    if (prev)\n        i = prev - m->elems + 1;\n    else\n        i = 0;\n\n    for (; i < m->count; i++) {\n        const char *s = m->elems[i].key;\n        if (flags & AV_DICT_MATCH_CASE)\n            for (j = 0; s[j] == key[j] && key[j]; j++)\n                ;\n        else\n            for (j = 0; av_toupper(s[j]) == av_toupper(key[j]) && key[j]; j++)\n                ;\n        if (key[j])\n            continue;\n        if (s[j] && !(flags & AV_DICT_IGNORE_SUFFIX))\n            continue;\n        return &m->elems[i];\n    }\n    return NULL;\n}", "target": 1}
{"idx": 5287, "func": "static int rv30_decode_mb_info(RV34DecContext *r)\n{\n    static const int rv30_p_types[6] = { RV34_MB_SKIP, RV34_MB_P_16x16, RV34_MB_P_8x8, -1, RV34_MB_TYPE_INTRA, RV34_MB_TYPE_INTRA16x16 };\n    static const int rv30_b_types[6] = { RV34_MB_SKIP, RV34_MB_B_DIRECT, RV34_MB_B_FORWARD, RV34_MB_B_BACKWARD, RV34_MB_TYPE_INTRA, RV34_MB_TYPE_INTRA16x16 };\n    MpegEncContext *s = &r->s;\n    GetBitContext *gb = &s->gb;\n    int code = svq3_get_ue_golomb(gb);\n\n    if(code > 11){\n        av_log(s->avctx, AV_LOG_ERROR, \"Incorrect MB type code\\n\");\n        return -1;\n    }\n    if(code > 5){\n        av_log(s->avctx, AV_LOG_ERROR, \"dquant needed\\n\");\n        code -= 6;\n    }\n    if(s->pict_type != AV_PICTURE_TYPE_B)\n        return rv30_p_types[code];\n    else\n        return rv30_b_types[code];\n}", "target": 1}
{"idx": 5288, "func": "static void encode_cblk(Jpeg2000EncoderContext *s, Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk, Jpeg2000Tile *tile,\n                        int width, int height, int bandpos, int lev)\n{\n    int pass_t = 2, passno, x, y, max=0, nmsedec, bpno;\n    int64_t wmsedec = 0;\n\n    memset(t1->flags, 0, t1->stride * (height + 2) * sizeof(*t1->flags));\n\n    for (y = 0; y < height; y++){\n        for (x = 0; x < width; x++){\n            if (t1->data[(y) * t1->stride + x] < 0){\n                t1->flags[(y+1) * t1->stride + x+1] |= JPEG2000_T1_SGN;\n                t1->data[(y) * t1->stride + x] = -t1->data[(y) * t1->stride + x];\n            }\n            max = FFMAX(max, t1->data[(y) * t1->stride + x]);\n        }\n    }\n\n    if (max == 0){\n        cblk->nonzerobits = 0;\n        bpno = 0;\n    } else{\n        cblk->nonzerobits = av_log2(max) + 1 - NMSEDEC_FRACBITS;\n        bpno = cblk->nonzerobits - 1;\n    }\n\n    cblk->data[0] = 0;\n    ff_mqc_initenc(&t1->mqc, cblk->data + 1);\n\n    for (passno = 0; bpno >= 0; passno++){\n        nmsedec=0;\n\n        switch(pass_t){\n            case 0: encode_sigpass(t1, width, height, bandpos, &nmsedec, bpno);\n                    break;\n            case 1: encode_refpass(t1, width, height, &nmsedec, bpno);\n                    break;\n            case 2: encode_clnpass(t1, width, height, bandpos, &nmsedec, bpno);\n                    break;\n        }\n\n        cblk->passes[passno].rate = ff_mqc_flush_to(&t1->mqc, cblk->passes[passno].flushed, &cblk->passes[passno].flushed_len);\n        wmsedec += (int64_t)nmsedec << (2*bpno);\n        cblk->passes[passno].disto = wmsedec;\n\n        if (++pass_t == 3){\n            pass_t = 0;\n            bpno--;\n        }\n    }\n    cblk->npasses = passno;\n    cblk->ninclpasses = passno;\n\n    cblk->passes[passno-1].rate = ff_mqc_flush_to(&t1->mqc, cblk->passes[passno-1].flushed, &cblk->passes[passno-1].flushed_len);\n}", "target": 0}
{"idx": 5289, "func": "static int pkey_gost01cp_keygen (EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\n\t{\n\tstruct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(ctx);\n\tEC_KEY *ec=NULL;\n\tif (data->sign_param_nid == NID_undef)\n\t\t{\n\t\t\tGOSTerr(GOST_F_PKEY_GOST01_KEYGEN,\n\t\t\t\tGOST_R_NO_PARAMETERS_SET);\n\t\t\treturn 0;\n\t\t}\n\tec = EC_KEY_new();\n\tif (!fill_GOST2001_params(ec,data->sign_param_nid))\n\t\t{\n\t\tEC_KEY_free(ec);\n\t\treturn 0;\n\t\t}\n\tgost2001_keygen(ec);\n\n\tEVP_PKEY_assign(pkey,NID_id_GostR3410_2001,ec);\n\treturn 1;\n\t}", "target": 0}
{"idx": 5290, "func": "static void assert_file_overwrite(const char *filename)\n{\n    if (file_overwrite && no_file_overwrite) {\n        fprintf(stderr, \"Error, both -y and -n supplied. Exiting.\\n\");\n        exit_program(1);\n    }\n\n    if (!file_overwrite) {\n        const char *proto_name = avio_find_protocol_name(filename);\n        if (proto_name && !strcmp(proto_name, \"file\") && avio_check(filename, 0) == 0) {\n            if (stdin_interaction && !no_file_overwrite) {\n                fprintf(stderr,\"File '%s' already exists. Overwrite ? [y/N] \", filename);\n                fflush(stderr);\n                term_exit();\n                signal(SIGINT, SIG_DFL);\n                if (!read_yesno()) {\n                    av_log(NULL, AV_LOG_FATAL, \"Not overwriting - exiting\\n\");\n                    exit_program(1);\n                }\n                term_init();\n            }\n            else {\n                av_log(NULL, AV_LOG_FATAL, \"File '%s' already exists. Exiting.\\n\", filename);\n                exit_program(1);\n            }\n        }\n    }\n}", "target": 0}
{"idx": 5291, "func": "static inline void skip_bits_long(GetBitContext *s, int n){\n#if UNCHECKED_BITSTREAM_READER\n    s->index += n;\n#else\n    s->index += av_clip(n, -s->index, s->size_in_bits_plus8 - s->index);\n#endif\n}", "target": 1}
{"idx": 5292, "func": "static void\ndopr(\n    char *buffer,\n    size_t maxlen,\n    size_t *retlen,\n    const char *format,\n    va_list args)\n{\n    char ch;\n    LLONG value;\n    LDOUBLE fvalue;\n    char *strvalue;\n    int min;\n    int max;\n    int state;\n    int flags;\n    int cflags;\n    size_t currlen;\n\n    state = DP_S_DEFAULT;\n    flags = currlen = cflags = min = 0;\n    max = -1;\n    ch = *format++;\n\n    while (state != DP_S_DONE) {\n        if ((ch == '\\0') || (currlen >= maxlen))\n            state = DP_S_DONE;\n\n        switch (state) {\n        case DP_S_DEFAULT:\n            if (ch == '%')\n                state = DP_S_FLAGS;\n            else\n                dopr_outch(buffer, &currlen, maxlen, ch);\n            ch = *format++;\n            break;\n        case DP_S_FLAGS:\n            switch (ch) {\n            case '-':\n                flags |= DP_F_MINUS;\n                ch = *format++;\n                break;\n            case '+':\n                flags |= DP_F_PLUS;\n                ch = *format++;\n                break;\n            case ' ':\n                flags |= DP_F_SPACE;\n                ch = *format++;\n                break;\n            case '#':\n                flags |= DP_F_NUM;\n                ch = *format++;\n                break;\n            case '0':\n                flags |= DP_F_ZERO;\n                ch = *format++;\n                break;\n            default:\n                state = DP_S_MIN;\n                break;\n            }\n            break;\n        case DP_S_MIN:\n            if (isdigit((unsigned char)ch)) {\n                min = 10 * min + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                min = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_DOT;\n            } else\n                state = DP_S_DOT;\n            break;\n        case DP_S_DOT:\n            if (ch == '.') {\n                state = DP_S_MAX;\n                ch = *format++;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MAX:\n            if (isdigit((unsigned char)ch)) {\n                if (max < 0)\n                    max = 0;\n                max = 10 * max + char_to_int(ch);\n                ch = *format++;\n            } else if (ch == '*') {\n                max = va_arg(args, int);\n                ch = *format++;\n                state = DP_S_MOD;\n            } else\n                state = DP_S_MOD;\n            break;\n        case DP_S_MOD:\n            switch (ch) {\n            case 'h':\n                cflags = DP_C_SHORT;\n                ch = *format++;\n                break;\n            case 'l':\n                if (*format == 'l') {\n                    cflags = DP_C_LLONG;\n                    format++;\n                } else\n                    cflags = DP_C_LONG;\n                ch = *format++;\n                break;\n            case 'q':\n                cflags = DP_C_LLONG;\n                ch = *format++;\n                break;\n            case 'L':\n                cflags = DP_C_LDOUBLE;\n                ch = *format++;\n                break;\n            default:\n                break;\n            }\n            state = DP_S_CONV;\n            break;\n        case DP_S_CONV:\n            switch (ch) {\n            case 'd':\n            case 'i':\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (short int)va_arg(args, int);\n                    break;\n                case DP_C_LONG:\n                    value = va_arg(args, long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, LLONG);\n                    break;\n                default:\n                    value = va_arg(args, int);\n                    break;\n                }\n                fmtint(buffer, &currlen, maxlen, value, 10, min, max, flags);\n                break;\n            case 'X':\n                flags |= DP_F_UP;\n                /* FALLTHROUGH */\n            case 'x':\n            case 'o':\n            case 'u':\n                flags |= DP_F_UNSIGNED;\n                switch (cflags) {\n                case DP_C_SHORT:\n                    value = (unsigned short int)va_arg(args, unsigned int);\n                    break;\n                case DP_C_LONG:\n                    value = (LLONG) va_arg(args,\n                        unsigned long int);\n                    break;\n                case DP_C_LLONG:\n                    value = va_arg(args, unsigned LLONG);\n                    break;\n                default:\n                    value = (LLONG) va_arg(args,\n                        unsigned int);\n                    break;\n                }\n                fmtint(buffer, &currlen, maxlen, value,\n                       ch == 'o' ? 8 : (ch == 'u' ? 10 : 16),\n                       min, max, flags);\n                break;\n            case 'f':\n                if (cflags == DP_C_LDOUBLE)\n                    fvalue = va_arg(args, LDOUBLE);\n                else\n                    fvalue = va_arg(args, double);\n                fmtfp(buffer, &currlen, maxlen, fvalue, min, max, flags);\n                break;\n            case 'E':\n                flags |= DP_F_UP;\n            case 'e':\n                if (cflags == DP_C_LDOUBLE)\n                    fvalue = va_arg(args, LDOUBLE);\n                else\n                    fvalue = va_arg(args, double);\n                break;\n            case 'G':\n                flags |= DP_F_UP;\n            case 'g':\n                if (cflags == DP_C_LDOUBLE)\n                    fvalue = va_arg(args, LDOUBLE);\n                else\n                    fvalue = va_arg(args, double);\n                break;\n            case 'c':\n                dopr_outch(buffer, &currlen, maxlen,\n                    va_arg(args, int));\n                break;\n            case 's':\n                strvalue = va_arg(args, char *);\n                if (max < 0)\n                    max = maxlen;\n                fmtstr(buffer, &currlen, maxlen, strvalue,\n                    flags, min, max);\n                break;\n            case 'p':\n                value = (long)va_arg(args, void *);\n                fmtint(buffer, &currlen, maxlen,\n                    value, 16, min, max, flags);\n                break;\n            case 'n': /* XXX */\n                if (cflags == DP_C_SHORT) {\n                    short int *num;\n                    num = va_arg(args, short int *);\n                    *num = currlen;\n                } else if (cflags == DP_C_LONG) { /* XXX */\n                    long int *num;\n                    num = va_arg(args, long int *);\n                    *num = (long int) currlen;\n                } else if (cflags == DP_C_LLONG) { /* XXX */\n                    LLONG *num;\n                    num = va_arg(args, LLONG *);\n                    *num = (LLONG) currlen;\n                } else {\n                    int    *num;\n                    num = va_arg(args, int *);\n                    *num = currlen;\n                }\n                break;\n            case '%':\n                dopr_outch(buffer, &currlen, maxlen, ch);\n                break;\n            case 'w':\n                /* not supported yet, treat as next char */\n                ch = *format++;\n                break;\n            default:\n                /* unknown, skip */\n                break;\n            }\n            ch = *format++;\n            state = DP_S_DEFAULT;\n            flags = cflags = min = 0;\n            max = -1;\n            break;\n        case DP_S_DONE:\n            break;\n        default:\n            break;\n        }\n    }\n    if (currlen >= maxlen - 1)\n        currlen = maxlen - 1;\n    buffer[currlen] = '\\0';\n    *retlen = currlen;\n    return;\n}", "target": 1}
{"idx": 5293, "func": "void\nngx_slab_init(ngx_slab_pool_t *pool)\n{\n    u_char           *p;\n    size_t            size;\n    ngx_int_t         m;\n    ngx_uint_t        i, n, pages;\n    ngx_slab_page_t  *slots, *page;\n\n    /* STUB */\n    if (ngx_slab_max_size == 0) {\n        ngx_slab_max_size = ngx_pagesize / 2;\n        ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t));\n        for (n = ngx_slab_exact_size; n >>= 1; ngx_slab_exact_shift++) {\n            /* void */\n        }\n    }\n    /**/\n\n    pool->min_size = 1 << pool->min_shift;\n\n    slots = ngx_slab_slots(pool);\n\n    p = (u_char *) slots;\n    size = pool->end - p;\n\n    ngx_slab_junk(p, size);\n\n    n = ngx_pagesize_shift - pool->min_shift;\n\n    for (i = 0; i < n; i++) {\n        /* only \"next\" is used in list head */\n        slots[i].slab = 0;\n        slots[i].next = &slots[i];\n        slots[i].prev = 0;\n    }\n\n    p += n * sizeof(ngx_slab_page_t);\n    size -= n * sizeof(ngx_slab_page_t);\n\n    pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t)));\n\n    pool->pages = (ngx_slab_page_t *) p;\n    ngx_memzero(pool->pages, pages * sizeof(ngx_slab_page_t));\n\n    page = pool->pages;\n\n    /* only \"next\" is used in list head */\n    pool->free.slab = 0;\n    pool->free.next = page;\n    pool->free.prev = 0;\n\n    page->slab = pages;\n    page->next = &pool->free;\n    page->prev = (uintptr_t) &pool->free;\n\n    pool->start = ngx_align_ptr(p + pages * sizeof(ngx_slab_page_t),\n                                ngx_pagesize);\n\n    m = pages - (pool->end - pool->start) / ngx_pagesize;\n    if (m > 0) {\n        pages -= m;\n        page->slab = pages;\n    }\n\n    pool->last = pool->pages + pages;\n\n    pool->log_nomem = 1;\n    pool->log_ctx = &pool->zero;\n    pool->zero = '\\0';\n}", "target": 0}
{"idx": 5294, "func": "static int ea_read_packet(AVFormatContext *s,\n                          AVPacket *pkt)\n{\n    EaDemuxContext *ea = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret = 0;\n    int packet_read = 0;\n    unsigned int chunk_type, chunk_size;\n    int key = 0;\n    int av_uninit(num_samples);\n\n    while (!packet_read) {\n        chunk_type = avio_rl32(pb);\n        chunk_size = ea->big_endian ? avio_rb32(pb) : avio_rl32(pb);\n        if (chunk_size <= 8)\n            return AVERROR_INVALIDDATA;\n        chunk_size -= 8;\n\n        switch (chunk_type) {\n        /* audio data */\n        case ISNh_TAG:\n            /* header chunk also contains data; skip over the header portion*/\n            if (chunk_size < 32)\n                return AVERROR_INVALIDDATA;\n            avio_skip(pb, 32);\n            chunk_size -= 32;\n        case ISNd_TAG:\n        case SCDl_TAG:\n        case SNDC_TAG:\n        case SDEN_TAG:\n            if (!ea->audio_codec) {\n                avio_skip(pb, chunk_size);\n                break;\n            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||\n                       ea->audio_codec == CODEC_ID_MP3) {\n                num_samples = avio_rl32(pb);\n                avio_skip(pb, 8);\n                chunk_size -= 12;\n            }\n            ret = av_get_packet(pb, pkt, chunk_size);\n            if (ret < 0)\n                return ret;\n            pkt->stream_index = ea->audio_stream_index;\n\n            switch (ea->audio_codec) {\n            case CODEC_ID_ADPCM_EA:\n            case CODEC_ID_ADPCM_EA_R1:\n            case CODEC_ID_ADPCM_EA_R2:\n            case CODEC_ID_ADPCM_IMA_EA_EACS:\n                pkt->duration = AV_RL32(pkt->data);\n                break;\n            case CODEC_ID_ADPCM_EA_R3:\n                pkt->duration = AV_RB32(pkt->data);\n                break;\n            case CODEC_ID_ADPCM_IMA_EA_SEAD:\n                pkt->duration = ret * 2 / ea->num_channels;\n                break;\n            case CODEC_ID_PCM_S16LE_PLANAR:\n            case CODEC_ID_MP3:\n                pkt->duration = num_samples;\n                break;\n            default:\n                pkt->duration = chunk_size / (ea->bytes * ea->num_channels);\n            }\n\n            packet_read = 1;\n            break;\n\n        /* ending tag */\n        case 0:\n        case ISNe_TAG:\n        case SCEl_TAG:\n        case SEND_TAG:\n        case SEEN_TAG:\n            ret = AVERROR(EIO);\n            packet_read = 1;\n            break;\n\n        case MVIh_TAG:\n        case kVGT_TAG:\n        case pQGT_TAG:\n        case TGQs_TAG:\n        case MADk_TAG:\n            key = AV_PKT_FLAG_KEY;\n        case MVIf_TAG:\n        case fVGT_TAG:\n        case MADm_TAG:\n        case MADe_TAG:\n            avio_seek(pb, -8, SEEK_CUR);     // include chunk preamble\n            chunk_size += 8;\n            goto get_video_packet;\n\n        case mTCD_TAG:\n            avio_skip(pb, 8);  // skip ea dct header\n            chunk_size -= 8;\n            goto get_video_packet;\n\n        case MV0K_TAG:\n        case MPCh_TAG:\n        case pIQT_TAG:\n            key = AV_PKT_FLAG_KEY;\n        case MV0F_TAG:\nget_video_packet:\n            ret = av_get_packet(pb, pkt, chunk_size);\n            if (ret < 0)\n                return ret;\n            pkt->stream_index = ea->video_stream_index;\n            pkt->flags |= key;\n            packet_read = 1;\n            break;\n\n        default:\n            avio_skip(pb, chunk_size);\n            break;\n        }\n    }\n\n    return ret;\n}", "target": 0}
{"idx": 5295, "func": "void ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher)\n\t{\n\tCERT_PKEY *cpk;\n\tint rsa_enc,rsa_tmp,rsa_sign,dh_tmp,dh_rsa,dh_dsa,dsa_sign;\n\tint rsa_enc_export,dh_rsa_export,dh_dsa_export;\n\tint rsa_tmp_export,dh_tmp_export,kl;\n\tunsigned long mask_k,mask_a,emask_k,emask_a;\n\tint have_ecc_cert, ecdh_ok, ecdsa_ok, ecc_pkey_size;\n#ifndef OPENSSL_NO_ECDH\n\tint have_ecdh_tmp;\n#endif\n\tX509 *x = NULL;\n\tEVP_PKEY *ecc_pkey = NULL;\n\tint signature_nid = 0;\n\n\tif (c == NULL) return;\n\n\tkl=SSL_C_EXPORT_PKEYLENGTH(cipher);\n\n#ifndef OPENSSL_NO_RSA\n\trsa_tmp=(c->rsa_tmp != NULL || c->rsa_tmp_cb != NULL);\n\trsa_tmp_export=(c->rsa_tmp_cb != NULL ||\n\t\t(rsa_tmp && RSA_size(c->rsa_tmp)*8 <= kl));\n#else\n\trsa_tmp=rsa_tmp_export=0;\n#endif\n#ifndef OPENSSL_NO_DH\n\tdh_tmp=(c->dh_tmp != NULL || c->dh_tmp_cb != NULL);\n\tdh_tmp_export=(c->dh_tmp_cb != NULL ||\n\t\t(dh_tmp && DH_size(c->dh_tmp)*8 <= kl));\n#else\n\tdh_tmp=dh_tmp_export=0;\n#endif\n\n#ifndef OPENSSL_NO_ECDH\n\thave_ecdh_tmp=(c->ecdh_tmp != NULL || c->ecdh_tmp_cb != NULL);\n#endif\n\tcpk= &(c->pkeys[SSL_PKEY_RSA_ENC]);\n\trsa_enc= (cpk->x509 != NULL && cpk->privatekey != NULL);\n\trsa_enc_export=(rsa_enc && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\n\tcpk= &(c->pkeys[SSL_PKEY_RSA_SIGN]);\n\trsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);\n\tcpk= &(c->pkeys[SSL_PKEY_DSA_SIGN]);\n\tdsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);\n\tcpk= &(c->pkeys[SSL_PKEY_DH_RSA]);\n\tdh_rsa=  (cpk->x509 != NULL && cpk->privatekey != NULL);\n\tdh_rsa_export=(dh_rsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\n\tcpk= &(c->pkeys[SSL_PKEY_DH_DSA]);\n/* FIX THIS EAY EAY EAY */\n\tdh_dsa=  (cpk->x509 != NULL && cpk->privatekey != NULL);\n\tdh_dsa_export=(dh_dsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\n\tcpk= &(c->pkeys[SSL_PKEY_ECC]);\n\thave_ecc_cert= (cpk->x509 != NULL && cpk->privatekey != NULL);\n\tmask_k=0;\n\tmask_a=0;\n\temask_k=0;\n\temask_a=0;\n\n\t\n\n#ifdef CIPHER_DEBUG\n\tprintf(\"rt=%d rte=%d dht=%d ecdht=%d re=%d ree=%d rs=%d ds=%d dhr=%d dhd=%d\\n\",\n\t        rsa_tmp,rsa_tmp_export,dh_tmp,have_ecdh_tmp,\n\t\trsa_enc,rsa_enc_export,rsa_sign,dsa_sign,dh_rsa,dh_dsa);\n#endif\n\t\n\tcpk = &(c->pkeys[SSL_PKEY_GOST01]);\n\tif (cpk->x509 != NULL && cpk->privatekey !=NULL) {\n\t\tmask_k |= SSL_kGOST;\n\t\tmask_a |= SSL_aGOST01;\n\t}\n\tcpk = &(c->pkeys[SSL_PKEY_GOST94]);\n\tif (cpk->x509 != NULL && cpk->privatekey !=NULL) {\n\t\tmask_k |= SSL_kGOST;\n\t\tmask_a |= SSL_aGOST94;\n\t}\n\n\tif (rsa_enc || (rsa_tmp && rsa_sign))\n\t\tmask_k|=SSL_kRSA;\n\tif (rsa_enc_export || (rsa_tmp_export && (rsa_sign || rsa_enc)))\n\t\temask_k|=SSL_kRSA;\n\n#if 0\n\t/* The match needs to be both kEDH and aRSA or aDSA, so don't worry */\n\tif (\t(dh_tmp || dh_rsa || dh_dsa) &&\n\t\t(rsa_enc || rsa_sign || dsa_sign))\n\t\tmask_k|=SSL_kEDH;\n\tif ((dh_tmp_export || dh_rsa_export || dh_dsa_export) &&\n\t\t(rsa_enc || rsa_sign || dsa_sign))\n\t\temask_k|=SSL_kEDH;\n#endif\n\n\tif (dh_tmp_export)\n\t\temask_k|=SSL_kEDH;\n\n\tif (dh_tmp)\n\t\tmask_k|=SSL_kEDH;\n\n\tif (dh_rsa) mask_k|=SSL_kDHr;\n\tif (dh_rsa_export) emask_k|=SSL_kDHr;\n\n\tif (dh_dsa) mask_k|=SSL_kDHd;\n\tif (dh_dsa_export) emask_k|=SSL_kDHd;\n\n\tif (rsa_enc || rsa_sign)\n\t\t{\n\t\tmask_a|=SSL_aRSA;\n\t\temask_a|=SSL_aRSA;\n\t\t}\n\n\tif (dsa_sign)\n\t\t{\n\t\tmask_a|=SSL_aDSS;\n\t\temask_a|=SSL_aDSS;\n\t\t}\n\n\tmask_a|=SSL_aNULL;\n\temask_a|=SSL_aNULL;\n\n#ifndef OPENSSL_NO_KRB5\n\tmask_k|=SSL_kKRB5;\n\tmask_a|=SSL_aKRB5;\n\temask_k|=SSL_kKRB5;\n\temask_a|=SSL_aKRB5;\n#endif\n\n\t/* An ECC certificate may be usable for ECDH and/or\n\t * ECDSA cipher suites depending on the key usage extension.\n\t */\n\tif (have_ecc_cert)\n\t\t{\n\t\t/* This call populates extension flags (ex_flags) */\n\t\tx = (c->pkeys[SSL_PKEY_ECC]).x509;\n\t\tX509_check_purpose(x, -1, 0);\n\t\tecdh_ok = (x->ex_flags & EXFLAG_KUSAGE) ?\n\t\t    (x->ex_kusage & X509v3_KU_KEY_AGREEMENT) : 1;\n\t\tecdsa_ok = (x->ex_flags & EXFLAG_KUSAGE) ?\n\t\t    (x->ex_kusage & X509v3_KU_DIGITAL_SIGNATURE) : 1;\n\t\tecc_pkey = X509_get_pubkey(x);\n\t\tecc_pkey_size = (ecc_pkey != NULL) ?\n\t\t    EVP_PKEY_bits(ecc_pkey) : 0;\n\t\tEVP_PKEY_free(ecc_pkey);\n\t\tif ((x->sig_alg) && (x->sig_alg->algorithm))\n\t\t\tsignature_nid = OBJ_obj2nid(x->sig_alg->algorithm);\n#ifndef OPENSSL_NO_ECDH\n\t\tif (ecdh_ok)\n\t\t\t{\n\t\t\tconst char *sig = OBJ_nid2ln(signature_nid);\n\t\t\tif (sig == NULL)\n\t\t\t\t{\n\t\t\t\tERR_clear_error();\n\t\t\t\tsig = \"unknown\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\tif (strstr(sig, \"WithRSA\"))\n\t\t\t\t{\n\t\t\t\tmask_k|=SSL_kECDHr;\n\t\t\t\tmask_a|=SSL_aECDH;\n\t\t\t\tif (ecc_pkey_size <= 163)\n\t\t\t\t\t{\n\t\t\t\t\temask_k|=SSL_kECDHr;\n\t\t\t\t\temask_a|=SSL_aECDH;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif (signature_nid == NID_ecdsa_with_SHA1)\n\t\t\t\t{\n\t\t\t\tmask_k|=SSL_kECDHe;\n\t\t\t\tmask_a|=SSL_aECDH;\n\t\t\t\tif (ecc_pkey_size <= 163)\n\t\t\t\t\t{\n\t\t\t\t\temask_k|=SSL_kECDHe;\n\t\t\t\t\temask_a|=SSL_aECDH;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tif (ecdsa_ok)\n\t\t\t{\n\t\t\tmask_a|=SSL_aECDSA;\n\t\t\temask_a|=SSL_aECDSA;\n\t\t\t}\n#endif\n\t\t}\n\n#ifndef OPENSSL_NO_ECDH\n\tif (have_ecdh_tmp)\n\t\t{\n\t\tmask_k|=SSL_kEECDH;\n\t\temask_k|=SSL_kEECDH;\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_PSK\n\tmask_k |= SSL_kPSK;\n\tmask_a |= SSL_aPSK;\n\temask_k |= SSL_kPSK;\n\temask_a |= SSL_aPSK;\n#endif\n\n\tc->mask_k=mask_k;\n\tc->mask_a=mask_a;\n\tc->export_mask_k=emask_k;\n\tc->export_mask_a=emask_a;\n\tc->valid=1;\n\t}", "target": 1}
{"idx": 5296, "func": "static int configure_filtergraph(FilterGraph *fg)\n{\n    return fg->graph_desc ? configure_complex_filter(fg) :\n                            configure_simple_filtergraph(fg);\n}", "target": 0}
{"idx": 5297, "func": "static av_cold int aac_encode_init(AVCodecContext *avctx)\n{\n    AACEncContext *s = avctx->priv_data;\n    int i;\n    const uint8_t *sizes[2];\n    uint8_t grouping[AAC_MAX_CHANNELS];\n    int lengths[2];\n\n    avctx->frame_size = 1024;\n\n    for (i = 0; i < 16; i++)\n        if (avctx->sample_rate == avpriv_mpeg4audio_sample_rates[i])\n            break;\n    if (i == 16) {\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported sample rate %d\\n\", avctx->sample_rate);\n        return -1;\n    }\n    if (avctx->channels > AAC_MAX_CHANNELS) {\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of channels: %d\\n\", avctx->channels);\n        return -1;\n    }\n    if (avctx->profile != FF_PROFILE_UNKNOWN && avctx->profile != FF_PROFILE_AAC_LOW) {\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported profile %d\\n\", avctx->profile);\n        return -1;\n    }\n    if (1024.0 * avctx->bit_rate / avctx->sample_rate > 6144 * avctx->channels) {\n        av_log(avctx, AV_LOG_ERROR, \"Too many bits per frame requested\\n\");\n        return -1;\n    }\n    s->samplerate_index = i;\n\n    dsputil_init(&s->dsp, avctx);\n    ff_mdct_init(&s->mdct1024, 11, 0, 1.0);\n    ff_mdct_init(&s->mdct128,   8, 0, 1.0);\n    // window init\n    ff_kbd_window_init(ff_aac_kbd_long_1024, 4.0, 1024);\n    ff_kbd_window_init(ff_aac_kbd_short_128, 6.0, 128);\n    ff_init_ff_sine_windows(10);\n    ff_init_ff_sine_windows(7);\n\n    s->chan_map           = aac_chan_configs[avctx->channels-1];\n    s->samples            = av_malloc(2 * 1024 * avctx->channels * sizeof(s->samples[0]));\n    s->cpe                = av_mallocz(sizeof(ChannelElement) * s->chan_map[0]);\n    avctx->extradata      = av_mallocz(5 + FF_INPUT_BUFFER_PADDING_SIZE);\n    avctx->extradata_size = 5;\n    put_audio_specific_config(avctx);\n\n    sizes[0]   = swb_size_1024[i];\n    sizes[1]   = swb_size_128[i];\n    lengths[0] = ff_aac_num_swb_1024[i];\n    lengths[1] = ff_aac_num_swb_128[i];\n    for (i = 0; i < s->chan_map[0]; i++)\n        grouping[i] = s->chan_map[i + 1] == TYPE_CPE;\n    ff_psy_init(&s->psy, avctx, 2, sizes, lengths, s->chan_map[0], grouping);\n    s->psypp = ff_psy_preprocess_init(avctx);\n    s->coder = &ff_aac_coders[2];\n\n    s->lambda = avctx->global_quality ? avctx->global_quality : 120;\n\n    ff_aac_tableinit();\n\n    return 0;\n}", "target": 1}
{"idx": 5298, "func": "static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size)\n{\n    AVCodecContext *const avctx = h->avctx;\n    unsigned context_count = 0;\n    int nals_needed = 0; ///< number of NALs that need decoding before the next frame thread starts\n    int i, ret = 0;\n\n    h->max_contexts = h->slice_context_count;\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)) {\n        h->current_slice = 0;\n        if (!h->first_field)\n            h->cur_pic_ptr = NULL;\n        ff_h264_sei_uninit(&h->sei);\n    }\n\n    ret = ff_h2645_packet_split(&h->pkt, buf, buf_size, avctx, h->is_avc,\n                                h->nal_length_size, avctx->codec_id);\n    if (ret < 0) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Error splitting the input into NAL units.\\n\");\n        return ret;\n    }\n\n    if (avctx->active_thread_type & FF_THREAD_FRAME)\n        nals_needed = get_last_needed_nal(h);\n\n    for (i = 0; i < h->pkt.nb_nals; i++) {\n        H2645NAL *nal = &h->pkt.nals[i];\n        H264SliceContext *sl = &h->slice_ctx[context_count];\n        int err;\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF &&\n            nal->ref_idc == 0 && nal->type != NAL_SEI)\n            continue;\n\nagain:\n        // FIXME these should stop being context-global variables\n        h->nal_ref_idc   = nal->ref_idc;\n        h->nal_unit_type = nal->type;\n\n        err = 0;\n        switch (nal->type) {\n        case NAL_IDR_SLICE:\n            if (nal->type != NAL_IDR_SLICE) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"Invalid mix of idr and non-idr slices\\n\");\n                ret = -1;\n                goto end;\n            }\n            idr(h); // FIXME ensure we don't lose some frames if there is reordering\n        case NAL_SLICE:\n            sl->gb = nal->gb;\n\n            if ((err = ff_h264_decode_slice_header(h, sl)))\n                break;\n\n            if (h->sei.recovery_point.recovery_frame_cnt >= 0 && h->recovery_frame < 0) {\n                h->recovery_frame = (h->poc.frame_num + h->sei.recovery_point.recovery_frame_cnt) &\n                                    ((1 << h->ps.sps->log2_max_frame_num) - 1);\n            }\n\n            h->cur_pic_ptr->f->key_frame |=\n                (nal->type == NAL_IDR_SLICE) || (h->sei.recovery_point.recovery_frame_cnt >= 0);\n\n            if (nal->type == NAL_IDR_SLICE || h->recovery_frame == h->poc.frame_num) {\n                h->recovery_frame         = -1;\n                h->cur_pic_ptr->recovered = 1;\n            }\n            // If we have an IDR, all frames after it in decoded order are\n            // \"recovered\".\n            if (nal->type == NAL_IDR_SLICE)\n                h->frame_recovered |= FRAME_RECOVERED_IDR;\n            h->cur_pic_ptr->recovered |= !!(h->frame_recovered & FRAME_RECOVERED_IDR);\n\n            if (h->current_slice == 1) {\n                if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS))\n                    decode_postinit(h, i >= nals_needed);\n\n                if (h->avctx->hwaccel &&\n                    (ret = h->avctx->hwaccel->start_frame(h->avctx, NULL, 0)) < 0)\n                    return ret;\n            }\n\n            if (sl->redundant_pic_count == 0 &&\n                (avctx->skip_frame < AVDISCARD_NONREF || nal->ref_idc) &&\n                (avctx->skip_frame < AVDISCARD_BIDIR  ||\n                 sl->slice_type_nos != AV_PICTURE_TYPE_B) &&\n                (avctx->skip_frame < AVDISCARD_NONKEY ||\n                 h->cur_pic_ptr->f->key_frame) &&\n                avctx->skip_frame < AVDISCARD_ALL) {\n                if (avctx->hwaccel) {\n                    ret = avctx->hwaccel->decode_slice(avctx, nal->raw_data, nal->raw_size);\n                    if (ret < 0)\n                        return ret;\n                } else\n                    context_count++;\n            }\n            break;\n        case NAL_DPA:\n        case NAL_DPB:\n        case NAL_DPC:\n            avpriv_request_sample(avctx, \"data partitioning\");\n            ret = AVERROR(ENOSYS);\n            goto end;\n            break;\n        case NAL_SEI:\n            ret = ff_h264_sei_decode(&h->sei, &nal->gb, &h->ps, avctx);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            break;\n        case NAL_SPS:\n            ret = ff_h264_decode_seq_parameter_set(&nal->gb, avctx, &h->ps);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            break;\n        case NAL_PPS:\n            ret = ff_h264_decode_picture_parameter_set(&nal->gb, avctx, &h->ps,\n                                                       nal->size_bits);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            break;\n        case NAL_AUD:\n        case NAL_END_SEQUENCE:\n        case NAL_END_STREAM:\n        case NAL_FILLER_DATA:\n        case NAL_SPS_EXT:\n        case NAL_AUXILIARY_SLICE:\n            break;\n        case NAL_FF_IGNORE:\n            break;\n        default:\n            av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\",\n                   nal->type, nal->size_bits);\n        }\n\n        if (context_count == h->max_contexts) {\n            ret = ff_h264_execute_decode_slices(h, context_count);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            context_count = 0;\n        }\n\n        if (err < 0) {\n            av_log(h->avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n            sl->ref_count[0] = sl->ref_count[1] = sl->list_count = 0;\n        } else if (err == 1) {\n            /* Slice could not be decoded in parallel mode, restart. */\n            sl               = &h->slice_ctx[0];\n            goto again;\n        }\n    }\n    if (context_count) {\n        ret = ff_h264_execute_decode_slices(h, context_count);\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n            goto end;\n    }\n\n    ret = 0;\nend:\n    /* clean up */\n    if (h->cur_pic_ptr && !h->droppable) {\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    }\n\n    return (ret < 0) ? ret : buf_size;\n}", "target": 1}
{"idx": 5299, "func": "static int x9_62_tests()\n{\n    int ret = 0;\n\n    /* set own rand method */\n    if (!change_rand())\n        goto x962_err;\n\n    if (!TEST_true(x9_62_test_internal(NID_X9_62_prime192v1,\n                 \"3342403536405981729393488334694600415596881826869351677613\",\n                 \"5735822328888155254683894997897571951568553642892029982342\")))\n        goto x962_err;\n    if (!TEST_true(x9_62_test_internal(NID_X9_62_prime239v1,\n                 \"3086361431751678114926225473006680188549593787585317781474\"\n                             \"62058306432176\",\n                 \"3238135532097973577080787768312505059318910517550078427819\"\n                             \"78505179448783\")))\n        goto x962_err;\n\n# ifndef OPENSSL_NO_EC2M\n    if (!TEST_true(x9_62_test_internal(NID_X9_62_c2tnb191v1,\n                 \"87194383164871543355722284926904419997237591535066528048\",\n                 \"308992691965804947361541664549085895292153777025772063598\")))\n        goto x962_err;\n    if (!TEST_true(x9_62_test_internal(NID_X9_62_c2tnb239v1,\n                 \"2159633321041961198501834003903461262881815148684178964245\"\n                             \"5876922391552\",\n                 \"1970303740007316867383349976549972270528498040721988191026\"\n                             \"49413465737174\")))\n        goto x962_err;\n# endif\n    ret = 1;\n\n x962_err:\n    if (!TEST_true(restore_rand()))\n        ret = 0;\n    return ret;\n}", "target": 0}
{"idx": 5300, "func": "static int init_dimensions(H264Context *h)\n{\n    SPS *sps = h->ps.sps;\n    int width  = h->width  - (sps->crop_right + sps->crop_left);\n    int height = h->height - (sps->crop_top   + sps->crop_bottom);\n\n    /* handle container cropping */\n    if (FFALIGN(h->avctx->width,  16) == FFALIGN(width,  16) &&\n        FFALIGN(h->avctx->height, 16) == FFALIGN(height, 16)) {\n        width  = h->avctx->width;\n        height = h->avctx->height;\n    }\n\n    if (width <= 0 || height <= 0) {\n        av_log(h->avctx, AV_LOG_ERROR, \"Invalid cropped dimensions: %dx%d.\\n\",\n               width, height);\n        if (h->avctx->err_recognition & AV_EF_EXPLODE)\n            return AVERROR_INVALIDDATA;\n\n        av_log(h->avctx, AV_LOG_WARNING, \"Ignoring cropping information.\\n\");\n        sps->crop_bottom =\n        sps->crop_top    =\n        sps->crop_right  =\n        sps->crop_left   =\n        sps->crop        = 0;\n\n        width  = h->width;\n        height = h->height;\n    }\n\n    h->avctx->coded_width  = h->width;\n    h->avctx->coded_height = h->height;\n    h->avctx->width        = width;\n    h->avctx->height       = height;\n\n    return 0;\n}", "target": 0}
{"idx": 5301, "func": "static int rv10_decode_frame(AVCodecContext *avctx,\n                             void *data, int *data_size,\n                             AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    MpegEncContext *s = avctx->priv_data;\n    int i;\n    AVFrame *pict = data;\n    int slice_count;\n    const uint8_t *slices_hdr = NULL;\n\n    av_dlog(avctx, \"*****frame %d size=%d\\n\", avctx->frame_number, buf_size);\n\n    /* no supplementary picture */\n    if (buf_size == 0) {\n        return 0;\n    }\n\n    if(!avctx->slice_count){\n        slice_count = (*buf++) + 1;\n        slices_hdr = buf + 4;\n        buf += 8 * slice_count;\n    }else\n        slice_count = avctx->slice_count;\n\n    for(i=0; i<slice_count; i++){\n        unsigned offset = get_slice_offset(avctx, slices_hdr, i);\n        int size, size2;\n\n        if (offset >= buf_size)\n            return AVERROR_INVALIDDATA;\n\n        if(i+1 == slice_count)\n            size= buf_size - offset;\n        else\n            size= get_slice_offset(avctx, slices_hdr, i+1) - offset;\n\n        if(i+2 >= slice_count)\n            size2= buf_size - offset;\n        else\n            size2= get_slice_offset(avctx, slices_hdr, i+2) - offset;\n\n        if (size <= 0 || size2 <= 0 ||\n            offset + FFMAX(size, size2) > buf_size)\n            return AVERROR_INVALIDDATA;\n\n        if(rv10_decode_packet(avctx, buf+offset, size, size2) > 8*size)\n            i++;\n    }\n\n    if(s->current_picture_ptr != NULL && s->mb_y>=s->mb_height){\n        ff_er_frame_end(s);\n        MPV_frame_end(s);\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n            *pict= *(AVFrame*)s->current_picture_ptr;\n        } else if (s->last_picture_ptr != NULL) {\n            *pict= *(AVFrame*)s->last_picture_ptr;\n        }\n\n        if(s->last_picture_ptr || s->low_delay){\n            *data_size = sizeof(AVFrame);\n            ff_print_debug_info(s, pict);\n        }\n        s->current_picture_ptr= NULL; //so we can detect if frame_end wasnt called (find some nicer solution...)\n    }\n\n    return buf_size;\n}", "target": 0}
{"idx": 5302, "func": "static void update_odml_entry(AVFormatContext *s, int stream_index, int64_t ix, int size)\n{\n    AVIOContext *pb = s->pb;\n    AVIContext *avi = s->priv_data;\n    AVIStream *avist = s->streams[stream_index]->priv_data;\n    int64_t pos;\n    int au_byterate, au_ssize, au_scale;\n\n    avio_flush(pb);\n    pos = avio_tell(pb);\n\n    /* Updating one entry in the AVI OpenDML master index */\n    avio_seek(pb, avist->indexes.indx_start - 8, SEEK_SET);\n    ffio_wfourcc(pb, \"indx\");             /* enabling this entry */\n    avio_skip(pb, 8);\n    avio_wl32(pb, avi->riff_id - avist->indexes.master_odml_riff_id_base);          /* nEntriesInUse */\n    avio_skip(pb, 16 * (avi->riff_id - avist->indexes.master_odml_riff_id_base));\n    avio_wl64(pb, ix);                    /* qwOffset */\n    avio_wl32(pb, size);                  /* dwSize */\n    ff_parse_specific_params(s->streams[stream_index], &au_byterate, &au_ssize, &au_scale);\n    if (s->streams[stream_index]->codec->codec_type == AVMEDIA_TYPE_AUDIO && au_ssize > 0) {\n        uint32_t audio_segm_size = (avist->audio_strm_length - avist->indexes.audio_strm_offset);\n        if ((audio_segm_size % au_ssize > 0) && !avist->sample_requested) {\n            avpriv_request_sample(s, \"OpenDML index duration for audio packets with partial frames\");\n            avist->sample_requested = 1;\n        }\n        avio_wl32(pb, audio_segm_size / au_ssize);  /* dwDuration (sample count) */\n    } else\n        avio_wl32(pb, avist->indexes.entry);  /* dwDuration (packet count) */\n\n    avio_seek(pb, pos, SEEK_SET);\n}", "target": 0}
{"idx": 5303, "func": "static void sh_free(char *ptr)\n{\n    size_t list;\n    char *buddy;\n\n    if (ptr == NULL)\n        return;\n    OPENSSL_assert(WITHIN_ARENA(ptr));\n    if (!WITHIN_ARENA(ptr))\n        return;\n\n    list = sh_getlist(ptr);\n    OPENSSL_assert(sh_testbit(ptr, list, sh.bittable));\n    sh_clearbit(ptr, list, sh.bitmalloc);\n    sh_add_to_list(&sh.freelist[list], ptr);\n\n    /* Try to coalesce two adjacent free areas. */\n    while ((buddy = sh_find_my_buddy(ptr, list)) != NULL) {\n        OPENSSL_assert(ptr == sh_find_my_buddy(buddy, list));\n        OPENSSL_assert(ptr != NULL);\n        OPENSSL_assert(!sh_testbit(ptr, list, sh.bitmalloc));\n        sh_clearbit(ptr, list, sh.bittable);\n        sh_remove_from_list(ptr);\n        OPENSSL_assert(!sh_testbit(ptr, list, sh.bitmalloc));\n        sh_clearbit(buddy, list, sh.bittable);\n        sh_remove_from_list(buddy);\n\n        list--;\n\n        if (ptr > buddy)\n            ptr = buddy;\n\n        OPENSSL_assert(!sh_testbit(ptr, list, sh.bitmalloc));\n        sh_setbit(ptr, list, sh.bittable);\n        sh_add_to_list(&sh.freelist[list], ptr);\n        OPENSSL_assert(sh.freelist[list] == ptr);\n    }\n}", "target": 0}
{"idx": 5304, "func": "int X509_verify_cert(X509_STORE_CTX *ctx)\n\t{\n\tX509 *x,*xtmp,*chain_ss=NULL;\n\tX509_NAME *xn;\n\tint depth,i,ok=0;\n\tint num;\n\tint (*cb)();\n\tSTACK_OF(X509) *sktmp=NULL;\n\n\tif (ctx->cert == NULL)\n\t\t{\n\t\tX509err(X509_F_X509_VERIFY_CERT,X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\n\t\treturn(-1);\n\t\t}\n\n\tcb=ctx->verify_cb;\n\tif (cb == NULL) cb=null_callback;\n\n\t/* first we make sure the chain we are going to build is\n\t * present and that the first entry is in place */\n\tif (ctx->chain == NULL)\n\t\t{\n\t\tif (\t((ctx->chain=sk_X509_new_null()) == NULL) ||\n\t\t\t(!sk_X509_push(ctx->chain,ctx->cert)))\n\t\t\t{\n\t\t\tX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto end;\n\t\t\t}\n\t\tCRYPTO_add(&ctx->cert->references,1,CRYPTO_LOCK_X509);\n\t\tctx->last_untrusted=1;\n\t\t}\n\n\t/* We use a temporary STACK so we can chop and hack at it */\n\tif (ctx->untrusted != NULL\n\t    && (sktmp=sk_X509_dup(ctx->untrusted)) == NULL)\n\t\t{\n\t\tX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\n\t\tgoto end;\n\t\t}\n\n\tnum=sk_X509_num(ctx->chain);\n\tx=sk_X509_value(ctx->chain,num-1);\n\tdepth=ctx->depth;\n\n\n\tfor (;;)\n\t\t{\n\t\t/* If we have enough, we break */\n\t\tif (depth < num) break; /* FIXME: If this happens, we should take\n\t\t                         * note of it and, if appropriate, use the\n\t\t                         * X509_V_ERR_CERT_CHAIN_TOO_LONG error\n\t\t                         * code later.\n\t\t                         */\n\n\t\t/* If we are self signed, we break */\n\t\txn=X509_get_issuer_name(x);\n\t\tif (ctx->check_issued(ctx, x,x)) break;\n\n\t\t/* If we were passed a cert chain, use it first */\n\t\tif (ctx->untrusted != NULL)\n\t\t\t{\n\t\t\txtmp=find_issuer(ctx, sktmp,x);\n\t\t\tif (xtmp != NULL)\n\t\t\t\t{\n\t\t\t\tif (!sk_X509_push(ctx->chain,xtmp))\n\t\t\t\t\t{\n\t\t\t\t\tX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tCRYPTO_add(&xtmp->references,1,CRYPTO_LOCK_X509);\n\t\t\t\tsk_X509_delete_ptr(sktmp,xtmp);\n\t\t\t\tctx->last_untrusted++;\n\t\t\t\tx=xtmp;\n\t\t\t\tnum++;\n\t\t\t\t/* reparse the full chain for\n\t\t\t\t * the next one */\n\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\tbreak;\n\t\t}\n\n\t/* at this point, chain should contain a list of untrusted\n\t * certificates.  We now need to add at least one trusted one,\n\t * if possible, otherwise we complain. */\n\n\t/* Examine last certificate in chain and see if it\n \t * is self signed.\n \t */\n\n\ti=sk_X509_num(ctx->chain);\n\tx=sk_X509_value(ctx->chain,i-1);\n\txn = X509_get_subject_name(x);\n\tif (ctx->check_issued(ctx, x, x))\n\t\t{\n\t\t/* we have a self signed certificate */\n\t\tif (sk_X509_num(ctx->chain) == 1)\n\t\t\t{\n\t\t\t/* We have a single self signed certificate: see if\n\t\t\t * we can find it in the store. We must have an exact\n\t\t\t * match to avoid possible impersonation.\n\t\t\t */\n\t\t\tok = ctx->get_issuer(&xtmp, ctx, x);\n\t\t\tif ((ok <= 0) || X509_cmp(x, xtmp)) \n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\n\t\t\t\tctx->current_cert=x;\n\t\t\t\tctx->error_depth=i-1;\n\t\t\t\tif(ok == 1) X509_free(xtmp);\n\t\t\t\tok=cb(0,ctx);\n\t\t\t\tif (!ok) goto end;\n\t\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\t/* We have a match: replace certificate with store version\n\t\t\t\t * so we get any trust settings.\n\t\t\t\t */\n\t\t\t\tX509_free(x);\n\t\t\t\tx = xtmp;\n\t\t\t\tsk_X509_set(ctx->chain, i - 1, x);\n\t\t\t\tctx->last_untrusted=0;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t/* extract and save self signed certificate for later use */\n\t\t\tchain_ss=sk_X509_pop(ctx->chain);\n\t\t\tctx->last_untrusted--;\n\t\t\tnum--;\n\t\t\tx=sk_X509_value(ctx->chain,num-1);\n\t\t\t}\n\t\t}\n\n\t/* We now lookup certs from the certificate store */\n\tfor (;;)\n\t\t{\n\t\t/* If we have enough, we break */\n\t\tif (depth < num) break;\n\n\t\t/* If we are self signed, we break */\n\t\txn=X509_get_issuer_name(x);\n\t\tif (ctx->check_issued(ctx,x,x)) break;\n\n\t\tok = ctx->get_issuer(&xtmp, ctx, x);\n\n\t\tif (ok < 0) return ok;\n\t\tif(ok == 0) break;\n\n\t\tx = xtmp;\n\t\tif (!sk_X509_push(ctx->chain,x))\n\t\t\t{\n\t\t\tX509_free(xtmp);\n\t\t\tX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\n\t\t\treturn(0);\n\t\t\t}\n\t\tnum++;\n\t\t}\n\n\t/* we now have our chain, lets check it... */\n\txn=X509_get_issuer_name(x);\n\n\t/* Is last certificate looked up self signed? */\n\tif (!ctx->check_issued(ctx,x,x))\n\t\t{\n\t\tif ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss))\n\t\t\t{\n\t\t\tif (ctx->last_untrusted >= num)\n\t\t\t\tctx->error=X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n\t\t\telse\n\t\t\t\tctx->error=X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n\t\t\tctx->current_cert=x;\n\t\t\t}\n\t\telse\n\t\t\t{\n\n\t\t\tsk_X509_push(ctx->chain,chain_ss);\n\t\t\tnum++;\n\t\t\tctx->last_untrusted=num;\n\t\t\tctx->current_cert=chain_ss;\n\t\t\tctx->error=X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n\t\t\tchain_ss=NULL;\n\t\t\t}\n\n\t\tctx->error_depth=num-1;\n\t\tok=cb(0,ctx);\n\t\tif (!ok) goto end;\n\t\t}\n\n\t/* We have the chain complete: now we need to check its purpose */\n\tif(ctx->purpose > 0) ok = check_chain_purpose(ctx);\n\n\tif(!ok) goto end;\n\n\t/* The chain extensions are OK: check trust */\n\n\tif(ctx->trust > 0) ok = check_trust(ctx);\n\n\tif(!ok) goto end;\n\n\t/* We may as well copy down any DSA parameters that are required */\n\tX509_get_pubkey_parameters(NULL,ctx->chain);\n\n\t/* At this point, we have a chain and just need to verify it */\n\tif (ctx->verify != NULL)\n\t\tok=ctx->verify(ctx);\n\telse\n\t\tok=internal_verify(ctx);\n\tif (0)\n\t\t{\nend:\n\t\tX509_get_pubkey_parameters(NULL,ctx->chain);\n\t\t}\n\tif (sktmp != NULL) sk_X509_free(sktmp);\n\tif (chain_ss != NULL) X509_free(chain_ss);\n\treturn(ok);\n\t}", "target": 0}
{"idx": 5305, "func": "static void store_slotmem(ap_slotmem_instance_t *slotmem)\n{\n    apr_file_t *fp;\n    apr_status_t rv;\n    apr_size_t nbytes;\n    unsigned char digest[APR_MD5_DIGESTSIZE];\n    const char *storename = slotmem->pname;\n\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02334)\n                 \"storing %s\", storename);\n\n    if (storename) {\n        rv = apr_file_open(&fp, storename, APR_CREATE | APR_READ | APR_WRITE,\n                           APR_OS_DEFAULT, slotmem->pool);\n        if (APR_STATUS_IS_EEXIST(rv)) {\n            apr_file_remove(storename, slotmem->pool);\n            rv = apr_file_open(&fp, storename, APR_CREATE | APR_READ | APR_WRITE,\n                               APR_OS_DEFAULT, slotmem->pool);\n        }\n        if (rv != APR_SUCCESS) {\n            return;\n        }\n        if (AP_SLOTMEM_IS_CLEARINUSE(slotmem)) {\n            slotmem_clearinuse(slotmem);\n        }\n        nbytes = (slotmem->desc->size * slotmem->desc->num) +\n                 (slotmem->desc->num * sizeof(char)) + AP_UNSIGNEDINT_OFFSET;\n        apr_md5(digest, slotmem->persist, nbytes);\n        rv = apr_file_write_full(fp, slotmem->persist, nbytes, NULL);\n        if (rv == APR_SUCCESS) {\n            rv = apr_file_write_full(fp, digest, APR_MD5_DIGESTSIZE, NULL);\n        }\n        if (rv == APR_SUCCESS) {\n            rv = apr_file_write_full(fp, slotmem->desc, AP_SLOTMEM_OFFSET,\n                                     NULL);\n        }\n        apr_file_close(fp);\n        if (rv != APR_SUCCESS) {\n            apr_file_remove(storename, slotmem->pool);\n        }\n    }\n}", "target": 1}
{"idx": 5306, "func": "int sk_insert(STACK *st, char *data, int loc)\n\t{\n\tchar **s;\n\n\tif(st == NULL) return 0;\n\tif (st->num_alloc <= st->num+1)\n\t\t{\n\t\ts=(char **)Realloc((char *)st->data,\n\t\t\t(unsigned int)sizeof(char *)*st->num_alloc*2);\n\t\tif (s == NULL)\n\t\t\treturn(0);\n\t\tst->data=s;\n\t\tst->num_alloc*=2;\n\t\t}\n\tif ((loc >= (int)st->num) || (loc < 0))\n\t\tst->data[st->num]=data;\n\telse\n\t\t{\n\t\tint i;\n\t\tchar **f,**t;\n\n\t\tf=(char **)st->data;\n\t\tt=(char **)&(st->data[1]);\n\t\tfor (i=st->num; i>=loc; i--)\n\t\t\tt[i]=f[i];\n\t\t\t\n#ifdef undef /* no memmove on sunos :-( */\n\t\tmemmove( (char *)&(st->data[loc+1]),\n\t\t\t(char *)&(st->data[loc]),\n\t\t\tsizeof(char *)*(st->num-loc));\n#endif\n\t\tst->data[loc]=data;\n\t\t}\n\tst->num++;\n\tst->sorted=0;\n\treturn(st->num);\n\t}", "target": 1}
{"idx": 5307, "func": "static void proxy_wstunnel_callback(void *b) { \n    int status;\n    apr_socket_t *sockets[3] = {NULL, NULL, NULL};\n    ws_baton_t *baton = (ws_baton_t*)b;\n    proxyws_dir_conf *dconf = ap_get_module_config(baton->r->per_dir_config, &proxy_wstunnel_module);\n    apr_pool_clear(baton->subpool);\n    status = proxy_wstunnel_pump(baton, dconf->async_delay, dconf->is_async);\n    if (status == SUSPENDED) {\n        sockets[0] = baton->client_soc;\n        sockets[1] = baton->server_soc;\n        ap_mpm_register_socket_callback_timeout(sockets, baton->subpool, 1, \n            proxy_wstunnel_callback, \n            proxy_wstunnel_cancel_callback, \n            baton, \n            dconf->idle_timeout);\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, baton->r, \"proxy_wstunnel_callback suspend\");\n    }\n    else { \n        proxy_wstunnel_finish(baton);\n    }\n}", "target": 0}
{"idx": 5308, "func": "static int ssl_add_cert_to_buf(BUF_MEM *buf, unsigned long *l, X509 *x)\n\t{\n\tint n;\n\tunsigned char *p;\n\n\tn=i2d_X509(x,NULL);\n\tif (!BUF_MEM_grow_clean(buf,(int)(n+(*l)+3)))\n\t\t{\n\t\tSSLerr(SSL_F_SSL_ADD_CERT_TO_BUF,ERR_R_BUF_LIB);\n\t\treturn 0;\n\t\t}\n\tp=(unsigned char *)&(buf->data[*l]);\n\tl2n3(n,p);\n\ti2d_X509(x,&p);\n\t*l+=n+3;\n\n\treturn 1;\n\t}", "target": 1}
{"idx": 5309, "func": "static int add_file(AVFormatContext *avf, char *filename, ConcatFile **rfile,\n                    unsigned *nb_files_alloc)\n{\n    ConcatContext *cat = avf->priv_data;\n    ConcatFile *file;\n    char *url = NULL;\n    const char *proto;\n    size_t url_len, proto_len;\n    int ret;\n\n    if (cat->safe > 0 && !safe_filename(filename)) {\n        av_log(avf, AV_LOG_ERROR, \"Unsafe file name '%s'\\n\", filename);\n        FAIL(AVERROR(EPERM));\n    }\n\n    proto = avio_find_protocol_name(filename);\n    proto_len = proto ? strlen(proto) : 0;\n    if (proto && !memcmp(filename, proto, proto_len) &&\n        (filename[proto_len] == ':' || filename[proto_len] == ',')) {\n        url = filename;\n        filename = NULL;\n    } else {\n        url_len = strlen(avf->filename) + strlen(filename) + 16;\n        if (!(url = av_malloc(url_len)))\n            FAIL(AVERROR(ENOMEM));\n        ff_make_absolute_url(url, url_len, avf->filename, filename);\n        av_freep(&filename);\n    }\n\n    if (cat->nb_files >= *nb_files_alloc) {\n        size_t n = FFMAX(*nb_files_alloc * 2, 16);\n        ConcatFile *new_files;\n        if (n <= cat->nb_files || n > SIZE_MAX / sizeof(*cat->files) ||\n            !(new_files = av_realloc(cat->files, n * sizeof(*cat->files))))\n            FAIL(AVERROR(ENOMEM));\n        cat->files = new_files;\n        *nb_files_alloc = n;\n    }\n\n    file = &cat->files[cat->nb_files++];\n    memset(file, 0, sizeof(*file));\n    *rfile = file;\n\n    file->url        = url;\n    file->start_time = AV_NOPTS_VALUE;\n    file->duration   = AV_NOPTS_VALUE;\n    file->next_dts   = AV_NOPTS_VALUE;\n    file->inpoint    = AV_NOPTS_VALUE;\n    file->outpoint   = AV_NOPTS_VALUE;\n\n    return 0;\n\nfail:\n    av_free(url);\n    av_free(filename);\n    return ret;\n}", "target": 0}
{"idx": 5310, "func": "int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)\n{\n    int id, sr, ch, ba, tag, bps;\n\n    id  = avctx->codec_id;\n    sr  = avctx->sample_rate;\n    ch  = avctx->channels;\n    ba  = avctx->block_align;\n    tag = avctx->codec_tag;\n    bps = av_get_exact_bits_per_sample(avctx->codec_id);\n\n    /* codecs with an exact constant bits per sample */\n    if (bps > 0 && ch > 0 && frame_bytes > 0)\n        return (frame_bytes * 8) / (bps * ch);\n    bps = avctx->bits_per_coded_sample;\n\n    /* codecs with a fixed packet duration */\n    switch (id) {\n    case CODEC_ID_ADPCM_ADX:    return   32;\n    case CODEC_ID_ADPCM_IMA_QT: return   64;\n    case CODEC_ID_ADPCM_EA_XAS: return  128;\n    case CODEC_ID_AMR_NB:\n    case CODEC_ID_GSM:\n    case CODEC_ID_QCELP:\n    case CODEC_ID_RA_144:\n    case CODEC_ID_RA_288:       return  160;\n    case CODEC_ID_IMC:          return  256;\n    case CODEC_ID_AMR_WB:\n    case CODEC_ID_GSM_MS:       return  320;\n    case CODEC_ID_MP1:          return  384;\n    case CODEC_ID_ATRAC1:       return  512;\n    case CODEC_ID_ATRAC3:       return 1024;\n    case CODEC_ID_MP2:\n    case CODEC_ID_MUSEPACK7:    return 1152;\n    case CODEC_ID_AC3:          return 1536;\n    }\n\n    if (sr > 0) {\n        /* calc from sample rate */\n        if (id == CODEC_ID_TTA)\n            return 256 * sr / 245;\n\n        if (ch > 0) {\n            /* calc from sample rate and channels */\n            if (id == CODEC_ID_BINKAUDIO_DCT)\n                return (480 << (sr / 22050)) / ch;\n        }\n    }\n\n    if (ba > 0) {\n        /* calc from block_align */\n        if (id == CODEC_ID_SIPR) {\n            switch (ba) {\n            case 20: return 160;\n            case 19: return 144;\n            case 29: return 288;\n            case 37: return 480;\n            }\n        }\n    }\n\n    if (frame_bytes > 0) {\n        /* calc from frame_bytes only */\n        if (id == CODEC_ID_TRUESPEECH)\n            return 240 * (frame_bytes / 32);\n        if (id == CODEC_ID_NELLYMOSER)\n            return 256 * (frame_bytes / 64);\n\n        if (bps > 0) {\n            /* calc from frame_bytes and bits_per_coded_sample */\n            if (id == CODEC_ID_ADPCM_G726)\n                return frame_bytes * 8 / bps;\n        }\n\n        if (ch > 0) {\n            /* calc from frame_bytes and channels */\n            switch (id) {\n            case CODEC_ID_ADPCM_4XM:\n            case CODEC_ID_ADPCM_IMA_ISS:\n                return (frame_bytes - 4 * ch) * 2 / ch;\n            case CODEC_ID_ADPCM_IMA_SMJPEG:\n                return (frame_bytes - 4) * 2 / ch;\n            case CODEC_ID_ADPCM_IMA_AMV:\n                return (frame_bytes - 8) * 2 / ch;\n            case CODEC_ID_ADPCM_XA:\n                return (frame_bytes / 128) * 224 / ch;\n            case CODEC_ID_INTERPLAY_DPCM:\n                return (frame_bytes - 6 - ch) / ch;\n            case CODEC_ID_ROQ_DPCM:\n                return (frame_bytes - 8) / ch;\n            case CODEC_ID_XAN_DPCM:\n                return (frame_bytes - 2 * ch) / ch;\n            case CODEC_ID_MACE3:\n                return 3 * frame_bytes / ch;\n            case CODEC_ID_MACE6:\n                return 6 * frame_bytes / ch;\n            case CODEC_ID_PCM_LXF:\n                return 2 * (frame_bytes / (5 * ch));\n            }\n\n            if (tag) {\n                /* calc from frame_bytes, channels, and codec_tag */\n                if (id == CODEC_ID_SOL_DPCM) {\n                    if (tag == 3)\n                        return frame_bytes / ch;\n                    else\n                        return frame_bytes * 2 / ch;\n                }\n            }\n\n            if (ba > 0) {\n                /* calc from frame_bytes, channels, and block_align */\n                int blocks = frame_bytes / ba;\n                switch (avctx->codec_id) {\n                case CODEC_ID_ADPCM_IMA_WAV:\n                    return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\n                case CODEC_ID_ADPCM_IMA_DK3:\n                    return blocks * (((ba - 16) * 2 / 3 * 4) / ch);\n                case CODEC_ID_ADPCM_IMA_DK4:\n                    return blocks * (1 + (ba - 4 * ch) * 2 / ch);\n                case CODEC_ID_ADPCM_MS:\n                    return blocks * (2 + (ba - 7 * ch) * 2 / ch);\n                }\n            }\n\n            if (bps > 0) {\n                /* calc from frame_bytes, channels, and bits_per_coded_sample */\n                switch (avctx->codec_id) {\n                case CODEC_ID_PCM_DVD:\n                    return 2 * (frame_bytes / ((bps * 2 / 8) * ch));\n                case CODEC_ID_PCM_BLURAY:\n                    return frame_bytes / ((FFALIGN(ch, 2) * bps) / 8);\n                case CODEC_ID_S302M:\n                    return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5311, "func": "static int ast_write_trailer(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    ASTMuxContext *ast = s->priv_data;\n    AVCodecContext *enc = s->streams[0]->codec;\n    int64_t file_size = avio_tell(pb);\n    int64_t samples = (file_size - 64 - (32 * s->streams[0]->nb_frames)) / enc->block_align; /* PCM_S16BE_PLANAR */\n\n    av_log(s, AV_LOG_DEBUG, \"total samples: %\"PRId64\"\\n\", samples);\n\n    if (s->pb->seekable) {\n        /* Number of samples */\n        avio_seek(pb, ast->samples, SEEK_SET);\n        avio_wb32(pb, samples);\n\n        /* Loopstart if provided */\n        if (ast->loopstart > 0) {\n        if (ast->loopstart >= samples) {\n            av_log(s, AV_LOG_WARNING, \"Loopstart value is out of range and will be ignored\\n\");\n            ast->loopstart = -1;\n            avio_skip(pb, 4);\n        } else\n        avio_wb32(pb, ast->loopstart);\n        } else\n            avio_skip(pb, 4);\n\n        /* Loopend if provided. Otherwise number of samples again */\n        if (ast->loopend && ast->loopstart >= 0) {\n            if (ast->loopend > samples) {\n                av_log(s, AV_LOG_WARNING, \"Loopend value is out of range and will be ignored\\n\");\n                ast->loopend = samples;\n            }\n            avio_wb32(pb, ast->loopend);\n        } else {\n            avio_wb32(pb, samples);\n        }\n\n        /* Size of first block */\n        avio_wb32(pb, ast->fbs);\n\n        /* File size minus header */\n        avio_seek(pb, ast->size, SEEK_SET);\n        avio_wb32(pb, file_size - 64);\n\n        /* Loop flag */\n        if (ast->loopstart >= 0) {\n            avio_skip(pb, 6);\n            avio_wb16(pb, 0xFFFF);\n        }\n\n        avio_seek(pb, file_size, SEEK_SET);\n        avio_flush(pb);\n    }\n    return 0;\n}", "target": 0}
{"idx": 5312, "func": "static int parse_m3d(AVFilterContext *ctx, FILE *f)\n{\n    LUT3DContext *lut3d = ctx->priv;\n    float scale;\n    int i, j, k, size, in = -1, out = -1;\n    char line[MAX_LINE_SIZE];\n    uint8_t rgb_map[3] = {0, 1, 2};\n\n    while (fgets(line, sizeof(line), f)) {\n        if      (!strncmp(line, \"in\",  2)) in  = strtol(line + 2, NULL, 0);\n        else if (!strncmp(line, \"out\", 3)) out = strtol(line + 3, NULL, 0);\n        else if (!strncmp(line, \"values\", 6)) {\n            const char *p = line + 6;\n#define SET_COLOR(id) do {                  \\\n    while (av_isspace(*p))                  \\\n        p++;                                \\\n    switch (*p) {                           \\\n    case 'r': rgb_map[id] = 0; break;       \\\n    case 'g': rgb_map[id] = 1; break;       \\\n    case 'b': rgb_map[id] = 2; break;       \\\n    }                                       \\\n    while (*p && !av_isspace(*p))           \\\n        p++;                                \\\n} while (0)\n            SET_COLOR(0);\n            SET_COLOR(1);\n            SET_COLOR(2);\n            break;\n        }\n    }\n\n    if (in == -1 || out == -1) {\n        av_log(ctx, AV_LOG_ERROR, \"in and out must be defined\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (in < 2 || out < 2 ||\n        in  > MAX_LEVEL*MAX_LEVEL*MAX_LEVEL ||\n        out > MAX_LEVEL*MAX_LEVEL*MAX_LEVEL) {\n        av_log(ctx, AV_LOG_ERROR, \"invalid in (%d) or out (%d)\\n\", in, out);\n        return AVERROR_INVALIDDATA;\n    }\n    for (size = 1; size*size*size < in; size++);\n    lut3d->lutsize = size;\n    scale = 1. / (out - 1);\n\n    for (k = 0; k < size; k++) {\n        for (j = 0; j < size; j++) {\n            for (i = 0; i < size; i++) {\n                struct rgbvec *vec = &lut3d->lut[k][j][i];\n                float val[3];\n\n                NEXT_LINE(0);\n                if (sscanf(line, \"%f %f %f\", val, val + 1, val + 2) != 3)\n                    return AVERROR_INVALIDDATA;\n                vec->r = val[rgb_map[0]] * scale;\n                vec->g = val[rgb_map[1]] * scale;\n                vec->b = val[rgb_map[2]] * scale;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": 5313, "func": "static int cdg_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    int ret;\n    uint8_t command, inst;\n    uint8_t cdg_data[CDG_DATA_SIZE] = {0};\n    AVFrame *frame = data;\n    CDGraphicsContext *cc = avctx->priv_data;\n\n    if (buf_size < CDG_MINIMUM_PKT_SIZE) {\n        av_log(avctx, AV_LOG_ERROR, \"buffer too small for decoder\\n\");\n        return AVERROR(EINVAL);\n    }\n    if (buf_size > CDG_HEADER_SIZE + CDG_DATA_SIZE) {\n        av_log(avctx, AV_LOG_ERROR, \"buffer too big for decoder\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if ((ret = ff_reget_buffer(avctx, cc->frame)) < 0)\n        return ret;\n    if (!avctx->frame_number) {\n        memset(cc->frame->data[0], 0, cc->frame->linesize[0] * avctx->height);\n        memset(cc->frame->data[1], 0, AVPALETTE_SIZE);\n    }\n\n    command = bytestream_get_byte(&buf);\n    inst    = bytestream_get_byte(&buf);\n    inst    &= CDG_MASK;\n    buf += 2;  /// skipping 2 unneeded bytes\n\n    if (buf_size > CDG_HEADER_SIZE)\n        bytestream_get_buffer(&buf, cdg_data, buf_size - CDG_HEADER_SIZE);\n\n    if ((command & CDG_MASK) == CDG_COMMAND) {\n        switch (inst) {\n        case CDG_INST_MEMORY_PRESET:\n            if (!(cdg_data[1] & 0x0F))\n                memset(cc->frame->data[0], cdg_data[0] & 0x0F,\n                       cc->frame->linesize[0] * CDG_FULL_HEIGHT);\n            break;\n        case CDG_INST_LOAD_PAL_LO:\n        case CDG_INST_LOAD_PAL_HIGH:\n            if (buf_size - CDG_HEADER_SIZE < CDG_DATA_SIZE) {\n                av_log(avctx, AV_LOG_ERROR, \"buffer too small for loading palette\\n\");\n                return AVERROR(EINVAL);\n            }\n\n            cdg_load_palette(cc, cdg_data, inst == CDG_INST_LOAD_PAL_LO);\n            break;\n        case CDG_INST_BORDER_PRESET:\n            cdg_border_preset(cc, cdg_data);\n            break;\n        case CDG_INST_TILE_BLOCK_XOR:\n        case CDG_INST_TILE_BLOCK:\n            if (buf_size - CDG_HEADER_SIZE < CDG_DATA_SIZE) {\n                av_log(avctx, AV_LOG_ERROR, \"buffer too small for drawing tile\\n\");\n                return AVERROR(EINVAL);\n            }\n\n            ret = cdg_tile_block(cc, cdg_data, inst == CDG_INST_TILE_BLOCK_XOR);\n            if (ret) {\n                av_log(avctx, AV_LOG_ERROR, \"tile is out of range\\n\");\n                return ret;\n            }\n            break;\n        case CDG_INST_SCROLL_PRESET:\n        case CDG_INST_SCROLL_COPY:\n            if (buf_size - CDG_HEADER_SIZE < CDG_MINIMUM_SCROLL_SIZE) {\n                av_log(avctx, AV_LOG_ERROR, \"buffer too small for scrolling\\n\");\n                return AVERROR(EINVAL);\n            }\n\n            if ((ret = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n                return ret;\n\n            cdg_scroll(cc, cdg_data, frame, inst == CDG_INST_SCROLL_COPY);\n            av_frame_unref(cc->frame);\n            ret = av_frame_ref(cc->frame, frame);\n            if (ret < 0)\n                return ret;\n            break;\n        default:\n            break;\n        }\n\n        if (!frame->data[0]) {\n            ret = av_frame_ref(frame, cc->frame);\n            if (ret < 0)\n                return ret;\n        }\n        *got_frame = 1;\n    } else {\n        *got_frame = 0;\n        buf_size   = 0;\n    }\n\n    return buf_size;\n}", "target": 0}
{"idx": 5314, "func": "static int wsd_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    int version;\n    uint32_t text_offset, data_offset, channel_assign;\n    char playback_time[AV_TIMECODE_STR_SIZE];\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    avio_skip(pb, 8);\n    version = avio_r8(pb);\n    av_log(s, AV_LOG_DEBUG, \"version: %i.%i\\n\", version >> 4, version & 0xF);\n    avio_skip(pb, 11);\n\n    if (version < 0x10) {\n        text_offset = 0x80;\n        data_offset = 0x800;\n        avio_skip(pb, 8);\n    } else {\n        text_offset = avio_rb32(pb);\n        data_offset = avio_rb32(pb);\n    }\n\n    avio_skip(pb, 4);\n    av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);\n    av_dict_set(&s->metadata, \"playback_time\", playback_time, 0);\n\n    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n    st->codecpar->codec_id    = s->iformat->raw_codec_id;\n    st->codecpar->sample_rate = avio_rb32(pb) / 8;\n    avio_skip(pb, 4);\n    st->codecpar->channels    = avio_r8(pb) & 0xF;\n    st->codecpar->bit_rate    = st->codecpar->channels * st->codecpar->sample_rate * 8LL;\n    if (!st->codecpar->channels)\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 3);\n    channel_assign         = avio_rb32(pb);\n    if (!(channel_assign & 1)) {\n        int i;\n        for (i = 1; i < 32; i++)\n            if (channel_assign & (1 << i))\n                st->codecpar->channel_layout |= wsd_to_av_channel_layoyt(s, i);\n    }\n\n    avio_skip(pb, 16);\n    if (avio_rb32(pb))\n       avpriv_request_sample(s, \"emphasis\");\n\n    if (avio_seek(pb, text_offset, SEEK_SET) >= 0) {\n        get_metadata(s, \"title\",       128);\n        get_metadata(s, \"composer\",    128);\n        get_metadata(s, \"song_writer\", 128);\n        get_metadata(s, \"artist\",      128);\n        get_metadata(s, \"album\",       128);\n        get_metadata(s, \"genre\",        32);\n        get_metadata(s, \"date\",         32);\n        get_metadata(s, \"location\",     32);\n        get_metadata(s, \"comment\",     512);\n        get_metadata(s, \"user\",        512);\n    }\n\n    return avio_seek(pb, data_offset, SEEK_SET);\n}", "target": 1}
{"idx": 5315, "func": "int ff_rtmp_packet_read_internal(URLContext *h, RTMPPacket *p, int chunk_size,\n                                 RTMPPacket *prev_pkt, uint8_t hdr)\n{\n\n    uint8_t t, buf[16];\n    int channel_id, timestamp, data_size, offset = 0;\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int size = 0;\n    int ret;\n\n    size++;\n    channel_id = hdr & 0x3F;\n\n    if (channel_id < 2) { //special case for channel number >= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        size += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    }\n    data_size = prev_pkt[channel_id].data_size;\n    type      = prev_pkt[channel_id].type;\n    extra     = prev_pkt[channel_id].extra;\n\n    hdr >>= 6;\n    if (hdr == RTMP_PS_ONEBYTE) {\n        timestamp = prev_pkt[channel_id].ts_delta;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        size += 3;\n        timestamp = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            size += 3;\n            data_size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            size++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                size += 4;\n                extra = AV_RL32(buf);\n            }\n        }\n        if (timestamp == 0xFFFFFF) {\n            if (ffurl_read_complete(h, buf, 4) != 4)\n                return AVERROR(EIO);\n            timestamp = AV_RB32(buf);\n        }\n    }\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n\n    if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                     data_size)) < 0)\n        return ret;\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].data_size  = data_size;\n    prev_pkt[channel_id].ts_delta   = timestamp - prev_pkt[channel_id].timestamp;\n    prev_pkt[channel_id].timestamp  = timestamp;\n    prev_pkt[channel_id].extra      = extra;\n    while (data_size > 0) {\n        int toread = FFMIN(data_size, chunk_size);\n        if (ffurl_read_complete(h, p->data + offset, toread) != toread) {\n            ff_rtmp_packet_destroy(p);\n            return AVERROR(EIO);\n        }\n        data_size -= chunk_size;\n        offset    += chunk_size;\n        size      += chunk_size;\n        if (data_size > 0) {\n            if ((ret = ffurl_read_complete(h, &t, 1)) < 0) { // marker\n                ff_rtmp_packet_destroy(p);\n                return ret;\n            }\n            size++;\n            if (t != (0xC0 + channel_id))\n                return -1;\n        }\n    }\n    return size;\n}", "target": 0}
{"idx": 5316, "func": "static av_cold int decode_init(AVCodecContext *avctx)\n{\n    IffContext *s = avctx->priv_data;\n    int err;\n\n    if (avctx->bits_per_coded_sample <= 8) {\n        avctx->pix_fmt = PIX_FMT_PAL8;\n    } else if (avctx->bits_per_coded_sample <= 32) {\n        avctx->pix_fmt = PIX_FMT_BGR32;\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->planesize = avctx->width / 8;\n    s->planebuf = av_malloc(s->planesize + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!s->planebuf)\n        return AVERROR(ENOMEM);\n\n    s->frame.reference = 1;\n    if ((err = avctx->get_buffer(avctx, &s->frame) < 0)) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return err;\n    }\n\n    return avctx->bits_per_coded_sample <= 8 ?\n       ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1]) : 0;\n}", "target": 1}
{"idx": 5317, "func": "int ENGINE_finish(ENGINE *e)\n\t{\n\tint to_return = 1;\n\n\tif(e == NULL)\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_FINISH,ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t\t}\n\tCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\n\tif((e->funct_ref == 1) && e->finish)\n#if 0\n\t\t/* This is the last functional reference and the engine\n\t\t * requires cleanup so we do it now. */\n\t\tto_return = e->finish();\n\tif(to_return)\n\t\t{\n\t\t/* Cleanup the functional reference which is also a\n\t\t * structural reference. */\n\t\te->struct_ref--;\n\t\te->funct_ref--;\n\t\t}\n\tCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\n#else\n\t\t/* I'm going to deliberately do a convoluted version of this\n\t\t * piece of code because we don't want \"finish\" functions\n\t\t * being called inside a locked block of code, if at all\n\t\t * possible. I'd rather have this call take an extra couple\n\t\t * of ticks than have throughput serialised on a externally-\n\t\t * provided callback function that may conceivably never come\n\t\t * back. :-( */\n\t\t{\n\t\tCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\n\t\t/* CODE ALERT: This *IS* supposed to be \"=\" and NOT \"==\" :-) */\n\t\tif((to_return = e->finish()))\n\t\t\t{\n\t\t\tCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\n\t\t\t/* Cleanup the functional reference which is also a\n\t\t\t * structural reference. */\n\t\t\te->struct_ref--;\n\t\t\te->funct_ref--;\n\t\t\tCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\n\t\t\t}\n\t\t}\n\telse\n\t\tCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\n#endif\n\treturn to_return;\n\t}", "target": 1}
{"idx": 5318, "func": "static int opt_streamid(const char *opt, const char *arg)\n{\n    int idx;\n    char *p;\n    char idx_str[16];\n\n    av_strlcpy(idx_str, arg, sizeof(idx_str));\n    p = strchr(idx_str, ':');\n    if (!p) {\n        fprintf(stderr,\n                \"Invalid value '%s' for option '%s', required syntax is 'index:value'\\n\",\n                arg, opt);\n        ffmpeg_exit(1);\n    }\n    *p++ = '\\0';\n    idx = parse_number_or_die(opt, idx_str, OPT_INT, 0, MAX_STREAMS-1);\n    streamid_map = grow_array(streamid_map, sizeof(*streamid_map), &nb_streamid_map, idx+1);\n    streamid_map[idx] = parse_number_or_die(opt, p, OPT_INT, 0, INT_MAX);\n    return 0;\n}", "target": 0}
{"idx": 5319, "func": "static int ape_read_packet(AVFormatContext * s, AVPacket * pkt)\n{\n    int ret;\n    int nblocks;\n    APEContext *ape = s->priv_data;\n    uint32_t extra_size = 8;\n\n    if (url_feof(s->pb))\n        return AVERROR_EOF;\n    if (ape->currentframe >= ape->totalframes)\n        return AVERROR_EOF;\n\n    if (avio_seek(s->pb, ape->frames[ape->currentframe].pos, SEEK_SET) < 0)\n        return AVERROR(EIO);\n\n    /* Calculate how many blocks there are in this frame */\n    if (ape->currentframe == (ape->totalframes - 1))\n        nblocks = ape->finalframeblocks;\n    else\n        nblocks = ape->blocksperframe;\n\n    if (ape->frames[ape->currentframe].size <= 0 ||\n        ape->frames[ape->currentframe].size > INT_MAX - extra_size) {\n        av_log(s, AV_LOG_ERROR, \"invalid packet size: %d\\n\",\n               ape->frames[ape->currentframe].size);\n        ape->currentframe++;\n        return AVERROR(EIO);\n    }\n\n    if (av_new_packet(pkt,  ape->frames[ape->currentframe].size + extra_size) < 0)\n        return AVERROR(ENOMEM);\n\n    AV_WL32(pkt->data    , nblocks);\n    AV_WL32(pkt->data + 4, ape->frames[ape->currentframe].skip);\n    ret = avio_read(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);\n\n    pkt->pts = ape->frames[ape->currentframe].pts;\n    pkt->stream_index = 0;\n\n    /* note: we need to modify the packet size here to handle the last\n       packet */\n    pkt->size = ret + extra_size;\n\n    ape->currentframe++;\n\n    return 0;\n}", "target": 1}
{"idx": 5320, "func": "int MAIN(int argc, char **argv)\n\t{\n\tPKCS7 *p7=NULL;\n\tint i,badops=0;\n\tBIO *in=NULL,*out=NULL;\n\tint informat,outformat;\n\tchar *infile,*outfile,*prog;\n\tint print_certs=0,text=0,noout=0;\n\tint ret=0;\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\tinfile=NULL;\n\toutfile=NULL;\n\tinformat=FORMAT_PEM;\n\toutformat=FORMAT_PEM;\n\n\tprog=argv[0];\n\targc--;\n\targv++;\n\twhile (argc >= 1)\n\t\t{\n\t\tif \t(strcmp(*argv,\"-inform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-outform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-in\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-out\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-noout\") == 0)\n\t\t\tnoout=1;\n\t\telse if (strcmp(*argv,\"-text\") == 0)\n\t\t\ttext=1;\n\t\telse if (strcmp(*argv,\"-print_certs\") == 0)\n\t\t\tprint_certs=1;\n\t\telse\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\n\t\t\tbadops=1;\n\t\t\tbreak;\n\t\t\t}\n\t\targc--;\n\t\targv++;\n\t\t}\n\n\tif (badops)\n\t\t{\nbad:\n\t\tBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\n\t\tBIO_printf(bio_err,\"where options are\\n\");\n\t\tBIO_printf(bio_err,\" -inform arg   input format - DER or PEM\\n\");\n\t\tBIO_printf(bio_err,\" -outform arg  output format - DER or PEM\\n\");\n\t\tBIO_printf(bio_err,\" -in arg       input file\\n\");\n\t\tBIO_printf(bio_err,\" -out arg      output file\\n\");\n\t\tBIO_printf(bio_err,\" -print_certs  print any certs or crl in the input\\n\");\n\t\tBIO_printf(bio_err,\" -text         print full details of certificates\\n\");\n\t\tBIO_printf(bio_err,\" -noout        don't output encoded data\\n\");\n\t\tEXIT(1);\n\t\t}\n\n\tERR_load_crypto_strings();\n\n\tin=BIO_new(BIO_s_file());\n\tout=BIO_new(BIO_s_file());\n\tif ((in == NULL) || (out == NULL))\n\t\t{\n\t\tERR_print_errors(bio_err);\n                goto end;\n                }\n\n\tif (infile == NULL)\n\t\tBIO_set_fp(in,stdin,BIO_NOCLOSE);\n\telse\n\t\t{\n\t\tif (BIO_read_filename(in,infile) <= 0)\n\t\tif (in == NULL)\n\t\t\t{\n\t\t\tperror(infile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif\t(informat == FORMAT_ASN1)\n\t\tp7=d2i_PKCS7_bio(in,NULL);\n\telse if (informat == FORMAT_PEM)\n\t\tp7=PEM_read_bio_PKCS7(in,NULL,NULL,NULL);\n\telse\n\t\t{\n\t\tBIO_printf(bio_err,\"bad input format specified for pkcs7 object\\n\");\n\t\tgoto end;\n\t\t}\n\tif (p7 == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to load PKCS7 object\\n\");\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (outfile == NULL)\n\t\t{\n\t\tBIO_set_fp(out,stdout,BIO_NOCLOSE);\n#ifdef VMS\n\t\t{\n\t\tBIO *tmpbio = BIO_new(BIO_f_linebuffer());\n\t\tout = BIO_push(tmpbio, out);\n\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\tif (BIO_write_filename(out,outfile) <= 0)\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif (print_certs)\n\t\t{\n\t\tSTACK_OF(X509) *certs=NULL;\n\t\tSTACK_OF(X509_CRL) *crls=NULL;\n\n\t\ti=OBJ_obj2nid(p7->type);\n\t\tswitch (i)\n\t\t\t{\n\t\tcase NID_pkcs7_signed:\n\t\t\tcerts=p7->d.sign->cert;\n\t\t\tcrls=p7->d.sign->crl;\n\t\t\tbreak;\n\t\tcase NID_pkcs7_signedAndEnveloped:\n\t\t\tcerts=p7->d.signed_and_enveloped->cert;\n\t\t\tcrls=p7->d.signed_and_enveloped->crl;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t\t}\n\n\t\tif (certs != NULL)\n\t\t\t{\n\t\t\tX509 *x;\n\n\t\t\tfor (i=0; i<sk_X509_num(certs); i++)\n\t\t\t\t{\n\t\t\t\tx=sk_X509_value(certs,i);\n\t\t\t\tif(text) X509_print(out, x);\n\t\t\t\telse dump_cert_text(out, x);\n\n\t\t\t\tif(!noout) PEM_write_bio_X509(out,x);\n\t\t\t\tBIO_puts(out,\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\tif (crls != NULL)\n\t\t\t{\n\t\t\tX509_CRL *crl;\n\n\t\t\tfor (i=0; i<sk_X509_CRL_num(crls); i++)\n\t\t\t\t{\n\t\t\t\tcrl=sk_X509_CRL_value(crls,i);\n\n\t\t\t\tX509_CRL_print(out, crl);\n\n\t\t\t\tif(!noout)PEM_write_bio_X509_CRL(out,crl);\n\t\t\t\tBIO_puts(out,\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\tret=0;\n\t\tgoto end;\n\t\t}\n\n\tif(!noout) {\n\t\tif \t(outformat == FORMAT_ASN1)\n\t\t\ti=i2d_PKCS7_bio(out,p7);\n\t\telse if (outformat == FORMAT_PEM)\n\t\t\ti=PEM_write_bio_PKCS7(out,p7);\n\t\telse\t{\n\t\t\tBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\n\t\tif (!i)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unable to write pkcs7 object\\n\");\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t}\n\tret=0;\nend:\n\tif (p7 != NULL) PKCS7_free(p7);\n\tif (in != NULL) BIO_free(in);\n\tif (out != NULL) BIO_free_all(out);\n\tEXIT(ret);\n\t}", "target": 0}
{"idx": 5321, "func": "static int mkv_write_tracks(AVFormatContext *s)\n{\n    MatroskaMuxContext *mkv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int i, ret, default_stream_exists = 0;\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_TRACKS, avio_tell(pb));\n    if (ret < 0)\n        return ret;\n\n    ret = start_ebml_master_crc32(pb, &mkv->tracks_bc, mkv, &mkv->tracks_master, MATROSKA_ID_TRACKS, 0);\n    if (ret < 0)\n        return ret;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        default_stream_exists |= st->disposition & AV_DISPOSITION_DEFAULT;\n    }\n    for (i = 0; i < s->nb_streams; i++) {\n        ret = mkv_write_track(s, mkv, i, mkv->tracks_bc, default_stream_exists);\n        if (ret < 0)\n            return ret;\n    }\n\n    if (pb->seekable && !mkv->is_live)\n        end_ebml_master_crc32_preliminary(pb, &mkv->tracks_bc, mkv, mkv->tracks_master);\n    else\n        end_ebml_master_crc32(pb, &mkv->tracks_bc, mkv, mkv->tracks_master);\n\n    return 0;\n}", "target": 0}
{"idx": 5322, "func": "int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)\n\t{\n\tint ret = 0;\n\tstruct sockaddr_un addr;\n\tint len, num, numbytes;\n\tint fd = -1;\n\tint success;\n\tunsigned char egdbuf[2], tempbuf[255], *retrievebuf;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tif (strlen(path) >= sizeof(addr.sun_path))\n\t\treturn (-1);\n\tBUF_strlcpy(addr.sun_path,path,sizeof addr.sun_path);\n\tlen = offsetof(struct sockaddr_un, sun_path) + strlen(path);\n\tfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (fd == -1) return (-1);\n\tsuccess = 0;\n\twhile (!success)\n\t    {\n\t    if (connect(fd, (struct sockaddr *)&addr, len) == 0)\n\t       success = 1;\n\t    else\n\t\t{\n\t\tswitch (errno)\n\t\t    {\n#ifdef EINTR\n\t\t    case EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    case EAGAIN:\n#endif\n#ifdef EINPROGRESS\n\t\t    case EINPROGRESS:\n#endif\n#ifdef EALREADY\n\t\t    case EALREADY:\n#endif\n\t\t\t/* No error, try again */\n\t\t\tbreak;\n#ifdef EISCONN\n\t\t    case EISCONN:\n\t\t\tsuccess = 1;\n\t\t\tbreak;\n#endif\n\t\t    default:\n\t\t\tgoto err;\t/* failure */\n\t\t    }\n\t\t}\n\t    }\n\n\twhile(bytes > 0)\n\t    {\n\t    egdbuf[0] = 1;\n\t    egdbuf[1] = bytes < 255 ? bytes : 255;\n\t    numbytes = 0;\n\t    while (numbytes != 2)\n\t\t{\n\t        num = write(fd, egdbuf + numbytes, 2 - numbytes);\n\t        if (num >= 0)\n\t\t    numbytes += num;\n\t    \telse\n\t\t    {\n\t\t    switch (errno)\n\t\t    \t{\n#ifdef EINTR\n\t\t    \tcase EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    \tcase EAGAIN:\n#endif\n\t\t\t    /* No error, try again */\n\t\t\t    break;\n\t\t    \tdefault:\n\t\t\t    ret = -1;\n\t\t\t    goto err;\t/* failure */\n\t\t\t}\n\t\t    }\n\t\t}\n\t    numbytes = 0;\n\t    while (numbytes != 1)\n\t\t{\n\t        num = read(fd, egdbuf, 1);\n\t        if (num >= 0)\n\t\t    numbytes += num;\n\t    \telse\n\t\t    {\n\t\t    switch (errno)\n\t\t    \t{\n#ifdef EINTR\n\t\t    \tcase EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    \tcase EAGAIN:\n#endif\n\t\t\t    /* No error, try again */\n\t\t\t    break;\n\t\t    \tdefault:\n\t\t\t    ret = -1;\n\t\t\t    goto err;\t/* failure */\n\t\t\t}\n\t\t    }\n\t\t}\n\t    if(egdbuf[0] == 0)\n\t\tgoto err;\n\t    if (buf)\n\t\tretrievebuf = buf + ret;\n\t    else\n\t\tretrievebuf = tempbuf;\n\t    numbytes = 0;\n\t    while (numbytes != egdbuf[0])\n\t\t{\n\t        num = read(fd, retrievebuf + numbytes, egdbuf[0] - numbytes);\n\t        if (num >= 0)\n\t\t    numbytes += num;\n\t    \telse\n\t\t    {\n\t\t    switch (errno)\n\t\t    \t{\n#ifdef EINTR\n\t\t    \tcase EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    \tcase EAGAIN:\n#endif\n\t\t\t    /* No error, try again */\n\t\t\t    break;\n\t\t    \tdefault:\n\t\t\t    ret = -1;\n\t\t\t    goto err;\t/* failure */\n\t\t\t}\n\t\t    }\n\t\t}\n\t    ret += egdbuf[0];\n\t    bytes -= egdbuf[0];\n\t    if (!buf)\n\t\tRAND_seed(tempbuf, egdbuf[0]);\n\t    }\n err:\n\tif (fd != -1) close(fd);\n\treturn(ret);\n\t}", "target": 0}
{"idx": 5323, "func": "static void chroma(WaveformContext *s, AVFrame *in, AVFrame *out,\n                   int component, int intensity, int offset, int column)\n{\n    const int plane = s->desc->comp[component].plane;\n    const int mirror = s->mirror;\n    const int c0_linesize = in->linesize[(plane + 1) % s->ncomp];\n    const int c1_linesize = in->linesize[(plane + 2) % s->ncomp];\n    const int dst_linesize = out->linesize[plane];\n    const int max = 255 - intensity;\n    const int src_h = in->height;\n    const int src_w = in->width;\n    int x, y;\n\n    if (column) {\n        const int dst_signed_linesize = dst_linesize * (mirror == 1 ? -1 : 1);\n\n        for (x = 0; x < src_w; x++) {\n            const uint8_t *c0_data = in->data[(plane + 1) % s->ncomp];\n            const uint8_t *c1_data = in->data[(plane + 2) % s->ncomp];\n            uint8_t *dst_data = out->data[plane] + offset * dst_linesize;\n            uint8_t * const dst_bottom_line = dst_data + dst_linesize * (s->size - 1);\n            uint8_t * const dst_line = (mirror ? dst_bottom_line : dst_data);\n            uint8_t *dst = dst_line;\n\n            for (y = 0; y < src_h; y++) {\n                const int sum = FFABS(c0_data[x] - 128) + FFABS(c1_data[x] - 128);\n                uint8_t *target;\n\n                target = dst + x + dst_signed_linesize * (256 - sum);\n                update(target, max, intensity);\n                target = dst + x + dst_signed_linesize * (255 + sum);\n                update(target, max, intensity);\n\n                c0_data += c0_linesize;\n                c1_data += c1_linesize;\n                dst_data += dst_linesize;\n            }\n        }\n    } else {\n        const uint8_t *c0_data = in->data[(plane + 1) % s->ncomp];\n        const uint8_t *c1_data = in->data[(plane + 2) % s->ncomp];\n        uint8_t *dst_data = out->data[plane] + offset;\n\n        if (mirror)\n            dst_data += s->size - 1;\n        for (y = 0; y < src_h; y++) {\n            for (x = 0; x < src_w; x++) {\n                const int sum = FFABS(c0_data[x] - 128) + FFABS(c1_data[x] - 128);\n                uint8_t *target;\n\n                if (mirror) {\n                    target = dst_data - (256 - sum);\n                    update(target, max, intensity);\n                    target = dst_data - (255 + sum);\n                    update(target, max, intensity);\n                } else {\n                    target = dst_data + (256 - sum);\n                    update(target, max, intensity);\n                    target = dst_data + (255 + sum);\n                    update(target, max, intensity);\n                }\n            }\n\n            c0_data += c0_linesize;\n            c1_data += c1_linesize;\n            dst_data += dst_linesize;\n        }\n    }\n\n    envelope(s, out, plane, (plane + 0) % s->ncomp);\n}", "target": 0}
{"idx": 5324, "func": "static int sh_init(size_t size, int minsize)\n{\n    int ret;\n    size_t i;\n    size_t pgsize;\n    size_t aligned;\n\n    memset(&sh, 0, sizeof sh);\n\n    /* make sure size and minsize are powers of 2 */\n    OPENSSL_assert(size > 0);\n    OPENSSL_assert((size & (size - 1)) == 0);\n    OPENSSL_assert(minsize > 0);\n    OPENSSL_assert((minsize & (minsize - 1)) == 0);\n    if (size <= 0 || (size & (size - 1)) != 0)\n        goto err;\n    if (minsize <= 0 || (minsize & (minsize - 1)) != 0)\n        goto err;\n\n    while (minsize < (int)sizeof(SH_LIST))\n        minsize *= 2;\n\n    sh.arena_size = size;\n    sh.minsize = minsize;\n    sh.bittable_size = (sh.arena_size / sh.minsize) * 2;\n\n    /* Prevent allocations of size 0 later on */\n    if (sh.bittable_size >> 3 == 0)\n        goto err;\n\n    sh.freelist_size = -1;\n    for (i = sh.bittable_size; i; i >>= 1)\n        sh.freelist_size++;\n\n    sh.freelist = OPENSSL_zalloc(sh.freelist_size * sizeof (char *));\n    OPENSSL_assert(sh.freelist != NULL);\n    if (sh.freelist == NULL)\n        goto err;\n\n    sh.bittable = OPENSSL_zalloc(sh.bittable_size >> 3);\n    OPENSSL_assert(sh.bittable != NULL);\n    if (sh.bittable == NULL)\n        goto err;\n\n    sh.bitmalloc = OPENSSL_zalloc(sh.bittable_size >> 3);\n    OPENSSL_assert(sh.bitmalloc != NULL);\n    if (sh.bitmalloc == NULL)\n        goto err;\n\n    /* Allocate space for heap, and two extra pages as guards */\n#if defined(_SC_PAGE_SIZE) || defined (_SC_PAGESIZE)\n    {\n# if defined(_SC_PAGE_SIZE)\n        long tmppgsize = sysconf(_SC_PAGE_SIZE);\n# else\n        long tmppgsize = sysconf(_SC_PAGESIZE);\n# endif\n        if (tmppgsize < 1)\n            pgsize = PAGE_SIZE;\n        else\n            pgsize = (size_t)tmppgsize;\n    }\n#else\n    pgsize = PAGE_SIZE;\n#endif\n    sh.map_size = pgsize + sh.arena_size + pgsize;\n    if (1) {\n#ifdef MAP_ANON\n        sh.map_result = mmap(NULL, sh.map_size,\n                             PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);\n    } else {\n#endif\n        int fd;\n\n        sh.map_result = MAP_FAILED;\n        if ((fd = open(\"/dev/zero\", O_RDWR)) >= 0) {\n            sh.map_result = mmap(NULL, sh.map_size,\n                                 PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);\n            close(fd);\n        }\n    }\n    OPENSSL_assert(sh.map_result != MAP_FAILED);\n    if (sh.map_result == MAP_FAILED)\n        goto err;\n    sh.arena = (char *)(sh.map_result + pgsize);\n    sh_setbit(sh.arena, 0, sh.bittable);\n    sh_add_to_list(&sh.freelist[0], sh.arena);\n\n    /* Now try to add guard pages and lock into memory. */\n    ret = 1;\n\n    /* Starting guard is already aligned from mmap. */\n    if (mprotect(sh.map_result, pgsize, PROT_NONE) < 0)\n        ret = 2;\n\n    /* Ending guard page - need to round up to page boundary */\n    aligned = (pgsize + sh.arena_size + (pgsize - 1)) & ~(pgsize - 1);\n    if (mprotect(sh.map_result + aligned, pgsize, PROT_NONE) < 0)\n        ret = 2;\n\n#if defined(OPENSSL_SYS_LINUX) && defined(MLOCK_ONFAULT) && defined(SYS_mlock2)\n    if (syscall(SYS_mlock2, sh.arena, sh.arena_size, MLOCK_ONFAULT) < 0) {\n        if (errno == ENOSYS) {\n            if (mlock(sh.arena, sh.arena_size) < 0)\n                ret = 2;\n        } else {\n            ret = 2;\n        }\n    }\n#else\n    if (mlock(sh.arena, sh.arena_size) < 0)\n        ret = 2;\n#endif\n#ifdef MADV_DONTDUMP\n    if (madvise(sh.arena, sh.arena_size, MADV_DONTDUMP) < 0)\n        ret = 2;\n#endif\n\n    return ret;\n\n err:\n    sh_done();\n    return 0;\n}", "target": 0}
{"idx": 5325, "func": "STACK_OF(SSL_CIPHER) *ssl_create_cipher_list(const SSL_METHOD *ssl_method,\n\t\tSTACK_OF(SSL_CIPHER) **cipher_list,\n\t\tSTACK_OF(SSL_CIPHER) **cipher_list_by_id,\n\t\tconst char *rule_str)\n\t{\n\tint ok, num_of_ciphers, num_of_alias_max, num_of_group_aliases;\n\tunsigned long disabled_mkey, disabled_auth, disabled_enc, disabled_mac, disabled_ssl;\n\tSTACK_OF(SSL_CIPHER) *cipherstack, *tmp_cipher_list;\n\tconst char *rule_p;\n\tCIPHER_ORDER *co_list = NULL, *head = NULL, *tail = NULL, *curr;\n\tconst SSL_CIPHER **ca_list = NULL;\n\n\t/*\n\t * Return with error if nothing to do.\n\t */\n\tif (rule_str == NULL || cipher_list == NULL || cipher_list_by_id == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * To reduce the work to do we only want to process the compiled\n\t * in algorithms, so we first get the mask of disabled ciphers.\n\t */\n\tssl_cipher_get_disabled(&disabled_mkey, &disabled_auth, &disabled_enc, &disabled_mac, &disabled_ssl);\n\n\t/*\n\t * Now we have to collect the available ciphers from the compiled\n\t * in ciphers. We cannot get more than the number compiled in, so\n\t * it is used for allocation.\n\t */\n\tnum_of_ciphers = ssl_method->num_ciphers();\n#ifdef KSSL_DEBUG\n\tprintf(\"ssl_create_cipher_list() for %d ciphers\\n\", num_of_ciphers);\n#endif    /* KSSL_DEBUG */\n\tco_list = (CIPHER_ORDER *)OPENSSL_malloc(sizeof(CIPHER_ORDER) * num_of_ciphers);\n\tif (co_list == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_CREATE_CIPHER_LIST,ERR_R_MALLOC_FAILURE);\n\t\treturn(NULL);\t/* Failure */\n\t\t}\n\n\tssl_cipher_collect_ciphers(ssl_method, num_of_ciphers,\n\t                           disabled_mkey, disabled_auth, disabled_enc, disabled_mac, disabled_ssl,\n\t                           co_list, &head, &tail);\n\n\n\t/* Now arrange all ciphers by preference: */\n\n\t/* Everything else being equal, prefer ephemeral ECDH over other key exchange mechanisms */\n\tssl_cipher_apply_rule(0, SSL_kEECDH, 0, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);\n\tssl_cipher_apply_rule(0, SSL_kEECDH, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head, &tail);\n\n\t/* AES is our preferred symmetric cipher */\n\tssl_cipher_apply_rule(0, 0, 0, SSL_AES, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);\n\n\t/* Temporarily enable everything else for sorting */\n\tssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);\n\n\t/* Low priority for MD5 */\n\tssl_cipher_apply_rule(0, 0, 0, 0, SSL_MD5, 0, 0, CIPHER_ORD, -1, &head, &tail);\n\n\t/* Move anonymous ciphers to the end.  Usually, these will remain disabled.\n\t * (For applications that allow them, they aren't too bad, but we prefer\n\t * authenticated ciphers.) */\n\tssl_cipher_apply_rule(0, 0, SSL_aNULL, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);\n\n\t/* Move ciphers without forward secrecy to the end */\n\tssl_cipher_apply_rule(0, 0, SSL_aECDH, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);\n\t/* ssl_cipher_apply_rule(0, 0, SSL_aDH, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail); */\n\tssl_cipher_apply_rule(0, SSL_kRSA, 0, 0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);\n\tssl_cipher_apply_rule(0, SSL_kPSK, 0,0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);\n\tssl_cipher_apply_rule(0, SSL_kKRB5, 0,0, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);\n\n\t/* RC4 is sort-of broken -- move the the end */\n\tssl_cipher_apply_rule(0, 0, 0, SSL_RC4, 0, 0, 0, CIPHER_ORD, -1, &head, &tail);\n\n\t/* Now sort by symmetric encryption strength.  The above ordering remains\n\t * in force within each class */\n\tif (!ssl_cipher_strength_sort(&head, &tail))\n\t\t{\n\t\tOPENSSL_free(co_list);\n\t\treturn NULL;\n\t\t}\n\n\t/* Now disable everything (maintaining the ordering!) */\n\tssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head, &tail);\n\n\n\t/*\n\t * We also need cipher aliases for selecting based on the rule_str.\n\t * There might be two types of entries in the rule_str: 1) names\n\t * of ciphers themselves 2) aliases for groups of ciphers.\n\t * For 1) we need the available ciphers and for 2) the cipher\n\t * groups of cipher_aliases added together in one list (otherwise\n\t * we would be happy with just the cipher_aliases table).\n\t */\n\tnum_of_group_aliases = sizeof(cipher_aliases) / sizeof(SSL_CIPHER);\n\tnum_of_alias_max = num_of_ciphers + num_of_group_aliases + 1;\n\tca_list = OPENSSL_malloc(sizeof(SSL_CIPHER *) * num_of_alias_max);\n\tif (ca_list == NULL)\n\t\t{\n\t\tOPENSSL_free(co_list);\n\t\tSSLerr(SSL_F_SSL_CREATE_CIPHER_LIST,ERR_R_MALLOC_FAILURE);\n\t\treturn(NULL);\t/* Failure */\n\t\t}\n\tssl_cipher_collect_aliases(ca_list, num_of_group_aliases,\n\t                           disabled_mkey, disabled_auth, disabled_enc,\n\t\t\t\t   disabled_mac, disabled_ssl, head);\n\n\t/*\n\t * If the rule_string begins with DEFAULT, apply the default rule\n\t * before using the (possibly available) additional rules.\n\t */\n\tok = 1;\n\trule_p = rule_str;\n\tif (strncmp(rule_str,\"DEFAULT\",7) == 0)\n\t\t{\n\t\tok = ssl_cipher_process_rulestr(SSL_DEFAULT_CIPHER_LIST,\n\t\t\t&head, &tail, ca_list);\n\t\trule_p += 7;\n\t\tif (*rule_p == ':')\n\t\t\trule_p++;\n\t\t}\n\n\tif (ok && (strlen(rule_p) > 0))\n\t\tok = ssl_cipher_process_rulestr(rule_p, &head, &tail, ca_list);\n\n\tOPENSSL_free((void *)ca_list);\t/* Not needed anymore */\n\n\tif (!ok)\n\t\t{\t/* Rule processing failure */\n\t\tOPENSSL_free(co_list);\n\t\treturn(NULL);\n\t\t}\n\t\n\t/*\n\t * Allocate new \"cipherstack\" for the result, return with error\n\t * if we cannot get one.\n\t */\n\tif ((cipherstack = sk_SSL_CIPHER_new_null()) == NULL)\n\t\t{\n\t\tOPENSSL_free(co_list);\n\t\treturn(NULL);\n\t\t}\n\n\t/*\n\t * The cipher selection for the list is done. The ciphers are added\n\t * to the resulting precedence to the STACK_OF(SSL_CIPHER).\n\t */\n\tfor (curr = head; curr != NULL; curr = curr->next)\n\t\t{\n#ifdef OPENSSL_FIPS\n\t\tif (curr->active && (!FIPS_mode() || curr->cipher->algo_strength & SSL_FIPS))\n#else\n\t\tif (curr->active)\n#endif\n\t\t\t{\n\t\t\tsk_SSL_CIPHER_push(cipherstack, curr->cipher);\n#ifdef CIPHER_DEBUG\n\t\t\tprintf(\"<%s>\\n\",curr->cipher->name);\n#endif\n\t\t\t}\n\t\t}\n\tOPENSSL_free(co_list);\t/* Not needed any longer */\n\n\ttmp_cipher_list = sk_SSL_CIPHER_dup(cipherstack);\n\tif (tmp_cipher_list == NULL)\n\t\t{\n\t\tsk_SSL_CIPHER_free(cipherstack);\n\t\treturn NULL;\n\t\t}\n\tif (*cipher_list != NULL)\n\t\tsk_SSL_CIPHER_free(*cipher_list);\n\t*cipher_list = cipherstack;\n\tif (*cipher_list_by_id != NULL)\n\t\tsk_SSL_CIPHER_free(*cipher_list_by_id);\n\t*cipher_list_by_id = tmp_cipher_list;\n\t(void)sk_SSL_CIPHER_set_cmp_func(*cipher_list_by_id,ssl_cipher_ptr_id_cmp);\n\n\tsk_SSL_CIPHER_sort(*cipher_list_by_id);\n\treturn(cipherstack);\n\t}", "target": 1}
{"idx": 5326, "func": "static uint8_t *ogg_write_vorbiscomment(int64_t offset, int bitexact,\n                                        int *header_len, AVDictionary **m, int framing_bit)\n{\n    const char *vendor = bitexact ? \"ffmpeg\" : LIBAVFORMAT_IDENT;\n    int64_t size;\n    uint8_t *p, *p0;\n\n    ff_metadata_conv(m, ff_vorbiscomment_metadata_conv, NULL);\n\n    size = offset + ff_vorbiscomment_length(*m, vendor) + framing_bit;\n    if (size > INT_MAX)\n        return NULL;\n    p = av_mallocz(size);\n    if (!p)\n        return NULL;\n    p0 = p;\n\n    p += offset;\n    ff_vorbiscomment_write(&p, m, vendor);\n    if (framing_bit)\n        bytestream_put_byte(&p, 1);\n\n    *header_len = size;\n    return p0;\n}", "target": 0}
{"idx": 5327, "func": "static int theora_packet(AVFormatContext *s, int idx)\n{\n    struct ogg *ogg = s->priv_data;\n    struct ogg_stream *os = ogg->streams + idx;\n    int duration;\n\n    /* first packet handling\n       here we parse the duration of each packet in the first page and compare\n       the total duration to the page granule to find the encoder delay and\n       set the first timestamp */\n\n    if ((!os->lastpts || os->lastpts == AV_NOPTS_VALUE) && !(os->flags & OGG_FLAG_EOS)) {\n        int seg;\n\n        duration = 1;\n        for (seg = os->segp; seg < os->nsegs; seg++) {\n            if (os->segments[seg] < 255)\n                duration ++;\n        }\n\n        os->lastpts = os->lastdts   = theora_gptopts(s, idx, os->granule, NULL) - duration;\n        if(s->streams[idx]->start_time == AV_NOPTS_VALUE) {\n            s->streams[idx]->start_time = os->lastpts;\n            if (s->streams[idx]->duration > 0)\n                s->streams[idx]->duration -= s->streams[idx]->start_time;\n        }\n    }\n\n    /* parse packet duration */\n    if (os->psize > 0) {\n        os->pduration = 1;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5328, "func": "static void bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a,\n                            const BN_ULONG b)\n{\n    register BN_ULONG h, l, s;\n    BN_ULONG tab[16], top3b = a >> 61;\n    register BN_ULONG a1, a2, a4, a8;\n\n    a1 = a & (0x1FFFFFFFFFFFFFFFULL);\n    a2 = a1 << 1;\n    a4 = a2 << 1;\n    a8 = a4 << 1;\n\n    tab[0] = 0;\n    tab[1] = a1;\n    tab[2] = a2;\n    tab[3] = a1 ^ a2;\n    tab[4] = a4;\n    tab[5] = a1 ^ a4;\n    tab[6] = a2 ^ a4;\n    tab[7] = a1 ^ a2 ^ a4;\n    tab[8] = a8;\n    tab[9] = a1 ^ a8;\n    tab[10] = a2 ^ a8;\n    tab[11] = a1 ^ a2 ^ a8;\n    tab[12] = a4 ^ a8;\n    tab[13] = a1 ^ a4 ^ a8;\n    tab[14] = a2 ^ a4 ^ a8;\n    tab[15] = a1 ^ a2 ^ a4 ^ a8;\n\n    s = tab[b & 0xF];\n    l = s;\n    s = tab[b >> 4 & 0xF];\n    l ^= s << 4;\n    h = s >> 60;\n    s = tab[b >> 8 & 0xF];\n    l ^= s << 8;\n    h ^= s >> 56;\n    s = tab[b >> 12 & 0xF];\n    l ^= s << 12;\n    h ^= s >> 52;\n    s = tab[b >> 16 & 0xF];\n    l ^= s << 16;\n    h ^= s >> 48;\n    s = tab[b >> 20 & 0xF];\n    l ^= s << 20;\n    h ^= s >> 44;\n    s = tab[b >> 24 & 0xF];\n    l ^= s << 24;\n    h ^= s >> 40;\n    s = tab[b >> 28 & 0xF];\n    l ^= s << 28;\n    h ^= s >> 36;\n    s = tab[b >> 32 & 0xF];\n    l ^= s << 32;\n    h ^= s >> 32;\n    s = tab[b >> 36 & 0xF];\n    l ^= s << 36;\n    h ^= s >> 28;\n    s = tab[b >> 40 & 0xF];\n    l ^= s << 40;\n    h ^= s >> 24;\n    s = tab[b >> 44 & 0xF];\n    l ^= s << 44;\n    h ^= s >> 20;\n    s = tab[b >> 48 & 0xF];\n    l ^= s << 48;\n    h ^= s >> 16;\n    s = tab[b >> 52 & 0xF];\n    l ^= s << 52;\n    h ^= s >> 12;\n    s = tab[b >> 56 & 0xF];\n    l ^= s << 56;\n    h ^= s >> 8;\n    s = tab[b >> 60];\n    l ^= s << 60;\n    h ^= s >> 4;\n\n    /* compensate for the top three bits of a */\n\n    if (top3b & 01) {\n        l ^= b << 61;\n        h ^= b >> 3;\n    }\n    if (top3b & 02) {\n        l ^= b << 62;\n        h ^= b >> 2;\n    }\n    if (top3b & 04) {\n        l ^= b << 63;\n        h ^= b >> 1;\n    }\n\n    *r1 = h;\n    *r0 = l;\n}", "target": 1}
{"idx": 5329, "func": "int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\n    uint8_t *data[4];\n    int linesize[4];\n\n    if (!desc)\n        return AVERROR(EINVAL);\n    if (av_image_check_size(width, height, 0, NULL) < 0)\n        return AVERROR(EINVAL);\n    if (desc->flags & PIX_FMT_PSEUDOPAL)\n        // do not include palette for these pseudo-paletted formats\n        return width * height;\n    return av_image_fill_arrays(data, linesize, NULL, pix_fmt, width, height, align);\n}", "target": 1}
{"idx": 5330, "func": "static void vc1_decode_i_blocks(VC1Context *v)\n{\n    int k, j;\n    MpegEncContext *s = &v->s;\n    int cbp, val;\n    uint8_t *coded_val;\n    int mb_pos;\n\n    /* select codingmode used for VLC tables selection */\n    switch(v->y_ac_table_index){\n    case 0:\n        v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n        break;\n    case 1:\n        v->codingset = CS_HIGH_MOT_INTRA;\n        break;\n    case 2:\n        v->codingset = CS_MID_RATE_INTRA;\n        break;\n    }\n\n    switch(v->c_ac_table_index){\n    case 0:\n        v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n        break;\n    case 1:\n        v->codingset2 = CS_HIGH_MOT_INTER;\n        break;\n    case 2:\n        v->codingset2 = CS_MID_RATE_INTER;\n        break;\n    }\n\n    /* Set DC scale - y and c use the same */\n    s->y_dc_scale = s->y_dc_scale_table[v->pq];\n    s->c_dc_scale = s->c_dc_scale_table[v->pq];\n\n    //do frame decode\n    s->mb_x = s->mb_y = 0;\n    s->mb_intra = 1;\n    s->first_slice_line = 1;\n    for(s->mb_y = 0; s->mb_y < s->mb_height; s->mb_y++) {\n        s->mb_x = 0;\n        ff_init_block_index(s);\n        for(; s->mb_x < s->mb_width; s->mb_x++) {\n            ff_update_block_index(s);\n            s->dsp.clear_blocks(s->block[0]);\n            mb_pos = s->mb_x + s->mb_y * s->mb_width;\n            s->current_picture.mb_type[mb_pos] = MB_TYPE_INTRA;\n            s->current_picture.qscale_table[mb_pos] = v->pq;\n            s->current_picture.motion_val[1][s->block_index[0]][0] = 0;\n            s->current_picture.motion_val[1][s->block_index[0]][1] = 0;\n\n            // do actual MB decoding and displaying\n            cbp = get_vlc2(&v->s.gb, ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS, 2);\n            v->s.ac_pred = get_bits1(&v->s.gb);\n\n            for(k = 0; k < 6; k++) {\n                val = ((cbp >> (5 - k)) & 1);\n\n                if (k < 4) {\n                    int pred = vc1_coded_block_pred(&v->s, k, &coded_val);\n                    val = val ^ pred;\n                    *coded_val = val;\n                }\n                cbp |= val << (5 - k);\n\n                vc1_decode_i_block(v, s->block[k], k, val, (k<4)? v->codingset : v->codingset2);\n\n                v->vc1dsp.vc1_inv_trans_8x8(s->block[k]);\n                if(v->pq >= 9 && v->overlap) {\n                    for(j = 0; j < 64; j++) s->block[k][j] += 128;\n                }\n            }\n\n            vc1_put_block(v, s->block);\n            if(v->pq >= 9 && v->overlap) {\n                if(s->mb_x) {\n                    v->vc1dsp.vc1_h_overlap(s->dest[0], s->linesize);\n                    v->vc1dsp.vc1_h_overlap(s->dest[0] + 8 * s->linesize, s->linesize);\n                    if(!(s->flags & CODEC_FLAG_GRAY)) {\n                        v->vc1dsp.vc1_h_overlap(s->dest[1], s->uvlinesize);\n                        v->vc1dsp.vc1_h_overlap(s->dest[2], s->uvlinesize);\n                    }\n                }\n                v->vc1dsp.vc1_h_overlap(s->dest[0] + 8, s->linesize);\n                v->vc1dsp.vc1_h_overlap(s->dest[0] + 8 * s->linesize + 8, s->linesize);\n                if(!s->first_slice_line) {\n                    v->vc1dsp.vc1_v_overlap(s->dest[0], s->linesize);\n                    v->vc1dsp.vc1_v_overlap(s->dest[0] + 8, s->linesize);\n                    if(!(s->flags & CODEC_FLAG_GRAY)) {\n                        v->vc1dsp.vc1_v_overlap(s->dest[1], s->uvlinesize);\n                        v->vc1dsp.vc1_v_overlap(s->dest[2], s->uvlinesize);\n                    }\n                }\n                v->vc1dsp.vc1_v_overlap(s->dest[0] + 8 * s->linesize, s->linesize);\n                v->vc1dsp.vc1_v_overlap(s->dest[0] + 8 * s->linesize + 8, s->linesize);\n            }\n            if(v->s.loop_filter) vc1_loop_filter_iblk(v, v->pq);\n\n            if(get_bits_count(&s->gb) > v->bits) {\n                ff_er_add_slice(s, 0, 0, s->mb_x, s->mb_y, (AC_END|DC_END|MV_END));\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i\\n\", get_bits_count(&s->gb), v->bits);\n                return;\n            }\n        }\n        if (!v->s.loop_filter)\n            ff_draw_horiz_band(s, s->mb_y * 16, 16);\n        else if (s->mb_y)\n            ff_draw_horiz_band(s, (s->mb_y-1) * 16, 16);\n\n        s->first_slice_line = 0;\n    }\n    if (v->s.loop_filter)\n        ff_draw_horiz_band(s, (s->mb_height-1)*16, 16);\n    ff_er_add_slice(s, 0, 0, s->mb_width - 1, s->mb_height - 1, (AC_END|DC_END|MV_END));\n}", "target": 1}
{"idx": 5331, "func": "static int adx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf0 = avpkt->data;\n    int buf_size        = avpkt->size;\n    ADXContext *c       = avctx->priv_data;\n    int16_t *samples    = data;\n    const uint8_t *buf  = buf0;\n    int rest            = buf_size;\n\n    if (!c->header_parsed) {\n        int hdrsize = adx_decode_header(avctx, buf, rest);\n        if (!hdrsize)\n            return -1;\n        c->header_parsed = 1;\n        buf  += hdrsize;\n        rest -= hdrsize;\n    }\n\n    /* 18 bytes of data are expanded into 32*2 bytes of audio,\n       so guard against buffer overflows */\n    if (rest / 18 > *data_size / 64)\n        rest = (*data_size / 64) * 18;\n\n    if (c->in_temp) {\n        int copysize = 18 * avctx->channels - c->in_temp;\n        memcpy(c->dec_temp + c->in_temp, buf, copysize);\n        rest -= copysize;\n        buf  += copysize;\n        if (avctx->channels == 1) {\n            adx_decode(samples, c->dec_temp, c->prev);\n            samples += 32;\n        } else {\n            adx_decode_stereo(samples, c->dec_temp, c->prev);\n            samples += 32*2;\n        }\n    }\n\n    if (avctx->channels == 1) {\n        while (rest >= 18) {\n            adx_decode(samples, buf, c->prev);\n            rest    -= 18;\n            buf     += 18;\n            samples += 32;\n        }\n    } else {\n        while (rest >= 18 * 2) {\n            adx_decode_stereo(samples, buf, c->prev);\n            rest    -= 18 * 2;\n            buf     += 18 * 2;\n            samples += 32 * 2;\n        }\n    }\n\n    c->in_temp = rest;\n    if (rest) {\n        memcpy(c->dec_temp, buf, rest);\n        buf += rest;\n    }\n    *data_size = (uint8_t*)samples - (uint8_t*)data;\n    return buf - buf0;\n}", "target": 1}
{"idx": 5332, "func": "void ff_mspel_motion(MpegEncContext *s,\n                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n                               int motion_x, int motion_y, int h)\n{\n    Wmv2Context * const w= (Wmv2Context*)s;\n    uint8_t *ptr;\n    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;\n    int emu=0;\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n    dxy = 2*dxy + w->hshift;\n    src_x = s->mb_x * 16 + (motion_x >> 1);\n    src_y = s->mb_y * 16 + (motion_y >> 1);\n\n    /* WARNING: do no forget half pels */\n    v_edge_pos = s->v_edge_pos;\n    src_x = av_clip(src_x, -16, s->width);\n    src_y = av_clip(src_y, -16, s->height);\n\n    if(src_x<=-16 || src_x >= s->width)\n        dxy &= ~3;\n    if(src_y<=-16 || src_y >= s->height)\n        dxy &= ~4;\n\n    linesize   = s->linesize;\n    uvlinesize = s->uvlinesize;\n    ptr = ref_picture[0] + (src_y * linesize) + src_x;\n\n        if(src_x<1 || src_y<1 || src_x + 17  >= s->h_edge_pos\n                              || src_y + h+1 >= v_edge_pos){\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr - 1 - s->linesize, s->linesize, 19, 19,\n                             src_x-1, src_y-1, s->h_edge_pos, s->v_edge_pos);\n            ptr= s->edge_emu_buffer + 1 + s->linesize;\n            emu=1;\n        }\n\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y             , ptr             , linesize);\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8           , ptr+8           , linesize);\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y  +8*linesize, ptr  +8*linesize, linesize);\n    s->dsp.put_mspel_pixels_tab[dxy](dest_y+8+8*linesize, ptr+8+8*linesize, linesize);\n\n    if(s->flags&CODEC_FLAG_GRAY) return;\n\n    if (s->out_format == FMT_H263) {\n        dxy = 0;\n        if ((motion_x & 3) != 0)\n            dxy |= 1;\n        if ((motion_y & 3) != 0)\n            dxy |= 2;\n        mx = motion_x >> 2;\n        my = motion_y >> 2;\n    } else {\n        mx = motion_x / 2;\n        my = motion_y / 2;\n        dxy = ((my & 1) << 1) | (mx & 1);\n        mx >>= 1;\n        my >>= 1;\n    }\n\n    src_x = s->mb_x * 8 + mx;\n    src_y = s->mb_y * 8 + my;\n    src_x = av_clip(src_x, -8, s->width >> 1);\n    if (src_x == (s->width >> 1))\n        dxy &= ~1;\n    src_y = av_clip(src_y, -8, s->height >> 1);\n    if (src_y == (s->height >> 1))\n        dxy &= ~2;\n    offset = (src_y * uvlinesize) + src_x;\n    ptr = ref_picture[1] + offset;\n    if(emu){\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n        ptr= s->edge_emu_buffer;\n    }\n    pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);\n\n    ptr = ref_picture[2] + offset;\n    if(emu){\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n        ptr= s->edge_emu_buffer;\n    }\n    pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);\n}", "target": 1}
{"idx": 5333, "func": "char *CRYPTO_strdup(const char *str, const char* file, int line)\n{\n    char *ret;\n    size_t size;\n\n    if (str == NULL)\n        return NULL;\n    size = strlen(str) + 1;\n    ret = CRYPTO_malloc(size, file, line);\n    if (ret != NULL)\n        memcpy(ret, str, size);\n    return ret;\n}", "target": 1}
{"idx": 5334, "func": "static av_always_inline void filter_mb_edgeh(uint8_t *pix, int stride,\n                                             const int16_t bS[4],\n                                             unsigned int qp, int a, int b,\n                                             const H264Context *h, int intra)\n{\n    const unsigned int index_a = qp + a;\n    const int alpha = alpha_table[index_a];\n    const int beta  = beta_table[qp + b];\n    if (alpha ==0 || beta == 0) return;\n\n    if( bS[0] < 4 || !intra ) {\n        int8_t tc[4];\n        tc[0] = tc0_table[index_a][bS[0]];\n        tc[1] = tc0_table[index_a][bS[1]];\n        tc[2] = tc0_table[index_a][bS[2]];\n        tc[3] = tc0_table[index_a][bS[3]];\n        h->h264dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);\n    } else {\n        h->h264dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);\n    }\n}", "target": 1}
{"idx": 5335, "func": "static int ssl2_read_internal(SSL *s, void *buf, int len, int peek)\n\t{\n\tint n;\n\tunsigned char mac[MAX_MAC_SIZE];\n\tunsigned char *p;\n\tint i;\n\tunsigned int mac_size;\n\n ssl2_read_again:\n\tif (SSL_in_init(s) && !s->in_handshake)\n\t\t{\n\t\tn=s->handshake_func(s);\n\t\tif (n < 0) return(n);\n\t\tif (n == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\t\t}\n\n\tclear_sys_error();\n\ts->rwstate=SSL_NOTHING;\n\tif (len <= 0) return(len);\n\n\tif (s->s2->ract_data_length != 0) /* read from buffer */\n\t\t{\n\t\tif (len > s->s2->ract_data_length)\n\t\t\tn=s->s2->ract_data_length;\n\t\telse\n\t\t\tn=len;\n\n\t\tmemcpy(buf,s->s2->ract_data,(unsigned int)n);\n\t\tif (!peek)\n\t\t\t{\n\t\t\ts->s2->ract_data_length-=n;\n\t\t\ts->s2->ract_data+=n;\n\t\t\tif (s->s2->ract_data_length == 0)\n\t\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\t}\n\n\t\treturn(n);\n\t\t}\n\n\t/* s->s2->ract_data_length == 0\n\t * \n\t * Fill the buffer, then goto ssl2_read_again.\n\t */\n\n\tif (s->rstate == SSL_ST_READ_HEADER)\n\t\t{\n\t\tif (s->first_packet)\n\t\t\t{\n\t\t\tn=read_n(s,5,SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2,0);\n\t\t\tif (n <= 0) return(n); /* error or non-blocking */\n\t\t\ts->first_packet=0;\n\t\t\tp=s->packet;\n\t\t\tif (!((p[0] & 0x80) && (\n\t\t\t\t(p[2] == SSL2_MT_CLIENT_HELLO) ||\n\t\t\t\t(p[2] == SSL2_MT_SERVER_HELLO))))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_NON_SSLV2_INITIAL_PACKET);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tn=read_n(s,2,SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2,0);\n\t\t\tif (n <= 0) return(n); /* error or non-blocking */\n\t\t\t}\n\t\t/* part read stuff */\n\n\t\ts->rstate=SSL_ST_READ_BODY;\n\t\tp=s->packet;\n\t\t/* Do header */\n\t\t/*s->s2->padding=0;*/\n\t\ts->s2->escape=0;\n\t\ts->s2->rlength=(((unsigned int)p[0])<<8)|((unsigned int)p[1]);\n\t\tif ((p[0] & TWO_BYTE_BIT))\t\t/* Two byte header? */\n\t\t\t{\n\t\t\ts->s2->three_byte_header=0;\n\t\t\ts->s2->rlength&=TWO_BYTE_MASK;\t\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\ts->s2->three_byte_header=1;\n\t\t\ts->s2->rlength&=THREE_BYTE_MASK;\n\n\t\t\t/* security >s2->escape */\n\t\t\ts->s2->escape=((p[0] & SEC_ESC_BIT))?1:0;\n\t\t\t}\n\t\t}\n\n\tif (s->rstate == SSL_ST_READ_BODY)\n\t\t{\n\t\tn=s->s2->rlength+2+s->s2->three_byte_header;\n\t\tif (n > (int)s->packet_length)\n\t\t\t{\n\t\t\tn-=s->packet_length;\n\t\t\ti=read_n(s,(unsigned int)n,(unsigned int)n,1);\n\t\t\tif (i <= 0) return(i); /* ERROR */\n\t\t\t}\n\n\t\tp= &(s->packet[2]);\n\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\tif (s->s2->three_byte_header)\n\t\t\ts->s2->padding= *(p++);\n\t\telse\ts->s2->padding=0;\n\n\t\t/* Data portion */\n\t\tif (s->s2->clear_text)\n\t\t\t{\n\t\t\tmac_size = 0;\n\t\t\ts->s2->mac_data=p;\n\t\t\ts->s2->ract_data=p;\n\t\t\tif (s->s2->padding)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_ILLEGAL_PADDING);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tmac_size=EVP_MD_size(s->read_hash);\n\t\t\ts->s2->mac_data=p;\n\t\t\ts->s2->ract_data= &p[mac_size];\n\t\t\tif (s->s2->padding + mac_size > s->s2->rlength)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_ILLEGAL_PADDING);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\t}\n\n\t\ts->s2->ract_data_length=s->s2->rlength;\n\t\t/* added a check for length > max_size in case\n\t\t * encryption was not turned on yet due to an error */\n\t\tif ((!s->s2->clear_text) &&\n\t\t\t(s->s2->rlength >= mac_size))\n\t\t\t{\n\t\t\tssl2_enc(s,0);\n\t\t\ts->s2->ract_data_length-=mac_size;\n\t\t\tssl2_mac(s,mac,0);\n\t\t\ts->s2->ract_data_length-=s->s2->padding;\n\t\t\tif (\t(memcmp(mac,s->s2->mac_data,\n\t\t\t\t(unsigned int)mac_size) != 0) ||\n\t\t\t\t(s->s2->rlength%EVP_CIPHER_CTX_block_size(s->enc_read_ctx) != 0))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_BAD_MAC_DECODE);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\t}\n\t\tINC32(s->s2->read_sequence); /* expect next number */\n\t\t/* s->s2->ract_data is now available for processing */\n\n\t\t/* Possibly the packet that we just read had 0 actual data bytes.\n\t\t * (SSLeay/OpenSSL itself never sends such packets; see ssl2_write.)\n\t\t * In this case, returning 0 would be interpreted by the caller\n\t\t * as indicating EOF, so it's not a good idea.  Instead, we just\n\t\t * continue reading; thus ssl2_read_internal may have to process\n\t\t * multiple packets before it can return.\n\t\t *\n\t\t * [Note that using select() for blocking sockets *never* guarantees\n\t\t * that the next SSL_read will not block -- the available\n\t\t * data may contain incomplete packets, and except for SSL 2,\n\t\t * renegotiation can confuse things even more.] */\n\n\t\tgoto ssl2_read_again; /* This should really be\n\t\t                       * \"return ssl2_read(s,buf,len)\",\n\t\t                       * but that would allow for\n\t\t                       * denial-of-service attacks if a\n\t\t                       * C compiler is used that does not\n\t\t                       * recognize end-recursion. */\n\t\t}\n\telse\n\t\t{\n\t\tSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_BAD_STATE);\n\t\t\treturn(-1);\n\t\t}\n\t}", "target": 0}
{"idx": 5336, "func": "static int tiff_unpack_strip(TiffContext *s, uint8_t *dst, int stride,\n                             const uint8_t *src, int size, int lines)\n{\n    PutByteContext pb;\n    int c, line, pixels, code, ret;\n    int width = ((s->width * s->bpp) + 7) >> 3;\n\n    if (size <= 0)\n        return AVERROR_INVALIDDATA;\n\n    if (s->compr == TIFF_DEFLATE || s->compr == TIFF_ADOBE_DEFLATE) {\n#if CONFIG_ZLIB\n        return tiff_unpack_zlib(s, dst, stride, src, size, width, lines);\n#else\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"zlib support not enabled, \"\n               \"deflate compression not supported\\n\");\n        return AVERROR(ENOSYS);\n#endif\n    }\n    if (s->compr == TIFF_LZW) {\n        if ((ret = ff_lzw_decode_init(s->lzw, 8, src, size, FF_LZW_TIFF)) < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Error initializing LZW decoder\\n\");\n            return ret;\n        }\n        for (line = 0; line < lines; line++) {\n            pixels = ff_lzw_decode(s->lzw, dst, width);\n            if (pixels < width) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Decoded only %i bytes of %i\\n\",\n                       pixels, width);\n                return AVERROR_INVALIDDATA;\n            }\n            dst += stride;\n        }\n        return 0;\n    }\n    if (s->compr == TIFF_CCITT_RLE ||\n        s->compr == TIFF_G3        ||\n        s->compr == TIFF_G4) {\n        return tiff_unpack_fax(s, dst, stride, src, size, lines);\n    }\n\n    bytestream2_init(&s->gb, src, size);\n    bytestream2_init_writer(&pb, dst, stride * lines);\n\n    for (line = 0; line < lines; line++) {\n        if (bytestream2_get_bytes_left(&s->gb) == 0 || bytestream2_get_eof(&pb))\n            break;\n        bytestream2_seek_p(&pb, stride * line, SEEK_SET);\n        switch (s->compr) {\n        case TIFF_RAW:\n            if (!s->fill_order) {\n                bytestream2_copy_buffer(&pb, &s->gb, width);\n            } else {\n                int i;\n                for (i = 0; i < width; i++)\n                    bytestream2_put_byte(&pb, ff_reverse[bytestream2_get_byte(&s->gb)]);\n            }\n            break;\n        case TIFF_PACKBITS:\n            for (pixels = 0; pixels < width;) {\n                code = ff_u8_to_s8(bytestream2_get_byte(&s->gb));\n                if (code >= 0) {\n                    code++;\n                    bytestream2_copy_buffer(&pb, &s->gb, code);\n                    pixels += code;\n                } else if (code != -128) { // -127..-1\n                    code = (-code) + 1;\n                    c    = bytestream2_get_byte(&s->gb);\n                    bytestream2_set_buffer(&pb, c, code);\n                    pixels += code;\n                }\n            }\n            break;\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": 5337, "func": "static void SET_TYPE(resample_one)(ResampleContext *c,\n                                   void *dst0, int dst_index, const void *src0,\n                                   int src_size, int index, int frac)\n{\n    FELEM *dst = dst0;\n    const FELEM *src = src0;\n    int i;\n    int sample_index = index >> c->phase_shift;\n    FELEM2 val = 0;\n    FELEM *filter = ((FELEM *)c->filter_bank) +\n                    c->filter_length * (index & c->phase_mask);\n\n    if (sample_index < 0) {\n        for (i = 0; i < c->filter_length; i++)\n            val += src[FFABS(sample_index + i) % src_size] *\n                   (FELEM2)filter[i];\n    } else if (c->linear) {\n        FELEM2 v2 = 0;\n        for (i = 0; i < c->filter_length; i++) {\n            val += src[sample_index + i] * (FELEM2)filter[i];\n            v2  += src[sample_index + i] * (FELEM2)filter[i + c->filter_length];\n        }\n        val += (v2 - val) * (FELEML)frac / c->src_incr;\n    } else {\n        for (i = 0; i < c->filter_length; i++)\n            val += src[sample_index + i] * (FELEM2)filter[i];\n    }\n\n    OUT(dst[dst_index], val);\n}", "target": 1}
{"idx": 5338, "func": "int64_t ff_gen_search(AVFormatContext *s, int stream_index, int64_t target_ts,\n                      int64_t pos_min, int64_t pos_max, int64_t pos_limit,\n                      int64_t ts_min, int64_t ts_max, int flags, int64_t *ts_ret,\n                      int64_t (*read_timestamp)(struct AVFormatContext *, int , int64_t *, int64_t ))\n{\n    int64_t pos, ts;\n    int64_t start_pos, filesize;\n    int no_change;\n\n    av_dlog(s, \"gen_seek: %d %s\\n\", stream_index, av_ts2str(target_ts));\n\n    if(ts_min == AV_NOPTS_VALUE){\n        pos_min = s->data_offset;\n        ts_min = ff_read_timestamp(s, stream_index, &pos_min, INT64_MAX, read_timestamp);\n        if (ts_min == AV_NOPTS_VALUE)\n            return -1;\n    }\n\n    if(ts_min >= target_ts){\n        *ts_ret= ts_min;\n        return pos_min;\n    }\n\n    if(ts_max == AV_NOPTS_VALUE){\n        int step= 1024;\n        filesize = avio_size(s->pb);\n        pos_max = filesize - 1;\n        do{\n            pos_max = FFMAX(0, pos_max - step);\n            ts_max = ff_read_timestamp(s, stream_index, &pos_max, pos_max + step, read_timestamp);\n            step += step;\n        }while(ts_max == AV_NOPTS_VALUE && pos_max > 0);\n        if (ts_max == AV_NOPTS_VALUE)\n            return -1;\n\n        for(;;){\n            int64_t tmp_pos= pos_max + 1;\n            int64_t tmp_ts= ff_read_timestamp(s, stream_index, &tmp_pos, INT64_MAX, read_timestamp);\n            if(tmp_ts == AV_NOPTS_VALUE)\n                break;\n            ts_max= tmp_ts;\n            pos_max= tmp_pos;\n            if(tmp_pos >= filesize)\n                break;\n        }\n        pos_limit= pos_max;\n    }\n\n    if(ts_max <= target_ts){\n        *ts_ret= ts_max;\n        return pos_max;\n    }\n\n    if(ts_min > ts_max){\n        return -1;\n    }else if(ts_min == ts_max){\n        pos_limit= pos_min;\n    }\n\n    no_change=0;\n    while (pos_min < pos_limit) {\n        av_dlog(s, \"pos_min=0x%\"PRIx64\" pos_max=0x%\"PRIx64\" dts_min=%s dts_max=%s\\n\",\n                pos_min, pos_max, av_ts2str(ts_min), av_ts2str(ts_max));\n        assert(pos_limit <= pos_max);\n\n        if(no_change==0){\n            int64_t approximate_keyframe_distance= pos_max - pos_limit;\n            // interpolate position (better than dichotomy)\n            pos = av_rescale(target_ts - ts_min, pos_max - pos_min, ts_max - ts_min)\n                + pos_min - approximate_keyframe_distance;\n        }else if(no_change==1){\n            // bisection, if interpolation failed to change min or max pos last time\n            pos = (pos_min + pos_limit)>>1;\n        }else{\n            /* linear search if bisection failed, can only happen if there\n               are very few or no keyframes between min/max */\n            pos=pos_min;\n        }\n        if(pos <= pos_min)\n            pos= pos_min + 1;\n        else if(pos > pos_limit)\n            pos= pos_limit;\n        start_pos= pos;\n\n        ts = ff_read_timestamp(s, stream_index, &pos, INT64_MAX, read_timestamp); //may pass pos_limit instead of -1\n        if(pos == pos_max)\n            no_change++;\n        else\n            no_change=0;\n        av_dlog(s, \"%\"PRId64\" %\"PRId64\" %\"PRId64\" / %s %s %s target:%s limit:%\"PRId64\" start:%\"PRId64\" noc:%d\\n\",\n                pos_min, pos, pos_max,\n                av_ts2str(ts_min), av_ts2str(ts), av_ts2str(ts_max), av_ts2str(target_ts),\n                pos_limit, start_pos, no_change);\n        if(ts == AV_NOPTS_VALUE){\n            av_log(s, AV_LOG_ERROR, \"read_timestamp() failed in the middle\\n\");\n            return -1;\n        }\n        assert(ts != AV_NOPTS_VALUE);\n        if (target_ts <= ts) {\n            pos_limit = start_pos - 1;\n            pos_max = pos;\n            ts_max = ts;\n        }\n        if (target_ts >= ts) {\n            pos_min = pos;\n            ts_min = ts;\n        }\n    }\n\n    pos = (flags & AVSEEK_FLAG_BACKWARD) ? pos_min : pos_max;\n    ts  = (flags & AVSEEK_FLAG_BACKWARD) ?  ts_min :  ts_max;\n#if 0\n    pos_min = pos;\n    ts_min = ff_read_timestamp(s, stream_index, &pos_min, INT64_MAX, read_timestamp);\n    pos_min++;\n    ts_max = ff_read_timestamp(s, stream_index, &pos_min, INT64_MAX, read_timestamp);\n    av_dlog(s, \"pos=0x%\"PRIx64\" %s<=%s<=%s\\n\",\n            pos, av_ts2str(ts_min), av_ts2str(target_ts), av_ts2str(ts_max));\n#endif\n    *ts_ret= ts;\n    return pos;\n}", "target": 1}
{"idx": 5339, "func": "static inline int wv_unpack_mono(WavpackFrameContext *s, GetBitContext *gb,\n                                 void *dst, const int type)\n{\n    int i, j, count = 0;\n    int last, t;\n    int A, S, T;\n    int pos                  = s->pos;\n    uint32_t crc             = s->sc.crc;\n    uint32_t crc_extra_bits  = s->extra_sc.crc;\n    int16_t *dst16           = dst;\n    int32_t *dst32           = dst;\n    float *dstfl             = dst;\n\n    s->one = s->zero = s->zeroes = 0;\n    do {\n        T = wv_get_value(s, gb, 0, &last);\n        S = 0;\n        if (last)\n            break;\n        for (i = 0; i < s->terms; i++) {\n            t = s->decorr[i].value;\n            if (t > 8) {\n                if (t & 1)\n                    A =  2U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1];\n                else\n                    A = (int)(3U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1]) >> 1;\n                s->decorr[i].samplesA[1] = s->decorr[i].samplesA[0];\n                j                        = 0;\n            } else {\n                A = s->decorr[i].samplesA[pos];\n                j = (pos + t) & 7;\n            }\n            if (type != AV_SAMPLE_FMT_S16P)\n                S = T + ((s->decorr[i].weightA * (int64_t)A + 512) >> 10);\n            else\n                S = T + (unsigned)((int)(s->decorr[i].weightA * (unsigned)A + 512) >> 10);\n            if (A && T)\n                s->decorr[i].weightA -= ((((T ^ A) >> 30) & 2) - 1) * s->decorr[i].delta;\n            s->decorr[i].samplesA[j] = T = S;\n        }\n        pos = (pos + 1) & 7;\n        crc = crc * 3 + S;\n\n        if (type == AV_SAMPLE_FMT_FLTP) {\n            *dstfl++ = wv_get_value_float(s, &crc_extra_bits, S);\n        } else if (type == AV_SAMPLE_FMT_S32P) {\n            *dst32++ = wv_get_value_integer(s, &crc_extra_bits, S);\n        } else {\n            *dst16++ = wv_get_value_integer(s, &crc_extra_bits, S);\n        }\n        count++;\n    } while (!last && count < s->samples);\n\n    wv_reset_saved_context(s);\n\n    if (last && count < s->samples) {\n        int size = av_get_bytes_per_sample(type);\n        memset((uint8_t*)dst + count*size, 0, (s->samples-count)*size);\n    }\n\n    if (s->avctx->err_recognition & AV_EF_CRCCHECK) {\n        int ret = wv_check_crc(s, crc, crc_extra_bits);\n        if (ret < 0 && s->avctx->err_recognition & AV_EF_EXPLODE)\n            return ret;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5340, "func": "static void inc_128(DRBG_CTR_CTX *cctx)\n{\n    int i;\n    unsigned char c;\n    unsigned char *p = &cctx->V[15];\n\n    for (i = 0; i < 16; i++, p--) {\n        c = *p;\n        c++;\n        *p = c;\n        if (c != 0) {\n            /* If we didn't wrap around, we're done. */\n            break;\n        }\n    }\n}", "target": 1}
{"idx": 5341, "func": "int BIO_get_accept_socket(char *host, int bind_mode)\n\t{\n\tint ret=0;\n\tstruct sockaddr_in server,client;\n\tint s= -1,cs;\n\tunsigned char ip[4];\n\tunsigned short port;\n\tchar *str,*e;\n\tconst char *h,*p;\n\tunsigned long l;\n\tint err_num;\n\n\tif (BIO_sock_init() != 1) return(INVALID_SOCKET);\n\n\tif ((str=BUF_strdup(host)) == NULL) return(INVALID_SOCKET);\n\n\th=p=NULL;\n\th=str;\n\tfor (e=str; *e; e++)\n\t\t{\n\t\tif (*e == ':')\n\t\t\t{\n\t\t\tp= &(e[1]);\n\t\t\t*e='\\0';\n\t\t\t}\n\t\telse if (*e == '/')\n\t\t\t{\n\t\t\t*e='\\0';\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tif (p == NULL)\n\t\t{\n\t\tp=h;\n\t\th=\"*\";\n\t\t}\n\n\tif (!BIO_get_port(p,&port)) return(INVALID_SOCKET);\n\n\tmemset((char *)&server,0,sizeof(server));\n\tserver.sin_family=AF_INET;\n\tserver.sin_port=htons(port);\n\n\tif (strcmp(h,\"*\") == 0)\n\t\tserver.sin_addr.s_addr=INADDR_ANY;\n\telse\n\t\t{\n\t\tif (!BIO_get_host_ip(h,&(ip[0]))) return(INVALID_SOCKET);\n\t\tl=(unsigned long)\n\t\t\t((unsigned long)ip[0]<<24L)|\n\t\t\t((unsigned long)ip[1]<<16L)|\n\t\t\t((unsigned long)ip[2]<< 8L)|\n\t\t\t((unsigned long)ip[3]);\n\t\tserver.sin_addr.s_addr=htonl(l);\n\t\t}\n\nagain:\n\ts=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\n\tif (s == INVALID_SOCKET)\n\t\t{\n\t\tSYSerr(SYS_F_SOCKET,get_last_socket_error());\n\t\tERR_add_error_data(3,\"port='\",host,\"'\");\n\t\tBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_CREATE_SOCKET);\n\t\tgoto err;\n\t\t}\n\n#ifdef SO_REUSEADDR\n\tif (bind_mode == BIO_BIND_REUSEADDR)\n\t\t{\n\t\tint i=1;\n\n\t\tret=setsockopt(s,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof(i));\n\t\tbind_mode=BIO_BIND_NORMAL;\n\t\t}\n#endif\n\tif (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1)\n\t\t{\n#ifdef SO_REUSEADDR\n\t\terr_num=get_last_socket_error();\n\t\tif ((bind_mode == BIO_BIND_REUSEADDR_IF_UNUSED) &&\n\t\t\t(err_num == EADDRINUSE))\n\t\t\t{\n\t\t\tmemcpy((char *)&client,(char *)&server,sizeof(server));\n\t\t\tif (strcmp(h,\"*\") == 0)\n\t\t\t\tclient.sin_addr.s_addr=htonl(0x7F000001);\n\t\t\tcs=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\n\t\t\tif (cs != INVALID_SOCKET)\n\t\t\t\t{\n\t\t\t\tint ii;\n\t\t\t\tii=connect(cs,(struct sockaddr *)&client,\n\t\t\t\t\tsizeof(client));\n\t\t\t\tclosesocket(cs);\n\t\t\t\tif (ii == INVALID_SOCKET)\n\t\t\t\t\t{\n\t\t\t\t\tbind_mode=BIO_BIND_REUSEADDR;\n\t\t\t\t\tclosesocket(s);\n\t\t\t\t\tgoto again;\n\t\t\t\t\t}\n\t\t\t\t/* else error */\n\t\t\t\t}\n\t\t\t/* else error */\n\t\t\t}\n#endif\n\t\tSYSerr(SYS_F_BIND,err_num);\n\t\tERR_add_error_data(3,\"port='\",host,\"'\");\n\t\tBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_BIND_SOCKET);\n\t\tgoto err;\n\t\t}\n\tif (listen(s,MAX_LISTEN) == -1)\n\t\t{\n\t\tSYSerr(SYS_F_BIND,get_last_socket_error());\n\t\tERR_add_error_data(3,\"port='\",host,\"'\");\n\t\tBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_LISTEN_SOCKET);\n\t\tgoto err;\n\t\t}\n\tret=1;\nerr:\n\tif (str != NULL) OPENSSL_free(str);\n\tif ((ret == 0) && (s != INVALID_SOCKET))\n\t\t{\n\t\tclosesocket(s);\n\t\ts= INVALID_SOCKET;\n\t\t}\n\treturn(s);\n\t}", "target": 1}
{"idx": 5342, "func": "static int mxf_write_header_metadata_sets(AVFormatContext *s)\n{\n    mxf_write_preface(s);\n    mxf_write_identification(s);\n    mxf_write_content_storage(s);\n    mxf_build_structural_metadata(s, MaterialPackage);\n    mxf_build_structural_metadata(s, SourcePackage);\n    return 0;\n}", "target": 0}
{"idx": 5343, "func": "static void chroma_4mv_motion(MpegEncContext *s,\n                              uint8_t *dest_cb, uint8_t *dest_cr,\n                              uint8_t **ref_picture,\n                              op_pixels_func *pix_op,\n                              int mx, int my)\n{\n    int dxy, emu=0, src_x, src_y, offset;\n    uint8_t *ptr;\n\n    /* In case of 8X8, we construct a single chroma motion vector\n       with a special rounding */\n    mx= ff_h263_round_chroma(mx);\n    my= ff_h263_round_chroma(my);\n\n    dxy = ((my & 1) << 1) | (mx & 1);\n    mx >>= 1;\n    my >>= 1;\n\n    src_x = s->mb_x * 8 + mx;\n    src_y = s->mb_y * 8 + my;\n    src_x = av_clip(src_x, -8, (s->width >> 1));\n    if (src_x == (s->width >> 1))\n        dxy &= ~1;\n    src_y = av_clip(src_y, -8, (s->height >> 1));\n    if (src_y == (s->height >> 1))\n        dxy &= ~2;\n\n    offset = src_y * s->uvlinesize + src_x;\n    ptr = ref_picture[1] + offset;\n    if(s->flags&CODEC_FLAG_EMU_EDGE){\n        if(   (unsigned)src_x > FFMAX((s->h_edge_pos>>1) - (dxy &1) - 8, 0)\n           || (unsigned)src_y > FFMAX((s->v_edge_pos>>1) - (dxy>>1) - 8, 0)){\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize,\n                                9, 9, src_x, src_y,\n                                s->h_edge_pos>>1, s->v_edge_pos>>1);\n            ptr= s->edge_emu_buffer;\n            emu=1;\n        }\n    }\n    pix_op[dxy](dest_cb, ptr, s->uvlinesize, 8);\n\n    ptr = ref_picture[2] + offset;\n    if(emu){\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize,\n                            9, 9, src_x, src_y,\n                            s->h_edge_pos>>1, s->v_edge_pos>>1);\n        ptr= s->edge_emu_buffer;\n    }\n    pix_op[dxy](dest_cr, ptr, s->uvlinesize, 8);\n}", "target": 1}
{"idx": 5344, "func": "static void end_last_frame(AVFilterContext *ctx)\n{\n    TileContext *tile    = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    AVFilterBufferRef *out_buf = outlink->out_buf;\n\n    outlink->out_buf = NULL;\n    while (tile->current < tile->nb_frames)\n        draw_blank_frame(ctx, out_buf);\n    ff_filter_frame(outlink, out_buf);\n    tile->current = 0;\n}", "target": 0}
{"idx": 5345, "func": "static int decode_packet(J2kDecoderContext *s, J2kCodingStyle *codsty, J2kResLevel *rlevel, int precno,\n                         int layno, uint8_t *expn, int numgbits)\n{\n    int bandno, cblkny, cblknx, cblkno, ret;\n\n    if (!(ret = get_bits(s, 1))){\n        j2k_flush(s);\n        return 0;\n    } else if (ret < 0)\n        return ret;\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++){\n        J2kBand *band = rlevel->band + bandno;\n        J2kPrec *prec = band->prec + precno;\n        int pos = 0;\n\n        if (band->coord[0][0] == band->coord[0][1]\n        ||  band->coord[1][0] == band->coord[1][1])\n            continue;\n\n        for (cblkny = prec->yi0; cblkny < prec->yi1; cblkny++)\n            for(cblknx = prec->xi0, cblkno = cblkny * band->cblknx + cblknx; cblknx < prec->xi1; cblknx++, cblkno++, pos++){\n                J2kCblk *cblk = band->cblk + cblkno;\n                int incl, newpasses, llen;\n\n                if (cblk->npasses)\n                    incl = get_bits(s, 1);\n                else\n                    incl = tag_tree_decode(s, prec->cblkincl + pos, layno+1) == layno;\n                if (!incl)\n                    continue;\n                else if (incl < 0)\n                    return incl;\n\n                if (!cblk->npasses)\n                    cblk->nonzerobits = expn[bandno] + numgbits - 1 - tag_tree_decode(s, prec->zerobits + pos, 100);\n                if ((newpasses = getnpasses(s)) < 0)\n                    return newpasses;\n                if ((llen = getlblockinc(s)) < 0)\n                    return llen;\n                cblk->lblock += llen;\n                if ((ret = get_bits(s, av_log2(newpasses) + cblk->lblock)) < 0)\n                    return ret;\n                cblk->lengthinc = ret;\n                cblk->npasses += newpasses;\n            }\n    }\n    j2k_flush(s);\n\n    if (codsty->csty & J2K_CSTY_EPH) {\n        if (bytestream2_peek_be16(&s->g) == J2K_EPH) {\n            bytestream2_skip(&s->g, 2);\n        } else {\n            av_log(s->avctx, AV_LOG_ERROR, \"EPH marker not found.\\n\");\n        }\n    }\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++){\n        J2kBand *band = rlevel->band + bandno;\n        int yi, cblknw = band->prec[precno].xi1 - band->prec[precno].xi0;\n        for (yi = band->prec[precno].yi0; yi < band->prec[precno].yi1; yi++){\n            int xi;\n            for (xi = band->prec[precno].xi0; xi < band->prec[precno].xi1; xi++){\n                J2kCblk *cblk = band->cblk + yi * cblknw + xi;\n                if (bytestream2_get_bytes_left(&s->g) < cblk->lengthinc)\n                    return AVERROR(EINVAL);\n                bytestream2_get_bufferu(&s->g, cblk->data, cblk->lengthinc);\n                cblk->length += cblk->lengthinc;\n                cblk->lengthinc = 0;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": 5346, "func": "static\nint SM2_sig_verify(const EC_KEY *key, const ECDSA_SIG *sig, const BIGNUM *e)\n{\n    int ret = 0;\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    const BIGNUM *order = EC_GROUP_get0_order(group);\n    BN_CTX *ctx = NULL;\n    EC_POINT *pt = NULL;\n\n    BIGNUM *t = NULL;\n    BIGNUM *x1 = NULL;\n    const BIGNUM *r = NULL;\n    const BIGNUM *s = NULL;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto done;\n    pt = EC_POINT_new(group);\n    if (pt == NULL)\n        goto done;\n\n    BN_CTX_start(ctx);\n\n    t = BN_CTX_get(ctx);\n    x1 = BN_CTX_get(ctx);\n\n    if (x1 == NULL)\n        goto done;\n\n    /*\n       B1: verify whether r' in [1,n-1], verification failed if not\n       B2: vefify whether s' in [1,n-1], verification failed if not\n       B3: set M'~=ZA || M'\n       B4: calculate e'=Hv(M'~)\n       B5: calculate t = (r' + s') modn, verification failed if t=0\n       B6: calculate the point (x1', y1')=[s']G + [t]PA\n       B7: calculate R=(e'+x1') modn, verfication pass if yes, otherwise failed\n     */\n\n    ECDSA_SIG_get0(sig, &r, &s);\n\n    if (BN_cmp(r, BN_value_one()) < 0)\n        goto done;\n    if (BN_cmp(s, BN_value_one()) < 0)\n        goto done;\n\n    if (BN_cmp(order, r) <= 0)\n        goto done;\n    if (BN_cmp(order, s) <= 0)\n        goto done;\n\n    if (BN_mod_add(t, r, s, order, ctx) == 0)\n        goto done;\n\n    if (BN_is_zero(t) == 1)\n        goto done;\n\n    if (EC_POINT_mul(group, pt, s, EC_KEY_get0_public_key(key), t, ctx) == 0)\n        goto done;\n\n    if (EC_POINT_get_affine_coordinates_GFp(group, pt, x1, NULL, ctx) == 0)\n        goto done;\n\n    if (BN_mod_add(t, e, x1, order, ctx) == 0)\n        goto done;\n\n    if (BN_cmp(r, t) == 0)\n        ret = 1;\n\n done:\n    EC_POINT_free(pt);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"idx": 5347, "func": "static int decode_band_types(AACContext *ac, enum BandType band_type[120],\n                             int band_type_run_end[120], GetBitContext *gb,\n                             IndividualChannelStream *ics)\n{\n    int g, idx = 0;\n    const int bits = (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;\n    for (g = 0; g < ics->num_window_groups; g++) {\n        int k = 0;\n        while (k < ics->max_sfb) {\n            uint8_t sect_end = k;\n            int sect_len_incr;\n            int sect_band_type = get_bits(gb, 4);\n            if (sect_band_type == 12) {\n                av_log(ac->avctx, AV_LOG_ERROR, \"invalid band type\\n\");\n                return -1;\n            }\n            do {\n                sect_len_incr = get_bits(gb, bits);\n                sect_end += sect_len_incr;\n                if (get_bits_left(gb) < 0) {\n                    av_log(ac->avctx, AV_LOG_ERROR, overread_err);\n                    return -1;\n                }\n                if (sect_end > ics->max_sfb) {\n                    av_log(ac->avctx, AV_LOG_ERROR,\n                           \"Number of bands (%d) exceeds limit (%d).\\n\",\n                           sect_end, ics->max_sfb);\n                    return -1;\n                }\n            } while (sect_len_incr == (1 << bits) - 1);\n            for (; k < sect_end; k++) {\n                band_type        [idx]   = sect_band_type;\n                band_type_run_end[idx++] = sect_end;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": 5348, "func": "static ASN1_INTEGER *x509_load_serial(const char *CAfile, const char *serialfile,\n                                      int create)\n{\n    char *buf = NULL, *p;\n    ASN1_INTEGER *bs = NULL;\n    BIGNUM *serial = NULL;\n    size_t len;\n\n    len = ((serialfile == NULL)\n           ? (strlen(CAfile) + strlen(POSTFIX) + 1)\n           : (strlen(serialfile))) + 1;\n    buf = app_malloc(len, \"serial# buffer\");\n    if (serialfile == NULL) {\n        strcpy(buf, CAfile);\n        for (p = buf; *p; p++)\n            if (*p == '.') {\n                *p = '\\0';\n                break;\n            }\n        strcat(buf, POSTFIX);\n    } else {\n        strcpy(buf, serialfile);\n    }\n\n    serial = load_serial(buf, create, NULL);\n    if (serial == NULL)\n        goto end;\n\n    if (!BN_add_word(serial, 1)) {\n        BIO_printf(bio_err, \"add_word failure\\n\");\n        goto end;\n    }\n\n    if (!save_serial(buf, NULL, serial, &bs))\n        goto end;\n\n end:\n    OPENSSL_free(buf);\n    BN_free(serial);\n    return bs;\n}", "target": 0}
{"idx": 5349, "func": "static int decode_nal_sei_pic_timing(HEVCSEIContext *s, GetBitContext *gb, const HEVCParamSets *ps,\n                                     void *logctx, int size)\n{\n    HEVCSEIPictureTiming *h = &s->picture_timing;\n    HEVCSPS *sps;\n\n    if (!ps->sps_list[s->active_seq_parameter_set_id])\n        return(AVERROR(ENOMEM));\n    sps = (HEVCSPS*)ps->sps_list[s->active_seq_parameter_set_id]->data;\n\n    if (sps->vui.frame_field_info_present_flag) {\n        int pic_struct = get_bits(gb, 4);\n        h->picture_struct = AV_PICTURE_STRUCTURE_UNKNOWN;\n        if (pic_struct == 2) {\n            av_log(logctx, AV_LOG_DEBUG, \"BOTTOM Field\\n\");\n            h->picture_struct = AV_PICTURE_STRUCTURE_BOTTOM_FIELD;\n        } else if (pic_struct == 1) {\n            av_log(logctx, AV_LOG_DEBUG, \"TOP Field\\n\");\n            h->picture_struct = AV_PICTURE_STRUCTURE_TOP_FIELD;\n        }\n        get_bits(gb, 2);                   // source_scan_type\n        get_bits(gb, 1);                   // duplicate_flag\n        skip_bits1(gb);\n        size--;\n    }\n    skip_bits_long(gb, 8 * size);\n\n    return 0;\n}", "target": 0}
{"idx": 5350, "func": "static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic,\n                                const uint8_t *src, int src_size)\n{\n    GetByteContext gb;\n    GetBitContext  gb2;\n    int nslices, slice, slice_height, ref_slice_height;\n    int cur_y, next_y;\n    uint32_t off, slice_size;\n    uint8_t *Y, *U, *V;\n    int ret;\n\n    bytestream2_init(&gb, src, src_size);\n    nslices = bytestream2_get_le16(&gb);\n    off = FFALIGN(nslices * 4 + 2, 16);\n    if (src_size < off) {\n        av_log(avctx, AV_LOG_ERROR, \"no slice data\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!nslices || avctx->height % nslices) {\n        avpriv_request_sample(avctx, \"%d slices for %dx%d\", nslices,\n                              avctx->width, avctx->height);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    ref_slice_height = avctx->height / nslices;\n    if ((avctx->width & 1) || (avctx->height & 1)) {\n        avpriv_request_sample(avctx, \"Frame dimensions %dx%d\",\n                              avctx->width, avctx->height);\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    Y = pic->data[0];\n    U = pic->data[1];\n    V = pic->data[2];\n\n    cur_y  = 0;\n    next_y = ref_slice_height;\n    for (slice = 0; slice < nslices; slice++) {\n        slice_size   = bytestream2_get_le32(&gb);\n        slice_height = (next_y & ~1) - (cur_y & ~1);\n\n        ret = check_slice_size(avctx, src, src_size, slice_size, off);\n        if (ret < 0)\n            return ret;\n\n        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);\n        dx2_decode_slice_420(&gb2, avctx->width, slice_height, Y, U, V,\n                             pic->linesize[0], pic->linesize[1],\n                             pic->linesize[2]);\n\n        Y += pic->linesize[0] *  slice_height;\n        U += pic->linesize[1] * (slice_height >> 1);\n        V += pic->linesize[2] * (slice_height >> 1);\n        off += slice_size;\n        cur_y   = next_y;\n        next_y += ref_slice_height;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5351, "func": "static void x509v3_cache_extensions(X509 *x)\n{\n\tBASIC_CONSTRAINTS *bs;\n\tPROXY_CERT_INFO_EXTENSION *pci;\n\tASN1_BIT_STRING *usage;\n\tASN1_BIT_STRING *ns;\n\tEXTENDED_KEY_USAGE *extusage;\n\tX509_EXTENSION *ex;\n\t\n\tint i;\n\tif(x->ex_flags & EXFLAG_SET) return;\n#ifndef OPENSSL_NO_SHA\n\tX509_digest(x, EVP_sha1(), x->sha1_hash, NULL);\n#endif\n\t/* Does subject name match issuer ? */\n\tif(!X509_NAME_cmp(X509_get_subject_name(x), X509_get_issuer_name(x)))\n\t\t\t x->ex_flags |= EXFLAG_SI;\n\t/* V1 should mean no extensions ... */\n\tif(!X509_get_version(x)) x->ex_flags |= EXFLAG_V1;\n\t/* Handle basic constraints */\n\tif((bs=X509_get_ext_d2i(x, NID_basic_constraints, NULL, NULL))) {\n\t\tif(bs->ca) x->ex_flags |= EXFLAG_CA;\n\t\tif(bs->pathlen) {\n\t\t\tif((bs->pathlen->type == V_ASN1_NEG_INTEGER)\n\t\t\t\t\t\t|| !bs->ca) {\n\t\t\t\tx->ex_flags |= EXFLAG_INVALID;\n\t\t\t\tx->ex_pathlen = 0;\n\t\t\t} else x->ex_pathlen = ASN1_INTEGER_get(bs->pathlen);\n\t\t} else x->ex_pathlen = -1;\n\t\tBASIC_CONSTRAINTS_free(bs);\n\t\tx->ex_flags |= EXFLAG_BCONS;\n\t}\n\t/* Handle proxy certificates */\n\tif((pci=X509_get_ext_d2i(x, NID_proxyCertInfo, NULL, NULL))) {\n\t\tif (x->ex_flags & EXFLAG_CA\n\t\t    || X509_get_ext_by_NID(x, NID_subject_alt_name, 0) >= 0\n\t\t    || X509_get_ext_by_NID(x, NID_issuer_alt_name, 0) >= 0) {\n\t\t\tx->ex_flags |= EXFLAG_INVALID;\n\t\t}\n\t\tif (pci->pcPathLengthConstraint) {\n\t\t\tx->ex_pcpathlen =\n\t\t\t\tASN1_INTEGER_get(pci->pcPathLengthConstraint);\n\t\t} else x->ex_pcpathlen = -1;\n\t\tPROXY_CERT_INFO_EXTENSION_free(pci);\n\t\tx->ex_flags |= EXFLAG_PROXY;\n\t}\n\t/* Handle key usage */\n\tif((usage=X509_get_ext_d2i(x, NID_key_usage, NULL, NULL))) {\n\t\tif(usage->length > 0) {\n\t\t\tx->ex_kusage = usage->data[0];\n\t\t\tif(usage->length > 1) \n\t\t\t\tx->ex_kusage |= usage->data[1] << 8;\n\t\t} else x->ex_kusage = 0;\n\t\tx->ex_flags |= EXFLAG_KUSAGE;\n\t\tASN1_BIT_STRING_free(usage);\n\t}\n\tx->ex_xkusage = 0;\n\tif((extusage=X509_get_ext_d2i(x, NID_ext_key_usage, NULL, NULL))) {\n\t\tx->ex_flags |= EXFLAG_XKUSAGE;\n\t\tfor(i = 0; i < sk_ASN1_OBJECT_num(extusage); i++) {\n\t\t\tswitch(OBJ_obj2nid(sk_ASN1_OBJECT_value(extusage,i))) {\n\t\t\t\tcase NID_server_auth:\n\t\t\t\tx->ex_xkusage |= XKU_SSL_SERVER;\n\t\t\t\tbreak;\n\n\t\t\t\tcase NID_client_auth:\n\t\t\t\tx->ex_xkusage |= XKU_SSL_CLIENT;\n\t\t\t\tbreak;\n\n\t\t\t\tcase NID_email_protect:\n\t\t\t\tx->ex_xkusage |= XKU_SMIME;\n\t\t\t\tbreak;\n\n\t\t\t\tcase NID_code_sign:\n\t\t\t\tx->ex_xkusage |= XKU_CODE_SIGN;\n\t\t\t\tbreak;\n\n\t\t\t\tcase NID_ms_sgc:\n\t\t\t\tcase NID_ns_sgc:\n\t\t\t\tx->ex_xkusage |= XKU_SGC;\n\t\t\t\tbreak;\n\n\t\t\t\tcase NID_OCSP_sign:\n\t\t\t\tx->ex_xkusage |= XKU_OCSP_SIGN;\n\t\t\t\tbreak;\n\n\t\t\t\tcase NID_time_stamp:\n\t\t\t\tx->ex_xkusage |= XKU_TIMESTAMP;\n\t\t\t\tbreak;\n\n\t\t\t\tcase NID_dvcs:\n\t\t\t\tx->ex_xkusage |= XKU_DVCS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsk_ASN1_OBJECT_pop_free(extusage, ASN1_OBJECT_free);\n\t}\n\n\tif((ns=X509_get_ext_d2i(x, NID_netscape_cert_type, NULL, NULL))) {\n\t\tif(ns->length > 0) x->ex_nscert = ns->data[0];\n\t\telse x->ex_nscert = 0;\n\t\tx->ex_flags |= EXFLAG_NSCERT;\n\t\tASN1_BIT_STRING_free(ns);\n\t}\n\tx->skid =X509_get_ext_d2i(x, NID_subject_key_identifier, NULL, NULL);\n\tx->akid =X509_get_ext_d2i(x, NID_authority_key_identifier, NULL, NULL);\n\tx->crldp = X509_get_ext_d2i(x, NID_crl_distribution_points, NULL, NULL);\n#ifndef OPENSSL_NO_RFC3779\n \tx->rfc3779_addr =X509_get_ext_d2i(x, NID_sbgp_ipAddrBlock, NULL, NULL);\n \tx->rfc3779_asid =X509_get_ext_d2i(x, NID_sbgp_autonomousSysNum,\n \t\t\t\t\t  NULL, NULL);\n#endif\n\tfor (i = 0; i < X509_get_ext_count(x); i++)\n\t\t{\n\t\tex = X509_get_ext(x, i);\n\t\tif (!X509_EXTENSION_get_critical(ex))\n\t\t\tcontinue;\n\t\tif (!X509_supported_extension(ex))\n\t\t\t{\n\t\t\tx->ex_flags |= EXFLAG_CRITICAL;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tx->ex_flags |= EXFLAG_SET;\n}", "target": 0}
{"idx": 5352, "func": "int ssl3_finish_mac(SSL *s, const unsigned char *buf, size_t len)\n{\n    int ret;\n\n    if (s->s3.handshake_dgst == NULL) {\n        /* Note: this writes to a memory BIO so a failure is a fatal error */\n        if (len > INT_MAX) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_SSL3_FINISH_MAC,\n                     SSL_R_OVERFLOW_ERROR);\n            return 0;\n        }\n        ret = BIO_write(s->s3.handshake_buffer, (void *)buf, (int)len);\n        if (ret <= 0 || ret != (int)len) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_SSL3_FINISH_MAC,\n                     ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    } else {\n        ret = EVP_DigestUpdate(s->s3.handshake_dgst, buf, len);\n        if (!ret) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_SSL3_FINISH_MAC,\n                     ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"idx": 5353, "func": "static int flac_parse(AVCodecParserContext *s, AVCodecContext *avctx,\n                      const uint8_t **poutbuf, int *poutbuf_size,\n                      const uint8_t *buf, int buf_size)\n{\n    FLACParseContext *fpc = s->priv_data;\n    FLACHeaderMarker *curr;\n    int nb_headers;\n    const uint8_t *read_end   = buf;\n    const uint8_t *read_start = buf;\n\n    if (s->flags & PARSER_FLAG_COMPLETE_FRAMES) {\n        FLACFrameInfo fi;\n        if (frame_header_is_valid(avctx, buf, &fi))\n            avctx->frame_size = fi.blocksize;\n        *poutbuf      = buf;\n        *poutbuf_size = buf_size;\n        return buf_size;\n    }\n\n    fpc->avctx = avctx;\n    if (fpc->best_header_valid)\n        return get_best_header(fpc, poutbuf, poutbuf_size);\n\n    /* If a best_header was found last call remove it with the buffer data. */\n    if (fpc->best_header && fpc->best_header->best_child) {\n        FLACHeaderMarker *temp;\n        FLACHeaderMarker *best_child = fpc->best_header->best_child;\n\n        /* Remove headers in list until the end of the best_header. */\n        for (curr = fpc->headers; curr != best_child; curr = temp) {\n            if (curr != fpc->best_header) {\n                av_log(avctx, AV_LOG_DEBUG,\n                       \"dropping low score %i frame header from offset %i to %i\\n\",\n                       curr->max_score, curr->offset, curr->next->offset);\n            }\n            temp = curr->next;\n            av_freep(&curr->link_penalty);\n            av_free(curr);\n            fpc->nb_headers_buffered--;\n        }\n        /* Release returned data from ring buffer. */\n        av_fifo_drain(fpc->fifo_buf, best_child->offset);\n\n        /* Fix the offset for the headers remaining to match the new buffer. */\n        for (curr = best_child->next; curr; curr = curr->next)\n            curr->offset -= best_child->offset;\n\n        fpc->nb_headers_buffered--;\n        best_child->offset = 0;\n        fpc->headers       = best_child;\n        if (fpc->nb_headers_buffered >= FLAC_MIN_HEADERS) {\n            fpc->best_header = best_child;\n            return get_best_header(fpc, poutbuf, poutbuf_size);\n        }\n        fpc->best_header   = NULL;\n    } else if (fpc->best_header) {\n        /* No end frame no need to delete the buffer; probably eof */\n        FLACHeaderMarker *temp;\n\n        for (curr = fpc->headers; curr != fpc->best_header; curr = temp) {\n            temp = curr->next;\n            av_freep(&curr->link_penalty);\n            av_free(curr);\n        }\n        fpc->headers = fpc->best_header->next;\n        av_freep(&fpc->best_header->link_penalty);\n        av_freep(&fpc->best_header);\n    }\n\n    /* Find and score new headers. */\n    while ((buf && read_end < buf + buf_size &&\n            fpc->nb_headers_buffered < FLAC_MIN_HEADERS)\n           || (!buf && !fpc->end_padded)) {\n        int start_offset;\n\n        /* Pad the end once if EOF, to check the final region for headers. */\n        if (!buf) {\n            fpc->end_padded      = 1;\n            buf_size = MAX_FRAME_HEADER_SIZE;\n            read_end = read_start + MAX_FRAME_HEADER_SIZE;\n        } else {\n            /* The maximum read size is the upper-bound of what the parser\n               needs to have the required number of frames buffered */\n            int nb_desired = FLAC_MIN_HEADERS - fpc->nb_headers_buffered + 1;\n            read_end       = read_end + FFMIN(buf + buf_size - read_end,\n                                              nb_desired * FLAC_AVG_FRAME_SIZE);\n        }\n\n        /* Fill the buffer. */\n        if (av_fifo_realloc2(fpc->fifo_buf,\n                             (read_end - read_start) + av_fifo_size(fpc->fifo_buf)) < 0) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"couldn't reallocate buffer of size %d\\n\",\n                   (read_end - read_start) + av_fifo_size(fpc->fifo_buf));\n            goto handle_error;\n        }\n\n        if (buf) {\n            av_fifo_generic_write(fpc->fifo_buf, (void*) read_start,\n                                  read_end - read_start, NULL);\n        } else {\n            int8_t pad[MAX_FRAME_HEADER_SIZE];\n            memset(pad, 0, sizeof(pad));\n            av_fifo_generic_write(fpc->fifo_buf, (void*) pad, sizeof(pad), NULL);\n        }\n\n        /* Tag headers and update sequences. */\n        start_offset = av_fifo_size(fpc->fifo_buf) -\n                       ((read_end - read_start) + (MAX_FRAME_HEADER_SIZE - 1));\n        start_offset = FFMAX(0, start_offset);\n        nb_headers   = find_new_headers(fpc, start_offset);\n\n        if (nb_headers < 0) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"find_new_headers couldn't allocate FLAC header\\n\");\n            goto handle_error;\n        }\n\n        fpc->nb_headers_buffered = nb_headers;\n        /* Wait till FLAC_MIN_HEADERS to output a valid frame. */\n        if (!fpc->end_padded && fpc->nb_headers_buffered < FLAC_MIN_HEADERS) {\n            if (buf && read_end < buf + buf_size) {\n                read_start = read_end;\n                continue;\n            } else {\n                goto handle_error;\n            }\n        }\n\n        /* If headers found, update the scores since we have longer chains. */\n        if (fpc->end_padded || fpc->nb_headers_found)\n            score_sequences(fpc);\n\n        /* restore the state pre-padding */\n        if (fpc->end_padded) {\n            /* HACK: drain the tail of the fifo */\n            fpc->fifo_buf->wptr -= MAX_FRAME_HEADER_SIZE;\n            fpc->fifo_buf->wndx -= MAX_FRAME_HEADER_SIZE;\n            if (fpc->fifo_buf->wptr < 0) {\n                fpc->fifo_buf->wptr += fpc->fifo_buf->end -\n                    fpc->fifo_buf->buffer;\n            }\n            buf_size = 0;\n            read_start = read_end = NULL;\n        }\n    }\n\n    curr = fpc->headers;\n    for (curr = fpc->headers; curr; curr = curr->next)\n        if (!fpc->best_header || curr->max_score > fpc->best_header->max_score)\n            fpc->best_header = curr;\n\n    if (fpc->best_header) {\n        fpc->best_header_valid = 1;\n        if (fpc->best_header->offset > 0) {\n            /* Output a junk frame. */\n            av_log(avctx, AV_LOG_DEBUG, \"Junk frame till offset %i\\n\",\n                   fpc->best_header->offset);\n\n            /* Set frame_size to 0. It is unknown or invalid in a junk frame. */\n            avctx->frame_size = 0;\n            *poutbuf_size     = fpc->best_header->offset;\n            *poutbuf          = flac_fifo_read_wrap(fpc, 0, *poutbuf_size,\n                                                    &fpc->wrap_buf,\n                                                    &fpc->wrap_buf_allocated_size);\n            return buf_size ? (read_end - buf) : (fpc->best_header->offset -\n                                           av_fifo_size(fpc->fifo_buf));\n        }\n        if (!buf_size)\n            return get_best_header(fpc, poutbuf, poutbuf_size);\n    }\n\nhandle_error:\n    *poutbuf      = NULL;\n    *poutbuf_size = 0;\n    return read_end - buf;\n}", "target": 0}
{"idx": 5354, "func": "void CRYPTO_cbc128_encrypt(const unsigned char *in, unsigned char *out,\n                           size_t len, const void *key,\n                           unsigned char ivec[16], block128_f block)\n{\n    size_t n;\n    const unsigned char *iv = ivec;\n\n    if (len == 0)\n        return;\n\n#if !defined(OPENSSL_SMALL_FOOTPRINT)\n    if (STRICT_ALIGNMENT &&\n        ((size_t)in | (size_t)out | (size_t)ivec) % sizeof(size_t) != 0) {\n        while (len >= 16) {\n            for (n = 0; n < 16; ++n)\n                out[n] = in[n] ^ iv[n];\n            (*block) (out, out, key);\n            iv = out;\n            len -= 16;\n            in += 16;\n            out += 16;\n        }\n    } else {\n        while (len >= 16) {\n            for (n = 0; n < 16; n += sizeof(size_t))\n                *(size_t *)(out + n) =\n                    *(size_t *)(in + n) ^ *(size_t *)(iv + n);\n            (*block) (out, out, key);\n            iv = out;\n            len -= 16;\n            in += 16;\n            out += 16;\n        }\n    }\n#endif\n    while (len) {\n        for (n = 0; n < 16 && n < len; ++n)\n            out[n] = in[n] ^ iv[n];\n        for (; n < 16; ++n)\n            out[n] = iv[n];\n        (*block) (out, out, key);\n        iv = out;\n        if (len <= 16)\n            break;\n        len -= 16;\n        in += 16;\n        out += 16;\n    }\n    memcpy(ivec, iv, 16);\n}", "target": 0}
{"idx": 5355, "func": "int i2d_DIST_POINT_NAME(DIST_POINT_NAME *a, unsigned char **pp)\n{\n\tM_ASN1_I2D_vars(a);\n\n\tif(a->fullname) {\n\t\tM_ASN1_I2D_len_IMP_opt (a->fullname, i2d_GENERAL_NAMES);\n\t} else {\n\t\tM_ASN1_I2D_len_IMP_SET_opt_type(X509_NAME_ENTRY,\n\t\t\t\ta->relativename, i2d_X509_NAME_ENTRY, 1);\n\t}\n\n\t/* Don't want a SEQUENCE so... */\n\tif(pp == NULL) return ret;\n\tp = *pp;\n\n\tif(a->fullname) {\n\t\tM_ASN1_I2D_put_IMP_opt (a->fullname, i2d_GENERAL_NAMES, 0);\n\t} else {\n\t\tM_ASN1_I2D_put_IMP_SET_opt_type(X509_NAME_ENTRY,\n\t\t\t\ta->relativename, i2d_X509_NAME_ENTRY, 1);\n\t}\n\tM_ASN1_I2D_finish();\n}", "target": 0}
{"idx": 5356, "func": "static inline void qtrle_decode_2n4bpp(QtrleContext *s, int row_ptr,\n                                       int lines_to_change, int bpp)\n{\n    int rle_code, i;\n    int pixel_ptr;\n    int row_inc = s->frame.linesize[0];\n    unsigned char pi[16];  /* 16 palette indices */\n    unsigned char *rgb = s->frame.data[0];\n    int pixel_limit = s->frame.linesize[0] * s->avctx->height;\n    int num_pixels = (bpp == 4) ? 8 : 16;\n\n    while (lines_to_change--) {\n        pixel_ptr = row_ptr + (num_pixels * (bytestream2_get_byte(&s->g) - 1));\n\n        while ((rle_code = (signed char)bytestream2_get_byte(&s->g)) != -1) {\n            if (rle_code == 0) {\n                /* there's another skip code in the stream */\n                pixel_ptr += (num_pixels * (bytestream2_get_byte(&s->g) - 1));\n                CHECK_PIXEL_PTR(0);  /* make sure pixel_ptr is positive */\n            } else if (rle_code < 0) {\n                /* decode the run length code */\n                rle_code = -rle_code;\n                /* get the next 4 bytes from the stream, treat them as palette\n                 * indexes, and output them rle_code times */\n                for (i = num_pixels-1; i >= 0; i--) {\n                    pi[num_pixels-1-i] = (bytestream2_peek_byte(&s->g) >> ((i*bpp) & 0x07)) & ((1<<bpp)-1);\n                    bytestream2_skip(&s->g, ((i & ((num_pixels>>2)-1)) == 0));\n                }\n                CHECK_PIXEL_PTR(rle_code * num_pixels);\n                while (rle_code--) {\n                    for (i = 0; i < num_pixels; i++)\n                        rgb[pixel_ptr++] = pi[i];\n                }\n            } else {\n                /* copy the same pixel directly to output 4 times */\n                rle_code *= 4;\n                CHECK_PIXEL_PTR(rle_code*(num_pixels>>2));\n                while (rle_code--) {\n                    if(bpp == 4) {\n                        int x = bytestream2_get_byte(&s->g);\n                        rgb[pixel_ptr++] = (x >> 4) & 0x0f;\n                        rgb[pixel_ptr++] =  x       & 0x0f;\n                    } else {\n                        int x = bytestream2_get_byte(&s->g);\n                        rgb[pixel_ptr++] = (x >> 6) & 0x03;\n                        rgb[pixel_ptr++] = (x >> 4) & 0x03;\n                        rgb[pixel_ptr++] = (x >> 2) & 0x03;\n                        rgb[pixel_ptr++] =  x       & 0x03;\n                    }\n                }\n            }\n        }\n        row_ptr += row_inc;\n    }\n}", "target": 0}
{"idx": 5357, "func": "static av_cold int ass_decode_init(AVCodecContext *avctx)\n{\n    avctx->subtitle_header = av_malloc(avctx->extradata_size);\n    if (!avctx->extradata)\n        return AVERROR(ENOMEM);\n    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);\n    avctx->subtitle_header_size = avctx->extradata_size;\n    return 0;\n}", "target": 1}
{"idx": 5358, "func": "static inline int wv_unpack_mono(WavpackFrameContext *s, GetBitContext *gb,\n                                 void *dst, const int type)\n{\n    int i, j, count = 0;\n    int last, t;\n    int A, S, T;\n    int pos                  = s->pos;\n    uint32_t crc             = s->sc.crc;\n    uint32_t crc_extra_bits  = s->extra_sc.crc;\n    int16_t *dst16           = dst;\n    int32_t *dst32           = dst;\n    float *dstfl             = dst;\n\n    s->one = s->zero = s->zeroes = 0;\n    do {\n        T = wv_get_value(s, gb, 0, &last);\n        S = 0;\n        if (last)\n            break;\n        for (i = 0; i < s->terms; i++) {\n            t = s->decorr[i].value;\n            if (t > 8) {\n                if (t & 1)\n                    A =  2U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1];\n                else\n                    A = (int)(3U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1]) >> 1;\n                s->decorr[i].samplesA[1] = s->decorr[i].samplesA[0];\n                j                        = 0;\n            } else {\n                A = s->decorr[i].samplesA[pos];\n                j = (pos + t) & 7;\n            }\n            if (type != AV_SAMPLE_FMT_S16P)\n                S = T + ((s->decorr[i].weightA * (int64_t)A + 512) >> 10);\n            else\n                S = T + ((int)(s->decorr[i].weightA * (unsigned)A + 512) >> 10);\n            if (A && T)\n                s->decorr[i].weightA -= ((((T ^ A) >> 30) & 2) - 1) * s->decorr[i].delta;\n            s->decorr[i].samplesA[j] = T = S;\n        }\n        pos = (pos + 1) & 7;\n        crc = crc * 3 + S;\n\n        if (type == AV_SAMPLE_FMT_FLTP) {\n            *dstfl++ = wv_get_value_float(s, &crc_extra_bits, S);\n        } else if (type == AV_SAMPLE_FMT_S32P) {\n            *dst32++ = wv_get_value_integer(s, &crc_extra_bits, S);\n        } else {\n            *dst16++ = wv_get_value_integer(s, &crc_extra_bits, S);\n        }\n        count++;\n    } while (!last && count < s->samples);\n\n    wv_reset_saved_context(s);\n\n    if (last && count < s->samples) {\n        int size = av_get_bytes_per_sample(type);\n        memset((uint8_t*)dst + count*size, 0, (s->samples-count)*size);\n    }\n\n    if (s->avctx->err_recognition & AV_EF_CRCCHECK) {\n        int ret = wv_check_crc(s, crc, crc_extra_bits);\n        if (ret < 0 && s->avctx->err_recognition & AV_EF_EXPLODE)\n            return ret;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5359, "func": "c448_error_t c448_ed448_verify(\n                    const uint8_t signature[EDDSA_448_SIGNATURE_BYTES],\n                    const uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],\n                    const uint8_t *message, size_t message_len,\n                    uint8_t prehashed, const uint8_t *context,\n                    uint8_t context_len)\n{\n    curve448_point_t pk_point, r_point;\n    c448_error_t error =\n        curve448_point_decode_like_eddsa_and_mul_by_ratio(pk_point, pubkey);\n    curve448_scalar_t challenge_scalar;\n    curve448_scalar_t response_scalar;\n\n    if (C448_SUCCESS != error)\n        return error;\n\n    error =\n        curve448_point_decode_like_eddsa_and_mul_by_ratio(r_point, signature);\n    if (C448_SUCCESS != error)\n        return error;\n\n    {\n        /* Compute the challenge */\n        EVP_MD_CTX *hashctx = EVP_MD_CTX_new();\n        uint8_t challenge[2 * EDDSA_448_PRIVATE_BYTES];\n\n        if (hashctx == NULL\n                || !hash_init_with_dom(hashctx, prehashed, 0, context,\n                                       context_len)\n                || !EVP_DigestUpdate(hashctx, signature, EDDSA_448_PUBLIC_BYTES)\n                || !EVP_DigestUpdate(hashctx, pubkey, EDDSA_448_PUBLIC_BYTES)\n                || !EVP_DigestUpdate(hashctx, message, message_len)\n                || !EVP_DigestFinalXOF(hashctx, challenge, sizeof(challenge))) {\n            EVP_MD_CTX_free(hashctx);\n            return C448_FAILURE;\n        }\n\n        EVP_MD_CTX_free(hashctx);\n        curve448_scalar_decode_long(challenge_scalar, challenge,\n                                    sizeof(challenge));\n        OPENSSL_cleanse(challenge, sizeof(challenge));\n    }\n    curve448_scalar_sub(challenge_scalar, curve448_scalar_zero,\n                        challenge_scalar);\n\n    curve448_scalar_decode_long(response_scalar,\n                                &signature[EDDSA_448_PUBLIC_BYTES],\n                                EDDSA_448_PRIVATE_BYTES);\n\n    /* pk_point = -c(x(P)) + (cx + k)G = kG */\n    curve448_base_double_scalarmul_non_secret(pk_point,\n                                              response_scalar,\n                                              pk_point, challenge_scalar);\n    return c448_succeed_if(curve448_point_eq(pk_point, r_point));\n}", "target": 0}
{"idx": 5360, "func": "void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl)\n{\n    static int print_prefix = 1;\n    static int count;\n    static char prev[LINE_SZ];\n    char part[3][LINE_SZ];\n    char line[LINE_SZ];\n    static int is_atty;\n    int type[2];\n\n    if (level > av_log_level)\n        return;\n    format_line(ptr, level, fmt, vl, part, sizeof(part[0]), &print_prefix, type);\n    snprintf(line, sizeof(line), \"%s%s%s\", part[0], part[1], part[2]);\n\n#if HAVE_ISATTY\n    if (!is_atty)\n        is_atty = isatty(2) ? 1 : -1;\n#endif\n\n#undef fprintf\n    if (print_prefix && (flags & AV_LOG_SKIP_REPEATED) && !strcmp(line, prev)){\n        count++;\n        if (is_atty == 1)\n            fprintf(stderr, \"    Last message repeated %d times\\r\", count);\n        return;\n    }\n    if (count > 0) {\n        fprintf(stderr, \"    Last message repeated %d times\\n\", count);\n        count = 0;\n    }\n    strcpy(prev, line);\n    sanitize(part[0]);\n    colored_fputs(type[0], part[0]);\n    sanitize(part[1]);\n    colored_fputs(type[1], part[1]);\n    sanitize(part[2]);\n    colored_fputs(av_clip(level >> 3, 0, 6), part[2]);\n}", "target": 0}
{"idx": 5361, "func": "static void fill_buffer(AVIOContext *s)\n{\n    uint8_t *dst= !s->max_packet_size && s->buf_end - s->buffer < s->buffer_size ? s->buf_end : s->buffer;\n    int len= s->buffer_size - (dst - s->buffer);\n    int max_buffer_size = s->max_packet_size ? s->max_packet_size : IO_BUFFER_SIZE;\n\n    /* can't fill the buffer without read_packet, just set EOF if appropriate */\n    if (!s->read_packet && s->buf_ptr >= s->buf_end)\n        s->eof_reached = 1;\n\n    /* no need to do anything if EOF already reached */\n    if (s->eof_reached)\n        return;\n\n    if(s->update_checksum && dst == s->buffer){\n        if(s->buf_end > s->checksum_ptr)\n            s->checksum= s->update_checksum(s->checksum, s->checksum_ptr, s->buf_end - s->checksum_ptr);\n        s->checksum_ptr= s->buffer;\n    }\n\n    /* make buffer smaller in case it ended up large after probing */\n    if (s->read_packet && s->buffer_size > max_buffer_size) {\n        ffio_set_buf_size(s, max_buffer_size);\n\n        s->checksum_ptr = dst = s->buffer;\n        len = s->buffer_size;\n    }\n\n    if(s->read_packet)\n        len = s->read_packet(s->opaque, dst, len);\n    else\n        len = 0;\n    if (len <= 0) {\n        /* do not modify buffer if EOF reached so that a seek back can\n           be done without rereading data */\n        s->eof_reached = 1;\n        if(len<0)\n            s->error= len;\n    } else {\n        s->pos += len;\n        s->buf_ptr = dst;\n        s->buf_end = dst + len;\n        s->bytes_read += len;\n    }\n}", "target": 1}
{"idx": 5362, "func": "int avfilter_graph_add_filter(AVFilterGraph *graph, AVFilterContext *filter)\n{\n    AVFilterContext **filters = av_realloc(graph->filters,\n                                           sizeof(AVFilterContext*) * (graph->filter_count+1));\n    if (!filters)\n        return AVERROR(ENOMEM);\n\n    graph->filters = filters;\n    graph->filters[graph->filter_count++] = filter;\n\n    return 0;\n}", "target": 1}
{"idx": 5363, "func": "int ff_update_duplicate_context(MpegEncContext *dst, MpegEncContext *src)\n{\n    MpegEncContext bak;\n    int i, ret;\n    // FIXME copy only needed parts\n    // START_TIMER\n    backup_duplicate_context(&bak, dst);\n    memcpy(dst, src, sizeof(MpegEncContext));\n    backup_duplicate_context(dst, &bak);\n    for (i = 0; i < 12; i++) {\n        dst->pblocks[i] = &dst->block[i];\n    }\n    if (dst->avctx->codec_tag == AV_RL32(\"VCR2\")) {\n        // exchange uv\n        int16_t (*tmp)[64];\n        tmp             = dst->pblocks[4];\n        dst->pblocks[4] = dst->pblocks[5];\n        dst->pblocks[5] = tmp;\n    }\n    if (!dst->sc.edge_emu_buffer &&\n        (ret = ff_mpeg_framesize_alloc(dst->avctx, &dst->me,\n                                       &dst->sc, dst->linesize)) < 0) {\n        av_log(dst->avctx, AV_LOG_ERROR, \"failed to allocate context \"\n               \"scratch buffers.\\n\");\n        return ret;\n    }\n    // STOP_TIMER(\"update_duplicate_context\")\n    // about 10k cycles / 0.01 sec for  1000frames on 1ghz with 2 threads\n    return 0;\n}", "target": 1}
{"idx": 5364, "func": "static inline void MPV_motion_lowres(MpegEncContext *s,\n                                     uint8_t *dest_y, uint8_t *dest_cb,\n                                     uint8_t *dest_cr,\n                                     int dir, uint8_t **ref_picture,\n                                     h264_chroma_mc_func *pix_op)\n{\n    int mx, my;\n    int mb_x, mb_y, i;\n    const int lowres  = s->avctx->lowres;\n    const int block_s = 8 >>lowres;\n\n    mb_x = s->mb_x;\n    mb_y = s->mb_y;\n\n    switch (s->mv_type) {\n    case MV_TYPE_16X16:\n        mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                           0, 0, 0,\n                           ref_picture, pix_op,\n                           s->mv[dir][0][0], s->mv[dir][0][1],\n                           2 * block_s, mb_y);\n        break;\n    case MV_TYPE_8X8:\n        mx = 0;\n        my = 0;\n        for (i = 0; i < 4; i++) {\n            hpel_motion_lowres(s, dest_y + ((i & 1) + (i >> 1) *\n                               s->linesize) * block_s,\n                               ref_picture[0], 0, 0,\n                               (2 * mb_x + (i & 1)) * block_s,\n                               (2 * mb_y + (i >> 1)) * block_s,\n                               s->width, s->height, s->linesize,\n                               s->h_edge_pos >> lowres, s->v_edge_pos >> lowres,\n                               block_s, block_s, pix_op,\n                               s->mv[dir][i][0], s->mv[dir][i][1]);\n\n            mx += s->mv[dir][i][0];\n            my += s->mv[dir][i][1];\n        }\n\n        if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY))\n            chroma_4mv_motion_lowres(s, dest_cb, dest_cr, ref_picture,\n                                     pix_op, mx, my);\n        break;\n    case MV_TYPE_FIELD:\n        if (s->picture_structure == PICT_FRAME) {\n            /* top field */\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               1, 0, s->field_select[dir][0],\n                               ref_picture, pix_op,\n                               s->mv[dir][0][0], s->mv[dir][0][1],\n                               block_s, mb_y);\n            /* bottom field */\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               1, 1, s->field_select[dir][1],\n                               ref_picture, pix_op,\n                               s->mv[dir][1][0], s->mv[dir][1][1],\n                               block_s, mb_y);\n        } else {\n            if (s->picture_structure != s->field_select[dir][0] + 1 &&\n                s->pict_type != AV_PICTURE_TYPE_B && !s->first_field) {\n                ref_picture = s->current_picture_ptr->f.data;\n\n            }\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               0, 0, s->field_select[dir][0],\n                               ref_picture, pix_op,\n                               s->mv[dir][0][0],\n                               s->mv[dir][0][1], 2 * block_s, mb_y >> 1);\n            }\n        break;\n    case MV_TYPE_16X8:\n        for (i = 0; i < 2; i++) {\n            uint8_t **ref2picture;\n\n            if (s->picture_structure == s->field_select[dir][i] + 1 ||\n                s->pict_type == AV_PICTURE_TYPE_B || s->first_field) {\n                ref2picture = ref_picture;\n            } else {\n                ref2picture = s->current_picture_ptr->f.data;\n            }\n\n            mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                               0, 0, s->field_select[dir][i],\n                               ref2picture, pix_op,\n                               s->mv[dir][i][0], s->mv[dir][i][1] +\n                               2 * block_s * i, block_s, mb_y >> 1);\n\n            dest_y  +=  2 * block_s *  s->linesize;\n            dest_cb += (2 * block_s >> s->chroma_y_shift) * s->uvlinesize;\n            dest_cr += (2 * block_s >> s->chroma_y_shift) * s->uvlinesize;\n        }\n        break;\n    case MV_TYPE_DMV:\n        if (s->picture_structure == PICT_FRAME) {\n            for (i = 0; i < 2; i++) {\n                int j;\n                for (j = 0; j < 2; j++) {\n                    mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                                       1, j, j ^ i,\n                                       ref_picture, pix_op,\n                                       s->mv[dir][2 * i + j][0],\n                                       s->mv[dir][2 * i + j][1],\n                                       block_s, mb_y);\n                }\n                pix_op = s->h264chroma.avg_h264_chroma_pixels_tab;\n            }\n        } else {\n            for (i = 0; i < 2; i++) {\n                mpeg_motion_lowres(s, dest_y, dest_cb, dest_cr,\n                                   0, 0, s->picture_structure != i + 1,\n                                   ref_picture, pix_op,\n                                   s->mv[dir][2 * i][0],s->mv[dir][2 * i][1],\n                                   2 * block_s, mb_y >> 1);\n\n                // after put we make avg of the same block\n                pix_op = s->h264chroma.avg_h264_chroma_pixels_tab;\n\n                // opposite parity is always in the same\n                // frame if this is second field\n                if (!s->first_field) {\n                    ref_picture = s->current_picture_ptr->f.data;\n                }\n            }\n        }\n        break;\n    default:\n        av_assert2(0);\n    }\n}", "target": 1}
{"idx": 5365, "func": "static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)\n{\n    int dy  = y1 - y0;\n    int adx = x1 - x0;\n    int ady = FFABS(dy);\n    int sy  = dy < 0 ? -1 : 1;\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n    if (ady*2 <= adx) { // optimized common case\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n    } else {\n        int base  = dy / adx;\n        int x     = x0;\n        uint8_t y = y0;\n        int err   = -adx;\n        ady -= FFABS(base) * adx;\n        while (++x < x1) {\n            y += base;\n            err += ady;\n            if (err >= 0) {\n                err -= adx;\n                y   += sy;\n            }\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n        }\n    }\n}", "target": 0}
{"idx": 5366, "func": "int EC_GROUP_copy(EC_GROUP *dest, const EC_GROUP *src)\n{\n    EC_EXTRA_DATA *d;\n\n    if (dest->meth->group_copy == 0) {\n        ECerr(EC_F_EC_GROUP_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (dest->meth != src->meth) {\n        ECerr(EC_F_EC_GROUP_COPY, EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    if (dest == src)\n        return 1;\n\n    EC_EX_DATA_free_all_data(&dest->extra_data);\n\n    for (d = src->extra_data; d != NULL; d = d->next) {\n        void *t = d->dup_func(d->data);\n\n        if (t == NULL)\n            return 0;\n        if (!EC_EX_DATA_set_data\n            (&dest->extra_data, t, d->dup_func, d->free_func,\n             d->clear_free_func))\n            return 0;\n    }\n\n    if (src->mont_data != NULL) {\n        if (dest->mont_data == NULL) {\n            dest->mont_data = BN_MONT_CTX_new();\n            if (dest->mont_data == NULL)\n                return 0;\n        }\n        if (!BN_MONT_CTX_copy(dest->mont_data, src->mont_data))\n            return 0;\n    } else {\n        /* src->generator == NULL */\n        BN_MONT_CTX_free(dest->mont_data);\n        dest->mont_data = NULL;\n    }\n\n    if (src->generator != NULL) {\n        if (dest->generator == NULL) {\n            dest->generator = EC_POINT_new(dest);\n            if (dest->generator == NULL)\n                return 0;\n        }\n        if (!EC_POINT_copy(dest->generator, src->generator))\n            return 0;\n    } else {\n        /* src->generator == NULL */\n        EC_POINT_clear_free(dest->generator);\n        dest->generator = NULL;\n    }\n\n    if (!BN_copy(dest->order, src->order))\n        return 0;\n    if (!BN_copy(dest->cofactor, src->cofactor))\n        return 0;\n\n    dest->curve_name = src->curve_name;\n    dest->asn1_flag = src->asn1_flag;\n    dest->asn1_form = src->asn1_form;\n\n    if (src->seed) {\n        OPENSSL_free(dest->seed);\n        dest->seed = OPENSSL_malloc(src->seed_len);\n        if (dest->seed == NULL)\n            return 0;\n        if (!memcpy(dest->seed, src->seed, src->seed_len))\n            return 0;\n        dest->seed_len = src->seed_len;\n    } else {\n        OPENSSL_free(dest->seed);\n        dest->seed = NULL;\n        dest->seed_len = 0;\n    }\n\n    return dest->meth->group_copy(dest, src);\n}", "target": 1}
{"idx": 5367, "func": "void\n_TIFFmemset(void* p, int v, tmsize_t c)\n{\n\tmemset(p, v, (size_t) c);\n}", "target": 0}
{"idx": 5368, "func": "static int do_test_file(const char *testfile)\n{\n    BIO *in;\n    EVP_TEST t;\n    int c;\n\n    set_test_title(testfile);\n    current_test_file = testfile;\n    if (!TEST_ptr(in = BIO_new_file(testfile, \"rb\")))\n        return 0;\n    memset(&t, 0, sizeof(t));\n    t.in = in;\n\n    TEST_info(\"Reading %s\", testfile);\n    for ( ; ; ) {\n        c = read_stanza(&t);\n        if (t.skip)\n            continue;\n        if (c == 0 || !run_test(&t)) {\n            t.errors++;\n            break;\n        }\n        if (c == EOF)\n            break;\n    }\n    clear_test(&t);\n\n    TEST_info(\"Completed %d tests with %d errors and %d skipped\",\n              t.ntests, t.errors, t.nskip);\n    free_key_list(public_keys);\n    free_key_list(private_keys);\n    BIO_free(t.key);\n    BIO_free(in);\n    return t.errors == 0;\n}", "target": 1}
{"idx": 5369, "func": "BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w)\n\t{\n#ifndef BN_LLONG\n\tBN_ULONG ret=0;\n#else\n\tBN_ULLONG ret=0;\n#endif\n\tint i;\n\n\tif (w == 0)\n\t\treturn (BN_ULONG)-1;\n\n\tbn_check_top(a);\n\tw&=BN_MASK2;\n\tfor (i=a->top-1; i>=0; i--)\n\t\t{\n#ifndef BN_LLONG\n\t\tret=((ret<<BN_BITS4)|((a->d[i]>>BN_BITS4)&BN_MASK2l))%w;\n\t\tret=((ret<<BN_BITS4)|(a->d[i]&BN_MASK2l))%w;\n#else\n\t\tret=(BN_ULLONG)(((ret<<(BN_ULLONG)BN_BITS2)|a->d[i])%\n\t\t\t(BN_ULLONG)w);\n#endif\n\t\t}\n\treturn((BN_ULONG)ret);\n\t}", "target": 1}
{"idx": 5370, "func": "static int test_secret(SSL *s, unsigned char *prk,\n                       const unsigned char *label, size_t labellen,\n                       const unsigned char *ref_secret,\n                       const unsigned char *ref_key, const unsigned char *ref_iv)\n{\n    size_t hashsize;\n    unsigned char gensecret[EVP_MAX_MD_SIZE];\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned char key[KEYLEN];\n    unsigned char iv[IVLEN];\n    const EVP_MD *md = ssl_handshake_md(s);\n\n    if (!ssl_handshake_hash(s, hash, sizeof(hash), &hashsize)) {\n        TEST_error(\"Failed to get hash\");\n        return 0;\n    }\n\n    if (!tls13_hkdf_expand(s, md, prk, label, labellen, hash, hashsize,\n                           gensecret, hashsize, 1)) {\n        TEST_error(\"Secret generation failed\");\n        return 0;\n    }\n\n    if (!TEST_mem_eq(gensecret, hashsize, ref_secret, hashsize))\n        return 0;\n\n    if (!tls13_derive_key(s, md, gensecret, key, KEYLEN)) {\n        TEST_error(\"Key generation failed\");\n        return 0;\n    }\n\n    if (!TEST_mem_eq(key, KEYLEN, ref_key, KEYLEN))\n        return 0;\n\n    if (!tls13_derive_iv(s, md, gensecret, iv, IVLEN)) {\n        TEST_error(\"IV generation failed\");\n        return 0;\n    }\n\n    if (!TEST_mem_eq(iv, IVLEN, ref_iv, IVLEN))\n        return 0;\n\n    return 1;\n}", "target": 0}
{"idx": 5371, "func": "static struct segment *current_segment(struct playlist *pls)\n{\n    return pls->segments[pls->cur_seq_no - pls->start_seq_no];\n}", "target": 1}
{"idx": 5372, "func": "static int test_rand_range_single(size_t n)\n{\n    const unsigned int range = rand_range_cases[n].range;\n    const unsigned int iterations = rand_range_cases[n].iterations;\n    const double critical = rand_range_cases[n].critical;\n    const double expected = iterations / (double)range;\n    double sum = 0;\n    BIGNUM *rng = NULL, *val = NULL;\n    size_t *counts;\n    unsigned int i, v;\n    int res = 0;\n\n    if (!TEST_ptr(counts = OPENSSL_zalloc(sizeof(*counts) * range))\n        || !TEST_ptr(rng = BN_new())\n        || !TEST_ptr(val = BN_new())\n        || !TEST_true(BN_set_word(rng, range)))\n        goto err;\n    for (i = 0; i < iterations; i++) {\n        if (!TEST_true(BN_rand_range(val, rng))\n            || !TEST_uint_lt(v = (unsigned int)BN_get_word(val), range))\n            goto err;\n        counts[v]++;\n    }\n\n    for (i = 0; i < range; i++) {\n        const double delta = counts[i] - expected;\n        sum += delta * delta;\n    }\n    sum /= expected;\n\n    if (sum > critical) {\n        TEST_info(\"Chi^2 test negative %.4f > %4.f\", sum, critical);\n        TEST_note(\"test case %zu  range %u  iterations %u\", n + 1, range,\n                  iterations);\n        goto err;\n    }\n\n    res = 1;\nerr:\n    BN_free(rng);\n    BN_free(val);\n    OPENSSL_free(counts);\n    return res;\n}", "target": 0}
{"idx": 5373, "func": "int ff_do_elbg(int *points, int dim, int numpoints, int *codebook,\n                int numCB, int max_steps, int *closest_cb,\n                AVLFG *rand_state)\n{\n    int dist;\n    elbg_data elbg_d;\n    elbg_data *elbg = &elbg_d;\n    int i, j, k, last_error, steps = 0, ret = 0;\n    int *dist_cb = av_malloc(numpoints*sizeof(int));\n    int *size_part = av_malloc(numCB*sizeof(int));\n    cell *list_buffer = av_malloc(numpoints*sizeof(cell));\n    cell *free_cells;\n    int best_dist, best_idx = 0;\n\n    elbg->error = INT_MAX;\n    elbg->dim = dim;\n    elbg->numCB = numCB;\n    elbg->codebook = codebook;\n    elbg->cells = av_malloc(numCB*sizeof(cell *));\n    elbg->utility = av_malloc(numCB*sizeof(int));\n    elbg->nearest_cb = closest_cb;\n    elbg->points = points;\n    elbg->utility_inc = av_malloc(numCB*sizeof(int));\n    elbg->scratchbuf = av_malloc(5*dim*sizeof(int));\n\n    if (!dist_cb || !size_part || !list_buffer || !elbg->cells ||\n        !elbg->utility || !elbg->utility_inc || !elbg->scratchbuf) {\n        ret = AVERROR(ENOMEM);\n        goto out;\n    }\n\n    elbg->rand_state = rand_state;\n\n    do {\n        free_cells = list_buffer;\n        last_error = elbg->error;\n        steps++;\n        memset(elbg->utility, 0, numCB*sizeof(int));\n        memset(elbg->cells, 0, numCB*sizeof(cell *));\n\n        elbg->error = 0;\n\n        /* This loop evaluate the actual Voronoi partition. It is the most\n           costly part of the algorithm. */\n        for (i=0; i < numpoints; i++) {\n            best_dist = distance_limited(elbg->points + i*elbg->dim, elbg->codebook + best_idx*elbg->dim, dim, INT_MAX);\n            for (k=0; k < elbg->numCB; k++) {\n                dist = distance_limited(elbg->points + i*elbg->dim, elbg->codebook + k*elbg->dim, dim, best_dist);\n                if (dist < best_dist) {\n                    best_dist = dist;\n                    best_idx = k;\n                }\n            }\n            elbg->nearest_cb[i] = best_idx;\n            dist_cb[i] = best_dist;\n            elbg->error += dist_cb[i];\n            elbg->utility[elbg->nearest_cb[i]] += dist_cb[i];\n            free_cells->index = i;\n            free_cells->next = elbg->cells[elbg->nearest_cb[i]];\n            elbg->cells[elbg->nearest_cb[i]] = free_cells;\n            free_cells++;\n        }\n\n        do_shiftings(elbg);\n\n        memset(size_part, 0, numCB*sizeof(int));\n\n        memset(elbg->codebook, 0, elbg->numCB*dim*sizeof(int));\n\n        for (i=0; i < numpoints; i++) {\n            size_part[elbg->nearest_cb[i]]++;\n            for (j=0; j < elbg->dim; j++)\n                elbg->codebook[elbg->nearest_cb[i]*elbg->dim + j] +=\n                    elbg->points[i*elbg->dim + j];\n        }\n\n        for (i=0; i < elbg->numCB; i++)\n            vect_division(elbg->codebook + i*elbg->dim,\n                          elbg->codebook + i*elbg->dim, size_part[i], elbg->dim);\n\n    } while(((last_error - elbg->error) > DELTA_ERR_MAX*elbg->error) &&\n            (steps < max_steps));\n\nout:\n    av_free(dist_cb);\n    av_free(size_part);\n    av_free(elbg->utility);\n    av_free(list_buffer);\n    av_free(elbg->cells);\n    av_free(elbg->utility_inc);\n    av_free(elbg->scratchbuf);\n    return ret;\n}", "target": 1}
{"idx": 5374, "func": "static void vc1_inv_trans_4x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n{\n    int i;\n    int dc = block[0];\n    const uint8_t *cm;\n    dc = (17 * dc +  4) >> 3;\n    dc = (17 * dc + 64) >> 7;\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n    for(i = 0; i < 4; i++){\n        dest[0] = cm[dest[0]];\n        dest[1] = cm[dest[1]];\n        dest[2] = cm[dest[2]];\n        dest[3] = cm[dest[3]];\n        dest += linesize;\n    }\n}", "target": 1}
{"idx": 5375, "func": "void av_freep(void *arg)\n{\n    void **ptr= (void**)arg;\n    av_free(*ptr);\n    *ptr = NULL;\n}", "target": 1}
{"idx": 5376, "func": "static apr_status_t sock_read(int fd, void *vbuf, size_t buf_size)\n{\n    char *buf = vbuf;\n    int rc;\n    size_t bytes_read = 0;\n\n    do {\n        do {\n            rc = read(fd, buf + bytes_read, buf_size - bytes_read);\n        } while (rc < 0 && errno == EINTR);\n        switch(rc) {\n        case -1:\n            return errno;\n        case 0: /* unexpected */\n            return ECONNRESET;\n        default:\n            bytes_read += rc;\n        }\n    } while (bytes_read < buf_size);\n\n    return APR_SUCCESS;\n}", "target": 1}
{"idx": 5377, "func": "static int cms_add1_signingTime(CMS_SignerInfo *si, ASN1_TIME *t)\n\t{\n\tASN1_TIME *tt;\n\tint r = 0;\n\tif (t)\n\t\ttt = t;\n\telse\n\t\ttt = X509_gmtime_adj(NULL, 0);\n\n\tif (!tt)\n\t\tgoto merr;\n\n\tif (CMS_signed_add1_attr_by_NID(si, NID_pkcs9_signingTime,\n\t\t\t\t\t\ttt->type, tt, -1) <= 0)\n\t\tgoto merr;\n\n\tr = 1;\n\n\tmerr:\n\n\tif (!t)\n\t\tASN1_TIME_free(tt);\n\n\tif (!r)\n\t\tCMSerr(CMS_F_CMS_ADD1_SIGNINGTIME, ERR_R_MALLOC_FAILURE);\n\n\treturn r;\n\n\t}", "target": 0}
{"idx": 5378, "func": "static int\ngtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileContigRoutine put = img->put.contig;\n\tuint32 row, y, nrow, nrowsub, rowstoread;\n\ttmsize_t pos;\n\tunsigned char* buf = NULL;\n\tuint32 rowsperstrip;\n\tuint16 subsamplinghor,subsamplingver;\n\tuint32 imagewidth = img->width;\n\ttmsize_t scanline;\n\tint32 fromskew, toskew;\n\tint ret = 1, flip;\n        tmsize_t maxstripsize;\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\tif( subsamplingver == 0 ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Invalid vertical YCbCr subsampling\");\n\t\treturn (0);\n\t}\n\t\n\tmaxstripsize = TIFFStripSize(tif);\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t} else {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\n\tscanline = TIFFScanlineSize(tif);\n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\tnrowsub = nrow;\n\t\tif ((nrowsub%subsamplingver)!=0)\n\t\t\tnrowsub+=subsamplingver-nrowsub%subsamplingver;\n\t\tif (_TIFFReadEncodedStripAndAllocBuffer(tif,\n\t\t    TIFFComputeStrip(tif,row+img->row_offset, 0),\n\t\t    (void**)(&buf),\n                    maxstripsize,\n\t\t    ((row + img->row_offset)%rowsperstrip + nrowsub) * scanline)==(tmsize_t)(-1)\n\t\t    && (buf == NULL || img->stoponerr))\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}", "target": 1}
{"idx": 5379, "func": "int gost2001_do_verify(const unsigned char *dgst,int dgst_len,\n\tDSA_SIG *sig, EC_KEY *ec)\n\t{\n\tBN_CTX *ctx=BN_CTX_new();\n\tconst EC_GROUP *group = EC_KEY_get0_group(ec);\n\tBIGNUM *order;\n\tBIGNUM *md = NULL,*e=NULL,*R=NULL,*v=NULL,*z1=NULL,*z2=NULL;\n\tBIGNUM *X=NULL,*tmp=NULL;\n\tEC_POINT *C = NULL;\n\tconst EC_POINT *pub_key=NULL;\n\tint ok=0;\n\n\tBN_CTX_start(ctx);\n\torder = BN_CTX_get(ctx);\n\te = BN_CTX_get(ctx);\n\tz1 = BN_CTX_get(ctx);\n\tz2 = BN_CTX_get(ctx);\n\ttmp = BN_CTX_get(ctx);\n\tX= BN_CTX_get(ctx);\t\n\tR=BN_CTX_get(ctx);\n\tv=BN_CTX_get(ctx);\n\t\n\tEC_GROUP_get_order(group,order,ctx);\n\tpub_key = EC_KEY_get0_public_key(ec);\n\tif (BN_is_zero(sig->s) || BN_is_zero(sig->r) ||\n\t\t(BN_cmp(sig->s,order)>=1) || (BN_cmp(sig->r,order)>=1)) \n\t\t{\n\t\tGOSTerr(GOST_F_GOST2001_DO_VERIFY,GOST_R_SIGNATURE_PARTS_GREATER_THAN_Q);\n\t\tgoto err;\n\n\t\t}\n\tmd = hashsum2bn(dgst);\n\n\tBN_mod(e,md,order,ctx);\n#ifdef DEBUG_SIGN\n\tfprintf(stderr,\"digest as bignum: \");\n\tBN_print_fp(stderr,md);\n\tfprintf(stderr,\"\\ndigest mod q: \");\n\tBN_print_fp(stderr,e);\n#endif\t\n\tif (BN_is_zero(e)) BN_one(e);\n\tv=BN_mod_inverse(v,e,order,ctx);\n\tBN_mod_mul(z1,sig->s,v,order,ctx);\n\tBN_sub(tmp,order,sig->r);\n\tBN_mod_mul(z2,tmp,v,order,ctx);\n#ifdef DEBUG_SIGN\n\tfprintf(stderr,\"\\nInverted digest value: \");\n\tBN_print_fp(stderr,v);\n\tfprintf(stderr,\"\\nz1: \");\n\tBN_print_fp(stderr,z1);\n\tfprintf(stderr,\"\\nz2: \");\n\tBN_print_fp(stderr,z2);\n#endif\t\n\tC = EC_POINT_new(group);\n\tif (!EC_POINT_mul(group,C,z1,pub_key,z2,ctx)) \n\t\t{\t\n\t\tGOSTerr(GOST_F_GOST2001_DO_VERIFY,ERR_R_EC_LIB);\n\t\tgoto err;\n\t\t}\t\n\tif (!EC_POINT_get_affine_coordinates_GFp(group,C,X,NULL,ctx)) \n\t\t{\n\t\tGOSTerr(GOST_F_GOST2001_DO_VERIFY,ERR_R_EC_LIB);\n\t\tgoto err;\n\t\t}\n\tBN_mod(R,X,order,ctx);\n#ifdef DEBUG_SIGN\n\tfprintf(stderr,\"\\nX=\");\n\tBN_print_fp(stderr,X);\n\tfprintf(stderr,\"\\nX mod q=\");\n\tBN_print_fp(stderr,R);\n\tfprintf(stderr,\"\\n\");\n#endif\t\n\tif (BN_cmp(R,sig->r)!=0)\n\t\t{\n\t\tGOSTerr(GOST_F_GOST2001_DO_VERIFY,GOST_R_SIGNATURE_MISMATCH);\n\t\t}\n\telse\n\t\t{\n\t\tok = 1;\n\t\t}\n\terr:\n\tEC_POINT_free(C);\n\tBN_CTX_end(ctx);\n\tBN_CTX_free(ctx);\n\tBN_free(md);\n\treturn ok;\n\t}", "target": 1}
{"idx": 5380, "func": "static int init(AVFilterContext *ctx, const char *args)\n{\n    EvalContext *eval = ctx->priv;\n    char *args1 = av_strdup(args);\n    char *expr, *buf, *bufptr;\n    int ret, i;\n\n    eval->class = &aevalsrc_class;\n    av_opt_set_defaults(eval);\n\n    if (!args1) {\n        av_log(ctx, AV_LOG_ERROR, \"Argument is empty\\n\");\n        ret = args ? AVERROR(ENOMEM) : AVERROR(EINVAL);\n        goto end;\n    }\n\n    /* parse expressions */\n    buf = args1;\n    i = 0;\n    while (expr = av_strtok(buf, \":\", &bufptr)) {\n        ret = av_expr_parse(&eval->expr[i], expr, var_names,\n                            NULL, NULL, NULL, NULL, 0, ctx);\n        if (ret < 0)\n            goto end;\n        i++;\n        if (bufptr && *bufptr == ':') { /* found last expression */\n            bufptr++;\n            break;\n        }\n        buf = NULL;\n    }\n    eval->nb_channels = i;\n\n    if (bufptr && (ret = av_set_options_string(eval, bufptr, \"=\", \":\")) < 0)\n        goto end;\n\n    if (eval->chlayout_str) {\n        int n;\n        ret = ff_parse_channel_layout(&eval->chlayout, eval->chlayout_str, ctx);\n        if (ret < 0)\n            goto end;\n\n        n = av_get_channel_layout_nb_channels(eval->chlayout);\n        if (n != eval->nb_channels) {\n            av_log(ctx, AV_LOG_ERROR,\n                   \"Mismatch between the specified number of channels '%d' \"\n                   \"and the number of channels '%d' in the specified channel layout '%s'\\n\",\n                   eval->nb_channels, n, eval->chlayout_str);\n            ret = AVERROR(EINVAL);\n            goto end;\n        }\n    } else {\n        /* guess channel layout from nb expressions/channels */\n        eval->chlayout = av_get_default_channel_layout(eval->nb_channels);\n        if (!eval->chlayout) {\n            av_log(ctx, AV_LOG_ERROR, \"Invalid number of channels '%d' provided\\n\",\n                   eval->nb_channels);\n            ret = AVERROR(EINVAL);\n            goto end;\n        }\n    }\n\n    if ((ret = ff_parse_sample_rate(&eval->sample_rate, eval->sample_rate_str, ctx)))\n        goto end;\n\n    eval->duration = -1;\n    if (eval->duration_str) {\n        int64_t us = -1;\n        if ((ret = av_parse_time(&us, eval->duration_str, 1)) < 0) {\n            av_log(ctx, AV_LOG_ERROR, \"Invalid duration: '%s'\\n\", eval->duration_str);\n            goto end;\n        }\n        eval->duration = (double)us / 1000000;\n    }\n    eval->n = 0;\n\nend:\n    av_free(args1);\n    return ret;\n}", "target": 0}
{"idx": 5381, "func": "int ff_msmpeg4_encode_init(MpegEncContext *s)\n{\n    static int init_done=0;\n    int i, ret;\n\n    ff_msmpeg4_common_init(s);\n    if(s->msmpeg4_version>=4){\n        s->min_qcoeff= -255;\n        s->max_qcoeff=  255;\n    }\n\n    if (!init_done) {\n        /* init various encoding tables */\n        init_done = 1;\n        if ((ret = init_mv_table(&ff_mv_tables[0])) < 0)\n            return ret;\n        if ((ret = init_mv_table(&ff_mv_tables[1])) < 0)\n            return ret;\n        for(i=0;i<NB_RL_TABLES;i++)\n            ff_init_rl(&ff_rl_table[i], ff_static_rl_table_store[i]);\n\n        for(i=0; i<NB_RL_TABLES; i++){\n            int level;\n            for (level = 1; level <= MAX_LEVEL; level++) {\n                int run;\n                for(run=0; run<=MAX_RUN; run++){\n                    int last;\n                    for(last=0; last<2; last++){\n                        rl_length[i][level][run][last]= get_size_of_code(s, &ff_rl_table[  i], last, run, level, 0);\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5382, "func": "static void output_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost)\n{\n    int ret = 0;\n\n    /* apply the output bitstream filters, if any */\n    if (ost->nb_bitstream_filters) {\n        int idx;\n\n        av_packet_split_side_data(pkt);\n        ret = av_bsf_send_packet(ost->bsf_ctx[0], pkt);\n        if (ret < 0)\n            goto finish;\n\n        idx = 1;\n        while (idx) {\n            /* get a packet from the previous filter up the chain */\n            ret = av_bsf_receive_packet(ost->bsf_ctx[idx - 1], pkt);\n            /* HACK! - aac_adtstoasc updates extradata after filtering the first frame when\n             * the api states this shouldn't happen after init(). Propagate it here to the\n             * muxer and to the next filters in the chain to workaround this.\n             * TODO/FIXME - Make aac_adtstoasc use new packet side data instead of changing\n             * par_out->extradata and adapt muxers accordingly to get rid of this. */\n            if (!(ost->bsf_extradata_updated[idx - 1] & 1)) {\n                ret = avcodec_parameters_copy(ost->st->codecpar, ost->bsf_ctx[idx - 1]->par_out);\n                if (ret < 0)\n                    goto finish;\n                ost->bsf_extradata_updated[idx - 1] |= 1;\n            }\n            if (ret == AVERROR(EAGAIN)) {\n                ret = 0;\n                idx--;\n                continue;\n            } else if (ret < 0)\n                goto finish;\n\n            /* send it to the next filter down the chain or to the muxer */\n            if (idx < ost->nb_bitstream_filters) {\n                /* HACK/FIXME! - See above */\n                if (!(ost->bsf_extradata_updated[idx] & 2)) {\n                    ret = avcodec_parameters_copy(ost->bsf_ctx[idx]->par_out, ost->bsf_ctx[idx - 1]->par_out);\n                    if (ret < 0)\n                        goto finish;\n                    ost->bsf_extradata_updated[idx] |= 2;\n                }\n                ret = av_bsf_send_packet(ost->bsf_ctx[idx], pkt);\n                if (ret < 0)\n                    goto finish;\n                idx++;\n            } else\n                write_packet(of, pkt, ost);\n        }\n    } else\n        write_packet(of, pkt, ost);\n\nfinish:\n    if (ret < 0 && ret != AVERROR_EOF) {\n        av_log(NULL, AV_LOG_ERROR, \"Error applying bitstream filters to an output \"\n               \"packet for stream #%d:%d.\\n\", ost->file_index, ost->index);\n        if(exit_on_error)\n            exit_program(1);\n    }\n}", "target": 0}
{"idx": 5383, "func": "int ff_insert_pad(unsigned idx, unsigned *count, size_t padidx_off,\n                   AVFilterPad **pads, AVFilterLink ***links,\n                   AVFilterPad *newpad)\n{\n    AVFilterLink **newlinks;\n    AVFilterPad *newpads;\n    unsigned i;\n\n    idx = FFMIN(idx, *count);\n\n    newpads  = av_realloc_array(*pads,  *count + 1, sizeof(AVFilterPad));\n    newlinks = av_realloc_array(*links, *count + 1, sizeof(AVFilterLink*));\n    if (newpads)\n        *pads  = newpads;\n    if (newlinks)\n        *links = newlinks;\n    if (!newpads || !newlinks)\n        return AVERROR(ENOMEM);\n\n    memmove(*pads  + idx + 1, *pads  + idx, sizeof(AVFilterPad)   * (*count - idx));\n    memmove(*links + idx + 1, *links + idx, sizeof(AVFilterLink*) * (*count - idx));\n    memcpy(*pads + idx, newpad, sizeof(AVFilterPad));\n    (*links)[idx] = NULL;\n\n    (*count)++;\n    for (i = idx + 1; i < *count; i++)\n        if (*links[i])\n            (*(unsigned *)((uint8_t *) *links[i] + padidx_off))++;\n\n    return 0;\n}", "target": 0}
{"idx": 5384, "func": "void RSA_free(RSA *r)\n\t{\n\tRSA_METHOD *meth;\n\tint i;\n\n\tif (r == NULL) return;\n\n\ti=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_RSA);\n#ifdef REF_PRINT\n\tREF_PRINT(\"RSA\",r);\n#endif\n\tif (i > 0) return;\n#ifdef REF_CHECK\n\tif (i < 0)\n\t\t{\n\t\tfprintf(stderr,\"RSA_free, bad reference count\\n\");\n\t\tabort();\n\t\t}\n#endif\n\n\tCRYPTO_free_ex_data(rsa_meth,r,&r->ex_data);\n\n\tmeth = ENGINE_get_RSA(r->engine);\n\tif (meth->finish != NULL)\n\t\tmeth->finish(r);\n\tENGINE_finish(r->engine);\n\n\tif (r->n != NULL) BN_clear_free(r->n);\n\tif (r->e != NULL) BN_clear_free(r->e);\n\tif (r->d != NULL) BN_clear_free(r->d);\n\tif (r->p != NULL) BN_clear_free(r->p);\n\tif (r->q != NULL) BN_clear_free(r->q);\n\tif (r->dmp1 != NULL) BN_clear_free(r->dmp1);\n\tif (r->dmq1 != NULL) BN_clear_free(r->dmq1);\n\tif (r->iqmp != NULL) BN_clear_free(r->iqmp);\n\tif (r->blinding != NULL) BN_BLINDING_free(r->blinding);\n\tif (r->bignum_data != NULL) OPENSSL_free_locked(r->bignum_data);\n\tOPENSSL_free(r);\n\t}", "target": 0}
{"idx": 5385, "func": "ngx_int_t\nngx_http_upstream_get_round_robin_peer(ngx_peer_connection_t *pc, void *data)\n{\n    ngx_http_upstream_rr_peer_data_t  *rrp = data;\n\n    ngx_int_t                      rc;\n    ngx_uint_t                     i, n;\n    ngx_connection_t              *c;\n    ngx_http_upstream_rr_peer_t   *peer;\n    ngx_http_upstream_rr_peers_t  *peers;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,\n                   \"get rr peer, try: %ui\", pc->tries);\n\n    /* ngx_lock_mutex(rrp->peers->mutex); */\n\n    if (rrp->peers->last_cached) {\n\n        /* cached connection */\n\n        c = rrp->peers->cached[rrp->peers->last_cached];\n        rrp->peers->last_cached--;\n\n        /* ngx_unlock_mutex(ppr->peers->mutex); */\n\n#if (NGX_THREADS)\n        c->read->lock = c->read->own_lock;\n        c->write->lock = c->write->own_lock;\n#endif\n\n        pc->connection = c;\n        pc->cached = 1;\n\n        return NGX_OK;\n    }\n\n    pc->cached = 0;\n    pc->connection = NULL;\n\n    if (rrp->peers->single) {\n        peer = &rrp->peers->peer[0];\n\n    } else {\n\n        /* there are several peers */\n\n        peer = ngx_http_upstream_get_peer(rrp);\n\n        if (peer == NULL) {\n            goto failed;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc->log, 0,\n                       \"get rr peer, current: %ui %i\",\n                       rrp->current, peer->current_weight);\n    }\n\n    pc->sockaddr = peer->sockaddr;\n    pc->socklen = peer->socklen;\n    pc->name = &peer->name;\n\n    /* ngx_unlock_mutex(rrp->peers->mutex); */\n\n    if (pc->tries == 1 && rrp->peers->next) {\n        pc->tries += rrp->peers->next->number;\n    }\n\n    return NGX_OK;\n\nfailed:\n\n    peers = rrp->peers;\n\n    if (peers->next) {\n\n        /* ngx_unlock_mutex(peers->mutex); */\n\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, pc->log, 0, \"backup servers\");\n\n        rrp->peers = peers->next;\n        pc->tries = rrp->peers->number;\n\n        n = rrp->peers->number / (8 * sizeof(uintptr_t)) + 1;\n        for (i = 0; i < n; i++) {\n             rrp->tried[i] = 0;\n        }\n\n        rc = ngx_http_upstream_get_round_robin_peer(pc, rrp);\n\n        if (rc != NGX_BUSY) {\n            return rc;\n        }\n\n        /* ngx_lock_mutex(peers->mutex); */\n    }\n\n    /* all peers failed, mark them as live for quick recovery */\n\n    for (i = 0; i < peers->number; i++) {\n        peers->peer[i].fails = 0;\n    }\n\n    /* ngx_unlock_mutex(peers->mutex); */\n\n    pc->name = peers->name;\n\n    return NGX_BUSY;\n}", "target": 0}
{"idx": 5386, "func": "ASN1_STRING_TABLE *ASN1_STRING_TABLE_get(int nid)\n{\n\tint idx;\n\tASN1_STRING_TABLE *ttmp;\n\tASN1_STRING_TABLE fnd;\n\tfnd.nid = nid;\n\tttmp = OBJ_bsearch_table(&fnd, tbl_standard, \n\t\t\t   sizeof(tbl_standard)/sizeof(ASN1_STRING_TABLE));\n\tif(ttmp) return ttmp;\n\tif(!stable) return NULL;\n\tidx = sk_ASN1_STRING_TABLE_find(stable, &fnd);\n\tif(idx < 0) return NULL;\n\treturn sk_ASN1_STRING_TABLE_value(stable, idx);\n}", "target": 0}
{"idx": 5387, "func": "static void writeout(AVIOContext *s, const uint8_t *data, int len)\n{\n    if (!s->error) {\n        int ret = 0;\n        if (s->write_data_type)\n            ret = s->write_data_type(s->opaque, (uint8_t *)data,\n                                     len,\n                                     s->current_type,\n                                     s->last_time);\n        else if (s->write_packet)\n            ret = s->write_packet(s->opaque, (uint8_t *)data, len);\n        if (ret < 0) {\n            s->error = ret;\n        }\n    }\n    if (s->current_type == AVIO_DATA_MARKER_SYNC_POINT ||\n        s->current_type == AVIO_DATA_MARKER_BOUNDARY_POINT) {\n        s->current_type = AVIO_DATA_MARKER_UNKNOWN;\n    }\n    s->last_time = AV_NOPTS_VALUE;\n    s->writeout_count ++;\n    s->pos += len;\n}", "target": 1}
{"idx": 5388, "func": "static PayloadContext *\nrdt_new_extradata (void)\n{\n    PayloadContext *rdt = av_mallocz(sizeof(PayloadContext));\n\n    av_open_input_stream(&rdt->rmctx, NULL, \"\", &rdt_demuxer, NULL);\n\n    return rdt;\n}", "target": 1}
{"idx": 5389, "func": "static void latm_write_frame_header(AVFormatContext *s, PutBitContext *bs)\n{\n    LATMContext *ctx = s->priv_data;\n    AVCodecContext *avctx = s->streams[0]->codec;\n    GetBitContext gb;\n    int header_size;\n\n    /* AudioMuxElement */\n    put_bits(bs, 1, !!ctx->counter);\n\n    if (!ctx->counter) {\n        init_get_bits(&gb, avctx->extradata, avctx->extradata_size * 8);\n\n        /* StreamMuxConfig */\n        put_bits(bs, 1, 0); /* audioMuxVersion */\n        put_bits(bs, 1, 1); /* allStreamsSameTimeFraming */\n        put_bits(bs, 6, 0); /* numSubFrames */\n        put_bits(bs, 4, 0); /* numProgram */\n        put_bits(bs, 3, 0); /* numLayer */\n\n        /* AudioSpecificConfig */\n        if (ctx->object_type == AOT_ALS) {\n            header_size = avctx->extradata_size-(ctx->off >> 3);\n            avpriv_copy_bits(bs, &avctx->extradata[ctx->off >> 3], header_size);\n        } else {\n            avpriv_copy_bits(bs, avctx->extradata, ctx->off + 3);\n\n            if (!ctx->channel_conf) {\n                avpriv_copy_pce_data(bs, &gb);\n            }\n        }\n\n        put_bits(bs, 3, 0); /* frameLengthType */\n        put_bits(bs, 8, 0xff); /* latmBufferFullness */\n\n        put_bits(bs, 1, 0); /* otherDataPresent */\n        put_bits(bs, 1, 0); /* crcCheckPresent */\n    }\n\n    ctx->counter++;\n    ctx->counter %= ctx->mod;\n}", "target": 0}
{"idx": 5390, "func": "static void blake2s_init_param(BLAKE2S_CTX *S, const BLAKE2S_PARAM *P)\n{\n    const uint8_t *p = (const uint8_t *)(P);\n    size_t i;\n\n    /* The param struct is carefully hand packed, and should be 32 bytes on\n     * every platform. */\n    OPENSSL_assert(sizeof(BLAKE2S_PARAM) == 32);\n    blake2s_init0(S);\n    /* IV XOR ParamBlock */\n    for (i = 0; i < 8; ++i) {\n        S->h[i] ^= load32(&p[i*4]);\n    }\n}", "target": 0}
{"idx": 5391, "func": "static void frame_end(MpegEncContext *s)\n{\n    if (s->unrestricted_mv &&\n        s->current_picture.reference &&\n        !s->intra_only) {\n        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->avctx->pix_fmt);\n        int hshift = desc->log2_chroma_w;\n        int vshift = desc->log2_chroma_h;\n        s->mpvencdsp.draw_edges(s->current_picture.f->data[0],\n                                s->current_picture.f->linesize[0],\n                                s->h_edge_pos, s->v_edge_pos,\n                                EDGE_WIDTH, EDGE_WIDTH,\n                                EDGE_TOP | EDGE_BOTTOM);\n        s->mpvencdsp.draw_edges(s->current_picture.f->data[1],\n                                s->current_picture.f->linesize[1],\n                                s->h_edge_pos >> hshift,\n                                s->v_edge_pos >> vshift,\n                                EDGE_WIDTH >> hshift,\n                                EDGE_WIDTH >> vshift,\n                                EDGE_TOP | EDGE_BOTTOM);\n        s->mpvencdsp.draw_edges(s->current_picture.f->data[2],\n                                s->current_picture.f->linesize[2],\n                                s->h_edge_pos >> hshift,\n                                s->v_edge_pos >> vshift,\n                                EDGE_WIDTH >> hshift,\n                                EDGE_WIDTH >> vshift,\n                                EDGE_TOP | EDGE_BOTTOM);\n    }\n\n    emms_c();\n\n    s->last_pict_type                 = s->pict_type;\n    s->last_lambda_for [s->pict_type] = s->current_picture_ptr->f->quality;\n    if (s->pict_type!= AV_PICTURE_TYPE_B)\n        s->last_non_b_pict_type = s->pict_type;\n\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n    av_frame_unref(s->avctx->coded_frame);\n    av_frame_copy_props(s->avctx->coded_frame, s->current_picture.f);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n#if FF_API_ERROR_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n    memcpy(s->current_picture.f->error, s->current_picture.encoding_error,\n           sizeof(s->current_picture.encoding_error));\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n}", "target": 0}
{"idx": 5392, "func": "static inline int wnv1_get_code(WNV1Context *w, int base_value)\n{\n    int v = get_vlc2(&w->gb, code_vlc.table, CODE_VLC_BITS, 1);\n\n    if (v == 15)\n        return ff_reverse[get_bits(&w->gb, 8 - w->shift)];\n    else\n        return base_value + ((v - 7) << w->shift);\n}", "target": 1}
{"idx": 5393, "func": "static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,\n                           void (*f) (void))\n{\n    int idx;\n    char *s = (char *)p;\n    /* Take care of the easy one first (eg. it requires no searches) */\n    if (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {\n        if ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))\n            return 0;\n        return e->cmd_defns->cmd_num;\n    }\n    /* One or two commands require that \"p\" be a valid string buffer */\n    if ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\n        (cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\n        (cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {\n        if (s == NULL) {\n            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);\n            return -1;\n        }\n    }\n    /* Now handle cmd_name -> cmd_num conversion */\n    if (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {\n        if ((e->cmd_defns == NULL)\n            || ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {\n            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);\n            return -1;\n        }\n        return e->cmd_defns[idx].cmd_num;\n    }\n    /*\n     * For the rest of the commands, the 'long' argument must specify a valid\n     * command number - so we need to conduct a search.\n     */\n    if ((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,\n                                                              (unsigned int)\n                                                              i)) < 0)) {\n        ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);\n        return -1;\n    }\n    /* Now the logic splits depending on command type */\n    switch (cmd) {\n    case ENGINE_CTRL_GET_NEXT_CMD_TYPE:\n        idx++;\n        if (int_ctrl_cmd_is_null(e->cmd_defns + idx))\n            /* end-of-list */\n            return 0;\n        else\n            return e->cmd_defns[idx].cmd_num;\n    case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\n        return strlen(e->cmd_defns[idx].cmd_name);\n    case ENGINE_CTRL_GET_NAME_FROM_CMD:\n        return BIO_snprintf(s, strlen(e->cmd_defns[idx].cmd_name) + 1,\n                            \"%s\", e->cmd_defns[idx].cmd_name);\n    case ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:\n        if (e->cmd_defns[idx].cmd_desc)\n            return strlen(e->cmd_defns[idx].cmd_desc);\n        return strlen(int_no_description);\n    case ENGINE_CTRL_GET_DESC_FROM_CMD:\n        if (e->cmd_defns[idx].cmd_desc)\n            return BIO_snprintf(s,\n                                strlen(e->cmd_defns[idx].cmd_desc) + 1,\n                                \"%s\", e->cmd_defns[idx].cmd_desc);\n        return BIO_snprintf(s, strlen(int_no_description) + 1, \"%s\",\n                            int_no_description);\n    case ENGINE_CTRL_GET_CMD_FLAGS:\n        return e->cmd_defns[idx].cmd_flags;\n    }\n    /* Shouldn't really be here ... */\n    ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INTERNAL_LIST_ERROR);\n    return -1;\n}", "target": 1}
{"idx": 5394, "func": "int dv_produce_packet(DVDemuxContext *c, AVPacket *pkt,\n                      uint8_t* buf, int buf_size)\n{\n    int size, i;\n    uint8_t *ppcm[4] = {0};\n\n    if (buf_size < DV_PROFILE_BYTES ||\n        !(c->sys = dv_frame_profile(buf)) ||\n        buf_size < c->sys->frame_size) {\n          return -1;   /* Broken frame, or not enough data */\n    }\n\n    /* Queueing audio packet */\n    /* FIXME: in case of no audio/bad audio we have to do something */\n    size = dv_extract_audio_info(c, buf);\n    for (i = 0; i < c->ach; i++) {\n       c->audio_pkt[i].size = size;\n       c->audio_pkt[i].pts  = c->abytes * 30000*8 / c->ast[i]->codec->bit_rate;\n       ppcm[i] = c->audio_buf[i];\n    }\n    dv_extract_audio(buf, ppcm, c->sys);\n    c->abytes += size;\n\n    /* We work with 720p frames split in half, thus even frames have\n     * channels 0,1 and odd 2,3. */\n    if (c->sys->height == 720) {\n        if (buf[1] & 0x0C)\n            c->audio_pkt[2].size = c->audio_pkt[3].size = 0;\n        else\n            c->audio_pkt[0].size = c->audio_pkt[1].size = 0;\n    }\n\n    /* Now it's time to return video packet */\n    size = dv_extract_video_info(c, buf);\n    av_init_packet(pkt);\n    pkt->data         = buf;\n    pkt->size         = size;\n    pkt->flags       |= PKT_FLAG_KEY;\n    pkt->stream_index = c->vst->id;\n    pkt->pts          = c->frames;\n\n    c->frames++;\n\n    return size;\n}", "target": 1}
{"idx": 5395, "func": "static int ubsec_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n\t\tconst BIGNUM *m, BN_CTX *ctx)\n\t{\n\tint \ty_len = 0;\n\tint \tfd;\n\n\tif(ubsec_dso == NULL)\n\t{\n\t\tUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_NOT_LOADED);\n\t\treturn 0;\n\t}\n\n\t/* Check if hardware can't handle this argument. */\n\ty_len = BN_num_bits(m);\n\tif (y_len > max_key_len) {\n\t\tUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\n                return BN_mod_exp(r, a, p, m, ctx);\n\t} \n\n\tif(!bn_wexpand(r, m->top))\n\t{\n\t\tUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_BN_EXPAND_FAIL);\n\t\treturn 0;\n\t}\n\tmemset(r->d, 0, BN_num_bytes(m));\n\n\tif ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0) {\n\t\tfd = 0;\n\t\tUBSECerr(UBSEC_F_UBSEC_INIT, UBSEC_R_UNIT_FAILURE);\n                return BN_mod_exp(r, a, p, m, ctx);\n\t}\n\n\tif (p_UBSEC_rsa_mod_exp_ioctl(fd, (unsigned char *)a->d, BN_num_bits(a),\n\t\t(unsigned char *)m->d, BN_num_bits(m), (unsigned char *)p->d, \n\t\tBN_num_bits(p), (unsigned char *)r->d, &y_len) != 0)\n\t{\n\t\tUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_REQUEST_FAILED);\n                p_UBSEC_ubsec_close(fd);\n\n                return BN_mod_exp(r, a, p, m, ctx);\n\t}\n\n\tp_UBSEC_ubsec_close(fd);\n\n\tr->top = (BN_num_bits(m)+BN_BITS2-1)/BN_BITS2;\n\treturn 1;\n\t}", "target": 1}
{"idx": 5396, "func": "static int hls_append_segment(struct AVFormatContext *s, HLSContext *hls, double duration,\n                              int64_t pos, int64_t size)\n{\n    HLSSegment *en = av_malloc(sizeof(*en));\n    const char  *filename;\n    int ret;\n\n    if (!en)\n        return AVERROR(ENOMEM);\n\n    if ((hls->flags & (HLS_SECOND_LEVEL_SEGMENT_SIZE | HLS_SECOND_LEVEL_SEGMENT_DURATION)) &&\n        strlen(hls->current_segment_final_filename_fmt)) {\n        char * old_filename = av_strdup(hls->avf->filename);  // %%s will be %s after strftime\n        if (!old_filename) {\n            av_free(en);\n            return AVERROR(ENOMEM);\n        }\n        av_strlcpy(hls->avf->filename, hls->current_segment_final_filename_fmt, sizeof(hls->avf->filename));\n        if (hls->flags & HLS_SECOND_LEVEL_SEGMENT_SIZE) {\n            char * filename = av_strdup(hls->avf->filename);  // %%s will be %s after strftime\n            if (!filename) {\n                av_free(old_filename);\n                av_free(en);\n                return AVERROR(ENOMEM);\n            }\n            if (replace_int_data_in_filename(hls->avf->filename, sizeof(hls->avf->filename),\n                filename, 's', pos + size) < 1) {\n                av_log(hls, AV_LOG_ERROR,\n                       \"Invalid second level segment filename template '%s', \"\n                        \"you can try to remove second_level_segment_size flag\\n\",\n                       filename);\n                av_free(filename);\n                av_free(old_filename);\n                av_free(en);\n                return AVERROR(EINVAL);\n            }\n            av_free(filename);\n        }\n        if (hls->flags & HLS_SECOND_LEVEL_SEGMENT_DURATION) {\n            char * filename = av_strdup(hls->avf->filename);  // %%t will be %t after strftime\n            if (!filename) {\n                av_free(old_filename);\n                av_free(en);\n                return AVERROR(ENOMEM);\n            }\n            if (replace_int_data_in_filename(hls->avf->filename, sizeof(hls->avf->filename),\n                filename, 't',  (int64_t)round(1000000 * duration)) < 1) {\n                av_log(hls, AV_LOG_ERROR,\n                       \"Invalid second level segment filename template '%s', \"\n                        \"you can try to remove second_level_segment_time flag\\n\",\n                       filename);\n                av_free(filename);\n                av_free(old_filename);\n                av_free(en);\n                return AVERROR(EINVAL);\n            }\n            av_free(filename);\n        }\n        ff_rename(old_filename, hls->avf->filename, hls);\n        av_free(old_filename);\n    }\n\n\n    filename = av_basename(hls->avf->filename);\n\n    if (hls->use_localtime_mkdir) {\n        filename = hls->avf->filename;\n    }\n    if (find_segment_by_filename(hls->segments, filename)\n        || find_segment_by_filename(hls->old_segments, filename)) {\n        av_log(hls, AV_LOG_WARNING, \"Duplicated segment filename detected: %s\\n\", filename);\n    }\n    av_strlcpy(en->filename, filename, sizeof(en->filename));\n\n    if(hls->has_subtitle)\n        av_strlcpy(en->sub_filename, av_basename(hls->vtt_avf->filename), sizeof(en->sub_filename));\n    else\n        en->sub_filename[0] = '\\0';\n\n    en->duration = duration;\n    en->pos      = pos;\n    en->size     = size;\n    en->next     = NULL;\n    en->discont  = 0;\n\n    if (hls->discontinuity) {\n        en->discont = 1;\n        hls->discontinuity = 0;\n    }\n\n    if (hls->key_info_file) {\n        av_strlcpy(en->key_uri, hls->key_uri, sizeof(en->key_uri));\n        av_strlcpy(en->iv_string, hls->iv_string, sizeof(en->iv_string));\n    }\n\n    if (!hls->segments)\n        hls->segments = en;\n    else\n        hls->last_segment->next = en;\n\n    hls->last_segment = en;\n\n    // EVENT or VOD playlists imply sliding window cannot be used\n    if (hls->pl_type != PLAYLIST_TYPE_NONE)\n        hls->max_nb_segments = 0;\n\n    if (hls->max_nb_segments && hls->nb_entries >= hls->max_nb_segments) {\n        en = hls->segments;\n        hls->initial_prog_date_time += en->duration;\n        hls->segments = en->next;\n        if (en && hls->flags & HLS_DELETE_SEGMENTS &&\n                !(hls->flags & HLS_SINGLE_FILE || hls->wrap)) {\n            en->next = hls->old_segments;\n            hls->old_segments = en;\n            if ((ret = hls_delete_old_segments(hls)) < 0)\n                return ret;\n        } else\n            av_free(en);\n    } else\n        hls->nb_entries++;\n\n    if (hls->max_seg_size > 0) {\n        return 0;\n    }\n    hls->sequence++;\n\n    return 0;\n}", "target": 0}
{"idx": 5397, "func": "unsigned char *asc2uni(const char *asc, int asclen, unsigned char **uni, int *unilen)\n{\n\tint ulen, i;\n\tunsigned char *unitmp;\n\tif (asclen == -1) asclen = strlen(asc);\n\tulen = asclen*2  + 2;\n\tif (!(unitmp = OPENSSL_malloc(ulen))) return NULL;\n\tfor (i = 0; i < ulen - 2; i+=2) {\n\t\tunitmp[i] = 0;\n\t\tunitmp[i + 1] = asc[i>>1];\n\t}\n\t/* Make result double null terminated */\n\tunitmp[ulen - 2] = 0;\n\tunitmp[ulen - 1] = 0;\n\tif (unilen) *unilen = ulen;\n\tif (uni) *uni = unitmp;\n\treturn unitmp;\n}", "target": 1}
{"idx": 5398, "func": "SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,\n                             long length)\n{\n    long id;\n    size_t tmpl;\n    const unsigned char *p = *pp;\n    SSL_SESSION_ASN1 *as = NULL;\n    SSL_SESSION *ret = NULL;\n\n    as = d2i_SSL_SESSION_ASN1(NULL, &p, length);\n    /* ASN.1 code returns suitable error */\n    if (as == NULL)\n        goto err;\n\n    if (!a || !*a) {\n        ret = SSL_SESSION_new();\n        if (ret == NULL)\n            goto err;\n    } else {\n        ret = *a;\n    }\n\n    if (as->version != SSL_SESSION_ASN1_VERSION) {\n        SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_UNKNOWN_SSL_VERSION);\n        goto err;\n    }\n\n    if ((as->ssl_version >> 8) != SSL3_VERSION_MAJOR\n        && (as->ssl_version >> 8) != DTLS1_VERSION_MAJOR\n        && as->ssl_version != DTLS1_BAD_VER) {\n        SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_UNSUPPORTED_SSL_VERSION);\n        goto err;\n    }\n\n    ret->ssl_version = (int)as->ssl_version;\n\n    if (as->cipher->length != 2) {\n        SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_CIPHER_CODE_WRONG_LENGTH);\n        goto err;\n    }\n\n    p = as->cipher->data;\n    id = 0x03000000L | ((unsigned long)p[0] << 8L) | (unsigned long)p[1];\n\n    ret->cipher_id = id;\n    ret->cipher = ssl3_get_cipher_by_id(id);\n    if (ret->cipher == NULL)\n        goto err;\n\n    if (!ssl_session_memcpy(ret->session_id, &ret->session_id_length,\n                            as->session_id, SSL3_MAX_SSL_SESSION_ID_LENGTH))\n        goto err;\n\n    if (!ssl_session_memcpy(ret->master_key, &tmpl,\n                            as->master_key, SSL_MAX_MASTER_KEY_LENGTH))\n        goto err;\n\n    ret->master_key_length = tmpl;\n\n    if (as->time != 0)\n        ret->time = as->time;\n    else\n        ret->time = (unsigned long)time(NULL);\n\n    if (as->timeout != 0)\n        ret->timeout = as->timeout;\n    else\n        ret->timeout = 3;\n\n    X509_free(ret->peer);\n    ret->peer = as->peer;\n    as->peer = NULL;\n\n    if (!ssl_session_memcpy(ret->sid_ctx, &ret->sid_ctx_length,\n                            as->session_id_context, SSL_MAX_SID_CTX_LENGTH))\n        goto err;\n\n    /* NB: this defaults to zero which is X509_V_OK */\n    ret->verify_result = as->verify_result;\n\n    if (!ssl_session_strndup(&ret->ext.hostname, as->tlsext_hostname))\n        goto err;\n\n#ifndef OPENSSL_NO_PSK\n    if (!ssl_session_strndup(&ret->psk_identity_hint, as->psk_identity_hint))\n        goto err;\n    if (!ssl_session_strndup(&ret->psk_identity, as->psk_identity))\n        goto err;\n#endif\n\n    ret->ext.tick_lifetime_hint = as->tlsext_tick_lifetime_hint;\n    ret->ext.tick_age_add = as->tlsext_tick_age_add;\n    if (as->tlsext_tick) {\n        ret->ext.tick = as->tlsext_tick->data;\n        ret->ext.ticklen = as->tlsext_tick->length;\n        as->tlsext_tick->data = NULL;\n    } else {\n        ret->ext.tick = NULL;\n    }\n#ifndef OPENSSL_NO_COMP\n    if (as->comp_id) {\n        if (as->comp_id->length != 1) {\n            SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_BAD_LENGTH);\n            goto err;\n        }\n        ret->compress_meth = as->comp_id->data[0];\n    } else {\n        ret->compress_meth = 0;\n    }\n#endif\n\n#ifndef OPENSSL_NO_SRP\n    if (!ssl_session_strndup(&ret->srp_username, as->srp_username))\n        goto err;\n#endif                          /* OPENSSL_NO_SRP */\n    /* Flags defaults to zero which is fine */\n    ret->flags = as->flags;\n\n    M_ASN1_free_of(as, SSL_SESSION_ASN1);\n\n    if ((a != NULL) && (*a == NULL))\n        *a = ret;\n    *pp = p;\n    return ret;\n\n err:\n    M_ASN1_free_of(as, SSL_SESSION_ASN1);\n    if ((a == NULL) || (*a != ret))\n        SSL_SESSION_free(ret);\n    return NULL;\n}", "target": 0}
{"idx": 5399, "func": "int ff_update_duplicate_context(MpegEncContext *dst, MpegEncContext *src)\n{\n    MpegEncContext bak;\n    int i, ret;\n    // FIXME copy only needed parts\n    // START_TIMER\n    backup_duplicate_context(&bak, dst);\n    memcpy(dst, src, sizeof(MpegEncContext));\n    backup_duplicate_context(dst, &bak);\n    for (i = 0; i < 12; i++) {\n        dst->pblocks[i] = &dst->block[i];\n    }\n    if (dst->avctx->codec_tag == AV_RL32(\"VCR2\")) {\n        // exchange uv\n        FFSWAP(void *, dst->pblocks[4], dst->pblocks[5]);\n    }\n    if (!dst->sc.edge_emu_buffer &&\n        (ret = ff_mpeg_framesize_alloc(dst->avctx, &dst->me,\n                                       &dst->sc, dst->linesize)) < 0) {\n        av_log(dst->avctx, AV_LOG_ERROR, \"failed to allocate context \"\n               \"scratch buffers.\\n\");\n        return ret;\n    }\n    // STOP_TIMER(\"update_duplicate_context\")\n    // about 10k cycles / 0.01 sec for  1000frames on 1ghz with 2 threads\n    return 0;\n}", "target": 1}
{"idx": 5400, "func": "int ff_init_vlc_sparse(VLC *vlc, int nb_bits, int nb_codes,\n             const void *bits, int bits_wrap, int bits_size,\n             const void *codes, int codes_wrap, int codes_size,\n             const void *symbols, int symbols_wrap, int symbols_size,\n             int flags)\n{\n    VLCcode *buf;\n    int i, j, ret;\n\n    vlc->bits = nb_bits;\n    if(flags & INIT_VLC_USE_NEW_STATIC){\n        VLC dyn_vlc = *vlc;\n\n        if (vlc->table_size)\n            return 0;\n\n        ret = ff_init_vlc_sparse(&dyn_vlc, nb_bits, nb_codes,\n                                 bits, bits_wrap, bits_size,\n                                 codes, codes_wrap, codes_size,\n                                 symbols, symbols_wrap, symbols_size,\n                                 flags & ~INIT_VLC_USE_NEW_STATIC);\n        av_assert0(ret >= 0);\n        av_assert0(dyn_vlc.table_size <= vlc->table_allocated);\n        if(dyn_vlc.table_size < vlc->table_allocated)\n            av_log(NULL, AV_LOG_ERROR, \"needed %d had %d\\n\", dyn_vlc.table_size, vlc->table_allocated);\n        memcpy(vlc->table, dyn_vlc.table, dyn_vlc.table_size * sizeof(*vlc->table));\n        vlc->table_size = dyn_vlc.table_size;\n        ff_free_vlc(&dyn_vlc);\n        return 0;\n    }else {\n        vlc->table = NULL;\n        vlc->table_allocated = 0;\n        vlc->table_size = 0;\n    }\n\n    av_dlog(NULL, \"build table nb_codes=%d\\n\", nb_codes);\n\n    buf = av_malloc((nb_codes+1)*sizeof(VLCcode));\n\n    av_assert0(symbols_size <= 2 || !symbols);\n    j = 0;\n#define COPY(condition)\\\n    for (i = 0; i < nb_codes; i++) {\\\n        GET_DATA(buf[j].bits, bits, i, bits_wrap, bits_size);\\\n        if (!(condition))\\\n            continue;\\\n        GET_DATA(buf[j].code, codes, i, codes_wrap, codes_size);\\\n        if (flags & INIT_VLC_LE)\\\n            buf[j].code = bitswap_32(buf[j].code);\\\n        else\\\n            buf[j].code <<= 32 - buf[j].bits;\\\n        if (symbols)\\\n            GET_DATA(buf[j].symbol, symbols, i, symbols_wrap, symbols_size)\\\n        else\\\n            buf[j].symbol = i;\\\n        j++;\\\n    }\n    COPY(buf[j].bits > nb_bits);\n    // qsort is the slowest part of init_vlc, and could probably be improved or avoided\n    qsort(buf, j, sizeof(VLCcode), compare_vlcspec);\n    COPY(buf[j].bits && buf[j].bits <= nb_bits);\n    nb_codes = j;\n\n    ret = build_table(vlc, nb_bits, nb_codes, buf, flags);\n\n    av_free(buf);\n    if (ret < 0) {\n        av_freep(&vlc->table);\n        return -1;\n    }\n    return 0;\n}", "target": 1}
{"idx": 5401, "func": "void wait_for_async(SSL *s)\n{\n    int width, fd;\n    fd_set asyncfds;\n\n    fd = SSL_get_async_wait_fd(s);\n    if (fd < 0)\n        return;\n\n    width = fd + 1;\n    FD_ZERO(&asyncfds);\n    openssl_fdset(fd, &asyncfds);\n    select(width, (void *)&asyncfds, NULL, NULL, NULL);\n}", "target": 0}
{"idx": 5402, "func": "STACK_OF(CONF_VALUE) *X509V3_parse_list(const char *line)\n{\n    char *p, *q, c;\n    char *ntmp, *vtmp;\n    STACK_OF(CONF_VALUE) *values = NULL;\n    char *linebuf;\n    int state;\n    /* We are going to modify the line so copy it first */\n    linebuf = OPENSSL_strdup(line);\n    if (linebuf == NULL) {\n        X509V3err(X509V3_F_X509V3_PARSE_LIST, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    state = HDR_NAME;\n    ntmp = NULL;\n    /* Go through all characters */\n    for (p = linebuf, q = linebuf; (c = *p) && (c != '\\r') && (c != '\\n');\n         p++) {\n\n        switch (state) {\n        case HDR_NAME:\n            if (c == ':') {\n                state = HDR_VALUE;\n                *p = 0;\n                ntmp = strip_spaces(q);\n                if (!ntmp) {\n                    X509V3err(X509V3_F_X509V3_PARSE_LIST,\n                              X509V3_R_INVALID_NULL_NAME);\n                    goto err;\n                }\n                q = p + 1;\n            } else if (c == ',') {\n                *p = 0;\n                ntmp = strip_spaces(q);\n                q = p + 1;\n                if (!ntmp) {\n                    X509V3err(X509V3_F_X509V3_PARSE_LIST,\n                              X509V3_R_INVALID_NULL_NAME);\n                    goto err;\n                }\n                X509V3_add_value(ntmp, NULL, &values);\n            }\n            break;\n\n        case HDR_VALUE:\n            if (c == ',') {\n                state = HDR_NAME;\n                *p = 0;\n                vtmp = strip_spaces(q);\n                if (!vtmp) {\n                    X509V3err(X509V3_F_X509V3_PARSE_LIST,\n                              X509V3_R_INVALID_NULL_VALUE);\n                    goto err;\n                }\n                X509V3_add_value(ntmp, vtmp, &values);\n                ntmp = NULL;\n                q = p + 1;\n            }\n\n        }\n    }\n\n    if (state == HDR_VALUE) {\n        vtmp = strip_spaces(q);\n        if (!vtmp) {\n            X509V3err(X509V3_F_X509V3_PARSE_LIST,\n                      X509V3_R_INVALID_NULL_VALUE);\n            goto err;\n        }\n        X509V3_add_value(ntmp, vtmp, &values);\n    } else {\n        ntmp = strip_spaces(q);\n        if (!ntmp) {\n            X509V3err(X509V3_F_X509V3_PARSE_LIST, X509V3_R_INVALID_NULL_NAME);\n            goto err;\n        }\n        X509V3_add_value(ntmp, NULL, &values);\n    }\n    OPENSSL_free(linebuf);\n    return values;\n\n err:\n    OPENSSL_free(linebuf);\n    sk_CONF_VALUE_pop_free(values, X509V3_conf_free);\n    return NULL;\n\n}", "target": 0}
{"idx": 5403, "func": "int ASYNC_init_thread(size_t max_size, size_t init_size)\n{\n    async_pool *pool;\n    size_t curr_size = 0;\n\n    if (init_size > max_size) {\n        ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ASYNC_R_INVALID_POOL_SIZE);\n        return 0;\n    }\n\n    if (!async_local_init()) {\n        ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ASYNC_R_INIT_FAILED);\n        return 0;\n    }\n    pool = OPENSSL_zalloc(sizeof *pool);\n    if (pool == NULL) {\n        ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    pool->jobs = sk_ASYNC_JOB_new_null();\n    if (pool->jobs == NULL) {\n        ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ERR_R_MALLOC_FAILURE);\n        OPENSSL_free(pool);\n        return 0;\n    }\n\n    pool->max_size = max_size;\n\n    /* Pre-create jobs as required */\n    while (init_size) {\n        ASYNC_JOB *job;\n        job = async_job_new();\n        if (job) {\n            async_fibre_makecontext(&job->fibrectx);\n            job->funcargs = NULL;\n            sk_ASYNC_JOB_push(pool->jobs, job);\n            curr_size++;\n            init_size--;\n        } else {\n            /*\n             * Not actually fatal because we already created the pool, just skip\n             * creation of any more jobs\n             */\n            init_size = 0;\n        }\n    }\n    pool->curr_size = curr_size;\n    if (!async_set_pool(pool)) {\n        ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ASYNC_R_FAILED_TO_SET_POOL);\n        goto err;\n    }\n\n    return 1;\nerr:\n    async_free_pool_internal(pool);\n    return 0;\n}", "target": 0}
{"idx": 5404, "func": "static int\nNeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"NeXTDecode\";\n\tunsigned char *bp, *op;\n\ttmsize_t cc;\n\tuint8* row;\n\ttmsize_t scanline, n;\n\n\t(void) s;\n\t/*\n\t * Each scanline is assumed to start off as all\n\t * white (we assume a PhotometricInterpretation\n\t * of ``min-is-black'').\n\t */\n\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\n\t\t*op++ = 0xff;\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tscanline = tif->tif_scanlinesize;\n\tif (occ % scanline)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (0);\n\t}\n\tfor (row = buf; occ > 0; occ -= scanline, row += scanline) {\n\t\tn = *bp++, cc--;\n\t\tswitch (n) {\n\t\tcase LITERALROW:\n\t\t\t/*\n\t\t\t * The entire scanline is given as literal values.\n\t\t\t */\n\t\t\tif (cc < scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row, bp, scanline);\n\t\t\tbp += scanline;\n\t\t\tcc -= scanline;\n\t\t\tbreak;\n\t\tcase LITERALSPAN: {\n\t\t\ttmsize_t off;\n\t\t\t/*\n\t\t\t * The scanline has a literal span that begins at some\n\t\t\t * offset.\n\t\t\t */\n\t\t\toff = (bp[0] * 256) + bp[1];\n\t\t\tn = (bp[2] * 256) + bp[3];\n\t\t\tif (cc < 4+n || off+n > scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row+off, bp+4, n);\n\t\t\tbp += 4+n;\n\t\t\tcc -= 4+n;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tuint32 npixels = 0, grey;\n\t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;\n            if( isTiled(tif) )\n                imagewidth = tif->tif_dir.td_tilewidth;\n\n\t\t\t/*\n\t\t\t * The scanline is composed of a sequence of constant\n\t\t\t * color ``runs''.  We shift into ``run mode'' and\n\t\t\t * interpret bytes as codes of the form\n\t\t\t * <color><npixels> until we've filled the scanline.\n\t\t\t */\n\t\t\top = row;\n\t\t\tfor (;;) {\n\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\n\t\t\t\tn &= 0x3f;\n\t\t\t\t/*\n\t\t\t\t * Ensure the run does not exceed the scanline\n\t\t\t\t * bounds, potentially resulting in a security\n\t\t\t\t * issue.\n\t\t\t\t */\n\t\t\t\twhile (n-- > 0 && npixels < imagewidth)\n\t\t\t\t\tSETPIXEL(op, grey);\n\t\t\t\tif (npixels >= imagewidth)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cc == 0)\n\t\t\t\t\tgoto bad;\n\t\t\t\tn = *bp++, cc--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\n\t    (long) tif->tif_row);\n\treturn (0);\n}", "target": 1}
{"idx": 5405, "func": "int avpriv_adx_decode_header(AVCodecContext *avctx, const uint8_t *buf,\n                             int bufsize, int *header_size, int *coeff)\n{\n    int offset, cutoff;\n\n    if (bufsize < 24)\n        return AVERROR_INVALIDDATA;\n\n    if (AV_RB16(buf) != 0x8000)\n        return AVERROR_INVALIDDATA;\n    offset = AV_RB16(buf + 2) + 4;\n\n    /* if copyright string is within the provided data, validate it */\n    if (bufsize >= offset && memcmp(buf + offset - 6, \"(c)CRI\", 6))\n        return AVERROR_INVALIDDATA;\n\n    /* check for encoding=3 block_size=18, sample_size=4 */\n    if (buf[4] != 3 || buf[5] != 18 || buf[6] != 4) {\n        av_log_ask_for_sample(avctx, \"unsupported ADX format\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* channels */\n    avctx->channels = buf[7];\n    if (avctx->channels > 2)\n        return AVERROR_INVALIDDATA;\n\n    /* sample rate */\n    avctx->sample_rate = AV_RB32(buf + 8);\n    if (avctx->sample_rate < 1 ||\n        avctx->sample_rate > INT_MAX / (avctx->channels * BLOCK_SIZE * 8))\n        return AVERROR_INVALIDDATA;\n\n    /* bit rate */\n    avctx->bit_rate = avctx->sample_rate * avctx->channels * BLOCK_SIZE * 8 / BLOCK_SAMPLES;\n\n    /* LPC coefficients */\n    if (coeff) {\n        cutoff = AV_RB16(buf + 16);\n        ff_adx_calculate_coeffs(cutoff, avctx->sample_rate, COEFF_BITS, coeff);\n    }\n\n    *header_size = offset;\n    return 0;\n}", "target": 1}
{"idx": 5406, "func": "static int rtp_send_samples(AVFormatContext *s1,\n                            const uint8_t *buf1, int size, int sample_size_bits)\n{\n    RTPMuxContext *s = s1->priv_data;\n    int len, max_packet_size, n;\n    /* Calculate the number of bytes to get samples aligned on a byte border */\n    int aligned_samples_size = sample_size_bits/av_gcd(sample_size_bits, 8);\n\n    max_packet_size = (s->max_payload_size / aligned_samples_size) * aligned_samples_size;\n    /* Not needed, but who knows. Don't check if samples aren't an even number of bytes. */\n    if ((sample_size_bits % 8) == 0 && ((8 * size) % sample_size_bits) != 0)\n        return AVERROR(EINVAL);\n    n = 0;\n    while (size > 0) {\n        s->buf_ptr = s->buf;\n        len = FFMIN(max_packet_size, size);\n\n        /* copy data */\n        memcpy(s->buf_ptr, buf1, len);\n        s->buf_ptr += len;\n        buf1 += len;\n        size -= len;\n        s->timestamp = s->cur_timestamp + n * 8 / sample_size_bits;\n        ff_rtp_send_data(s1, s->buf, s->buf_ptr - s->buf, 0);\n        n += (s->buf_ptr - s->buf);\n    }\n    return 0;\n}", "target": 1}
{"idx": 5407, "func": "int extract_host_port(char *str, char **host_ptr, unsigned char *ip,\n                      unsigned short *port_ptr)\n{\n    char *h, *p;\n\n    h = str;\n    p = strchr(str, ':');\n    if (p == NULL) {\n        BIO_printf(bio_err, \"no port defined\\n\");\n        return (0);\n    }\n    *(p++) = '\\0';\n\n    if ((ip != NULL) && !host_ip(str, ip))\n        goto err;\n    if (host_ptr != NULL)\n        *host_ptr = h;\n\n    if (!extract_port(p, port_ptr))\n        goto err;\n    return (1);\n err:\n    return (0);\n}", "target": 1}
{"idx": 5408, "func": "int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)\n{\n    int i, j, t, rconpointer = 0;\n    uint8_t tk[8][4];\n    int KC = key_bits >> 5;\n    int rounds = KC + 6;\n    uint8_t log8[256];\n    uint8_t alog8[512];\n\n    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {\n        j = 1;\n        for (i = 0; i < 255; i++) {\n            alog8[i] = alog8[i + 255] = j;\n            log8[j] = i;\n            j ^= j + j;\n            if (j > 255)\n                j ^= 0x11B;\n        }\n        for (i = 0; i < 256; i++) {\n            j = i ? alog8[255 - log8[i]] : 0;\n            j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4);\n            j = (j ^ (j >> 8) ^ 99) & 255;\n            inv_sbox[j] = i;\n            sbox[i] = j;\n        }\n        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },\n                     log8, alog8, inv_sbox);\n        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },\n                     log8, alog8, sbox);\n    }\n\n    if (key_bits != 128 && key_bits != 192 && key_bits != 256)\n        return -1;\n\n    a->rounds = rounds;\n\n    memcpy(tk, key, KC * 4);\n\n    for (t = 0; t < (rounds + 1) * 16;) {\n        memcpy(a->round_key[0].u8 + t, tk, KC * 4);\n        t += KC * 4;\n\n        for (i = 0; i < 4; i++)\n            tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]];\n        tk[0][0] ^= rcon[rconpointer++];\n\n        for (j = 1; j < KC; j++) {\n            if (KC != 8 || j != KC >> 1)\n                for (i = 0; i < 4; i++)\n                    tk[j][i] ^= tk[j - 1][i];\n            else\n                for (i = 0; i < 4; i++)\n                    tk[j][i] ^= sbox[tk[j - 1][i]];\n        }\n    }\n\n    if (decrypt) {\n        for (i = 1; i < rounds; i++) {\n            av_aes_block tmp[3];\n            tmp[2] = a->round_key[i];\n            subshift(&tmp[1], 0, sbox);\n            mix(tmp, dec_multbl, 1, 3);\n            a->round_key[i] = tmp[0];\n        }\n    } else {\n        for (i = 0; i < (rounds + 1) >> 1; i++) {\n            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]);\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5409, "func": "static int graph_config_pointers(AVFilterGraph *graph,\n                                             AVClass *log_ctx)\n{\n    unsigned i, j;\n    int sink_links_count = 0, n = 0;\n    AVFilterContext *f;\n    AVFilterLink **sinks;\n\n    for (i = 0; i < graph->nb_filters; i++) {\n        f = graph->filters[i];\n        for (j = 0; j < f->nb_inputs; j++) {\n            f->inputs[j]->graph     = graph;\n            f->inputs[j]->age_index = -1;\n        }\n        for (j = 0; j < f->nb_outputs; j++) {\n            f->outputs[j]->graph    = graph;\n            f->outputs[j]->age_index= -1;\n        }\n        if (!f->nb_outputs) {\n            if (f->nb_inputs > INT_MAX - sink_links_count)\n                return AVERROR(EINVAL);\n            sink_links_count += f->nb_inputs;\n        }\n    }\n    sinks = av_calloc(sink_links_count, sizeof(*sinks));\n    if (!sinks)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < graph->nb_filters; i++) {\n        f = graph->filters[i];\n        if (!f->nb_outputs) {\n            for (j = 0; j < f->nb_inputs; j++) {\n                sinks[n] = f->inputs[j];\n                f->inputs[j]->age_index = n++;\n            }\n        }\n    }\n    av_assert0(n == sink_links_count);\n    graph->sink_links       = sinks;\n    graph->sink_links_count = sink_links_count;\n    return 0;\n}", "target": 1}
{"idx": 5410, "func": "void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    /* let's disallow possible ambiguous cases */\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    //FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    av_assert0(diff>0 && diff<=ALIGN);\n    ptr = realloc((char *)ptr - diff, size + diff);\n    if (ptr)\n        ptr = (char *)ptr + diff;\n    return ptr;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size + !size, ALIGN);\n#else\n    return realloc(ptr, size + !size);\n#endif\n}", "target": 0}
{"idx": 5411, "func": "static int opcode_0xf7(SANMVideoContext *ctx, int cx, int cy, int block_size, int pitch)\n{\n    uint16_t *dst = ctx->frm0 + cx + cy * ctx->pitch;\n\n    if (block_size == 2) {\n        uint32_t indices;\n\n        if (bytestream2_get_bytes_left(&ctx->gb) < 4)\n            return AVERROR_INVALIDDATA;\n\n        indices        = bytestream2_get_le32u(&ctx->gb);\n        dst[0]         = ctx->codebook[indices & 0xFF]; indices >>= 8;\n        dst[1]         = ctx->codebook[indices & 0xFF]; indices >>= 8;\n        dst[pitch]     = ctx->codebook[indices & 0xFF]; indices >>= 8;\n        dst[pitch + 1] = ctx->codebook[indices & 0xFF];\n    } else {\n        uint16_t fgcolor, bgcolor;\n        int glyph;\n\n        if (bytestream2_get_bytes_left(&ctx->gb) < 3)\n            return AVERROR_INVALIDDATA;\n\n        glyph   = bytestream2_get_byteu(&ctx->gb);\n        bgcolor = ctx->codebook[bytestream2_get_byteu(&ctx->gb)];\n        fgcolor = ctx->codebook[bytestream2_get_byteu(&ctx->gb)];\n\n        draw_glyph(ctx, dst, glyph, fgcolor, bgcolor, block_size, pitch);\n    }\n    return 0;\n}", "target": 1}
{"idx": 5412, "func": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n\t{\n\tchar *str;\n\tASN1_TIME atm;\n\tlong offset;\n\tchar buff1[24],buff2[24],*p;\n\tint i,j;\n\n\tp=buff1;\n\ti=ctm->length;\n\tstr=(char *)ctm->data;\n\tif (ctm->type == V_ASN1_UTCTIME)\n\t\t{\n\t\tif ((i < 11) || (i > 17)) return 0;\n\t\tmemcpy(p,str,10);\n\t\tp+=10;\n\t\tstr+=10;\n\t\t}\n\telse\n\t\t{\n\t\tif (i < 13) return 0;\n\t\tmemcpy(p,str,12);\n\t\tp+=12;\n\t\tstr+=12;\n\t\t}\n\n\tif ((*str == 'Z') || (*str == '-') || (*str == '+'))\n\t\t{ *(p++)='0'; *(p++)='0'; }\n\telse\n\t\t{ \n\t\t*(p++)= *(str++);\n\t\t*(p++)= *(str++);\n\t\t/* Skip any fractional seconds... */\n\t\tif (*str == '.')\n\t\t\t{\n\t\t\tstr++;\n\t\t\twhile ((*str >= '0') && (*str <= '9')) str++;\n\t\t\t}\n\t\t\n\t\t}\n\t*(p++)='Z';\n\t*(p++)='\\0';\n\n\tif (*str == 'Z')\n\t\toffset=0;\n\telse\n\t\t{\n\t\tif ((*str != '+') && (*str != '-'))\n\t\t\treturn 0;\n\t\toffset=((str[1]-'0')*10+(str[2]-'0'))*60;\n\t\toffset+=(str[3]-'0')*10+(str[4]-'0');\n\t\tif (*str == '-')\n\t\t\toffset= -offset;\n\t\t}\n\tatm.type=ctm->type;\n\tatm.length=sizeof(buff2);\n\tatm.data=(unsigned char *)buff2;\n\n\tif (X509_time_adj(&atm,-offset*60, cmp_time) == NULL)\n\t\treturn 0;\n\n\tif (ctm->type == V_ASN1_UTCTIME)\n\t\t{\n\t\ti=(buff1[0]-'0')*10+(buff1[1]-'0');\n\t\tif (i < 50) i+=100; /* cf. RFC 2459 */\n\t\tj=(buff2[0]-'0')*10+(buff2[1]-'0');\n\t\tif (j < 50) j+=100;\n\n\t\tif (i < j) return -1;\n\t\tif (i > j) return 1;\n\t\t}\n\ti=strcmp(buff1,buff2);\n\tif (i == 0) /* wait a second then return younger :-) */\n\t\treturn -1;\n\telse\n\t\treturn i;\n\t}", "target": 1}
{"idx": 5413, "func": "int tls13_generate_secret(SSL *s, const EVP_MD *md,\n                          const unsigned char *prevsecret,\n                          const unsigned char *insecret,\n                          size_t insecretlen,\n                          unsigned char *outsecret)\n{\n    size_t mdlen, prevsecretlen;\n    int ret;\n    EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, NULL);\n    static const char derived_secret_label[] = \"derived\";\n    unsigned char preextractsec[EVP_MAX_MD_SIZE];\n\n    if (pctx == NULL)\n        return 0;\n\n    mdlen = EVP_MD_size(md);\n\n    if (insecret == NULL) {\n        insecret = default_zeros;\n        insecretlen = mdlen;\n    }\n    if (prevsecret == NULL) {\n        prevsecret = default_zeros;\n        prevsecretlen = 0;\n    } else {\n        EVP_MD_CTX *mctx = EVP_MD_CTX_new();\n        unsigned char hash[EVP_MAX_MD_SIZE];\n\n        /* The pre-extract derive step uses a hash of no messages */\n        if (mctx == NULL\n                || EVP_DigestInit_ex(mctx, md, NULL) <= 0\n                || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {\n            EVP_MD_CTX_free(mctx);\n            EVP_PKEY_CTX_free(pctx);\n            return 0;\n        }\n        EVP_MD_CTX_free(mctx);\n\n        /* Generate the pre-extract secret */\n        if (!tls13_hkdf_expand(s, md, prevsecret,\n                               (unsigned char *)derived_secret_label,\n                               sizeof(derived_secret_label) - 1, hash, mdlen,\n                               preextractsec, mdlen)) {\n            EVP_PKEY_CTX_free(pctx);\n            return 0;\n        }\n\n        prevsecret = preextractsec;\n        prevsecretlen = mdlen;\n    }\n\n    ret = EVP_PKEY_derive_init(pctx) <= 0\n            || EVP_PKEY_CTX_hkdf_mode(pctx, EVP_PKEY_HKDEF_MODE_EXTRACT_ONLY)\n               <= 0\n            || EVP_PKEY_CTX_set_hkdf_md(pctx, md) <= 0\n            || EVP_PKEY_CTX_set1_hkdf_key(pctx, insecret, insecretlen) <= 0\n            || EVP_PKEY_CTX_set1_hkdf_salt(pctx, prevsecret, prevsecretlen)\n               <= 0\n            || EVP_PKEY_derive(pctx, outsecret, &mdlen)\n               <= 0;\n\n    EVP_PKEY_CTX_free(pctx);\n    if (prevsecret == preextractsec)\n        OPENSSL_cleanse(preextractsec, mdlen);\n    return ret == 0;\n}", "target": 0}
{"idx": 5414, "func": "static int hwupload_query_formats(AVFilterContext *avctx)\n{\n    HWUploadContext *ctx = avctx->priv;\n    AVHWFramesConstraints *constraints = NULL;\n    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;\n    AVFilterFormats *input_formats = NULL;\n    int err, i;\n\n    if (!avctx->hw_device_ctx) {\n        av_log(ctx, AV_LOG_ERROR, \"A hardware device reference is required \"\n               \"to upload frames to.\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);\n    if (!ctx->hwdevice_ref)\n        return AVERROR(ENOMEM);\n    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);\n    if (!constraints) {\n        err = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    input_pix_fmts  = constraints->valid_sw_formats;\n    output_pix_fmts = constraints->valid_hw_formats;\n\n    input_formats = ff_make_format_list(output_pix_fmts);\n    if (!input_formats) {\n        err = AVERROR(ENOMEM);\n        goto fail;\n    }\n    if (input_pix_fmts) {\n        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {\n            err = ff_add_format(&input_formats, input_pix_fmts[i]);\n            if (err < 0)\n                goto fail;\n        }\n    }\n\n    if ((err = ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats)) < 0 ||\n        (err = ff_formats_ref(ff_make_format_list(output_pix_fmts),\n                              &avctx->outputs[0]->in_formats)) < 0)\n        goto fail;\n\n    av_hwframe_constraints_free(&constraints);\n    return 0;\n\nfail:\n    av_buffer_unref(&ctx->hwdevice_ref);\n    av_hwframe_constraints_free(&constraints);\n    return err;\n}", "target": 0}
{"idx": 5415, "func": "static void end_frame_over(AVFilterLink *inlink)\n{\n    AVFilterContext *ctx = inlink->dst;\n    OverlayContext *over = ctx->priv;\n    AVFilterBufferRef *inpicref = inlink->cur_buf;\n\n    flush_frames(ctx);\n    inpicref->pts = av_rescale_q(inpicref->pts, ctx->inputs[OVERLAY]->time_base,\n                                 ctx->outputs[0]->time_base);\n    ff_bufqueue_add(ctx, &over->queue_over, inpicref);\n    try_push_frame(ctx);\n}", "target": 0}
{"idx": 5416, "func": "void ff_check_pixfmt_descriptors(void){\n    int i, j;\n\n    for (i=0; i<FF_ARRAY_ELEMS(av_pix_fmt_descriptors); i++) {\n        const AVPixFmtDescriptor *d = &av_pix_fmt_descriptors[i];\n        uint8_t fill[4][8+6+3] = {{0}};\n        uint8_t *data[4] = {fill[0], fill[1], fill[2], fill[3]};\n        int linesize[4] = {0,0,0,0};\n        uint16_t tmp[2];\n\n        if (!d->name && !d->nb_components && !d->log2_chroma_w && !d->log2_chroma_h && !d->flags)\n            continue;\n//         av_log(NULL, AV_LOG_DEBUG, \"Checking: %s\\n\", d->name);\n        av_assert0(d->log2_chroma_w <= 3);\n        av_assert0(d->log2_chroma_h <= 3);\n        av_assert0(d->nb_components <= 4);\n        av_assert0(d->name && d->name[0]);\n        av_assert0((d->nb_components==4 || d->nb_components==2) == !!(d->flags & AV_PIX_FMT_FLAG_ALPHA));\n        av_assert2(av_get_pix_fmt(d->name) == i);\n\n        for (j=0; j<FF_ARRAY_ELEMS(d->comp); j++) {\n            const AVComponentDescriptor *c = &d->comp[j];\n            if(j>=d->nb_components) {\n                av_assert0(!c->plane && !c->step_minus1 && !c->offset_plus1 && !c->shift && !c->depth_minus1);\n                continue;\n            }\n            if (d->flags & AV_PIX_FMT_FLAG_BITSTREAM) {\n                av_assert0(c->step_minus1 >= c->depth_minus1);\n            } else {\n                av_assert0(8*(c->step_minus1+1) >= c->depth_minus1+1);\n            }\n            av_read_image_line(tmp, (void*)data, linesize, d, 0, 0, j, 2, 0);\n            if (!strncmp(d->name, \"bayer_\", 6))\n                continue;\n            av_assert0(tmp[0] == 0 && tmp[1] == 0);\n            tmp[0] = tmp[1] = (1<<(c->depth_minus1 + 1)) - 1;\n            av_write_image_line(tmp, data, linesize, d, 0, 0, j, 2);\n        }\n    }\n}", "target": 1}
{"idx": 5417, "func": "static EVP_PKEY *ibm_4758_load_privkey(ENGINE* e, const char* key_id,\n\t\t\tUI_METHOD *ui_method, void *callback_data)\n\t{\n\tRSA *rtmp = NULL;\n\tEVP_PKEY *res = NULL;\n\tunsigned char* keyToken = NULL;\n\tunsigned char pubKeyToken[MAX_CCA_PKA_TOKEN_SIZE];\n\tlong pubKeyTokenLength = MAX_CCA_PKA_TOKEN_SIZE;\n\tlong keyTokenLength = MAX_CCA_PKA_TOKEN_SIZE;\n\tlong returnCode;\n\tlong reasonCode;\n\tlong exitDataLength = 0;\n\tlong ruleArrayLength = 0;\n\tunsigned char exitData[8];\n\tunsigned char ruleArray[8];\n\tunsigned char keyLabel[64];\n\tunsigned long keyLabelLength = strlen(key_id);\n\tunsigned char modulus[256];\n\tlong modulusFieldLength = sizeof(modulus);\n\tlong modulusLength = 0;\n\tunsigned char exponent[256];\n\tlong exponentLength = sizeof(exponent);\n\n\tif (keyLabelLength > sizeof(keyLabel))\n\t\t{\n\t\tCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\n\t\tCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\n\t\treturn NULL;\n\t\t}\n\n\tmemset(keyLabel,' ', sizeof(keyLabel));\n\tmemcpy(keyLabel, key_id, keyLabelLength);\n\n\tkeyToken = OPENSSL_malloc(MAX_CCA_PKA_TOKEN_SIZE + sizeof(long));\n\tif (!keyToken)\n\t\t{\n\t\tCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\n\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tkeyRecordRead(&returnCode, &reasonCode, &exitDataLength,\n\t\texitData, &ruleArrayLength, ruleArray, keyLabel,\n\t\t&keyTokenLength, keyToken+sizeof(long));\n\n\tif (returnCode)\n\t\t{\n\t\tCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\n\t\t\tCCA4758_R_FAILED_LOADING_PRIVATE_KEY);\n\t\tgoto err;\n\t\t}\n\n\tpublicKeyExtract(&returnCode, &reasonCode, &exitDataLength,\n\t\texitData, &ruleArrayLength, ruleArray, &keyTokenLength,\n\t\tkeyToken+sizeof(long), &pubKeyTokenLength, pubKeyToken);\n\n\tif (returnCode)\n\t\t{\n\t\tCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\n\t\t\tCCA4758_R_FAILED_LOADING_PRIVATE_KEY);\n\t\tgoto err;\n\t\t}\n\n\tif (!getModulusAndExponent(pubKeyToken, &exponentLength,\n\t\t\texponent, &modulusLength, &modulusFieldLength,\n\t\t\tmodulus))\n\t\t{\n\t\tCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\n\t\t\tCCA4758_R_FAILED_LOADING_PRIVATE_KEY);\n\t\tgoto err;\n\t\t}\n\n\t(*(long*)keyToken) = keyTokenLength;\n\trtmp = RSA_new_method(e);\n\tRSA_set_ex_data(rtmp, hndidx, (char *)keyToken);\n\n\trtmp->e = BN_bin2bn(exponent, exponentLength, NULL);\n\trtmp->n = BN_bin2bn(modulus, modulusFieldLength, NULL);\n\trtmp->flags |= RSA_FLAG_EXT_PKEY;\n\n\tres = EVP_PKEY_new();\n\tEVP_PKEY_assign_RSA(res, rtmp);\n\n\treturn res;\nerr:\n\tif (keyToken)\n\t\tOPENSSL_free(keyToken);\n\treturn NULL;\n\t}", "target": 1}
{"idx": 5418, "func": "ngx_int_t\nngx_http_internal_redirect(ngx_http_request_t *r,\n    ngx_str_t *uri, ngx_str_t *args)\n{\n    ngx_http_core_srv_conf_t  *cscf;\n\n    r->uri_changes--;\n\n    if (r->uri_changes == 0) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"rewrite or internal redirection cycle \"\n                      \"while internally redirecting to \\\"%V\\\"\", uri);\n\n        r->main->count++;\n        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return NGX_DONE;\n    }\n\n    r->uri = *uri;\n\n    if (args) {\n        r->args = *args;\n\n    } else {\n        ngx_str_null(&r->args);\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"internal redirect: \\\"%V?%V\\\"\", uri, &r->args);\n\n    ngx_http_set_exten(r);\n\n    /* clear the modules contexts */\n    ngx_memzero(r->ctx, sizeof(void *) * ngx_http_max_module);\n\n    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n    r->loc_conf = cscf->ctx->loc_conf;\n\n    ngx_http_update_location_config(r);\n\n#if (NGX_HTTP_CACHE)\n    r->cache = NULL;\n#endif\n\n    r->internal = 1;\n    r->valid_unparsed_uri = 0;\n    r->add_uri_to_alias = 0;\n    r->main->count++;\n\n    ngx_http_handler(r);\n\n    return NGX_DONE;\n}", "target": 1}
{"idx": 5419, "func": "STACK_OF(X509_INFO) *PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u)\n\t{\n\tX509_INFO *xi=NULL;\n\tchar *name=NULL,*header=NULL;\n\tvoid *pp;\n\tunsigned char *data=NULL;\n\tconst unsigned char *p;\n\tlong len,error=0;\n\tint ok=0;\n\tSTACK_OF(X509_INFO) *ret=NULL;\n\tunsigned int i,raw,ptype;\n\td2i_of_void *d2i;\n\n\tif (sk == NULL)\n\t\t{\n\t\tif ((ret=sk_X509_INFO_new_null()) == NULL)\n\t\t\t{\n\t\t\tPEMerr(PEM_F_PEM_X509_INFO_READ_BIO,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\tret=sk;\n\n\tif ((xi=X509_INFO_new()) == NULL) goto err;\n\tfor (;;)\n\t\t{\n\t\traw=0;\n\t\tptype = 0;\n\t\ti=PEM_read_bio(bp,&name,&header,&data,&len);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\terror=ERR_GET_REASON(ERR_peek_last_error());\n\t\t\tif (error == PEM_R_NO_START_LINE)\n\t\t\t\t{\n\t\t\t\tERR_clear_error();\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tgoto err;\n\t\t\t}\nstart:\n\t\tif (\t(strcmp(name,PEM_STRING_X509) == 0) ||\n\t\t\t(strcmp(name,PEM_STRING_X509_OLD) == 0))\n\t\t\t{\n\t\t\td2i=(D2I_OF(void))d2i_X509;\n\t\t\tif (xi->x509 != NULL)\n\t\t\t\t{\n\t\t\t\tif (!sk_X509_INFO_push(ret,xi)) goto err;\n\t\t\t\tif ((xi=X509_INFO_new()) == NULL) goto err;\n\t\t\t\tgoto start;\n\t\t\t\t}\n\t\t\tpp=&(xi->x509);\n\t\t\t}\n\t\telse if ((strcmp(name,PEM_STRING_X509_TRUSTED) == 0))\n\t\t\t{\n\t\t\td2i=(D2I_OF(void))d2i_X509_AUX;\n\t\t\tif (xi->x509 != NULL)\n\t\t\t\t{\n\t\t\t\tif (!sk_X509_INFO_push(ret,xi)) goto err;\n\t\t\t\tif ((xi=X509_INFO_new()) == NULL) goto err;\n\t\t\t\tgoto start;\n\t\t\t\t}\n\t\t\tpp=&(xi->x509);\n\t\t\t}\n\t\telse if (strcmp(name,PEM_STRING_X509_CRL) == 0)\n\t\t\t{\n\t\t\td2i=(D2I_OF(void))d2i_X509_CRL;\n\t\t\tif (xi->crl != NULL)\n\t\t\t\t{\n\t\t\t\tif (!sk_X509_INFO_push(ret,xi)) goto err;\n\t\t\t\tif ((xi=X509_INFO_new()) == NULL) goto err;\n\t\t\t\tgoto start;\n\t\t\t\t}\n\t\t\tpp=&(xi->crl);\n\t\t\t}\n\t\telse\n#ifndef OPENSSL_NO_RSA\n\t\t\tif (strcmp(name,PEM_STRING_RSA) == 0)\n\t\t\t{\n\t\t\tif (xi->x_pkey != NULL) \n\t\t\t\t{\n\t\t\t\tif (!sk_X509_INFO_push(ret,xi)) goto err;\n\t\t\t\tif ((xi=X509_INFO_new()) == NULL) goto err;\n\t\t\t\tgoto start;\n\t\t\t\t}\n\n\t\t\txi->enc_data=NULL;\n\t\t\txi->enc_len=0;\n\n\t\t\txi->x_pkey=X509_PKEY_new();\n\t\t\tptype=EVP_PKEY_RSA;\n\t\t\tpp=&xi->x_pkey->dec_pkey;\n\t\t\tif ((int)strlen(header) > 10) /* assume encrypted */\n\t\t\t\traw=1;\n\t\t\t}\n\t\telse\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\t\tif (strcmp(name,PEM_STRING_DSA) == 0)\n\t\t\t{\n\t\t\td2i=(D2I_OF(void))d2i_DSAPrivateKey;\n\t\t\tif (xi->x_pkey != NULL) \n\t\t\t\t{\n\t\t\t\tif (!sk_X509_INFO_push(ret,xi)) goto err;\n\t\t\t\tif ((xi=X509_INFO_new()) == NULL) goto err;\n\t\t\t\tgoto start;\n\t\t\t\t}\n\n\t\t\txi->enc_data=NULL;\n\t\t\txi->enc_len=0;\n\n\t\t\txi->x_pkey=X509_PKEY_new();\n\t\t\tptype = EVP_PKEY_DSA;\n\t\t\tpp=&xi->x_pkey->dec_pkey;\n\t\t\tif ((int)strlen(header) > 10) /* assume encrypted */\n\t\t\t\traw=1;\n\t\t\t}\n\t\telse\n#endif\n#ifndef OPENSSL_NO_EC\n \t\t\tif (strcmp(name,PEM_STRING_ECPRIVATEKEY) == 0)\n \t\t\t{\n \t\t\t\td2i=(D2I_OF(void))d2i_ECPrivateKey;\n \t\t\t\tif (xi->x_pkey != NULL) \n \t\t\t\t{\n \t\t\t\t\tif (!sk_X509_INFO_push(ret,xi)) goto err;\n \t\t\t\t\tif ((xi=X509_INFO_new()) == NULL) goto err;\n \t\t\t\t\t\tgoto start;\n \t\t\t\t}\n \n \t\t\txi->enc_data=NULL;\n \t\t\txi->enc_len=0;\n \n \t\t\txi->x_pkey=X509_PKEY_new();\n\t\t\tptype = EVP_PKEY_EC;\n \t\t\tpp=&xi->x_pkey->dec_pkey;\n \t\t\tif ((int)strlen(header) > 10) /* assume encrypted */\n \t\t\t\traw=1;\n\t\t\t}\n\t\telse\n#endif\n\t\t\t{\n\t\t\td2i=NULL;\n\t\t\tpp=NULL;\n\t\t\t}\n\n\t\tif (d2i != NULL)\n\t\t\t{\n\t\t\tif (!raw)\n\t\t\t\t{\n\t\t\t\tEVP_CIPHER_INFO cipher;\n\n\t\t\t\tif (!PEM_get_EVP_CIPHER_INFO(header,&cipher))\n\t\t\t\t\tgoto err;\n\t\t\t\tif (!PEM_do_header(&cipher,data,&len,cb,u))\n\t\t\t\t\tgoto err;\n\t\t\t\tp=data;\n\t\t\t\tif (ptype)\n\t\t\t\t\t{\n\t\t\t\t\tif (!d2i_PrivateKey(ptype, pp, &p, len))\n\t\t\t\t\t\t{\n\t\t\t\t\t\tPEMerr(PEM_F_PEM_X509_INFO_READ_BIO,ERR_R_ASN1_LIB);\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse if (d2i(pp,&p,len) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tPEMerr(PEM_F_PEM_X509_INFO_READ_BIO,ERR_R_ASN1_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{ /* encrypted RSA data */\n\t\t\t\tif (!PEM_get_EVP_CIPHER_INFO(header,\n\t\t\t\t\t&xi->enc_cipher)) goto err;\n\t\t\t\txi->enc_data=(char *)data;\n\t\t\t\txi->enc_len=(int)len;\n\t\t\t\tdata=NULL;\n\t\t\t\t}\n\t\t\t}\n\t\telse\t{\n\t\t\t/* unknown */\n\t\t\t}\n\t\tif (name != NULL) OPENSSL_free(name);\n\t\tif (header != NULL) OPENSSL_free(header);\n\t\tif (data != NULL) OPENSSL_free(data);\n\t\tname=NULL;\n\t\theader=NULL;\n\t\tdata=NULL;\n\t\t}\n\n\t/* if the last one hasn't been pushed yet and there is anything\n\t * in it then add it to the stack ... \n\t */\n\tif ((xi->x509 != NULL) || (xi->crl != NULL) ||\n\t\t(xi->x_pkey != NULL) || (xi->enc_data != NULL))\n\t\t{\n\t\tif (!sk_X509_INFO_push(ret,xi)) goto err;\n\t\txi=NULL;\n\t\t}\n\tok=1;\nerr:\n\tif (xi != NULL) X509_INFO_free(xi);\n\tif (!ok)\n\t\t{\n\t\tfor (i=0; ((int)i)<sk_X509_INFO_num(ret); i++)\n\t\t\t{\n\t\t\txi=sk_X509_INFO_value(ret,i);\n\t\t\tX509_INFO_free(xi);\n\t\t\t}\n\t\tif (ret != sk) sk_X509_INFO_free(ret);\n\t\tret=NULL;\n\t\t}\n\t\t\n\tif (name != NULL) OPENSSL_free(name);\n\tif (header != NULL) OPENSSL_free(header);\n\tif (data != NULL) OPENSSL_free(data);\n\treturn(ret);\n\t}", "target": 0}
{"idx": 5420, "func": "static int compand_delay(AVFilterContext *ctx, AVFrame *frame)\n{\n    CompandContext *s    = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    const int channels = inlink->channels;\n    const int nb_samples = frame->nb_samples;\n    int chan, i, av_uninit(dindex), oindex, av_uninit(count);\n    AVFrame *out_frame   = NULL;\n    int err;\n\n    if (s->pts == AV_NOPTS_VALUE) {\n        s->pts = (frame->pts == AV_NOPTS_VALUE) ? 0 : frame->pts;\n    }\n\n    av_assert1(channels > 0); /* would corrupt delay_count and delay_index */\n\n    for (chan = 0; chan < channels; chan++) {\n        AVFrame *delay_frame = s->delay_frame;\n        const double *src = (double *)frame->extended_data[chan];\n        double *dbuf      = (double *)delay_frame->extended_data[chan];\n        ChanParam *cp        = &s->channels[chan];\n        double *dst;\n\n        count  = s->delay_count;\n        dindex = s->delay_index;\n        for (i = 0, oindex = 0; i < nb_samples; i++) {\n            const double in = src[i];\n            update_volume(cp, fabs(in));\n\n            if (count >= s->delay_samples) {\n                if (!out_frame) {\n                    out_frame = ff_get_audio_buffer(inlink, nb_samples - i);\n                    if (!out_frame) {\n                        av_frame_free(&frame);\n                        return AVERROR(ENOMEM);\n                    }\n                    err = av_frame_copy_props(out_frame, frame);\n                    if (err < 0) {\n                        av_frame_free(&out_frame);\n                        av_frame_free(&frame);\n                        return err;\n                    }\n                    out_frame->pts = s->pts;\n                    s->pts += av_rescale_q(nb_samples - i,\n                        (AVRational){ 1, inlink->sample_rate },\n                        inlink->time_base);\n                }\n\n                dst = (double *)out_frame->extended_data[chan];\n                dst[oindex++] = av_clipd(dbuf[dindex] *\n                        get_volume(s, cp->volume), -1, 1);\n            } else {\n                count++;\n            }\n\n            dbuf[dindex] = in;\n            dindex = MOD(dindex + 1, s->delay_samples);\n        }\n    }\n\n    s->delay_count = count;\n    s->delay_index = dindex;\n\n    av_frame_free(&frame);\n    return out_frame ? ff_filter_frame(ctx->outputs[0], out_frame) : 0;\n}", "target": 0}
{"idx": 5421, "func": "ngx_int_t\nngx_create_temp_file(ngx_file_t *file, ngx_path_t *path, ngx_pool_t *pool,\n    ngx_uint_t persistent, ngx_uint_t clean, ngx_uint_t access)\n{\n    u_char                   *p;\n    uint32_t                  n;\n    ngx_err_t                 err;\n    ngx_str_t                 prefix;\n    ngx_pool_cleanup_t       *cln;\n    ngx_pool_cleanup_file_t  *clnf;\n\n    prefix = path ? path->name : file->name;\n    file->name.len = prefix.len + 1 + (path ? path->len : 0) + 10;\n\n    file->name.data = ngx_pnalloc(pool, file->name.len + 1);\n    if (file->name.data == NULL) {\n        return NGX_ERROR;\n    }\n\n#if 0\n    for (i = 0; i < file->name.len; i++) {\n         file->name.data[i] = 'X';\n    }\n#endif\n\n    p = ngx_cpymem(file->name.data, prefix.data, prefix.len);\n\n    if (path) {\n        p += 1 + path->len;\n\n    } else {\n        *p++ = '.';\n    }\n\n    n = (uint32_t) ngx_next_temp_number(0);\n\n    cln = ngx_pool_cleanup_add(pool, sizeof(ngx_pool_cleanup_file_t));\n    if (cln == NULL) {\n        return NGX_ERROR;\n    }\n\n    for ( ;; ) {\n        (void) ngx_sprintf(p, \"%010uD%Z\", n);\n\n        if (path) {\n            ngx_create_hashed_filename(path, file->name.data, file->name.len);\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, file->log, 0,\n                       \"hashed path: %s\", file->name.data);\n\n        file->fd = ngx_open_tempfile(file->name.data, persistent, access);\n\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, file->log, 0,\n                       \"temp fd:%d\", file->fd);\n\n        if (file->fd != NGX_INVALID_FILE) {\n\n            cln->handler = clean ? ngx_pool_delete_file : ngx_pool_cleanup_file;\n            clnf = cln->data;\n\n            clnf->fd = file->fd;\n            clnf->name = file->name.data;\n            clnf->log = pool->log;\n\n            return NGX_OK;\n        }\n\n        err = ngx_errno;\n\n        if (err == NGX_EEXIST) {\n            n = (uint32_t) ngx_next_temp_number(1);\n            continue;\n        }\n\n        if ((path == NULL) || (path->level[0] == 0) || (err != NGX_ENOPATH)) {\n            ngx_log_error(NGX_LOG_CRIT, file->log, err,\n                          ngx_open_tempfile_n \" \\\"%s\\\" failed\",\n                          file->name.data);\n            return NGX_ERROR;\n        }\n\n        if (ngx_create_path(file, path) == NGX_ERROR) {\n            return NGX_ERROR;\n        }\n    }\n}", "target": 0}
{"idx": 5422, "func": "static int output_data_internal(MLPDecodeContext *m, unsigned int substr,\n                                uint8_t *data, unsigned int *data_size, int is32)\n{\n    SubStream *s = &m->substream[substr];\n    unsigned int i, out_ch = 0;\n    int32_t *data_32 = (int32_t*) data;\n    int16_t *data_16 = (int16_t*) data;\n\n    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))\n        return -1;\n\n    for (i = 0; i < s->blockpos; i++) {\n        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {\n            int mat_ch = s->ch_assign[out_ch];\n            int32_t sample = m->sample_buffer[i][mat_ch]\n                          << s->output_shift[mat_ch];\n            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;\n            if (is32) *data_32++ = sample << 8;\n            else      *data_16++ = sample >> 8;\n        }\n    }\n\n    *data_size = i * out_ch * (is32 ? 4 : 2);\n\n    return 0;\n}", "target": 1}
{"idx": 5423, "func": "static ossl_inline void blake2s_increment_counter(BLAKE2S_CTX *S,\n                                                  const uint32_t inc)\n{\n    S->t[0] += inc;\n    S->t[1] += (S->t[0] < inc);\n}", "target": 1}
{"idx": 5424, "func": "static int get_sindex(AVFormatContext *s, int id, int format) {\n    int i;\n    AVStream *st = NULL;\n    for (i = 0; i < s->nb_streams; i++) {\n        if (s->streams[i]->id == id)\n            return i;\n    }\n    st = av_new_stream(s, id);\n    if (!st)\n        return AVERROR(ENOMEM);\n    switch (format) {\n        case 3:\n        case 4:\n            st->codec->codec_type = CODEC_TYPE_VIDEO;\n            st->codec->codec_id = CODEC_ID_MJPEG;\n            break;\n        case 13:\n        case 15:\n            st->codec->codec_type = CODEC_TYPE_VIDEO;\n            st->codec->codec_id = CODEC_ID_DVVIDEO;\n            break;\n        case 14:\n        case 16:\n            st->codec->codec_type = CODEC_TYPE_VIDEO;\n            st->codec->codec_id = CODEC_ID_DVVIDEO;\n            break;\n        case 11:\n        case 12:\n        case 20:\n            st->codec->codec_type = CODEC_TYPE_VIDEO;\n            st->codec->codec_id = CODEC_ID_MPEG2VIDEO;\n            st->need_parsing = AVSTREAM_PARSE_HEADERS; //get keyframe flag etc.\n            break;\n        case 22:\n        case 23:\n            st->codec->codec_type = CODEC_TYPE_VIDEO;\n            st->codec->codec_id = CODEC_ID_MPEG1VIDEO;\n            st->need_parsing = AVSTREAM_PARSE_HEADERS; //get keyframe flag etc.\n            break;\n        case 9:\n            st->codec->codec_type = CODEC_TYPE_AUDIO;\n            st->codec->codec_id = CODEC_ID_PCM_S24LE;\n            st->codec->channels = 1;\n            st->codec->sample_rate = 48000;\n            st->codec->bit_rate = 3 * 1 * 48000 * 8;\n            st->codec->block_align = 3 * 1;\n            st->codec->bits_per_sample = 24;\n            break;\n        case 10:\n            st->codec->codec_type = CODEC_TYPE_AUDIO;\n            st->codec->codec_id = CODEC_ID_PCM_S16LE;\n            st->codec->channels = 1;\n            st->codec->sample_rate = 48000;\n            st->codec->bit_rate = 2 * 1 * 48000 * 8;\n            st->codec->block_align = 2 * 1;\n            st->codec->bits_per_sample = 16;\n            break;\n        case 17:\n            st->codec->codec_type = CODEC_TYPE_AUDIO;\n            st->codec->codec_id = CODEC_ID_AC3;\n            st->codec->channels = 2;\n            st->codec->sample_rate = 48000;\n            break;\n        // timecode tracks:\n        case 7:\n        case 8:\n        case 24:\n            st->codec->codec_type = CODEC_TYPE_DATA;\n            st->codec->codec_id = CODEC_ID_NONE;\n            break;\n        default:\n            st->codec->codec_type = CODEC_TYPE_UNKNOWN;\n            st->codec->codec_id = CODEC_ID_NONE;\n            break;\n    }\n    return s->nb_streams - 1;\n}", "target": 0}
{"idx": 5425, "func": "static int start_ebml_master_crc32(AVIOContext *pb, AVIOContext **dyn_cp, MatroskaMuxContext *mkv,\n                                   ebml_master *master, unsigned int elementid, uint64_t expectedsize)\n{\n    int ret;\n\n    if ((ret = avio_open_dyn_buf(dyn_cp)) < 0)\n        return ret;\n\n    if (pb->seekable) {\n        *master = start_ebml_master(pb, elementid, expectedsize);\n        if (mkv->write_crc && mkv->mode != MODE_WEBM)\n            put_ebml_void(*dyn_cp, 6); /* Reserve space for CRC32 so position/size calculations using avio_tell() take it into account */\n    } else\n        *master = start_ebml_master(*dyn_cp, elementid, expectedsize);\n\n    return 0;\n}", "target": 0}
{"idx": 5426, "func": "static int mov_text_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_sub_ptr, AVPacket *avpkt)\n{\n    AVSubtitle *sub = data;\n    int ret, ts_start, ts_end;\n    AVBPrint buf;\n    char *ptr = avpkt->data;\n    char *end;\n    //char *ptr_temp;\n    int text_length, tsmb_type, style_entries, tsmb_size, tracksize;\n    int **style_start = {0,};\n    int **style_end = {0,};\n    int **style_flags = {0,};\n    const uint8_t *tsmb;\n    int index, i;\n    int *flag;\n    int *style_pos;\n\n    if (!ptr || avpkt->size < 2)\n        return AVERROR_INVALIDDATA;\n\n    /*\n     * A packet of size two with value zero is an empty subtitle\n     * used to mark the end of the previous non-empty subtitle.\n     * We can just drop them here as we have duration information\n     * already. If the value is non-zero, then it's technically a\n     * bad packet.\n     */\n    if (avpkt->size == 2)\n        return AV_RB16(ptr) == 0 ? 0 : AVERROR_INVALIDDATA;\n\n    /*\n     * The first two bytes of the packet are the length of the text string\n     * In complex cases, there are style descriptors appended to the string\n     * so we can't just assume the packet size is the string size.\n     */\n    text_length = AV_RB16(ptr);\n    end = ptr + FFMIN(2 + text_length, avpkt->size);\n    ptr += 2;\n\n    ts_start = av_rescale_q(avpkt->pts,\n                            avctx->time_base,\n                            (AVRational){1,100});\n    ts_end   = av_rescale_q(avpkt->pts + avpkt->duration,\n                            avctx->time_base,\n                            (AVRational){1,100});\n\n    tsmb_size = 0;\n    tracksize = 2 + text_length;\n    // Note that the spec recommends lines be no longer than 2048 characters.\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);\n    if (text_length + 2 != avpkt->size) {\n        while (tracksize + 8 <= avpkt->size) {\n            // A box is a minimum of 8 bytes.\n            tsmb = ptr + tracksize - 2;\n            tsmb_size = AV_RB32(tsmb);\n            tsmb += 4;\n            tsmb_type = AV_RB32(tsmb);\n            tsmb += 4;\n\n            if (tracksize + tsmb_size > avpkt->size)\n                break;\n\n            if (tsmb_type == MKBETAG('s','t','y','l')) {\n                if (tracksize + 10 > avpkt->size)\n                    break;\n                style_entries = AV_RB16(tsmb);\n                tsmb += 2;\n\n                // A single style record is of length 12 bytes.\n                if (tracksize + 10 + style_entries * 12 > avpkt->size)\n                    break;\n\n                for(i = 0; i < style_entries; i++) {\n                    style_pos = av_malloc(4);\n                    *style_pos = AV_RB16(tsmb);\n                    index = i;\n                    av_dynarray_add(&style_start, &index, style_pos);\n                    tsmb += 2;\n                    style_pos = av_malloc(4);\n                    *style_pos = AV_RB16(tsmb);\n                    index = i;\n                    av_dynarray_add(&style_end, &index, style_pos);\n                    tsmb += 2;\n                    // fontID = AV_RB16(tsmb);\n                    tsmb += 2;\n                    flag = av_malloc(4);\n                    *flag = AV_RB8(tsmb);\n                    index = i;\n                    av_dynarray_add(&style_flags, &index, flag);\n                    //fontsize=AV_RB8(tsmb);\n                    tsmb += 2;\n                    // text-color-rgba\n                    tsmb += 4;\n                }\n                text_to_ass(&buf, ptr, end, style_start, style_end, style_flags, style_entries);\n                av_freep(&style_start);\n                av_freep(&style_end);\n                av_freep(&style_flags);\n            }\n            tracksize = tracksize + tsmb_size;\n        }\n    } else\n        text_to_ass(&buf, ptr, end, NULL, NULL, 0, 0);\n\n    ret = ff_ass_add_rect_bprint(sub, &buf, ts_start, ts_end - ts_start);\n    av_bprint_finalize(&buf, NULL);\n    if (ret < 0)\n        return ret;\n    *got_sub_ptr = sub->num_rects > 0;\n    return avpkt->size;\n}", "target": 0}
{"idx": 5427, "func": "static inline void memcpy_backptr(uint8_t *dst, int back, int cnt) {\n    const uint8_t *src = &dst[-back];\n    if (back == 1) {\n        memset(dst, *src, cnt);\n    } else {\n#ifdef OUTBUF_PADDED\n        COPY2(dst, src);\n        COPY2(dst + 2, src + 2);\n        src += 4;\n        dst += 4;\n        cnt -= 4;\n        if (cnt > 0) {\n            COPY2(dst, src);\n            COPY2(dst + 2, src + 2);\n            COPY2(dst + 4, src + 4);\n            COPY2(dst + 6, src + 6);\n            src += 8;\n            dst += 8;\n            cnt -= 8;\n        }\n#endif\n        if (cnt > 0) {\n            int blocklen = back;\n            while (cnt > blocklen) {\n                memcpy(dst, src, blocklen);\n                dst += blocklen;\n                cnt -= blocklen;\n                blocklen <<= 1;\n            }\n            memcpy(dst, src, cnt);\n        }\n    }\n}", "target": 1}
{"idx": 5428, "func": "int RAND_poll(void)\n{\n    int ret = 0;\n\n    RAND_POOL *pool = NULL;\n\n    const RAND_METHOD *meth = RAND_get_rand_method();\n\n    if (meth == RAND_OpenSSL()) {\n        /* fill random pool and seed the master DRBG */\n        RAND_DRBG *drbg = RAND_DRBG_get0_master();\n\n        if (drbg == NULL)\n            return 0;\n\n        rand_drbg_lock(drbg);\n        ret = rand_drbg_restart(drbg, NULL, 0, 0);\n        rand_drbg_unlock(drbg);\n\n        return ret;\n\n    } else {\n        /* fill random pool and seed the current legacy RNG */\n        pool = rand_pool_new(RAND_DRBG_STRENGTH,\n                             RAND_DRBG_STRENGTH / 8,\n                             RAND_POOL_MAX_LENGTH);\n        if (pool == NULL)\n            return 0;\n\n        if (rand_pool_acquire_entropy(pool) == 0)\n            goto err;\n\n        if (meth->add == NULL\n            || meth->add(rand_pool_buffer(pool),\n                         rand_pool_length(pool),\n                         (rand_pool_entropy(pool) / 8.0)) == 0)\n            goto err;\n\n        ret = 1;\n    }\n\nerr:\n    rand_pool_free(pool);\n    return ret;\n}", "target": 0}
{"idx": 5429, "func": "void ff_sbr_apply(AACContext *ac, SpectralBandReplication *sbr, int id_aac,\n                  float* L, float* R)\n{\n    int downsampled = ac->m4ac.ext_sample_rate < sbr->sample_rate;\n    int ch;\n    int nch = (id_aac == TYPE_CPE) ? 2 : 1;\n\n    if (sbr->start) {\n        sbr_dequant(sbr, id_aac);\n    }\n    for (ch = 0; ch < nch; ch++) {\n        /* decode channel */\n        sbr_qmf_analysis(&ac->dsp, &sbr->mdct_ana, &sbr->dsp, ch ? R : L, sbr->data[ch].analysis_filterbank_samples,\n                         (float*)sbr->qmf_filter_scratch,\n                         sbr->data[ch].W);\n        sbr_lf_gen(ac, sbr, sbr->X_low, sbr->data[ch].W);\n        if (sbr->start) {\n            sbr_hf_inverse_filter(&sbr->dsp, sbr->alpha0, sbr->alpha1, sbr->X_low, sbr->k[0]);\n            sbr_chirp(sbr, &sbr->data[ch]);\n            sbr_hf_gen(ac, sbr, sbr->X_high, sbr->X_low, sbr->alpha0, sbr->alpha1,\n                       sbr->data[ch].bw_array, sbr->data[ch].t_env,\n                       sbr->data[ch].bs_num_env);\n\n            // hf_adj\n            sbr_mapping(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);\n            sbr_env_estimate(sbr->e_curr, sbr->X_high, sbr, &sbr->data[ch]);\n            sbr_gain_calc(ac, sbr, &sbr->data[ch], sbr->data[ch].e_a);\n            sbr_hf_assemble(sbr->data[ch].Y, sbr->X_high, sbr, &sbr->data[ch],\n                            sbr->data[ch].e_a);\n        }\n\n        /* synthesis */\n        sbr_x_gen(sbr, sbr->X[ch], sbr->X_low, sbr->data[ch].Y, ch);\n    }\n\n    if (ac->m4ac.ps == 1) {\n        if (sbr->ps.start) {\n            ff_ps_apply(ac->avctx, &sbr->ps, sbr->X[0], sbr->X[1], sbr->kx[1] + sbr->m[1]);\n        } else {\n            memcpy(sbr->X[1], sbr->X[0], sizeof(sbr->X[0]));\n        }\n        nch = 2;\n    }\n\n    sbr_qmf_synthesis(&ac->dsp, &sbr->mdct, &sbr->dsp, L, sbr->X[0], sbr->qmf_filter_scratch,\n                      sbr->data[0].synthesis_filterbank_samples,\n                      &sbr->data[0].synthesis_filterbank_samples_offset,\n                      downsampled);\n    if (nch == 2)\n        sbr_qmf_synthesis(&ac->dsp, &sbr->mdct, &sbr->dsp, R, sbr->X[1], sbr->qmf_filter_scratch,\n                          sbr->data[1].synthesis_filterbank_samples,\n                          &sbr->data[1].synthesis_filterbank_samples_offset,\n                          downsampled);\n}", "target": 0}
{"idx": 5430, "func": "static int ljpeg_decode_yuv_scan(MJpegDecodeContext *s, int predictor,\n                                 int point_transform)\n{\n    int i, mb_x, mb_y;\n    const int nb_components=s->nb_components;\n    int bits= (s->bits+7)&~7;\n    int resync_mb_y = 0;\n    int resync_mb_x = 0;\n\n    point_transform += bits - s->bits;\n\n    av_assert0(nb_components==1 || nb_components==3);\n\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n            if (s->restart_interval && !s->restart_count){\n                s->restart_count = s->restart_interval;\n                resync_mb_x = mb_x;\n                resync_mb_y = mb_y;\n            }\n\n            if(!mb_x || mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x || s->interlaced){\n                int toprow  = mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x;\n                int leftcol = !mb_x || mb_y == resync_mb_y && mb_x == resync_mb_x;\n                for (i = 0; i < nb_components; i++) {\n                    uint8_t *ptr;\n                    uint16_t *ptr16;\n                    int n, h, v, x, y, c, j, linesize;\n                    n = s->nb_blocks[i];\n                    c = s->comp_index[i];\n                    h = s->h_scount[i];\n                    v = s->v_scount[i];\n                    x = 0;\n                    y = 0;\n                    linesize= s->linesize[c];\n\n                    if(bits>8) linesize /= 2;\n\n                    for(j=0; j<n; j++) {\n                        int pred, dc;\n\n                        dc = mjpeg_decode_dc(s, s->dc_index[i]);\n                        if(dc == 0xFFFF)\n                            return -1;\n                        if(bits<=8){\n                        ptr = s->picture.data[c] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap\n                        if(y==0 && toprow){\n                            if(x==0 && leftcol){\n                                pred= 1 << (bits - 1);\n                            }else{\n                                pred= ptr[-1];\n                            }\n                        }else{\n                            if(x==0 && leftcol){\n                                pred= ptr[-linesize];\n                            }else{\n                                PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n                            }\n                        }\n\n                        if (s->interlaced && s->bottom_field)\n                            ptr += linesize >> 1;\n                        pred &= (-1)<<(8-s->bits);\n                        *ptr= pred + (dc << point_transform);\n                        }else{\n                            ptr16 = (uint16_t*)(s->picture.data[c] + 2*(linesize * (v * mb_y + y)) + 2*(h * mb_x + x)); //FIXME optimize this crap\n                            if(y==0 && toprow){\n                                if(x==0 && leftcol){\n                                    pred= 1 << (bits - 1);\n                                }else{\n                                    pred= ptr16[-1];\n                                }\n                            }else{\n                                if(x==0 && leftcol){\n                                    pred= ptr16[-linesize];\n                                }else{\n                                    PREDICT(pred, ptr16[-linesize-1], ptr16[-linesize], ptr16[-1], predictor);\n                                }\n                            }\n\n                            if (s->interlaced && s->bottom_field)\n                                ptr16 += linesize >> 1;\n                            pred &= (-1)<<(16-s->bits);\n                            *ptr16= pred + (dc << point_transform);\n                        }\n                        if (++x == h) {\n                            x = 0;\n                            y++;\n                        }\n                    }\n                }\n            } else {\n                for (i = 0; i < nb_components; i++) {\n                    uint8_t *ptr;\n                    uint16_t *ptr16;\n                    int n, h, v, x, y, c, j, linesize, dc;\n                    n        = s->nb_blocks[i];\n                    c        = s->comp_index[i];\n                    h        = s->h_scount[i];\n                    v        = s->v_scount[i];\n                    x        = 0;\n                    y        = 0;\n                    linesize = s->linesize[c];\n\n                    if(bits>8) linesize /= 2;\n\n                    for (j = 0; j < n; j++) {\n                        int pred;\n\n                        dc = mjpeg_decode_dc(s, s->dc_index[i]);\n                        if(dc == 0xFFFF)\n                            return -1;\n                        if(bits<=8){\n                            ptr = s->picture.data[c] +\n                              (linesize * (v * mb_y + y)) +\n                              (h * mb_x + x); //FIXME optimize this crap\n                            PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n\n                            pred &= (-1)<<(8-s->bits);\n                            *ptr = pred + (dc << point_transform);\n                        }else{\n                            ptr16 = (uint16_t*)(s->picture.data[c] + 2*(linesize * (v * mb_y + y)) + 2*(h * mb_x + x)); //FIXME optimize this crap\n                            PREDICT(pred, ptr16[-linesize-1], ptr16[-linesize], ptr16[-1], predictor);\n\n                            pred &= (-1)<<(16-s->bits);\n                            *ptr16= pred + (dc << point_transform);\n                        }\n\n                        if (++x == h) {\n                            x = 0;\n                            y++;\n                        }\n                    }\n                }\n            }\n            if (s->restart_interval && !--s->restart_count) {\n                align_get_bits(&s->gb);\n                skip_bits(&s->gb, 16); /* skip RSTn */\n            }\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": 5431, "func": "static void\nngx_http_file_cache_cleanup(void *data)\n{\n    ngx_http_cache_t  *c = data;\n\n    if (c->updated) {\n        return;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->file.log, 0,\n                   \"http file cache cleanup\");\n\n    if (c->updating) {\n        ngx_log_error(NGX_LOG_ALERT, c->file.log, 0,\n                      \"stalled cache updating, error:%ui\", c->error);\n    }\n\n    ngx_http_file_cache_free(c, NULL);\n}", "target": 0}
{"idx": 5432, "func": "static int init_output_stream_streamcopy(OutputStream *ost)\n{\n    OutputFile *of = output_files[ost->file_index];\n    InputStream *ist = get_input_stream(ost);\n    AVCodecParameters *par_dst = ost->st->codecpar;\n    AVCodecParameters *par_src = ost->ref_par;\n    AVRational sar;\n    int i, ret;\n    uint32_t codec_tag = par_dst->codec_tag;\n\n    av_assert0(ist && !ost->filter);\n\n    ret = avcodec_parameters_to_context(ost->enc_ctx, ist->st->codecpar);\n    if (ret >= 0)\n        ret = av_opt_set_dict(ost->enc_ctx, &ost->encoder_opts);\n    if (ret < 0) {\n        av_log(NULL, AV_LOG_FATAL,\n               \"Error setting up codec context options.\\n\");\n        return ret;\n    }\n    avcodec_parameters_from_context(par_src, ost->enc_ctx);\n\n    if (!codec_tag) {\n        unsigned int codec_tag_tmp;\n        if (!of->ctx->oformat->codec_tag ||\n            av_codec_get_id (of->ctx->oformat->codec_tag, par_src->codec_tag) == par_src->codec_id ||\n            !av_codec_get_tag2(of->ctx->oformat->codec_tag, par_src->codec_id, &codec_tag_tmp))\n            codec_tag = par_src->codec_tag;\n    }\n\n    ret = avcodec_parameters_copy(par_dst, par_src);\n    if (ret < 0)\n        return ret;\n\n    par_dst->codec_tag = codec_tag;\n\n    if (!ost->frame_rate.num)\n        ost->frame_rate = ist->framerate;\n    ost->st->avg_frame_rate = ost->frame_rate;\n\n    ret = avformat_transfer_internal_stream_timing_info(of->ctx->oformat, ost->st, ist->st, copy_tb);\n    if (ret < 0)\n        return ret;\n\n    // copy timebase while removing common factors\n    ost->st->time_base = av_add_q(av_stream_get_codec_timebase(ost->st), (AVRational){0, 1});\n\n    // copy disposition\n    ost->st->disposition = ist->st->disposition;\n\n    if (ist->st->nb_side_data) {\n        ost->st->side_data = av_realloc_array(NULL, ist->st->nb_side_data,\n                                              sizeof(*ist->st->side_data));\n        if (!ost->st->side_data)\n            return AVERROR(ENOMEM);\n\n        ost->st->nb_side_data = 0;\n        for (i = 0; i < ist->st->nb_side_data; i++) {\n            const AVPacketSideData *sd_src = &ist->st->side_data[i];\n            AVPacketSideData *sd_dst = &ost->st->side_data[ost->st->nb_side_data];\n\n            if (ost->rotate_overridden && sd_src->type == AV_PKT_DATA_DISPLAYMATRIX)\n                continue;\n\n            sd_dst->data = av_malloc(sd_src->size);\n            if (!sd_dst->data)\n                return AVERROR(ENOMEM);\n            memcpy(sd_dst->data, sd_src->data, sd_src->size);\n            sd_dst->size = sd_src->size;\n            sd_dst->type = sd_src->type;\n            ost->st->nb_side_data++;\n        }\n    }\n\n    ost->parser = av_parser_init(par_dst->codec_id);\n    ost->parser_avctx = avcodec_alloc_context3(NULL);\n    if (!ost->parser_avctx)\n        return AVERROR(ENOMEM);\n\n    switch (par_dst->codec_type) {\n    case AVMEDIA_TYPE_AUDIO:\n        if (audio_volume != 256) {\n            av_log(NULL, AV_LOG_FATAL, \"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\n            exit_program(1);\n        }\n        if((par_dst->block_align == 1 || par_dst->block_align == 1152 || par_dst->block_align == 576) && par_dst->codec_id == AV_CODEC_ID_MP3)\n            par_dst->block_align= 0;\n        if(par_dst->codec_id == AV_CODEC_ID_AC3)\n            par_dst->block_align= 0;\n        break;\n    case AVMEDIA_TYPE_VIDEO:\n        if (ost->frame_aspect_ratio.num) { // overridden by the -aspect cli option\n            sar =\n                av_mul_q(ost->frame_aspect_ratio,\n                         (AVRational){ par_dst->height, par_dst->width });\n            av_log(NULL, AV_LOG_WARNING, \"Overriding aspect ratio \"\n                   \"with stream copy may produce invalid files\\n\");\n            }\n        else if (ist->st->sample_aspect_ratio.num)\n            sar = ist->st->sample_aspect_ratio;\n        else\n            sar = par_src->sample_aspect_ratio;\n        ost->st->sample_aspect_ratio = par_dst->sample_aspect_ratio = sar;\n        ost->st->avg_frame_rate = ist->st->avg_frame_rate;\n        ost->st->r_frame_rate = ist->st->r_frame_rate;\n        break;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5433, "func": "static int wma_decode_superframe(AVCodecContext *avctx, void *data,\n                                 int *got_frame_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    WMACodecContext *s = avctx->priv_data;\n    int nb_frames, bit_offset, i, pos, len, ret;\n    uint8_t *q;\n    int16_t *samples;\n\n    tprintf(avctx, \"***decode_superframe:\\n\");\n\n    if(buf_size==0){\n        s->last_superframe_len = 0;\n        return 0;\n    }\n    if (buf_size < s->block_align)\n        return 0;\n    buf_size = s->block_align;\n\n    init_get_bits(&s->gb, buf, buf_size*8);\n\n    if (s->use_bit_reservoir) {\n        /* read super frame header */\n        skip_bits(&s->gb, 4); /* super frame index */\n        nb_frames = get_bits(&s->gb, 4) - (s->last_superframe_len <= 0);\n    } else {\n        nb_frames = 1;\n    }\n\n    /* get output buffer */\n    s->frame.nb_samples = nb_frames * s->frame_len;\n    if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    samples = (int16_t *)s->frame.data[0];\n\n    if (s->use_bit_reservoir) {\n        bit_offset = get_bits(&s->gb, s->byte_offset_bits + 3);\n\n        if (s->last_superframe_len > 0) {\n            //        printf(\"skip=%d\\n\", s->last_bitoffset);\n            /* add bit_offset bits to last frame */\n            if ((s->last_superframe_len + ((bit_offset + 7) >> 3)) >\n                MAX_CODED_SUPERFRAME_SIZE)\n                goto fail;\n            q = s->last_superframe + s->last_superframe_len;\n            len = bit_offset;\n            while (len > 7) {\n                *q++ = (get_bits)(&s->gb, 8);\n                len -= 8;\n            }\n            if (len > 0) {\n                *q++ = (get_bits)(&s->gb, len) << (8 - len);\n            }\n\n            /* XXX: bit_offset bits into last frame */\n            init_get_bits(&s->gb, s->last_superframe, MAX_CODED_SUPERFRAME_SIZE*8);\n            /* skip unused bits */\n            if (s->last_bitoffset > 0)\n                skip_bits(&s->gb, s->last_bitoffset);\n            /* this frame is stored in the last superframe and in the\n               current one */\n            if (wma_decode_frame(s, samples) < 0)\n                goto fail;\n            samples += s->nb_channels * s->frame_len;\n            nb_frames--;\n        }\n\n        /* read each frame starting from bit_offset */\n        pos = bit_offset + 4 + 4 + s->byte_offset_bits + 3;\n        init_get_bits(&s->gb, buf + (pos >> 3), (MAX_CODED_SUPERFRAME_SIZE - (pos >> 3))*8);\n        len = pos & 7;\n        if (len > 0)\n            skip_bits(&s->gb, len);\n\n        s->reset_block_lengths = 1;\n        for(i=0;i<nb_frames;i++) {\n            if (wma_decode_frame(s, samples) < 0)\n                goto fail;\n            samples += s->nb_channels * s->frame_len;\n        }\n\n        /* we copy the end of the frame in the last frame buffer */\n        pos = get_bits_count(&s->gb) + ((bit_offset + 4 + 4 + s->byte_offset_bits + 3) & ~7);\n        s->last_bitoffset = pos & 7;\n        pos >>= 3;\n        len = buf_size - pos;\n        if (len > MAX_CODED_SUPERFRAME_SIZE || len < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"len %d invalid\\n\", len);\n            goto fail;\n        }\n        s->last_superframe_len = len;\n        memcpy(s->last_superframe, buf + pos, len);\n    } else {\n        /* single frame decode */\n        if (wma_decode_frame(s, samples) < 0)\n            goto fail;\n        samples += s->nb_channels * s->frame_len;\n    }\n\n//av_log(NULL, AV_LOG_ERROR, \"%d %d %d %d outbytes:%d eaten:%d\\n\", s->frame_len_bits, s->block_len_bits, s->frame_len, s->block_len,        (int8_t *)samples - (int8_t *)data, s->block_align);\n\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = s->frame;\n\n    return s->block_align;\n fail:\n    /* when error, we reset the bit reservoir */\n    s->last_superframe_len = 0;\n    return -1;\n}", "target": 1}
{"idx": 5434, "func": "static int tiff_unpack_strip(TiffContext *s, uint8_t* dst, int stride, const uint8_t *src, int size, int lines){\n    int c, line, pixels, code;\n    const uint8_t *ssrc = src;\n    int width = ((s->width * s->bpp) + 7) >> 3;\n\n    if (size <= 0)\n        return AVERROR_INVALIDDATA;\n\n#if CONFIG_ZLIB\n    if(s->compr == TIFF_DEFLATE || s->compr == TIFF_ADOBE_DEFLATE){\n        uint8_t *zbuf; unsigned long outlen;\n        int ret;\n        outlen = width * lines;\n        zbuf = av_malloc(outlen);\n        if (!zbuf)\n            return AVERROR(ENOMEM);\n        ret = tiff_uncompress(zbuf, &outlen, src, size);\n        if(ret != Z_OK){\n            av_log(s->avctx, AV_LOG_ERROR, \"Uncompressing failed (%lu of %lu) with error %d\\n\", outlen, (unsigned long)width * lines, ret);\n            av_free(zbuf);\n            return -1;\n        }\n        src = zbuf;\n        for(line = 0; line < lines; line++){\n            memcpy(dst, src, width);\n            dst += stride;\n            src += width;\n        }\n        av_free(zbuf);\n        return 0;\n    }\n#endif\n    if(s->compr == TIFF_LZW){\n        if(ff_lzw_decode_init(s->lzw, 8, src, size, FF_LZW_TIFF) < 0){\n            av_log(s->avctx, AV_LOG_ERROR, \"Error initializing LZW decoder\\n\");\n            return -1;\n        }\n    }\n    if(s->compr == TIFF_CCITT_RLE || s->compr == TIFF_G3 || s->compr == TIFF_G4){\n        int i, ret = 0;\n        uint8_t *src2 = av_malloc((unsigned)size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!src2) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\n            return AVERROR(ENOMEM);\n        }\n        if(s->fax_opts & 2){\n            av_log(s->avctx, AV_LOG_ERROR, \"Uncompressed fax mode is not supported (yet)\\n\");\n            av_free(src2);\n            return -1;\n        }\n        if(!s->fill_order){\n            memcpy(src2, src, size);\n        }else{\n            for(i = 0; i < size; i++)\n                src2[i] = av_reverse[src[i]];\n        }\n        memset(src2+size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n        switch(s->compr){\n        case TIFF_CCITT_RLE:\n        case TIFF_G3:\n        case TIFF_G4:\n            ret = ff_ccitt_unpack(s->avctx, src2, size, dst, lines, stride, s->compr, s->fax_opts);\n            break;\n        }\n        av_free(src2);\n        return ret;\n    }\n    for(line = 0; line < lines; line++){\n        if(src - ssrc > size){\n            av_log(s->avctx, AV_LOG_ERROR, \"Source data overread\\n\");\n            return -1;\n        }\n        switch(s->compr){\n        case TIFF_RAW:\n            if (ssrc + size - src < width)\n                return AVERROR_INVALIDDATA;\n            if (!s->fill_order) {\n                memcpy(dst, src, width);\n            } else {\n                int i;\n                for (i = 0; i < width; i++)\n                    dst[i] = av_reverse[src[i]];\n            }\n            src += width;\n            break;\n        case TIFF_PACKBITS:\n            for(pixels = 0; pixels < width;){\n                code = (int8_t)*src++;\n                if(code >= 0){\n                    code++;\n                    if(pixels + code > width){\n                        av_log(s->avctx, AV_LOG_ERROR, \"Copy went out of bounds\\n\");\n                        return -1;\n                    }\n                    memcpy(dst + pixels, src, code);\n                    src += code;\n                    pixels += code;\n                }else if(code != -128){ // -127..-1\n                    code = (-code) + 1;\n                    if(pixels + code > width){\n                        av_log(s->avctx, AV_LOG_ERROR, \"Run went out of bounds\\n\");\n                        return -1;\n                    }\n                    c = *src++;\n                    memset(dst + pixels, c, code);\n                    pixels += code;\n                }\n            }\n            break;\n        case TIFF_LZW:\n            pixels = ff_lzw_decode(s->lzw, dst, width);\n            if(pixels < width){\n                av_log(s->avctx, AV_LOG_ERROR, \"Decoded only %i bytes of %i\\n\", pixels, width);\n                return -1;\n            }\n            break;\n        }\n        dst += stride;\n    }\n    return 0;\n}", "target": 0}
{"idx": 5435, "func": "static int find_timestamp_in_playlist(HLSContext *c, struct playlist *pls,\n                                      int64_t timestamp, int *seq_no)\n{\n    int i;\n    int64_t pos = c->first_timestamp == AV_NOPTS_VALUE ?\n                  0 : c->first_timestamp;\n\n    if (timestamp < pos) {\n        *seq_no = pls->start_seq_no;\n        return 0;\n    }\n\n    for (i = 0; i < pls->n_segments; i++) {\n        int64_t diff = pos + pls->segments[i]->duration - timestamp;\n        if (diff > 0) {\n            *seq_no = pls->start_seq_no + i;\n            return 1;\n        }\n        pos += pls->segments[i]->duration;\n    }\n\n    *seq_no = pls->start_seq_no + pls->n_segments - 1;\n\n    return 0;\n}", "target": 1}
{"idx": 5436, "func": "static int test_mod()\n{\n    BIGNUM *a, *b, *c, *d, *e;\n    int i;\n\n    a = BN_new();\n    b = BN_new();\n    c = BN_new();\n    d = BN_new();\n    e = BN_new();\n\n    BN_bntest_rand(a, 1024, 0, 0);\n    for (i = 0; i < NUM0; i++) {\n        BN_bntest_rand(b, 450 + i * 10, 0, 0);\n        a->neg = rand_neg();\n        b->neg = rand_neg();\n        BN_mod(c, a, b, ctx);\n        BN_div(d, e, a, b, ctx);\n        BN_sub(e, e, c);\n        if (!BN_is_zero(e)) {\n            printf(\"Modulo test failed!\\n\");\n            return 0;\n        }\n    }\n    BN_free(a);\n    BN_free(b);\n    BN_free(c);\n    BN_free(d);\n    BN_free(e);\n    return 1;\n}", "target": 0}
{"idx": 5437, "func": "int ssl3_send_client_verify(SSL *s)\n\t{\n\tunsigned char *p,*d;\n\tunsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\n\tEVP_PKEY *pkey;\n\tEVP_PKEY_CTX *pctx=NULL;\n\tEVP_MD_CTX mctx;\n\tunsigned u=0;\n\tunsigned long n;\n\tint j;\n\n\tEVP_MD_CTX_init(&mctx);\n\n\tif (s->state == SSL3_ST_CW_CERT_VRFY_A)\n\t\t{\n\t\td=(unsigned char *)s->init_buf->data;\n\t\tp= &(d[4]);\n\t\tpkey=s->cert->key->privatekey;\n/* Create context from key and test if sha1 is allowed as digest */\n\t\tpctx = EVP_PKEY_CTX_new(pkey,NULL);\n\t\tEVP_PKEY_sign_init(pctx);\n\t\tif (EVP_PKEY_CTX_set_signature_md(pctx, EVP_sha1())>0)\n\t\t\t{\n\t\t\tif (s->version < TLS1_2_VERSION)\n\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\t\t\tNID_sha1,\n\t\t\t\t\t\t&(data[MD5_DIGEST_LENGTH]));\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tERR_clear_error();\n\t\t\t}\n\t\t/* For TLS v1.2 send signature algorithm and signature\n\t\t * using agreed digest and cached handshake records.\n\t\t */\n\t\tif (s->version >= TLS1_2_VERSION)\n\t\t\t{\n\t\t\tlong hdatalen = 0;\n\t\t\tvoid *hdata;\n\t\t\tconst EVP_MD *md = s->cert->key->digest;\n\t\t\thdatalen = BIO_get_mem_data(s->s3->handshake_buffer,\n\t\t\t\t\t\t\t\t&hdata);\n\t\t\tif (hdatalen <= 0 || !tls12_get_sigandhash(p, pkey, md))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,\n\t\t\t\t\t\tERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tp += 2;\n#ifdef SSL_DEBUG\n\t\t\tfprintf(stderr, \"Using TLS 1.2 with client alg %s\\n\",\n\t\t\t\t\t\t\tEVP_MD_name(md));\n#endif\n\t\t\tif (!EVP_SignInit_ex(&mctx, md, NULL)\n\t\t\t\t|| !EVP_SignUpdate(&mctx, hdata, hdatalen)\n\t\t\t\t|| !EVP_SignFinal(&mctx, p + 2, &u, pkey))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,\n\t\t\t\t\t\tERR_R_EVP_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts2n(u,p);\n\t\t\tn = u + 4;\n\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\telse\n#ifndef OPENSSL_NO_RSA\n\t\tif (pkey->type == EVP_PKEY_RSA)\n\t\t\t{\n\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\tNID_md5,\n\t\t\t \t&(data[0]));\n\t\t\tif (RSA_sign(NID_md5_sha1, data,\n\t\t\t\t\t MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,\n\t\t\t\t\t&(p[2]), &u, pkey->pkey.rsa) <= 0 )\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts2n(u,p);\n\t\t\tn=u+2;\n\t\t\t}\n\t\telse\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\t\tif (pkey->type == EVP_PKEY_DSA)\n\t\t\t{\n\t\t\tif (!DSA_sign(pkey->save_type,\n\t\t\t\t&(data[MD5_DIGEST_LENGTH]),\n\t\t\t\tSHA_DIGEST_LENGTH,&(p[2]),\n\t\t\t\t(unsigned int *)&j,pkey->pkey.dsa))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts2n(j,p);\n\t\t\tn=j+2;\n\t\t\t}\n\t\telse\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\t\tif (pkey->type == EVP_PKEY_EC)\n\t\t\t{\n\t\t\tif (!ECDSA_sign(pkey->save_type,\n\t\t\t\t&(data[MD5_DIGEST_LENGTH]),\n\t\t\t\tSHA_DIGEST_LENGTH,&(p[2]),\n\t\t\t\t(unsigned int *)&j,pkey->pkey.ec))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,\n\t\t\t\t    ERR_R_ECDSA_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts2n(j,p);\n\t\t\tn=j+2;\n\t\t\t}\n\t\telse\n#endif\n\t\tif (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) \n\t\t{\n\t\tunsigned char signbuf[64];\n\t\tint i;\n\t\tsize_t sigsize=64;\n\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\tNID_id_GostR3411_94,\n\t\t\tdata);\n\t\tif (EVP_PKEY_sign(pctx, signbuf, &sigsize, data, 32) <= 0) {\n\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,\n\t\t\tERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t}\n\t\tfor (i=63,j=0; i>=0; j++, i--) {\n\t\t\tp[2+j]=signbuf[i];\n\t\t}\t\n\t\ts2n(j,p);\n\t\tn=j+2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t}\n\t\t*(d++)=SSL3_MT_CERTIFICATE_VERIFY;\n\t\tl2n3(n,d);\n\n\t\ts->state=SSL3_ST_CW_CERT_VRFY_B;\n\t\ts->init_num=(int)n+4;\n\t\ts->init_off=0;\n\t\t}\n\tEVP_MD_CTX_cleanup(&mctx);\n\tEVP_PKEY_CTX_free(pctx);\n\treturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\nerr:\n\tEVP_MD_CTX_cleanup(&mctx);\n\tEVP_PKEY_CTX_free(pctx);\n\treturn(-1);\n\t}", "target": 0}
{"idx": 5438, "func": "static int noise(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const char *args,\n                     uint8_t **poutbuf, int *poutbuf_size,\n                     const uint8_t *buf, int buf_size, int keyframe){\n    unsigned int *state= bsfc->priv_data;\n    int amount= args ? atoi(args) : (*state % 10001+1);\n    int i;\n\n    if(amount <= 0)\n        return AVERROR(EINVAL);\n\n    *poutbuf= av_malloc(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!*poutbuf)\n        return AVERROR(ENOMEM);\n\n    memcpy(*poutbuf, buf, buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n    for(i=0; i<buf_size; i++){\n        (*state) += (*poutbuf)[i] + 1;\n        if(*state % amount == 0)\n            (*poutbuf)[i] = *state;\n    }\n    return 1;\n}", "target": 0}
{"idx": 5439, "func": "static int do_raw_keyop(int pkey_op, EVP_PKEY_CTX *ctx,\n                        const EVP_MD *md, EVP_PKEY *pkey, BIO *in,\n                        int filesize, unsigned char *sig, int siglen,\n                        unsigned char **out, size_t *poutlen)\n{\n    int rv = 0;\n    EVP_MD_CTX *mctx = NULL;\n    unsigned char tbuf[TBUF_MAXSIZE];\n    unsigned char *mbuf = NULL;\n    int buf_len = 0;\n\n    if ((mctx = EVP_MD_CTX_new()) == NULL) {\n        BIO_printf(bio_err, \"Error: out of memory\\n\");\n        return rv;\n    }\n    EVP_MD_CTX_set_pkey_ctx(mctx, ctx);\n\n    /* Some algorithms only support oneshot digests */\n    if (EVP_PKEY_id(pkey) == EVP_PKEY_ED25519\n            || EVP_PKEY_id(pkey) == EVP_PKEY_ED448) {\n        if (filesize < 0) {\n            BIO_printf(bio_err,\n                       \"Error: unable to determine file size for oneshot operation\\n\");\n            return rv;\n        }\n        mbuf = app_malloc(filesize, \"oneshot sign/verify buffer\");\n        switch(pkey_op) {\n        case EVP_PKEY_OP_VERIFY:\n            if (EVP_DigestVerifyInit(mctx, NULL, md, NULL, pkey) != 1)\n                goto end;\n            buf_len = BIO_read(in, mbuf, filesize);\n            if (buf_len != filesize) {\n                BIO_printf(bio_err, \"Error reading raw input data\\n\");\n                goto end;\n            }\n            rv = EVP_DigestVerify(mctx, sig, (size_t)siglen, mbuf, buf_len);\n            break;\n        case EVP_PKEY_OP_SIGN:\n            if (EVP_DigestSignInit(mctx, NULL, md, NULL, pkey) != 1)\n                goto end;\n            buf_len = BIO_read(in, mbuf, filesize);\n            if (buf_len != filesize) {\n                BIO_printf(bio_err, \"Error reading raw input data\\n\");\n                goto end;\n            }\n            rv = EVP_DigestSign(mctx, NULL, poutlen, mbuf, buf_len);\n            if (rv == 1 && out != NULL) {\n                *out = app_malloc(*poutlen, \"buffer output\");\n                rv = EVP_DigestSign(mctx, *out, poutlen, mbuf, buf_len);\n            }\n            break;\n        }\n        OPENSSL_free(mbuf);\n        goto end;\n    }\n\n    switch(pkey_op) {\n    case EVP_PKEY_OP_VERIFY:\n        if (EVP_DigestVerifyInit(mctx, NULL, md, NULL, pkey) != 1)\n            goto end;\n        for (;;) {\n            buf_len = BIO_read(in, tbuf, TBUF_MAXSIZE);\n            if (buf_len == 0)\n                break;\n            if (buf_len < 0) {\n                BIO_printf(bio_err, \"Error reading raw input data\\n\");\n                goto end;\n            }\n            rv = EVP_DigestVerifyUpdate(mctx, tbuf, (size_t)buf_len);\n            if (rv != 1) {\n                BIO_printf(bio_err, \"Error verifying raw input data\\n\");\n                goto end;\n            }\n        }\n        rv = EVP_DigestVerifyFinal(mctx, sig, (size_t)siglen);\n        break;\n    case EVP_PKEY_OP_SIGN:\n        if (EVP_DigestSignInit(mctx, NULL, md, NULL, pkey) != 1)\n            goto end;\n        for (;;) {\n            buf_len = BIO_read(in, tbuf, TBUF_MAXSIZE);\n            if (buf_len == 0)\n                break;\n            if (buf_len < 0) {\n                BIO_printf(bio_err, \"Error reading raw input data\\n\");\n                goto end;\n            }\n            rv = EVP_DigestSignUpdate(mctx, tbuf, (size_t)buf_len);\n            if (rv != 1) {\n                BIO_printf(bio_err, \"Error signing raw input data\\n\");\n                goto end;\n            }\n        }\n        rv = EVP_DigestSignFinal(mctx, NULL, poutlen);\n        if (rv == 1 && out != NULL) {\n            *out = app_malloc(*poutlen, \"buffer output\");\n            rv = EVP_DigestSignFinal(mctx, *out, poutlen);\n        }\n        break;\n    }\n\n end:\n    EVP_MD_CTX_free(mctx);\n    return rv;\n}", "target": 0}
{"idx": 5440, "func": "static int h264_mp4toannexb_filter(AVBitStreamFilterContext *bsfc,\n                                   AVCodecContext *avctx, const char *args,\n                                   uint8_t  **poutbuf, int *poutbuf_size,\n                                   const uint8_t *buf, int      buf_size,\n                                   int keyframe) {\n    H264BSFContext *ctx = bsfc->priv_data;\n    uint8_t unit_type;\n    uint32_t nal_size, cumul_size = 0;\n\n    /* nothing to filter */\n    if (!avctx->extradata || avctx->extradata_size < 6) {\n        *poutbuf = (uint8_t*) buf;\n        *poutbuf_size = buf_size;\n        return 0;\n    }\n\n    /* retrieve sps and pps NAL units from extradata */\n    if (!ctx->sps_pps_data) {\n        uint16_t unit_size;\n        uint32_t total_size = 0;\n        uint8_t *out = NULL, unit_nb, sps_done = 0;\n        const uint8_t *extradata = avctx->extradata+4;\n        static const uint8_t nalu_header[4] = {0, 0, 0, 1};\n\n        /* retrieve length coded size */\n        ctx->length_size = (*extradata++ & 0x3) + 1;\n        if (ctx->length_size == 3)\n            return AVERROR(EINVAL);\n\n        /* retrieve sps and pps unit(s) */\n        unit_nb = *extradata++ & 0x1f; /* number of sps unit(s) */\n        if (!unit_nb) {\n            unit_nb = *extradata++; /* number of pps unit(s) */\n            sps_done++;\n        }\n        while (unit_nb--) {\n            unit_size = AV_RB16(extradata);\n            total_size += unit_size+4;\n            if (extradata+2+unit_size > avctx->extradata+avctx->extradata_size) {\n                av_free(out);\n                return AVERROR(EINVAL);\n            }\n            out = av_realloc(out, total_size);\n            if (!out)\n                return AVERROR(ENOMEM);\n            memcpy(out+total_size-unit_size-4, nalu_header, 4);\n            memcpy(out+total_size-unit_size,   extradata+2, unit_size);\n            extradata += 2+unit_size;\n\n            if (!unit_nb && !sps_done++)\n                unit_nb = *extradata++; /* number of pps unit(s) */\n        }\n\n        ctx->sps_pps_data = out;\n        ctx->size = total_size;\n        ctx->first_idr = 1;\n    }\n\n    *poutbuf_size = 0;\n    *poutbuf = NULL;\n    do {\n        if (ctx->length_size == 1)\n            nal_size = buf[0];\n        else if (ctx->length_size == 2)\n            nal_size = AV_RB16(buf);\n        else\n            nal_size = AV_RB32(buf);\n\n        buf += ctx->length_size;\n        unit_type = *buf & 0x1f;\n\n        /* prepend only to the first type 5 NAL unit of an IDR picture */\n        if (ctx->first_idr && unit_type == 5) {\n            alloc_and_copy(poutbuf, poutbuf_size,\n                           ctx->sps_pps_data, ctx->size,\n                           buf, nal_size);\n            ctx->first_idr = 0;\n        }\n        else {\n            alloc_and_copy(poutbuf, poutbuf_size,\n                           NULL, 0,\n                           buf, nal_size);\n            if (!ctx->first_idr && unit_type == 1)\n                ctx->first_idr = 1;\n        }\n\n        buf += nal_size;\n        cumul_size += nal_size + ctx->length_size;\n    } while (cumul_size < buf_size);\n\n    return 1;\n}", "target": 1}
{"idx": 5441, "func": "static av_always_inline\nint vp78_decode_mb_row_sliced(AVCodecContext *avctx, void *tdata, int jobnr,\n                              int threadnr, int is_vp7)\n{\n    VP8Context *s = avctx->priv_data;\n    VP8ThreadData *td = &s->thread_data[jobnr];\n    VP8ThreadData *next_td = NULL, *prev_td = NULL;\n    VP8Frame *curframe = s->curframe;\n    int mb_y, num_jobs = s->num_jobs;\n\n    td->thread_nr = threadnr;\n    for (mb_y = jobnr; mb_y < s->mb_height; mb_y += num_jobs) {\n        if (mb_y >= s->mb_height)\n            break;\n        td->thread_mb_pos = mb_y << 16;\n        vp8_decode_mb_row_no_filter(avctx, tdata, jobnr, threadnr, is_vp7);\n        if (s->deblock_filter)\n            vp8_filter_mb_row(avctx, tdata, jobnr, threadnr, is_vp7);\n        update_pos(td, mb_y, INT_MAX & 0xFFFF);\n\n        s->mv_min.y -= 64;\n        s->mv_max.y -= 64;\n\n        if (avctx->active_thread_type == FF_THREAD_FRAME)\n            ff_thread_report_progress(&curframe->tf, mb_y, 0);\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5442, "func": "static av_cold int raw_init_decoder(AVCodecContext *avctx)\n{\n    RawVideoContext *context = avctx->priv_data;\n    const AVPixFmtDescriptor *desc;\n\n    if (   avctx->codec_tag == MKTAG('r','a','w',' ')\n        || avctx->codec_tag == MKTAG('N','O','1','6'))\n        avctx->pix_fmt = avpriv_find_pix_fmt(pix_fmt_bps_mov,\n                                      avctx->bits_per_coded_sample);\n    else if (avctx->codec_tag == MKTAG('W', 'R', 'A', 'W'))\n        avctx->pix_fmt = avpriv_find_pix_fmt(pix_fmt_bps_avi,\n                                      avctx->bits_per_coded_sample);\n    else if (avctx->codec_tag)\n        avctx->pix_fmt = avpriv_find_pix_fmt(ff_raw_pix_fmt_tags, avctx->codec_tag);\n    else if (avctx->pix_fmt == AV_PIX_FMT_NONE && avctx->bits_per_coded_sample)\n        avctx->pix_fmt = avpriv_find_pix_fmt(pix_fmt_bps_avi,\n                                      avctx->bits_per_coded_sample);\n\n    desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n    if (!desc) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid pixel format.\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if (desc->flags & (PIX_FMT_PAL | PIX_FMT_PSEUDOPAL)) {\n        context->palette = av_buffer_alloc(AVPALETTE_SIZE);\n        if (!context->palette)\n            return AVERROR(ENOMEM);\n        if (desc->flags & PIX_FMT_PSEUDOPAL)\n            avpriv_set_systematic_pal2((uint32_t*)context->palette->data, avctx->pix_fmt);\n        else\n            memset(context->palette->data, 0, AVPALETTE_SIZE);\n    }\n\n    context->frame_size = avpicture_get_size(avctx->pix_fmt, avctx->width,\n                                             avctx->height);\n    if ((avctx->bits_per_coded_sample == 4 || avctx->bits_per_coded_sample == 2) &&\n        avctx->pix_fmt == AV_PIX_FMT_PAL8 &&\n       (!avctx->codec_tag || avctx->codec_tag == MKTAG('r','a','w',' ')))\n        context->is_2_4_bpp = 1;\n\n    if ((avctx->extradata_size >= 9 &&\n         !memcmp(avctx->extradata + avctx->extradata_size - 9, \"BottomUp\", 9)) ||\n        avctx->codec_tag == MKTAG('c','y','u','v') ||\n        avctx->codec_tag == MKTAG(3, 0, 0, 0) ||\n        avctx->codec_tag == MKTAG('W','R','A','W'))\n        context->flip = 1;\n\n    if (avctx->field_order > AV_FIELD_PROGRESSIVE) { /*we have interlaced material flagged in container */\n        avctx->coded_frame->interlaced_frame = 1;\n        if (avctx->field_order == AV_FIELD_TT  || avctx->field_order == AV_FIELD_TB)\n            avctx->coded_frame->top_field_first = 1;\n    }\n\n    if (avctx->codec_tag == AV_RL32(\"yuv2\") &&\n        avctx->pix_fmt   == AV_PIX_FMT_YUYV422)\n        context->is_yuv2 = 1;\n\n    return 0;\n}", "target": 0}
{"idx": 5443, "func": "static int add_DN_object(X509_NAME *n, char *text, char *def, char *value,\n\t     int nid, int n_min, int n_max, unsigned long chtype, int mval)\n\t{\n\tint i,ret=0;\n\tMS_STATIC char buf[1024];\nstart:\n\tif (!batch) BIO_printf(bio_err,\"%s [%s]:\",text,def);\n\t(void)BIO_flush(bio_err);\n\tif(value != NULL)\n\t\t{\n\t\tOPENSSL_assert(strlen(value) < sizeof buf-2);\n\t\tstrcpy(buf,value);\n\t\tstrcat(buf,\"\\n\");\n\t\tBIO_printf(bio_err,\"%s\\n\",value);\n\t\t}\n\telse\n\t\t{\n\t\tbuf[0]='\\0';\n\t\tif (!batch)\n\t\t\t{\n\t\t\tfgets(buf,sizeof buf,stdin);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tbuf[0] = '\\n';\n\t\t\tbuf[1] = '\\0';\n\t\t\t}\n\t\t}\n\n\tif (buf[0] == '\\0') return(0);\n\telse if (buf[0] == '\\n')\n\t\t{\n\t\tif ((def == NULL) || (def[0] == '\\0'))\n\t\t\treturn(1);\n\t\tstrcpy(buf,def);\n\t\tstrcat(buf,\"\\n\");\n\t\t}\n\telse if ((buf[0] == '.') && (buf[1] == '\\n')) return(1);\n\n\ti=strlen(buf);\n\tif (buf[i-1] != '\\n')\n\t\t{\n\t\tBIO_printf(bio_err,\"weird input :-(\\n\");\n\t\treturn(0);\n\t\t}\n\tbuf[--i]='\\0';\n#ifdef CHARSET_EBCDIC\n\tebcdic2ascii(buf, buf, i);\n#endif\n\tif(!req_check_len(i, n_min, n_max)) goto start;\n\tif (!X509_NAME_add_entry_by_NID(n,nid, chtype,\n\t\t\t\t(unsigned char *) buf, -1,-1,mval)) goto err;\n\tret=1;\nerr:\n\treturn(ret);\n\t}", "target": 1}
{"idx": 5444, "func": "CACHE_DECLARE(apr_int64_t) ap_cache_current_age(cache_info *info,\n                                                const apr_time_t age_value,\n                                                apr_time_t now)\n{\n    apr_time_t apparent_age, corrected_received_age, response_delay,\n               corrected_initial_age, resident_time, current_age,\n               age_value_usec;\n\n    age_value_usec = apr_time_from_sec(age_value);\n\n    /* Perform an HTTP/1.1 age calculation. (RFC2616 13.2.3) */\n\n    apparent_age = MAX(0, info->response_time - info->date);\n    corrected_received_age = MAX(apparent_age, age_value_usec);\n    response_delay = info->response_time - info->request_time;\n    corrected_initial_age = corrected_received_age + response_delay;\n    resident_time = now - info->response_time;\n    current_age = corrected_initial_age + resident_time;\n\n    if (current_age < 0) {\n        current_age = 0;\n    }\n\n    return apr_time_sec(current_age);\n}", "target": 1}
{"idx": 5445, "func": "static av_always_inline int get_dst_color_err(PaletteUseContext *s,\n                                              uint32_t c, int *er, int *eg, int *eb,\n                                              const enum color_search_method search_method)\n{\n    const uint8_t a = c >> 24 & 0xff;\n    const uint8_t r = c >> 16 & 0xff;\n    const uint8_t g = c >>  8 & 0xff;\n    const uint8_t b = c       & 0xff;\n    uint32_t dstc;\n    const int dstx = color_get(s, c, a, r, g, b, search_method);\n    if (dstx < 0)\n        return dstx;\n    dstc = s->palette[dstx];\n    *er = r - (dstc >> 16 & 0xff);\n    *eg = g - (dstc >>  8 & 0xff);\n    *eb = b - (dstc       & 0xff);\n    return dstx;\n}", "target": 0}
{"idx": 5446, "func": "static int decode_gost_algor_params(EVP_PKEY *pkey, X509_ALGOR *palg)\n{\n    ASN1_OBJECT *palg_obj = NULL;\n    int ptype = V_ASN1_UNDEF;\n    int pkey_nid = NID_undef, param_nid = NID_undef;\n    void *_pval;\n    ASN1_STRING *pval = NULL;\n    const unsigned char *p;\n    GOST_KEY_PARAMS *gkp = NULL;\n\n    X509_ALGOR_get0(&palg_obj, &ptype, &_pval, palg);\n    pval = _pval;\n    if (ptype != V_ASN1_SEQUENCE) {\n        GOSTerr(GOST_F_DECODE_GOST_ALGOR_PARAMS,\n                GOST_R_BAD_KEY_PARAMETERS_FORMAT);\n        return 0;\n    }\n    p = pval->data;\n    pkey_nid = OBJ_obj2nid(palg_obj);\n\n    gkp = d2i_GOST_KEY_PARAMS(NULL, &p, pval->length);\n    if (!gkp) {\n        GOSTerr(GOST_F_DECODE_GOST_ALGOR_PARAMS,\n                GOST_R_BAD_PKEY_PARAMETERS_FORMAT);\n        return 0;\n    }\n    param_nid = OBJ_obj2nid(gkp->key_params);\n    GOST_KEY_PARAMS_free(gkp);\n    if (!EVP_PKEY_set_type(pkey, pkey_nid)) {\n        GOSTerr(GOST_F_DECODE_GOST_ALGOR_PARAMS, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    switch (pkey_nid) {\n    case NID_id_GostR3410_2001:\n        {\n            EC_KEY *ec = EVP_PKEY_get0(pkey);\n            if (!ec) {\n                ec = EC_KEY_new();\n                if (!EVP_PKEY_assign(pkey, pkey_nid, ec))\n                    return 0;\n            }\n            if (!fill_GOST2001_params(ec, param_nid))\n                return 0;\n        }\n    }\n\n    return 1;\n}", "target": 0}
{"idx": 5447, "func": "int test_gf2m_mod_mul(BIO *bp,BN_CTX *ctx)\n\t{\n\tBIGNUM *a,*b[2],*c,*d,*e,*f,*g,*h;\n\tint i, j, ret = 0;\n\tint p0[] = {163,7,6,3,0,-1};\n\tint p1[] = {193,15,0,-1};\n\n\ta=BN_new();\n\tb[0]=BN_new();\n\tb[1]=BN_new();\n\tc=BN_new();\n\td=BN_new();\n\te=BN_new();\n\tf=BN_new();\n\tg=BN_new();\n\th=BN_new();\n\n\tBN_GF2m_arr2poly(p0, b[0]);\n\tBN_GF2m_arr2poly(p1, b[1]);\n\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(a, 1024, 0, 0);\n\t\tBN_bntest_rand(c, 1024, 0, 0);\n\t\tBN_bntest_rand(d, 1024, 0, 0);\n\t\tfor (j=0; j < 2; j++)\n\t\t\t{\n\t\t\tBN_GF2m_mod_mul(e, a, c, b[j], ctx);\n#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */\n\t\t\tif (bp != NULL)\n\t\t\t\t{\n\t\t\t\tif (!results)\n\t\t\t\t\t{\n\t\t\t\t\tBN_print(bp,a);\n\t\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\t\tBN_print(bp,c);\n\t\t\t\t\tBIO_puts(bp,\" % \");\n\t\t\t\t\tBN_print(bp,b[j]);\n\t\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t\tBN_print(bp,e);\n\t\t\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\tBN_GF2m_add(f, a, d);\n\t\t\tBN_GF2m_mod_mul(g, f, c, b[j], ctx);\n\t\t\tBN_GF2m_mod_mul(h, d, c, b[j], ctx);\n\t\t\tBN_GF2m_add(f, e, g);\n\t\t\tBN_GF2m_add(f, f, h);\n\t\t\t/* Test that (a+d)*c = a*c + d*c. */\n\t\t\tif(!BN_is_zero(f))\n\t\t\t\t{\n\t\t\t\tfprintf(stderr,\"GF(2^m) modular multiplication test failed!\\n\");\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tret = 1;\n  err:\n\tBN_free(a);\n\tBN_free(b[0]);\n\tBN_free(b[1]);\n\tBN_free(c);\n\tBN_free(d);\n\tBN_free(e);\n\tBN_free(f);\n\tBN_free(g);\n\tBN_free(h);\n\treturn ret;\n\t}", "target": 0}
{"idx": 5448, "func": "static void vp56_mc(VP56Context *s, int b, int plane, uint8_t *src,\n                    int stride, int x, int y)\n{\n    uint8_t *dst = s->frames[VP56_FRAME_CURRENT]->data[plane] + s->block_offset[b];\n    uint8_t *src_block;\n    int src_offset;\n    int overlap_offset = 0;\n    int mask = s->vp56_coord_div[b] - 1;\n    int deblock_filtering = s->deblock_filtering;\n    int dx;\n    int dy;\n\n    if (s->avctx->skip_loop_filter >= AVDISCARD_ALL ||\n        (s->avctx->skip_loop_filter >= AVDISCARD_NONKEY\n         && !s->frames[VP56_FRAME_CURRENT]->key_frame))\n        deblock_filtering = 0;\n\n    dx = s->mv[b].x / s->vp56_coord_div[b];\n    dy = s->mv[b].y / s->vp56_coord_div[b];\n\n    if (b >= 4) {\n        x /= 2;\n        y /= 2;\n    }\n    x += dx - 2;\n    y += dy - 2;\n\n    if (x<0 || x+12>=s->plane_width[plane] ||\n        y<0 || y+12>=s->plane_height[plane]) {\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer,\n                            src + s->block_offset[b] + (dy-2)*stride + (dx-2),\n                            stride, 12, 12, x, y,\n                            s->plane_width[plane],\n                            s->plane_height[plane]);\n        src_block = s->edge_emu_buffer;\n        src_offset = 2 + 2*stride;\n    } else if (deblock_filtering) {\n        /* only need a 12x12 block, but there is no such dsp function, */\n        /* so copy a 16x12 block */\n        s->hdsp.put_pixels_tab[0][0](s->edge_emu_buffer,\n                                     src + s->block_offset[b] + (dy-2)*stride + (dx-2),\n                                     stride, 12);\n        src_block = s->edge_emu_buffer;\n        src_offset = 2 + 2*stride;\n    } else {\n        src_block = src;\n        src_offset = s->block_offset[b] + dy*stride + dx;\n    }\n\n    if (deblock_filtering)\n        vp56_deblock_filter(s, src_block, stride, dx&7, dy&7);\n\n    if (s->mv[b].x & mask)\n        overlap_offset += (s->mv[b].x > 0) ? 1 : -1;\n    if (s->mv[b].y & mask)\n        overlap_offset += (s->mv[b].y > 0) ? stride : -stride;\n\n    if (overlap_offset) {\n        if (s->filter)\n            s->filter(s, dst, src_block, src_offset, src_offset+overlap_offset,\n                      stride, s->mv[b], mask, s->filter_selection, b<4);\n        else\n            s->vp3dsp.put_no_rnd_pixels_l2(dst, src_block+src_offset,\n                                           src_block+src_offset+overlap_offset,\n                                           stride, 8);\n    } else {\n        s->hdsp.put_pixels_tab[1][0](dst, src_block+src_offset, stride, 8);\n    }\n}", "target": 1}
{"idx": 5449, "func": "static int decode_frame_apng(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PNGDecContext *const s = avctx->priv_data;\n    int ret;\n    AVFrame *p;\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    FFSWAP(ThreadFrame, s->picture, s->last_picture);\n    p = s->picture.f;\n\n    if (!(s->state & PNG_IHDR)) {\n        if (!avctx->extradata_size)\n            return AVERROR_INVALIDDATA;\n\n        /* only init fields, there is no zlib use in extradata */\n        s->zstream.zalloc = ff_png_zalloc;\n        s->zstream.zfree  = ff_png_zfree;\n\n        bytestream2_init(&s->gb, avctx->extradata, avctx->extradata_size);\n        if ((ret = decode_frame_common(avctx, s, p, avpkt)) < 0)\n            goto end;\n    }\n\n    /* reset state for a new frame */\n    if ((ret = inflateInit(&s->zstream)) != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"inflateInit returned error %d\\n\", ret);\n        ret = AVERROR_EXTERNAL;\n        goto end;\n    }\n    s->y = 0;\n    s->state &= ~(PNG_IDAT | PNG_ALLIMAGE);\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n    if ((ret = decode_frame_common(avctx, s, p, avpkt)) < 0)\n        goto end;\n\n    if (!(s->state & PNG_ALLIMAGE))\n        av_log(avctx, AV_LOG_WARNING, \"Frame did not contain a complete image\\n\");\n    if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n    if ((ret = av_frame_ref(data, s->picture.f)) < 0)\n        goto end;\n\n    *got_frame = 1;\n    ret = bytestream2_tell(&s->gb);\n\nend:\n    inflateEnd(&s->zstream);\n    return ret;\n}", "target": 0}
{"idx": 5450, "func": "static int avi_read_seek(AVFormatContext *s, int stream_index,\n                         int64_t timestamp, int flags)\n{\n    AVIContext *avi = s->priv_data;\n    AVStream *st;\n    int i, index;\n    int64_t pos, pos_min;\n    AVIStream *ast;\n\n    /* Does not matter which stream is requested dv in avi has the\n     * stream information in the first video stream.\n     */\n    if (avi->dv_demux)\n        stream_index = 0;\n\n    if (!avi->index_loaded) {\n        /* we only load the index on demand */\n        avi_load_index(s);\n        avi->index_loaded |= 1;\n    }\n    av_assert0(stream_index >= 0);\n\n    st    = s->streams[stream_index];\n    ast   = st->priv_data;\n    index = av_index_search_timestamp(st,\n                                      timestamp * FFMAX(ast->sample_size, 1),\n                                      flags);\n    if (index < 0) {\n        if (st->nb_index_entries > 0)\n            av_log(s, AV_LOG_DEBUG, \"Failed to find timestamp %\"PRId64 \" in index %\"PRId64 \" .. %\"PRId64 \"\\n\",\n                   timestamp * FFMAX(ast->sample_size, 1),\n                   st->index_entries[0].timestamp,\n                   st->index_entries[st->nb_index_entries - 1].timestamp);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* find the position */\n    pos       = st->index_entries[index].pos;\n    timestamp = st->index_entries[index].timestamp / FFMAX(ast->sample_size, 1);\n\n    av_log(s, AV_LOG_TRACE, \"XX %\"PRId64\" %d %\"PRId64\"\\n\",\n            timestamp, index, st->index_entries[index].timestamp);\n\n    if (CONFIG_DV_DEMUXER && avi->dv_demux) {\n        /* One and only one real stream for DV in AVI, and it has video  */\n        /* offsets. Calling with other stream indexes should have failed */\n        /* the av_index_search_timestamp call above.                     */\n\n        if (avio_seek(s->pb, pos, SEEK_SET) < 0)\n            return -1;\n\n        /* Feed the DV video stream version of the timestamp to the */\n        /* DV demux so it can synthesize correct timestamps.        */\n        ff_dv_offset_reset(avi->dv_demux, timestamp);\n\n        avi->stream_index = -1;\n        return 0;\n    }\n\n    pos_min = pos;\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st2   = s->streams[i];\n        AVIStream *ast2 = st2->priv_data;\n\n        ast2->packet_size =\n        ast2->remaining   = 0;\n\n        if (ast2->sub_ctx) {\n            seek_subtitle(st, st2, timestamp);\n            continue;\n        }\n\n        if (st2->nb_index_entries <= 0)\n            continue;\n\n//        av_assert1(st2->codecpar->block_align);\n        index = av_index_search_timestamp(st2,\n                                          av_rescale_q(timestamp,\n                                                       st->time_base,\n                                                       st2->time_base) *\n                                          FFMAX(ast2->sample_size, 1),\n                                          flags |\n                                          AVSEEK_FLAG_BACKWARD |\n                                          (st2->codecpar->codec_type != AVMEDIA_TYPE_VIDEO ? AVSEEK_FLAG_ANY : 0));\n        if (index < 0)\n            index = 0;\n        ast2->seek_pos = st2->index_entries[index].pos;\n        pos_min = FFMIN(pos_min,ast2->seek_pos);\n    }\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st2 = s->streams[i];\n        AVIStream *ast2 = st2->priv_data;\n\n        if (ast2->sub_ctx || st2->nb_index_entries <= 0)\n            continue;\n\n        index = av_index_search_timestamp(\n                st2,\n                av_rescale_q(timestamp, st->time_base, st2->time_base) * FFMAX(ast2->sample_size, 1),\n                flags | AVSEEK_FLAG_BACKWARD | (st2->codecpar->codec_type != AVMEDIA_TYPE_VIDEO ? AVSEEK_FLAG_ANY : 0));\n        if (index < 0)\n            index = 0;\n        while (!avi->non_interleaved && index>0 && st2->index_entries[index-1].pos >= pos_min)\n            index--;\n        ast2->frame_offset = st2->index_entries[index].timestamp;\n    }\n\n    /* do the seek */\n    if (avio_seek(s->pb, pos_min, SEEK_SET) < 0) {\n        av_log(s, AV_LOG_ERROR, \"Seek failed\\n\");\n        return -1;\n    }\n    avi->stream_index = -1;\n    avi->dts_max      = INT_MIN;\n    return 0;\n}", "target": 0}
{"idx": 5451, "func": "static void dvbsub_parse_clut_segment(AVCodecContext *avctx,\n                                        const uint8_t *buf, int buf_size)\n{\n    DVBSubContext *ctx = avctx->priv_data;\n\n    const uint8_t *buf_end = buf + buf_size;\n    int i, clut_id;\n    DVBSubCLUT *clut;\n    int entry_id, depth , full_range;\n    int y, cr, cb, alpha;\n    int r, g, b, r_add, g_add, b_add;\n\n    av_dlog(avctx, \"DVB clut packet:\\n\");\n\n    for (i=0; i < buf_size; i++) {\n        av_dlog(avctx, \"%02x \", buf[i]);\n        if (i % 16 == 15)\n            av_dlog(avctx, \"\\n\");\n    }\n\n    if (i % 16)\n        av_dlog(avctx, \"\\n\");\n\n    clut_id = *buf++;\n    buf += 1;\n\n    clut = get_clut(ctx, clut_id);\n\n    if (!clut) {\n        clut = av_malloc(sizeof(DVBSubCLUT));\n\n        memcpy(clut, &default_clut, sizeof(DVBSubCLUT));\n\n        clut->id = clut_id;\n\n        clut->next = ctx->clut_list;\n        ctx->clut_list = clut;\n    }\n\n    while (buf + 4 < buf_end) {\n        entry_id = *buf++;\n\n        depth = (*buf) & 0xe0;\n\n        if (depth == 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid clut depth 0x%x!\\n\", *buf);\n            return;\n        }\n\n        full_range = (*buf++) & 1;\n\n        if (full_range) {\n            y = *buf++;\n            cr = *buf++;\n            cb = *buf++;\n            alpha = *buf++;\n        } else {\n            y = buf[0] & 0xfc;\n            cr = (((buf[0] & 3) << 2) | ((buf[1] >> 6) & 3)) << 4;\n            cb = (buf[1] << 2) & 0xf0;\n            alpha = (buf[1] << 6) & 0xc0;\n\n            buf += 2;\n        }\n\n        if (y == 0)\n            alpha = 0xff;\n\n        YUV_TO_RGB1_CCIR(cb, cr);\n        YUV_TO_RGB2_CCIR(r, g, b, y);\n\n        av_dlog(avctx, \"clut %d := (%d,%d,%d,%d)\\n\", entry_id, r, g, b, alpha);\n\n        if (depth & 0x80)\n            clut->clut4[entry_id] = RGBA(r,g,b,255 - alpha);\n        if (depth & 0x40)\n            clut->clut16[entry_id] = RGBA(r,g,b,255 - alpha);\n        if (depth & 0x20)\n            clut->clut256[entry_id] = RGBA(r,g,b,255 - alpha);\n    }\n}", "target": 1}
{"idx": 5452, "func": "void CRYPTO_free(void *str, const char *file, int line)\n{\n    if (free_impl != NULL && free_impl != &CRYPTO_free) {\n        free_impl(str, file, line);\n        return;\n    }\n\n#ifndef OPENSSL_NO_CRYPTO_MDEBUG\n    if (call_malloc_debug) {\n        CRYPTO_mem_debug_free(str, 0, file, line);\n        free(str);\n        CRYPTO_mem_debug_free(str, 1, file, line);\n    } else {\n        free(str);\n    }\n#else\n    free(str);\n#endif\n}", "target": 0}
{"idx": 5453, "func": "static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  uint32 j;\n  int32  bytes_read = 0;\n  uint16 bps = 0, planar;\n  uint32 nstrips;\n  uint32 strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n\n  if (obuf == NULL)\n    {\n    TIFFError(\"readSeparateStripsIntoBuffer\",\"Invalid buffer argument\");\n    return (0);\n    }\n\n  memset (srcbuffs, '\\0', sizeof(srcbuffs));\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n  if (rps > length)\n    rps = length;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if (bytes_per_pixel < (bytes_per_sample + 1))\n    shift_width = bytes_per_pixel;\n  else\n    shift_width = bytes_per_sample + 1;\n\n  src_rowsize = ((bps * width) + 7) / 8;\n  dst_rowsize = ((bps * width * spp) + 7) / 8;\n  dst = obuf;\n\n  if ((dump->infile != NULL) && (dump->level == 3))\n    {\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Image width %d, length %d, Scanline size, %4d bytes\",\n                width, length,  scanlinesize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d, Shift width %d\",\n\t\tbps, spp, shift_width);\n    }\n\n  /* Libtiff seems to assume/require that data for separate planes are \n   * written one complete plane after another and not interleaved in any way.\n   * Multiple scanlines and possibly strips of the same plane must be \n   * written before data for any other plane.\n   */\n  nstrips = TIFFNumberOfStrips(in);\n  strips_per_sample = nstrips /spp;\n\n  /* Add 3 padding bytes for combineSeparateSamples32bits */\n  if( (size_t) stripsize > 0xFFFFFFFFU - 3U )\n  {\n      TIFFError(\"readSeparateStripsIntoBuffer\", \"Integer overflow when calculating buffer size.\");\n      exit(-1);\n  }\n\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    srcbuffs[s] = NULL;\n    buff = limitMalloc(stripsize + 3);\n    if (!buff)\n      {\n      TIFFError (\"readSeparateStripsIntoBuffer\", \n                 \"Unable to allocate strip read buffer for sample %d\", s);\n      for (i = 0; i < s; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    buff[stripsize] = 0;\n    buff[stripsize+1] = 0;\n    buff[stripsize+2] = 0;\n    srcbuffs[s] = buff;\n    }\n\n  rows_processed = 0;\n  for (j = 0; (j < strips_per_sample) && (result == 1); j++)\n    {\n    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n      {\n      buff = srcbuffs[s];\n      strip = (s * strips_per_sample) + j; \n      bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);\n      rows_this_strip = bytes_read / src_rowsize;\n      if (bytes_read < 0 && !ignore)\n        {\n        TIFFError(TIFFFileName(in),\n\t          \"Error, can't read strip %lu for sample %d\",\n         \t   (unsigned long) strip, s + 1);\n        result = 0;\n        break;\n        }\n#ifdef DEVELMODE\n      TIFFError(\"\", \"Strip %2d, read %5d bytes for %4d scanlines, shift width %d\", \n\t\tstrip, bytes_read, rows_this_strip, shift_width);\n#endif\n      }\n\n    if (rps > rows_this_strip)\n      rps = rows_this_strip;\n    dst = obuf + (dst_rowsize * rows_processed);\n    if ((bps % 8) == 0)\n      {\n      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,\n                                       spp, bps, dump->infile, \n                                       dump->format, dump->level))\n        {\n        result = 0;\n        break;\n\t}\n      }\n    else\n      {\n      switch (shift_width)\n        {\n        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,\n                                                 spp, bps, dump->infile,\n                                                 dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n      \t          }\n\t        break;\n        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n       \t          }\n                break;\n        case 4: \n        case 5:\n        case 6:\n        case 7:\n        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        default: TIFFError (\"readSeparateStripsIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  result = 0;\n                  break;\n        }\n      }\n \n    if ((rows_processed + rps) > length)\n      {\n      rows_processed = length;\n      rps = length - rows_processed;\n      }\n    else\n      rows_processed += rps;\n    }\n\n  /* free any buffers allocated for each plane or scanline and \n   * any temporary buffers \n   */\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    buff = srcbuffs[s];\n    if (buff != NULL)\n      _TIFFfree(buff);\n    }\n\n  return (result);\n  }", "target": 0}
{"idx": 5454, "func": "static int execute_test_large_message(const SSL_METHOD *smeth,\n                                      const SSL_METHOD *cmeth)\n{\n    SSL_CTX *cctx = NULL, *sctx = NULL;\n    SSL *clientssl = NULL, *serverssl = NULL;\n    int testresult = 0;\n    int i;\n    BIO *certbio = BIO_new_file(cert, \"r\");\n    X509 *chaincert = NULL;\n    int certlen;\n\n    if (certbio == NULL) {\n        printf(\"Can't load the certficate file\\n\");\n        goto end;\n    }\n    chaincert = PEM_read_bio_X509(certbio, NULL, NULL, NULL);\n    BIO_free(certbio);\n    certbio = NULL;\n    if (chaincert == NULL) {\n        printf(\"Unable to load certificate for chain\\n\");\n        goto end;\n    }\n\n    if (!create_ssl_ctx_pair(smeth, cmeth, &sctx,\n                             &cctx, cert, privkey)) {\n        printf(\"Unable to create SSL_CTX pair\\n\");\n        goto end;\n    }\n\n    /*\n     * We assume the supplied certificate is big enough so that if we add\n     * NUM_EXTRA_CERTS it will make the overall message large enough. The\n     * default buffer size is requested to be 16k, but due to the way BUF_MEM\n     * works, it ends up allocing a little over 21k (16 * 4/3). So, in this test\n     * we need to have a message larger than that.\n     */\n    certlen = i2d_X509(chaincert, NULL);\n    OPENSSL_assert((certlen * NUM_EXTRA_CERTS)\n                   > ((SSL3_RT_MAX_PLAIN_LENGTH * 4) / 3));\n    for (i = 0; i < NUM_EXTRA_CERTS; i++) {\n        if (!X509_up_ref(chaincert)) {\n            printf(\"Unable to up ref cert\\n\");\n            goto end;\n        }\n        if (!SSL_CTX_add_extra_chain_cert(sctx, chaincert)) {\n            printf(\"Unable to add extra chain cert %d\\n\", i);\n            X509_free(chaincert);\n            goto end;\n        }\n    }\n\n    if (!create_ssl_objects(sctx, cctx, &serverssl, &clientssl, NULL, NULL)) {\n        printf(\"Unable to create SSL objects\\n\");\n        goto end;\n    }\n\n    if (!create_ssl_connection(serverssl, clientssl)) {\n        printf(\"Unable to create SSL connection\\n\");\n        goto end;\n    }\n\n    testresult = 1;\n\n end:\n    X509_free(chaincert);\n    SSL_free(serverssl);\n    SSL_free(clientssl);\n    SSL_CTX_free(sctx);\n    SSL_CTX_free(cctx);\n\n    return testresult;\n}", "target": 0}
{"idx": 5455, "func": "static int cdg_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    int ret;\n    uint8_t command, inst;\n    uint8_t cdg_data[CDG_DATA_SIZE];\n    AVFrame *frame = data;\n    CDGraphicsContext *cc = avctx->priv_data;\n\n    if (buf_size < CDG_MINIMUM_PKT_SIZE) {\n        av_log(avctx, AV_LOG_ERROR, \"buffer too small for decoder\\n\");\n        return AVERROR(EINVAL);\n    }\n    if (buf_size > CDG_HEADER_SIZE + CDG_DATA_SIZE) {\n        av_log(avctx, AV_LOG_ERROR, \"buffer too big for decoder\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if ((ret = ff_reget_buffer(avctx, cc->frame)) < 0)\n        return ret;\n    if (!avctx->frame_number) {\n        memset(cc->frame->data[0], 0, cc->frame->linesize[0] * avctx->height);\n        memset(cc->frame->data[1], 0, AVPALETTE_SIZE);\n    }\n\n    command = bytestream_get_byte(&buf);\n    inst    = bytestream_get_byte(&buf);\n    inst    &= CDG_MASK;\n    buf += 2;  /// skipping 2 unneeded bytes\n\n    if (buf_size > CDG_HEADER_SIZE)\n        bytestream_get_buffer(&buf, cdg_data, buf_size - CDG_HEADER_SIZE);\n\n    if ((command & CDG_MASK) == CDG_COMMAND) {\n        switch (inst) {\n        case CDG_INST_MEMORY_PRESET:\n            if (!(cdg_data[1] & 0x0F))\n                memset(cc->frame->data[0], cdg_data[0] & 0x0F,\n                       cc->frame->linesize[0] * CDG_FULL_HEIGHT);\n            break;\n        case CDG_INST_LOAD_PAL_LO:\n        case CDG_INST_LOAD_PAL_HIGH:\n            if (buf_size - CDG_HEADER_SIZE < CDG_DATA_SIZE) {\n                av_log(avctx, AV_LOG_ERROR, \"buffer too small for loading palette\\n\");\n                return AVERROR(EINVAL);\n            }\n\n            cdg_load_palette(cc, cdg_data, inst == CDG_INST_LOAD_PAL_LO);\n            break;\n        case CDG_INST_BORDER_PRESET:\n            cdg_border_preset(cc, cdg_data);\n            break;\n        case CDG_INST_TILE_BLOCK_XOR:\n        case CDG_INST_TILE_BLOCK:\n            if (buf_size - CDG_HEADER_SIZE < CDG_DATA_SIZE) {\n                av_log(avctx, AV_LOG_ERROR, \"buffer too small for drawing tile\\n\");\n                return AVERROR(EINVAL);\n            }\n\n            ret = cdg_tile_block(cc, cdg_data, inst == CDG_INST_TILE_BLOCK_XOR);\n            if (ret) {\n                av_log(avctx, AV_LOG_ERROR, \"tile is out of range\\n\");\n                return ret;\n            }\n            break;\n        case CDG_INST_SCROLL_PRESET:\n        case CDG_INST_SCROLL_COPY:\n            if (buf_size - CDG_HEADER_SIZE < CDG_MINIMUM_SCROLL_SIZE) {\n                av_log(avctx, AV_LOG_ERROR, \"buffer too small for scrolling\\n\");\n                return AVERROR(EINVAL);\n            }\n\n            if ((ret = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n                return ret;\n\n            cdg_scroll(cc, cdg_data, frame, inst == CDG_INST_SCROLL_COPY);\n            av_frame_unref(cc->frame);\n            ret = av_frame_ref(cc->frame, frame);\n            if (ret < 0)\n                return ret;\n            break;\n        default:\n            break;\n        }\n\n        if (!frame->data[0]) {\n            ret = av_frame_ref(frame, cc->frame);\n            if (ret < 0)\n                return ret;\n        }\n        *got_frame = 1;\n    } else {\n        *got_frame = 0;\n        buf_size   = 0;\n    }\n\n    return buf_size;\n}", "target": 1}
{"idx": 5456, "func": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_frame, AVPacket *pkt)\n{\n    CDXLVideoContext *c = avctx->priv_data;\n    AVFrame * const p = data;\n    int ret, w, h, encoding, aligned_width, buf_size = pkt->size;\n    const uint8_t *buf = pkt->data;\n\n    if (buf_size < 32)\n        return AVERROR_INVALIDDATA;\n    encoding        = buf[1] & 7;\n    c->format       = buf[1] & 0xE0;\n    w               = AV_RB16(&buf[14]);\n    h               = AV_RB16(&buf[16]);\n    c->bpp          = buf[19];\n    c->palette_size = AV_RB16(&buf[20]);\n    c->palette      = buf + 32;\n    c->video        = c->palette + c->palette_size;\n    c->video_size   = buf_size - c->palette_size - 32;\n\n    if (c->palette_size > 512)\n        return AVERROR_INVALIDDATA;\n    if (buf_size < c->palette_size + 32)\n        return AVERROR_INVALIDDATA;\n    if (c->bpp < 1)\n        return AVERROR_INVALIDDATA;\n    if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {\n        avpriv_request_sample(avctx, \"Pixel format 0x%0x\", c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n\n    if (c->format == CHUNKY)\n        aligned_width = avctx->width;\n    else\n        aligned_width = FFALIGN(c->avctx->width, 16);\n    c->padded_bits  = aligned_width - c->avctx->width;\n    if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)\n        return AVERROR_INVALIDDATA;\n    if (!encoding && c->palette_size && c->bpp <= 8) {\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {\n        if (c->palette_size != (1 << (c->bpp - 1)))\n            return AVERROR_INVALIDDATA;\n        avctx->pix_fmt = AV_PIX_FMT_BGR24;\n    } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&\n               !c->palette_size) {\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n    } else {\n        avpriv_request_sample(avctx, \"Encoding %d, bpp %d and format 0x%x\",\n                              encoding, c->bpp, c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    if (encoding) {\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n                              h * w + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!c->new_video)\n            return AVERROR(ENOMEM);\n        if (c->bpp == 8)\n            cdxl_decode_ham8(c, p);\n        else\n            cdxl_decode_ham6(c, p);\n    } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n        cdxl_decode_rgb(c, p);\n    } else {\n        cdxl_decode_raw(c, p);\n    }\n    *got_frame = 1;\n\n    return buf_size;\n}", "target": 0}
{"idx": 5457, "func": "static void inc_128(RAND_DRBG_CTR *ctr)\n{\n    int i;\n    unsigned char c;\n    unsigned char *p = &ctr->V[15];\n\n    for (i = 0; i < 16; i++, p--) {\n        c = *p;\n        c++;\n        *p = c;\n        if (c != 0) {\n            /* If we didn't wrap around, we're done. */\n            break;\n        }\n    }\n}", "target": 0}
{"idx": 5458, "func": "int ff_add_index_entry(AVIndexEntry **index_entries,\n                       int *nb_index_entries,\n                       unsigned int *index_entries_allocated_size,\n                       int64_t pos, int64_t timestamp, int size, int distance, int flags)\n{\n    AVIndexEntry *entries, *ie;\n    int index;\n\n    if((unsigned)*nb_index_entries + 1 >= UINT_MAX / sizeof(AVIndexEntry))\n        return -1;\n\n    if(timestamp == AV_NOPTS_VALUE)\n        return AVERROR(EINVAL);\n\n    if (size < 0 || size > 0x3FFFFFFF)\n        return AVERROR(EINVAL);\n\n    if (is_relative(timestamp)) //FIXME this maintains previous behavior but we should shift by the correct offset once known\n        timestamp -= RELATIVE_TS_BASE;\n\n    entries = av_fast_realloc(*index_entries,\n                              index_entries_allocated_size,\n                              (*nb_index_entries + 1) *\n                              sizeof(AVIndexEntry));\n    if(!entries)\n        return -1;\n\n    *index_entries= entries;\n\n    index= ff_index_search_timestamp(*index_entries, *nb_index_entries, timestamp, AVSEEK_FLAG_ANY);\n\n    if(index<0){\n        index= (*nb_index_entries)++;\n        ie= &entries[index];\n        av_assert0(index==0 || ie[-1].timestamp < timestamp);\n    }else{\n        ie= &entries[index];\n        if(ie->timestamp != timestamp){\n            if(ie->timestamp <= timestamp)\n                return -1;\n            memmove(entries + index + 1, entries + index, sizeof(AVIndexEntry)*(*nb_index_entries - index));\n            (*nb_index_entries)++;\n        }else if(ie->pos == pos && distance < ie->min_distance) //do not reduce the distance\n            distance= ie->min_distance;\n    }\n\n    ie->pos = pos;\n    ie->timestamp = timestamp;\n    ie->min_distance= distance;\n    ie->size= size;\n    ie->flags = flags;\n\n    return index;\n}", "target": 1}
{"idx": 5459, "func": "static const struct ssl_conf_name *ssl_name_find(const char *name)\n{\n    size_t i;\n    const struct ssl_conf_name *nm;\n\n    if (name == NULL)\n        return NULL;\n    for (i = 0, nm = ssl_names; i < ssl_names_count; i++, nm++) {\n        if (strcmp(nm->name, name) == 0)\n            return nm;\n    }\n    return NULL;\n}", "target": 1}
{"idx": 5460, "func": "int gost_set_default_param(int param, const char *value)\n{\n    const char *tmp;\n    if (param < 0 || param > GOST_PARAM_MAX)\n        return 0;\n    tmp = getenv(gost_envnames[param]);\n    /*\n     * if there is value in the environment, use it, else -passed string *\n     */\n    if (!tmp)\n        tmp = value;\n    OPENSSL_free(gost_params[param]);\n    gost_params[param] = OPENSSL_strdup(tmp);\n\n    return 1;\n}", "target": 0}
{"idx": 5461, "func": "MSG_PROCESS_RETURN tls_process_client_certificate(SSL *s, PACKET *pkt)\n{\n    int i;\n    MSG_PROCESS_RETURN ret = MSG_PROCESS_ERROR;\n    X509 *x = NULL;\n    unsigned long l;\n    const unsigned char *certstart, *certbytes;\n    STACK_OF(X509) *sk = NULL;\n    PACKET spkt, context;\n    size_t chainidx;\n    SSL_SESSION *new_sess = NULL;\n\n    if ((sk = sk_X509_new_null()) == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                 ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (SSL_IS_TLS13(s) && (!PACKET_get_length_prefixed_1(pkt, &context)\n                            || (s->pha_context == NULL && PACKET_remaining(&context) != 0)\n                            || (s->pha_context != NULL &&\n                                !PACKET_equal(&context, s->pha_context, s->pha_context_len)))) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                 SSL_R_INVALID_CONTEXT);\n        goto err;\n    }\n\n    if (!PACKET_get_length_prefixed_3(pkt, &spkt)\n            || PACKET_remaining(pkt) != 0) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                 SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n\n    for (chainidx = 0; PACKET_remaining(&spkt) > 0; chainidx++) {\n        if (!PACKET_get_net_3(&spkt, &l)\n            || !PACKET_get_bytes(&spkt, &certbytes, l)) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR,\n                     SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                     SSL_R_CERT_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        certstart = certbytes;\n        x = d2i_X509(NULL, (const unsigned char **)&certbytes, l);\n        if (x == NULL) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR,\n                     SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_ASN1_LIB);\n            goto err;\n        }\n        if (certbytes != (certstart + l)) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR,\n                     SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                     SSL_R_CERT_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        if (SSL_IS_TLS13(s)) {\n            RAW_EXTENSION *rawexts = NULL;\n            PACKET extensions;\n\n            if (!PACKET_get_length_prefixed_2(&spkt, &extensions)) {\n                SSLfatal(s, SSL_AD_DECODE_ERROR,\n                         SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                         SSL_R_BAD_LENGTH);\n                goto err;\n            }\n            if (!tls_collect_extensions(s, &extensions,\n                                        SSL_EXT_TLS1_3_CERTIFICATE, &rawexts,\n                                        NULL, chainidx == 0)\n                || !tls_parse_all_extensions(s, SSL_EXT_TLS1_3_CERTIFICATE,\n                                             rawexts, x, chainidx,\n                                             PACKET_remaining(&spkt) == 0)) {\n                OPENSSL_free(rawexts);\n                goto err;\n            }\n            OPENSSL_free(rawexts);\n        }\n\n        if (!sk_X509_push(sk, x)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                     ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        x = NULL;\n    }\n\n    if (sk_X509_num(sk) <= 0) {\n        /* TLS does not mind 0 certs returned */\n        if (s->version == SSL3_VERSION) {\n            SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\n                     SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                     SSL_R_NO_CERTIFICATES_RETURNED);\n            goto err;\n        }\n        /* Fail for TLS only if we required a certificate */\n        else if ((s->verify_mode & SSL_VERIFY_PEER) &&\n                 (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {\n            SSLfatal(s, SSL_AD_CERTIFICATE_REQUIRED,\n                     SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                     SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n            goto err;\n        }\n        /* No client certificate so digest cached records */\n        if (s->s3->handshake_buffer && !ssl3_digest_cached_records(s, 0)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n    } else {\n        EVP_PKEY *pkey;\n        i = ssl_verify_cert_chain(s, sk);\n        if (i <= 0) {\n            SSLfatal(s, ssl_verify_alarm_type(s->verify_result),\n                     SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                     SSL_R_CERTIFICATE_VERIFY_FAILED);\n            goto err;\n        }\n        if (i > 1) {\n            SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\n                     SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, i);\n            goto err;\n        }\n        pkey = X509_get0_pubkey(sk_X509_value(sk, 0));\n        if (pkey == NULL) {\n            SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\n                     SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                     SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n            goto err;\n        }\n    }\n\n    /*\n     * Sessions must be immutable once they go into the session cache. Otherwise\n     * we can get multi-thread problems. Therefore we don't \"update\" sessions,\n     * we replace them with a duplicate. Here, we need to do this every time\n     * a new certificate is received via post-handshake authentication, as the\n     * session may have already gone into the session cache.\n     */\n\n    if (s->post_handshake_auth == SSL_PHA_REQUESTED) {\n        int m = s->session_ctx->session_cache_mode;\n\n        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                     ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        if (m & SSL_SESS_CACHE_SERVER) {\n            /*\n             * Remove the old session from the cache. We carry on if this fails\n             */\n            SSL_CTX_remove_session(s->session_ctx, s->session);\n        }\n\n        SSL_SESSION_free(s->session);\n        s->session = new_sess;\n    }\n\n    X509_free(s->session->peer);\n    s->session->peer = sk_X509_shift(sk);\n    s->session->verify_result = s->verify_result;\n\n    sk_X509_pop_free(s->session->peer_chain, X509_free);\n    s->session->peer_chain = sk;\n\n    if (new_sess != NULL)\n        ssl_update_cache(s, SSL_SESS_CACHE_SERVER);\n\n    /*\n     * Freeze the handshake buffer. For <TLS1.3 we do this after the CKE\n     * message\n     */\n    if (SSL_IS_TLS13(s) && !ssl3_digest_cached_records(s, 1)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    /*\n     * Inconsistency alert: cert_chain does *not* include the peer's own\n     * certificate, while we do include it in statem_clnt.c\n     */\n    sk = NULL;\n\n    /* Save the current hash state for when we receive the CertificateVerify */\n    if (SSL_IS_TLS13(s)\n            && !ssl_handshake_hash(s, s->cert_verify_hash,\n                                   sizeof(s->cert_verify_hash),\n                                   &s->cert_verify_hash_len)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    ret = MSG_PROCESS_CONTINUE_READING;\n\n err:\n    X509_free(x);\n    sk_X509_pop_free(sk, X509_free);\n    return ret;\n}", "target": 0}
{"idx": 5462, "func": "static char *shorts2str(int16_t *sp, int count, const char *sep)\n{\n    int i;\n    char *ap, *ap0;\n    if (!sep) sep = \", \";\n    ap = av_malloc((5 + strlen(sep)) * count);\n    if (!ap)\n        return NULL;\n    ap0   = ap;\n    ap[0] = '\\0';\n    for (i = 0; i < count; i++) {\n        int l = snprintf(ap, 5 + strlen(sep), \"%d%s\", sp[i], sep);\n        ap += l;\n    }\n    ap0[strlen(ap0) - strlen(sep)] = '\\0';\n    return ap0;\n}", "target": 1}
{"idx": 5463, "func": "static CodeBook unpack_codebook(GetBitContext* gb, unsigned depth,\n                                 unsigned size)\n{\n    unsigned i, j;\n    CodeBook cb = { 0 };\n\n    if (!can_safely_read(gb, (uint64_t)size * 34))\n        return cb;\n\n    if (size >= INT_MAX / sizeof(MacroBlock))\n        return cb;\n    cb.blocks = av_malloc(size ? size * sizeof(MacroBlock) : 1);\n    if (!cb.blocks)\n        return cb;\n\n    cb.depth = depth;\n    cb.size = size;\n    for (i = 0; i < size; i++) {\n        unsigned mask_bits = get_bits(gb, 4);\n        unsigned color0 = get_bits(gb, 15);\n        unsigned color1 = get_bits(gb, 15);\n\n        for (j = 0; j < 4; j++) {\n            if (mask_bits & (1 << j))\n                cb.blocks[i].pixels[j] = color1;\n            else\n                cb.blocks[i].pixels[j] = color0;\n        }\n    }\n    return cb;\n}", "target": 1}
{"idx": 5464, "func": "static void add_pollset(apr_pollset_t *pollset, apr_pollfd_t *pfd,\n                        apr_int16_t events)\n{\n    apr_status_t rv;\n\n    if (events & APR_POLLIN) {\n        events |= APR_POLLHUP;\n    }\n\n    if ((pfd->reqevents & events) == events) {\n        return;\n    }\n\n    if (pfd->reqevents) {\n        rv = apr_pollset_remove(pollset, pfd);\n        if (rv != APR_SUCCESS) {\n            AP_DEBUG_ASSERT(1);\n        }\n    }\n\n    pfd->reqevents |= events;\n    rv = apr_pollset_add(pollset, pfd);\n    if (rv != APR_SUCCESS) {\n        AP_DEBUG_ASSERT(1);\n    }\n}", "target": 0}
{"idx": 5465, "func": "static int check_bits_for_superframe(GetBitContext *orig_gb,\n                                     WMAVoiceContext *s)\n{\n    GetBitContext s_gb, *gb = &s_gb;\n    int n, need_bits, bd_idx;\n    const struct frame_type_desc *frame_desc;\n\n    /* initialize a copy */\n    init_get_bits(gb, orig_gb->buffer, orig_gb->size_in_bits);\n    skip_bits_long(gb, get_bits_count(orig_gb));\n    av_assert1(get_bits_left(gb) == get_bits_left(orig_gb));\n\n    /* superframe header */\n    if (get_bits_left(gb) < 14)\n        return 1;\n    if (!get_bits1(gb))\n        return AVERROR(ENOSYS);           // WMAPro-in-WMAVoice superframe\n    if (get_bits1(gb)) skip_bits(gb, 12); // number of  samples in superframe\n    if (s->has_residual_lsps) {           // residual LSPs (for all frames)\n        if (get_bits_left(gb) < s->sframe_lsp_bitsize)\n            return 1;\n        skip_bits_long(gb, s->sframe_lsp_bitsize);\n    }\n\n    /* frames */\n    for (n = 0; n < MAX_FRAMES; n++) {\n        int aw_idx_is_ext = 0;\n\n        if (!s->has_residual_lsps) {     // independent LSPs (per-frame)\n           if (get_bits_left(gb) < s->frame_lsp_bitsize) return 1;\n           skip_bits_long(gb, s->frame_lsp_bitsize);\n        }\n        bd_idx = s->vbm_tree[get_vlc2(gb, frame_type_vlc.table, 6, 3)];\n        if (bd_idx < 0)\n            return AVERROR_INVALIDDATA; // invalid frame type VLC code\n        frame_desc = &frame_descs[bd_idx];\n        if (frame_desc->acb_type == ACB_TYPE_ASYMMETRIC) {\n            if (get_bits_left(gb) < s->pitch_nbits)\n                return 1;\n            skip_bits_long(gb, s->pitch_nbits);\n        }\n        if (frame_desc->fcb_type == FCB_TYPE_SILENCE) {\n            skip_bits(gb, 8);\n        } else if (frame_desc->fcb_type == FCB_TYPE_AW_PULSES) {\n            int tmp = get_bits(gb, 6);\n            if (tmp >= 0x36) {\n                skip_bits(gb, 2);\n                aw_idx_is_ext = 1;\n            }\n        }\n\n        /* blocks */\n        if (frame_desc->acb_type == ACB_TYPE_HAMMING) {\n            need_bits = s->block_pitch_nbits +\n                (frame_desc->n_blocks - 1) * s->block_delta_pitch_nbits;\n        } else if (frame_desc->fcb_type == FCB_TYPE_AW_PULSES) {\n            need_bits = 2 * !aw_idx_is_ext;\n        } else\n            need_bits = 0;\n        need_bits += frame_desc->frame_size;\n        if (get_bits_left(gb) < need_bits)\n            return 1;\n        skip_bits_long(gb, need_bits);\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5466, "func": "static int internal_verify(X509_STORE_CTX *ctx)\n\t{\n\tint i,ok=0,n;\n\tX509 *xs,*xi;\n\tEVP_PKEY *pkey=NULL;\n\ttime_t *ptime;\n\tint (*cb)();\n\n\tcb=ctx->verify_cb;\n\tif (cb == NULL) cb=null_callback;\n\n\tn=sk_X509_num(ctx->chain);\n\tctx->error_depth=n-1;\n\tn--;\n\txi=sk_X509_value(ctx->chain,n);\n\tif(ctx->flags & X509_V_FLAG_USE_CHECK_TIME) ptime = &ctx->check_time;\n\telse ptime = NULL;\n\tif (ctx->check_issued(ctx, xi, xi))\n\t\txs=xi;\n\telse\n\t\t{\n\t\tif (n <= 0)\n\t\t\t{\n\t\t\tctx->error=X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;\n\t\t\tctx->current_cert=xi;\n\t\t\tok=cb(0,ctx);\n\t\t\tgoto end;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tn--;\n\t\t\tctx->error_depth=n;\n\t\t\txs=sk_X509_value(ctx->chain,n);\n\t\t\t}\n\t\t}\n\n/*\tctx->error=0;  not needed */\n\twhile (n >= 0)\n\t\t{\n\t\tctx->error_depth=n;\n\t\tif (!xs->valid)\n\t\t\t{\n\t\t\tif ((pkey=X509_get_pubkey(xi)) == NULL)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n\t\t\t\tctx->current_cert=xi;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok) goto end;\n\t\t\t\t}\n\t\t\tif (X509_verify(xs,pkey) <= 0)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_CERT_SIGNATURE_FAILURE;\n\t\t\t\tctx->current_cert=xs;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\t{\n\t\t\t\t\tEVP_PKEY_free(pkey);\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tEVP_PKEY_free(pkey);\n\t\t\tpkey=NULL;\n\n\t\t\ti=X509_cmp_time(X509_get_notBefore(xs), ptime);\n\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\n\t\t\t\tctx->current_cert=xs;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok) goto end;\n\t\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_CERT_NOT_YET_VALID;\n\t\t\t\tctx->current_cert=xs;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok) goto end;\n\t\t\t\t}\n\t\t\txs->valid=1;\n\t\t\t}\n\n\t\ti=X509_cmp_time(X509_get_notAfter(xs), ptime);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\n\t\t\tctx->current_cert=xs;\n\t\t\tok=(*cb)(0,ctx);\n\t\t\tif (!ok) goto end;\n\t\t\t}\n\n\t\tif (i < 0)\n\t\t\t{\n\t\t\tctx->error=X509_V_ERR_CERT_HAS_EXPIRED;\n\t\t\tctx->current_cert=xs;\n\t\t\tok=(*cb)(0,ctx);\n\t\t\tif (!ok) goto end;\n\t\t\t}\n\n\t\t/* CRL CHECK */\n\n\t\t/* The last error (if any) is still in the error value */\n\t\tctx->current_cert=xs;\n\t\tok=(*cb)(1,ctx);\n\t\tif (!ok) goto end;\n\n\t\tn--;\n\t\tif (n >= 0)\n\t\t\t{\n\t\t\txi=xs;\n\t\t\txs=sk_X509_value(ctx->chain,n);\n\t\t\t}\n\t\t}\n\tok=1;\nend:\n\treturn(ok);\n\t}", "target": 0}
{"idx": 5467, "func": "static long file_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    long ret = 1;\n    FILE *fp = (FILE *)b->ptr;\n    FILE **fpp;\n    char p[4];\n    int st;\n\n    switch (cmd) {\n    case BIO_C_FILE_SEEK:\n    case BIO_CTRL_RESET:\n        if (b->flags & BIO_FLAGS_UPLINK)\n            ret = (long)UP_fseek(b->ptr, num, 0);\n        else\n            ret = (long)fseek(fp, num, 0);\n        break;\n    case BIO_CTRL_EOF:\n        if (b->flags & BIO_FLAGS_UPLINK)\n            ret = (long)UP_feof(fp);\n        else\n            ret = (long)feof(fp);\n        break;\n    case BIO_C_FILE_TELL:\n    case BIO_CTRL_INFO:\n        if (b->flags & BIO_FLAGS_UPLINK)\n            ret = UP_ftell(b->ptr);\n        else\n            ret = ftell(fp);\n        break;\n    case BIO_C_SET_FILE_PTR:\n        file_free(b);\n        b->shutdown = (int)num & BIO_CLOSE;\n        b->ptr = ptr;\n        b->init = 1;\n#  if BIO_FLAGS_UPLINK!=0\n#   if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\n#    define _IOB_ENTRIES 20\n#   endif\n        /* Safety net to catch purely internal BIO_set_fp calls */\n#   if defined(_MSC_VER) && _MSC_VER>=1900\n        if (ptr == stdin || ptr == stdout || ptr == stderr)\n            BIO_clear_flags(b, BIO_FLAGS_UPLINK);\n#   elif defined(_IOB_ENTRIES)\n        if ((size_t)ptr >= (size_t)stdin &&\n            (size_t)ptr < (size_t)(stdin + _IOB_ENTRIES))\n            BIO_clear_flags(b, BIO_FLAGS_UPLINK);\n#   endif\n#  endif\n#  ifdef UP_fsetmod\n        if (b->flags & BIO_FLAGS_UPLINK)\n            UP_fsetmod(b->ptr, (char)((num & BIO_FP_TEXT) ? 't' : 'b'));\n        else\n#  endif\n        {\n#  if defined(OPENSSL_SYS_WINDOWS)\n            int fd = _fileno((FILE *)ptr);\n            if (num & BIO_FP_TEXT)\n                _setmode(fd, _O_TEXT);\n            else\n                _setmode(fd, _O_BINARY);\n#  elif defined(OPENSSL_SYS_MSDOS)\n            int fd = fileno((FILE *)ptr);\n            /* Set correct text/binary mode */\n            if (num & BIO_FP_TEXT)\n                _setmode(fd, _O_TEXT);\n            /* Dangerous to set stdin/stdout to raw (unless redirected) */\n            else {\n                if (fd == STDIN_FILENO || fd == STDOUT_FILENO) {\n                    if (isatty(fd) <= 0)\n                        _setmode(fd, _O_BINARY);\n                } else\n                    _setmode(fd, _O_BINARY);\n            }\n#  elif defined(OPENSSL_SYS_WIN32_CYGWIN)\n            int fd = fileno((FILE *)ptr);\n            if (num & BIO_FP_TEXT)\n                setmode(fd, O_TEXT);\n            else\n                setmode(fd, O_BINARY);\n#  endif\n        }\n        break;\n    case BIO_C_SET_FILENAME:\n        file_free(b);\n        b->shutdown = (int)num & BIO_CLOSE;\n        if (num & BIO_FP_APPEND) {\n            if (num & BIO_FP_READ)\n                strcpy(p, \"a+\");\n            else\n                strcpy(p, \"a\");\n        } else if ((num & BIO_FP_READ) && (num & BIO_FP_WRITE))\n            strcpy(p, \"r+\");\n        else if (num & BIO_FP_WRITE)\n            strcpy(p, \"w\");\n        else if (num & BIO_FP_READ)\n            strcpy(p, \"r\");\n        else {\n            BIOerr(BIO_F_FILE_CTRL, BIO_R_BAD_FOPEN_MODE);\n            ret = 0;\n            break;\n        }\n#  if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32_CYGWIN)\n        if (!(num & BIO_FP_TEXT))\n            strcat(p, \"b\");\n        else\n            strcat(p, \"t\");\n#  endif\n        fp = openssl_fopen(ptr, p);\n        if (fp == NULL) {\n            SYSerr(SYS_F_FOPEN, get_last_sys_error());\n            ERR_add_error_data(5, \"fopen('\", ptr, \"','\", p, \"')\");\n            BIOerr(BIO_F_FILE_CTRL, ERR_R_SYS_LIB);\n            ret = 0;\n            break;\n        }\n        b->ptr = fp;\n        b->init = 1;\n        BIO_clear_flags(b, BIO_FLAGS_UPLINK); /* we did fopen -> we disengage\n                                               * UPLINK */\n        break;\n    case BIO_C_GET_FILE_PTR:\n        /* the ptr parameter is actually a FILE ** in this case. */\n        if (ptr != NULL) {\n            fpp = (FILE **)ptr;\n            *fpp = (FILE *)b->ptr;\n        }\n        break;\n    case BIO_CTRL_GET_CLOSE:\n        ret = (long)b->shutdown;\n        break;\n    case BIO_CTRL_SET_CLOSE:\n        b->shutdown = (int)num;\n        break;\n    case BIO_CTRL_FLUSH:\n        st = b->flags & BIO_FLAGS_UPLINK\n                ? UP_fflush(b->ptr) : fflush((FILE *)b->ptr);\n        if (st == EOF) {\n            SYSerr(SYS_F_FFLUSH, get_last_sys_error());\n            ERR_add_error_data(1, \"fflush()\");\n            BIOerr(BIO_F_FILE_CTRL, ERR_R_SYS_LIB);\n            ret = 0;\n        }\n        break;\n    case BIO_CTRL_DUP:\n        ret = 1;\n        break;\n\n    case BIO_CTRL_WPENDING:\n    case BIO_CTRL_PENDING:\n    case BIO_CTRL_PUSH:\n    case BIO_CTRL_POP:\n    default:\n        ret = 0;\n        break;\n    }\n    return (ret);\n}", "target": 0}
{"idx": 5468, "func": "static int hls_write_trailer(struct AVFormatContext *s)\n{\n    HLSContext *hls = s->priv_data;\n    AVFormatContext *oc = hls->avf;\n\n    av_write_trailer(oc);\n    ff_format_io_close(s, &oc->pb);\n    avformat_free_context(oc);\n    av_free(hls->basename);\n    append_entry(hls, hls->duration);\n    hls_window(s, 1);\n\n    free_entries(hls);\n    return 0;\n}", "target": 0}
{"idx": 5469, "func": "static int test_kdf_tls1_prf(void)\n{\n    int ret;\n    EVP_KDF_CTX *kctx;\n    unsigned char out[16];\n    const unsigned char expected[sizeof(out)] = {\n        0x8e, 0x4d, 0x93, 0x25, 0x30, 0xd7, 0x65, 0xa0,\n        0xaa, 0xe9, 0x74, 0xc3, 0x04, 0x73, 0x5e, 0xcc\n    };\n\n    ret = TEST_ptr(kctx = EVP_KDF_CTX_new_id(EVP_KDF_TLS1_PRF))\n          && TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()),\n                         0)\n          && TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_TLS_SECRET,\n                                      \"secret\", (size_t)6), 0)\n          && TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_ADD_TLS_SEED, \"seed\",\n                                      (size_t)4), 0)\n          && TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)\n          && TEST_mem_eq(out, sizeof(out), expected, sizeof(expected));\n\n    EVP_KDF_CTX_free(kctx);\n    return ret;\n}", "target": 0}
{"idx": 5470, "func": "void ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\n\t{\n\tint i;\n\tif (tt->flags & ASN1_TFLG_SK_MASK)\n\t\t{\n\t\tSTACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\n\t\tfor (i = 0; i < sk_ASN1_VALUE_num(sk); i++)\n\t\t\t{\n\t\t\tASN1_VALUE *vtmp;\n\t\t\tvtmp = sk_ASN1_VALUE_value(sk, i);\n\t\t\tasn1_item_combine_free(&vtmp, ASN1_ITEM_ptr(tt->item),\n\t\t\t\t\t\t\t\t\t0);\n\t\t\t}\n\t\tsk_ASN1_VALUE_free(sk);\n\t\t*pval = NULL;\n\t\t}\n\telse\n\t\tasn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),\n\t\t\t\t\t\ttt->flags & ASN1_TFLG_COMBINE);\n\t}", "target": 1}
{"idx": 5471, "func": "uintptr_t\nngx_escape_html(u_char *dst, u_char *src, size_t size)\n{\n    u_char      ch;\n    ngx_uint_t  len;\n\n    if (dst == NULL) {\n\n        len = 0;\n\n        while (size) {\n            switch (*src++) {\n\n            case '<':\n                len += sizeof(\"&lt;\") - 2;\n                break;\n\n            case '>':\n                len += sizeof(\"&gt;\") - 2;\n                break;\n\n            case '&':\n                len += sizeof(\"&amp;\") - 2;\n                break;\n\n            default:\n                break;\n            }\n            size--;\n        }\n\n        return (uintptr_t) len;\n    }\n\n    while (size) {\n        ch = *src++;\n\n        switch (ch) {\n\n        case '<':\n            *dst++ = '&'; *dst++ = 'l'; *dst++ = 't'; *dst++ = ';';\n            break;\n\n        case '>':\n            *dst++ = '&'; *dst++ = 'g'; *dst++ = 't'; *dst++ = ';';\n            break;\n\n        case '&':\n            *dst++ = '&'; *dst++ = 'a'; *dst++ = 'm'; *dst++ = 'p';\n            *dst++ = ';';\n            break;\n\n        default:\n            *dst++ = ch;\n            break;\n        }\n        size--;\n    }\n\n    return (uintptr_t) dst;\n}", "target": 0}
{"idx": 5472, "func": "static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)\n{\n    int log2_min_cb_size = sps->log2_min_cb_size;\n    int width            = sps->width;\n    int height           = sps->height;\n    int pic_size_in_ctb  = ((width  >> log2_min_cb_size) + 1) *\n                           ((height >> log2_min_cb_size) + 1);\n    int ctb_count        = sps->ctb_width * sps->ctb_height;\n    int min_pu_size      = sps->min_pu_width * sps->min_pu_height;\n\n    s->bs_width  = (width  >> 2) + 1;\n    s->bs_height = (height >> 2) + 1;\n\n    s->sao           = av_mallocz_array(ctb_count, sizeof(*s->sao));\n    s->deblock       = av_mallocz_array(ctb_count, sizeof(*s->deblock));\n    if (!s->sao || !s->deblock)\n        goto fail;\n\n    s->skip_flag    = av_malloc(sps->min_cb_height * sps->min_cb_width);\n    s->tab_ct_depth = av_malloc_array(sps->min_cb_height, sps->min_cb_width);\n    if (!s->skip_flag || !s->tab_ct_depth)\n        goto fail;\n\n    s->cbf_luma = av_malloc_array(sps->min_tb_width, sps->min_tb_height);\n    s->tab_ipm  = av_mallocz(min_pu_size);\n    s->is_pcm   = av_malloc((sps->min_pu_width + 1) * (sps->min_pu_height + 1));\n    if (!s->tab_ipm || !s->cbf_luma || !s->is_pcm)\n        goto fail;\n\n    s->filter_slice_edges = av_mallocz(ctb_count);\n    s->tab_slice_address  = av_malloc_array(pic_size_in_ctb,\n                                      sizeof(*s->tab_slice_address));\n    s->qp_y_tab           = av_malloc_array(pic_size_in_ctb,\n                                      sizeof(*s->qp_y_tab));\n    if (!s->qp_y_tab || !s->filter_slice_edges || !s->tab_slice_address)\n        goto fail;\n\n    s->horizontal_bs = av_mallocz_array(s->bs_width, s->bs_height);\n    s->vertical_bs   = av_mallocz_array(s->bs_width, s->bs_height);\n    if (!s->horizontal_bs || !s->vertical_bs)\n        goto fail;\n\n    s->tab_mvf_pool = av_buffer_pool_init(min_pu_size * sizeof(MvField),\n                                          av_buffer_allocz);\n    s->rpl_tab_pool = av_buffer_pool_init(ctb_count * sizeof(RefPicListTab),\n                                          av_buffer_allocz);\n    if (!s->tab_mvf_pool || !s->rpl_tab_pool)\n        goto fail;\n\n    return 0;\n\nfail:\n    pic_arrays_free(s);\n    return AVERROR(ENOMEM);\n}", "target": 0}
{"idx": 5473, "func": "void avformat_free_context(AVFormatContext *s)\n{\n    int i;\n\n    if (!s)\n        return;\n\n    av_opt_free(s);\n    if (s->iformat && s->iformat->priv_class && s->priv_data)\n        av_opt_free(s->priv_data);\n    if (s->oformat && s->oformat->priv_class && s->priv_data)\n        av_opt_free(s->priv_data);\n\n    for (i = s->nb_streams - 1; i >= 0; i--) {\n        ff_free_stream(s, s->streams[i]);\n    }\n    for (i = s->nb_programs - 1; i >= 0; i--) {\n        av_dict_free(&s->programs[i]->metadata);\n        av_freep(&s->programs[i]->stream_index);\n        av_freep(&s->programs[i]);\n    }\n    av_freep(&s->programs);\n    av_freep(&s->priv_data);\n    while (s->nb_chapters--) {\n        av_dict_free(&s->chapters[s->nb_chapters]->metadata);\n        av_freep(&s->chapters[s->nb_chapters]);\n    }\n    av_freep(&s->chapters);\n    av_dict_free(&s->metadata);\n    av_freep(&s->streams);\n    av_freep(&s->internal);\n    flush_packet_queue(s);\n    av_free(s);\n}", "target": 1}
{"idx": 5474, "func": "uint32_t avpriv_fmt_ff2v4l(enum AVPixelFormat pix_fmt, enum AVCodecID codec_id)\n{\n    int i;\n\n    for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {\n        if ((codec_id == AV_CODEC_ID_NONE ||\n             avpriv_fmt_conversion_table[i].codec_id == codec_id) &&\n            (pix_fmt == AV_PIX_FMT_NONE ||\n             avpriv_fmt_conversion_table[i].ff_fmt == pix_fmt)) {\n            return avpriv_fmt_conversion_table[i].v4l2_fmt;\n        }\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5475, "func": "static void deinterlace_line_c(uint8_t *dst,\n                             const uint8_t *lum_m4, const uint8_t *lum_m3,\n                             const uint8_t *lum_m2, const uint8_t *lum_m1,\n                             const uint8_t *lum,\n                             int size)\n{\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n    int sum;\n\n    for(;size > 0;size--) {\n        sum = -lum_m4[0];\n        sum += lum_m3[0] << 2;\n        sum += lum_m2[0] << 1;\n        sum += lum_m1[0] << 2;\n        sum += -lum[0];\n        dst[0] = cm[(sum + 4) >> 3];\n        lum_m4++;\n        lum_m3++;\n        lum_m2++;\n        lum_m1++;\n        lum++;\n        dst++;\n    }\n}", "target": 1}
{"idx": 5476, "func": "static int ssl_conf_cmd_skip_prefix(SSL_CONF_CTX *cctx, const char **pcmd)\n{\n    if (!pcmd || !*pcmd)\n        return 0;\n    /* If a prefix is set, check and skip */\n    if (cctx->prefix) {\n        if (strlen(*pcmd) <= cctx->prefixlen)\n            return 0;\n        if (cctx->flags & SSL_CONF_FLAG_CMDLINE &&\n            strncmp(*pcmd, cctx->prefix, cctx->prefixlen))\n            return 0;\n        if (cctx->flags & SSL_CONF_FLAG_FILE &&\n            strncasecmp(*pcmd, cctx->prefix, cctx->prefixlen))\n            return 0;\n        *pcmd += cctx->prefixlen;\n    } else if (cctx->flags & SSL_CONF_FLAG_CMDLINE) {\n        if (**pcmd != '-' || !(*pcmd)[1])\n            return 0;\n        *pcmd += 1;\n    }\n    return 1;\n}", "target": 1}
{"idx": 5477, "func": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n\t     const unsigned char *in, int inl)\n\t{\n\tint i,j,bl;\n\n\tif (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER)\n\t\t{\n\t\ti = ctx->cipher->do_cipher(ctx, out, in, inl);\n\t\tif (i < 0)\n\t\t\treturn 0;\n\t\telse\n\t\t\t*outl = i;\n\t\treturn 1;\n\t\t}\n\n\tif (inl <= 0)\n\t\t{\n\t\t*outl = 0;\n\t\treturn inl == 0;\n\t\t}\n\n\tif(ctx->buf_len == 0 && (inl&(ctx->block_mask)) == 0)\n\t\t{\n\t\tif(ctx->cipher->do_cipher(ctx,out,in,inl))\n\t\t\t{\n\t\t\t*outl=inl;\n\t\t\treturn 1;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t*outl=0;\n\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\ti=ctx->buf_len;\n\tbl=ctx->cipher->block_size;\n\tOPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n\tif (i != 0)\n\t\t{\n\t\tif (i+inl < bl)\n\t\t\t{\n\t\t\tmemcpy(&(ctx->buf[i]),in,inl);\n\t\t\tctx->buf_len+=inl;\n\t\t\t*outl=0;\n\t\t\treturn 1;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tj=bl-i;\n\t\t\tmemcpy(&(ctx->buf[i]),in,j);\n\t\t\tif(!ctx->cipher->do_cipher(ctx,out,ctx->buf,bl)) return 0;\n\t\t\tinl-=j;\n\t\t\tin+=j;\n\t\t\tout+=bl;\n\t\t\t*outl=bl;\n\t\t\t}\n\t\t}\n\telse\n\t\t*outl = 0;\n\ti=inl&(bl-1);\n\tinl-=i;\n\tif (inl > 0)\n\t\t{\n\t\tif(!ctx->cipher->do_cipher(ctx,out,in,inl)) return 0;\n\t\t*outl+=inl;\n\t\t}\n\n\tif (i != 0)\n\t\tmemcpy(ctx->buf,&(in[inl]),i);\n\tctx->buf_len=i;\n\treturn 1;\n\t}", "target": 1}
{"idx": 5478, "func": "static int mpc8_read_header(AVFormatContext *s)\n{\n    MPCContext *c = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    int tag = 0;\n    int64_t size, pos;\n\n    c->header_pos = avio_tell(pb);\n    if(avio_rl32(pb) != TAG_MPCK){\n        av_log(s, AV_LOG_ERROR, \"Not a Musepack8 file\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    while(!avio_feof(pb)){\n        pos = avio_tell(pb);\n        mpc8_get_chunk_header(pb, &tag, &size);\n        if (size < 0) {\n            av_log(s, AV_LOG_ERROR, \"Invalid chunk length\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if(tag == TAG_STREAMHDR)\n            break;\n        mpc8_handle_chunk(s, tag, pos, size);\n    }\n    if(tag != TAG_STREAMHDR){\n        av_log(s, AV_LOG_ERROR, \"Stream header not found\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    pos = avio_tell(pb);\n    avio_skip(pb, 4); //CRC\n    c->ver = avio_r8(pb);\n    if(c->ver != 8){\n        avpriv_report_missing_feature(s, \"Stream version %d\", c->ver);\n        return AVERROR_PATCHWELCOME;\n    }\n    c->samples = ffio_read_varlen(pb);\n    ffio_read_varlen(pb); //silence samples at the beginning\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    st->codecpar->codec_id = AV_CODEC_ID_MUSEPACK8;\n    st->codecpar->bits_per_coded_sample = 16;\n\n    if (ff_get_extradata(s, st->codecpar, pb, 2) < 0)\n        return AVERROR(ENOMEM);\n\n    st->codecpar->channels = (st->codecpar->extradata[1] >> 4) + 1;\n    st->codecpar->sample_rate = mpc8_rate[st->codecpar->extradata[0] >> 5];\n    avpriv_set_pts_info(st, 32, 1152  << (st->codecpar->extradata[1]&3)*2, st->codecpar->sample_rate);\n    st->start_time = 0;\n    st->duration = c->samples / (1152 << (st->codecpar->extradata[1]&3)*2);\n    size -= avio_tell(pb) - pos;\n    if (size > 0)\n        avio_skip(pb, size);\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t pos = avio_tell(s->pb);\n        c->apetag_start = ff_ape_parse_tag(s);\n        avio_seek(s->pb, pos, SEEK_SET);\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5479, "func": "static int dv_extract_audio(const uint8_t *frame, uint8_t **ppcm,\n                            const AVDVProfile *sys)\n{\n    int size, chan, i, j, d, of, smpls, freq, quant, half_ch;\n    uint16_t lc, rc;\n    const uint8_t *as_pack;\n    uint8_t *pcm, ipcm;\n\n    as_pack = dv_extract_pack(frame, dv_audio_source);\n    if (!as_pack)    /* No audio ? */\n        return 0;\n\n    smpls = as_pack[1]      & 0x3f; /* samples in this frame - min. samples */\n    freq  = as_pack[4] >> 3 & 0x07; /* 0 - 48kHz, 1 - 44,1kHz, 2 - 32kHz */\n    quant = as_pack[4]      & 0x07; /* 0 - 16-bit linear, 1 - 12-bit nonlinear */\n\n    if (quant > 1)\n        return -1;  /* unsupported quantization */\n\n    if (freq >= FF_ARRAY_ELEMS(dv_audio_frequency))\n        return AVERROR_INVALIDDATA;\n\n    size    = (sys->audio_min_samples[freq] + smpls) * 4; /* 2ch, 2bytes */\n    half_ch = sys->difseg_size / 2;\n\n    /* We work with 720p frames split in half, thus even frames have\n     * channels 0,1 and odd 2,3. */\n    ipcm = (sys->height == 720 && !(frame[1] & 0x0C)) ? 2 : 0;\n\n    if (ipcm + sys->n_difchan > (quant == 1 ? 2 : 4)) {\n        av_log(NULL, AV_LOG_ERROR, \"too many dv pcm frames\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* for each DIF channel */\n    for (chan = 0; chan < sys->n_difchan; chan++) {\n        av_assert0(ipcm<4);\n        pcm = ppcm[ipcm++];\n        if (!pcm)\n            break;\n\n        /* for each DIF segment */\n        for (i = 0; i < sys->difseg_size; i++) {\n            frame += 6 * 80; /* skip DIF segment header */\n            if (quant == 1 && i == half_ch) {\n                /* next stereo channel (12-bit mode only) */\n                av_assert0(ipcm<4);\n                pcm = ppcm[ipcm++];\n                if (!pcm)\n                    break;\n            }\n\n            /* for each AV sequence */\n            for (j = 0; j < 9; j++) {\n                for (d = 8; d < 80; d += 2) {\n                    if (quant == 0) {  /* 16-bit quantization */\n                        of = sys->audio_shuffle[i][j] +\n                             (d - 8) / 2 * sys->audio_stride;\n                        if (of * 2 >= size)\n                            continue;\n\n                        /* FIXME: maybe we have to admit that DV is a\n                         * big-endian PCM */\n                        pcm[of * 2]     = frame[d + 1];\n                        pcm[of * 2 + 1] = frame[d];\n\n                        if (pcm[of * 2 + 1] == 0x80 && pcm[of * 2] == 0x00)\n                            pcm[of * 2 + 1] = 0;\n                    } else {           /* 12-bit quantization */\n                        lc = ((uint16_t)frame[d]     << 4) |\n                             ((uint16_t)frame[d + 2] >> 4);\n                        rc = ((uint16_t)frame[d + 1] << 4) |\n                             ((uint16_t)frame[d + 2] & 0x0f);\n                        lc = (lc == 0x800 ? 0 : dv_audio_12to16(lc));\n                        rc = (rc == 0x800 ? 0 : dv_audio_12to16(rc));\n\n                        of = sys->audio_shuffle[i % half_ch][j] +\n                             (d - 8) / 3 * sys->audio_stride;\n                        if (of * 2 >= size)\n                            continue;\n\n                        /* FIXME: maybe we have to admit that DV is a\n                         * big-endian PCM */\n                        pcm[of * 2]     = lc & 0xff;\n                        pcm[of * 2 + 1] = lc >> 8;\n                        of = sys->audio_shuffle[i % half_ch + half_ch][j] +\n                             (d - 8) / 3 * sys->audio_stride;\n                        /* FIXME: maybe we have to admit that DV is a\n                         * big-endian PCM */\n                        pcm[of * 2]     = rc & 0xff;\n                        pcm[of * 2 + 1] = rc >> 8;\n                        ++d;\n                    }\n                }\n\n                frame += 16 * 80; /* 15 Video DIFs + 1 Audio DIF */\n            }\n        }\n    }\n\n    return size;\n}", "target": 1}
{"idx": 5480, "func": "static int pkey_gost_encrypt_init(EVP_PKEY_CTX *ctx)\n\t{\n\treturn 1;\n\t}", "target": 0}
{"idx": 5481, "func": "static int y41p_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_frame, AVPacket *avpkt)\n{\n    AVFrame *pic = data;\n    uint8_t *src = avpkt->data;\n    uint8_t *y, *u, *v;\n    int i, j, ret;\n\n    if (avpkt->size < 3LL * avctx->height * FFALIGN(avctx->width, 8) / 2) {\n        av_log(avctx, AV_LOG_ERROR, \"Insufficient input data.\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    pic->key_frame = 1;\n    pic->pict_type = AV_PICTURE_TYPE_I;\n\n    for (i = avctx->height - 1; i >= 0 ; i--) {\n        y = &pic->data[0][i * pic->linesize[0]];\n        u = &pic->data[1][i * pic->linesize[1]];\n        v = &pic->data[2][i * pic->linesize[2]];\n        for (j = 0; j < avctx->width; j += 8) {\n            *(u++) = *src++;\n            *(y++) = *src++;\n            *(v++) = *src++;\n            *(y++) = *src++;\n\n            *(u++) = *src++;\n            *(y++) = *src++;\n            *(v++) = *src++;\n            *(y++) = *src++;\n\n            *(y++) = *src++;\n            *(y++) = *src++;\n            *(y++) = *src++;\n            *(y++) = *src++;\n        }\n    }\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}", "target": 0}
{"idx": 5482, "func": "int OPENSSL_sk_insert(OPENSSL_STACK *st, const void *data, int loc)\n{\n    if (st == NULL || st->num == max_nodes)\n        return 0;\n\n    if (!sk_reserve(st, 1, 0))\n        return 0;\n\n    if ((loc >= st->num) || (loc < 0)) {\n        st->data[st->num] = data;\n    } else {\n        memmove(&st->data[loc + 1], &st->data[loc],\n                sizeof(st->data[0]) * (st->num - loc));\n        st->data[loc] = data;\n    }\n    st->num++;\n    st->sorted = 0;\n    return st->num;\n}", "target": 1}
{"idx": 5483, "func": "static void lumRangeToJpeg16_c(int16_t *_dst, int width)\n{\n    int i;\n    int32_t *dst = (int32_t *) _dst;\n    for (i = 0; i < width; i++)\n        dst[i] = (FFMIN(dst[i],30189<<4)*4769 - (39057361<<2))>>12;\n}", "target": 0}
{"idx": 5484, "func": "static int query_command(const char *data, char *digest, const EVP_MD *md,\n                         const char *policy, int no_nonce,\n                         int cert, const char *in, const char *out, int text)\n{\n    int ret = 0;\n    TS_REQ *query = NULL;\n    BIO *in_bio = NULL;\n    BIO *data_bio = NULL;\n    BIO *out_bio = NULL;\n\n    /* Build query object either from file or from scratch. */\n    if (in != NULL) {\n        if ((in_bio = bio_open_default(in, 'r', FORMAT_ASN1)) == NULL)\n            goto end;\n        query = d2i_TS_REQ_bio(in_bio, NULL);\n    } else {\n        /* Open the file if no explicit digest bytes were specified. */\n        if (digest == NULL\n            && (data_bio = bio_open_default(data, 'r', FORMAT_ASN1)) == NULL)\n            goto end;\n        query = create_query(data_bio, digest, md, policy, no_nonce, cert);\n    }\n    if (query == NULL)\n        goto end;\n\n    /* Write query either in ASN.1 or in text format. */\n    if (text) {\n        /* Text output. */\n        if ((out_bio = bio_open_default(out, 'w', FORMAT_TEXT)) == NULL)\n            goto end;\n        if (!TS_REQ_print_bio(out_bio, query))\n            goto end;\n    } else {\n        /* ASN.1 output. */\n        if ((out_bio = bio_open_default(out, 'w', FORMAT_ASN1)) == NULL)\n            goto end;\n        if (!i2d_TS_REQ_bio(out_bio, query))\n            goto end;\n    }\n\n    ret = 1;\n\n end:\n    ERR_print_errors(bio_err);\n\n    /* Clean up. */\n    BIO_free_all(in_bio);\n    BIO_free_all(data_bio);\n    BIO_free_all(out_bio);\n    TS_REQ_free(query);\n\n    return ret;\n}", "target": 0}
{"idx": 5485, "func": "static int idp_check_crlissuer(DIST_POINT *dp, X509_CRL *crl, int *pimatch)\n\t{\n\tint i;\n\tX509_NAME *nm = X509_CRL_get_issuer(crl);\n\t/* If no CRLissuer return is successful iff don't need a match */\n\tif (!dp->CRLissuer)\n\t\treturn *pimatch;\n\tfor (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++)\n\t\t{\n\t\tGENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);\n\t\tif (gen->type != GEN_DIRNAME)\n\t\t\tcontinue;\n\t\tif (!X509_NAME_cmp(gen->d.directoryName, nm))\n\t\t\t{\n\t\t\t*pimatch = 1;\n\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n\t}", "target": 0}
{"idx": 5486, "func": "int EVP_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, unsigned int *siglen,\n\t     EVP_PKEY *pkey)\n\t{\n\tunsigned char m[EVP_MAX_MD_SIZE];\n\tunsigned int m_len;\n\tint i = 0,ok = 0,v;\n\tMS_STATIC EVP_MD_CTX tmp_ctx;\n\tEVP_PKEY_CTX *pkctx = NULL;\n\n\t*siglen=0;\n\tEVP_MD_CTX_init(&tmp_ctx);\n\tif (!EVP_MD_CTX_copy_ex(&tmp_ctx,ctx))\n\t\tgoto err;  \n\tif (!EVP_DigestFinal_ex(&tmp_ctx,&(m[0]),&m_len))\n\t\tgoto err;\n\tEVP_MD_CTX_cleanup(&tmp_ctx);\n\n\tif (ctx->digest->flags & EVP_MD_FLAG_PKEY_METHOD_SIGNATURE)\n\t\t{\n\t\tsize_t sltmp = (size_t)EVP_PKEY_size(pkey);\n\t\ti = 0;\n\t\tpkctx = EVP_PKEY_CTX_new(pkey, NULL);\n\t\tif (!pkctx)\n\t\t\tgoto err;\n\t\tif (EVP_PKEY_sign_init(pkctx) <= 0)\n\t\t\tgoto err;\n\t\tif (EVP_PKEY_CTX_set_signature_md(pkctx, ctx->digest) <= 0)\n\t\t\tgoto err;\n\t\tif (EVP_PKEY_sign(pkctx, sigret, &sltmp, m, m_len) <= 0)\n\t\t\tgoto err;\n\t\t*siglen = sltmp;\n\t\ti = 1;\n\t\terr:\n\t\tEVP_PKEY_CTX_free(pkctx);\n\t\treturn i;\n\t\t}\n\n\tfor (i=0; i<4; i++)\n\t\t{\n\t\tv=ctx->digest->required_pkey_type[i];\n\t\tif (v == 0) break;\n\t\tif (pkey->type == v)\n\t\t\t{\n\t\t\tok=1;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tif (!ok)\n\t\t{\n\t\tEVPerr(EVP_F_EVP_SIGNFINAL,EVP_R_WRONG_PUBLIC_KEY_TYPE);\n\t\treturn(0);\n\t\t}\n\n\tif (ctx->digest->sign == NULL)\n\t\t{\n\t\tEVPerr(EVP_F_EVP_SIGNFINAL,EVP_R_NO_SIGN_FUNCTION_CONFIGURED);\n\t\treturn(0);\n\t\t}\n\treturn(ctx->digest->sign(ctx->digest->type,m,m_len,sigret,siglen,\n\t\tpkey->pkey.ptr));\n\t}", "target": 0}
{"idx": 5487, "func": "void lh_free(LHASH *lh)\n\t{\n\tunsigned int i;\n\tLHASH_NODE *n,*nn;\n\n\tif (lh == NULL)\n\t    return;\n\n\tfor (i=0; i<lh->num_nodes; i++)\n\t\t{\n\t\tn=lh->b[i];\n\t\twhile (n != NULL)\n\t\t\t{\n\t\t\tnn=n->next;\n\t\t\tOPENSSL_free(n);\n\t\t\tn=nn;\n\t\t\t}\n\t\t}\n\tOPENSSL_free(lh->b);\n\tOPENSSL_free(lh);\n\t}", "target": 1}
{"idx": 5488, "func": "static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)\n{\n    int log2_min_cb_size = sps->log2_min_cb_size;\n    int width            = sps->width;\n    int height           = sps->height;\n    int pic_size_in_ctb  = ((width  >> log2_min_cb_size) + 1) *\n                           ((height >> log2_min_cb_size) + 1);\n    int ctb_count        = sps->ctb_width * sps->ctb_height;\n    int min_pu_size      = sps->min_pu_width * sps->min_pu_height;\n\n    s->bs_width  = width  >> 3;\n    s->bs_height = height >> 3;\n\n    s->sao           = av_mallocz_array(ctb_count, sizeof(*s->sao));\n    s->deblock       = av_mallocz_array(ctb_count, sizeof(*s->deblock));\n    if (!s->sao || !s->deblock)\n        goto fail;\n\n    s->skip_flag    = av_malloc(pic_size_in_ctb);\n    s->tab_ct_depth = av_malloc(sps->min_cb_height * sps->min_cb_width);\n    if (!s->skip_flag || !s->tab_ct_depth)\n        goto fail;\n\n    s->cbf_luma = av_malloc(sps->min_tb_width * sps->min_tb_height);\n    s->tab_ipm  = av_mallocz(min_pu_size);\n    s->is_pcm   = av_malloc(min_pu_size);\n    if (!s->tab_ipm || !s->cbf_luma || !s->is_pcm)\n        goto fail;\n\n    s->filter_slice_edges = av_malloc(ctb_count);\n    s->tab_slice_address  = av_malloc(pic_size_in_ctb *\n                                      sizeof(*s->tab_slice_address));\n    s->qp_y_tab           = av_malloc(pic_size_in_ctb *\n                                      sizeof(*s->qp_y_tab));\n    if (!s->qp_y_tab || !s->filter_slice_edges || !s->tab_slice_address)\n        goto fail;\n\n    s->horizontal_bs = av_mallocz(2 * s->bs_width * (s->bs_height + 1));\n    s->vertical_bs   = av_mallocz(2 * s->bs_width * (s->bs_height + 1));\n    if (!s->horizontal_bs || !s->vertical_bs)\n        goto fail;\n\n    s->tab_mvf_pool = av_buffer_pool_init(min_pu_size * sizeof(MvField),\n                                          av_buffer_alloc);\n    s->rpl_tab_pool = av_buffer_pool_init(ctb_count * sizeof(RefPicListTab),\n                                          av_buffer_allocz);\n    if (!s->tab_mvf_pool || !s->rpl_tab_pool)\n        goto fail;\n\n    return 0;\n\nfail:\n    pic_arrays_free(s);\n    return AVERROR(ENOMEM);\n}", "target": 1}
{"idx": 5489, "func": "int ff_h264_fill_default_ref_list(H264Context *h)\n{\n    int i, len;\n\n    if (h->slice_type_nos == AV_PICTURE_TYPE_B) {\n        Picture *sorted[32];\n        int cur_poc, list;\n        int lens[2];\n\n        if (FIELD_PICTURE(h))\n            cur_poc = h->cur_pic_ptr->field_poc[h->picture_structure == PICT_BOTTOM_FIELD];\n        else\n            cur_poc = h->cur_pic_ptr->poc;\n\n        for (list = 0; list < 2; list++) {\n            len  = add_sorted(sorted,       h->short_ref, h->short_ref_count, cur_poc, 1 ^ list);\n            len += add_sorted(sorted + len, h->short_ref, h->short_ref_count, cur_poc, 0 ^ list);\n            assert(len <= 32);\n            len  = build_def_list(h->default_ref_list[list],       sorted,      len, 0, h->picture_structure);\n            len += build_def_list(h->default_ref_list[list] + len, h->long_ref, 16,  1, h->picture_structure);\n            assert(len <= 32);\n\n            if (len < h->ref_count[list])\n                memset(&h->default_ref_list[list][len], 0, sizeof(Picture) * (h->ref_count[list] - len));\n            lens[list] = len;\n        }\n\n        if (lens[0] == lens[1] && lens[1] > 1) {\n            for (i = 0; i < lens[0] &&\n                        h->default_ref_list[0][i].f.buf[0]->buffer ==\n                        h->default_ref_list[1][i].f.buf[0]->buffer; i++);\n            if (i == lens[0]) {\n                Picture tmp;\n                COPY_PICTURE(&tmp, &h->default_ref_list[1][0]);\n                COPY_PICTURE(&h->default_ref_list[1][0], &h->default_ref_list[1][1]);\n                COPY_PICTURE(&h->default_ref_list[1][1], &tmp);\n            }\n        }\n    } else {\n        len  = build_def_list(h->default_ref_list[0],       h->short_ref, h->short_ref_count, 0, h->picture_structure);\n        len += build_def_list(h->default_ref_list[0] + len, h-> long_ref, 16,                 1, h->picture_structure);\n        assert(len <= 32);\n        if (len < h->ref_count[0])\n            memset(&h->default_ref_list[0][len], 0, sizeof(Picture) * (h->ref_count[0] - len));\n    }\n#ifdef TRACE\n    for (i = 0; i < h->ref_count[0]; i++) {\n        tprintf(h->avctx, \"List0: %s fn:%d 0x%p\\n\",\n                (h->default_ref_list[0][i].long_ref ? \"LT\" : \"ST\"),\n                h->default_ref_list[0][i].pic_id,\n                h->default_ref_list[0][i].f.data[0]);\n    }\n    if (h->slice_type_nos == AV_PICTURE_TYPE_B) {\n        for (i = 0; i < h->ref_count[1]; i++) {\n            tprintf(h->avctx, \"List1: %s fn:%d 0x%p\\n\",\n                    (h->default_ref_list[1][i].long_ref ? \"LT\" : \"ST\"),\n                    h->default_ref_list[1][i].pic_id,\n                    h->default_ref_list[1][i].f.data[0]);\n        }\n    }\n#endif\n    return 0;\n}", "target": 1}
{"idx": 5490, "func": "static int decode_info_header(NUTContext *nut)\n{\n    AVFormatContext *s = nut->avf;\n    AVIOContext *bc    = s->pb;\n    uint64_t tmp, chapter_start, chapter_len;\n    unsigned int stream_id_plus1, count;\n    int chapter_id, i;\n    int64_t value, end;\n    char name[256], str_value[1024], type_str[256];\n    const char *type;\n    int *event_flags        = NULL;\n    AVChapter *chapter      = NULL;\n    AVStream *st            = NULL;\n    AVDictionary **metadata = NULL;\n    int metadata_flag       = 0;\n\n    end  = get_packetheader(nut, bc, 1, INFO_STARTCODE);\n    end += avio_tell(bc);\n\n    GET_V(stream_id_plus1, tmp <= s->nb_streams);\n    chapter_id    = get_s(bc);\n    chapter_start = ffio_read_varlen(bc);\n    chapter_len   = ffio_read_varlen(bc);\n    count         = ffio_read_varlen(bc);\n\n    if (chapter_id && !stream_id_plus1) {\n        int64_t start = chapter_start / nut->time_base_count;\n        chapter = avpriv_new_chapter(s, chapter_id,\n                                     nut->time_base[chapter_start %\n                                                    nut->time_base_count],\n                                     start, start + chapter_len, NULL);\n        metadata = &chapter->metadata;\n    } else if (stream_id_plus1) {\n        st       = s->streams[stream_id_plus1 - 1];\n        metadata = &st->metadata;\n        event_flags = &st->event_flags;\n        metadata_flag = AVSTREAM_EVENT_FLAG_METADATA_UPDATED;\n    } else {\n        metadata = &s->metadata;\n        event_flags = &s->event_flags;\n        metadata_flag = AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    }\n\n    for (i = 0; i < count; i++) {\n        get_str(bc, name, sizeof(name));\n        value = get_s(bc);\n        if (value == -1) {\n            type = \"UTF-8\";\n            get_str(bc, str_value, sizeof(str_value));\n        } else if (value == -2) {\n            get_str(bc, type_str, sizeof(type_str));\n            type = type_str;\n            get_str(bc, str_value, sizeof(str_value));\n        } else if (value == -3) {\n            type  = \"s\";\n            value = get_s(bc);\n        } else if (value == -4) {\n            type  = \"t\";\n            value = ffio_read_varlen(bc);\n        } else if (value < -4) {\n            type = \"r\";\n            get_s(bc);\n        } else {\n            type = \"v\";\n        }\n\n        if (stream_id_plus1 > s->nb_streams) {\n            av_log(s, AV_LOG_ERROR, \"invalid stream id for info packet\\n\");\n            continue;\n        }\n\n        if (!strcmp(type, \"UTF-8\")) {\n            if (chapter_id == 0 && !strcmp(name, \"Disposition\")) {\n                set_disposition_bits(s, str_value, stream_id_plus1 - 1);\n                continue;\n            }\n            if (metadata && av_strcasecmp(name, \"Uses\") &&\n                av_strcasecmp(name, \"Depends\") && av_strcasecmp(name, \"Replaces\")) {\n                if (event_flags)\n                    *event_flags |= metadata_flag;\n                av_dict_set(metadata, name, str_value, 0);\n            }\n        }\n    }\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n        av_log(s, AV_LOG_ERROR, \"info header checksum mismatch\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"idx": 5491, "func": "void ff_subblock_synthesis(RA144Context *ractx, const int16_t *lpc_coefs,\n                           int cba_idx, int cb1_idx, int cb2_idx,\n                           int gval, int gain)\n{\n    int16_t *block;\n    int m[3];\n\n    if (cba_idx) {\n        cba_idx += BLOCKSIZE/2 - 1;\n        ff_copy_and_dup(ractx->buffer_a, ractx->adapt_cb, cba_idx);\n        m[0] = (ff_irms(&ractx->adsp, ractx->buffer_a) * gval) >> 12;\n    } else {\n        m[0] = 0;\n    }\n    m[1] = (ff_cb1_base[cb1_idx] * gval) >> 8;\n    m[2] = (ff_cb2_base[cb2_idx] * gval) >> 8;\n    memmove(ractx->adapt_cb, ractx->adapt_cb + BLOCKSIZE,\n            (BUFFERSIZE - BLOCKSIZE) * sizeof(*ractx->adapt_cb));\n\n    block = ractx->adapt_cb + BUFFERSIZE - BLOCKSIZE;\n\n    add_wav(block, gain, cba_idx, m, cba_idx? ractx->buffer_a: NULL,\n            ff_cb1_vects[cb1_idx], ff_cb2_vects[cb2_idx]);\n\n    memcpy(ractx->curr_sblock, ractx->curr_sblock + BLOCKSIZE,\n           LPC_ORDER*sizeof(*ractx->curr_sblock));\n\n    if (ff_celp_lp_synthesis_filter(ractx->curr_sblock + LPC_ORDER, lpc_coefs,\n                                    block, BLOCKSIZE, LPC_ORDER, 1, 0, 0xfff))\n        memset(ractx->curr_sblock, 0, (LPC_ORDER+BLOCKSIZE)*sizeof(*ractx->curr_sblock));\n}", "target": 1}
{"idx": 5492, "func": "void ffv1_clear_slice_state(FFV1Context *f, FFV1Context *fs)\n{\n    int i, j;\n\n    for (i = 0; i < f->plane_count; i++) {\n        PlaneContext *p = &fs->plane[i];\n\n        p->interlace_bit_state[0] = 128;\n        p->interlace_bit_state[1] = 128;\n\n        if (fs->ac) {\n            if (f->initial_states[p->quant_table_index]) {\n                memcpy(p->state, f->initial_states[p->quant_table_index],\n                       CONTEXT_SIZE * p->context_count);\n            } else\n                memset(p->state, 128, CONTEXT_SIZE * p->context_count);\n        } else {\n            for (j = 0; j < p->context_count; j++) {\n                p->vlc_state[j].drift     = 0;\n                p->vlc_state[j].error_sum = 4;    //FFMAX((RANGE + 32)/64, 2);\n                p->vlc_state[j].bias      = 0;\n                p->vlc_state[j].count     = 1;\n            }\n        }\n    }\n}", "target": 1}
{"idx": 5493, "func": "void ff_slice_thread_free(AVCodecContext *avctx)\n{\n    SliceThreadContext *c = avctx->internal->thread_ctx;\n    int i;\n\n    pthread_mutex_lock(&c->current_job_lock);\n    c->done = 1;\n    pthread_cond_broadcast(&c->current_job_cond);\n    for (i = 0; i < c->thread_count; i++)\n        pthread_cond_broadcast(&c->progress_cond[i]);\n    pthread_mutex_unlock(&c->current_job_lock);\n\n    for (i=0; i<avctx->thread_count; i++)\n         pthread_join(c->workers[i], NULL);\n\n    for (i = 0; i < c->thread_count; i++) {\n        pthread_mutex_destroy(&c->progress_mutex[i]);\n        pthread_cond_destroy(&c->progress_cond[i]);\n    }\n\n    pthread_mutex_destroy(&c->current_job_lock);\n    pthread_cond_destroy(&c->current_job_cond);\n    pthread_cond_destroy(&c->last_job_cond);\n\n    av_freep(&c->entries);\n    av_freep(&c->progress_mutex);\n    av_freep(&c->progress_cond);\n\n    av_freep(&c->workers);\n    av_freep(&avctx->internal->thread_ctx);\n}", "target": 1}
{"idx": 5494, "func": "static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n                               const uint8_t *buf, int buf_size,\n                               int first_field)\n{\n    static const uint8_t header_prefix[]    = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n    static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 };\n    static const uint8_t header_prefixhr1[] = { 0x00, 0x00, 0x02, 0x80, 0x03 };\n    static const uint8_t header_prefixhr2[] = { 0x00, 0x00, 0x03, 0x8C, 0x03 };\n    int i, cid, ret;\n    int old_bit_depth = ctx->bit_depth;\n    int old_mb_height = ctx->mb_height;\n\n    if (buf_size < 0x280) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < 640).\\n\", buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5) &&\n        memcmp(buf, header_prefixhr1, 5) && memcmp(buf, header_prefixhr2, 5)) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n               buf[0], buf[1], buf[2], buf[3], buf[4]);\n        return AVERROR_INVALIDDATA;\n    }\n    if (buf[5] & 2) { /* interlaced */\n        ctx->cur_field = buf[5] & 1;\n        frame->interlaced_frame = 1;\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n    } else {\n        ctx->cur_field = 0;\n    }\n    ctx->mbaff = (buf[0x6] >> 5) & 1;\n\n    ctx->height = AV_RB16(buf + 0x18);\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n    switch(buf[0x21] >> 5) {\n    case 1: ctx->bit_depth = 8; break;\n    case 2: ctx->bit_depth = 10; break;\n    case 3: ctx->bit_depth = 12; break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"Unknown bitdepth indicator (%d)\\n\", buf[0x21] >> 5);\n        return AVERROR_INVALIDDATA;\n    }\n    ctx->avctx->bits_per_raw_sample = ctx->bit_depth;\n\n    ctx->is_444 = (buf[0x2C] >> 6) & 1;\n    if (ctx->is_444) {\n        if (ctx->bit_depth == 8) {\n            avpriv_request_sample(ctx->avctx, \"4:4:4 8 bits\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (ctx->bit_depth == 10) {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n            ctx->pix_fmt = AV_PIX_FMT_YUV444P10;\n        } else {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_12_444;\n            ctx->pix_fmt = AV_PIX_FMT_YUV444P12;\n        }\n    } else if (ctx->bit_depth == 12) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_12;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P12;\n    } else if (ctx->bit_depth == 10) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n    } else {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P;\n    }\n    if (ctx->bit_depth != old_bit_depth) {\n        ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n        ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n        ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,\n                          ff_zigzag_direct);\n    }\n\n    cid = AV_RB32(buf + 0x28);\n\n    if ((ret = dnxhd_init_vlc(ctx, cid)) < 0)\n        return ret;\n    if (ctx->mbaff && ctx->cid_table->cid != 1260)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive MB interlace flag in an unsupported profile.\\n\");\n\n    ctx->act = buf[0x2C] & 7;\n    if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive color transform in an unsupported profile.\\n\");\n\n    // make sure profile size constraints are respected\n    // DNx100 allows 1920->1440 and 1280->960 subsampling\n    if (ctx->width != ctx->cid_table->width &&\n        ctx->cid_table->width != DNXHD_VARIABLE) {\n        av_reduce(&ctx->avctx->sample_aspect_ratio.num,\n                  &ctx->avctx->sample_aspect_ratio.den,\n                  ctx->width, ctx->cid_table->width, 255);\n        ctx->width = ctx->cid_table->width;\n    }\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size (%d < %d).\\n\",\n               buf_size, ctx->cid_table->coding_unit_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->mb_width  = (ctx->width + 15)>> 4;\n    ctx->mb_height = buf[0x16d];\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n        ctx->height <<= 1;\n\n    av_log(ctx->avctx, AV_LOG_VERBOSE, \"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\\n\",\n           ctx->width, ctx->height, ctx->is_444 ? \"4:4\" : \"2:2\",\n           ctx->bit_depth, ctx->mbaff, ctx->act);\n\n    // Newer format supports variable mb_scan_index sizes\n    if (!memcmp(buf, header_prefixhr2, 5)) {\n        ctx->data_offset = 0x170 + (ctx->mb_height << 2);\n    } else {\n        if (ctx->mb_height > 68 ||\n            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"mb height too big: %d\\n\", ctx->mb_height);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->data_offset = 0x280;\n    }\n\n    if (buf_size < ctx->data_offset) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < %d).\\n\", buf_size, ctx->data_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->mb_height != old_mb_height) {\n        av_freep(&ctx->mb_scan_index);\n\n        ctx->mb_scan_index = av_mallocz_array(ctx->mb_height, sizeof(uint32_t));\n        if (!ctx->mb_scan_index)\n            return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < ctx->mb_height; i++) {\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n        ff_dlog(ctx->avctx, \"mb scan index %d, pos %d: %u\\n\", i, 0x170 + (i << 2), ctx->mb_scan_index[i]);\n        if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"invalid mb scan index (%u vs %u).\\n\",\n                   ctx->mb_scan_index[i], buf_size - ctx->data_offset);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5495, "func": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && nmemb && size)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 0}
{"idx": 5496, "func": "uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type,\n                                 int size)\n{\n    int elems = pkt->side_data_elems;\n\n    if ((unsigned)elems + 1 > INT_MAX / sizeof(*pkt->side_data))\n        return NULL;\n    if ((unsigned)size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)\n        return NULL;\n\n    pkt->side_data = av_realloc(pkt->side_data,\n                                (elems + 1) * sizeof(*pkt->side_data));\n    if (!pkt->side_data)\n        return NULL;\n\n    pkt->side_data[elems].data = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!pkt->side_data[elems].data)\n        return NULL;\n    pkt->side_data[elems].size = size;\n    pkt->side_data[elems].type = type;\n    pkt->side_data_elems++;\n\n    return pkt->side_data[elems].data;\n}", "target": 0}
{"idx": 5497, "func": "static void get_tag(AVFormatContext *s, const char *key, int type, int len, int type2_size)\n{\n    char *value;\n    int64_t off = avio_tell(s->pb);\n\n    if ((unsigned)len >= (UINT_MAX - 1) / 2)\n        return;\n\n    value = av_malloc(2 * len + 1);\n    if (!value)\n        goto finish;\n\n    if (type == 0) {         // UTF16-LE\n        avio_get_str16le(s->pb, len, value, 2 * len + 1);\n    } else if (type == -1) { // ASCII\n        avio_read(s->pb, value, len);\n        value[len]=0;\n    } else if (type == 1) {  // byte array\n        if (!strcmp(key, \"WM/Picture\")) { // handle cover art\n            asf_read_picture(s, len);\n        } else if (!strcmp(key, \"ID3\")) { // handle ID3 tag\n            get_id3_tag(s, len);\n        } else {\n            av_log(s, AV_LOG_VERBOSE, \"Unsupported byte array in tag %s.\\n\", key);\n        }\n        goto finish;\n    } else if (type > 1 && type <= 5) {  // boolean or DWORD or QWORD or WORD\n        uint64_t num = get_value(s->pb, type, type2_size);\n        snprintf(value, len, \"%\"PRIu64, num);\n    } else if (type == 6) { // (don't) handle GUID\n        av_log(s, AV_LOG_DEBUG, \"Unsupported GUID value in tag %s.\\n\", key);\n        goto finish;\n    } else {\n        av_log(s, AV_LOG_DEBUG,\n               \"Unsupported value type %d in tag %s.\\n\", type, key);\n        goto finish;\n    }\n    if (*value)\n        av_dict_set(&s->metadata, key, value, 0);\n\nfinish:\n    av_freep(&value);\n    avio_seek(s->pb, off + len, SEEK_SET);\n}", "target": 0}
{"idx": 5498, "func": "static void deinterlace_bottom_field(uint8_t *dst, int dst_wrap,\n                                    const uint8_t *src1, int src_wrap,\n                                    int width, int height)\n{\n    const uint8_t *src_m2, *src_m1, *src_0, *src_p1, *src_p2;\n    int y;\n\n    src_m2 = src1;\n    src_m1 = src1;\n    src_0=&src_m1[src_wrap];\n    src_p1=&src_0[src_wrap];\n    src_p2=&src_p1[src_wrap];\n    for(y=0;y<(height-2);y+=2) {\n        memcpy(dst,src_m1,width);\n        dst += dst_wrap;\n        deinterlace_line(dst,src_m2,src_m1,src_0,src_p1,src_p2,width);\n        src_m2 = src_0;\n        src_m1 = src_p1;\n        src_0 = src_p2;\n        src_p1 += 2*src_wrap;\n        src_p2 += 2*src_wrap;\n        dst += dst_wrap;\n    }\n    memcpy(dst,src_m1,width);\n    dst += dst_wrap;\n    /* do last line */\n    deinterlace_line(dst,src_m2,src_m1,src_0,src_0,src_0,width);\n}", "target": 1}
{"idx": 5499, "func": "int BN_sub_word(BIGNUM *a, BN_ULONG w)\n\t{\n\tint i;\n\n\tbn_check_top(a);\n\tw &= BN_MASK2;\n\n\t/* degenerate case: w is zero */\n\tif (!w) return 1;\n\t/* degenerate case: a is zero */\n\tif(BN_is_zero(a))\n\t\t{\n\t\ti = BN_set_word(a,w);\n\t\tif (i != 0)\n\t\t\tBN_set_negative(a, 1);\n\t\treturn i;\n\t\t}\n\t/* handle 'a' when negative */\n\tif (a->neg)\n\t\t{\n\t\ta->neg=0;\n\t\ti=BN_add_word(a,w);\n\t\ta->neg=1;\n\t\treturn(i);\n\t\t}\n\n\tif ((a->top == 1) && (a->d[0] < w))\n\t\t{\n\t\ta->d[0]=w-a->d[0];\n\t\ta->neg=1;\n\t\treturn(1);\n\t\t}\n\ti=0;\n\tfor (;;)\n\t\t{\n\t\tif (a->d[i] >= w)\n\t\t\t{\n\t\t\ta->d[i]-=w;\n\t\t\tbreak;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\ta->d[i]=(a->d[i]-w)&BN_MASK2;\n\t\t\ti++;\n\t\t\tw=1;\n\t\t\t}\n\t\t}\n\tif ((a->d[i] == 0) && (i == (a->top-1)))\n\t\ta->top--;\n\tbn_check_top(a);\n\treturn(1);\n\t}", "target": 1}
{"idx": 5500, "func": "enum WORK_STATE tls_post_process_client_hello(SSL *s, enum WORK_STATE wst)\n{\n    int al = SSL_AD_HANDSHAKE_FAILURE;\n    SSL_CIPHER *cipher;\n\n    if (wst == WORK_MORE_A) {\n        if (!s->hit) {\n            /* Let cert callback update server certificates if required */\n            if (s->cert->cert_cb) {\n                int rv = s->cert->cert_cb(s, s->cert->cert_cb_arg);\n                if (rv == 0) {\n                    al = SSL_AD_INTERNAL_ERROR;\n                    SSLerr(SSL_F_TLS_POST_PROCESS_CLIENT_HELLO, SSL_R_CERT_CB_ERROR);\n                    goto f_err;\n                }\n                if (rv < 0) {\n                    s->rwstate = SSL_X509_LOOKUP;\n                    return WORK_MORE_A;\n                }\n                s->rwstate = SSL_NOTHING;\n            }\n            cipher = ssl3_choose_cipher(s, s->session->ciphers, SSL_get_ciphers(s));\n\n            if (cipher == NULL) {\n                SSLerr(SSL_F_TLS_POST_PROCESS_CLIENT_HELLO, SSL_R_NO_SHARED_CIPHER);\n                goto f_err;\n            }\n            s->s3->tmp.new_cipher = cipher;\n            /* check whether we should disable session resumption */\n            if (s->not_resumable_session_cb != NULL)\n                s->session->not_resumable = s->not_resumable_session_cb(s,\n                    ((cipher->algorithm_mkey & (SSL_kDHE | SSL_kECDHE)) != 0));\n            if (s->session->not_resumable)\n                /* do not send a session ticket */\n                s->tlsext_ticket_expected = 0;\n        } else {\n            /* Session-id reuse */\n            s->s3->tmp.new_cipher = s->session->cipher;\n        }\n\n        if (!SSL_USE_SIGALGS(s) || !(s->verify_mode & SSL_VERIFY_PEER)) {\n            if (!ssl3_digest_cached_records(s, 0)) {\n                al = SSL_AD_INTERNAL_ERROR;\n                goto f_err;\n            }\n        }\n\n        /*-\n         * we now have the following setup.\n         * client_random\n         * cipher_list          - our prefered list of ciphers\n         * ciphers              - the clients prefered list of ciphers\n         * compression          - basically ignored right now\n         * ssl version is set   - sslv3\n         * s->session           - The ssl session has been setup.\n         * s->hit               - session reuse flag\n         * s->s3->tmp.new_cipher- the new cipher to use.\n         */\n\n        /* Handles TLS extensions that we couldn't check earlier */\n        if (s->version >= SSL3_VERSION) {\n            if (ssl_check_clienthello_tlsext_late(s) <= 0) {\n                SSLerr(SSL_F_TLS_POST_PROCESS_CLIENT_HELLO,\n                       SSL_R_CLIENTHELLO_TLSEXT);\n                goto f_err;\n            }\n        }\n\n        wst = WORK_MORE_B;\n    }\n#ifndef OPENSSL_NO_SRP\n    if (wst == WORK_MORE_B) {\n        int ret;\n        if ((ret = ssl_check_srp_ext_ClientHello(s, &al)) < 0) {\n            /*\n             * callback indicates further work to be done\n             */\n            s->rwstate = SSL_X509_LOOKUP;\n            return WORK_MORE_B;\n        }\n        if (ret != SSL_ERROR_NONE) {\n            /*\n             * This is not really an error but the only means to for\n             * a client to detect whether srp is supported.\n             */\n            if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY)\n                SSLerr(SSL_F_TLS_POST_PROCESS_CLIENT_HELLO,\n                           SSL_R_CLIENTHELLO_TLSEXT);\n            goto f_err;\n        }\n    }\n#endif\n    s->renegotiate = 2;\n\n    return WORK_FINISHED_STOP;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    ossl_statem_set_error(s);\n    return WORK_ERROR;\n}", "target": 0}
{"idx": 5501, "func": "static inline void mc_part_weighted(H264Context *h, int n, int square, int chroma_height, int delta,\n                           uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n                           int x_offset, int y_offset,\n                           qpel_mc_func *qpix_put, h264_chroma_mc_func chroma_put,\n                           h264_weight_func luma_weight_op, h264_weight_func chroma_weight_op,\n                           h264_biweight_func luma_weight_avg, h264_biweight_func chroma_weight_avg,\n                           int list0, int list1){\n    MpegEncContext * const s = &h->s;\n\n    dest_y  += 2*x_offset + 2*y_offset*h->  mb_linesize;\n    dest_cb +=   x_offset +   y_offset*h->mb_uvlinesize;\n    dest_cr +=   x_offset +   y_offset*h->mb_uvlinesize;\n    x_offset += 8*s->mb_x;\n    y_offset += 8*(s->mb_y >> MB_FIELD);\n\n    if(list0 && list1){\n        /* don't optimize for luma-only case, since B-frames usually\n         * use implicit weights => chroma too. */\n        uint8_t *tmp_cb = s->obmc_scratchpad;\n        uint8_t *tmp_cr = s->obmc_scratchpad + 8;\n        uint8_t *tmp_y  = s->obmc_scratchpad + 8*h->mb_uvlinesize;\n        int refn0 = h->ref_cache[0][ scan8[n] ];\n        int refn1 = h->ref_cache[1][ scan8[n] ];\n\n        mc_dir_part(h, &h->ref_list[0][refn0], n, square, chroma_height, delta, 0,\n                    dest_y, dest_cb, dest_cr,\n                    x_offset, y_offset, qpix_put, chroma_put);\n        mc_dir_part(h, &h->ref_list[1][refn1], n, square, chroma_height, delta, 1,\n                    tmp_y, tmp_cb, tmp_cr,\n                    x_offset, y_offset, qpix_put, chroma_put);\n\n        if(h->use_weight == 2){\n            int weight0 = h->implicit_weight[refn0][refn1];\n            int weight1 = 64 - weight0;\n            luma_weight_avg(  dest_y,  tmp_y,  h->  mb_linesize, 5, weight0, weight1, 0);\n            chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize, 5, weight0, weight1, 0);\n            chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize, 5, weight0, weight1, 0);\n        }else{\n            luma_weight_avg(dest_y, tmp_y, h->mb_linesize, h->luma_log2_weight_denom,\n                            h->luma_weight[0][refn0], h->luma_weight[1][refn1],\n                            h->luma_offset[0][refn0] + h->luma_offset[1][refn1]);\n            chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize, h->chroma_log2_weight_denom,\n                            h->chroma_weight[0][refn0][0], h->chroma_weight[1][refn1][0],\n                            h->chroma_offset[0][refn0][0] + h->chroma_offset[1][refn1][0]);\n            chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize, h->chroma_log2_weight_denom,\n                            h->chroma_weight[0][refn0][1], h->chroma_weight[1][refn1][1],\n                            h->chroma_offset[0][refn0][1] + h->chroma_offset[1][refn1][1]);\n        }\n    }else{\n        int list = list1 ? 1 : 0;\n        int refn = h->ref_cache[list][ scan8[n] ];\n        Picture *ref= &h->ref_list[list][refn];\n        mc_dir_part(h, ref, n, square, chroma_height, delta, list,\n                    dest_y, dest_cb, dest_cr, x_offset, y_offset,\n                    qpix_put, chroma_put);\n\n        luma_weight_op(dest_y, h->mb_linesize, h->luma_log2_weight_denom,\n                       h->luma_weight[list][refn], h->luma_offset[list][refn]);\n        if(h->use_weight_chroma){\n            chroma_weight_op(dest_cb, h->mb_uvlinesize, h->chroma_log2_weight_denom,\n                             h->chroma_weight[list][refn][0], h->chroma_offset[list][refn][0]);\n            chroma_weight_op(dest_cr, h->mb_uvlinesize, h->chroma_log2_weight_denom,\n                             h->chroma_weight[list][refn][1], h->chroma_offset[list][refn][1]);\n        }\n    }\n}", "target": 0}
{"idx": 5502, "func": "int RAND_load_file(const char *file, long bytes)\n{\n    unsigned char buf[RAND_FILE_SIZE];\n#ifndef OPENSSL_NO_POSIX_IO\n    struct stat sb;\n#endif\n    int i, n, ret = 0;\n    FILE *in;\n\n    if (bytes == 0)\n        return 0;\n\n    if ((in = openssl_fopen(file, \"rb\")) == NULL) {\n        RANDerr(RAND_F_RAND_LOAD_FILE, RAND_R_CANNOT_OPEN_FILE);\n        ERR_add_error_data(2, \"Filename=\", file);\n        return -1;\n    }\n\n#ifndef OPENSSL_NO_POSIX_IO\n    if (fstat(fileno(in), &sb) < 0) {\n        RANDerr(RAND_F_RAND_LOAD_FILE, RAND_R_INTERNAL_ERROR);\n        ERR_add_error_data(2, \"Filename=\", file);\n        return -1;\n    }\n\n    if (!S_ISREG(sb.st_mode) && bytes < 0)\n        bytes = 256;\n#endif\n    /*\n     * Don't buffer, because even if |file| is regular file, we have\n     * no control over the buffer, so why would we want a copy of its\n     * contents lying around?\n     */\n    setbuf(in, NULL);\n\n    for ( ; ; ) {\n        if (bytes > 0)\n            n = (bytes < RAND_FILE_SIZE) ? (int)bytes : RAND_FILE_SIZE;\n        else\n            n = RAND_FILE_SIZE;\n        i = fread(buf, 1, n, in);\n#ifdef EINTR\n        if (ferror(in) && errno == EINTR){\n            clearerr(in);\n            if (i == 0)\n                continue;\n        }\n#endif\n        if (i == 0)\n            break;\n\n        RAND_add(buf, i, (double)i);\n        ret += i;\n\n        /* If given a bytecount, and we did it, break. */\n        if (bytes > 0 && (bytes -= i) <= 0)\n            break;\n    }\n\n    OPENSSL_cleanse(buf, sizeof(buf));\n    fclose(in);\n    return ret;\n}", "target": 0}
{"idx": 5503, "func": "static int url_alloc_for_protocol (URLContext **puc, struct URLProtocol *up,\n                                   const char *filename, int flags)\n{\n    URLContext *uc;\n    int err;\n\n#if CONFIG_NETWORK\n    if (!ff_network_init())\n        return AVERROR(EIO);\n#endif\n    uc = av_mallocz(sizeof(URLContext) + strlen(filename) + 1);\n    if (!uc) {\n        err = AVERROR(ENOMEM);\n        goto fail;\n    }\n    uc->av_class = &urlcontext_class;\n    uc->filename = (char *) &uc[1];\n    strcpy(uc->filename, filename);\n    uc->prot = up;\n    uc->flags = flags;\n    uc->is_streamed = 0; /* default = not streamed */\n    uc->max_packet_size = 0; /* default: stream file */\n    if (up->priv_data_size) {\n        uc->priv_data = av_mallocz(up->priv_data_size);\n        if (up->priv_data_class) {\n            *(const AVClass**)uc->priv_data = up->priv_data_class;\n            av_opt_set_defaults(uc->priv_data);\n        }\n    }\n\n    *puc = uc;\n    return 0;\n fail:\n    *puc = NULL;\n#if CONFIG_NETWORK\n    ff_network_close();\n#endif\n    return err;\n}", "target": 1}
{"idx": 5504, "func": "static void truncpasses(Jpeg2000EncoderContext *s, Jpeg2000Tile *tile)\n{\n    int precno, compno, reslevelno, bandno, cblkno, lev;\n    Jpeg2000CodingStyle *codsty = &s->codsty;\n\n    for (compno = 0; compno < s->ncomponents; compno++){\n        Jpeg2000Component *comp = tile->comp + compno;\n\n        for (reslevelno = 0, lev = codsty->nreslevels-1; reslevelno < codsty->nreslevels; reslevelno++, lev--){\n            Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n\n            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++){\n                for (bandno = 0; bandno < reslevel->nbands ; bandno++){\n                    int bandpos = bandno + (reslevelno > 0);\n                    Jpeg2000Band *band = reslevel->band + bandno;\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_height * prec->nb_codeblocks_width; cblkno++){\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n                        cblk->ninclpasses = getcut(cblk, s->lambda,\n                                (int64_t)dwt_norms[codsty->transform == FF_DWT53][bandpos][lev] * (int64_t)band->i_stepsize >> 16);\n                    }\n                }\n            }\n        }\n    }\n}", "target": 0}
{"idx": 5505, "func": "static int test_zu(int i)\n{\n    char bio_buf[80];\n    const z_data *data = &zu_data[i];\n\n    BIO_snprintf(bio_buf, sizeof(bio_buf) - 1, data->format, data->value);\n    if (!TEST_str_eq(bio_buf, data->expected))\n        return 0;\n    return 1;\n}", "target": 0}
{"idx": 5506, "func": "int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int fix_len, cmpl = inl;\n    unsigned int b;\n\n    b = ctx->cipher->block_size;\n\n    if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))\n        cmpl = (cmpl + 7) / 8;\n\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        if (b == 1 && is_partially_overlapping(out, in, cmpl)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n\n        fix_len = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (fix_len < 0) {\n            *outl = 0;\n            return 0;\n        } else\n            *outl = fix_len;\n        return 1;\n    }\n\n    if (inl <= 0) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx->flags & EVP_CIPH_NO_PADDING)\n        return EVP_EncryptUpdate(ctx, out, outl, in, inl);\n\n    OPENSSL_assert(b <= sizeof(ctx->final));\n\n    if (ctx->final_used) {\n        /* see comment about PTRDIFF_T comparison above */\n        if (((PTRDIFF_T)out == (PTRDIFF_T)in)\n            || is_partially_overlapping(out, in, b)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        memcpy(out, ctx->final, b);\n        out += b;\n        fix_len = 1;\n    } else\n        fix_len = 0;\n\n    if (!EVP_EncryptUpdate(ctx, out, outl, in, inl))\n        return 0;\n\n    /*\n     * if we have 'decrypted' a multiple of block size, make sure we have a\n     * copy of this last block\n     */\n    if (b > 1 && !ctx->buf_len) {\n        *outl -= b;\n        ctx->final_used = 1;\n        memcpy(ctx->final, &out[*outl], b);\n    } else\n        ctx->final_used = 0;\n\n    if (fix_len)\n        *outl += b;\n\n    return 1;\n}", "target": 1}
{"idx": 5507, "func": "static int tta_decode_frame(AVCodecContext *avctx,\n        void *data, int *data_size,\n        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    TTAContext *s = avctx->priv_data;\n    int i;\n\n    init_get_bits(&s->gb, buf, buf_size*8);\n    {\n        int32_t predictors[s->channels];\n        TTAFilter filters[s->channels];\n        TTARice rices[s->channels];\n        int cur_chan = 0, framelen = s->frame_length;\n        int32_t *p;\n\n        // FIXME: seeking\n        s->total_frames--;\n        if (!s->total_frames && s->last_frame_length)\n            framelen = s->last_frame_length;\n\n        // init per channel states\n        for (i = 0; i < s->channels; i++) {\n            predictors[i] = 0;\n            ttafilter_init(&(filters[i]), ttafilter_configs[s->bps-1][0], ttafilter_configs[s->bps-1][1]);\n            rice_init(&(rices[i]), 10, 10);\n        }\n\n        for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n            int32_t *predictor = &(predictors[cur_chan]);\n            TTAFilter *filter = &(filters[cur_chan]);\n            TTARice *rice = &(rices[cur_chan]);\n            uint32_t unary, depth, k;\n            int32_t value;\n\n            unary = tta_get_unary(&s->gb);\n\n            if (unary == 0) {\n                depth = 0;\n                k = rice->k0;\n            } else {\n                depth = 1;\n                k = rice->k1;\n                unary--;\n            }\n\n            if (get_bits_left(&s->gb) < k)\n                return -1;\n\n            if (k) {\n                if (k > MIN_CACHE_BITS)\n                    return -1;\n                value = (unary << k) + get_bits(&s->gb, k);\n            } else\n                value = unary;\n\n            // FIXME: copy paste from original\n            switch (depth) {\n            case 1:\n                rice->sum1 += value - (rice->sum1 >> 4);\n                if (rice->k1 > 0 && rice->sum1 < shift_16[rice->k1])\n                    rice->k1--;\n                else if(rice->sum1 > shift_16[rice->k1 + 1])\n                    rice->k1++;\n                value += shift_1[rice->k0];\n            default:\n                rice->sum0 += value - (rice->sum0 >> 4);\n                if (rice->k0 > 0 && rice->sum0 < shift_16[rice->k0])\n                    rice->k0--;\n                else if(rice->sum0 > shift_16[rice->k0 + 1])\n                    rice->k0++;\n            }\n\n            // extract coded value\n#define UNFOLD(x) (((x)&1) ? (++(x)>>1) : (-(x)>>1))\n            *p = UNFOLD(value);\n\n            // run hybrid filter\n            ttafilter_process(filter, p, 0);\n\n            // fixed order prediction\n#define PRED(x, k) (int32_t)((((uint64_t)x << k) - x) >> k)\n            switch (s->bps) {\n                case 1: *p += PRED(*predictor, 4); break;\n                case 2:\n                case 3: *p += PRED(*predictor, 5); break;\n                case 4: *p += *predictor; break;\n            }\n            *predictor = *p;\n\n#if 0\n            // extract 32bit float from last two int samples\n            if (s->is_float && ((p - data) & 1)) {\n                uint32_t neg = *p & 0x80000000;\n                uint32_t hi = *(p - 1);\n                uint32_t lo = abs(*p) - 1;\n\n                hi += (hi || lo) ? 0x3f80 : 0;\n                // SWAP16: swap all the 16 bits\n                *(p - 1) = (hi << 16) | SWAP16(lo) | neg;\n            }\n#endif\n\n            /*if ((get_bits_count(&s->gb)+7)/8 > buf_size)\n            {\n                av_log(NULL, AV_LOG_INFO, \"overread!!\\n\");\n                break;\n            }*/\n\n            // flip channels\n            if (cur_chan < (s->channels-1))\n                cur_chan++;\n            else {\n                // decorrelate in case of stereo integer\n                if (!s->is_float && (s->channels > 1)) {\n                    int32_t *r = p - 1;\n                    for (*p += *r / 2; r > p - s->channels; r--)\n                        *r = *(r + 1) - *r;\n                }\n                cur_chan = 0;\n            }\n        }\n\n        if (get_bits_left(&s->gb) < 32)\n            return -1;\n        skip_bits(&s->gb, 32); // frame crc\n\n        // convert to output buffer\n        switch(s->bps) {\n            case 2: {\n                uint16_t *samples = data;\n                for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n//                    *samples++ = (unsigned char)*p;\n//                    *samples++ = (unsigned char)(*p >> 8);\n                    *samples++ = *p;\n                }\n                *data_size = (uint8_t *)samples - (uint8_t *)data;\n                break;\n            }\n            default:\n                av_log(s->avctx, AV_LOG_ERROR, \"Error, only 16bit samples supported!\\n\");\n        }\n    }\n\n//    return get_bits_count(&s->gb)+7)/8;\n    return buf_size;\n}", "target": 0}
{"idx": 5508, "func": "int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)\n{\n    unsigned char *p;\n    int i;\n    switch (gen->type) {\n    case GEN_OTHERNAME:\n        BIO_printf(out, \"othername:<unsupported>\");\n        break;\n\n    case GEN_X400:\n        BIO_printf(out, \"X400Name:<unsupported>\");\n        break;\n\n    case GEN_EDIPARTY:\n        /* Maybe fix this: it is supported now */\n        BIO_printf(out, \"EdiPartyName:<unsupported>\");\n        break;\n\n    case GEN_EMAIL:\n        BIO_printf(out, \"email:%s\", gen->d.ia5->data);\n        break;\n\n    case GEN_DNS:\n        BIO_printf(out, \"DNS:%s\", gen->d.ia5->data);\n        break;\n\n    case GEN_URI:\n        BIO_printf(out, \"URI:%s\", gen->d.ia5->data);\n        break;\n\n    case GEN_DIRNAME:\n        BIO_printf(out, \"DirName:\");\n        X509_NAME_print_ex(out, gen->d.dirn, 0, XN_FLAG_ONELINE);\n        break;\n\n    case GEN_IPADD:\n        p = gen->d.ip->data;\n        if (gen->d.ip->length == 4)\n            BIO_printf(out, \"IP Address:%d.%d.%d.%d\", p[0], p[1], p[2], p[3]);\n        else if (gen->d.ip->length == 16) {\n            BIO_printf(out, \"IP Address\");\n            for (i = 0; i < 8; i++) {\n                BIO_printf(out, \":%X\", p[0] << 8 | p[1]);\n                p += 2;\n            }\n            BIO_puts(out, \"\\n\");\n        } else {\n            BIO_printf(out, \"IP Address:<invalid>\");\n            break;\n        }\n        break;\n\n    case GEN_RID:\n        BIO_printf(out, \"Registered ID:\");\n        i2a_ASN1_OBJECT(out, gen->d.rid);\n        break;\n    }\n    return 1;\n}", "target": 0}
{"idx": 5509, "func": "static int normalize_bits(int num, int width)\n{\n    int i = 0;\n    int bits = (width) ? 31 : 15;\n    int limit = 1 << (bits - 1);\n\n    if (num) {\n        if (num == -1)\n            return bits;\n        if (num < 0)\n            num = ~num;\n        for (i = 0; num < limit; i++)\n            num <<= 1;\n    }\n    return i;\n}", "target": 1}
{"idx": 5510, "func": "int CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len)\n{\n    size_t i;\n    const unsigned char *a = in_a;\n    const unsigned char *b = in_b;\n    unsigned char x = 0;\n\n    for (i = 0; i < len; i++)\n        x |= a[i] ^ b[i];\n\n    return x;\n}", "target": 1}
{"idx": 5511, "func": "void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    /* let's disallow possible ambiguous cases */\n    if(size > (INT_MAX-16) )\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    //FIXME this isn't aligned correctly, though it probably isn't needed\n    if(!ptr) return av_malloc(size);\n    diff= ((char*)ptr)[-1];\n    return (char*)realloc((char*)ptr - diff, size + diff) + diff;\n#else\n    return realloc(ptr, size);\n#endif\n}", "target": 1}
{"idx": 5512, "func": "static inline\nvoid compute_images_mse_16bit(PSNRContext *s,\n                        const uint8_t *main_data[4], const int main_linesizes[4],\n                        const uint8_t *ref_data[4], const int ref_linesizes[4],\n                        int w, int h, double mse[4])\n{\n    int i, c, j;\n\n    for (c = 0; c < s->nb_components; c++) {\n        const int outw = s->planewidth[c];\n        const int outh = s->planeheight[c];\n        const uint16_t *main_line = (uint16_t *)main_data[c];\n        const uint16_t *ref_line = (uint16_t *)ref_data[c];\n        const int ref_linesize = ref_linesizes[c] / 2;\n        const int main_linesize = main_linesizes[c] / 2;\n        uint64_t m = 0;\n\n        for (i = 0; i < outh; i++) {\n            for (j = 0; j < outw; j++)\n                m += pow2(main_line[j] - ref_line[j]);\n            ref_line += ref_linesize;\n            main_line += main_linesize;\n        }\n        mse[c] = m / (double)(outw * outh);\n    }\n}", "target": 1}
{"idx": 5513, "func": "static av_always_inline\nvoid decode_mb_coeffs(VP8Context *s, VP8ThreadData *td, VP56RangeCoder *c,\n                      VP8Macroblock *mb, uint8_t t_nnz[9], uint8_t l_nnz[9],\n                      int is_vp7)\n{\n    int i, x, y, luma_start = 0, luma_ctx = 3;\n    int nnz_pred, nnz, nnz_total = 0;\n    int segment = mb->segment;\n    int block_dc = 0;\n\n    if (mb->mode != MODE_I4x4 && (is_vp7 || mb->mode != VP8_MVMODE_SPLIT)) {\n        nnz_pred = t_nnz[8] + l_nnz[8];\n\n        // decode DC values and do hadamard\n        nnz = decode_block_coeffs(c, td->block_dc, s->prob->token[1], 0,\n                                  nnz_pred, s->qmat[segment].luma_dc_qmul,\n                                  zigzag_scan, is_vp7);\n        l_nnz[8] = t_nnz[8] = !!nnz;\n\n        if (is_vp7 && mb->mode > MODE_I4x4) {\n            nnz |=  inter_predict_dc(td->block_dc,\n                                     s->inter_dc_pred[mb->ref_frame - 1]);\n        }\n\n        if (nnz) {\n            nnz_total += nnz;\n            block_dc   = 1;\n            if (nnz == 1)\n                s->vp8dsp.vp8_luma_dc_wht_dc(td->block, td->block_dc);\n            else\n                s->vp8dsp.vp8_luma_dc_wht(td->block, td->block_dc);\n        }\n        luma_start = 1;\n        luma_ctx   = 0;\n    }\n\n    // luma blocks\n    for (y = 0; y < 4; y++)\n        for (x = 0; x < 4; x++) {\n            nnz_pred = l_nnz[y] + t_nnz[x];\n            nnz = decode_block_coeffs(c, td->block[y][x],\n                                      s->prob->token[luma_ctx],\n                                      luma_start, nnz_pred,\n                                      s->qmat[segment].luma_qmul,\n                                      s->prob[0].scan, is_vp7);\n            /* nnz+block_dc may be one more than the actual last index,\n             * but we don't care */\n            td->non_zero_count_cache[y][x] = nnz + block_dc;\n            t_nnz[x] = l_nnz[y] = !!nnz;\n            nnz_total += nnz;\n        }\n\n    // chroma blocks\n    // TODO: what to do about dimensions? 2nd dim for luma is x,\n    // but for chroma it's (y<<1)|x\n    for (i = 4; i < 6; i++)\n        for (y = 0; y < 2; y++)\n            for (x = 0; x < 2; x++) {\n                nnz_pred = l_nnz[i + 2 * y] + t_nnz[i + 2 * x];\n                nnz = decode_block_coeffs(c, td->block[i][(y << 1) + x],\n                                          s->prob->token[2], 0, nnz_pred,\n                                          s->qmat[segment].chroma_qmul,\n                                          s->prob[0].scan, is_vp7);\n                td->non_zero_count_cache[i][(y << 1) + x] = nnz;\n                t_nnz[i + 2 * x] = l_nnz[i + 2 * y] = !!nnz;\n                nnz_total += nnz;\n            }\n\n    // if there were no coded coeffs despite the macroblock not being marked skip,\n    // we MUST not do the inner loop filter and should not do IDCT\n    // Since skip isn't used for bitstream prediction, just manually set it.\n    if (!nnz_total)\n        mb->skip = 1;\n}", "target": 0}
{"idx": 5514, "func": "static inline int hpel_motion_lowres(MpegEncContext *s,\n                                     uint8_t *dest, uint8_t *src,\n                                     int field_based, int field_select,\n                                     int src_x, int src_y,\n                                     int width, int height, int stride,\n                                     int h_edge_pos, int v_edge_pos,\n                                     int w, int h, h264_chroma_mc_func *pix_op,\n                                     int motion_x, int motion_y)\n{\n    const int lowres   = s->avctx->lowres;\n    const int op_index = FFMIN(lowres, 3);\n    const int s_mask   = (2 << lowres) - 1;\n    int emu = 0;\n    int sx, sy;\n\n    if (s->quarter_sample) {\n        motion_x /= 2;\n        motion_y /= 2;\n    }\n\n    sx = motion_x & s_mask;\n    sy = motion_y & s_mask;\n    src_x += motion_x >> lowres + 1;\n    src_y += motion_y >> lowres + 1;\n\n    src   += src_y * stride + src_x;\n\n    if ((unsigned)src_x > FFMAX( h_edge_pos - (!!sx) - w,                 0) ||\n        (unsigned)src_y > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, src, s->linesize, w + 1,\n                                (h + 1) << field_based, src_x,\n                                src_y   << field_based,\n                                h_edge_pos,\n                                v_edge_pos);\n        src = s->edge_emu_buffer;\n        emu = 1;\n    }\n\n    sx = (sx << 2) >> lowres;\n    sy = (sy << 2) >> lowres;\n    if (field_select)\n        src += s->linesize;\n    pix_op[op_index](dest, src, stride, h, sx, sy);\n    return emu;\n}", "target": 1}
{"idx": 5515, "func": "static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n                        const AVFrame *pic, int *got_packet)\n{\n    ProresContext *ctx = avctx->priv_data;\n    uint8_t *orig_buf, *buf, *slice_hdr, *slice_sizes, *tmp;\n    uint8_t *picture_size_pos;\n    PutBitContext pb;\n    int x, y, i, mb, q = 0;\n    int sizes[4] = { 0 };\n    int slice_hdr_size = 2 + 2 * (ctx->num_planes - 1);\n    int frame_size, picture_size, slice_size;\n    int pkt_size, ret, max_slice_size = 0;\n    uint8_t frame_flags;\n\n    *avctx->coded_frame           = *pic;\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n    avctx->coded_frame->key_frame = 1;\n\n    pkt_size = ctx->frame_size_upper_bound;\n\n    if ((ret = ff_alloc_packet(pkt, pkt_size + FF_MIN_BUFFER_SIZE)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");\n        return ret;\n    }\n\n    orig_buf = pkt->data;\n\n    // frame atom\n    orig_buf += 4;                              // frame size\n    bytestream_put_be32  (&orig_buf, FRAME_ID); // frame container ID\n    buf = orig_buf;\n\n    // frame header\n    tmp = buf;\n    buf += 2;                                   // frame header size will be stored here\n    bytestream_put_be16  (&buf, 0);             // version 1\n    bytestream_put_buffer(&buf, ctx->vendor, 4);\n    bytestream_put_be16  (&buf, avctx->width);\n    bytestream_put_be16  (&buf, avctx->height);\n\n    frame_flags = ctx->chroma_factor << 6;\n    if (avctx->flags & CODEC_FLAG_INTERLACED_DCT)\n        frame_flags |= pic->top_field_first ? 0x04 : 0x08;\n    bytestream_put_byte  (&buf, frame_flags);\n\n    bytestream_put_byte  (&buf, 0);             // reserved\n    bytestream_put_byte  (&buf, avctx->color_primaries);\n    bytestream_put_byte  (&buf, avctx->color_trc);\n    bytestream_put_byte  (&buf, avctx->colorspace);\n    bytestream_put_byte  (&buf, 0x40 | (ctx->alpha_bits >> 3));\n    bytestream_put_byte  (&buf, 0);             // reserved\n    if (ctx->quant_sel != QUANT_MAT_DEFAULT) {\n        bytestream_put_byte  (&buf, 0x03);      // matrix flags - both matrices are present\n        // luma quantisation matrix\n        for (i = 0; i < 64; i++)\n            bytestream_put_byte(&buf, ctx->quant_mat[i]);\n        // chroma quantisation matrix\n        for (i = 0; i < 64; i++)\n            bytestream_put_byte(&buf, ctx->quant_mat[i]);\n    } else {\n        bytestream_put_byte  (&buf, 0x00);      // matrix flags - default matrices are used\n    }\n    bytestream_put_be16  (&tmp, buf - orig_buf); // write back frame header size\n\n    for (ctx->cur_picture_idx = 0;\n         ctx->cur_picture_idx < ctx->pictures_per_frame;\n         ctx->cur_picture_idx++) {\n        // picture header\n        picture_size_pos = buf + 1;\n        bytestream_put_byte  (&buf, 0x40);          // picture header size (in bits)\n        buf += 4;                                   // picture data size will be stored here\n        bytestream_put_be16  (&buf, ctx->slices_per_picture);\n        bytestream_put_byte  (&buf, av_log2(ctx->mbs_per_slice) << 4); // slice width and height in MBs\n\n        // seek table - will be filled during slice encoding\n        slice_sizes = buf;\n        buf += ctx->slices_per_picture * 2;\n\n        // slices\n        if (!ctx->force_quant) {\n            ret = avctx->execute2(avctx, find_quant_thread, NULL, NULL,\n                                  ctx->mb_height);\n            if (ret)\n                return ret;\n        }\n\n        for (y = 0; y < ctx->mb_height; y++) {\n            int mbs_per_slice = ctx->mbs_per_slice;\n            for (x = mb = 0; x < ctx->mb_width; x += mbs_per_slice, mb++) {\n                q = ctx->force_quant ? ctx->force_quant\n                                     : ctx->slice_q[mb + y * ctx->slices_width];\n\n                while (ctx->mb_width - x < mbs_per_slice)\n                    mbs_per_slice >>= 1;\n\n                bytestream_put_byte(&buf, slice_hdr_size << 3);\n                slice_hdr = buf;\n                buf += slice_hdr_size - 1;\n                if (pkt_size <= buf - orig_buf + 2 * max_slice_size) {\n                    uint8_t *start = pkt->data;\n                    // Recompute new size according to max_slice_size\n                    // and deduce delta\n                    int delta = 200 + ctx->pictures_per_frame *\n                                ctx->slices_per_picture * max_slice_size -\n                                pkt_size;\n\n                    delta = FFMAX(delta, 2 * max_slice_size);\n                    ctx->frame_size_upper_bound += delta;\n\n                    if (!ctx->warn) {\n                        avpriv_request_sample(avctx,\n                                              \"Packet too small: is %i,\"\n                                              \" needs %i (slice: %i). \"\n                                              \"Correct allocation\",\n                                              pkt_size, delta, max_slice_size);\n                        ctx->warn = 1;\n                    }\n\n                    ret = av_grow_packet(pkt, delta);\n                    if (ret < 0)\n                        return ret;\n\n                    pkt_size += delta;\n                    // restore pointers\n                    orig_buf         = pkt->data + (orig_buf         - start);\n                    buf              = pkt->data + (buf              - start);\n                    picture_size_pos = pkt->data + (picture_size_pos - start);\n                    slice_sizes      = pkt->data + (slice_sizes      - start);\n                    slice_hdr        = pkt->data + (slice_hdr        - start);\n                    tmp              = pkt->data + (tmp              - start);\n                }\n                init_put_bits(&pb, buf, (pkt_size - (buf - orig_buf)) * 8);\n                ret = encode_slice(avctx, pic, &pb, sizes, x, y, q,\n                                   mbs_per_slice);\n                if (ret < 0)\n                    return ret;\n\n                bytestream_put_byte(&slice_hdr, q);\n                slice_size = slice_hdr_size + sizes[ctx->num_planes - 1];\n                for (i = 0; i < ctx->num_planes - 1; i++) {\n                    bytestream_put_be16(&slice_hdr, sizes[i]);\n                    slice_size += sizes[i];\n                }\n                bytestream_put_be16(&slice_sizes, slice_size);\n                buf += slice_size - slice_hdr_size;\n                if (max_slice_size < slice_size)\n                    max_slice_size = slice_size;\n            }\n        }\n\n        if (ctx->pictures_per_frame == 1)\n            picture_size = buf - picture_size_pos - 6;\n        else\n            picture_size = buf - picture_size_pos + 1;\n        bytestream_put_be32(&picture_size_pos, picture_size);\n    }\n\n    orig_buf -= 8;\n    frame_size = buf - orig_buf;\n    bytestream_put_be32(&orig_buf, frame_size);\n\n    pkt->size   = frame_size;\n    pkt->flags |= AV_PKT_FLAG_KEY;\n    *got_packet = 1;\n\n    return 0;\n}", "target": 0}
{"idx": 5516, "func": "static int decode_block_coeffs(VP56RangeCoder *c, DCTELEM block[16],\n                               uint8_t probs[8][3][NUM_DCT_TOKENS-1],\n                               int i, int zero_nhood, int16_t qmul[2])\n{\n    uint8_t *token_prob;\n    int nonzero = 0;\n    int coeff;\n\n    do {\n        token_prob = probs[vp8_coeff_band[i]][zero_nhood];\n\n        if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB\n            return nonzero;\n\nskip_eob:\n        if (!vp56_rac_get_prob_branchy(c, token_prob[1])) { // DCT_0\n            if (++i == 16)\n                return nonzero; // invalid input; blocks should end with EOB\n            zero_nhood = 0;\n            token_prob = probs[vp8_coeff_band[i]][0];\n            goto skip_eob;\n        }\n\n        if (!vp56_rac_get_prob_branchy(c, token_prob[2])) { // DCT_1\n            coeff = 1;\n            zero_nhood = 1;\n        } else {\n            zero_nhood = 2;\n\n            if (!vp56_rac_get_prob_branchy(c, token_prob[3])) { // DCT 2,3,4\n                coeff = vp56_rac_get_prob(c, token_prob[4]);\n                if (coeff)\n                    coeff += vp56_rac_get_prob(c, token_prob[5]);\n                coeff += 2;\n            } else {\n                // DCT_CAT*\n                if (!vp56_rac_get_prob_branchy(c, token_prob[6])) {\n                    if (!vp56_rac_get_prob_branchy(c, token_prob[7])) { // DCT_CAT1\n                        coeff  = 5 + vp56_rac_get_prob(c, vp8_dct_cat1_prob[0]);\n                    } else {                                    // DCT_CAT2\n                        coeff  = 7;\n                        coeff += vp56_rac_get_prob(c, vp8_dct_cat2_prob[0]) << 1;\n                        coeff += vp56_rac_get_prob(c, vp8_dct_cat2_prob[1]);\n                    }\n                } else {    // DCT_CAT3 and up\n                    int a = vp56_rac_get_prob(c, token_prob[8]);\n                    int b = vp56_rac_get_prob(c, token_prob[9+a]);\n                    int cat = (a<<1) + b;\n                    coeff  = 3 + (8<<cat);\n                    coeff += vp8_rac_get_coeff(c, vp8_dct_cat_prob[cat]);\n                }\n            }\n        }\n\n        // todo: full [16] qmat? load into register?\n        block[zigzag_scan[i]] = (vp8_rac_get(c) ? -coeff : coeff) * qmul[!!i];\n        nonzero = ++i;\n    } while (i < 16);\n\n    return nonzero;\n}", "target": 0}
{"idx": 5517, "func": "static inline int silk_is_lpc_stable(const int16_t lpc[16], int order)\n{\n    int k, j, DC_resp = 0;\n    int32_t lpc32[2][16];       // Q24\n    int totalinvgain = 1 << 30; // 1.0 in Q30\n    int32_t *row = lpc32[0], *prevrow;\n\n    /* initialize the first row for the Levinson recursion */\n    for (k = 0; k < order; k++) {\n        DC_resp += lpc[k];\n        row[k] = lpc[k] * 4096;\n    }\n\n    if (DC_resp >= 4096)\n        return 0;\n\n    /* check if prediction gain pushes any coefficients too far */\n    for (k = order - 1; 1; k--) {\n        int rc;      // Q31; reflection coefficient\n        int gaindiv; // Q30; inverse of the gain (the divisor)\n        int gain;    // gain for this reflection coefficient\n        int fbits;   // fractional bits used for the gain\n        int error;   // Q29; estimate of the error of our partial estimate of 1/gaindiv\n\n        if (FFABS(row[k]) > 16773022)\n            return 0;\n\n        rc      = -(row[k] * 128);\n        gaindiv = (1 << 30) - MULH(rc, rc);\n\n        totalinvgain = MULH(totalinvgain, gaindiv) << 2;\n        if (k == 0)\n            return (totalinvgain >= 107374);\n\n        /* approximate 1.0/gaindiv */\n        fbits = opus_ilog(gaindiv);\n        gain  = ((1 << 29) - 1) / (gaindiv >> (fbits + 1 - 16)); // Q<fbits-16>\n        error = (1 << 29) - MULL(gaindiv << (15 + 16 - fbits), gain, 16);\n        gain  = ((gain << 16) + (error * gain >> 13));\n\n        /* switch to the next row of the LPC coefficients */\n        prevrow = row;\n        row = lpc32[k & 1];\n\n        for (j = 0; j < k; j++) {\n            int x = prevrow[j] - ROUND_MULL(prevrow[k - j - 1], rc, 31);\n            row[j] = ROUND_MULL(x, gain, fbits);\n        }\n    }\n}", "target": 1}
{"idx": 5518, "func": "static inline int wv_unpack_mono(WavpackFrameContext *s, GetBitContext *gb,\n                                 void *dst, const int type)\n{\n    int i, j, count = 0;\n    int last, t;\n    int A, S, T;\n    int pos                  = s->pos;\n    uint32_t crc             = s->sc.crc;\n    uint32_t crc_extra_bits  = s->extra_sc.crc;\n    int16_t *dst16           = dst;\n    int32_t *dst32           = dst;\n    float *dstfl             = dst;\n\n    s->one = s->zero = s->zeroes = 0;\n    do {\n        T = wv_get_value(s, gb, 0, &last);\n        S = 0;\n        if (last)\n            break;\n        for (i = 0; i < s->terms; i++) {\n            t = s->decorr[i].value;\n            if (t > 8) {\n                if (t & 1)\n                    A =  2U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1];\n                else\n                    A = (int)(3U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1]) >> 1;\n                s->decorr[i].samplesA[1] = s->decorr[i].samplesA[0];\n                j                        = 0;\n            } else {\n                A = s->decorr[i].samplesA[pos];\n                j = (pos + t) & 7;\n            }\n            if (type != AV_SAMPLE_FMT_S16P)\n                S = T + ((s->decorr[i].weightA * (int64_t)A + 512) >> 10);\n            else\n                S = T + ((s->decorr[i].weightA * A + 512) >> 10);\n            if (A && T)\n                s->decorr[i].weightA -= ((((T ^ A) >> 30) & 2) - 1) * s->decorr[i].delta;\n            s->decorr[i].samplesA[j] = T = S;\n        }\n        pos = (pos + 1) & 7;\n        crc = crc * 3 + S;\n\n        if (type == AV_SAMPLE_FMT_FLTP) {\n            *dstfl++ = wv_get_value_float(s, &crc_extra_bits, S);\n        } else if (type == AV_SAMPLE_FMT_S32P) {\n            *dst32++ = wv_get_value_integer(s, &crc_extra_bits, S);\n        } else {\n            *dst16++ = wv_get_value_integer(s, &crc_extra_bits, S);\n        }\n        count++;\n    } while (!last && count < s->samples);\n\n    wv_reset_saved_context(s);\n\n    if (last && count < s->samples) {\n        int size = av_get_bytes_per_sample(type);\n        memset((uint8_t*)dst + count*size, 0, (s->samples-count)*size);\n    }\n\n    if (s->avctx->err_recognition & AV_EF_CRCCHECK) {\n        int ret = wv_check_crc(s, crc, crc_extra_bits);\n        if (ret < 0 && s->avctx->err_recognition & AV_EF_EXPLODE)\n            return ret;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5519, "func": "int SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c)\n{\n    int ret = 0;\n    SSL_SESSION *s;\n\n    /*\n     * add just 1 reference count for the SSL_CTX's session cache even though\n     * it has two ways of access: each session is in a doubly linked list and\n     * an lhash\n     */\n    SSL_SESSION_up_ref(c);\n    /*\n     * if session c is in already in cache, we take back the increment later\n     */\n\n    CRYPTO_THREAD_write_lock(ctx->lock);\n    s = lh_SSL_SESSION_insert(ctx->sessions, c);\n\n    /*\n     * s != NULL iff we already had a session with the given PID. In this\n     * case, s == c should hold (then we did not really modify\n     * ctx->sessions), or we're in trouble.\n     */\n    if (s != NULL && s != c) {\n        /* We *are* in trouble ... */\n        SSL_SESSION_list_remove(ctx, s);\n        SSL_SESSION_free(s);\n        /*\n         * ... so pretend the other session did not exist in cache (we cannot\n         * handle two SSL_SESSION structures with identical session ID in the\n         * same cache, which could happen e.g. when two threads concurrently\n         * obtain the same session from an external cache)\n         */\n        s = NULL;\n    } else if (s == NULL &&\n               lh_SSL_SESSION_retrieve(ctx->sessions, c) == NULL) {\n        /* s == NULL can also mean OOM error in lh_SSL_SESSION_insert ... */\n\n        /*\n         * ... so take back the extra reference and also don't add\n         * the session to the SSL_SESSION_list at this time\n         */\n        s = c;\n    }\n\n    /* Put at the head of the queue unless it is already in the cache */\n    if (s == NULL)\n        SSL_SESSION_list_add(ctx, c);\n\n    if (s != NULL) {\n        /*\n         * existing cache entry -- decrement previously incremented reference\n         * count because it already takes into account the cache\n         */\n\n        SSL_SESSION_free(s);    /* s == c */\n        ret = 0;\n    } else {\n        /*\n         * new cache entry -- remove old ones if cache has become too large\n         */\n\n        ret = 1;\n\n        if (SSL_CTX_sess_get_cache_size(ctx) > 0) {\n            while (SSL_CTX_sess_number(ctx) > SSL_CTX_sess_get_cache_size(ctx)) {\n                if (!remove_session_lock(ctx, ctx->session_cache_tail, 0))\n                    break;\n                else\n                    ctx->stats.sess_cache_full++;\n            }\n        }\n    }\n    CRYPTO_THREAD_unlock(ctx->lock);\n    return ret;\n}", "target": 0}
{"idx": 5520, "func": "int tls1_check_chain(SSL *s, X509 *x, EVP_PKEY *pk, STACK_OF(X509) *chain,\n                     int idx)\n{\n    int i;\n    int rv = 0;\n    int check_flags = 0, strict_mode;\n    CERT_PKEY *cpk = NULL;\n    CERT *c = s->cert;\n    uint32_t *pvalid;\n    unsigned int suiteb_flags = tls1_suiteb(s);\n    /* idx == -1 means checking server chains */\n    if (idx != -1) {\n        /* idx == -2 means checking client certificate chains */\n        if (idx == -2) {\n            cpk = c->key;\n            idx = cpk - c->pkeys;\n        } else\n            cpk = c->pkeys + idx;\n        pvalid = s->s3->tmp.valid_flags + idx;\n        x = cpk->x509;\n        pk = cpk->privatekey;\n        chain = cpk->chain;\n        strict_mode = c->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT;\n        /* If no cert or key, forget it */\n        if (!x || !pk)\n            goto end;\n#ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL\n        /* Allow any certificate to pass test */\n        if (s->cert->cert_flags & SSL_CERT_FLAG_BROKEN_PROTOCOL) {\n            rv = CERT_PKEY_STRICT_FLAGS | CERT_PKEY_EXPLICIT_SIGN |\n                CERT_PKEY_VALID | CERT_PKEY_SIGN;\n            *pvalid = rv;\n            return rv;\n        }\n#endif\n    } else {\n        if (!x || !pk)\n            return 0;\n        idx = ssl_cert_type(x, pk);\n        if (idx == -1)\n            return 0;\n        pvalid = s->s3->tmp.valid_flags + idx;\n\n        if (c->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT)\n            check_flags = CERT_PKEY_STRICT_FLAGS;\n        else\n            check_flags = CERT_PKEY_VALID_FLAGS;\n        strict_mode = 1;\n    }\n\n    if (suiteb_flags) {\n        int ok;\n        if (check_flags)\n            check_flags |= CERT_PKEY_SUITEB;\n        ok = X509_chain_check_suiteb(NULL, x, chain, suiteb_flags);\n        if (ok == X509_V_OK)\n            rv |= CERT_PKEY_SUITEB;\n        else if (!check_flags)\n            goto end;\n    }\n\n    /*\n     * Check all signature algorithms are consistent with signature\n     * algorithms extension if TLS 1.2 or later and strict mode.\n     */\n    if (TLS1_get_version(s) >= TLS1_2_VERSION && strict_mode) {\n        int default_nid;\n        unsigned char rsign = 0;\n        if (s->s3->tmp.peer_sigalgs)\n            default_nid = 0;\n        /* If no sigalgs extension use defaults from RFC5246 */\n        else {\n            switch (idx) {\n            case SSL_PKEY_RSA_ENC:\n            case SSL_PKEY_RSA_SIGN:\n                rsign = TLSEXT_signature_rsa;\n                default_nid = NID_sha1WithRSAEncryption;\n                break;\n\n            case SSL_PKEY_DSA_SIGN:\n                rsign = TLSEXT_signature_dsa;\n                default_nid = NID_dsaWithSHA1;\n                break;\n\n            case SSL_PKEY_ECC:\n                rsign = TLSEXT_signature_ecdsa;\n                default_nid = NID_ecdsa_with_SHA1;\n                break;\n\n            case SSL_PKEY_GOST01:\n                rsign = TLSEXT_signature_gostr34102001;\n                default_nid = NID_id_GostR3411_94_with_GostR3410_2001;\n                break;\n\n            case SSL_PKEY_GOST12_256:\n                rsign = TLSEXT_signature_gostr34102012_256;\n                default_nid = NID_id_tc26_signwithdigest_gost3410_2012_256;\n                break;\n\n            case SSL_PKEY_GOST12_512:\n                rsign = TLSEXT_signature_gostr34102012_512;\n                default_nid = NID_id_tc26_signwithdigest_gost3410_2012_512;\n                break;\n\n            default:\n                default_nid = -1;\n                break;\n            }\n        }\n        /*\n         * If peer sent no signature algorithms extension and we have set\n         * preferred signature algorithms check we support sha1.\n         */\n        if (default_nid > 0 && c->conf_sigalgs) {\n            size_t j;\n            const unsigned char *p = c->conf_sigalgs;\n            for (j = 0; j < c->conf_sigalgslen; j += 2, p += 2) {\n                if (p[0] == TLSEXT_hash_sha1 && p[1] == rsign)\n                    break;\n            }\n            if (j == c->conf_sigalgslen) {\n                if (check_flags)\n                    goto skip_sigs;\n                else\n                    goto end;\n            }\n        }\n        /* Check signature algorithm of each cert in chain */\n        if (!tls1_check_sig_alg(c, x, default_nid)) {\n            if (!check_flags)\n                goto end;\n        } else\n            rv |= CERT_PKEY_EE_SIGNATURE;\n        rv |= CERT_PKEY_CA_SIGNATURE;\n        for (i = 0; i < sk_X509_num(chain); i++) {\n            if (!tls1_check_sig_alg(c, sk_X509_value(chain, i), default_nid)) {\n                if (check_flags) {\n                    rv &= ~CERT_PKEY_CA_SIGNATURE;\n                    break;\n                } else\n                    goto end;\n            }\n        }\n    }\n    /* Else not TLS 1.2, so mark EE and CA signing algorithms OK */\n    else if (check_flags)\n        rv |= CERT_PKEY_EE_SIGNATURE | CERT_PKEY_CA_SIGNATURE;\n skip_sigs:\n    /* Check cert parameters are consistent */\n    if (tls1_check_cert_param(s, x, check_flags ? 1 : 2))\n        rv |= CERT_PKEY_EE_PARAM;\n    else if (!check_flags)\n        goto end;\n    if (!s->server)\n        rv |= CERT_PKEY_CA_PARAM;\n    /* In strict mode check rest of chain too */\n    else if (strict_mode) {\n        rv |= CERT_PKEY_CA_PARAM;\n        for (i = 0; i < sk_X509_num(chain); i++) {\n            X509 *ca = sk_X509_value(chain, i);\n            if (!tls1_check_cert_param(s, ca, 0)) {\n                if (check_flags) {\n                    rv &= ~CERT_PKEY_CA_PARAM;\n                    break;\n                } else\n                    goto end;\n            }\n        }\n    }\n    if (!s->server && strict_mode) {\n        STACK_OF(X509_NAME) *ca_dn;\n        int check_type = 0;\n        switch (pk->type) {\n        case EVP_PKEY_RSA:\n            check_type = TLS_CT_RSA_SIGN;\n            break;\n        case EVP_PKEY_DSA:\n            check_type = TLS_CT_DSS_SIGN;\n            break;\n        case EVP_PKEY_EC:\n            check_type = TLS_CT_ECDSA_SIGN;\n            break;\n        }\n        if (check_type) {\n            const unsigned char *ctypes;\n            int ctypelen;\n            if (c->ctypes) {\n                ctypes = c->ctypes;\n                ctypelen = (int)c->ctype_num;\n            } else {\n                ctypes = (unsigned char *)s->s3->tmp.ctype;\n                ctypelen = s->s3->tmp.ctype_num;\n            }\n            for (i = 0; i < ctypelen; i++) {\n                if (ctypes[i] == check_type) {\n                    rv |= CERT_PKEY_CERT_TYPE;\n                    break;\n                }\n            }\n            if (!(rv & CERT_PKEY_CERT_TYPE) && !check_flags)\n                goto end;\n        } else\n            rv |= CERT_PKEY_CERT_TYPE;\n\n        ca_dn = s->s3->tmp.ca_names;\n\n        if (!sk_X509_NAME_num(ca_dn))\n            rv |= CERT_PKEY_ISSUER_NAME;\n\n        if (!(rv & CERT_PKEY_ISSUER_NAME)) {\n            if (ssl_check_ca_name(ca_dn, x))\n                rv |= CERT_PKEY_ISSUER_NAME;\n        }\n        if (!(rv & CERT_PKEY_ISSUER_NAME)) {\n            for (i = 0; i < sk_X509_num(chain); i++) {\n                X509 *xtmp = sk_X509_value(chain, i);\n                if (ssl_check_ca_name(ca_dn, xtmp)) {\n                    rv |= CERT_PKEY_ISSUER_NAME;\n                    break;\n                }\n            }\n        }\n        if (!check_flags && !(rv & CERT_PKEY_ISSUER_NAME))\n            goto end;\n    } else\n        rv |= CERT_PKEY_ISSUER_NAME | CERT_PKEY_CERT_TYPE;\n\n    if (!check_flags || (rv & check_flags) == check_flags)\n        rv |= CERT_PKEY_VALID;\n\n end:\n\n    if (TLS1_get_version(s) >= TLS1_2_VERSION) {\n        if (*pvalid & CERT_PKEY_EXPLICIT_SIGN)\n            rv |= CERT_PKEY_EXPLICIT_SIGN | CERT_PKEY_SIGN;\n        else if (s->s3->tmp.md[idx] != NULL)\n            rv |= CERT_PKEY_SIGN;\n    } else\n        rv |= CERT_PKEY_SIGN | CERT_PKEY_EXPLICIT_SIGN;\n\n    /*\n     * When checking a CERT_PKEY structure all flags are irrelevant if the\n     * chain is invalid.\n     */\n    if (!check_flags) {\n        if (rv & CERT_PKEY_VALID)\n            *pvalid = rv;\n        else {\n            /* Preserve explicit sign flag, clear rest */\n            *pvalid &= CERT_PKEY_EXPLICIT_SIGN;\n            return 0;\n        }\n    }\n    return rv;\n}", "target": 0}
{"idx": 5521, "func": "static int dirac_decode_data_unit(AVCodecContext *avctx, const uint8_t *buf, int size)\n{\n    DiracContext *s   = avctx->priv_data;\n    DiracFrame *pic   = NULL;\n    int ret, i, parse_code = buf[4];\n    unsigned tmp;\n\n    if (size < DATA_UNIT_HEADER_SIZE)\n        return -1;\n\n    init_get_bits(&s->gb, &buf[13], 8*(size - DATA_UNIT_HEADER_SIZE));\n\n    if (parse_code == pc_seq_header) {\n        if (s->seen_sequence_header)\n            return 0;\n\n        /* [DIRAC_STD] 10. Sequence header */\n        if (avpriv_dirac_parse_sequence_header(avctx, &s->gb, &s->source))\n            return -1;\n\n        avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);\n\n        if (alloc_sequence_buffers(s))\n            return -1;\n\n        s->seen_sequence_header = 1;\n    } else if (parse_code == pc_eos) { /* [DIRAC_STD] End of Sequence */\n        free_sequence_buffers(s);\n        s->seen_sequence_header = 0;\n    } else if (parse_code == pc_aux_data) {\n        if (buf[13] == 1) {     /* encoder implementation/version */\n            int ver[3];\n            /* versions older than 1.0.8 don't store quant delta for\n               subbands with only one codeblock */\n            if (sscanf(buf+14, \"Schroedinger %d.%d.%d\", ver, ver+1, ver+2) == 3)\n                if (ver[0] == 1 && ver[1] == 0 && ver[2] <= 7)\n                    s->old_delta_quant = 1;\n        }\n    } else if (parse_code & 0x8) {  /* picture data unit */\n        if (!s->seen_sequence_header) {\n            av_log(avctx, AV_LOG_DEBUG, \"Dropping frame without sequence header\\n\");\n            return -1;\n        }\n\n        /* find an unused frame */\n        for (i = 0; i < MAX_FRAMES; i++)\n            if (s->all_frames[i].avframe->data[0] == NULL)\n                pic = &s->all_frames[i];\n        if (!pic) {\n            av_log(avctx, AV_LOG_ERROR, \"framelist full\\n\");\n            return -1;\n        }\n\n        av_frame_unref(pic->avframe);\n\n        /* [DIRAC_STD] Defined in 9.6.1 ... */\n        tmp            =  parse_code & 0x03;                   /* [DIRAC_STD] num_refs()      */\n        if (tmp > 2) {\n            av_log(avctx, AV_LOG_ERROR, \"num_refs of 3\\n\");\n            return -1;\n        }\n        s->num_refs    = tmp;\n        s->is_arith    = (parse_code & 0x48) == 0x08;          /* [DIRAC_STD] using_ac()      */\n        s->low_delay   = (parse_code & 0x88) == 0x88;          /* [DIRAC_STD] is_low_delay()  */\n        pic->avframe->reference = (parse_code & 0x0C) == 0x0C;  /* [DIRAC_STD]  is_reference() */\n        pic->avframe->key_frame = s->num_refs == 0;             /* [DIRAC_STD] is_intra()      */\n        pic->avframe->pict_type = s->num_refs + 1;              /* Definition of AVPictureType in avutil.h */\n\n        if ((ret = get_buffer_with_edge(avctx, pic->avframe, (parse_code & 0x0C) == 0x0C ? AV_GET_BUFFER_FLAG_REF : 0)) < 0)\n            return ret;\n        s->current_picture = pic;\n        s->plane[0].stride = pic->avframe->linesize[0];\n        s->plane[1].stride = pic->avframe->linesize[1];\n        s->plane[2].stride = pic->avframe->linesize[2];\n\n        if (alloc_buffers(s, FFMAX3(FFABS(s->plane[0].stride), FFABS(s->plane[1].stride), FFABS(s->plane[2].stride))) < 0)\n            return AVERROR(ENOMEM);\n\n        /* [DIRAC_STD] 11.1 Picture parse. picture_parse() */\n        if (dirac_decode_picture_header(s))\n            return -1;\n\n        /* [DIRAC_STD] 13.0 Transform data syntax. transform_data() */\n        if (dirac_decode_frame_internal(s))\n            return -1;\n    }\n    return 0;\n}", "target": 0}
{"idx": 5522, "func": "void CRYPTO_destroy_dynlockid(int i)\n\t{\n\tCRYPTO_dynlock *pointer = NULL;\n\tif (i)\n\t\ti = -i-1;\n\tif (dynlock_destroy_callback == NULL)\n\t\treturn;\n\n\tCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))\n\t\treturn;\n\tpointer = sk_CRYPTO_dynlock_value(dyn_locks, i);\n\tif (pointer != NULL)\n\t\t{\n\t\t--pointer->references;\n#ifdef REF_CHECK\n\t\tif (pointer->references < 0)\n\t\t\t{\n\t\t\tfprintf(stderr,\"CRYPTO_destroy_dynlockid, bad reference count\\n\");\n\t\t\tabort();\n\t\t\t}\n\t\telse\n#endif\n\t\t\tif (pointer->references <= 0)\n\t\t\t\t{\n\t\t\t\tsk_CRYPTO_dynlock_set(dyn_locks, i, NULL);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tpointer = NULL;\n\t\t}\n\tCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\n\n\tif (pointer)\n\t\t{\n\t\tdynlock_destroy_callback(pointer->data,__FILE__,__LINE__);\n\t\tOPENSSL_free(pointer);\n\t\t}\n\t}", "target": 1}
{"idx": 5523, "func": "static av_always_inline void filter_mb_row(AVCodecContext *avctx, void *tdata,\n                              int jobnr, int threadnr, int is_vp7)\n{\n    VP8Context *s = avctx->priv_data;\n    VP8ThreadData *td = &s->thread_data[threadnr];\n    int mb_x, mb_y = atomic_load(&td->thread_mb_pos) >> 16, num_jobs = s->num_jobs;\n    AVFrame *curframe = s->curframe->tf.f;\n    VP8Macroblock *mb;\n    VP8ThreadData *prev_td, *next_td;\n    uint8_t *dst[3] = {\n        curframe->data[0] + 16 * mb_y * s->linesize,\n        curframe->data[1] +  8 * mb_y * s->uvlinesize,\n        curframe->data[2] +  8 * mb_y * s->uvlinesize\n    };\n\n    if (s->mb_layout == 1)\n        mb = s->macroblocks_base + ((s->mb_width + 1) * (mb_y + 1) + 1);\n    else\n        mb = s->macroblocks + (s->mb_height - mb_y - 1) * 2;\n\n    if (mb_y == 0)\n        prev_td = td;\n    else\n        prev_td = &s->thread_data[(jobnr + num_jobs - 1) % num_jobs];\n    if (mb_y == s->mb_height - 1)\n        next_td = td;\n    else\n        next_td = &s->thread_data[(jobnr + 1) % num_jobs];\n\n    for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb++) {\n        VP8FilterStrength *f = &td->filter_strength[mb_x];\n        if (prev_td != td)\n            check_thread_pos(td, prev_td,\n                             (mb_x + 1) + (s->mb_width + 3), mb_y - 1);\n        if (next_td != td)\n            if (next_td != &s->thread_data[0])\n                check_thread_pos(td, next_td, mb_x + 1, mb_y + 1);\n\n        if (num_jobs == 1) {\n            if (s->filter.simple)\n                backup_mb_border(s->top_border[mb_x + 1], dst[0],\n                                 NULL, NULL, s->linesize, 0, 1);\n            else\n                backup_mb_border(s->top_border[mb_x + 1], dst[0],\n                                 dst[1], dst[2], s->linesize, s->uvlinesize, 0);\n        }\n\n        if (s->filter.simple)\n            filter_mb_simple(s, dst[0], f, mb_x, mb_y);\n        else\n            filter_mb(s, dst, f, mb_x, mb_y, is_vp7);\n        dst[0] += 16;\n        dst[1] += 8;\n        dst[2] += 8;\n\n        update_pos(td, mb_y, (s->mb_width + 3) + mb_x);\n    }\n}", "target": 0}
{"idx": 5524, "func": "static void add_pixels_clamped4_c(const DCTELEM *block, uint8_t *restrict pixels,\n                          int line_size)\n{\n    int i;\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n    /* read the pixels */\n    for(i=0;i<4;i++) {\n        pixels[0] = cm[pixels[0] + block[0]];\n        pixels[1] = cm[pixels[1] + block[1]];\n        pixels[2] = cm[pixels[2] + block[2]];\n        pixels[3] = cm[pixels[3] + block[3]];\n        pixels += line_size;\n        block += 8;\n    }\n}", "target": 1}
{"idx": 5525, "func": "int ff_MPV_common_init(MpegEncContext *s)\n{\n    int i;\n    int nb_slices = (HAVE_THREADS &&\n                     s->avctx->active_thread_type & FF_THREAD_SLICE) ?\n                    s->avctx->thread_count : 1;\n\n    if (s->encoding && s->avctx->slices)\n        nb_slices = s->avctx->slices;\n\n    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n        s->mb_height = (s->height + 31) / 32 * 2;\n    else\n        s->mb_height = (s->height + 15) / 16;\n\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"decoding to AV_PIX_FMT_NONE is not supported.\\n\");\n        return -1;\n    }\n\n    if (nb_slices > MAX_THREADS || (nb_slices > s->mb_height && s->mb_height)) {\n        int max_slices;\n        if (s->mb_height)\n            max_slices = FFMIN(MAX_THREADS, s->mb_height);\n        else\n            max_slices = MAX_THREADS;\n        av_log(s->avctx, AV_LOG_WARNING, \"too many threads/slices (%d),\"\n               \" reducing to %d\\n\", nb_slices, max_slices);\n        nb_slices = max_slices;\n    }\n\n    if ((s->width || s->height) &&\n        av_image_check_size(s->width, s->height, 0, s->avctx))\n        return -1;\n\n    ff_dct_common_init(s);\n\n    s->flags  = s->avctx->flags;\n    s->flags2 = s->avctx->flags2;\n\n    /* set chroma shifts */\n    avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,\n                                  &s->chroma_x_shift,\n                                  &s->chroma_y_shift);\n\n    /* convert fourcc to upper case */\n    s->codec_tag          = avpriv_toupper4(s->avctx->codec_tag);\n\n    s->stream_codec_tag   = avpriv_toupper4(s->avctx->stream_codec_tag);\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->picture,\n                      MAX_PICTURE_COUNT * sizeof(Picture), fail);\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        av_frame_unref(&s->picture[i].f);\n    }\n    memset(&s->next_picture, 0, sizeof(s->next_picture));\n    memset(&s->last_picture, 0, sizeof(s->last_picture));\n    memset(&s->current_picture, 0, sizeof(s->current_picture));\n    av_frame_unref(&s->next_picture.f);\n    av_frame_unref(&s->last_picture.f);\n    av_frame_unref(&s->current_picture.f);\n\n        if (init_context_frame(s))\n            goto fail;\n\n        s->parse_context.state = -1;\n\n        s->context_initialized = 1;\n        s->thread_context[0]   = s;\n\n//     if (s->width && s->height) {\n        if (nb_slices > 1) {\n            for (i = 1; i < nb_slices; i++) {\n                s->thread_context[i] = av_malloc(sizeof(MpegEncContext));\n                memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n            }\n\n            for (i = 0; i < nb_slices; i++) {\n                if (init_duplicate_context(s->thread_context[i]) < 0)\n                    goto fail;\n                    s->thread_context[i]->start_mb_y =\n                        (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n                    s->thread_context[i]->end_mb_y   =\n                        (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n            }\n        } else {\n            if (init_duplicate_context(s) < 0)\n                goto fail;\n            s->start_mb_y = 0;\n            s->end_mb_y   = s->mb_height;\n        }\n        s->slice_context_count = nb_slices;\n//     }\n\n    return 0;\n fail:\n    ff_MPV_common_end(s);\n    return -1;\n}", "target": 1}
{"idx": 5526, "func": "static int cookie_string(AVDictionary *dict, char **cookies)\n{\n    AVDictionaryEntry *e = NULL;\n    int len = 1;\n\n    // determine how much memory is needed for the cookies string\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n        len += strlen(e->key) + strlen(e->value) + 1;\n\n    // reallocate the cookies\n    e = NULL;\n    if (*cookies) av_free(*cookies);\n    *cookies = av_malloc(len);\n    if (!cookies) return AVERROR(ENOMEM);\n    *cookies[0] = '\\0';\n\n    // write out the cookies\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n        av_strlcatf(*cookies, len, \"%s%s\\n\", e->key, e->value);\n\n    return 0;\n}", "target": 1}
{"idx": 5527, "func": "static const unsigned char *valid_star(const unsigned char *p, size_t len,\n\t\t\t\t\t\tunsigned int flags)\n\t{\n\tconst unsigned char *star = 0;\n\tsize_t i;\n\tint state = LABEL_START;\n\tint dots = 0;\n\tfor (i = 0; i < len; ++i)\n\t\t{\n\t\t/*\n\t\t * Locate first and only legal wildcard, either at the start\n\t\t * or end of a non-IDNA first and not final label.\n\t\t */\n\t\tif (p[i] == '*')\n\t\t\t{\n\t\t\tint atstart = (state & LABEL_START);\n\t\t\tint atend = (i == len - 1 || p[i+i] == '.');\n\t\t\t/*\n\t\t\t * At most one wildcard per pattern.\n\t\t\t * No wildcards in IDNA labels.\n\t\t\t * No wildcards after the first label.\n\t\t\t */\n\t\t\tif (star != NULL || (state & LABEL_IDNA) != 0 || dots)\n\t\t\t\treturn NULL;\n\t\t\t/* Only full-label '*.example.com' wildcards? */\n\t\t\tif ((flags & X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS)\n\t\t\t    && (!atstart || !atend))\n\t\t\t\treturn NULL;\n\t\t\t/* No 'foo*bar' wildcards */\n\t\t\tif (!atstart && !atend)\n\t\t\t\treturn NULL;\n\t\t\tstar = &p[i];\n\t\t\tstate &= ~LABEL_START;\n\t\t\t}\n\t\telse if ((state & LABEL_START) != 0)\n\t\t\t{\n\t\t\t/*\n\t\t\t * At the start of a label, skip any \"xn--\" and\n\t\t\t * remain in the LABEL_START state, but set the\n\t\t\t * IDNA label state\n\t\t\t */\n\t\t\tif ((state & LABEL_IDNA) == 0 && len - i >= 4\n\t\t\t    && strncasecmp((char *)&p[i], \"xn--\", 4) == 0)\n\t\t\t\t{\n\t\t\t\ti += 3;\n\t\t\t\tstate |= LABEL_IDNA;\n\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t/* Labels must start with a letter or digit */\n\t\t\tstate &= ~LABEL_START;\n\t\t\tif (('a' <= p[i] && p[i] <= 'z')\n\t\t\t    || ('A' <= p[i] && p[i] <= 'Z')\n\t\t\t    || ('0' <= p[i] && p[i] <= '9'))\n\t\t\t\tcontinue;\n\t\t\treturn NULL;\n\t\t\t}\n\t\telse if (('a' <= p[i] && p[i] <= 'z')\n\t\t\t || ('A' <= p[i] && p[i] <= 'Z')\n\t\t\t || ('0' <= p[i] && p[i] <= '9'))\n\t\t\t{\n\t\t\tstate &= LABEL_IDNA;\n\t\t\tcontinue;\n\t\t\t}\n\t\telse if (p[i] == '.')\n\t\t\t{\n\t\t\tif (state & (LABEL_HYPHEN | LABEL_START))\n\t\t\t\treturn NULL;\n\t\t\tstate = LABEL_START;\n\t\t\t++dots;\n\t\t\t}\n\t\telse if (p[i] == '-')\n\t\t\t{\n\t\t\tif (state & LABEL_HYPHEN)\n\t\t\t\treturn NULL;\n\t\t\tstate |= LABEL_HYPHEN;\n\t\t\t}\n\t\telse\n\t\t\treturn NULL;\n\t\t}\n\n\t/*\n\t * The final label must not end in a hyphen or \".\", and\n\t * there must be at least two dots after the star.\n\t */\n\tif ((state & (LABEL_START | LABEL_HYPHEN)) != 0\n\t    || dots < 2)\n\t\treturn NULL;\n\treturn star;\n\t}", "target": 0}
{"idx": 5528, "func": "int BN_num_bits(const BIGNUM *a)\n\t{\n\tBN_ULONG l;\n\tint i;\n\n\tbn_check_top(a);\n\n\tif (a->top == 0) return(0);\n\tl=a->d[a->top-1];\n\ti=(a->top-1)*BN_BITS2;\n\tif (l == 0)\n\t\t{\n#if !defined(NO_STDIO) && !defined(WIN16)\n\t\tfprintf(stderr,\"BAD TOP VALUE\\n\");\n#endif\n\t\tabort();\n\t\t}\n\treturn(i+BN_num_bits_word(l));\n\t}", "target": 1}
{"idx": 5529, "func": "static av_always_inline int small_diamond_search(MpegEncContext * s, int *best, int dmin,\n                                       int src_index, int ref_index, int const penalty_factor,\n                                       int size, int h, int flags)\n{\n    MotionEstContext * const c= &s->me;\n    me_cmp_func cmpf, chroma_cmpf;\n    int next_dir=-1;\n    LOAD_COMMON\n    LOAD_COMMON2\n    unsigned map_generation = c->map_generation;\n\n    cmpf        = s->mecc.me_cmp[size];\n    chroma_cmpf = s->mecc.me_cmp[size + 1];\n\n    { /* ensure that the best point is in the MAP as h/qpel refinement needs it */\n        const unsigned key = ((unsigned)best[1]<<ME_MAP_MV_BITS) + best[0] + map_generation;\n        const int index= (((unsigned)best[1]<<ME_MAP_SHIFT) + best[0])&(ME_MAP_SIZE-1);\n        if(map[index]!=key){ //this will be executed only very rarey\n            score_map[index]= cmp(s, best[0], best[1], 0, 0, size, h, ref_index, src_index, cmpf, chroma_cmpf, flags);\n            map[index]= key;\n        }\n    }\n\n    for(;;){\n        int d;\n        const int dir= next_dir;\n        const int x= best[0];\n        const int y= best[1];\n        next_dir=-1;\n\n        if(dir!=2 && x>xmin) CHECK_MV_DIR(x-1, y  , 0)\n        if(dir!=3 && y>ymin) CHECK_MV_DIR(x  , y-1, 1)\n        if(dir!=0 && x<xmax) CHECK_MV_DIR(x+1, y  , 2)\n        if(dir!=1 && y<ymax) CHECK_MV_DIR(x  , y+1, 3)\n\n        if(next_dir==-1){\n            return dmin;\n        }\n    }\n}", "target": 0}
{"idx": 5530, "func": "static void vp6_parse_coeff_huffman(VP56Context *s)\n{\n    VP56Model *model = s->modelp;\n    uint8_t *permute = s->scantable.permutated;\n    VLC *vlc_coeff;\n    int coeff, sign, coeff_idx;\n    int b, cg, idx;\n    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */\n\n    for (b=0; b<6; b++) {\n        int ct = 0;    /* code type */\n        if (b > 3) pt = 1;\n        vlc_coeff = &s->dccv_vlc[pt];\n\n        for (coeff_idx = 0;;) {\n            int run = 1;\n            if (coeff_idx<2 && s->nb_null[coeff_idx][pt]) {\n                s->nb_null[coeff_idx][pt]--;\n                if (coeff_idx)\n                    break;\n            } else {\n                if (get_bits_count(&s->gb) >= s->gb.size_in_bits)\n                    return;\n                coeff = get_vlc2(&s->gb, vlc_coeff->table, 9, 3);\n                if (coeff == 0) {\n                    if (coeff_idx) {\n                        int pt = (coeff_idx >= 6);\n                        run += get_vlc2(&s->gb, s->runv_vlc[pt].table, 9, 3);\n                        if (run >= 9)\n                            run += get_bits(&s->gb, 6);\n                    } else\n                        s->nb_null[0][pt] = vp6_get_nb_null(s);\n                    ct = 0;\n                } else if (coeff == 11) {  /* end of block */\n                    if (coeff_idx == 1)    /* first AC coeff ? */\n                        s->nb_null[1][pt] = vp6_get_nb_null(s);\n                    break;\n                } else {\n                    int coeff2 = vp56_coeff_bias[coeff];\n                    if (coeff > 4)\n                        coeff2 += get_bits(&s->gb, coeff <= 9 ? coeff - 4 : 11);\n                    ct = 1 + (coeff2 > 1);\n                    sign = get_bits1(&s->gb);\n                    coeff2 = (coeff2 ^ -sign) + sign;\n                    if (coeff_idx)\n                        coeff2 *= s->dequant_ac;\n                    idx = model->coeff_index_to_pos[coeff_idx];\n                    s->block_coeff[b][permute[idx]] = coeff2;\n                }\n            }\n            coeff_idx+=run;\n            if (coeff_idx >= 64)\n                break;\n            cg = FFMIN(vp6_coeff_groups[coeff_idx], 3);\n            vlc_coeff = &s->ract_vlc[pt][ct][cg];\n        }\n    }\n}", "target": 0}
{"idx": 5531, "func": "static int get_aiff_header(AVFormatContext *s, int size,\n                                    unsigned version)\n{\n    AVIOContext *pb        = s->pb;\n    AVCodecParameters *par = s->streams[0]->codecpar;\n    AIFFInputContext *aiff = s->priv_data;\n    int exp;\n    uint64_t val;\n    int sample_rate;\n    unsigned int num_frames;\n\n    if (size & 1)\n        size++;\n    par->codec_type = AVMEDIA_TYPE_AUDIO;\n    par->channels = avio_rb16(pb);\n    num_frames = avio_rb32(pb);\n    par->bits_per_coded_sample = avio_rb16(pb);\n\n    exp = avio_rb16(pb) - 16383 - 63;\n    val = avio_rb64(pb);\n    if (exp <-63 || exp >63) {\n        av_log(s, AV_LOG_ERROR, \"exp %d is out of range\\n\", exp);\n        return AVERROR_INVALIDDATA;\n    }\n    if (exp >= 0)\n        sample_rate = val << exp;\n    else\n        sample_rate = (val + (1ULL<<(-exp-1))) >> -exp;\n    par->sample_rate = sample_rate;\n    size -= 18;\n\n    /* get codec id for AIFF-C */\n    if (size < 4) {\n        version = AIFF;\n    } else if (version == AIFF_C_VERSION1) {\n        par->codec_tag = avio_rl32(pb);\n        par->codec_id  = ff_codec_get_id(ff_codec_aiff_tags, par->codec_tag);\n        if (par->codec_id == AV_CODEC_ID_NONE) {\n            char tag[32];\n            av_get_codec_tag_string(tag, sizeof(tag), par->codec_tag);\n            avpriv_request_sample(s, \"unknown or unsupported codec tag: %s\", tag);\n        }\n        size -= 4;\n    }\n\n    if (version != AIFF_C_VERSION1 || par->codec_id == AV_CODEC_ID_PCM_S16BE) {\n        par->codec_id = aiff_codec_get_id(par->bits_per_coded_sample);\n        par->bits_per_coded_sample = av_get_bits_per_sample(par->codec_id);\n        aiff->block_duration = 1;\n    } else {\n        switch (par->codec_id) {\n        case AV_CODEC_ID_PCM_F32BE:\n        case AV_CODEC_ID_PCM_F64BE:\n        case AV_CODEC_ID_PCM_S16LE:\n        case AV_CODEC_ID_PCM_ALAW:\n        case AV_CODEC_ID_PCM_MULAW:\n            aiff->block_duration = 1;\n            break;\n        case AV_CODEC_ID_ADPCM_IMA_QT:\n            par->block_align = 34 * par->channels;\n            break;\n        case AV_CODEC_ID_MACE3:\n            par->block_align = 2 * par->channels;\n            break;\n        case AV_CODEC_ID_ADPCM_G726LE:\n            par->bits_per_coded_sample = 5;\n        case AV_CODEC_ID_ADPCM_IMA_WS:\n        case AV_CODEC_ID_ADPCM_G722:\n        case AV_CODEC_ID_MACE6:\n        case AV_CODEC_ID_SDX2_DPCM:\n            par->block_align = 1 * par->channels;\n            break;\n        case AV_CODEC_ID_GSM:\n            par->block_align = 33;\n            break;\n        default:\n            aiff->block_duration = 1;\n            break;\n        }\n        if (par->block_align > 0)\n            aiff->block_duration = av_get_audio_frame_duration2(par,\n                                                                par->block_align);\n    }\n\n    /* Block align needs to be computed in all cases, as the definition\n     * is specific to applications -> here we use the WAVE format definition */\n    if (!par->block_align)\n        par->block_align = (av_get_bits_per_sample(par->codec_id) * par->channels) >> 3;\n\n    if (aiff->block_duration) {\n        par->bit_rate = (int64_t)par->sample_rate * (par->block_align << 3) /\n                        aiff->block_duration;\n    }\n\n    /* Chunk is over */\n    if (size)\n        avio_skip(pb, size);\n\n    return num_frames;\n}", "target": 0}
{"idx": 5532, "func": "OPENSSL_STACK *OPENSSL_sk_dup(const OPENSSL_STACK *sk)\n{\n    OPENSSL_STACK *ret;\n\n    if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL)\n        return NULL;\n\n    /* direct structure assignment */\n    *ret = *sk;\n\n    if (sk->num == 0) {\n        /* postpone |ret->data| allocation */\n        ret->data = NULL;\n        ret->num_alloc = 0;\n        return ret;\n    }\n    /* duplicate |sk->data| content */\n    if ((ret->data = OPENSSL_malloc(sizeof(*ret->data) * sk->num_alloc)) == NULL)\n        goto err;\n    memcpy(ret->data, sk->data, sizeof(void *) * sk->num);\n    return ret;\n err:\n    OPENSSL_sk_free(ret);\n    return NULL;\n}", "target": 1}
{"idx": 5533, "func": "static inline int compress_coeffs(int *coef, int order, int c_bits)\n{\n    int i;\n    const int low_idx   = c_bits ?  4 : 2;\n    const int shift_val = c_bits ?  8 : 4;\n    const int high_idx  = c_bits ? 11 : 5;\n#ifndef TNS_ENABLE_COEF_COMPRESSION\n    return 0;\n#endif /* TNS_ENABLE_COEF_COMPRESSION */\n    for (i = 0; i < order; i++)\n        if (coef[i] >= low_idx && coef[i] <= high_idx)\n            return 0;\n    for (i = 0; i < order; i++)\n        coef[i] -= (coef[i] > high_idx) ? shift_val : 0;\n    return 1;\n}", "target": 0}
{"idx": 5534, "func": "static int vqa_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    VqaContext *s = avctx->priv_data;\n    int res;\n\n    if (s->frame.data[0])\n        avctx->release_buffer(avctx, &s->frame);\n\n    if (avctx->get_buffer(avctx, &s->frame)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA Video: get_buffer() failed\\n\");\n        return -1;\n    }\n\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n    if ((res = vqa_decode_chunk(s)) < 0)\n        return res;\n\n    /* make the palette available on the way out */\n    memcpy(s->frame.data[1], s->palette, PALETTE_COUNT * 4);\n    s->frame.palette_has_changed = 1;\n\n    *data_size = sizeof(AVFrame);\n    *(AVFrame*)data = s->frame;\n\n    /* report that the buffer was completely consumed */\n    return avpkt->size;\n}", "target": 0}
{"idx": 5535, "func": "void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)\n{\n    void **p = ptr;\n    if (min_size < *size)\n        return;\n    min_size = FFMAX(17 * min_size / 16 + 32, min_size);\n    av_free(*p);\n    *p = av_malloc(min_size);\n    if (!*p)\n        min_size = 0;\n    *size = min_size;\n}", "target": 1}
{"idx": 5536, "func": "static int has_decode_delay_been_guessed(AVStream *st)\n{\n    return st->codec->codec_id != CODEC_ID_H264 ||\n        st->info->nb_decoded_frames >= 6;\n}", "target": 0}
{"idx": 5537, "func": "static int init(RAND_DRBG *drbg, DRBG_SELFTEST_DATA *td, TEST_CTX *t)\n{\n    if (!TEST_true(RAND_DRBG_set(drbg, td->nid, td->flags))\n            || !TEST_true(RAND_DRBG_set_callbacks(drbg, kat_entropy, NULL,\n                                                  kat_nonce, NULL)))\n        return 0;\n    RAND_DRBG_set_ex_data(drbg, app_data_index, t);\n    t->ent = td->ent;\n    t->entlen = td->entlen;\n    t->nonce = td->nonce;\n    t->noncelen = td->noncelen;\n    t->entcnt = 0;\n    t->noncecnt = 0;\n    return 1;\n}", "target": 0}
{"idx": 5538, "func": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    static const size_t utctime_length = sizeof(\"YYMMDDHHMMSSZ\") - 1;\n    static const size_t generalizedtime_length = sizeof(\"YYYYMMDDHHMMSSZ\") - 1;\n    ASN1_TIME *asn1_cmp_time = NULL;\n    int i, day, sec, ret = 0;\n\n    /*\n     * Note that ASN.1 allows much more slack in the time format than RFC5280.\n     * In RFC5280, the representation is fixed:\n     * UTCTime: YYMMDDHHMMSSZ\n     * GeneralizedTime: YYYYMMDDHHMMSSZ\n     *\n     * We do NOT currently enforce the following RFC 5280 requirement:\n     * \"CAs conforming to this profile MUST always encode certificate\n     *  validity dates through the year 2049 as UTCTime; certificate validity\n     *  dates in 2050 or later MUST be encoded as GeneralizedTime.\"\n     */\n    switch (ctm->type) {\n    case V_ASN1_UTCTIME:\n        if (ctm->length != (int)(utctime_length))\n            return 0;\n        break;\n    case V_ASN1_GENERALIZEDTIME:\n        if (ctm->length != (int)(generalizedtime_length))\n            return 0;\n        break;\n    default:\n        return 0;\n    }\n\n    /**\n     * Verify the format: the ASN.1 functions we use below allow a more\n     * flexible format than what's mandated by RFC 5280.\n     * Digit and date ranges will be verified in the conversion methods.\n     */\n    for (i = 0; i < ctm->length - 1; i++) {\n        if (!isdigit(ctm->data[i]))\n            return 0;\n    }\n    if (ctm->data[ctm->length - 1] != 'Z')\n        return 0;\n\n    /*\n     * There is ASN1_UTCTIME_cmp_time_t but no\n     * ASN1_GENERALIZEDTIME_cmp_time_t or ASN1_TIME_cmp_time_t,\n     * so we go through ASN.1\n     */\n    asn1_cmp_time = X509_time_adj(NULL, 0, cmp_time);\n    if (asn1_cmp_time == NULL)\n        goto err;\n    if (!ASN1_TIME_diff(&day, &sec, ctm, asn1_cmp_time))\n        goto err;\n\n    /*\n     * X509_cmp_time comparison is <=.\n     * The return value 0 is reserved for errors.\n     */\n    ret = (day >= 0 && sec >= 0) ? -1 : 1;\n\n err:\n    ASN1_TIME_free(asn1_cmp_time);\n    return ret;\n}", "target": 1}
{"idx": 5539, "func": "static ngx_int_t\nngx_process_options(ngx_cycle_t *cycle)\n{\n    u_char  *p;\n    size_t   len;\n\n    if (ngx_prefix) {\n        len = ngx_strlen(ngx_prefix);\n        p = ngx_prefix;\n\n        if (len && !ngx_path_separator(p[len - 1])) {\n            p = ngx_pnalloc(cycle->pool, len + 1);\n            if (p == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(p, ngx_prefix, len);\n            p[len++] = '/';\n        }\n\n        cycle->conf_prefix.len = len;\n        cycle->conf_prefix.data = p;\n        cycle->prefix.len = len;\n        cycle->prefix.data = p;\n\n    } else {\n\n#ifndef NGX_PREFIX\n\n        p = ngx_pnalloc(cycle->pool, NGX_MAX_PATH);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        if (ngx_getcwd(p, NGX_MAX_PATH) == 0) {\n            ngx_log_stderr(ngx_errno, \"[emerg]: \" ngx_getcwd_n \" failed\");\n            return NGX_ERROR;\n        }\n\n        len = ngx_strlen(p);\n\n        p[len++] = '/';\n\n        cycle->conf_prefix.len = len;\n        cycle->conf_prefix.data = p;\n        cycle->prefix.len = len;\n        cycle->prefix.data = p;\n\n#else\n\n#ifdef NGX_CONF_PREFIX\n        ngx_str_set(&cycle->conf_prefix, NGX_CONF_PREFIX);\n#else\n        ngx_str_set(&cycle->conf_prefix, NGX_PREFIX);\n#endif\n        ngx_str_set(&cycle->prefix, NGX_PREFIX);\n\n#endif\n    }\n\n    if (ngx_conf_file) {\n        cycle->conf_file.len = ngx_strlen(ngx_conf_file);\n        cycle->conf_file.data = ngx_conf_file;\n\n    } else {\n        ngx_str_set(&cycle->conf_file, NGX_CONF_PATH);\n    }\n\n    if (ngx_get_full_name(cycle->pool, &cycle->prefix, &cycle->conf_file)\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    for (p = cycle->conf_file.data + cycle->conf_file.len - 1;\n         p > cycle->conf_file.data;\n         p--)\n    {\n        if (ngx_path_separator(*p)) {\n            cycle->conf_prefix.len = p - ngx_cycle->conf_file.data + 1;\n            cycle->conf_prefix.data = ngx_cycle->conf_file.data;\n            break;\n        }\n    }\n\n    if (ngx_conf_params) {\n        cycle->conf_param.len = ngx_strlen(ngx_conf_params);\n        cycle->conf_param.data = ngx_conf_params;\n    }\n\n    if (ngx_test_config) {\n        cycle->log->log_level = NGX_LOG_INFO;\n    }\n\n    return NGX_OK;\n}", "target": 1}
{"idx": 5540, "func": "void BN_MONT_CTX_init(BN_MONT_CTX *ctx)\n{\n    ctx->ri = 0;\n    bn_init(&ctx->RR);\n    bn_init(&ctx->N);\n    bn_init(&ctx->Ni);\n    ctx->n0[0] = ctx->n0[1] = 0;\n    ctx->flags = 0;\n}", "target": 0}
{"idx": 5541, "func": "int ASN1_STRING_set(ASN1_STRING *str, const void *_data, int len)\n\t{\n\tunsigned char *c;\n\tconst char *data=_data;\n\n\tif (len < 0)\n\t\t{\n\t\tif (data == NULL)\n\t\t\treturn(0);\n\t\telse\n\t\t\tlen=strlen(data);\n\t\t}\n\tif ((str->length < len) || (str->data == NULL))\n\t\t{\n\t\tc=str->data;\n\t\tif (c == NULL)\n\t\t\tstr->data=OPENSSL_malloc(len+1);\n\t\telse\n\t\t\tstr->data=OPENSSL_realloc(c,len+1);\n\n\t\tif (str->data == NULL)\n\t\t\t{\n\t\t\tstr->data=c;\n\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\tstr->length=len;\n\tif (data != NULL)\n\t\t{\n\t\tmemcpy(str->data,data,len);\n\t\t/* an allowance for strings :-) */\n\t\tstr->data[len]='\\0';\n\t\t}\n\treturn(1);\n\t}", "target": 1}
{"idx": 5542, "func": "static int64_t get_pts(const char *buf, int *duration)\n{\n    int i;\n\n    for (i=0; i<2; i++) {\n        int hh1, mm1, ss1, ms1;\n        int hh2, mm2, ss2, ms2;\n        if (sscanf(buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\",\n                   &hh1, &mm1, &ss1, &ms1,\n                   &hh2, &mm2, &ss2, &ms2) == 8) {\n            int64_t start = (hh1*3600LL + mm1*60LL + ss1) * 1000LL + ms1;\n            int64_t end   = (hh2*3600LL + mm2*60LL + ss2) * 1000LL + ms2;\n            *duration = end - start;\n            return start;\n        }\n        buf += strcspn(buf, \"\\n\") + 1;\n    }\n    return AV_NOPTS_VALUE;\n}", "target": 0}
{"idx": 5543, "func": "static int cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,\n                                   int chunk_id, int size, const uint8_t *data)\n{\n    const uint8_t   *eod = (data + size);\n    uint32_t         flag, mask;\n    uint8_t         *cb0, *cb1, *cb2, *cb3;\n    int             x, y;\n    char            *ip0, *ip1, *ip2, *ip3;\n\n    flag = 0;\n    mask = 0;\n\n    for (y=strip->y1; y < strip->y2; y+=4) {\n\n/* take care of y dimension not being multiple of 4, such streams exist */\n        ip0 = ip1 = ip2 = ip3 = s->frame->data[0] +\n          (s->palette_video?strip->x1:strip->x1*3) + (y * s->frame->linesize[0]);\n        if(s->avctx->height - y > 1) {\n            ip1 = ip0 + s->frame->linesize[0];\n            if(s->avctx->height - y > 2) {\n                ip2 = ip1 + s->frame->linesize[0];\n                if(s->avctx->height - y > 3) {\n                    ip3 = ip2 + s->frame->linesize[0];\n                }\n            }\n        }\n/* to get the correct picture for not-multiple-of-4 cases let us fill\n * each block from the bottom up, thus possibly overwriting the top line\n * more than once but ending with the correct data in place\n * (instead of in-loop checking) */\n\n        for (x=strip->x1; x < strip->x2; x+=4) {\n            if ((chunk_id & 0x01) && !(mask >>= 1)) {\n                if ((data + 4) > eod)\n                    return AVERROR_INVALIDDATA;\n\n                flag  = AV_RB32 (data);\n                data += 4;\n                mask  = 0x80000000;\n            }\n\n            if (!(chunk_id & 0x01) || (flag & mask)) {\n                if (!(chunk_id & 0x02) && !(mask >>= 1)) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    flag  = AV_RB32 (data);\n                    data += 4;\n                    mask  = 0x80000000;\n                }\n\n                if ((chunk_id & 0x02) || (~flag & mask)) {\n                    uint8_t *p;\n                    if (data >= eod)\n                        return AVERROR_INVALIDDATA;\n\n                    p = strip->v1_codebook[*data++];\n                    if (s->palette_video) {\n                        ip3[0] = ip3[1] = ip2[0] = ip2[1] = p[6];\n                        ip3[2] = ip3[3] = ip2[2] = ip2[3] = p[9];\n                        ip1[0] = ip1[1] = ip0[0] = ip0[1] = p[0];\n                        ip1[2] = ip1[3] = ip0[2] = ip0[3] = p[3];\n                    } else {\n                        p += 6;\n                        memcpy(ip3 + 0, p, 3); memcpy(ip3 + 3, p, 3);\n                        memcpy(ip2 + 0, p, 3); memcpy(ip2 + 3, p, 3);\n                        p += 3; /* ... + 9 */\n                        memcpy(ip3 + 6, p, 3); memcpy(ip3 + 9, p, 3);\n                        memcpy(ip2 + 6, p, 3); memcpy(ip2 + 9, p, 3);\n                        p -= 9; /* ... + 0 */\n                        memcpy(ip1 + 0, p, 3); memcpy(ip1 + 3, p, 3);\n                        memcpy(ip0 + 0, p, 3); memcpy(ip0 + 3, p, 3);\n                        p += 3; /* ... + 3 */\n                        memcpy(ip1 + 6, p, 3); memcpy(ip1 + 9, p, 3);\n                        memcpy(ip0 + 6, p, 3); memcpy(ip0 + 9, p, 3);\n                    }\n\n                } else if (flag & mask) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    cb0 = strip->v4_codebook[*data++];\n                    cb1 = strip->v4_codebook[*data++];\n                    cb2 = strip->v4_codebook[*data++];\n                    cb3 = strip->v4_codebook[*data++];\n                    if (s->palette_video) {\n                        uint8_t *p;\n                        p = ip3;\n                        *p++ = cb2[6];\n                        *p++ = cb2[9];\n                        *p++ = cb3[6];\n                        *p   = cb3[9];\n                        p = ip2;\n                        *p++ = cb2[0];\n                        *p++ = cb2[3];\n                        *p++ = cb3[0];\n                        *p   = cb3[3];\n                        p = ip1;\n                        *p++ = cb0[6];\n                        *p++ = cb0[9];\n                        *p++ = cb1[6];\n                        *p   = cb1[9];\n                        p = ip0;\n                        *p++ = cb0[0];\n                        *p++ = cb0[3];\n                        *p++ = cb1[0];\n                        *p   = cb1[3];\n                    } else {\n                        memcpy(ip3 + 0, cb2 + 6, 6);\n                        memcpy(ip3 + 6, cb3 + 6, 6);\n                        memcpy(ip2 + 0, cb2 + 0, 6);\n                        memcpy(ip2 + 6, cb3 + 0, 6);\n                        memcpy(ip1 + 0, cb0 + 6, 6);\n                        memcpy(ip1 + 6, cb1 + 6, 6);\n                        memcpy(ip0 + 0, cb0 + 0, 6);\n                        memcpy(ip0 + 6, cb1 + 0, 6);\n                    }\n\n                }\n            }\n\n            if (s->palette_video) {\n                ip0 += 4;  ip1 += 4;\n                ip2 += 4;  ip3 += 4;\n            } else {\n                ip0 += 12;  ip1 += 12;\n                ip2 += 12;  ip3 += 12;\n            }\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5544, "func": "static long conn_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    BIO *dbio;\n    int *ip;\n    const char **pptr = NULL;\n    long ret = 1;\n    BIO_CONNECT *data;\n\n    data = (BIO_CONNECT *)b->ptr;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n        ret = 0;\n        data->state = BIO_CONN_S_BEFORE;\n        conn_close_socket(b);\n        b->flags = 0;\n        break;\n    case BIO_C_DO_STATE_MACHINE:\n        /* use this one to start the connection */\n        if (data->state != BIO_CONN_S_OK)\n            ret = (long)conn_state(b, data);\n        else\n            ret = 1;\n        break;\n    case BIO_C_GET_CONNECT:\n        if (ptr != NULL) {\n            pptr = (const char **)ptr;\n        }\n\n        if (b->init) {\n            if (pptr != NULL) {\n                ret = 1;\n                if (num == 0) {\n                    *pptr = data->param_hostname;\n                } else if (num == 1) {\n                    *pptr = data->param_port;\n                } else if (num == 2) {\n                    *pptr = (char *)&(data->ip[0]);\n                } else {\n                    ret = 0;\n                }\n            }\n            if (num == 3) {\n                ret = data->port;\n            }\n        } else {\n            if (pptr != NULL)\n                *pptr = \"not initialized\";\n            ret = 0;\n        }\n        break;\n    case BIO_C_SET_CONNECT:\n        if (ptr != NULL) {\n            b->init = 1;\n            if (num == 0) {\n                OPENSSL_free(data->param_hostname);\n                data->param_hostname = OPENSSL_strdup(ptr);\n            } else if (num == 1) {\n                OPENSSL_free(data->param_port);\n                data->param_port = OPENSSL_strdup(ptr);\n            } else if (num == 2) {\n                char buf[16];\n                unsigned char *p = ptr;\n\n                BIO_snprintf(buf, sizeof buf, \"%d.%d.%d.%d\",\n                             p[0], p[1], p[2], p[3]);\n                OPENSSL_free(data->param_hostname);\n                data->param_hostname = OPENSSL_strdup(buf);\n                memcpy(&(data->ip[0]), ptr, 4);\n            } else if (num == 3) {\n                char buf[DECIMAL_SIZE(int) + 1];\n\n                BIO_snprintf(buf, sizeof buf, \"%d\", *(int *)ptr);\n                OPENSSL_free(data->param_port);\n                data->param_port = OPENSSL_strdup(buf);\n                data->port = *(int *)ptr;\n            }\n        }\n        break;\n    case BIO_C_SET_NBIO:\n        data->nbio = (int)num;\n        break;\n    case BIO_C_GET_FD:\n        if (b->init) {\n            ip = (int *)ptr;\n            if (ip != NULL)\n                *ip = b->num;\n            ret = b->num;\n        } else\n            ret = -1;\n        break;\n    case BIO_CTRL_GET_CLOSE:\n        ret = b->shutdown;\n        break;\n    case BIO_CTRL_SET_CLOSE:\n        b->shutdown = (int)num;\n        break;\n    case BIO_CTRL_PENDING:\n    case BIO_CTRL_WPENDING:\n        ret = 0;\n        break;\n    case BIO_CTRL_FLUSH:\n        break;\n    case BIO_CTRL_DUP:\n        {\n            dbio = (BIO *)ptr;\n            if (data->param_port)\n                BIO_set_conn_port(dbio, data->param_port);\n            if (data->param_hostname)\n                BIO_set_conn_hostname(dbio, data->param_hostname);\n            BIO_set_nbio(dbio, data->nbio);\n            /*\n             * FIXME: the cast of the function seems unlikely to be a good\n             * idea\n             */\n            (void)BIO_set_info_callback(dbio,\n                                        (bio_info_cb *)data->info_callback);\n        }\n        break;\n    case BIO_CTRL_SET_CALLBACK:\n        {\n# if 0                          /* FIXME: Should this be used? -- Richard\n                                 * Levitte */\n            BIOerr(BIO_F_CONN_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n            ret = -1;\n# else\n            ret = 0;\n# endif\n        }\n        break;\n    case BIO_CTRL_GET_CALLBACK:\n        {\n            int (**fptr) (const BIO *bio, int state, int xret);\n\n            fptr = (int (**)(const BIO *bio, int state, int xret))ptr;\n            *fptr = data->info_callback;\n        }\n        break;\n    default:\n        ret = 0;\n        break;\n    }\n    return (ret);\n}", "target": 0}
{"idx": 5545, "func": "long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)\n\t{\n\tunsigned char *p;\n\tunsigned long l;\n\tlong n;\n\tint i,al;\n\n\tif (s->s3->tmp.reuse_message)\n\t\t{\n\t\ts->s3->tmp.reuse_message=0;\n\t\tif ((mt >= 0) && (s->s3->tmp.message_type != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t*ok=1;\n\t\ts->init_msg = s->init_buf->data + 4;\n\t\ts->init_num = (int)s->s3->tmp.message_size;\n\t\treturn s->init_num;\n\t\t}\n\n\tp=(unsigned char *)s->init_buf->data;\n\n\tif (s->state == st1) /* s->init_num < 4 */\n\t\t{\n\t\tint skip_message;\n\n\t\tdo\n\t\t\t{\n\t\t\twhile (s->init_num < 4)\n\t\t\t\t{\n\t\t\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],\n\t\t\t\t\t4 - s->init_num, 0);\n\t\t\t\tif (i <= 0)\n\t\t\t\t\t{\n\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\t*ok = 0;\n\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\ts->init_num+=i;\n\t\t\t\t}\n\t\t\t\n\t\t\tskip_message = 0;\n\t\t\tif (!s->server)\n\t\t\t\tif (p[0] == SSL3_MT_HELLO_REQUEST)\n\t\t\t\t\t/* The server may always send 'Hello Request' messages --\n\t\t\t\t\t * we are doing a handshake anyway now, so ignore them\n\t\t\t\t\t * if their format is correct. Does not count for\n\t\t\t\t\t * 'Finished' MAC. */\n\t\t\t\t\tif (p[1] == 0 && p[2] == 0 &&p[3] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->init_num = 0;\n\t\t\t\t\t\tskip_message = 1;\n\n\t\t\t\t\t\tif (s->msg_callback)\n\t\t\t\t\t\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, 4, s, s->msg_callback_arg);\n\t\t\t\t\t\t}\n\t\t\t}\n\t\twhile (skip_message);\n\n\t\t/* s->init_num == 4 */\n\n\t\tif ((mt >= 0) && (*p != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif ((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) &&\n\t\t\t\t\t(st1 == SSL3_ST_SR_CERT_A) &&\n\t\t\t\t\t(stn == SSL3_ST_SR_CERT_B))\n\t\t\t{\n\t\t\t/* At this point we have got an MS SGC second client\n\t\t\t * hello (maybe we should always allow the client to\n\t\t\t * start a new handshake?). We need to restart the mac.\n\t\t\t * Don't increment {num,total}_renegotiations because\n\t\t\t * we have not completed the handshake. */\n\t\t\tssl3_init_finished_mac(s);\n\t\t\t}\n\n\t\ts->s3->tmp.message_type= *(p++);\n\n\t\tn2l3(p,l);\n\t\tif (l > (unsigned long)max)\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (l > (INT_MAX-4)) /* BUF_MEM_grow takes an 'int' parameter */\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (l && !BUF_MEM_grow(s->init_buf,(int)l+4))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->s3->tmp.message_size=l;\n\t\ts->state=stn;\n\n\t\ts->init_msg = s->init_buf->data + 4;\n\t\ts->init_num = 0;\n\t\t}\n\n\t/* next state (stn) */\n\tp = s->init_msg;\n\tn = s->s3->tmp.message_size - s->init_num;\n\twhile (n > 0)\n\t\t{\n\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n,0);\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\ts->rwstate=SSL_READING;\n\t\t\t*ok = 0;\n\t\t\treturn i;\n\t\t\t}\n\t\ts->init_num += i;\n\t\tn -= i;\n\t\t}\n\tssl3_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num + 4);\n\tif (s->msg_callback)\n\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->init_buf->data, (size_t)s->init_num + 4, s, s->msg_callback_arg);\n\t*ok=1;\n\treturn s->init_num;\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\t*ok=0;\n\treturn(-1);\n\t}", "target": 0}
{"idx": 5546, "func": "static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n                                    const uint8_t *src, const uint8_t *src_end,\n                                    int width, int esc_count)\n{\n    int i = 0;\n    int count;\n    uint8_t zero_run = 0;\n    const uint8_t *src_start = src;\n    uint8_t mask1 = -(esc_count < 2);\n    uint8_t mask2 = -(esc_count < 3);\n    uint8_t *end = dst + (width - 2);\n\n    avpriv_request_sample(l->avctx, \"zero_run_line\");\n\n    memset(dst, 0, width);\n\noutput_zeros:\n    if (l->zeros_rem) {\n        count = FFMIN(l->zeros_rem, width - i);\n        if (end - dst < count) {\n            av_log(l->avctx, AV_LOG_ERROR, \"Too many zeros remaining.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        memset(dst, 0, count);\n        l->zeros_rem -= count;\n        dst += count;\n    }\n\n    while (dst < end) {\n        i = 0;\n        while (!zero_run && dst + i < end) {\n            i++;\n            if (i+2 >= src_end - src)\n                return AVERROR_INVALIDDATA;\n            zero_run =\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n        }\n        if (zero_run) {\n            zero_run = 0;\n            i += esc_count;\n            memcpy(dst, src, i);\n            dst += i;\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n\n            src += i + 1;\n            goto output_zeros;\n        } else {\n            memcpy(dst, src, i);\n            src += i;\n            dst += i;\n        }\n    }\n    return  src - src_start;\n}", "target": 0}
{"idx": 5547, "func": "static void qtrle_decode_1bpp(QtrleContext *s, int stream_ptr, int row_ptr, int lines_to_change)\n{\n    int rle_code;\n    int pixel_ptr = 0;\n    int row_inc = s->frame.linesize[0];\n    unsigned char pi0, pi1;  /* 2 8-pixel values */\n    unsigned char *rgb = s->frame.data[0];\n    int pixel_limit = s->frame.linesize[0] * s->avctx->height;\n    int skip;\n\n    while (lines_to_change) {\n        CHECK_STREAM_PTR(2);\n        skip = s->buf[stream_ptr++];\n        rle_code = (signed char)s->buf[stream_ptr++];\n        if (rle_code == 0)\n            break;\n        if(skip & 0x80) {\n            lines_to_change--;\n            row_ptr += row_inc;\n            pixel_ptr = row_ptr + 2 * (skip & 0x7f);\n        } else\n            pixel_ptr += 2 * skip;\n        CHECK_PIXEL_PTR(0);  /* make sure pixel_ptr is positive */\n\n        if (rle_code < 0) {\n            /* decode the run length code */\n            rle_code = -rle_code;\n            /* get the next 2 bytes from the stream, treat them as groups\n             * of 8 pixels, and output them rle_code times */\n            CHECK_STREAM_PTR(2);\n            pi0 = s->buf[stream_ptr++];\n            pi1 = s->buf[stream_ptr++];\n            CHECK_PIXEL_PTR(rle_code * 2);\n\n            while (rle_code--) {\n                rgb[pixel_ptr++] = pi0;\n                rgb[pixel_ptr++] = pi1;\n            }\n        } else {\n            /* copy the same pixel directly to output 2 times */\n            rle_code *= 2;\n            CHECK_STREAM_PTR(rle_code);\n            CHECK_PIXEL_PTR(rle_code);\n\n            while (rle_code--)\n                rgb[pixel_ptr++] = s->buf[stream_ptr++];\n        }\n    }\n}", "target": 1}
{"idx": 5548, "func": "int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,\n                              int64_t wanted_timestamp, int flags)\n{\n    int a, b, m;\n    int64_t timestamp;\n\n    a = -1;\n    b = nb_entries;\n\n    // Optimize appending index entries at the end.\n    if (b && entries[b - 1].timestamp < wanted_timestamp)\n        a = b - 1;\n\n    while (b - a > 1) {\n        m         = (a + b) >> 1;\n\n        // Search for the next non-discarded packet.\n        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {\n            m++;\n            if (m == b && entries[m].timestamp >= wanted_timestamp) {\n                m = b - 1;\n                break;\n            }\n        }\n\n        timestamp = entries[m].timestamp;\n        if (timestamp >= wanted_timestamp)\n            b = m;\n        if (timestamp <= wanted_timestamp)\n            a = m;\n    }\n    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;\n\n    if (!(flags & AVSEEK_FLAG_ANY))\n        while (m >= 0 && m < nb_entries &&\n               !(entries[m].flags & AVINDEX_KEYFRAME))\n            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;\n\n    if (m == nb_entries)\n        return -1;\n    return m;\n}", "target": 0}
{"idx": 5549, "func": "BIGNUM *BN_CTX_get(BN_CTX *ctx)\n{\n    BIGNUM *ret;\n\n    CTXDBG_ENTRY(\"BN_CTX_get\", ctx);\n    if (ctx->err_stack || ctx->too_many)\n        return NULL;\n    if ((ret = BN_POOL_get(&ctx->pool, ctx->flags)) == NULL) {\n        /*\n         * Setting too_many prevents repeated \"get\" attempts from cluttering\n         * the error stack.\n         */\n        ctx->too_many = 1;\n        BNerr(BN_F_BN_CTX_GET, BN_R_TOO_MANY_TEMPORARY_VARIABLES);\n        return NULL;\n    }\n    /* OK, make sure the returned bignum is \"zero\" */\n    BN_zero(ret);\n    ctx->used++;\n    CTXDBG_RET(ctx, ret);\n    return ret;\n}", "target": 1}
{"idx": 5550, "func": "static apr_status_t pending_filter_cleanup(void *arg)\n{\n    ap_filter_t *f = arg;\n\n    APR_RING_REMOVE(f, pending);\n    APR_RING_ELEM_INIT(f, pending);\n    f->bb = NULL;\n\n    return APR_SUCCESS;\n}", "target": 0}
{"idx": 5551, "func": "static int general_allocate_string(UI *ui, const char *prompt,\n\tint prompt_freeable, enum UI_string_types type, int input_flags,\n\tchar *result_buf, int minsize, int maxsize, const char *test_buf)\n\t{\n\tint ret = -1;\n\tUI_STRING *s = general_allocate_prompt(ui, prompt, prompt_freeable,\n\t\ttype, input_flags, result_buf);\n\n\tif (s)\n\t\t{\n\t\tif (allocate_string_stack(ui) >= 0)\n\t\t\t{\n\t\t\ts->_.string_data.result_minsize=minsize;\n\t\t\ts->_.string_data.result_maxsize=maxsize;\n\t\t\ts->_.string_data.test_buf=test_buf;\n\t\t\tret=sk_UI_STRING_push(ui->strings, s);\n\t\t\t/* sk_push() returns 0 on error.  Let's addapt that */\n\t\t\tif (ret <= 0) ret--;\n\t\t\t}\n\t\telse\n\t\t\tfree_string(s);\n\t\t}\n\treturn ret;\n\t}", "target": 1}
{"idx": 5552, "func": "static int ftp_open(URLContext *h, const char *url, int flags)\n{\n    char proto[10], path[MAX_URL_SIZE], credencials[MAX_URL_SIZE];\n    const char *tok_user = NULL, *tok_pass = NULL;\n    char *end = NULL;\n    int err;\n    FTPContext *s = h->priv_data;\n\n    av_dlog(h, \"ftp protocol open\\n\");\n\n    s->state = DISCONNECTED;\n    s->filesize = -1;\n    s->position = 0;\n\n    av_url_split(proto, sizeof(proto),\n                 credencials, sizeof(credencials),\n                 s->hostname, sizeof(s->hostname),\n                 &s->server_control_port,\n                 path, sizeof(path),\n                 url);\n\n    tok_user = av_strtok(credencials, \":\", &end);\n    tok_pass = av_strtok(end, \":\", &end);\n    if (!tok_user) {\n        tok_user = \"anonymous\";\n        tok_pass = av_x_if_null(s->anonymous_password, \"nopassword\");\n    }\n    s->user = av_strdup(tok_user);\n    s->password = av_strdup(tok_pass);\n    if (!s->user || (tok_pass && !s->password)) {\n        err = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    if (s->server_control_port < 0 || s->server_control_port > 65535)\n        s->server_control_port = 21;\n\n    if ((err = ftp_connect_control_connection(h)) < 0)\n        goto fail;\n\n    if ((err = ftp_current_dir(s)) < 0)\n        goto fail;\n    av_strlcat(s->path, path, sizeof(s->path));\n\n    if (ftp_restart(s, 0) < 0) {\n        h->is_streamed = 1;\n    } else {\n        if (ftp_file_size(s) < 0 && flags & AVIO_FLAG_READ)\n            h->is_streamed = 1;\n        if (s->write_seekable != 1 && flags & AVIO_FLAG_WRITE)\n            h->is_streamed = 1;\n    }\n\n    return 0;\n\n  fail:\n    av_log(h, AV_LOG_ERROR, \"FTP open failed\\n\");\n    ftp_close(h);\n    return err;\n}", "target": 0}
{"idx": 5553, "func": "static void fill_buffer(ByteIOContext *s)\n{\n    uint8_t *dst= !s->max_packet_size && s->buf_end - s->buffer < s->buffer_size ? s->buf_ptr : s->buffer;\n    int len= s->buffer_size - (dst - s->buffer);\n    int max_buffer_size = s->max_packet_size ? s->max_packet_size : IO_BUFFER_SIZE;\n\n    assert(s->buf_ptr == s->buf_end);\n\n    /* no need to do anything if EOF already reached */\n    if (s->eof_reached)\n        return;\n\n    if(s->update_checksum && dst == s->buffer){\n        if(s->buf_end > s->checksum_ptr)\n            s->checksum= s->update_checksum(s->checksum, s->checksum_ptr, s->buf_end - s->checksum_ptr);\n        s->checksum_ptr= s->buffer;\n    }\n\n    /* make buffer smaller in case it ended up large after probing */\n    if (s->buffer_size > max_buffer_size) {\n        url_setbufsize(s, max_buffer_size);\n\n        s->checksum_ptr = dst = s->buffer;\n        len = s->buffer_size;\n    }\n\n    if(s->read_packet)\n        len = s->read_packet(s->opaque, dst, len);\n    else\n        len = 0;\n    if (len <= 0) {\n        /* do not modify buffer if EOF reached so that a seek back can\n           be done without rereading data */\n        s->eof_reached = 1;\n        if(len<0)\n            s->error= len;\n    } else {\n        s->pos += len;\n        s->buf_ptr = dst;\n        s->buf_end = dst + len;\n    }\n}", "target": 1}
{"idx": 5554, "func": "static int unpack_modes(Vp3DecodeContext *s, GetBitContext *gb)\n{\n    int i, j, k, sb_x, sb_y;\n    int scheme;\n    int current_macroblock;\n    int current_fragment;\n    int coding_mode;\n    int custom_mode_alphabet[CODING_MODE_COUNT];\n\n    if (s->keyframe) {\n        for (i = 0; i < s->fragment_count; i++)\n            s->all_fragments[i].coding_method = MODE_INTRA;\n\n    } else {\n\n        /* fetch the mode coding scheme for this frame */\n        scheme = get_bits(gb, 3);\n\n        /* is it a custom coding scheme? */\n        if (scheme == 0) {\n            for (i = 0; i < 8; i++)\n                custom_mode_alphabet[i] = MODE_INTER_NO_MV;\n            for (i = 0; i < 8; i++)\n                custom_mode_alphabet[get_bits(gb, 3)] = i;\n        }\n\n        /* iterate through all of the macroblocks that contain 1 or more\n         * coded fragments */\n        for (sb_y = 0; sb_y < s->y_superblock_height; sb_y++) {\n            for (sb_x = 0; sb_x < s->y_superblock_width; sb_x++) {\n\n            for (j = 0; j < 4; j++) {\n                int mb_x = 2*sb_x +   (j>>1);\n                int mb_y = 2*sb_y + (((j>>1)+j)&1);\n                int frags_coded = 0;\n                current_macroblock = mb_y * s->macroblock_width + mb_x;\n\n                if (mb_x >= s->macroblock_width || mb_y >= s->macroblock_height)\n                    continue;\n\n#define BLOCK_X (2*mb_x + (k&1))\n#define BLOCK_Y (2*mb_y + (k>>1))\n                /* coding modes are only stored if the macroblock has at least one\n                 * luma block coded, otherwise it must be INTER_NO_MV */\n                for (k = 0; k < 4; k++) {\n                    current_fragment = BLOCK_Y*s->fragment_width + BLOCK_X;\n                    if (s->all_fragments[current_fragment].coding_method != MODE_COPY)\n                        break;\n                }\n                if (k == 4) {\n                    s->macroblock_coding[current_macroblock] = MODE_INTER_NO_MV;\n                    continue;\n                }\n\n                /* mode 7 means get 3 bits for each coding mode */\n                if (scheme == 7)\n                    coding_mode = get_bits(gb, 3);\n                else if(scheme == 0)\n                    coding_mode = custom_mode_alphabet\n                        [get_vlc2(gb, s->mode_code_vlc.table, 3, 3)];\n                else\n                    coding_mode = ModeAlphabet[scheme-1]\n                        [get_vlc2(gb, s->mode_code_vlc.table, 3, 3)];\n\n                s->macroblock_coding[current_macroblock] = coding_mode;\n                for (k = 0; k < 4; k++) {\n                    current_fragment =\n                        BLOCK_Y*s->fragment_width + BLOCK_X;\n                    if (s->all_fragments[current_fragment].coding_method !=\n                        MODE_COPY)\n                        s->all_fragments[current_fragment].coding_method =\n                            coding_mode;\n                }\n                for (k = 0; k < 2; k++) {\n                    current_fragment = s->fragment_start[k+1] +\n                        mb_y*(s->fragment_width>>1) + mb_x;\n                    if (s->all_fragments[current_fragment].coding_method !=\n                        MODE_COPY)\n                        s->all_fragments[current_fragment].coding_method =\n                            coding_mode;\n                }\n            }\n            }\n        }\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5555, "func": "static int dxtory_decode_v1_420(AVCodecContext *avctx, AVFrame *pic,\n                                const uint8_t *src, int src_size)\n{\n    int h, w;\n    uint8_t *Y1, *Y2, *U, *V;\n    int ret;\n\n    if (src_size < avctx->width * avctx->height * 3LL / 2) {\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    Y1 = pic->data[0];\n    Y2 = pic->data[0] + pic->linesize[0];\n    U  = pic->data[1];\n    V  = pic->data[2];\n    for (h = 0; h < avctx->height; h += 2) {\n        for (w = 0; w < avctx->width; w += 2) {\n            AV_COPY16(Y1 + w, src);\n            AV_COPY16(Y2 + w, src + 2);\n            U[w >> 1] = src[4] + 0x80;\n            V[w >> 1] = src[5] + 0x80;\n            src += 6;\n        }\n        Y1 += pic->linesize[0] << 1;\n        Y2 += pic->linesize[0] << 1;\n        U  += pic->linesize[1];\n        V  += pic->linesize[2];\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5556, "func": "int ssl3_new(SSL *s)\n\t{\n\tSSL3_STATE *s3;\n\n\tif ((s3=OPENSSL_malloc(sizeof *s3)) == NULL) goto err;\n\tmemset(s3,0,sizeof *s3);\n\tmemset(s3->rrec.seq_num,0,sizeof(s3->rrec.seq_num));\n\tmemset(s3->wrec.seq_num,0,sizeof(s3->wrec.seq_num));\n\n\ts->s3=s3;\n\n#ifndef OPENSSL_NO_SRP\n\tSSL_SRP_CTX_init(s);\n#endif\n\ts->method->ssl_clear(s);\n\treturn(1);\nerr:\n\treturn(0);\n\t}", "target": 1}
{"idx": 5557, "func": "AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c)\n{\n    AVStream *st;\n    int i;\n    AVStream **streams;\n\n    if (s->nb_streams >= INT_MAX/sizeof(*streams))\n        return NULL;\n    streams = av_realloc_array(s->streams, s->nb_streams + 1, sizeof(*streams));\n    if (!streams)\n        return NULL;\n    s->streams = streams;\n\n    st = av_mallocz(sizeof(AVStream));\n    if (!st)\n        return NULL;\n    if (!(st->info = av_mallocz(sizeof(*st->info)))) {\n        av_free(st);\n        return NULL;\n    }\n    st->info->last_dts = AV_NOPTS_VALUE;\n\n    st->codec = avcodec_alloc_context3(c);\n    if (s->iformat) {\n        /* no default bitrate if decoding */\n        st->codec->bit_rate = 0;\n\n        /* default pts setting is MPEG-like */\n        avpriv_set_pts_info(st, 33, 1, 90000);\n    }\n\n    st->index      = s->nb_streams;\n    st->start_time = AV_NOPTS_VALUE;\n    st->duration   = AV_NOPTS_VALUE;\n    /* we set the current DTS to 0 so that formats without any timestamps\n     * but durations get some timestamps, formats with some unknown\n     * timestamps have their first few packets buffered and the\n     * timestamps corrected before they are returned to the user */\n    st->cur_dts       = s->iformat ? RELATIVE_TS_BASE : 0;\n    st->first_dts     = AV_NOPTS_VALUE;\n    st->probe_packets = MAX_PROBE_PACKETS;\n    st->pts_wrap_reference = AV_NOPTS_VALUE;\n    st->pts_wrap_behavior = AV_PTS_WRAP_IGNORE;\n\n    st->last_IP_pts = AV_NOPTS_VALUE;\n    st->last_dts_for_order_check = AV_NOPTS_VALUE;\n    for (i = 0; i < MAX_REORDER_DELAY + 1; i++)\n        st->pts_buffer[i] = AV_NOPTS_VALUE;\n\n    st->sample_aspect_ratio = (AVRational) { 0, 1 };\n\n#if FF_API_R_FRAME_RATE\n    st->info->last_dts      = AV_NOPTS_VALUE;\n#endif\n    st->info->fps_first_dts = AV_NOPTS_VALUE;\n    st->info->fps_last_dts  = AV_NOPTS_VALUE;\n\n    st->inject_global_side_data = s->internal->inject_global_side_data;\n\n    s->streams[s->nb_streams++] = st;\n    return st;\n}", "target": 1}
{"idx": 5558, "func": "static void print_connection_info(SSL *con)\n{\n    const char *str;\n    X509 *peer;\n    char buf[BUFSIZ];\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    const unsigned char *next_proto_neg;\n    unsigned next_proto_neg_len;\n#endif\n    unsigned char *exportedkeymat;\n    int i;\n\n    if (s_brief)\n        print_ssl_summary(con);\n\n    PEM_write_bio_SSL_SESSION(bio_s_out, SSL_get_session(con));\n\n    peer = SSL_get_peer_certificate(con);\n    if (peer != NULL) {\n        BIO_printf(bio_s_out, \"Client certificate\\n\");\n        PEM_write_bio_X509(bio_s_out, peer);\n        dump_cert_text(bio_s_out, peer);\n        X509_free(peer);\n        peer = NULL;\n    }\n\n    if (SSL_get_shared_ciphers(con, buf, sizeof buf) != NULL)\n        BIO_printf(bio_s_out, \"Shared ciphers:%s\\n\", buf);\n    str = SSL_CIPHER_get_name(SSL_get_current_cipher(con));\n    ssl_print_sigalgs(bio_s_out, con);\n#ifndef OPENSSL_NO_EC\n    ssl_print_point_formats(bio_s_out, con);\n    ssl_print_groups(bio_s_out, con, 0);\n#endif\n    print_ca_names(bio_s_out, con);\n    BIO_printf(bio_s_out, \"CIPHER is %s\\n\", (str != NULL) ? str : \"(NONE)\");\n\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    SSL_get0_next_proto_negotiated(con, &next_proto_neg, &next_proto_neg_len);\n    if (next_proto_neg) {\n        BIO_printf(bio_s_out, \"NEXTPROTO is \");\n        BIO_write(bio_s_out, next_proto_neg, next_proto_neg_len);\n        BIO_printf(bio_s_out, \"\\n\");\n    }\n#endif\n#ifndef OPENSSL_NO_SRTP\n    {\n        SRTP_PROTECTION_PROFILE *srtp_profile\n            = SSL_get_selected_srtp_profile(con);\n\n        if (srtp_profile)\n            BIO_printf(bio_s_out, \"SRTP Extension negotiated, profile=%s\\n\",\n                       srtp_profile->name);\n    }\n#endif\n    if (SSL_session_reused(con))\n        BIO_printf(bio_s_out, \"Reused session-id\\n\");\n    BIO_printf(bio_s_out, \"Secure Renegotiation IS%s supported\\n\",\n               SSL_get_secure_renegotiation_support(con) ? \"\" : \" NOT\");\n    if (keymatexportlabel != NULL) {\n        BIO_printf(bio_s_out, \"Keying material exporter:\\n\");\n        BIO_printf(bio_s_out, \"    Label: '%s'\\n\", keymatexportlabel);\n        BIO_printf(bio_s_out, \"    Length: %i bytes\\n\", keymatexportlen);\n        exportedkeymat = app_malloc(keymatexportlen, \"export key\");\n        if (!SSL_export_keying_material(con, exportedkeymat,\n                                        keymatexportlen,\n                                        keymatexportlabel,\n                                        strlen(keymatexportlabel),\n                                        NULL, 0, 0)) {\n            BIO_printf(bio_s_out, \"    Error\\n\");\n        } else {\n            BIO_printf(bio_s_out, \"    Keying material: \");\n            for (i = 0; i < keymatexportlen; i++)\n                BIO_printf(bio_s_out, \"%02X\", exportedkeymat[i]);\n            BIO_printf(bio_s_out, \"\\n\");\n        }\n        OPENSSL_free(exportedkeymat);\n    }\n\n    (void)BIO_flush(bio_s_out);\n}", "target": 0}
{"idx": 5559, "func": "void sk_pop_free(_STACK *st, void (*func)(void *))\n\t{\n\tint i;\n\n\tif (st == NULL) return;\n\tfor (i=0; i<st->num; i++)\n\t\tif (st->data[i] != NULL)\n\t\t\tfunc(st->data[i]);\n\tsk_free(st);\n\t}", "target": 0}
{"idx": 5560, "func": "static inline int svq3_decode_block(GetBitContext *gb, DCTELEM *block,\n                                    int index, const int type)\n{\n    static const uint8_t *const scan_patterns[4] =\n    { luma_dc_zigzag_scan, zigzag_scan, svq3_scan, chroma_dc_scan };\n\n    int run, level, sign, vlc, limit;\n    const int intra = (3 * type) >> 2;\n    const uint8_t *const scan = scan_patterns[type];\n\n    for (limit = (16 >> intra); index < 16; index = limit, limit += 8) {\n        for (; (vlc = svq3_get_ue_golomb(gb)) != 0; index++) {\n\n          if (vlc < 0)\n              return -1;\n\n          sign = (vlc & 0x1) - 1;\n          vlc  = (vlc + 1) >> 1;\n\n          if (type == 3) {\n              if (vlc < 3) {\n                  run   = 0;\n                  level = vlc;\n              } else if (vlc < 4) {\n                  run   = 1;\n                  level = 1;\n              } else {\n                  run   = (vlc & 0x3);\n                  level = ((vlc + 9) >> 2) - run;\n              }\n          } else {\n              if (vlc < 16U) {\n                  run   = svq3_dct_tables[intra][vlc].run;\n                  level = svq3_dct_tables[intra][vlc].level;\n              } else if (intra) {\n                  run   = (vlc & 0x7);\n                  level = (vlc >> 3) + ((run == 0) ? 8 : ((run < 2) ? 2 : ((run < 5) ? 0 : -1)));\n              } else {\n                  run   = (vlc & 0xF);\n                  level = (vlc >> 4) + ((run == 0) ? 4 : ((run < 3) ? 2 : ((run < 10) ? 1 : 0)));\n              }\n          }\n\n          if ((index += run) >= limit)\n              return -1;\n\n          block[scan[index]] = (level ^ sign) - sign;\n        }\n\n        if (type != 2) {\n            break;\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5561, "func": "int DSO_set_filename(DSO *dso, const char *filename)\n\t{\n\tchar *copied;\n\n\tif((dso == NULL) || (filename == NULL))\n\t\t{\n\t\tDSOerr(DSO_F_DSO_SET_FILENAME,ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn(0);\n\t\t}\n\tif(dso->loaded_filename)\n\t\t{\n\t\tDSOerr(DSO_F_DSO_SET_FILENAME,DSO_R_DSO_ALREADY_LOADED);\n\t\treturn(0);\n\t\t}\n\t/* We'll duplicate filename */\n\tcopied = OPENSSL_malloc(strlen(filename) + 1);\n\tif(copied == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DSO_SET_FILENAME,ERR_R_MALLOC_FAILURE);\n\t\treturn(0);\n\t\t}\n\tstrcpy(copied, filename);\n\tif(dso->filename)\n\t\tOPENSSL_free(dso->filename);\n\tdso->filename = copied;\n\treturn(1);\n\t}", "target": 1}
{"idx": 5562, "func": "static int wpacket_intern_close(WPACKET *pkt)\n{\n    WPACKET_SUB *sub = pkt->subs;\n    size_t packlen = pkt->written - sub->pwritten;\n\n    if (packlen == 0\n            && (sub->flags & WPACKET_FLAGS_NON_ZERO_LENGTH) != 0)\n        return 0;\n\n    if (packlen == 0\n            && sub->flags & WPACKET_FLAGS_ABANDON_ON_ZERO_LENGTH) {\n        /* Deallocate any bytes allocated for the length of the WPACKET */\n        if ((pkt->curr - sub->lenbytes) == sub->packet_len) {\n            pkt->written -= sub->lenbytes;\n            pkt->curr -= sub->lenbytes;\n        }\n\n        /* Don't write out the packet length */\n        sub->packet_len = 0;\n        sub->lenbytes = 0;\n    }\n\n    /* Write out the WPACKET length if needed */\n    if (sub->lenbytes > 0\n                && !put_value(&GETBUF(pkt)[sub->packet_len], packlen,\n                              sub->lenbytes))\n            return 0;\n\n    pkt->subs = sub->parent;\n    OPENSSL_free(sub);\n\n    return 1;\n}", "target": 1}
{"idx": 5563, "func": "static int gxf_packet(AVFormatContext *s, AVPacket *pkt) {\n    ByteIOContext *pb = s->pb;\n    pkt_type_t pkt_type;\n    int pkt_len;\n    while (!url_feof(pb)) {\n        AVStream *st;\n        int track_type, track_id, ret;\n        int field_nr, field_info, skip = 0;\n        int stream_index;\n        if (!parse_packet_header(pb, &pkt_type, &pkt_len)) {\n            if (!url_feof(pb))\n                av_log(s, AV_LOG_ERROR, \"GXF: sync lost\\n\");\n            return -1;\n        }\n        if (pkt_type == PKT_FLT) {\n            gxf_read_index(s, pkt_len);\n            continue;\n        }\n        if (pkt_type != PKT_MEDIA) {\n            url_fskip(pb, pkt_len);\n            continue;\n        }\n        if (pkt_len < 16) {\n            av_log(s, AV_LOG_ERROR, \"GXF: invalid media packet length\\n\");\n            continue;\n        }\n        pkt_len -= 16;\n        track_type = get_byte(pb);\n        track_id = get_byte(pb);\n        stream_index = get_sindex(s, track_id, track_type);\n        if (stream_index < 0)\n            return stream_index;\n        st = s->streams[stream_index];\n        field_nr = get_be32(pb);\n        field_info = get_be32(pb);\n        get_be32(pb); // \"timeline\" field number\n        get_byte(pb); // flags\n        get_byte(pb); // reserved\n        if (st->codec->codec_id == CODEC_ID_PCM_S24LE ||\n            st->codec->codec_id == CODEC_ID_PCM_S16LE) {\n            int first = field_info >> 16;\n            int last  = field_info & 0xffff; // last is exclusive\n            int bps = av_get_bits_per_sample(st->codec->codec_id)>>3;\n            if (first <= last && last*bps <= pkt_len) {\n                url_fskip(pb, first*bps);\n                skip = pkt_len - last*bps;\n                pkt_len = (last-first)*bps;\n            } else\n                av_log(s, AV_LOG_ERROR, \"invalid first and last sample values\\n\");\n        }\n        ret = av_get_packet(pb, pkt, pkt_len);\n        if (skip)\n            url_fskip(pb, skip);\n        pkt->stream_index = stream_index;\n        pkt->dts = field_nr;\n        return ret;\n    }\n    return AVERROR(EIO);\n}", "target": 0}
{"idx": 5564, "func": "static void sha512_transform(uint64_t *state, const uint8_t buffer[128])\n{\n    uint64_t a, b, c, d, e, f, g, h;\n    uint64_t block[80];\n    uint64_t T1;\n    int i;\n\n    a = state[0];\n    b = state[1];\n    c = state[2];\n    d = state[3];\n    e = state[4];\n    f = state[5];\n    g = state[6];\n    h = state[7];\n#if CONFIG_SMALL\n    for (i = 0; i < 80; i++) {\n        uint64_t T2;\n        if (i < 16)\n            T1 = blk0(i);\n        else\n            T1 = blk(i);\n        T1 += h + Sigma1_512(e) + Ch(e, f, g) + K512[i];\n        T2 = Sigma0_512(a) + Maj(a, b, c);\n        h = g;\n        g = f;\n        f = e;\n        e = d + T1;\n        d = c;\n        c = b;\n        b = a;\n        a = T1 + T2;\n    }\n#else\n    for (i = 0; i < 16 - 7;) {\n        ROUND512_0_TO_15(a, b, c, d, e, f, g, h);\n        ROUND512_0_TO_15(h, a, b, c, d, e, f, g);\n        ROUND512_0_TO_15(g, h, a, b, c, d, e, f);\n        ROUND512_0_TO_15(f, g, h, a, b, c, d, e);\n        ROUND512_0_TO_15(e, f, g, h, a, b, c, d);\n        ROUND512_0_TO_15(d, e, f, g, h, a, b, c);\n        ROUND512_0_TO_15(c, d, e, f, g, h, a, b);\n        ROUND512_0_TO_15(b, c, d, e, f, g, h, a);\n    }\n\n    for (; i < 80 - 7;) {\n        ROUND512_16_TO_80(a, b, c, d, e, f, g, h);\n        ROUND512_16_TO_80(h, a, b, c, d, e, f, g);\n        ROUND512_16_TO_80(g, h, a, b, c, d, e, f);\n        ROUND512_16_TO_80(f, g, h, a, b, c, d, e);\n        ROUND512_16_TO_80(e, f, g, h, a, b, c, d);\n        ROUND512_16_TO_80(d, e, f, g, h, a, b, c);\n        ROUND512_16_TO_80(c, d, e, f, g, h, a, b);\n        ROUND512_16_TO_80(b, c, d, e, f, g, h, a);\n    }\n#endif\n    state[0] += a;\n    state[1] += b;\n    state[2] += c;\n    state[3] += d;\n    state[4] += e;\n    state[5] += f;\n    state[6] += g;\n    state[7] += h;\n}", "target": 1}
{"idx": 5565, "func": "static int create_new_vfile(char *userid, char *password, const char *filename)\n{\n    char *gNid = NULL;\n    OPENSSL_STRING *row = OPENSSL_zalloc(sizeof(row) * (DB_NUMBER + 1));\n    TXT_DB *db = NULL;\n    int ret = 0;\n    BIO *out = NULL, *dummy = BIO_new_mem_buf(\"\", 0);\n    size_t i;\n\n    if (!TEST_ptr(dummy) || !TEST_ptr(row))\n        goto end;\n\n    gNid = SRP_create_verifier(userid, password, &row[DB_srpsalt],\n                               &row[DB_srpverifier], NULL, NULL);\n    if (!TEST_ptr(gNid))\n        goto end;\n\n    /*\n     * The only way to create an empty TXT_DB is to provide a BIO with no data\n     * in it!\n     */\n    db = TXT_DB_read(dummy, DB_NUMBER);\n    if (!TEST_ptr(db))\n        goto end;\n\n    out = BIO_new_file(filename, \"w\");\n    if (!TEST_ptr(out))\n        goto end;\n\n    row[DB_srpid] = OPENSSL_strdup(userid);\n    row[DB_srptype] = OPENSSL_strdup(\"V\");\n    row[DB_srpgN] = OPENSSL_strdup(gNid);\n\n    if (!TEST_ptr(row[DB_srpid])\n            || !TEST_ptr(row[DB_srptype])\n            || !TEST_ptr(row[DB_srpgN])\n            || !TEST_true(TXT_DB_insert(db, row)))\n        goto end;\n\n    row = NULL;\n\n    if (!TXT_DB_write(out, db))\n        goto end;\n\n    ret = 1;\n end:\n    if (row != NULL) {\n        for (i = 0; i < DB_NUMBER; i++)\n            OPENSSL_free(row[i]);\n    }\n    OPENSSL_free(row);\n    BIO_free(dummy);\n    BIO_free(out);\n    TXT_DB_free(db);\n\n    return ret;\n}", "target": 1}
{"idx": 5566, "func": "void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){\n    int i, dc = (block[0] + 15) >> 5;\n\n    for(i = 0; i < 8; i++){\n        dest[0] = av_clip_uint8(dest[0] + dc);\n        dest[1] = av_clip_uint8(dest[1] + dc);\n        dest[2] = av_clip_uint8(dest[2] + dc);\n        dest[3] = av_clip_uint8(dest[3] + dc);\n        dest[4] = av_clip_uint8(dest[4] + dc);\n        dest[5] = av_clip_uint8(dest[5] + dc);\n        dest[6] = av_clip_uint8(dest[6] + dc);\n        dest[7] = av_clip_uint8(dest[7] + dc);\n        dest += line_size;\n    }\n}", "target": 1}
{"idx": 5567, "func": "static inline int available_samples(AVFrame *out)\n{\n    int samples;\n    int bytes_per_sample = av_get_bytes_per_sample(out->format);\n    if (!bytes_per_sample)\n        return AVERROR(EINVAL);\n\n    samples = out->linesize[0] / bytes_per_sample;\n    if (av_sample_fmt_is_planar(out->format)) {\n        return samples;\n    } else {\n        int channels = av_get_channel_layout_nb_channels(out->channel_layout);\n        return samples / channels;\n    }\n}", "target": 0}
{"idx": 5568, "func": "void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)\n{\n    int i;\n\n    for (i=0; i < in->n; i++) {\n        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);\n\n        if (in->pitch_lag > 0)\n        do {\n            out[x] = 0.0;\n            x += in->pitch_lag;\n        } while (x < size && repeats);\n    }\n}", "target": 0}
{"idx": 5569, "func": "static int decode_p_frame(FourXContext *f, const uint8_t *buf, int length)\n{\n    int x, y;\n    const int width  = f->avctx->width;\n    const int height = f->avctx->height;\n    uint16_t *src    = (uint16_t *)f->last_picture.data[0];\n    uint16_t *dst    = (uint16_t *)f->current_picture.data[0];\n    const int stride =             f->current_picture.linesize[0] >> 1;\n    unsigned int bitstream_size, bytestream_size, wordstream_size, extra,\n                 bytestream_offset, wordstream_offset;\n\n    if (f->version > 1) {\n        extra           = 20;\n        if (length < extra)\n            return -1;\n        bitstream_size  = AV_RL32(buf + 8);\n        wordstream_size = AV_RL32(buf + 12);\n        bytestream_size = AV_RL32(buf + 16);\n    } else {\n        extra           = 0;\n        bitstream_size  = AV_RL16(buf - 4);\n        wordstream_size = AV_RL16(buf - 2);\n        bytestream_size = FFMAX(length - bitstream_size - wordstream_size, 0);\n    }\n\n    if (bitstream_size > length ||\n        bytestream_size > length - bitstream_size ||\n        wordstream_size > length - bytestream_size - bitstream_size ||\n        extra > length - bytestream_size - bitstream_size - wordstream_size) {\n        av_log(f->avctx, AV_LOG_ERROR, \"lengths %d %d %d %d\\n\", bitstream_size, bytestream_size, wordstream_size,\n        bitstream_size+ bytestream_size+ wordstream_size - length);\n        return -1;\n    }\n\n    av_fast_malloc(&f->bitstream_buffer, &f->bitstream_buffer_size,\n                   bitstream_size + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!f->bitstream_buffer)\n        return AVERROR(ENOMEM);\n    f->dsp.bswap_buf(f->bitstream_buffer, (const uint32_t*)(buf + extra),\n                     bitstream_size / 4);\n    memset((uint8_t*)f->bitstream_buffer + bitstream_size,\n           0, FF_INPUT_BUFFER_PADDING_SIZE);\n    init_get_bits(&f->gb, f->bitstream_buffer, 8 * bitstream_size);\n\n    wordstream_offset = extra + bitstream_size;\n    bytestream_offset = extra + bitstream_size + wordstream_size;\n    bytestream2_init(&f->g2, buf + wordstream_offset,\n                     length - wordstream_offset);\n    bytestream2_init(&f->g, buf + bytestream_offset,\n                     length - bytestream_offset);\n\n    init_mv(f);\n\n    for (y = 0; y < height; y += 8) {\n        for (x = 0; x < width; x += 8)\n            decode_p_block(f, dst + x, src + x, 3, 3, stride);\n        src += 8 * stride;\n        dst += 8 * stride;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5570, "func": "static void heap_bubble_down(AVFilterGraph *graph,\n                             AVFilterLink *link, int index)\n{\n    AVFilterLink **links = graph->sink_links;\n\n    av_assert0(index >= 0);\n\n    while (1) {\n        int child = 2 * index + 1;\n        if (child >= graph->sink_links_count)\n            break;\n        if (child + 1 < graph->sink_links_count &&\n            links[child + 1]->current_pts_us < links[child]->current_pts_us)\n            child++;\n        if (link->current_pts_us < links[child]->current_pts_us)\n            break;\n        links[index] = links[child];\n        links[index]->age_index = index;\n        index = child;\n    }\n    links[index] = link;\n    link->age_index = index;\n}", "target": 1}
{"idx": 5571, "func": "int test_mod(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM *a,*b,*c,*d,*e;\n\tint i;\n\tint j;\n\n\ta=BN_new();\n\tb=BN_new();\n\tc=BN_new();\n\td=BN_new();\n\te=BN_new();\n\n\tBN_bntest_rand(a,1024,0,0); /**/\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(b,450+i*10,0,0); /**/\n\t\ta->neg=rand_neg();\n\t\tb->neg=rand_neg();\n\t\tif (bp == NULL)\n\t\t\tfor (j=0; j<100; j++)\n\t\t\t\tBN_mod(c,a,b,ctx);/**/\n\t\tBN_mod(c,a,b,ctx);/**/\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,a);\n\t\t\t\tBIO_puts(bp,\" % \");\n\t\t\t\tBN_print(bp,b);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(d,e,a,b,ctx);\n\t\tBN_sub(e,e,c);\n\t\tif(!BN_is_zero(e))\n\t\t    {\n\t\t    fprintf(stderr,\"Modulo test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(a);\n\tBN_free(b);\n\tBN_free(c);\n\tBN_free(d);\n\tBN_free(e);\n\treturn(1);\n\t}", "target": 0}
{"idx": 5572, "func": "static int mpeg4_decode_header(AVCodecParserContext *s1, AVCodecContext *avctx,\n                               const uint8_t *buf, int buf_size)\n{\n    struct Mp4vParseContext *pc = s1->priv_data;\n    Mpeg4DecContext *dec_ctx = &pc->dec_ctx;\n    MpegEncContext *s = &dec_ctx->m;\n    GetBitContext gb1, *gb = &gb1;\n    int ret;\n\n    s->avctx               = avctx;\n    s->current_picture_ptr = &s->current_picture;\n\n    if (avctx->extradata_size && pc->first_picture) {\n        init_get_bits(gb, avctx->extradata, avctx->extradata_size * 8);\n        ret = ff_mpeg4_decode_picture_header(dec_ctx, gb);\n    }\n\n    init_get_bits(gb, buf, 8 * buf_size);\n    ret = ff_mpeg4_decode_picture_header(dec_ctx, gb);\n    if (s->width && (!avctx->width || !avctx->height ||\n                     !avctx->coded_width || !avctx->coded_height)) {\n        ret = ff_set_dimensions(avctx, s->width, s->height);\n        if (ret < 0)\n            return ret;\n    }\n    if((s1->flags & PARSER_FLAG_USE_CODEC_TS) && s->avctx->time_base.den>0 && ret>=0){\n        av_assert1(s1->pts == AV_NOPTS_VALUE);\n        av_assert1(s1->dts == AV_NOPTS_VALUE);\n\n        s1->pts = av_rescale_q(s->time, (AVRational){1, s->avctx->time_base.den}, (AVRational){1, 1200000});\n    }\n\n    s1->pict_type     = s->pict_type;\n    pc->first_picture = 0;\n    return ret;\n}", "target": 1}
{"idx": 5573, "func": "int ff_h264_decode_extradata(H264Context *h, const uint8_t *buf, int size)\n{\n    AVCodecContext *avctx = h->s.avctx;\n\n    if (!buf || size <= 0)\n        return -1;\n\n    if (buf[0] == 1) {\n        int i, cnt, nalsize;\n        const unsigned char *p = buf;\n\n        h->is_avc = 1;\n\n        if (size < 7) {\n            av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");\n            return -1;\n        }\n        /* sps and pps in the avcC always have length coded with 2 bytes,\n         * so put a fake nal_length_size = 2 while parsing them */\n        h->nal_length_size = 2;\n        // Decode sps from avcC\n        cnt = *(p + 5) & 0x1f; // Number of sps\n        p  += 6;\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if(nalsize > size - (p-buf))\n                return -1;\n            if (decode_nal_units(h, p, nalsize) < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding sps %d from avcC failed\\n\", i);\n                return -1;\n            }\n            p += nalsize;\n        }\n        // Decode pps from avcC\n        cnt = *(p++); // Number of pps\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if(nalsize > size - (p-buf))\n                return -1;\n            if (decode_nal_units(h, p, nalsize) < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding pps %d from avcC failed\\n\", i);\n                return -1;\n            }\n            p += nalsize;\n        }\n        // Now store right nal length size, that will be used to parse all other nals\n        h->nal_length_size = (buf[4] & 0x03) + 1;\n    } else {\n        h->is_avc = 0;\n        if (decode_nal_units(h, buf, size) < 0)\n            return -1;\n    }\n    return size;\n}", "target": 1}
{"idx": 5574, "func": "void avfilter_free(AVFilterContext *filter)\n{\n    int i;\n    AVFilterLink *link;\n\n    if (!filter)\n        return;\n\n    if (filter->filter->uninit)\n        filter->filter->uninit(filter);\n\n    for (i = 0; i < filter->input_count; i++) {\n        if ((link = filter->inputs[i])) {\n            if (link->src)\n                link->src->outputs[link->srcpad - link->src->output_pads] = NULL;\n            avfilter_formats_unref(&link->in_formats);\n            avfilter_formats_unref(&link->out_formats);\n        }\n        avfilter_link_free(&link);\n    }\n    for (i = 0; i < filter->output_count; i++) {\n        if ((link = filter->outputs[i])) {\n            if (link->dst)\n                link->dst->inputs[link->dstpad - link->dst->input_pads] = NULL;\n            avfilter_formats_unref(&link->in_formats);\n            avfilter_formats_unref(&link->out_formats);\n        }\n        avfilter_link_free(&link);\n    }\n\n    av_freep(&filter->name);\n    av_freep(&filter->input_pads);\n    av_freep(&filter->output_pads);\n    av_freep(&filter->inputs);\n    av_freep(&filter->outputs);\n    av_freep(&filter->priv);\n    while(filter->command_queue){\n        command_queue_pop(filter);\n    }\n    av_free(filter);\n}", "target": 1}
{"idx": 5575, "func": "static int kek_wrap_key(unsigned char *out, size_t *outlen,\n\t\tconst unsigned char *in, size_t inlen, EVP_CIPHER_CTX *ctx)\n\t{\n\tsize_t blocklen = EVP_CIPHER_CTX_block_size(ctx);\n\tsize_t olen;\n\tint dummy;\n\t/* First decide length of output buffer: need header and round up to\n\t * multiple of block length.\n\t */\n\tolen = (inlen + 4 + blocklen - 1)/blocklen;\n\tolen *= blocklen;\n\tif (olen < 2 * blocklen)\n\t\t{\n\t\t/* Key too small */\n\t\treturn 0;\n\t\t}\n\tif (inlen > 0xFF)\n\t\t{\n\t\t/* Key too large */\n\t\treturn 0;\n\t\t}\n\tif (out)\n\t\t{\n\t\t/* Set header */\n\t\tout[0] = (unsigned char)inlen;\n\t\tout[1] = in[0] ^ 0xFF;\n\t\tout[2] = in[1] ^ 0xFF;\n\t\tout[3] = in[2] ^ 0xFF;\n\t\tmemcpy(out + 4, in, inlen);\n\t\t/* Add random padding to end */\n\t\tif (olen > inlen + 4)\n\t\t\tRAND_pseudo_bytes(out + 4 + inlen, olen - 4 - inlen);\n\t\t/* Encrypt twice */\n\t\tif (!EVP_EncryptUpdate(ctx, out, &dummy, out, olen)\n\t\t    || !EVP_EncryptUpdate(ctx, out, &dummy, out, olen))\n\t\t\treturn 0;\n\t\t}\n\n\t*outlen = olen;\n\n\treturn 1;\n\t}", "target": 1}
{"idx": 5576, "func": "int BIO_dump_indent_cb(int (*cb) (const void *data, size_t len, void *u),\n                       void *u, const char *s, int len, int indent)\n{\n    int ret = 0;\n    char buf[288 + 1], tmp[20], str[128 + 1];\n    int i, j, rows, trc;\n    unsigned char ch;\n    int dump_width;\n\n    trc = 0;\n\n#ifdef TRUNCATE\n    for (; (len > 0) && ((s[len - 1] == ' ') || (s[len - 1] == '\\0')); len--)\n        trc++;\n#endif\n\n    if (indent < 0)\n        indent = 0;\n    if (indent) {\n        if (indent > 128)\n            indent = 128;\n        memset(str, ' ', indent);\n    }\n    str[indent] = '\\0';\n\n    dump_width = DUMP_WIDTH_LESS_INDENT(indent);\n    rows = (len / dump_width);\n    if ((rows * dump_width) < len)\n        rows++;\n    for (i = 0; i < rows; i++) {\n        BUF_strlcpy(buf, str, sizeof buf);\n        BIO_snprintf(tmp, sizeof tmp, \"%04x - \", i * dump_width);\n        BUF_strlcat(buf, tmp, sizeof buf);\n        for (j = 0; j < dump_width; j++) {\n            if (((i * dump_width) + j) >= len) {\n                BUF_strlcat(buf, \"   \", sizeof buf);\n            } else {\n                ch = ((unsigned char)*(s + i * dump_width + j)) & 0xff;\n                BIO_snprintf(tmp, sizeof tmp, \"%02x%c\", ch,\n                             j == 7 ? '-' : ' ');\n                BUF_strlcat(buf, tmp, sizeof buf);\n            }\n        }\n        BUF_strlcat(buf, \"  \", sizeof buf);\n        for (j = 0; j < dump_width; j++) {\n            if (((i * dump_width) + j) >= len)\n                break;\n            ch = ((unsigned char)*(s + i * dump_width + j)) & 0xff;\n#ifndef CHARSET_EBCDIC\n            BIO_snprintf(tmp, sizeof tmp, \"%c\",\n                         ((ch >= ' ') && (ch <= '~')) ? ch : '.');\n#else\n            BIO_snprintf(tmp, sizeof tmp, \"%c\",\n                         ((ch >= os_toascii[' ']) && (ch <= os_toascii['~']))\n                         ? os_toebcdic[ch]\n                         : '.');\n#endif\n            BUF_strlcat(buf, tmp, sizeof buf);\n        }\n        BUF_strlcat(buf, \"\\n\", sizeof buf);\n        /*\n         * if this is the last call then update the ddt_dump thing so that we\n         * will move the selection point in the debug window\n         */\n        ret += cb((void *)buf, strlen(buf), u);\n    }\n#ifdef TRUNCATE\n    if (trc > 0) {\n        BIO_snprintf(buf, sizeof buf, \"%s%04x - <SPACES/NULS>\\n\", str,\n                     len + trc);\n        ret += cb((void *)buf, strlen(buf), u);\n    }\n#endif\n    return (ret);\n}", "target": 1}
{"idx": 5577, "func": "static void choose_sample_rate(AVStream *st, AVCodec *codec)\n{\n    if (codec && codec->supported_samplerates) {\n        const int *p  = codec->supported_samplerates;\n        int best      = 0;\n        int best_dist = INT_MAX;\n        for (; *p; p++) {\n            int dist = abs(st->codec->sample_rate - *p);\n            if (dist < best_dist) {\n                best_dist = dist;\n                best      = *p;\n            }\n        }\n        if (best_dist) {\n            int i;\n            const int *sample_rates = codec->supported_samplerates;\n            av_log(st->codec, AV_LOG_WARNING,\n                   \"Requested sampling rate (%dHz) unsupported, using %dHz instead\\n\"\n                   \"Available sampling rates for %s:\",\n                   st->codec->sample_rate, best, codec->name);\n            for (i = 0; sample_rates[i]; i++) {\n                if (!sample_rates[i + 1]) av_log(st->codec, AV_LOG_WARNING, \" and\");\n                else if (i)               av_log(st->codec, AV_LOG_WARNING, \",\");\n                av_log(st->codec, AV_LOG_WARNING, \" %d\", sample_rates[i]);\n            }\n            av_log(st->codec, AV_LOG_WARNING, \".\\n\");\n        }\n        st->codec->sample_rate = best;\n    }\n}", "target": 1}
{"idx": 5578, "func": "int tls_construct_cert_status_body(SSL *s, WPACKET *pkt)\n{\n    if (!WPACKET_put_bytes_u8(pkt, s->tlsext_status_type)\n            || !WPACKET_sub_memcpy_u24(pkt, s->tlsext_ocsp_resp,\n                                       s->tlsext_ocsp_resplen)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CERT_STATUS_BODY, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    return 1;\n}", "target": 0}
{"idx": 5579, "func": "static int codec2subblock(SANMVideoContext *ctx, int cx, int cy, int blk_size)\n{\n    int16_t mx, my, index;\n    int opcode;\n\n    if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n        return AVERROR_INVALIDDATA;\n\n    opcode = bytestream2_get_byteu(&ctx->gb);\n\n    av_dlog(ctx->avctx, \"opcode 0x%0X cx %d cy %d blk %d\\n\", opcode, cx, cy, blk_size);\n    switch (opcode) {\n    default:\n        mx = motion_vectors[opcode][0];\n        my = motion_vectors[opcode][1];\n\n        if (good_mvec(ctx, cx, cy, mx, my, blk_size)) {\n            copy_block(ctx->frm0 + cx      + ctx->pitch *  cy,\n                       ctx->frm2 + cx + mx + ctx->pitch * (cy + my),\n                       blk_size, ctx->pitch);\n        }\n        break;\n    case 0xF5:\n        if (bytestream2_get_bytes_left(&ctx->gb) < 2)\n            return AVERROR_INVALIDDATA;\n        index = bytestream2_get_le16u(&ctx->gb);\n\n        mx = index % ctx->width;\n        my = index / ctx->width;\n\n        if (good_mvec(ctx, cx, cy, mx, my, blk_size)) {\n            copy_block(ctx->frm0 + cx      + ctx->pitch *  cy,\n                       ctx->frm2 + cx + mx + ctx->pitch * (cy + my),\n                       blk_size, ctx->pitch);\n        }\n        break;\n    case 0xF6:\n        copy_block(ctx->frm0 + cx + ctx->pitch * cy,\n                   ctx->frm1 + cx + ctx->pitch * cy,\n                   blk_size, ctx->pitch);\n        break;\n    case 0xF7:\n        opcode_0xf7(ctx, cx, cy, blk_size, ctx->pitch);\n        break;\n\n    case 0xF8:\n        opcode_0xf8(ctx, cx, cy, blk_size, ctx->pitch);\n        break;\n    case 0xF9:\n    case 0xFA:\n    case 0xFB:\n    case 0xFC:\n        fill_block(ctx->frm0 + cx + cy * ctx->pitch,\n                   ctx->small_codebook[opcode - 0xf9], blk_size, ctx->pitch);\n        break;\n    case 0xFD:\n        if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n            return AVERROR_INVALIDDATA;\n        fill_block(ctx->frm0 + cx + cy * ctx->pitch,\n                   ctx->codebook[bytestream2_get_byteu(&ctx->gb)], blk_size, ctx->pitch);\n        break;\n    case 0xFE:\n        if (bytestream2_get_bytes_left(&ctx->gb) < 2)\n            return AVERROR_INVALIDDATA;\n        fill_block(ctx->frm0 + cx + cy * ctx->pitch,\n                   bytestream2_get_le16u(&ctx->gb), blk_size, ctx->pitch);\n        break;\n    case 0xFF:\n        if (blk_size == 2) {\n            opcode_0xf8(ctx, cx, cy, blk_size, ctx->pitch);\n        } else {\n            blk_size >>= 1;\n            if (codec2subblock(ctx, cx           , cy           , blk_size))\n                return AVERROR_INVALIDDATA;\n            if (codec2subblock(ctx, cx + blk_size, cy           , blk_size))\n                return AVERROR_INVALIDDATA;\n            if (codec2subblock(ctx, cx           , cy + blk_size, blk_size))\n                return AVERROR_INVALIDDATA;\n            if (codec2subblock(ctx, cx + blk_size, cy + blk_size, blk_size))\n                return AVERROR_INVALIDDATA;\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"idx": 5580, "func": "static int\nfmtfp(char **sbuffer,\n      char **buffer,\n      size_t *currlen,\n      size_t *maxlen, LDOUBLE fvalue, int min, int max, int flags)\n{\n    int signvalue = 0;\n    LDOUBLE ufvalue;\n    char iconvert[20];\n    char fconvert[20];\n    int iplace = 0;\n    int fplace = 0;\n    int padlen = 0;\n    int zpadlen = 0;\n    long intpart;\n    long fracpart;\n    long max10;\n\n    if (max < 0)\n        max = 6;\n    ufvalue = abs_val(fvalue);\n    if (fvalue < 0)\n        signvalue = '-';\n    else if (flags & DP_F_PLUS)\n        signvalue = '+';\n    else if (flags & DP_F_SPACE)\n        signvalue = ' ';\n\n    intpart = (long)ufvalue;\n\n    /*\n     * sorry, we only support 9 digits past the decimal because of our\n     * conversion method\n     */\n    if (max > 9)\n        max = 9;\n\n    /*\n     * we \"cheat\" by converting the fractional part to integer by multiplying\n     * by a factor of 10\n     */\n    max10 = roundv(pow_10(max));\n    fracpart = roundv(pow_10(max) * (ufvalue - intpart));\n\n    if (fracpart >= max10) {\n        intpart++;\n        fracpart -= max10;\n    }\n\n    /* convert integer part */\n    do {\n        iconvert[iplace++] = \"0123456789\"[intpart % 10];\n        intpart = (intpart / 10);\n    } while (intpart && (iplace < (int)sizeof(iconvert)));\n    if (iplace == sizeof iconvert)\n        iplace--;\n    iconvert[iplace] = 0;\n\n    /* convert fractional part */\n    do {\n        fconvert[fplace++] = \"0123456789\"[fracpart % 10];\n        fracpart = (fracpart / 10);\n    } while (fplace < max);\n    if (fplace == sizeof fconvert)\n        fplace--;\n    fconvert[fplace] = 0;\n\n    /* -1 for decimal point, another -1 if we are printing a sign */\n    padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);\n    zpadlen = max - fplace;\n    if (zpadlen < 0)\n        zpadlen = 0;\n    if (padlen < 0)\n        padlen = 0;\n    if (flags & DP_F_MINUS)\n        padlen = -padlen;\n\n    if ((flags & DP_F_ZERO) && (padlen > 0)) {\n        if (signvalue) {\n            if (!doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue))\n                return 0;\n            --padlen;\n            signvalue = 0;\n        }\n        while (padlen > 0) {\n            if (!doapr_outch(sbuffer, buffer, currlen, maxlen, '0'))\n                return 0;\n            --padlen;\n        }\n    }\n    while (padlen > 0) {\n        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, ' '))\n            return 0;\n        --padlen;\n    }\n    if (signvalue && !doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue))\n        return 0;\n\n    while (iplace > 0) {\n        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, iconvert[--iplace]))\n            return 0;\n    }\n\n    /*\n     * Decimal point. This should probably use locale to find the correct\n     * char to print out.\n     */\n    if (max > 0 || (flags & DP_F_NUM)) {\n        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, '.'))\n            return 0;\n\n        while (fplace > 0) {\n            if(!doapr_outch(sbuffer, buffer, currlen, maxlen,\n                            fconvert[--fplace]))\n                return 0;\n        }\n    }\n    while (zpadlen > 0) {\n        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, '0'))\n            return 0;\n        --zpadlen;\n    }\n\n    while (padlen < 0) {\n        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, ' '))\n            return 0;\n        ++padlen;\n    }\n    return 1;\n}", "target": 1}
{"idx": 5581, "func": "AVResampleContext *swr_resample_init(AVResampleContext *c, int out_rate, int in_rate, int filter_size, int phase_shift, int linear, double cutoff){\n    double factor= FFMIN(out_rate * cutoff / in_rate, 1.0);\n    int phase_count= 1<<phase_shift;\n\n    if (!c || c->phase_shift != phase_shift || c->linear!=linear || c->factor != factor\n           || c->filter_length != FFMAX((int)ceil(filter_size/factor), 1)) {\n        c = av_mallocz(sizeof(AVResampleContext));\n        if (!c)\n            return NULL;\n\n        c->phase_shift   = phase_shift;\n        c->phase_mask    = phase_count - 1;\n        c->linear        = linear;\n        c->factor        = factor;\n        c->filter_length = FFMAX((int)ceil(filter_size/factor), 1);\n        c->filter_bank   = av_mallocz(c->filter_length*(phase_count+1)*sizeof(FELEM));\n        if (!c->filter_bank)\n            goto error;\n        if (build_filter(c->filter_bank, factor, c->filter_length, phase_count, 1<<FILTER_SHIFT, WINDOW_TYPE))\n            goto error;\n        memcpy(&c->filter_bank[c->filter_length*phase_count+1], c->filter_bank, (c->filter_length-1)*sizeof(FELEM));\n        c->filter_bank[c->filter_length*phase_count]= c->filter_bank[c->filter_length - 1];\n    }\n\n    c->compensation_distance= 0;\n    if(!av_reduce(&c->src_incr, &c->dst_incr, out_rate, in_rate * (int64_t)phase_count, INT32_MAX/2))\n        goto error;\n    c->ideal_dst_incr= c->dst_incr;\n\n    c->index= -phase_count*((c->filter_length-1)/2);\n    c->frac= 0;\n\n    return c;\nerror:\n    av_free(c->filter_bank);\n    av_free(c);\n    return NULL;\n}", "target": 0}
{"idx": 5582, "func": "static int dca_exss_parse_asset_header(DCAContext *s)\n{\n    int header_pos = get_bits_count(&s->gb);\n    int header_size;\n    int channels;\n    int embedded_stereo = 0;\n    int embedded_6ch    = 0;\n    int drc_code_present;\n    int extensions_mask;\n    int i, j;\n\n    if (get_bits_left(&s->gb) < 16)\n        return -1;\n\n    /* We will parse just enough to get to the extensions bitmask with which\n     * we can set the profile value. */\n\n    header_size = get_bits(&s->gb, 9) + 1;\n    skip_bits(&s->gb, 3); // asset index\n\n    if (s->static_fields) {\n        if (get_bits1(&s->gb))\n            skip_bits(&s->gb, 4); // asset type descriptor\n        if (get_bits1(&s->gb))\n            skip_bits_long(&s->gb, 24); // language descriptor\n\n        if (get_bits1(&s->gb)) {\n            /* How can one fit 1024 bytes of text here if the maximum value\n             * for the asset header size field above was 512 bytes? */\n            int text_length = get_bits(&s->gb, 10) + 1;\n            if (get_bits_left(&s->gb) < text_length * 8)\n                return -1;\n            skip_bits_long(&s->gb, text_length * 8); // info text\n        }\n\n        skip_bits(&s->gb, 5); // bit resolution - 1\n        skip_bits(&s->gb, 4); // max sample rate code\n        channels = get_bits(&s->gb, 8) + 1;\n\n        if (get_bits1(&s->gb)) { // 1-to-1 channels to speakers\n            int spkr_remap_sets;\n            int spkr_mask_size = 16;\n            int num_spkrs[7];\n\n            if (channels > 2)\n                embedded_stereo = get_bits1(&s->gb);\n            if (channels > 6)\n                embedded_6ch = get_bits1(&s->gb);\n\n            if (get_bits1(&s->gb)) {\n                spkr_mask_size = (get_bits(&s->gb, 2) + 1) << 2;\n                skip_bits(&s->gb, spkr_mask_size); // spkr activity mask\n            }\n\n            spkr_remap_sets = get_bits(&s->gb, 3);\n\n            for (i = 0; i < spkr_remap_sets; i++) {\n                /* std layout mask for each remap set */\n                num_spkrs[i] = dca_exss_mask2count(get_bits(&s->gb, spkr_mask_size));\n            }\n\n            for (i = 0; i < spkr_remap_sets; i++) {\n                int num_dec_ch_remaps = get_bits(&s->gb, 5) + 1;\n                if (get_bits_left(&s->gb) < 0)\n                    return -1;\n\n                for (j = 0; j < num_spkrs[i]; j++) {\n                    int remap_dec_ch_mask = get_bits_long(&s->gb, num_dec_ch_remaps);\n                    int num_dec_ch = av_popcount(remap_dec_ch_mask);\n                    skip_bits_long(&s->gb, num_dec_ch * 5); // remap codes\n                }\n            }\n        } else {\n            skip_bits(&s->gb, 3); // representation type\n        }\n    }\n\n    drc_code_present = get_bits1(&s->gb);\n    if (drc_code_present)\n        get_bits(&s->gb, 8); // drc code\n\n    if (get_bits1(&s->gb))\n        skip_bits(&s->gb, 5); // dialog normalization code\n\n    if (drc_code_present && embedded_stereo)\n        get_bits(&s->gb, 8); // drc stereo code\n\n    if (s->mix_metadata && get_bits1(&s->gb)) {\n        skip_bits(&s->gb, 1); // external mix\n        skip_bits(&s->gb, 6); // post mix gain code\n\n        if (get_bits(&s->gb, 2) != 3) // mixer drc code\n            skip_bits(&s->gb, 3); // drc limit\n        else\n            skip_bits(&s->gb, 8); // custom drc code\n\n        if (get_bits1(&s->gb)) // channel specific scaling\n            for (i = 0; i < s->num_mix_configs; i++)\n                skip_bits_long(&s->gb, s->mix_config_num_ch[i] * 6); // scale codes\n        else\n            skip_bits_long(&s->gb, s->num_mix_configs * 6); // scale codes\n\n        for (i = 0; i < s->num_mix_configs; i++) {\n            if (get_bits_left(&s->gb) < 0)\n                return -1;\n            dca_exss_skip_mix_coeffs(&s->gb, channels, s->mix_config_num_ch[i]);\n            if (embedded_6ch)\n                dca_exss_skip_mix_coeffs(&s->gb, 6, s->mix_config_num_ch[i]);\n            if (embedded_stereo)\n                dca_exss_skip_mix_coeffs(&s->gb, 2, s->mix_config_num_ch[i]);\n        }\n    }\n\n    switch (get_bits(&s->gb, 2)) {\n    case 0:\n        extensions_mask = get_bits(&s->gb, 12);\n        break;\n    case 1:\n        extensions_mask = DCA_EXT_EXSS_XLL;\n        break;\n    case 2:\n        extensions_mask = DCA_EXT_EXSS_LBR;\n        break;\n    case 3:\n        extensions_mask = 0; /* aux coding */\n        break;\n    }\n\n    /* not parsed further, we were only interested in the extensions mask */\n\n    if (get_bits_left(&s->gb) < 0)\n        return -1;\n\n    if (get_bits_count(&s->gb) - header_pos > header_size * 8) {\n        av_log(s->avctx, AV_LOG_WARNING, \"Asset header size mismatch.\\n\");\n        return -1;\n    }\n    skip_bits_long(&s->gb, header_pos + header_size * 8 - get_bits_count(&s->gb));\n\n    if (extensions_mask & DCA_EXT_EXSS_XLL)\n        s->profile = FF_PROFILE_DTS_HD_MA;\n    else if (extensions_mask & (DCA_EXT_EXSS_XBR | DCA_EXT_EXSS_X96 |\n                                DCA_EXT_EXSS_XXCH))\n        s->profile = FF_PROFILE_DTS_HD_HRA;\n\n    if (!(extensions_mask & DCA_EXT_CORE))\n        av_log(s->avctx, AV_LOG_WARNING, \"DTS core detection mismatch.\\n\");\n    if ((extensions_mask & DCA_CORE_EXTS) != s->core_ext_mask)\n        av_log(s->avctx, AV_LOG_WARNING,\n               \"DTS extensions detection mismatch (%d, %d)\\n\",\n               extensions_mask & DCA_CORE_EXTS, s->core_ext_mask);\n\n    return 0;\n}", "target": 1}
{"idx": 5583, "func": "static int update_prob(VP56RangeCoder *c, int p)\n{\n    static const int inv_map_table[254] = {\n          7,  20,  33,  46,  59,  72,  85,  98, 111, 124, 137, 150, 163, 176,\n        189, 202, 215, 228, 241, 254,   1,   2,   3,   4,   5,   6,   8,   9,\n         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  21,  22,  23,  24,\n         25,  26,  27,  28,  29,  30,  31,  32,  34,  35,  36,  37,  38,  39,\n         40,  41,  42,  43,  44,  45,  47,  48,  49,  50,  51,  52,  53,  54,\n         55,  56,  57,  58,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,\n         70,  71,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,\n         86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  99, 100,\n        101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 112, 113, 114, 115,\n        116, 117, 118, 119, 120, 121, 122, 123, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 144, 145,\n        146, 147, 148, 149, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,\n        161, 162, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\n        177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191,\n        192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 203, 204, 205, 206,\n        207, 208, 209, 210, 211, 212, 213, 214, 216, 217, 218, 219, 220, 221,\n        222, 223, 224, 225, 226, 227, 229, 230, 231, 232, 233, 234, 235, 236,\n        237, 238, 239, 240, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251,\n        252, 253,\n    };\n    int d;\n\n    /* This code is trying to do a differential probability update. For a\n     * current probability A in the range [1, 255], the difference to a new\n     * probability of any value can be expressed differentially as 1-A,255-A\n     * where some part of this (absolute range) exists both in positive as\n     * well as the negative part, whereas another part only exists in one\n     * half. We're trying to code this shared part differentially, i.e.\n     * times two where the value of the lowest bit specifies the sign, and\n     * the single part is then coded on top of this. This absolute difference\n     * then again has a value of [0,254], but a bigger value in this range\n     * indicates that we're further away from the original value A, so we\n     * can code this as a VLC code, since higher values are increasingly\n     * unlikely. The first 20 values in inv_map_table[] allow 'cheap, rough'\n     * updates vs. the 'fine, exact' updates further down the range, which\n     * adds one extra dimension to this differential update model. */\n\n    if (!vp8_rac_get(c)) {\n        d = vp8_rac_get_uint(c, 4) + 0;\n    } else if (!vp8_rac_get(c)) {\n        d = vp8_rac_get_uint(c, 4) + 16;\n    } else if (!vp8_rac_get(c)) {\n        d = vp8_rac_get_uint(c, 5) + 32;\n    } else {\n        d = vp8_rac_get_uint(c, 7);\n        if (d >= 65)\n            d = (d << 1) - 65 + vp8_rac_get(c);\n        d += 64;\n    }\n\n    return p <= 128 ? 1 + inv_recenter_nonneg(inv_map_table[d], p - 1) :\n                    255 - inv_recenter_nonneg(inv_map_table[d], 255 - p);\n}", "target": 0}
{"idx": 5584, "func": "static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)\n{\n    int i, k, sb = 0;\n    int msb = sbr->k[0];\n    int usb = sbr->kx[1];\n    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;\n\n    sbr->num_patches = 0;\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n    } else\n        k = sbr->n_master;\n\n    do {\n        int odd = 0;\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n            sb = sbr->f_master[i];\n            odd = (sb + sbr->k[0]) & 1;\n        }\n\n        // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5.\n        // After this check the final number of patches can still be six which is\n        // illegal however the Coding Technologies decoder check stream has a final\n        // count of 6 patches\n        if (sbr->num_patches > 5) {\n            av_log(ac->avctx, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n            return -1;\n        }\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n            usb = sb;\n            msb = sb;\n            sbr->num_patches++;\n        } else\n            msb = sbr->kx[1];\n\n        if (sbr->f_master[k] - sb < 3)\n            k = sbr->n_master;\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n    if (sbr->num_patches > 1 && sbr->patch_num_subbands[sbr->num_patches-1] < 3)\n        sbr->num_patches--;\n\n    return 0;\n}", "target": 0}
{"idx": 5585, "func": "static int check_format_change_video(AVFilterContext *buffer_filter,\n                                     AVFilterBufferRef *picref)\n{\n    BufferSourceContext *c = buffer_filter->priv;\n    int ret;\n\n    if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pix_fmt) {\n        AVFilterContext *scale = buffer_filter->outputs[0]->dst;\n        AVFilterLink *link;\n        char scale_param[1024];\n\n        av_log(buffer_filter, AV_LOG_INFO,\n               \"Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n               c->w, c->h, av_pix_fmt_descriptors[c->pix_fmt].name,\n               picref->video->w, picref->video->h, av_pix_fmt_descriptors[picref->format].name);\n\n        if (!scale || strcmp(scale->filter->name, \"scale\")) {\n            AVFilter *f = avfilter_get_by_name(\"scale\");\n\n            av_log(buffer_filter, AV_LOG_INFO, \"Inserting scaler filter\\n\");\n            if ((ret = avfilter_open(&scale, f, \"Input equalizer\")) < 0)\n                return ret;\n\n            c->scale = scale;\n\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\", c->w, c->h, c->sws_param);\n            if ((ret = avfilter_init_filter(scale, scale_param, NULL)) < 0) {\n                return ret;\n            }\n\n            if ((ret = avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0)) < 0) {\n                return ret;\n            }\n            scale->outputs[0]->time_base = scale->inputs[0]->time_base;\n\n            scale->outputs[0]->format= c->pix_fmt;\n        } else if (!strcmp(scale->filter->name, \"scale\")) {\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\",\n                     scale->outputs[0]->w, scale->outputs[0]->h, c->sws_param);\n            scale->filter->init(scale, scale_param, NULL);\n        }\n\n        c->pix_fmt = scale->inputs[0]->format = picref->format;\n        c->w       = scale->inputs[0]->w      = picref->video->w;\n        c->h       = scale->inputs[0]->h      = picref->video->h;\n\n        link = scale->outputs[0];\n        if ((ret =  link->srcpad->config_props(link)) < 0)\n            return ret;\n    }\n    return 0;\n}", "target": 0}
{"idx": 5586, "func": "static int encode_bitstream(FlashSVContext *s, const AVFrame *p, uint8_t *buf,\n                            int buf_size, int block_width, int block_height,\n                            uint8_t *previous_frame, int *I_frame)\n{\n\n    PutBitContext pb;\n    int h_blocks, v_blocks, h_part, v_part, i, j;\n    int buf_pos, res;\n    int pred_blocks = 0;\n\n    init_put_bits(&pb, buf, buf_size * 8);\n\n    put_bits(&pb,  4, block_width / 16 - 1);\n    put_bits(&pb, 12, s->image_width);\n    put_bits(&pb,  4, block_height / 16 - 1);\n    put_bits(&pb, 12, s->image_height);\n    flush_put_bits(&pb);\n    buf_pos = 4;\n\n    h_blocks = s->image_width  / block_width;\n    h_part   = s->image_width  % block_width;\n    v_blocks = s->image_height / block_height;\n    v_part   = s->image_height % block_height;\n\n    /* loop over all block columns */\n    for (j = 0; j < v_blocks + (v_part ? 1 : 0); j++) {\n\n        int y_pos = j * block_height; // vertical position in frame\n        int cur_blk_height = (j < v_blocks) ? block_height : v_part;\n\n        /* loop over all block rows */\n        for (i = 0; i < h_blocks + (h_part ? 1 : 0); i++) {\n            int x_pos = i * block_width; // horizontal position in frame\n            int cur_blk_width = (i < h_blocks) ? block_width : h_part;\n            int ret = Z_OK;\n            uint8_t *ptr = buf + buf_pos;\n\n            /* copy the block to the temp buffer before compression\n             * (if it differs from the previous frame's block) */\n            res = copy_region_enc(p->data[0], s->tmpblock,\n                                  s->image_height - (y_pos + cur_blk_height + 1),\n                                  x_pos, cur_blk_height, cur_blk_width,\n                                  p->linesize[0], previous_frame);\n\n            if (res || *I_frame) {\n                unsigned long zsize = 3 * block_width * block_height;\n                ret = compress2(ptr + 2, &zsize, s->tmpblock,\n                                3 * cur_blk_width * cur_blk_height, 9);\n\n                //ret = deflateReset(&s->zstream);\n                if (ret != Z_OK)\n                    av_log(s->avctx, AV_LOG_ERROR,\n                           \"error while compressing block %dx%d\\n\", i, j);\n\n                bytestream_put_be16(&ptr, zsize);\n                buf_pos += zsize + 2;\n                av_dlog(s->avctx, \"buf_pos = %d\\n\", buf_pos);\n            } else {\n                pred_blocks++;\n                bytestream_put_be16(&ptr, 0);\n                buf_pos += 2;\n            }\n        }\n    }\n\n    if (pred_blocks)\n        *I_frame = 0;\n    else\n        *I_frame = 1;\n\n    return buf_pos;\n}", "target": 1}
{"idx": 5587, "func": "int test_sub(BIO *bp)\n{\n    BIGNUM *a, *b, *c;\n    int i;\n\n    a = BN_new();\n    b = BN_new();\n    c = BN_new();\n\n    for (i = 0; i < num0 + num1; i++) {\n        if (i < num1) {\n            BN_bntest_rand(a, 512, 0, 0);\n            BN_copy(b, a);\n            if (BN_set_bit(a, i) == 0)\n                return (0);\n            BN_add_word(b, i);\n        } else {\n            BN_bntest_rand(b, 400 + i - num1, 0, 0);\n            a->neg = rand_neg();\n            b->neg = rand_neg();\n        }\n        BN_sub(c, a, b);\n        if (bp != NULL) {\n            if (!results) {\n                BN_print(bp, a);\n                BIO_puts(bp, \" - \");\n                BN_print(bp, b);\n                BIO_puts(bp, \" - \");\n            }\n            BN_print(bp, c);\n            BIO_puts(bp, \"\\n\");\n        }\n        BN_add(c, c, b);\n        BN_sub(c, c, a);\n        if (!BN_is_zero(c)) {\n            fprintf(stderr, \"Subtract test failed!\\n\");\n            return 0;\n        }\n    }\n    BN_free(a);\n    BN_free(b);\n    BN_free(c);\n    return (1);\n}", "target": 1}
{"idx": 5588, "func": "void PEM_dek_info(char *buf, const char *type, int len, char *str)\n{\n    long i;\n    char *p = buf + strlen(buf);\n    int j = PEM_BUFSIZE - (size_t)(p - buf), n;\n\n    n = BIO_snprintf(p, j, \"DEK-Info: %s,\", type);\n    if (n > 0) {\n        j -= n;\n        p += n;\n        for (i = 0; i < len; i++) {\n            n = BIO_snprintf(p, j, \"%02X\", 0xff & str[i]);\n            if (n <= 0)\n                return;\n            j -= n;\n            p += n;\n        }\n        if (j > 1)\n            strcpy(p, \"\\n\");\n    }\n}", "target": 1}
{"idx": 5589, "func": "static void sbr_hf_inverse_filter(SBRDSPContext *dsp,\n                                  int (*alpha0)[2], int (*alpha1)[2],\n                                  const int X_low[32][40][2], int k0)\n{\n    int k;\n    int shift, round;\n\n    for (k = 0; k < k0; k++) {\n        SoftFloat phi[3][2][2];\n        SoftFloat a00, a01, a10, a11;\n        SoftFloat dk;\n\n        dsp->autocorrelate(X_low[k], phi);\n\n        dk = av_sub_sf(av_mul_sf(phi[2][1][0], phi[1][0][0]),\n             av_mul_sf(av_add_sf(av_mul_sf(phi[1][1][0], phi[1][1][0]),\n             av_mul_sf(phi[1][1][1], phi[1][1][1])), FLOAT_0999999));\n\n        if (!dk.mant) {\n            a10 = FLOAT_0;\n            a11 = FLOAT_0;\n        } else {\n            SoftFloat temp_real, temp_im;\n            temp_real = av_sub_sf(av_sub_sf(av_mul_sf(phi[0][0][0], phi[1][1][0]),\n                                            av_mul_sf(phi[0][0][1], phi[1][1][1])),\n                                  av_mul_sf(phi[0][1][0], phi[1][0][0]));\n            temp_im   = av_sub_sf(av_add_sf(av_mul_sf(phi[0][0][0], phi[1][1][1]),\n                                            av_mul_sf(phi[0][0][1], phi[1][1][0])),\n                                  av_mul_sf(phi[0][1][1], phi[1][0][0]));\n\n            a10 = av_div_sf(temp_real, dk);\n            a11 = av_div_sf(temp_im,   dk);\n        }\n\n        if (!phi[1][0][0].mant) {\n            a00 = FLOAT_0;\n            a01 = FLOAT_0;\n        } else {\n            SoftFloat temp_real, temp_im;\n            temp_real = av_add_sf(phi[0][0][0],\n                                  av_add_sf(av_mul_sf(a10, phi[1][1][0]),\n                                            av_mul_sf(a11, phi[1][1][1])));\n            temp_im   = av_add_sf(phi[0][0][1],\n                                  av_sub_sf(av_mul_sf(a11, phi[1][1][0]),\n                                            av_mul_sf(a10, phi[1][1][1])));\n\n            temp_real.mant = -temp_real.mant;\n            temp_im.mant   = -temp_im.mant;\n            a00 = av_div_sf(temp_real, phi[1][0][0]);\n            a01 = av_div_sf(temp_im,   phi[1][0][0]);\n        }\n\n        shift = a00.exp;\n        if (shift >= 3)\n            alpha0[k][0] = 0x7fffffff;\n        else if (shift <= -30)\n            alpha0[k][0] = 0;\n        else {\n            a00.mant *= 2;\n            shift = 2-shift;\n            if (shift == 0)\n                alpha0[k][0] = a00.mant;\n            else {\n                round = 1 << (shift-1);\n                alpha0[k][0] = (a00.mant + round) >> shift;\n            }\n        }\n\n        shift = a01.exp;\n        if (shift >= 3)\n            alpha0[k][1] = 0x7fffffff;\n        else if (shift <= -30)\n            alpha0[k][1] = 0;\n        else {\n            a01.mant *= 2;\n            shift = 2-shift;\n            if (shift == 0)\n                alpha0[k][1] = a01.mant;\n            else {\n                round = 1 << (shift-1);\n                alpha0[k][1] = (a01.mant + round) >> shift;\n            }\n        }\n        shift = a10.exp;\n        if (shift >= 3)\n            alpha1[k][0] = 0x7fffffff;\n        else if (shift <= -30)\n            alpha1[k][0] = 0;\n        else {\n            a10.mant *= 2;\n            shift = 2-shift;\n            if (shift == 0)\n                alpha1[k][0] = a10.mant;\n            else {\n                round = 1 << (shift-1);\n                alpha1[k][0] = (a10.mant + round) >> shift;\n            }\n        }\n\n        shift = a11.exp;\n        if (shift >= 3)\n            alpha1[k][1] = 0x7fffffff;\n        else if (shift <= -30)\n            alpha1[k][1] = 0;\n        else {\n            a11.mant *= 2;\n            shift = 2-shift;\n            if (shift == 0)\n                alpha1[k][1] = a11.mant;\n            else {\n                round = 1 << (shift-1);\n                alpha1[k][1] = (a11.mant + round) >> shift;\n            }\n        }\n\n        shift = (int)(((int64_t)(alpha1[k][0]>>1) * (alpha1[k][0]>>1) + \\\n                       (int64_t)(alpha1[k][1]>>1) * (alpha1[k][1]>>1) + \\\n                       0x40000000) >> 31);\n        if (shift >= 0x20000000){\n            alpha1[k][0] = 0;\n            alpha1[k][1] = 0;\n            alpha0[k][0] = 0;\n            alpha0[k][1] = 0;\n        }\n\n        shift = (int)(((int64_t)(alpha0[k][0]>>1) * (alpha0[k][0]>>1) + \\\n                       (int64_t)(alpha0[k][1]>>1) * (alpha0[k][1]>>1) + \\\n                       0x40000000) >> 31);\n        if (shift >= 0x20000000){\n            alpha1[k][0] = 0;\n            alpha1[k][1] = 0;\n            alpha0[k][0] = 0;\n            alpha0[k][1] = 0;\n        }\n    }\n}", "target": 0}
{"idx": 5590, "func": "UI *UI_new_method(const UI_METHOD *method)\n{\n    UI *ret = OPENSSL_zalloc(sizeof(*ret));\n\n    if (ret == NULL) {\n        UIerr(UI_F_UI_NEW_METHOD, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ret->lock = CRYPTO_THREAD_lock_new();\n    if (ret->lock == NULL) {\n        UIerr(UI_F_UI_NEW_METHOD, ERR_R_MALLOC_FAILURE);\n        OPENSSL_free(ret);\n        return NULL;\n    }\n\n    if (method == NULL)\n        ret->meth = UI_get_default_method();\n    else\n        ret->meth = method;\n\n    if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_UI, ret, &ret->ex_data)) {\n        OPENSSL_free(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 1}
{"idx": 5591, "func": "static int ebml_id_size(unsigned int id)\n{\n    return (av_log2(id + 1) - 1) / 7 + 1;\n}", "target": 1}
{"idx": 5592, "func": "static int avui_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n                             const AVFrame *pic, int *got_packet)\n{\n    uint8_t *dst, *src = pic->data[0];\n    int i, j, skip, ret, size, interlaced;\n\n    interlaced = avctx->field_order > AV_FIELD_PROGRESSIVE;\n\n    if (avctx->height == 486) {\n        skip = 10;\n    } else {\n        skip = 16;\n    }\n    size = 2 * avctx->width * (avctx->height + skip) + 8 * interlaced;\n    if ((ret = ff_alloc_packet2(avctx, pkt, size)) < 0)\n        return ret;\n    dst = pkt->data;\n    if (!(avctx->extradata = av_mallocz(24 + FF_INPUT_BUFFER_PADDING_SIZE)))\n        return AVERROR(ENOMEM);\n    avctx->extradata_size = 24;\n    memcpy(avctx->extradata, \"\\0\\0\\0\\x18\"\"APRGAPRG0001\", 16);\n    if (interlaced) {\n        avctx->extradata[19] = 2;\n    } else {\n        avctx->extradata[19] = 1;\n        dst += avctx->width * skip;\n    }\n\n    avctx->coded_frame->reference = 0;\n    avctx->coded_frame->key_frame = 1;\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\n    for (i = 0; i <= interlaced; i++) {\n        if (interlaced && avctx->height == 486) {\n            src = pic->data[0] + (1 - i) * pic->linesize[0];\n        } else {\n            src = pic->data[0] + i * pic->linesize[0];\n        }\n        dst += avctx->width * skip + 4 * i;\n        for (j = 0; j < avctx->height; j += interlaced + 1) {\n            memcpy(dst, src, avctx->width * 2);\n            src += (interlaced + 1) * pic->linesize[0];\n            dst += avctx->width * 2;\n        }\n    }\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n    *got_packet = 1;\n    return 0;\n}", "target": 1}
{"idx": 5593, "func": "void ff_formats_ref(AVFilterFormats *f, AVFilterFormats **ref)\n{\n    FORMATS_REF(f, ref);\n}", "target": 1}
{"idx": 5594, "func": "static void render_line(int x0, int y0, int x1, int y1, float *buf)\n{\n    int dy  = y1 - y0;\n    int adx = x1 - x0;\n    int ady = FFABS(dy);\n    int sy  = dy < 0 ? -1 : 1;\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n    if (ady*2 <= adx) { // optimized common case\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n    } else {\n        int base = dy / adx;\n        int x    = x0;\n        int y    = y0;\n        int err  = -adx;\n        ady -= FFABS(base) * adx;\n        while (++x < x1) {\n            y += base;\n            err += ady;\n            if (err >= 0) {\n                err -= adx;\n                y   += sy;\n            }\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n        }\n    }\n}", "target": 1}
{"idx": 5595, "func": "static int mxf_decrypt_triplet(AVFormatContext *s, AVPacket *pkt, KLVPacket *klv)\n{\n    static const uint8_t checkv[16] = {0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b};\n    MXFContext *mxf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int64_t end = avio_tell(pb) + klv->length;\n    uint64_t size;\n    uint64_t orig_size;\n    uint64_t plaintext_size;\n    uint8_t ivec[16];\n    uint8_t tmpbuf[16];\n    int index;\n\n    if (!mxf->aesc && s->key && s->keylen == 16) {\n        mxf->aesc = av_malloc(av_aes_size);\n        if (!mxf->aesc)\n            return -1;\n        av_aes_init(mxf->aesc, s->key, 128, 1);\n    }\n    // crypto context\n    avio_skip(pb, klv_decode_ber_length(pb));\n    // plaintext offset\n    klv_decode_ber_length(pb);\n    plaintext_size = avio_rb64(pb);\n    // source klv key\n    klv_decode_ber_length(pb);\n    avio_read(pb, klv->key, 16);\n    if (!IS_KLV_KEY(klv, mxf_essence_element_key))\n        return -1;\n    index = mxf_get_stream_index(s, klv);\n    if (index < 0)\n        return -1;\n    // source size\n    klv_decode_ber_length(pb);\n    orig_size = avio_rb64(pb);\n    if (orig_size < plaintext_size)\n        return -1;\n    // enc. code\n    size = klv_decode_ber_length(pb);\n    if (size < 32 || size - 32 < orig_size)\n        return -1;\n    avio_read(pb, ivec, 16);\n    avio_read(pb, tmpbuf, 16);\n    if (mxf->aesc)\n        av_aes_crypt(mxf->aesc, tmpbuf, tmpbuf, 1, ivec, 1);\n    if (memcmp(tmpbuf, checkv, 16))\n        av_log(s, AV_LOG_ERROR, \"probably incorrect decryption key\\n\");\n    size -= 32;\n    av_get_packet(pb, pkt, size);\n    size -= plaintext_size;\n    if (mxf->aesc)\n        av_aes_crypt(mxf->aesc, &pkt->data[plaintext_size],\n                     &pkt->data[plaintext_size], size >> 4, ivec, 1);\n    pkt->size = orig_size;\n    pkt->stream_index = index;\n    avio_skip(pb, end - avio_tell(pb));\n    return 0;\n}", "target": 1}
{"idx": 5596, "func": "int EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n)\n{\n    int i, ret = 0, a, b, c, d;\n    unsigned long l;\n\n    /* trim white space from the start of the line. */\n    while ((conv_ascii2bin(*f) == B64_WS) && (n > 0)) {\n        f++;\n        n--;\n    }\n\n    /*\n     * strip off stuff at the end of the line ascii2bin values B64_WS,\n     * B64_EOLN, B64_EOLN and B64_EOF\n     */\n    while ((n > 3) && (B64_NOT_BASE64(conv_ascii2bin(f[n - 1]))))\n        n--;\n\n    if (n % 4 != 0)\n        return -1;\n\n    for (i = 0; i < n; i += 4) {\n        a = conv_ascii2bin(*(f++));\n        b = conv_ascii2bin(*(f++));\n        c = conv_ascii2bin(*(f++));\n        d = conv_ascii2bin(*(f++));\n        if ((a & 0x80) || (b & 0x80) || (c & 0x80) || (d & 0x80))\n            return -1;\n        l = ((((unsigned long)a) << 18L) |\n             (((unsigned long)b) << 12L) |\n             (((unsigned long)c) << 6L) | (((unsigned long)d)));\n        *(t++) = (unsigned char)(l >> 16L) & 0xff;\n        *(t++) = (unsigned char)(l >> 8L) & 0xff;\n        *(t++) = (unsigned char)(l) & 0xff;\n        ret += 3;\n    }\n    return ret;\n}", "target": 1}
{"idx": 5597, "func": "static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx)\n{\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n    AVCodecContext *dec_ctx;\n    AVCodec *dec;\n    char val_str[128];\n    const char *s;\n    AVRational display_aspect_ratio;\n    struct print_buf pbuf = {.s = NULL};\n\n    print_section_header(\"stream\");\n\n    print_int(\"index\", stream->index);\n\n    if ((dec_ctx = stream->codec)) {\n        if ((dec = dec_ctx->codec)) {\n            print_str(\"codec_name\",      dec->name);\n            print_str(\"codec_long_name\", dec->long_name);\n        } else {\n            print_str_opt(\"codec_name\",      \"unknown\");\n            print_str_opt(\"codec_long_name\", \"unknown\");\n        }\n\n        s = av_get_media_type_string(dec_ctx->codec_type);\n        if (s) print_str    (\"codec_type\", s);\n        else   print_str_opt(\"codec_type\", \"unknown\");\n        print_fmt(\"codec_time_base\", \"%d/%d\", dec_ctx->time_base.num, dec_ctx->time_base.den);\n\n        /* print AVI/FourCC tag */\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n        print_str(\"codec_tag_string\",    val_str);\n        print_fmt(\"codec_tag\", \"0x%04x\", dec_ctx->codec_tag);\n\n        switch (dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_VIDEO:\n            print_int(\"width\",        dec_ctx->width);\n            print_int(\"height\",       dec_ctx->height);\n            print_int(\"has_b_frames\", dec_ctx->has_b_frames);\n            if (dec_ctx->sample_aspect_ratio.num) {\n                print_fmt(\"sample_aspect_ratio\", \"%d:%d\",\n                          dec_ctx->sample_aspect_ratio.num,\n                          dec_ctx->sample_aspect_ratio.den);\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n                          dec_ctx->width  * dec_ctx->sample_aspect_ratio.num,\n                          dec_ctx->height * dec_ctx->sample_aspect_ratio.den,\n                          1024*1024);\n                print_fmt(\"display_aspect_ratio\", \"%d:%d\",\n                          display_aspect_ratio.num,\n                          display_aspect_ratio.den);\n            } else {\n                print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n                print_str_opt(\"display_aspect_ratio\", \"N/A\");\n            }\n            s = av_get_pix_fmt_name(dec_ctx->pix_fmt);\n            if (s) print_str    (\"pix_fmt\", s);\n            else   print_str_opt(\"pix_fmt\", \"unknown\");\n            print_int(\"level\",   dec_ctx->level);\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n            s = av_get_sample_fmt_name(dec_ctx->sample_fmt);\n            if (s) print_str    (\"sample_fmt\", s);\n            else   print_str_opt(\"sample_fmt\", \"unknown\");\n            print_val(\"sample_rate\",     dec_ctx->sample_rate, unit_hertz_str);\n            print_int(\"channels\",        dec_ctx->channels);\n            print_int(\"bits_per_sample\", av_get_bits_per_sample(dec_ctx->codec_id));\n            break;\n        }\n    } else {\n        print_str_opt(\"codec_type\", \"unknown\");\n    }\n    if (dec_ctx->codec && dec_ctx->codec->priv_class) {\n        const AVOption *opt = NULL;\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n            uint8_t *str;\n            if (opt->flags) continue;\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n                print_str(opt->name, str);\n                av_free(str);\n            }\n        }\n    }\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n    else                                          print_str_opt(\"id\", \"N/A\");\n    print_fmt(\"r_frame_rate\",   \"%d/%d\", stream->r_frame_rate.num,   stream->r_frame_rate.den);\n    print_fmt(\"avg_frame_rate\", \"%d/%d\", stream->avg_frame_rate.num, stream->avg_frame_rate.den);\n    print_fmt(\"time_base\",      \"%d/%d\", stream->time_base.num,      stream->time_base.den);\n    print_time(\"start_time\",    stream->start_time, &stream->time_base);\n    print_time(\"duration\",      stream->duration,   &stream->time_base);\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n    show_tags(stream->metadata);\n\n    print_section_footer(\"stream\");\n    av_free(pbuf.s);\n    fflush(stdout);\n}", "target": 0}
{"idx": 5598, "func": "static av_always_inline void\nyuv2yuvX16_c_template(const int16_t *lumFilter, const int32_t **lumSrc,\n                      int lumFilterSize, const int16_t *chrFilter,\n                      const int32_t **chrUSrc, const int32_t **chrVSrc,\n                      int chrFilterSize, const int32_t **alpSrc,\n                      uint16_t *dest[4], int dstW, int chrDstW,\n                      int big_endian, int output_bits)\n{\n    //FIXME Optimize (just quickly written not optimized..)\n    int i;\n    int dword= output_bits == 16;\n    uint16_t *yDest = dest[0], *uDest = dest[1], *vDest = dest[2],\n             *aDest = CONFIG_SWSCALE_ALPHA ? dest[3] : NULL;\n    int shift = 11 + 4*dword + 16 - output_bits - 1;\n\n#define output_pixel(pos, val) \\\n    if (big_endian) { \\\n        if (output_bits == 16) { \\\n            AV_WB16(pos, av_clip_uint16(val >> shift)); \\\n        } else { \\\n            AV_WB16(pos, av_clip_uintp2(val >> shift, output_bits)); \\\n        } \\\n    } else { \\\n        if (output_bits == 16) { \\\n            AV_WL16(pos, av_clip_uint16(val >> shift)); \\\n        } else { \\\n            AV_WL16(pos, av_clip_uintp2(val >> shift, output_bits)); \\\n        } \\\n    }\n    for (i = 0; i < dstW; i++) {\n        int val = 1 << (26-output_bits + 4*dword - 1);\n        int j;\n\n        for (j = 0; j < lumFilterSize; j++)\n            val += ((dword ? lumSrc[j][i] : ((int16_t**)lumSrc)[j][i]) * lumFilter[j])>>1;\n\n        output_pixel(&yDest[i], val);\n    }\n\n    if (uDest) {\n        for (i = 0; i < chrDstW; i++) {\n            int u = 1 << (26-output_bits + 4*dword - 1);\n            int v = 1 << (26-output_bits + 4*dword - 1);\n            int j;\n\n            for (j = 0; j < chrFilterSize; j++) {\n                u += ((dword ? chrUSrc[j][i] : ((int16_t**)chrUSrc)[j][i]) * chrFilter[j]) >> 1;\n                v += ((dword ? chrVSrc[j][i] : ((int16_t**)chrVSrc)[j][i]) * chrFilter[j]) >> 1;\n            }\n\n            output_pixel(&uDest[i], u);\n            output_pixel(&vDest[i], v);\n        }\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n        for (i = 0; i < dstW; i++) {\n            int val = 1 << (26-output_bits + 4*dword - 1);\n            int j;\n\n            for (j = 0; j < lumFilterSize; j++)\n                val += ((dword ? alpSrc[j][i] : ((int16_t**)alpSrc)[j][i]) * lumFilter[j]) >> 1;\n\n            output_pixel(&aDest[i], val);\n        }\n    }\n#undef output_pixel\n}", "target": 0}
{"idx": 5599, "func": "static int parse_audio(DBEContext *s, int start, int end, int seg_id)\n{\n    int ch, ret, key;\n\n    if ((key = parse_key(s)) < 0)\n        return key;\n\n    for (ch = start; ch < end; ch++) {\n        if (!s->ch_size[ch]) {\n            s->channels[seg_id][ch].nb_groups = 0;\n            continue;\n        }\n        if ((ret = convert_input(s, s->ch_size[ch], key)) < 0)\n            return ret;\n        if ((ret = parse_channel(s, ch, seg_id)) < 0) {\n            if (s->avctx->err_recognition & AV_EF_EXPLODE)\n                return ret;\n            s->channels[seg_id][ch].nb_groups = 0;\n        }\n        if ((ret = skip_input(s, s->ch_size[ch])) < 0)\n            return ret;\n    }\n\n    return skip_input(s, 1);\n}", "target": 0}
{"idx": 5600, "func": "void\nngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n\n    /* the calculation is valid for positive time_t only */\n\n    if (t < 0) {\n        t = 0;\n    }\n\n    days = t / 86400;\n    sec = t % 86400;\n\n    /*\n     * no more than 4 year digits supported,\n     * truncate to December 31, 9999, 23:59:59\n     */\n\n    if (days > 2932896) {\n        days = 2932896;\n        sec = 86399;\n    }\n\n    /* January 1, 1970 was Thursday */\n\n    wday = (4 + days) % 7;\n\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n\n    /*\n     * the algorithm based on Gauss' formula,\n     * see src/core/ngx_parse_time.c\n     */\n\n    /* days since March 1, 1 BC */\n    days = days - (31 + 28) + 719527;\n\n    /*\n     * The \"days\" should be adjusted to 1 only, however, some March 1st's go\n     * to previous year, so we adjust them to 2.  This causes also shift of the\n     * last February days to next year, but we catch the case when \"yday\"\n     * becomes negative.\n     */\n\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n\n    /*\n     * The empirical formula that maps \"yday\" to month.\n     * There are at least 10 variants, some of them are:\n     *     mon = (yday + 31) * 15 / 459\n     *     mon = (yday + 31) * 17 / 520\n     *     mon = (yday + 31) * 20 / 612\n     */\n\n    mon = (yday + 31) * 10 / 306;\n\n    /* the Gauss' formula that evaluates days before the month */\n\n    mday = yday - (367 * mon / 12 - 30) + 1;\n\n    if (yday >= 306) {\n\n        year++;\n        mon -= 10;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday -= 306;\n         */\n\n    } else {\n\n        mon += 2;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday += 31 + 28 + leap;\n         */\n    }\n\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 0}
{"idx": 5601, "func": "ASN1_INTEGER *BN_to_ASN1_INTEGER(BIGNUM *bn, ASN1_INTEGER *ai)\n\t{\n\tASN1_INTEGER *ret;\n\tint len,j;\n\n\tif (ai == NULL)\n\t\tret=M_ASN1_INTEGER_new();\n\telse\n\t\tret=ai;\n\tif (ret == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_BN_TO_ASN1_INTEGER,ERR_R_NESTED_ASN1_ERROR);\n\t\tgoto err;\n\t\t}\n\tif(bn->neg) ret->type = V_ASN1_NEG_INTEGER;\n\telse ret->type=V_ASN1_INTEGER;\n\tj=BN_num_bits(bn);\n\tlen=((j == 0)?0:((j/8)+1));\n\tret->data=(unsigned char *)OPENSSL_malloc(len+4);\n\tret->length=BN_bn2bin(bn,ret->data);\n\t/* Correct zero case */\n\tif(!ret->length)\n\t\t{\n\t\tret->data[0] = 0;\n\t\tret->length = 1;\n\t\t}\n\treturn(ret);\nerr:\n\tif (ret != ai) M_ASN1_INTEGER_free(ret);\n\treturn(NULL);\n\t}", "target": 0}
{"idx": 5602, "func": "static int frame_list_add_frame(FrameList *frame_list, int nb_samples, int64_t pts)\n{\n    FrameInfo *info = av_malloc(sizeof(*info));\n    if (!info)\n        return AVERROR(ENOMEM);\n    info->nb_samples = nb_samples;\n    info->pts        = pts;\n    info->next       = NULL;\n\n    if (!frame_list->list) {\n        frame_list->list = info;\n        frame_list->end  = info;\n    } else {\n        av_assert0(frame_list->end);\n        frame_list->end->next = info;\n        frame_list->end       = info;\n    }\n    frame_list->nb_frames++;\n    frame_list->nb_samples += nb_samples;\n\n    return 0;\n}", "target": 1}
{"idx": 5603, "func": "void ssl3_finish_mac(SSL *s, const unsigned char *buf, int len)\n\t{\n\tif (s->s3->handshake_buffer && !(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) \n\t\t{\n\t\tBIO_write (s->s3->handshake_buffer,(void *)buf,len);\n\t\t} \n\telse \n\t\t{\n\t\tint i;\n\t\tfor (i=0;i< SSL_MAX_DIGEST;i++) \n\t\t\t{\n\t\t\tif (s->s3->handshake_dgst[i]!= NULL)\n\t\t\tEVP_DigestUpdate(s->s3->handshake_dgst[i],buf,len);\n\t\t\t}\n\t\t}\t\n\t}", "target": 1}
{"idx": 5604, "func": "static void vp3_v_loop_filter_c(uint8_t *first_pixel, int stride,\n                                int *bounding_values)\n{\n    unsigned char *end;\n    int filter_value;\n    const int nstride= -stride;\n\n    for (end= first_pixel + 8; first_pixel < end; first_pixel++) {\n        filter_value =\n            (first_pixel[2 * nstride] - first_pixel[ stride])\n         +3*(first_pixel[0          ] - first_pixel[nstride]);\n        filter_value = bounding_values[(filter_value + 4) >> 3];\n        first_pixel[nstride] = av_clip_uint8(first_pixel[nstride] + filter_value);\n        first_pixel[0] = av_clip_uint8(first_pixel[0] - filter_value);\n    }\n}", "target": 0}
{"idx": 5605, "func": "static int simple_lbg(elbg_data *elbg,\n                      int dim,\n                      int *centroid[3],\n                      int newutility[3],\n                      int *points,\n                      cell *cells)\n{\n    int i, idx;\n    int numpoints[2] = {0,0};\n    int *newcentroid[2] = {\n        elbg->scratchbuf + 3*dim,\n        elbg->scratchbuf + 4*dim\n    };\n    cell *tempcell;\n\n    memset(newcentroid[0], 0, 2 * dim * sizeof(*newcentroid[0]));\n\n    newutility[0] =\n    newutility[1] = 0;\n\n    for (tempcell = cells; tempcell; tempcell=tempcell->next) {\n        idx = distance_limited(centroid[0], points + tempcell->index*dim, dim, INT_MAX)>=\n              distance_limited(centroid[1], points + tempcell->index*dim, dim, INT_MAX);\n        numpoints[idx]++;\n        for (i=0; i<dim; i++)\n            newcentroid[idx][i] += points[tempcell->index*dim + i];\n    }\n\n    vect_division(centroid[0], newcentroid[0], numpoints[0], dim);\n    vect_division(centroid[1], newcentroid[1], numpoints[1], dim);\n\n    for (tempcell = cells; tempcell; tempcell=tempcell->next) {\n        int dist[2] = {distance_limited(centroid[0], points + tempcell->index*dim, dim, INT_MAX),\n                       distance_limited(centroid[1], points + tempcell->index*dim, dim, INT_MAX)};\n        int idx = dist[0] > dist[1];\n        newutility[idx] += dist[idx];\n    }\n\n    return newutility[0] + newutility[1];\n}", "target": 1}
{"idx": 5606, "func": "char *BN_bn2dec(const BIGNUM *a)\n{\n    int i = 0, num, ok = 0;\n    char *buf = NULL;\n    char *p;\n    BIGNUM *t = NULL;\n    BN_ULONG *bn_data = NULL, *lp;\n    int bn_data_num;\n\n    /*-\n     * get an upper bound for the length of the decimal integer\n     * num <= (BN_num_bits(a) + 1) * log(2)\n     *     <= 3 * BN_num_bits(a) * 0.101 + log(2) + 1     (rounding error)\n     *     <= 3 * BN_num_bits(a) / 10 + 3 * BN_num_bits / 1000 + 1 + 1\n     */\n    i = BN_num_bits(a) * 3;\n    num = (i / 10 + i / 1000 + 1) + 1;\n    bn_data_num = num / BN_DEC_NUM + 1;\n    bn_data = OPENSSL_malloc(bn_data_num * sizeof(BN_ULONG));\n    buf = OPENSSL_malloc(num + 3);\n    if ((buf == NULL) || (bn_data == NULL)) {\n        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((t = BN_dup(a)) == NULL)\n        goto err;\n\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\n    p = buf;\n    lp = bn_data;\n    if (BN_is_zero(t)) {\n        *(p++) = '0';\n        *(p++) = '\\0';\n    } else {\n        if (BN_is_negative(t))\n            *p++ = '-';\n\n        while (!BN_is_zero(t)) {\n            if (lp - bn_data >= bn_data_num)\n                goto err;\n            *lp = BN_div_word(t, BN_DEC_CONV);\n            if (*lp == (BN_ULONG)-1)\n                goto err;\n            lp++;\n        }\n        lp--;\n        /*\n         * We now have a series of blocks, BN_DEC_NUM chars in length, where\n         * the last one needs truncation. The blocks need to be reversed in\n         * order.\n         */\n        BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT1, *lp);\n        while (*p)\n            p++;\n        while (lp != bn_data) {\n            lp--;\n            BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT2, *lp);\n            while (*p)\n                p++;\n        }\n    }\n    ok = 1;\n err:\n    OPENSSL_free(bn_data);\n    BN_free(t);\n    if (ok)\n        return buf;\n    OPENSSL_free(buf);\n    return NULL;\n}", "target": 1}
{"idx": 5607, "func": "static av_always_inline int vc1_filter_line(uint8_t* src, int stride, int pq){\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n    int a0 = (2*(src[-2*stride] - src[ 1*stride]) - 5*(src[-1*stride] - src[ 0*stride]) + 4) >> 3;\n    int a0_sign = a0 >> 31;        /* Store sign */\n    a0 = (a0 ^ a0_sign) - a0_sign; /* a0 = FFABS(a0); */\n    if(a0 < pq){\n        int a1 = FFABS((2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3);\n        int a2 = FFABS((2*(src[ 0*stride] - src[ 3*stride]) - 5*(src[ 1*stride] - src[ 2*stride]) + 4) >> 3);\n        if(a1 < a0 || a2 < a0){\n            int clip = src[-1*stride] - src[ 0*stride];\n            int clip_sign = clip >> 31;\n            clip = ((clip ^ clip_sign) - clip_sign)>>1;\n            if(clip){\n                int a3 = FFMIN(a1, a2);\n                int d = 5 * (a3 - a0);\n                int d_sign = (d >> 31);\n                d = ((d ^ d_sign) - d_sign) >> 3;\n                d_sign ^= a0_sign;\n\n                if( d_sign ^ clip_sign )\n                    d = 0;\n                else{\n                    d = FFMIN(d, clip);\n                    d = (d ^ d_sign) - d_sign;          /* Restore sign */\n                    src[-1*stride] = cm[src[-1*stride] - d];\n                    src[ 0*stride] = cm[src[ 0*stride] + d];\n                }\n                return 1;\n            }\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": 5608, "func": "static int by_file_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl,\n\t     char **ret)\n\t{\n\tint ok=0;\n\tchar *file;\n\n\tswitch (cmd)\n\t\t{\n\tcase X509_L_FILE_LOAD:\n\t\tif (argl == X509_FILETYPE_DEFAULT)\n\t\t\t{\n\t\t\tok=X509_load_cert_crl_file(ctx,X509_get_default_cert_file(),\n\t\t\t\tX509_FILETYPE_PEM);\n\t\t\tif (!ok)\n\t\t\t\t{\n\t\t\t\tX509err(X509_F_BY_FILE_CTRL,X509_R_LOADING_DEFAULTS);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tfile=(char *)Getenv(X509_get_default_cert_file_env());\n\t\t\t\tok=X509_load_cert_crl_file(ctx,file,\n\t\t\t\t\tX509_FILETYPE_PEM);\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif(argl == X509_FILETYPE_PEM)\n\t\t\t\tok=X509_load_cert_crl_file(ctx,argp,\n\t\t\t\t\tX509_FILETYPE_PEM);\n\t\t\telse ok=X509_load_cert_file(ctx,argp,(int)argl);\n\t\t\t}\n\t\tbreak;\n\t\t}\n\treturn(ok);\n\t}", "target": 0}
{"idx": 5609, "func": "static inline int find_min_book(float maxval, int sf)\n{\n    float Q = ff_aac_pow2sf_tab[POW_SF2_ZERO - sf + SCALE_ONE_POS - SCALE_DIV_512];\n    float Q34 = sqrtf(Q * sqrtf(Q));\n    int qmaxval, cb;\n    qmaxval = maxval * Q34 + C_QUANT;\n    if (qmaxval >= (FF_ARRAY_ELEMS(aac_maxval_cb)))\n        cb = 11;\n    else\n        cb = aac_maxval_cb[qmaxval];\n    return cb;\n}", "target": 1}
{"idx": 5610, "func": "static int zero12v_decode_frame(AVCodecContext *avctx, void *data,\n                                int *got_frame, AVPacket *avpkt)\n{\n    int line = 0, ret;\n    const int width = avctx->width;\n    AVFrame *pic = data;\n    uint16_t *y, *u, *v;\n    const uint8_t *line_end, *src = avpkt->data;\n    int stride = avctx->width * 8 / 3;\n\n    if (width == 1) {\n        av_log(avctx, AV_LOG_ERROR, \"Width 1 not supported.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (   avctx->codec_tag == MKTAG('0', '1', '2', 'v')\n        && avpkt->size % avctx->height == 0\n        && avpkt->size / avctx->height * 3 >= width * 8)\n        stride = avpkt->size / avctx->height;\n\n    if (avpkt->size < avctx->height * stride) {\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small: %d instead of %d\\n\",\n               avpkt->size, avctx->height * stride);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    pic->pict_type = AV_PICTURE_TYPE_I;\n    pic->key_frame = 1;\n\n    y = (uint16_t *)pic->data[0];\n    u = (uint16_t *)pic->data[1];\n    v = (uint16_t *)pic->data[2];\n    line_end = avpkt->data + stride;\n\n    while (line++ < avctx->height) {\n        while (1) {\n            uint32_t t = AV_RL32(src);\n            src += 4;\n            *u++ = t <<  6 & 0xFFC0;\n            *y++ = t >>  4 & 0xFFC0;\n            *v++ = t >> 14 & 0xFFC0;\n\n            if (src >= line_end - 1) {\n                *y = 0x80;\n                src++;\n                line_end += stride;\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n                break;\n            }\n\n            t = AV_RL32(src);\n            src += 4;\n            *y++ = t <<  6 & 0xFFC0;\n            *u++ = t >>  4 & 0xFFC0;\n            *y++ = t >> 14 & 0xFFC0;\n            if (src >= line_end - 2) {\n                if (!(width & 1)) {\n                    *y = 0x80;\n                    src += 2;\n                }\n                line_end += stride;\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n                break;\n            }\n\n            t = AV_RL32(src);\n            src += 4;\n            *v++ = t <<  6 & 0xFFC0;\n            *y++ = t >>  4 & 0xFFC0;\n            *u++ = t >> 14 & 0xFFC0;\n\n            if (src >= line_end - 1) {\n                *y = 0x80;\n                src++;\n                line_end += stride;\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n                break;\n            }\n\n            t = AV_RL32(src);\n            src += 4;\n            *y++ = t <<  6 & 0xFFC0;\n            *v++ = t >>  4 & 0xFFC0;\n            *y++ = t >> 14 & 0xFFC0;\n\n            if (src >= line_end - 2) {\n                if (width & 1) {\n                    *y = 0x80;\n                    src += 2;\n                }\n                line_end += stride;\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n                break;\n            }\n        }\n    }\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}", "target": 1}
{"idx": 5611, "func": "static inline int get_ue_golomb(GetBitContext *gb){\n    unsigned int buf;\n    int log;\n\n    OPEN_READER(re, gb);\n    UPDATE_CACHE(re, gb);\n    buf=GET_CACHE(re, gb);\n\n    if(buf >= (1<<27)){\n        buf >>= 32 - 9;\n        LAST_SKIP_BITS(re, gb, ff_golomb_vlc_len[buf]);\n        CLOSE_READER(re, gb);\n\n        return ff_ue_golomb_vlc_code[buf];\n    }else{\n        log= 2*av_log2(buf) - 31;\n        buf>>= log;\n        buf--;\n        LAST_SKIP_BITS(re, gb, 32 - log);\n        CLOSE_READER(re, gb);\n\n        return buf;\n    }\n}", "target": 1}
{"idx": 5612, "func": "int verify_main(int argc, char **argv)\n{\n    ENGINE *e = NULL;\n    STACK_OF(X509) *untrusted = NULL, *trusted = NULL;\n    STACK_OF(X509_CRL) *crls = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = NULL;\n    const char *prog, *CApath = NULL, *CAfile = NULL;\n    int noCApath = 0, noCAfile = 0;\n    int vpmtouched = 0, crl_download = 0, show_chain = 0, i = 0, ret = 1;\n    OPTION_CHOICE o;\n\n    if ((vpm = X509_VERIFY_PARAM_new()) == NULL)\n        goto end;\n\n    prog = opt_init(argc, argv, verify_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(verify_options);\n            BIO_printf(bio_err, \"Recognized usages:\\n\");\n            for (i = 0; i < X509_PURPOSE_get_count(); i++) {\n                X509_PURPOSE *ptmp;\n                ptmp = X509_PURPOSE_get0(i);\n                BIO_printf(bio_err, \"\\t%-10s\\t%s\\n\",\n                        X509_PURPOSE_get0_sname(ptmp),\n                        X509_PURPOSE_get0_name(ptmp));\n            }\n\n            BIO_printf(bio_err, \"Recognized verify names:\\n\");\n            for (i = 0; i < X509_VERIFY_PARAM_get_count(); i++) {\n                const X509_VERIFY_PARAM *vptmp;\n                vptmp = X509_VERIFY_PARAM_get0(i);\n                BIO_printf(bio_err, \"\\t%-10s\\n\",\n                        X509_VERIFY_PARAM_get0_name(vptmp));\n            }\n            ret = 0;\n            goto end;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_UNTRUSTED:\n            /* Zero or more times */\n            if (!load_certs(opt_arg(), &untrusted, FORMAT_PEM, NULL,\n                            \"untrusted certificates\"))\n                goto end;\n            break;\n        case OPT_TRUSTED:\n            /* Zero or more times */\n            noCAfile = 1;\n            noCApath = 1;\n            if (!load_certs(opt_arg(), &trusted, FORMAT_PEM, NULL,\n                            \"trusted certificates\"))\n                goto end;\n            break;\n        case OPT_CRLFILE:\n            /* Zero or more times */\n            if (!load_crls(opt_arg(), &crls, FORMAT_PEM, NULL,\n                           \"other CRLs\"))\n                goto end;\n            break;\n        case OPT_CRL_DOWNLOAD:\n            crl_download = 1;\n            break;\n        case OPT_ENGINE:\n            if ((e = setup_engine(opt_arg(), 0)) == NULL) {\n                /* Failure message already displayed */\n                goto end;\n            }\n            break;\n        case OPT_SHOW_CHAIN:\n            show_chain = 1;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto end;\n            break;\n        case OPT_VERBOSE:\n            v_verbose = 1;\n            break;\n        }\n    }\n    argc = opt_num_rest();\n    argv = opt_rest();\n    if (trusted != NULL && (CAfile || CApath)) {\n        BIO_printf(bio_err,\n                   \"%s: Cannot use -trusted with -CAfile or -CApath\\n\",\n                   prog);\n        goto end;\n    }\n\n    if ((store = setup_verify(CAfile, CApath, noCAfile, noCApath)) == NULL)\n        goto end;\n    X509_STORE_set_verify_cb(store, cb);\n\n    if (vpmtouched)\n        X509_STORE_set1_param(store, vpm);\n\n    ERR_clear_error();\n\n    if (crl_download)\n        store_setup_crl_download(store);\n\n    ret = 0;\n    if (argc < 1) {\n        if (check(store, NULL, untrusted, trusted, crls, show_chain) != 1)\n            ret = -1;\n    } else {\n        for (i = 0; i < argc; i++)\n            if (check(store, argv[i], untrusted, trusted, crls,\n                      show_chain) != 1)\n                ret = -1;\n    }\n\n end:\n    X509_VERIFY_PARAM_free(vpm);\n    X509_STORE_free(store);\n    sk_X509_pop_free(untrusted, X509_free);\n    sk_X509_pop_free(trusted, X509_free);\n    sk_X509_CRL_pop_free(crls, X509_CRL_free);\n    release_engine(e);\n    return (ret < 0 ? 2 : ret);\n}", "target": 0}
{"idx": 5613, "func": "static void mov_create_chapter_track(AVFormatContext *s, int tracknum)\n{\n    MOVMuxContext *mov = s->priv_data;\n    MOVTrack *track = &mov->tracks[tracknum];\n    AVPacket pkt = { .stream_index = tracknum, .flags = AV_PKT_FLAG_KEY };\n    int i, len;\n\n    track->mode = mov->mode;\n    track->tag = MKTAG('t','e','x','t');\n    track->timescale = MOV_TIMESCALE;\n    track->enc = avcodec_alloc_context3(NULL);\n    track->enc->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n    for (i = 0; i < s->nb_chapters; i++) {\n        AVChapter *c = s->chapters[i];\n        AVDictionaryEntry *t;\n\n        int64_t end = av_rescale_q(c->end, c->time_base, (AVRational){1,MOV_TIMESCALE});\n        pkt.pts = pkt.dts = av_rescale_q(c->start, c->time_base, (AVRational){1,MOV_TIMESCALE});\n        pkt.duration = end - pkt.dts;\n\n        if ((t = av_dict_get(c->metadata, \"title\", NULL, 0))) {\n            len = strlen(t->value);\n            pkt.size = len+2;\n            pkt.data = av_malloc(pkt.size);\n            AV_WB16(pkt.data, len);\n            memcpy(pkt.data+2, t->value, len);\n            ff_mov_write_packet(s, &pkt);\n            av_freep(&pkt.data);\n        }\n    }\n}", "target": 1}
{"idx": 5614, "func": "void avfilter_start_frame(AVFilterLink *link, AVFilterBufferRef *picref)\n{\n    void (*start_frame)(AVFilterLink *, AVFilterBufferRef *);\n    AVFilterPad *dst = &link_dpad(link);\n\n    FF_DPRINTF_START(NULL, start_frame); ff_dprintf_link(NULL, link, 0); dprintf(NULL, \" \"); ff_dprintf_ref(NULL, picref, 1);\n\n    if (!(start_frame = dst->start_frame))\n        start_frame = avfilter_default_start_frame;\n\n    /* prepare to copy the picture if it has insufficient permissions */\n    if ((dst->min_perms & picref->perms) != dst->min_perms ||\n         dst->rej_perms & picref->perms) {\n        av_log(link->dst, AV_LOG_DEBUG,\n                \"frame copy needed (have perms %x, need %x, reject %x)\\n\",\n                picref->perms,\n                link_dpad(link).min_perms, link_dpad(link).rej_perms);\n\n        link->cur_buf = avfilter_get_video_buffer(link, dst->min_perms, link->w, link->h);\n        link->src_buf = picref;\n        avfilter_copy_buffer_ref_props(link->cur_buf, link->src_buf);\n    }\n    else\n        link->cur_buf = picref;\n\n    start_frame(link, link->cur_buf);\n}", "target": 0}
{"idx": 5615, "func": "static int allocate_buffers(ShortenContext *s)\n{\n    int i, chan, err;\n\n    for (chan = 0; chan < s->channels; chan++) {\n        if (FFMAX(1, s->nmean) >= UINT_MAX / sizeof(int32_t)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"nmean too large\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (s->blocksize + (uint64_t)s->nwrap >= UINT_MAX / sizeof(int32_t)) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"s->blocksize + s->nwrap too large\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if ((err = av_reallocp_array(&s->offset[chan],\n                               sizeof(int32_t),\n                               FFMAX(1, s->nmean))) < 0)\n            return err;\n\n        if ((err = av_reallocp_array(&s->decoded_base[chan], (s->blocksize + s->nwrap),\n                               sizeof(s->decoded_base[0][0]))) < 0)\n            return err;\n        for (i = 0; i < s->nwrap; i++)\n            s->decoded_base[chan][i] = 0;\n        s->decoded[chan] = s->decoded_base[chan] + s->nwrap;\n    }\n\n    if ((err = av_reallocp_array(&s->coeffs, s->nwrap, sizeof(*s->coeffs))) < 0)\n        return err;\n\n    return 0;\n}", "target": 1}
{"idx": 5616, "func": "int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n                      AVCodecContext *codec, int size, int big_endian)\n{\n    int id;\n    uint64_t bitrate;\n\n    if (size < 14) {\n        avpriv_request_sample(codec, \"wav header size < 14\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n    if (!big_endian) {\n        id                 = avio_rl16(pb);\n        if (id != 0x0165) {\n            codec->channels    = avio_rl16(pb);\n            codec->sample_rate = avio_rl32(pb);\n            bitrate            = avio_rl32(pb) * 8LL;\n            codec->block_align = avio_rl16(pb);\n        }\n    } else {\n        id                 = avio_rb16(pb);\n        codec->channels    = avio_rb16(pb);\n        codec->sample_rate = avio_rb32(pb);\n        bitrate            = avio_rb32(pb) * 8LL;\n        codec->block_align = avio_rb16(pb);\n    }\n    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */\n        codec->bits_per_coded_sample = 8;\n    } else {\n        if (!big_endian) {\n            codec->bits_per_coded_sample = avio_rl16(pb);\n        } else {\n            codec->bits_per_coded_sample = avio_rb16(pb);\n        }\n    }\n    if (id == 0xFFFE) {\n        codec->codec_tag = 0;\n    } else {\n        codec->codec_tag = id;\n        codec->codec_id  = ff_wav_codec_get_id(id,\n                                               codec->bits_per_coded_sample);\n    }\n    if (size >= 18 && id != 0x0165) {  /* We're obviously dealing with WAVEFORMATEX */\n        int cbSize = avio_rl16(pb); /* cbSize */\n        if (big_endian) {\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n        size  -= 18;\n        cbSize = FFMIN(size, cbSize);\n        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n            parse_waveformatex(pb, codec);\n            cbSize -= 22;\n            size   -= 22;\n        }\n        if (cbSize > 0) {\n            av_freep(&codec->extradata);\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n                return AVERROR(ENOMEM);\n            size -= cbSize;\n        }\n\n        /* It is possible for the chunk to contain garbage at the end */\n        if (size > 0)\n            avio_skip(pb, size);\n    } else if (id == 0x0165 && size >= 32) {\n        int nb_streams, i;\n\n        size -= 4;\n        av_freep(&codec->extradata);\n        if (ff_get_extradata(codec, pb, size) < 0)\n            return AVERROR(ENOMEM);\n        nb_streams         = AV_RL16(codec->extradata + 4);\n        codec->sample_rate = AV_RL32(codec->extradata + 12);\n        codec->channels    = 0;\n        bitrate            = 0;\n        if (size < 8 + nb_streams * 20)\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < nb_streams; i++)\n            codec->channels += codec->extradata[8 + i * 20 + 17];\n    }\n\n    if (bitrate > INT_MAX) {\n        if (s->error_recognition & AV_EF_EXPLODE) {\n            av_log(s, AV_LOG_ERROR,\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n                    bitrate);\n            return AVERROR_INVALIDDATA;\n        } else {\n            av_log(s, AV_LOG_WARNING,\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n                   bitrate);\n            codec->bit_rate = 0;\n        }\n    } else {\n        codec->bit_rate = bitrate;\n    }\n\n    if (codec->sample_rate <= 0) {\n        av_log(s, AV_LOG_ERROR,\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n        return AVERROR_INVALIDDATA;\n    }\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n        /* Channels and sample_rate values are those prior to applying SBR\n         * and/or PS. */\n        codec->channels    = 0;\n        codec->sample_rate = 0;\n    }\n    /* override bits_per_coded_sample for G.726 */\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;\n\n    return 0;\n}", "target": 1}
{"idx": 5617, "func": "static void sub2video_update(InputStream *ist, AVSubtitle *sub)\n{\n    int w = ist->sub2video.w, h = ist->sub2video.h;\n    AVFrame *frame = ist->sub2video.frame;\n    int8_t *dst;\n    int     dst_linesize;\n    int num_rects, i;\n    int64_t pts, end_pts;\n\n    if (!frame)\n        return;\n    if (sub) {\n        pts       = av_rescale_q(sub->pts + sub->start_display_time * 1000LL,\n                                 AV_TIME_BASE_Q, ist->st->time_base);\n        end_pts   = av_rescale_q(sub->pts + sub->end_display_time   * 1000LL,\n                                 AV_TIME_BASE_Q, ist->st->time_base);\n        num_rects = sub->num_rects;\n    } else {\n        pts       = ist->sub2video.end_pts;\n        end_pts   = INT64_MAX;\n        num_rects = 0;\n    }\n    if (sub2video_get_blank_frame(ist) < 0) {\n        av_log(ist->dec_ctx, AV_LOG_ERROR,\n               \"Impossible to get a blank canvas.\\n\");\n        return;\n    }\n    dst          = frame->data    [0];\n    dst_linesize = frame->linesize[0];\n    for (i = 0; i < num_rects; i++)\n        sub2video_copy_rect(dst, dst_linesize, w, h, sub->rects[i]);\n    sub2video_push_ref(ist, pts);\n    ist->sub2video.end_pts = end_pts;\n}", "target": 0}
{"idx": 5618, "func": "static int proxy_wstunnel_pump(ws_baton_t *baton, apr_time_t timeout, int try_async) {\n    request_rec *r = baton->r;\n    conn_rec *c = r->connection;\n    proxy_conn_rec *conn = baton->proxy_connrec;\n    apr_socket_t *sock = conn->sock;\n    conn_rec *backconn = conn->connection;\n    const apr_pollfd_t *signalled;\n    apr_int32_t pollcnt, pi;\n    apr_int16_t pollevent;\n    apr_pollset_t *pollset = baton->pollset;\n    apr_socket_t *client_socket = baton->client_soc;\n    apr_status_t rv;\n    apr_bucket_brigade *bb = baton->bb;\n\n    while(1) { \n        if ((rv = apr_pollset_poll(pollset, timeout, &pollcnt, &signalled))\n                != APR_SUCCESS) {\n            if (APR_STATUS_IS_EINTR(rv)) {\n                continue;\n            }\n            else if (APR_STATUS_IS_TIMEUP(rv)) { \n                if (try_async) { \n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02542) \"Attempting to go async\");\n                    return SUSPENDED;\n                }\n                else { \n                    return HTTP_REQUEST_TIME_OUT;\n                }\n            }\n            else { \n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02444) \"error apr_poll()\");\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02445)\n                \"woke from poll(), i=%d\", pollcnt);\n\n        for (pi = 0; pi < pollcnt; pi++) {\n            const apr_pollfd_t *cur = &signalled[pi];\n\n            if (cur->desc.s == sock) {\n                pollevent = cur->rtnevents;\n                if (pollevent & (APR_POLLIN | APR_POLLHUP)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02446)\n                            \"sock was readable\");\n                    rv = proxy_wstunnel_transfer(r, backconn, c, bb, \"sock\");\n                }\n                else if (pollevent & APR_POLLERR) {\n                    rv = APR_EPIPE;\n                    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02447)\n                            \"error on backconn\");\n                }\n                else { \n                    rv = APR_EGENERAL;\n                    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02605)\n                            \"unknown event on backconn %d\", pollevent);\n                }\n            }\n            else if (cur->desc.s == client_socket) {\n                pollevent = cur->rtnevents;\n                if (pollevent & (APR_POLLIN | APR_POLLHUP)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02448)\n                            \"client was readable\");\n                    rv = proxy_wstunnel_transfer(r, c, backconn, bb, \"client\");\n                }\n                else if (pollevent & APR_POLLERR) {\n                    rv = APR_EPIPE;\n                    c->aborted = 1;\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02607)\n                            \"error on client conn\");\n                }\n                else { \n                    rv = APR_EGENERAL;\n                    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02606)\n                            \"unknown event on client conn %d\", pollevent);\n                }\n            }\n            else {\n                rv = APR_EBADF;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02449)\n                        \"unknown socket in pollset\");\n            }\n\n        }\n        if (rv != APR_SUCCESS) {\n            break;\n        }\n\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n            \"finished with poll() - cleaning up\");\n\n    return OK;\n}", "target": 0}
{"idx": 5619, "func": "static void ssl_check_for_safari(SSL *s, const PACKET *pkt)\n{\n    unsigned int type;\n    PACKET sni, tmppkt;\n    size_t ext_len;\n\n    static const unsigned char kSafariExtensionsBlock[] = {\n        0x00, 0x0a,             /* elliptic_curves extension */\n        0x00, 0x08,             /* 8 bytes */\n        0x00, 0x06,             /* 6 bytes of curve ids */\n        0x00, 0x17,             /* P-256 */\n        0x00, 0x18,             /* P-384 */\n        0x00, 0x19,             /* P-521 */\n\n        0x00, 0x0b,             /* ec_point_formats */\n        0x00, 0x02,             /* 2 bytes */\n        0x01,                   /* 1 point format */\n        0x00,                   /* uncompressed */\n        /* The following is only present in TLS 1.2 */\n        0x00, 0x0d,             /* signature_algorithms */\n        0x00, 0x0c,             /* 12 bytes */\n        0x00, 0x0a,             /* 10 bytes */\n        0x05, 0x01,             /* SHA-384/RSA */\n        0x04, 0x01,             /* SHA-256/RSA */\n        0x02, 0x01,             /* SHA-1/RSA */\n        0x04, 0x03,             /* SHA-256/ECDSA */\n        0x02, 0x03,             /* SHA-1/ECDSA */\n    };\n\n    /* Length of the common prefix (first two extensions). */\n    static const size_t kSafariCommonExtensionsLength = 18;\n\n    tmppkt = *pkt;\n\n    if (!PACKET_forward(&tmppkt, 2)\n        || !PACKET_get_net_2(&tmppkt, &type)\n        || !PACKET_get_length_prefixed_2(&tmppkt, &sni)) {\n        return;\n    }\n\n    if (type != TLSEXT_TYPE_server_name)\n        return;\n\n    ext_len = TLS1_get_client_version(s) >= TLS1_2_VERSION ?\n        sizeof(kSafariExtensionsBlock) : kSafariCommonExtensionsLength;\n\n    s->s3->is_probably_safari = PACKET_equal(&tmppkt, kSafariExtensionsBlock,\n                                             ext_len);\n}", "target": 0}
{"idx": 5620, "func": "int av_frame_ref(AVFrame *dst, const AVFrame *src)\n{\n    int i, ret = 0;\n\n    dst->format         = src->format;\n    dst->width          = src->width;\n    dst->height         = src->height;\n    dst->channels       = src->channels;\n    dst->channel_layout = src->channel_layout;\n    dst->nb_samples     = src->nb_samples;\n\n    ret = av_frame_copy_props(dst, src);\n    if (ret < 0)\n        return ret;\n\n    /* duplicate the frame data if it's not refcounted */\n    if (!src->buf[0]) {\n        ret = av_frame_get_buffer(dst, 32);\n        if (ret < 0)\n            return ret;\n\n        ret = av_frame_copy(dst, src);\n        if (ret < 0)\n            av_frame_unref(dst);\n\n        return ret;\n    }\n\n    /* ref the buffers */\n    for (i = 0; i < FF_ARRAY_ELEMS(src->buf); i++) {\n        if (!src->buf[i])\n            continue;\n        dst->buf[i] = av_buffer_ref(src->buf[i]);\n        if (!dst->buf[i]) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n    }\n\n    if (src->extended_buf) {\n        dst->extended_buf = av_mallocz_array(sizeof(*dst->extended_buf),\n                                       src->nb_extended_buf);\n        if (!dst->extended_buf) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        dst->nb_extended_buf = src->nb_extended_buf;\n\n        for (i = 0; i < src->nb_extended_buf; i++) {\n            dst->extended_buf[i] = av_buffer_ref(src->extended_buf[i]);\n            if (!dst->extended_buf[i]) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n        }\n    }\n\n    /* duplicate extended data */\n    if (src->extended_data != src->data) {\n        int ch = src->channels;\n\n        if (!ch) {\n            ret = AVERROR(EINVAL);\n            goto fail;\n        }\n        CHECK_CHANNELS_CONSISTENCY(src);\n\n        dst->extended_data = av_malloc_array(sizeof(*dst->extended_data), ch);\n        if (!dst->extended_data) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        memcpy(dst->extended_data, src->extended_data, sizeof(*src->extended_data) * ch);\n    } else\n        dst->extended_data = dst->data;\n\n    memcpy(dst->data,     src->data,     sizeof(src->data));\n    memcpy(dst->linesize, src->linesize, sizeof(src->linesize));\n\n    return 0;\n\nfail:\n    av_frame_unref(dst);\n    return ret;\n}", "target": 1}
{"idx": 5621, "func": "static int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize)\n{\n    SCPRContext *s = avctx->priv_data;\n    GetByteContext *gb = &s->gb;\n    int cx = 0, cx1 = 0, k = 0, clr = 0;\n    int run, r, g, b, off, y = 0, x = 0, ret;\n    const int cxshift = s->cxshift;\n    unsigned lx, ly, ptype;\n\n    reinit_tables(s);\n    bytestream2_skip(gb, 2);\n    init_rangecoder(&s->rc, gb);\n\n    while (k < avctx->width + 1) {\n        ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = r >> cxshift;\n        ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = g >> cxshift;\n        ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n        if (ret < 0)\n            return ret;\n\n        cx1 = (cx << 6) & 0xFC0;\n        cx = b >> cxshift;\n\n        ret = decode_value(s, s->run_model[0], 256, 400, &run);\n        if (ret < 0)\n            return ret;\n\n        clr = (b << 16) + (g << 8) + r;\n        k += run;\n        while (run-- > 0) {\n            dst[y * linesize + x] = clr;\n            lx = x;\n            ly = y;\n            x++;\n            if (x >= avctx->width) {\n                x = 0;\n                y++;\n            }\n        }\n    }\n    off = -linesize - 1;\n    ptype = 0;\n\n    while (x < avctx->width && y < avctx->height) {\n        ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);\n        if (ret < 0)\n            return ret;\n        if (ptype == 0) {\n            ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n            if (ret < 0)\n                return ret;\n\n            cx1 = (cx << 6) & 0xFC0;\n            cx = r >> cxshift;\n            ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n            if (ret < 0)\n                return ret;\n\n            cx1 = (cx << 6) & 0xFC0;\n            cx = g >> cxshift;\n            ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n            if (ret < 0)\n                return ret;\n\n            cx1 = (cx << 6) & 0xFC0;\n            cx = b >> cxshift;\n            clr = (b << 16) + (g << 8) + r;\n        }\n        if (ptype > 5)\n            return AVERROR_INVALIDDATA;\n        ret = decode_value(s, s->run_model[ptype], 256, 400, &run);\n        if (ret < 0)\n            return ret;\n\n        switch (ptype) {\n        case 0:\n            while (run-- > 0) {\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 1:\n            while (run-- > 0) {\n                dst[y * linesize + x] = dst[ly * linesize + lx];\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            clr = dst[ly * linesize + lx];\n            break;\n        case 2:\n            while (run-- > 0) {\n                clr = dst[y * linesize + x + off + 1];\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 4:\n            while (run-- > 0) {\n                uint8_t *odst = (uint8_t *)dst;\n                r = odst[(ly * linesize + lx) * 4] +\n                    odst[((y * linesize + x) + off) * 4 + 4] -\n                    odst[((y * linesize + x) + off) * 4];\n                g = odst[(ly * linesize + lx) * 4 + 1] +\n                    odst[((y * linesize + x) + off) * 4 + 5] -\n                    odst[((y * linesize + x) + off) * 4 + 1];\n                b = odst[(ly * linesize + lx) * 4 + 2] +\n                    odst[((y * linesize + x) + off) * 4 + 6] -\n                    odst[((y * linesize + x) + off) * 4 + 2];\n                clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        case 5:\n            while (run-- > 0) {\n                clr = dst[y * linesize + x + off];\n                dst[y * linesize + x] = clr;\n                lx = x;\n                ly = y;\n                x++;\n                if (x >= avctx->width) {\n                    x = 0;\n                    y++;\n                }\n            }\n            break;\n        }\n\n        if (avctx->bits_per_coded_sample == 16) {\n            cx1 = (clr & 0xFF00) >> 2;\n            cx = (clr & 0xFFFFFF) >> 16;\n        } else {\n            cx1 = (clr & 0xFC00) >> 4;\n            cx = (clr & 0xFFFFFF) >> 18;\n        }\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5622, "func": "static char *sh_malloc(size_t size)\n{\n    int list, slist;\n    size_t i;\n    char *chunk;\n\n    list = sh.freelist_size - 1;\n    for (i = sh.minsize; i < size; i <<= 1)\n        list--;\n    if (list < 0)\n        return NULL;\n\n    /* try to find a larger entry to split */\n    for (slist = list; slist >= 0; slist--)\n        if (sh.freelist[slist] != NULL)\n            break;\n    if (slist < 0)\n        return NULL;\n\n    /* split larger entry */\n    while (slist != list) {\n        char *temp = sh.freelist[slist];\n\n        /* remove from bigger list */\n        OPENSSL_assert(!sh_testbit(temp, slist, sh.bitmalloc));\n        sh_clearbit(temp, slist, sh.bittable);\n        sh_remove_from_list(temp);\n        OPENSSL_assert(temp != sh.freelist[slist]);\n\n        /* done with bigger list */\n        slist++;\n\n        /* add to smaller list */\n        OPENSSL_assert(!sh_testbit(temp, slist, sh.bitmalloc));\n        sh_setbit(temp, slist, sh.bittable);\n        sh_add_to_list(&sh.freelist[slist], temp);\n        OPENSSL_assert(sh.freelist[slist] == temp);\n\n        /* split in 2 */\n        temp += sh.arena_size >> slist;\n        OPENSSL_assert(!sh_testbit(temp, slist, sh.bitmalloc));\n        sh_setbit(temp, slist, sh.bittable);\n        sh_add_to_list(&sh.freelist[slist], temp);\n        OPENSSL_assert(sh.freelist[slist] == temp);\n\n        OPENSSL_assert(temp-(sh.arena_size >> slist) == sh_find_my_buddy(temp, slist));\n    }\n\n    /* peel off memory to hand back */\n    chunk = sh.freelist[list];\n    OPENSSL_assert(sh_testbit(chunk, list, sh.bittable));\n    sh_setbit(chunk, list, sh.bitmalloc);\n    sh_remove_from_list(chunk);\n\n    OPENSSL_assert(WITHIN_ARENA(chunk));\n\n    return chunk;\n}", "target": 1}
{"idx": 5623, "func": "void DES_cfb_encrypt(const unsigned char *in, unsigned char *out, int numbits,\n\t\t     long length, DES_key_schedule *schedule, DES_cblock *ivec,\n\t\t     int enc)\n\t{\n\tregister DES_LONG d0,d1,v0,v1;\n\tregister unsigned long l=length;\n\tregister int num=numbits,n=(numbits+7)/8,i;\n\tDES_LONG ti[2];\n\tunsigned char *iv;\n\tunsigned char ovec[16];\n\n\tif (num > 64) return;\n\tiv = &(*ivec)[0];\n\tc2l(iv,v0);\n\tc2l(iv,v1);\n\tif (enc)\n\t\t{\n\t\twhile (l >= (unsigned long)n)\n\t\t\t{\n\t\t\tl-=n;\n\t\t\tti[0]=v0;\n\t\t\tti[1]=v1;\n\t\t\tDES_encrypt1((DES_LONG *)ti,schedule,DES_ENCRYPT);\n\t\t\tc2ln(in,d0,d1,n);\n\t\t\tin+=n;\n\t\t\td0^=ti[0];\n\t\t\td1^=ti[1];\n\t\t\tl2cn(d0,d1,out,n);\n\t\t\tout+=n;\n\t\t\t/* 30-08-94 - eay - changed because l>>32 and\n\t\t\t * l<<32 are bad under gcc :-( */\n\t\t\tif (num == 32)\n\t\t\t\t{ v0=v1; v1=d0; }\n\t\t\telse if (num == 64)\n\t\t\t\t{ v0=d0; v1=d1; }\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tiv=&ovec[0];\n\t\t\t\tl2c(v0,iv);\n\t\t\t\tl2c(v1,iv);\n\t\t\t\tl2c(d0,iv);\n\t\t\t\tl2c(d1,iv);\n\t\t\t\t/* shift ovec left most of the bits... */\n\t\t\t\tmemmove(ovec,ovec+num/8,8+(num%8 ? 1 : 0));\n\t\t\t\t/* now the remaining bits */\n\t\t\t\tif(num%8 != 0)\n\t\t\t\t\tfor(i=0 ; i < 8 ; ++i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tovec[i]<<=num%8;\n\t\t\t\t\t\tovec[i]|=ovec[i+1]>>(8-num%8);\n\t\t\t\t\t\t}\n\t\t\t\tiv=&ovec[0];\n\t\t\t\tc2l(iv,v0);\n\t\t\t\tc2l(iv,v1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\twhile (l >= (unsigned long)n)\n\t\t\t{\n\t\t\tl-=n;\n\t\t\tti[0]=v0;\n\t\t\tti[1]=v1;\n\t\t\tDES_encrypt1((DES_LONG *)ti,schedule,DES_ENCRYPT);\n\t\t\tc2ln(in,d0,d1,n);\n\t\t\tin+=n;\n\t\t\t/* 30-08-94 - eay - changed because l>>32 and\n\t\t\t * l<<32 are bad under gcc :-( */\n\t\t\tif (num == 32)\n\t\t\t\t{ v0=v1; v1=d0; }\n\t\t\telse if (num == 64)\n\t\t\t\t{ v0=d0; v1=d1; }\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tiv=&ovec[0];\n\t\t\t\tl2c(v0,iv);\n\t\t\t\tl2c(v1,iv);\n\t\t\t\tl2c(d0,iv);\n\t\t\t\tl2c(d1,iv);\n\t\t\t\t/* shift ovec left most of the bits... */\n\t\t\t\tmemmove(ovec,ovec+num/8,8+(num%8 ? 1 : 0));\n\t\t\t\t/* now the remaining bits */\n\t\t\t\tif(num%8 != 0)\n\t\t\t\t\tfor(i=0 ; i < 8 ; ++i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tovec[i]<<=num%8;\n\t\t\t\t\t\tovec[i]|=ovec[i+1]>>(8-num%8);\n\t\t\t\t\t\t}\n\t\t\t\tiv=&ovec[0];\n\t\t\t\tc2l(iv,v0);\n\t\t\t\tc2l(iv,v1);\n\t\t\t\t}\n\t\t\td0^=ti[0];\n\t\t\td1^=ti[1];\n\t\t\tl2cn(d0,d1,out,n);\n\t\t\tout+=n;\n\t\t\t}\n\t\t}\n\tiv = &(*ivec)[0];\n\tl2c(v0,iv);\n\tl2c(v1,iv);\n\tv0=v1=d0=d1=ti[0]=ti[1]=0;\n\t}", "target": 1}
{"idx": 5624, "func": "int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\n\t{\n\tint ret=0;\n\tint top,al,bl;\n\tBIGNUM *rr;\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\n\tint i;\n#endif\n#ifdef BN_RECURSION\n\tBIGNUM *t=NULL;\n\tint j=0,k;\n#endif\n\n#ifdef BN_COUNT\n\tfprintf(stderr,\"BN_mul %d * %d\\n\",a->top,b->top);\n#endif\n\n\tbn_check_top(a);\n\tbn_check_top(b);\n\tbn_check_top(r);\n\n\tal=a->top;\n\tbl=b->top;\n\n\tif ((al == 0) || (bl == 0))\n\t\t{\n\t\tBN_zero(r);\n\t\treturn(1);\n\t\t}\n\ttop=al+bl;\n\n\tBN_CTX_start(ctx);\n\tif ((r == a) || (r == b))\n\t\t{\n\t\tif ((rr = BN_CTX_get(ctx)) == NULL) goto err;\n\t\t}\n\telse\n\t\trr = r;\n\trr->neg=a->neg^b->neg;\n\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\n\ti = al-bl;\n#endif\n#ifdef BN_MUL_COMBA\n\tif (i == 0)\n\t\t{\n# if 0\n\t\tif (al == 4)\n\t\t\t{\n\t\t\tif (bn_wexpand(rr,8) == NULL) goto err;\n\t\t\trr->top=8;\n\t\t\tbn_mul_comba4(rr->d,a->d,b->d);\n\t\t\tgoto end;\n\t\t\t}\n# endif\n\t\tif (al == 8)\n\t\t\t{\n\t\t\tif (bn_wexpand(rr,16) == NULL) goto err;\n\t\t\trr->top=16;\n\t\t\tbn_mul_comba8(rr->d,a->d,b->d);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n#endif /* BN_MUL_COMBA */\n#ifdef BN_RECURSION\n\tif ((al >= BN_MULL_SIZE_NORMAL) && (bl >= BN_MULL_SIZE_NORMAL))\n\t\t{\n\t\tif (i >= -1 && i <= 1)\n\t\t\t{\n\t\t\tint sav_j =0;\n\t\t\t/* Find out the power of two lower or equal\n\t\t\t   to the longest of the two numbers */\n\t\t\tif (i >= 0)\n\t\t\t\t{\n\t\t\t\tj = BN_num_bits_word((BN_ULONG)al);\n\t\t\t\t}\n\t\t\tif (i == -1)\n\t\t\t\t{\n\t\t\t\tj = BN_num_bits_word((BN_ULONG)bl);\n\t\t\t\t}\n\t\t\tsav_j = j;\n\t\t\tj = 1<<(j-1);\n\t\t\tassert(j <= al || j <= bl);\n\t\t\tk = j+j;\n\t\t\tt = BN_CTX_get(ctx);\n\t\t\tif (al > j || bl > j)\n\t\t\t\t{\n\t\t\t\tbn_wexpand(t,k*4);\n\t\t\t\tbn_wexpand(rr,k*4);\n\t\t\t\tbn_mul_part_recursive(rr->d,a->d,b->d,\n\t\t\t\t\tj,al-j,bl-j,t->d);\n\t\t\t\t}\n\t\t\telse\t/* al <= j || bl <= j */\n\t\t\t\t{\n\t\t\t\tbn_wexpand(t,k*2);\n\t\t\t\tbn_wexpand(rr,k*2);\n\t\t\t\tbn_mul_recursive(rr->d,a->d,b->d,\n\t\t\t\t\tj,al-j,bl-j,t->d);\n\t\t\t\t}\n\t\t\trr->top=top;\n\t\t\tgoto end;\n\t\t\t}\n#if 0\n\t\tif (i == 1 && !BN_get_flags(b,BN_FLG_STATIC_DATA))\n\t\t\t{\n\t\t\tBIGNUM *tmp_bn = (BIGNUM *)b;\n\t\t\tif (bn_wexpand(tmp_bn,al) == NULL) goto err;\n\t\t\ttmp_bn->d[bl]=0;\n\t\t\tbl++;\n\t\t\ti--;\n\t\t\t}\n\t\telse if (i == -1 && !BN_get_flags(a,BN_FLG_STATIC_DATA))\n\t\t\t{\n\t\t\tBIGNUM *tmp_bn = (BIGNUM *)a;\n\t\t\tif (bn_wexpand(tmp_bn,bl) == NULL) goto err;\n\t\t\ttmp_bn->d[al]=0;\n\t\t\tal++;\n\t\t\ti++;\n\t\t\t}\n\t\tif (i == 0)\n\t\t\t{\n\t\t\t/* symmetric and > 4 */\n\t\t\t/* 16 or larger */\n\t\t\tj=BN_num_bits_word((BN_ULONG)al);\n\t\t\tj=1<<(j-1);\n\t\t\tk=j+j;\n\t\t\tt = BN_CTX_get(ctx);\n\t\t\tif (al == j) /* exact multiple */\n\t\t\t\t{\n\t\t\t\tif (bn_wexpand(t,k*2) == NULL) goto err;\n\t\t\t\tif (bn_wexpand(rr,k*2) == NULL) goto err;\n\t\t\t\tbn_mul_recursive(rr->d,a->d,b->d,al,t->d);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif (bn_wexpand(t,k*4) == NULL) goto err;\n\t\t\t\tif (bn_wexpand(rr,k*4) == NULL) goto err;\n\t\t\t\tbn_mul_part_recursive(rr->d,a->d,b->d,al-j,j,t->d);\n\t\t\t\t}\n\t\t\trr->top=top;\n\t\t\tgoto end;\n\t\t\t}\n#endif\n\t\t}\n#endif /* BN_RECURSION */\n\tif (bn_wexpand(rr,top) == NULL) goto err;\n\trr->top=top;\n\tbn_mul_normal(rr->d,a->d,al,b->d,bl);\n\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\nend:\n#endif\n\tbn_correct_top(rr);\n\tif (r != rr) BN_copy(r,rr);\n\tret=1;\nerr:\n\tbn_check_top(r);\n\tBN_CTX_end(ctx);\n\treturn(ret);\n\t}", "target": 1}
{"idx": 5625, "func": "static void render_line(int x0, int y0, int x1, int y1, float *buf)\n{\n    int dy  = y1 - y0;\n    int adx = x1 - x0;\n    int ady = FFABS(dy);\n    int sy  = dy < 0 ? -1 : 1;\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n    if (ady*2 <= adx) { // optimized common case\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n    } else {\n        int base = dy / adx;\n        int x    = x0;\n        unsigned char y = y0;\n        int err  = -adx;\n        ady -= FFABS(base) * adx;\n        while (++x < x1) {\n            y += base;\n            err += ady;\n            if (err >= 0) {\n                err -= adx;\n                y   += sy;\n            }\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n        }\n    }\n}", "target": 0}
{"idx": 5626, "func": "static int mkv_write_simpletag(AVIOContext *pb, AVDictionaryEntry *t)\n{\n    uint8_t *key = av_strdup(t->key);\n    uint8_t *p   = key;\n    const uint8_t *lang = NULL;\n    ebml_master tag;\n\n    if (!key)\n        return AVERROR(ENOMEM);\n\n    if ((p = strrchr(p, '-')) &&\n        (lang = av_convert_lang_to(p + 1, AV_LANG_ISO639_2_BIBL)))\n        *p = 0;\n\n    p = key;\n    while (*p) {\n        if (*p == ' ')\n            *p = '_';\n        else if (*p >= 'a' && *p <= 'z')\n            *p -= 'a' - 'A';\n        p++;\n    }\n\n    tag = start_ebml_master(pb, MATROSKA_ID_SIMPLETAG, 0);\n    put_ebml_string(pb, MATROSKA_ID_TAGNAME, key);\n    if (lang)\n        put_ebml_string(pb, MATROSKA_ID_TAGLANG, lang);\n    put_ebml_string(pb, MATROSKA_ID_TAGSTRING, t->value);\n    end_ebml_master(pb, tag);\n\n    av_freep(&key);\n    return 0;\n}", "target": 0}
{"idx": 5627, "func": "static inline void qpel_motion(MpegEncContext *s,\n                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n                               int field_based, int bottom_field, int field_select,\n                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n                               qpel_mc_func (*qpix_op)[16],\n                               int motion_x, int motion_y, int h)\n{\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n    int dxy, uvdxy, mx, my, src_x, src_y, uvsrc_x, uvsrc_y, v_edge_pos, linesize, uvlinesize;\n\n    dxy = ((motion_y & 3) << 2) | (motion_x & 3);\n    src_x = s->mb_x *  16                 + (motion_x >> 2);\n    src_y = s->mb_y * (16 >> field_based) + (motion_y >> 2);\n\n    v_edge_pos = s->v_edge_pos >> field_based;\n    linesize = s->linesize << field_based;\n    uvlinesize = s->uvlinesize << field_based;\n\n    if(field_based){\n        mx= motion_x/2;\n        my= motion_y>>1;\n    }else if(s->workaround_bugs&FF_BUG_QPEL_CHROMA2){\n        static const int rtab[8]= {0,0,1,1,0,0,0,1};\n        mx= (motion_x>>1) + rtab[motion_x&7];\n        my= (motion_y>>1) + rtab[motion_y&7];\n    }else if(s->workaround_bugs&FF_BUG_QPEL_CHROMA){\n        mx= (motion_x>>1)|(motion_x&1);\n        my= (motion_y>>1)|(motion_y&1);\n    }else{\n        mx= motion_x/2;\n        my= motion_y/2;\n    }\n    mx= (mx>>1)|(mx&1);\n    my= (my>>1)|(my&1);\n\n    uvdxy= (mx&1) | ((my&1)<<1);\n    mx>>=1;\n    my>>=1;\n\n    uvsrc_x = s->mb_x *  8                 + mx;\n    uvsrc_y = s->mb_y * (8 >> field_based) + my;\n\n    ptr_y  = ref_picture[0] +   src_y *   linesize +   src_x;\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    if(   (unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x&3) - 16, 0)\n       || (unsigned)src_y > FFMAX(   v_edge_pos - (motion_y&3) - h , 0)){\n        s->dsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize,\n                            17, 17+field_based, src_x, src_y<<field_based,\n                            s->h_edge_pos, s->v_edge_pos);\n        ptr_y= s->edge_emu_buffer;\n        if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n            uint8_t *uvbuf= s->edge_emu_buffer + 18*s->linesize;\n            s->dsp.emulated_edge_mc(uvbuf, ptr_cb, s->uvlinesize,\n                                9, 9 + field_based,\n                                uvsrc_x, uvsrc_y<<field_based,\n                                s->h_edge_pos>>1, s->v_edge_pos>>1);\n            s->dsp.emulated_edge_mc(uvbuf + 16, ptr_cr, s->uvlinesize,\n                                9, 9 + field_based,\n                                uvsrc_x, uvsrc_y<<field_based,\n                                s->h_edge_pos>>1, s->v_edge_pos>>1);\n            ptr_cb= uvbuf;\n            ptr_cr= uvbuf + 16;\n        }\n    }\n\n    if(!field_based)\n        qpix_op[0][dxy](dest_y, ptr_y, linesize);\n    else{\n        if(bottom_field){\n            dest_y += s->linesize;\n            dest_cb+= s->uvlinesize;\n            dest_cr+= s->uvlinesize;\n        }\n\n        if(field_select){\n            ptr_y  += s->linesize;\n            ptr_cb += s->uvlinesize;\n            ptr_cr += s->uvlinesize;\n        }\n        //damn interlaced mode\n        //FIXME boundary mirroring is not exactly correct here\n        qpix_op[1][dxy](dest_y  , ptr_y  , linesize);\n        qpix_op[1][dxy](dest_y+8, ptr_y+8, linesize);\n    }\n    if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n        pix_op[1][uvdxy](dest_cr, ptr_cr, uvlinesize, h >> 1);\n        pix_op[1][uvdxy](dest_cb, ptr_cb, uvlinesize, h >> 1);\n    }\n}", "target": 0}
{"idx": 5628, "func": "static int dnxhd_mb_var_thread(AVCodecContext *avctx, void *arg, int jobnr, int threadnr)\n{\n    DNXHDEncContext *ctx = avctx->priv_data;\n    int mb_y = jobnr, mb_x;\n    ctx = ctx->thread[threadnr];\n    if (ctx->cid_table->bit_depth == 8) {\n        uint8_t *pix = ctx->thread[0]->src[0] + ((mb_y<<4) * ctx->m.linesize);\n        for (mb_x = 0; mb_x < ctx->m.mb_width; ++mb_x, pix += 16) {\n            unsigned mb  = mb_y * ctx->m.mb_width + mb_x;\n            int sum = ctx->m.dsp.pix_sum(pix, ctx->m.linesize);\n            int varc = (ctx->m.dsp.pix_norm1(pix, ctx->m.linesize) - (((unsigned)(sum*sum))>>8)+128)>>8;\n            ctx->mb_cmp[mb].value = varc;\n            ctx->mb_cmp[mb].mb = mb;\n        }\n    } else { // 10-bit\n        int const linesize = ctx->m.linesize >> 1;\n        for (mb_x = 0; mb_x < ctx->m.mb_width; ++mb_x) {\n            uint16_t *pix = (uint16_t*)ctx->thread[0]->src[0] + ((mb_y << 4) * linesize) + (mb_x << 4);\n            unsigned mb  = mb_y * ctx->m.mb_width + mb_x;\n            int sum = 0;\n            int sqsum = 0;\n            int mean, sqmean;\n            int i, j;\n            // Macroblocks are 16x16 pixels, unlike DCT blocks which are 8x8.\n            for (i = 0; i < 16; ++i) {\n                for (j = 0; j < 16; ++j) {\n                    // Turn 16-bit pixels into 10-bit ones.\n                    int const sample = (unsigned)pix[j] >> 6;\n                    sum += sample;\n                    sqsum += sample * sample;\n                    // 2^10 * 2^10 * 16 * 16 = 2^28, which is less than INT_MAX\n                }\n                pix += linesize;\n            }\n            mean = sum >> 8; // 16*16 == 2^8\n            sqmean = sqsum >> 8;\n            ctx->mb_cmp[mb].value = sqmean - mean * mean;\n            ctx->mb_cmp[mb].mb = mb;\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": 5629, "func": "static int read_payload_length_info(struct LATMContext *ctx, GetBitContext *gb)\n{\n    uint8_t tmp;\n\n    if (ctx->frame_length_type == 0) {\n        int mux_slot_length = 0;\n        do {\n            if (get_bits_left(gb) < 8)\n                return AVERROR_INVALIDDATA;\n            tmp = get_bits(gb, 8);\n            mux_slot_length += tmp;\n        } while (tmp == 255);\n        return mux_slot_length;\n    } else if (ctx->frame_length_type == 1) {\n        return ctx->frame_length;\n    } else if (ctx->frame_length_type == 3 ||\n               ctx->frame_length_type == 5 ||\n               ctx->frame_length_type == 7) {\n        skip_bits(gb, 2);          // mux_slot_length_coded\n    }\n    return 0;\n}", "target": 0}
{"idx": 5630, "func": "ngx_int_t\nngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r,\n    ngx_http_upstream_resolved_t *ur)\n{\n    u_char                            *p;\n    size_t                             len;\n    ngx_uint_t                         i, n;\n    struct sockaddr_in                *sin;\n    ngx_http_upstream_rr_peers_t      *peers;\n    ngx_http_upstream_rr_peer_data_t  *rrp;\n\n    rrp = r->upstream->peer.data;\n\n    if (rrp == NULL) {\n        rrp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_rr_peer_data_t));\n        if (rrp == NULL) {\n            return NGX_ERROR;\n        }\n\n        r->upstream->peer.data = rrp;\n    }\n\n    peers = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_rr_peers_t)\n                     + sizeof(ngx_http_upstream_rr_peer_t) * (ur->naddrs - 1));\n    if (peers == NULL) {\n        return NGX_ERROR;\n    }\n\n    peers->single = (ur->naddrs == 1);\n    peers->number = ur->naddrs;\n    peers->name = &ur->host;\n\n    if (ur->sockaddr) {\n        peers->peer[0].sockaddr = ur->sockaddr;\n        peers->peer[0].socklen = ur->socklen;\n        peers->peer[0].name = ur->host;\n        peers->peer[0].weight = 1;\n        peers->peer[0].effective_weight = 1;\n        peers->peer[0].current_weight = 0;\n        peers->peer[0].max_fails = 1;\n        peers->peer[0].fail_timeout = 10;\n\n    } else {\n\n        for (i = 0; i < ur->naddrs; i++) {\n\n            len = NGX_INET_ADDRSTRLEN + sizeof(\":65536\") - 1;\n\n            p = ngx_pnalloc(r->pool, len);\n            if (p == NULL) {\n                return NGX_ERROR;\n            }\n\n            len = ngx_inet_ntop(AF_INET, &ur->addrs[i], p, NGX_INET_ADDRSTRLEN);\n            len = ngx_sprintf(&p[len], \":%d\", ur->port) - p;\n\n            sin = ngx_pcalloc(r->pool, sizeof(struct sockaddr_in));\n            if (sin == NULL) {\n                return NGX_ERROR;\n            }\n\n            sin->sin_family = AF_INET;\n            sin->sin_port = htons(ur->port);\n            sin->sin_addr.s_addr = ur->addrs[i];\n\n            peers->peer[i].sockaddr = (struct sockaddr *) sin;\n            peers->peer[i].socklen = sizeof(struct sockaddr_in);\n            peers->peer[i].name.len = len;\n            peers->peer[i].name.data = p;\n            peers->peer[i].weight = 1;\n            peers->peer[i].effective_weight = 1;\n            peers->peer[i].current_weight = 0;\n            peers->peer[i].max_fails = 1;\n            peers->peer[i].fail_timeout = 10;\n        }\n    }\n\n    rrp->peers = peers;\n    rrp->current = 0;\n\n    if (rrp->peers->number <= 8 * sizeof(uintptr_t)) {\n        rrp->tried = &rrp->data;\n        rrp->data = 0;\n\n    } else {\n        n = (rrp->peers->number + (8 * sizeof(uintptr_t) - 1))\n                / (8 * sizeof(uintptr_t));\n\n        rrp->tried = ngx_pcalloc(r->pool, n * sizeof(uintptr_t));\n        if (rrp->tried == NULL) {\n            return NGX_ERROR;\n        }\n    }\n\n    r->upstream->peer.get = ngx_http_upstream_get_round_robin_peer;\n    r->upstream->peer.free = ngx_http_upstream_free_round_robin_peer;\n    r->upstream->peer.tries = rrp->peers->number;\n#if (NGX_HTTP_SSL)\n    r->upstream->peer.set_session = ngx_http_upstream_empty_set_session;\n    r->upstream->peer.save_session = ngx_http_upstream_empty_save_session;\n#endif\n\n    return NGX_OK;\n}", "target": 0}
{"idx": 5631, "func": "uint64\n_TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)\n{\n\tuint64 bytes = first * second;\n\n\tif (second && bytes / second != first) {\n\t\tTIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where);\n\t\tbytes = 0;\n\t}\n\n\treturn bytes;\n}", "target": 1}
{"idx": 5632, "func": "static int read_access_unit(AVCodecContext *avctx, void* data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    MLPDecodeContext *m = avctx->priv_data;\n    GetBitContext gb;\n    unsigned int length, substr;\n    unsigned int substream_start;\n    unsigned int header_size = 4;\n    unsigned int substr_header_size = 0;\n    uint8_t substream_parity_present[MAX_SUBSTREAMS];\n    uint16_t substream_data_len[MAX_SUBSTREAMS];\n    uint8_t parity_bits;\n\n    if (buf_size < 4)\n        return 0;\n\n    length = (AV_RB16(buf) & 0xfff) * 2;\n\n    if (length < 4 || length > buf_size)\n        return -1;\n\n    init_get_bits(&gb, (buf + 4), (length - 4) * 8);\n\n    m->is_major_sync_unit = 0;\n    if (show_bits_long(&gb, 31) == (0xf8726fba >> 1)) {\n        if (read_major_sync(m, &gb) < 0)\n            goto error;\n        m->is_major_sync_unit = 1;\n        header_size += 28;\n    }\n\n    if (!m->params_valid) {\n        av_log(m->avctx, AV_LOG_WARNING,\n               \"Stream parameters not seen; skipping frame.\\n\");\n        *data_size = 0;\n        return length;\n    }\n\n    substream_start = 0;\n\n    for (substr = 0; substr < m->num_substreams; substr++) {\n        int extraword_present, checkdata_present, end, nonrestart_substr;\n\n        extraword_present = get_bits1(&gb);\n        nonrestart_substr = get_bits1(&gb);\n        checkdata_present = get_bits1(&gb);\n        skip_bits1(&gb);\n\n        end = get_bits(&gb, 12) * 2;\n\n        substr_header_size += 2;\n\n        if (extraword_present) {\n            if (m->avctx->codec_id == CODEC_ID_MLP) {\n                av_log(m->avctx, AV_LOG_ERROR, \"There must be no extraword for MLP.\\n\");\n                goto error;\n            }\n            skip_bits(&gb, 16);\n            substr_header_size += 2;\n        }\n\n        if (!(nonrestart_substr ^ m->is_major_sync_unit)) {\n            av_log(m->avctx, AV_LOG_ERROR, \"Invalid nonrestart_substr.\\n\");\n            goto error;\n        }\n\n        if (end + header_size + substr_header_size > length) {\n            av_log(m->avctx, AV_LOG_ERROR,\n                   \"Indicated length of substream %d data goes off end of \"\n                   \"packet.\\n\", substr);\n            end = length - header_size - substr_header_size;\n        }\n\n        if (end < substream_start) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Indicated end offset of substream %d data \"\n                   \"is smaller than calculated start offset.\\n\",\n                   substr);\n            goto error;\n        }\n\n        if (substr > m->max_decoded_substream)\n            continue;\n\n        substream_parity_present[substr] = checkdata_present;\n        substream_data_len[substr] = end - substream_start;\n        substream_start = end;\n    }\n\n    parity_bits  = ff_mlp_calculate_parity(buf, 4);\n    parity_bits ^= ff_mlp_calculate_parity(buf + header_size, substr_header_size);\n\n    if ((((parity_bits >> 4) ^ parity_bits) & 0xF) != 0xF) {\n        av_log(avctx, AV_LOG_ERROR, \"Parity check failed.\\n\");\n        goto error;\n    }\n\n    buf += header_size + substr_header_size;\n\n    for (substr = 0; substr <= m->max_decoded_substream; substr++) {\n        SubStream *s = &m->substream[substr];\n        init_get_bits(&gb, buf, substream_data_len[substr] * 8);\n\n        m->matrix_changed = 0;\n        memset(m->filter_changed, 0, sizeof(m->filter_changed));\n\n        s->blockpos = 0;\n        do {\n            if (get_bits1(&gb)) {\n                if (get_bits1(&gb)) {\n                    /* A restart header should be present. */\n                    if (read_restart_header(m, &gb, buf, substr) < 0)\n                        goto next_substr;\n                    s->restart_seen = 1;\n                }\n\n                if (!s->restart_seen)\n                    goto next_substr;\n                if (read_decoding_params(m, &gb, substr) < 0)\n                    goto next_substr;\n            }\n\n            if (!s->restart_seen)\n                goto next_substr;\n\n            if (read_block_data(m, &gb, substr) < 0)\n                return -1;\n\n            if (get_bits_count(&gb) >= substream_data_len[substr] * 8)\n                goto substream_length_mismatch;\n\n        } while (!get_bits1(&gb));\n\n        skip_bits(&gb, (-get_bits_count(&gb)) & 15);\n\n        if (substream_data_len[substr] * 8 - get_bits_count(&gb) >= 32) {\n            int shorten_by;\n\n            if (get_bits(&gb, 16) != 0xD234)\n                return -1;\n\n            shorten_by = get_bits(&gb, 16);\n            if      (m->avctx->codec_id == CODEC_ID_TRUEHD && shorten_by  & 0x2000)\n                s->blockpos -= FFMIN(shorten_by & 0x1FFF, s->blockpos);\n            else if (m->avctx->codec_id == CODEC_ID_MLP    && shorten_by != 0xD234)\n                return -1;\n\n            if (substr == m->max_decoded_substream)\n                av_log(m->avctx, AV_LOG_INFO, \"End of stream indicated.\\n\");\n        }\n\n        if (substream_parity_present[substr]) {\n            uint8_t parity, checksum;\n\n            if (substream_data_len[substr] * 8 - get_bits_count(&gb) != 16)\n                goto substream_length_mismatch;\n\n            parity   = ff_mlp_calculate_parity(buf, substream_data_len[substr] - 2);\n            checksum = ff_mlp_checksum8       (buf, substream_data_len[substr] - 2);\n\n            if ((get_bits(&gb, 8) ^ parity) != 0xa9    )\n                av_log(m->avctx, AV_LOG_ERROR, \"Substream %d parity check failed.\\n\", substr);\n            if ( get_bits(&gb, 8)           != checksum)\n                av_log(m->avctx, AV_LOG_ERROR, \"Substream %d checksum failed.\\n\"    , substr);\n        }\n\n        if (substream_data_len[substr] * 8 != get_bits_count(&gb))\n            goto substream_length_mismatch;\n\nnext_substr:\n        if (!s->restart_seen)\n            av_log(m->avctx, AV_LOG_ERROR,\n                   \"No restart header present in substream %d.\\n\", substr);\n\n        buf += substream_data_len[substr];\n    }\n\n    rematrix_channels(m, m->max_decoded_substream);\n\n    if (output_data(m, m->max_decoded_substream, data, data_size) < 0)\n        return -1;\n\n    return length;\n\nsubstream_length_mismatch:\n    av_log(m->avctx, AV_LOG_ERROR, \"substream %d length mismatch\\n\", substr);\n    return -1;\n\nerror:\n    m->params_valid = 0;\n    return -1;\n}", "target": 0}
{"idx": 5633, "func": "static void copy_parameter_set(void **to, void **from, int count, int size)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        if (to[i] && !from[i])\n            av_freep(&to[i]);\n        else if (from[i] && !to[i])\n            to[i] = av_malloc(size);\n\n        if (from[i])\n            memcpy(to[i], from[i], size);\n    }\n}", "target": 1}
{"idx": 5634, "func": "static int util_verbose(ENGINE *e, int verbose, BIO *bio_out, const char *indent)\n\t{\n\tstatic const int line_wrap = 78;\n\tint num;\n\tchar *name = NULL;\n\tchar *desc = NULL;\n\tint flags;\n\tint xpos = 0;\n\tSTACK *cmds = sk_new_null();\n\n\tif(!cmds)\n\t\tgoto err;\n\tif(!ENGINE_ctrl(e, ENGINE_CTRL_HAS_CTRL_FUNCTION, 0, NULL, NULL) ||\n\t\t\t((num = ENGINE_ctrl(e, ENGINE_CTRL_GET_FIRST_CMD_TYPE,\n\t\t\t\t\t0, NULL, NULL)) <= 0))\n\t\t{\n#if 0\n\t\tBIO_printf(bio_out, \"%s<no control commands>\\n\", indent);\n#endif\n\t\treturn 1;\n\t\t}\n\tdo {\n\t\tint len;\n\t\t/* Get the command name */\n\t\tif((len = ENGINE_ctrl(e, ENGINE_CTRL_GET_NAME_LEN_FROM_CMD, num,\n\t\t\t\t\tNULL, NULL)) <= 0)\n\t\t\tgoto err;\n\t\tif((name = OPENSSL_malloc(len + 1)) == NULL)\n\t\t\tgoto err;\n\t\tif(ENGINE_ctrl(e, ENGINE_CTRL_GET_NAME_FROM_CMD, num, name,\n\t\t\t\t\tNULL) <= 0)\n\t\t\tgoto err;\n\t\t/* Get the command description */\n\t\tif((len = ENGINE_ctrl(e, ENGINE_CTRL_GET_DESC_LEN_FROM_CMD, num,\n\t\t\t\t\tNULL, NULL)) < 0)\n\t\t\tgoto err;\n\t\tif(len > 0)\n\t\t\t{\n\t\t\tif((desc = OPENSSL_malloc(len + 1)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tif(ENGINE_ctrl(e, ENGINE_CTRL_GET_DESC_FROM_CMD, num, desc,\n\t\t\t\t\t\tNULL) <= 0)\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t/* Get the command input flags */\n\t\tif((flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num,\n\t\t\t\t\tNULL, NULL)) < 0)\n\t\t\tgoto err;\n\t\t/* Now decide on the output */\n\t\tif(xpos == 0)\n\t\t\t/* Do an indent */\n\t\t\txpos = BIO_printf(bio_out, indent);\n\t\telse\n\t\t\t/* Otherwise prepend a \", \" */\n\t\t\txpos += BIO_printf(bio_out, \", \");\n\t\tif(verbose == 1)\n\t\t\t{\n\t\t\t/* We're just listing names, comma-delimited */\n\t\t\tif((xpos > (int)strlen(indent)) &&\n\t\t\t\t\t(xpos + (int)strlen(name) > line_wrap))\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_out, \"\\n\");\n\t\t\t\txpos = BIO_printf(bio_out, indent);\n\t\t\t\t}\n\t\t\txpos += BIO_printf(bio_out, \"%s\", name);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t/* We're listing names plus descriptions */\n\t\t\tBIO_printf(bio_out, \"%s: %s\\n\", name,\n\t\t\t\t(desc == NULL) ? \"<no description>\" : desc);\n\t\t\t/* ... and sometimes input flags */\n\t\t\tif((verbose == 3) && !util_flags(bio_out, flags,\n\t\t\t\t\t\t\tindent))\n\t\t\t\tgoto err;\n\t\t\txpos = 0;\n\t\t\t}\n\t\tOPENSSL_free(name); name = NULL;\n\t\tif(desc) { OPENSSL_free(desc); desc = NULL; }\n\t\t/* Move to the next command */\n\t\tnum = ENGINE_ctrl(e, ENGINE_CTRL_GET_NEXT_CMD_TYPE,\n\t\t\t\t\tnum, NULL, NULL);\n\t\t} while(num > 0);\n\tif(xpos > 0)\n\t\tBIO_printf(bio_out, \"\\n\");\n\treturn 1;\nerr:\n\tif(cmds) sk_pop_free(cmds, identity);\n\tif(name) OPENSSL_free(name);\n\tif(desc) OPENSSL_free(desc);\n\treturn 0;\n\t}", "target": 0}
{"idx": 5635, "func": "static void sa_doall(const OPENSSL_SA *sa, void (*node)(void **),\n                     void (*leaf)(ossl_uintmax_t, void *, void *), void *arg)\n{\n    int i[SA_BLOCK_MAX_LEVELS];\n    void *nodes[SA_BLOCK_MAX_LEVELS];\n    ossl_uintmax_t idx = 0;\n    int l = 0;\n\n    i[0] = 0;\n    nodes[0] = sa->nodes;\n    while (l >= 0) {\n        const int n = i[l];\n        void ** const p = nodes[l];\n\n        if (n >= SA_BLOCK_MAX) {\n            if (p != NULL && node != NULL)\n                (*node)(p);\n            l--;\n            idx >>= OPENSSL_SA_BLOCK_BITS;\n        } else {\n            i[l] = n + 1;\n            if (p != NULL && p[n] != NULL) {\n                idx = (idx & ~SA_BLOCK_MASK) | n;\n                if (l < sa->levels - 1) {\n                    i[++l] = 0;\n                    nodes[l] = p[n];\n                    idx <<= OPENSSL_SA_BLOCK_BITS;\n                } else if (leaf != NULL) {\n                    (*leaf)(idx, p[n], arg);\n                }\n            }\n        }\n    }\n}", "target": 1}
{"idx": 5636, "func": "static int ape_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame_ptr, AVPacket *avpkt)\n{\n    AVFrame *frame     = data;\n    const uint8_t *buf = avpkt->data;\n    APEContext *s = avctx->priv_data;\n    uint8_t *sample8;\n    int16_t *sample16;\n    int32_t *sample24;\n    int i, ch, ret;\n    int blockstodecode;\n\n    /* this should never be negative, but bad things will happen if it is, so\n       check it just to make sure. */\n    av_assert0(s->samples >= 0);\n\n    if(!s->samples){\n        uint32_t nblocks, offset;\n        int buf_size;\n\n        if (!avpkt->size) {\n            *got_frame_ptr = 0;\n            return 0;\n        }\n        if (avpkt->size < 8) {\n            av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        buf_size = avpkt->size & ~3;\n        if (buf_size != avpkt->size) {\n            av_log(avctx, AV_LOG_WARNING, \"packet size is not a multiple of 4. \"\n                   \"extra bytes at the end will be skipped.\\n\");\n        }\n        if (s->fileversion < 3950) // previous versions overread two bytes\n            buf_size += 2;\n        av_fast_padded_malloc(&s->data, &s->data_size, buf_size);\n        if (!s->data)\n            return AVERROR(ENOMEM);\n        s->dsp.bswap_buf((uint32_t*)s->data, (const uint32_t*)buf, buf_size >> 2);\n        memset(s->data + (buf_size & ~3), 0, buf_size & 3);\n        s->ptr = s->data;\n        s->data_end = s->data + buf_size;\n\n        nblocks = bytestream_get_be32(&s->ptr);\n        offset  = bytestream_get_be32(&s->ptr);\n        if (s->fileversion >= 3900) {\n            if (offset > 3) {\n                av_log(avctx, AV_LOG_ERROR, \"Incorrect offset passed\\n\");\n                s->data = NULL;\n                return AVERROR_INVALIDDATA;\n            }\n            if (s->data_end - s->ptr < offset) {\n                av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            s->ptr += offset;\n        } else {\n            if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)\n                return ret;\n            if (s->fileversion > 3800)\n                skip_bits_long(&s->gb, offset * 8);\n            else\n                skip_bits_long(&s->gb, offset);\n        }\n\n        if (!nblocks || nblocks > INT_MAX) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %u.\\n\", nblocks);\n            return AVERROR_INVALIDDATA;\n        }\n        s->samples = nblocks;\n\n        /* Initialize the frame decoder */\n        if (init_frame_decoder(s) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Error reading frame header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (!s->data) {\n        *got_frame_ptr = 0;\n        return avpkt->size;\n    }\n\n    blockstodecode = FFMIN(s->blocks_per_loop, s->samples);\n    // for old files coefficients were not interleaved,\n    // so we need to decode all of them at once\n    if (s->fileversion < 3930)\n        blockstodecode = s->samples;\n\n    /* reallocate decoded sample buffer if needed */\n    av_fast_malloc(&s->decoded_buffer, &s->decoded_size,\n                   2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer));\n    if (!s->decoded_buffer)\n        return AVERROR(ENOMEM);\n    memset(s->decoded_buffer, 0, s->decoded_size);\n    s->decoded[0] = s->decoded_buffer;\n    s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);\n\n    /* get output buffer */\n    frame->nb_samples = blockstodecode;\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n\n    s->error=0;\n\n    if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))\n        ape_unpack_mono(s, blockstodecode);\n    else\n        ape_unpack_stereo(s, blockstodecode);\n    emms_c();\n\n    if (s->error) {\n        s->samples=0;\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding frame\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    switch (s->bps) {\n    case 8:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample8 = (uint8_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff;\n        }\n        break;\n    case 16:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample16 = (int16_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample16++ = s->decoded[ch][i];\n        }\n        break;\n    case 24:\n        for (ch = 0; ch < s->channels; ch++) {\n            sample24 = (int32_t *)frame->data[ch];\n            for (i = 0; i < blockstodecode; i++)\n                *sample24++ = s->decoded[ch][i] << 8;\n        }\n        break;\n    }\n\n    s->samples -= blockstodecode;\n\n    *got_frame_ptr = 1;\n\n    return !s->samples ? avpkt->size : 0;\n}", "target": 0}
{"idx": 5637, "func": "static void add_pixels_clamped2_c(const DCTELEM *block, uint8_t *restrict pixels,\n                          int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<2;i++) {\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n        pixels += line_size;\n        block += 8;\n    }\n}", "target": 0}
{"idx": 5638, "func": "static void decode_mb(MadContext *t, int inter)\n{\n    MpegEncContext *s = &t->s;\n    int mv_map = 0;\n    int mv_x, mv_y;\n    int j;\n\n    if (inter) {\n        int v = decode210(&s->gb);\n        if (v < 2) {\n            mv_map = v ? get_bits(&s->gb, 6) : 63;\n            mv_x = decode_motion(&s->gb);\n            mv_y = decode_motion(&s->gb);\n        } else {\n            mv_map = 0;\n        }\n    }\n\n    for (j=0; j<6; j++) {\n        if (mv_map & (1<<j)) {  // mv_x and mv_y are guarded by mv_map\n            int add = 2*decode_motion(&s->gb);\n            if (t->last_frame.data[0])\n                comp_block(t, s->mb_x, s->mb_y, j, mv_x, mv_y, add);\n        } else {\n            s->dsp.clear_block(t->block);\n            decode_block_intra(t, t->block);\n            idct_put(t, t->block, s->mb_x, s->mb_y, j);\n        }\n    }\n}", "target": 0}
{"idx": 5639, "func": "static inline int av_size_mult(size_t a, size_t b, size_t *r)\n{\n    size_t t = a * b;\n    /* Hack inspired from glibc: only try the division if nelem and elsize\n     * are both greater than sqrt(SIZE_MAX). */\n    if ((a | b) >= ((size_t)1 << (sizeof(size_t) * 4)) && a && t / a != b)\n        return AVERROR(EINVAL);\n    *r = t;\n    return 0;\n}", "target": 1}
{"idx": 5640, "func": "static int test_sec_mem(void)\n{\n#if defined(OPENSSL_SYS_LINUX) || defined(OPENSSL_SYS_UNIX)\n    int testresult = 0;\n    char *p = NULL, *q = NULL, *r = NULL, *s = NULL;\n\n    r = OPENSSL_secure_malloc(20);\n    /* r = non-secure 20 */\n    if (!TEST_ptr(r)\n        || !TEST_true(CRYPTO_secure_malloc_init(4096, 32))\n        || !TEST_false(CRYPTO_secure_allocated(r)))\n        goto end;\n    p = OPENSSL_secure_malloc(20);\n    if (!TEST_ptr(p)\n        /* r = non-secure 20, p = secure 20 */\n        || !TEST_true(CRYPTO_secure_allocated(p))\n        /* 20 secure -> 32-byte minimum allocaton unit */\n        || !TEST_size_t_eq(CRYPTO_secure_used(), 32))\n        goto end;\n    q = OPENSSL_malloc(20);\n    if (!TEST_ptr(q))\n        goto end;\n    /* r = non-secure 20, p = secure 20, q = non-secure 20 */\n    if (!TEST_false(CRYPTO_secure_allocated(q)))\n        goto end;\n    s = OPENSSL_secure_malloc(20);\n    if (!TEST_ptr(s)\n        /* r = non-secure 20, p = secure 20, q = non-secure 20, s = secure 20 */\n        || !TEST_true(CRYPTO_secure_allocated(s))\n        /* 2 * 20 secure -> 64 bytes allocated */\n        || !TEST_size_t_eq(CRYPTO_secure_used(), 64))\n        goto end;\n    OPENSSL_secure_free(p);\n    p = NULL;\n    /* 20 secure -> 32 bytes allocated */\n    if (!TEST_size_t_eq(CRYPTO_secure_used(), 32))\n        goto end;\n    OPENSSL_free(q);\n    q = NULL;\n    /* should not complete, as secure memory is still allocated */\n    if (!TEST_false(CRYPTO_secure_malloc_done())\n        || !TEST_true(CRYPTO_secure_malloc_initialized()))\n        goto end;\n    OPENSSL_secure_free(s);\n    s = NULL;\n    /* secure memory should now be 0, so done should complete */\n    if (!TEST_size_t_eq(CRYPTO_secure_used(), 0)\n        || !TEST_true(CRYPTO_secure_malloc_done())\n        || !TEST_false(CRYPTO_secure_malloc_initialized()))\n        goto end;\n\n    TEST_info(\"Possible infinite loop: allocate more than available\");\n    if (!TEST_true(CRYPTO_secure_malloc_init(32768, 16)))\n        goto end;\n    TEST_ptr_null(OPENSSL_secure_malloc((size_t)-1));\n    TEST_true(CRYPTO_secure_malloc_done());\n\n    TEST_info(\"Possible infinite loop: small arena\");\n    if (!TEST_false(CRYPTO_secure_malloc_init(16, 16)))\n        goto end;\n    TEST_false(CRYPTO_secure_malloc_initialized());\n    TEST_ptr_null(OPENSSL_secure_malloc((size_t)-1));\n    TEST_true(CRYPTO_secure_malloc_done());\n\n    if (sizeof(size_t) > 4) {\n        TEST_info(\"Possible infinite loop: 1<<31 limit\");\n        if (!TEST_true(CRYPTO_secure_malloc_init((size_t)1<<34, (size_t)1<<4) != 0))\n            goto end;\n        TEST_true(CRYPTO_secure_malloc_done());\n    }\n    \n    /* this can complete - it was not really secure */\n    testresult = 1;\n end:\n    OPENSSL_secure_free(p);\n    OPENSSL_free(q);\n    OPENSSL_secure_free(r);\n    OPENSSL_secure_free(s);\n    return testresult;\n#else\n    /* Should fail. */\n    return TEST_false(CRYPTO_secure_malloc_init(4096, 32));\n#endif\n}", "target": 0}
{"idx": 5641, "func": "static int bmv_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    BMVContext *c = s->priv_data;\n    int type, err;\n\n    while (c->get_next) {\n        if (s->pb->eof_reached)\n            return AVERROR_EOF;\n        type = avio_r8(s->pb);\n        if (type == BMV_NOP)\n            continue;\n        if (type == BMV_END)\n            return AVERROR_EOF;\n        c->size = avio_rl24(s->pb);\n        if (!c->size)\n            return AVERROR_INVALIDDATA;\n        if ((err = av_reallocp(&c->packet, c->size + 1)) < 0)\n            return err;\n        c->packet[0] = type;\n        if (avio_read(s->pb, c->packet + 1, c->size) != c->size)\n            return AVERROR(EIO);\n        if (type & BMV_AUDIO) {\n            int audio_size = c->packet[1] * 65 + 1;\n            if (audio_size >= c->size) {\n                av_log(s, AV_LOG_ERROR, \"Reported audio size %d is bigger than packet size (%d)\\n\",\n                       audio_size, c->size);\n                return AVERROR_INVALIDDATA;\n            }\n            if (av_new_packet(pkt, audio_size) < 0)\n                return AVERROR(ENOMEM);\n            memcpy(pkt->data, c->packet + 1, pkt->size);\n            pkt->stream_index = 1;\n            pkt->pts          = c->audio_pos;\n            pkt->duration     = c->packet[1] * 32;\n            c->audio_pos += pkt->duration;\n            c->get_next   = 0;\n            return pkt->size;\n        } else\n            break;\n    }\n    if (av_new_packet(pkt, c->size + 1) < 0)\n        return AVERROR(ENOMEM);\n    pkt->stream_index = 0;\n    c->get_next = 1;\n    memcpy(pkt->data, c->packet, pkt->size);\n    return pkt->size;\n}", "target": 1}
{"idx": 5642, "func": "static void png_filter_row(PNGDSPContext *dsp, uint8_t *dst, int filter_type,\n                           uint8_t *src, uint8_t *last, int size, int bpp)\n{\n    int i, p, r, g, b, a;\n\n    switch (filter_type) {\n    case PNG_FILTER_VALUE_NONE:\n        memcpy(dst, src, size);\n        break;\n    case PNG_FILTER_VALUE_SUB:\n        for (i = 0; i < bpp; i++) {\n            dst[i] = src[i];\n        }\n        if (bpp == 4) {\n            p = *(int*)dst;\n            for (; i < size; i += bpp) {\n                int s = *(int*)(src + i);\n                p = ((s & 0x7f7f7f7f) + (p & 0x7f7f7f7f)) ^ ((s ^ p) & 0x80808080);\n                *(int*)(dst + i) = p;\n            }\n        } else {\n#define OP_SUB(x,s,l) x+s\n            UNROLL_FILTER(OP_SUB);\n        }\n        break;\n    case PNG_FILTER_VALUE_UP:\n        dsp->add_bytes_l2(dst, src, last, size);\n        break;\n    case PNG_FILTER_VALUE_AVG:\n        for (i = 0; i < bpp; i++) {\n            p = (last[i] >> 1);\n            dst[i] = p + src[i];\n        }\n#define OP_AVG(x,s,l) (((x + l) >> 1) + s) & 0xff\n        UNROLL_FILTER(OP_AVG);\n        break;\n    case PNG_FILTER_VALUE_PAETH:\n        for (i = 0; i < bpp; i++) {\n            p = last[i];\n            dst[i] = p + src[i];\n        }\n        if (bpp > 2 && size > 4) {\n            // would write off the end of the array if we let it process the last pixel with bpp=3\n            int w = bpp == 4 ? size : size - 3;\n            dsp->add_paeth_prediction(dst + i, src + i, last + i, w - i, bpp);\n            i = w;\n        }\n        ff_add_png_paeth_prediction(dst + i, src + i, last + i, size - i, bpp);\n        break;\n    }\n}", "target": 1}
{"idx": 5643, "func": "int ff_probe_input_buffer(ByteIOContext **pb, AVInputFormat **fmt,\n                          const char *filename, void *logctx,\n                          unsigned int offset, unsigned int max_probe_size)\n{\n    AVProbeData pd = { filename ? filename : \"\", NULL, -offset };\n    unsigned char *buf = NULL;\n    int probe_size;\n\n    if (!max_probe_size) {\n        max_probe_size = PROBE_BUF_MAX;\n    } else if (max_probe_size > PROBE_BUF_MAX) {\n        max_probe_size = PROBE_BUF_MAX;\n    } else if (max_probe_size < PROBE_BUF_MIN) {\n        return AVERROR(EINVAL);\n    }\n\n    if (offset >= max_probe_size) {\n        return AVERROR(EINVAL);\n    }\n\n    for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt; probe_size<<=1){\n        int ret, score = probe_size < max_probe_size ? AVPROBE_SCORE_MAX/4 : 0;\n        int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1;\n\n        if (probe_size < offset) {\n            continue;\n        }\n\n        /* read probe data */\n        buf = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\n        if ((ret = get_buffer(*pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n            av_free(buf);\n            return ret;\n        }\n        pd.buf_size += ret;\n        pd.buf = &buf[offset];\n\n        memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n\n        /* guess file format */\n        *fmt = av_probe_input_format2(&pd, 1, &score);\n        if(*fmt){\n            if(score <= AVPROBE_SCORE_MAX/4){ //this can only be true in the last iteration\n                av_log(logctx, AV_LOG_WARNING, \"Format detected only with low score of %d, misdetection possible!\\n\", score);\n            }else\n                av_log(logctx, AV_LOG_DEBUG, \"Probed with size=%d and score=%d\\n\", probe_size, score);\n        }\n    }\n\n    av_free(buf);\n    if (url_fseek(*pb, 0, SEEK_SET) < 0) {\n        url_fclose(*pb);\n        if (url_fopen(pb, filename, URL_RDONLY) < 0)\n            return AVERROR(EIO);\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5644, "func": "static int nsv_parse_NSVf_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    unsigned int av_unused file_size;\n    unsigned int size;\n    int64_t duration;\n    int strings_size;\n    int table_entries;\n    int table_entries_used;\n\n    av_dlog(s, \"%s()\\n\", __FUNCTION__);\n\n    nsv->state = NSV_UNSYNC; /* in case we fail */\n\n    size = avio_rl32(pb);\n    if (size < 28)\n        return -1;\n    nsv->NSVf_end = size;\n\n    //s->file_size = (uint32_t)avio_rl32(pb);\n    file_size = (uint32_t)avio_rl32(pb);\n    av_dlog(s, \"NSV NSVf chunk_size %u\\n\", size);\n    av_dlog(s, \"NSV NSVf file_size %u\\n\", file_size);\n\n    nsv->duration = duration = avio_rl32(pb); /* in ms */\n    av_dlog(s, \"NSV NSVf duration %\"PRId64\" ms\\n\", duration);\n    // XXX: store it in AVStreams\n\n    strings_size = avio_rl32(pb);\n    table_entries = avio_rl32(pb);\n    table_entries_used = avio_rl32(pb);\n    av_dlog(s, \"NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\",\n            strings_size, table_entries, table_entries_used);\n    if (pb->eof_reached)\n        return -1;\n\n    av_dlog(s, \"NSV got header; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (strings_size > 0) {\n        char *strings; /* last byte will be '\\0' to play safe with str*() */\n        char *p, *endp;\n        char *token, *value;\n        char quote;\n\n        p = strings = av_mallocz((size_t)strings_size + 1);\n        if (!p)\n            return AVERROR(ENOMEM);\n        endp = strings + strings_size;\n        avio_read(pb, strings, strings_size);\n        while (p < endp) {\n            while (*p == ' ')\n                p++; /* strip out spaces */\n            if (p >= endp-2)\n                break;\n            token = p;\n            p = strchr(p, '=');\n            if (!p || p >= endp-2)\n                break;\n            *p++ = '\\0';\n            quote = *p++;\n            value = p;\n            p = strchr(p, quote);\n            if (!p || p >= endp)\n                break;\n            *p++ = '\\0';\n            av_dlog(s, \"NSV NSVf INFO: %s='%s'\\n\", token, value);\n            av_dict_set(&s->metadata, token, value, 0);\n        }\n        av_free(strings);\n    }\n    if (pb->eof_reached)\n        return -1;\n\n    av_dlog(s, \"NSV got infos; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (table_entries_used > 0) {\n        int i;\n        nsv->index_entries = table_entries_used;\n        if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))\n            return -1;\n        nsv->nsvs_file_offset = av_malloc((unsigned)table_entries_used * sizeof(uint32_t));\n        if (!nsv->nsvs_file_offset)\n            return AVERROR(ENOMEM);\n\n        for(i=0;i<table_entries_used;i++)\n            nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n\n        if(table_entries > table_entries_used &&\n           avio_rl32(pb) == MKTAG('T','O','C','2')) {\n            nsv->nsvs_timestamps = av_malloc((unsigned)table_entries_used*sizeof(uint32_t));\n            if (!nsv->nsvs_timestamps)\n                return AVERROR(ENOMEM);\n            for(i=0;i<table_entries_used;i++) {\n                nsv->nsvs_timestamps[i] = avio_rl32(pb);\n            }\n        }\n    }\n\n    av_dlog(s, \"NSV got index; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n#ifdef DEBUG_DUMP_INDEX\n#define V(v) ((v<0x20 || v > 127)?'.':v)\n    /* dump index */\n    av_dlog(s, \"NSV %d INDEX ENTRIES:\\n\", table_entries);\n    av_dlog(s, \"NSV [dataoffset][fileoffset]\\n\", table_entries);\n    for (i = 0; i < table_entries; i++) {\n        unsigned char b[8];\n        avio_seek(pb, size + nsv->nsvs_file_offset[i], SEEK_SET);\n        avio_read(pb, b, 8);\n        av_dlog(s, \"NSV [0x%08lx][0x%08lx]: %02x %02x %02x %02x %02x %02x %02x %02x\"\n           \"%c%c%c%c%c%c%c%c\\n\",\n           nsv->nsvs_file_offset[i], size + nsv->nsvs_file_offset[i],\n           b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7],\n           V(b[0]), V(b[1]), V(b[2]), V(b[3]), V(b[4]), V(b[5]), V(b[6]), V(b[7]) );\n    }\n    //avio_seek(pb, size, SEEK_SET); /* go back to end of header */\n#undef V\n#endif\n\n    avio_seek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */\n\n    if (pb->eof_reached)\n        return -1;\n    nsv->state = NSV_HAS_READ_NSVF;\n    return 0;\n}", "target": 0}
{"idx": 5645, "func": "void PEM_dek_info(char *buf, const char *type, int len, char *str)\n{\n    static const unsigned char map[17] = \"0123456789ABCDEF\";\n    long i;\n    int j;\n\n    strcat(buf, \"DEK-Info: \");\n    strcat(buf, type);\n    strcat(buf, \",\");\n    j = strlen(buf);\n    for (i = 0; i < len; i++) {\n        buf[j + i * 2] = map[(str[i] >> 4) & 0x0f];\n        buf[j + i * 2 + 1] = map[(str[i]) & 0x0f];\n    }\n    buf[j + i * 2] = '\\n';\n    buf[j + i * 2 + 1] = '\\0';\n}", "target": 0}
{"idx": 5646, "func": "int ff_h263_decode_mba(MpegEncContext *s)\n{\n    int i, mb_pos;\n\n    for(i=0; i<6; i++){\n        if(s->mb_num-1 <= ff_mba_max[i]) break;\n    }\n    mb_pos= get_bits(&s->gb, ff_mba_length[i]);\n    s->mb_x= mb_pos % s->mb_width;\n    s->mb_y= mb_pos / s->mb_width;\n\n    return mb_pos;\n}", "target": 1}
{"idx": 5647, "func": "const char *OBJ_bsearch_ex(const char *key, const char *base, int num,\n\tint size, int (*cmp)(const void *, const void *), int flags)\n\t{\n\tint l,h,i=0,c=0;\n\tconst char *p = NULL;\n\n\tif (num == 0) return(NULL);\n\tl=0;\n\th=num;\n\twhile (l < h)\n\t\t{\n\t\ti=(l+h)/2;\n\t\tp= &(base[i*size]);\n\t\tc=(*cmp)(key,p);\n\t\tif (c < 0)\n\t\t\th=i;\n\t\telse if (c > 0)\n\t\t\tl=i+1;\n\t\telse\n\t\t\tbreak;\n\t\t}\n#ifdef CHARSET_EBCDIC\n/* THIS IS A KLUDGE - Because the *_obj is sorted in ASCII order, and\n * I don't have perl (yet), we revert to a *LINEAR* search\n * when the object wasn't found in the binary search.\n */\n\tif (c != 0)\n\t\t{\n\t\tfor (i=0; i<num; ++i)\n\t\t\t{\n\t\t\tp= &(base[i*size]);\n\t\t\tc = (*cmp)(key,p);\n\t\t\tif (c == 0 || (c < 0 && (flags & OBJ_BSEARCH_VALUE_ON_NOMATCH)))\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n#endif\n\tif (c != 0 && !(flags & OBJ_BSEARCH_VALUE_ON_NOMATCH))\n\t\tp = NULL;\n\telse if (c == 0 && (flags & OBJ_BSEARCH_FIRST_VALUE_ON_MATCH))\n\t\t{\n\t\twhile(i > 0 && (*cmp)(key,&(base[(i-1)*size])) == 0)\n\t\t\ti--;\n\t\tp = &(base[i*size]);\n\t\t}\n\treturn(p);\n\t}", "target": 1}
{"idx": 5648, "func": "int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n                              AVStream *st, RMStream *rst,\n                              unsigned int codec_data_size, const uint8_t *mime)\n{\n    unsigned int v;\n    int size;\n    int64_t codec_pos;\n    int ret;\n\n    if (codec_data_size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n    codec_pos = avio_tell(pb);\n    v = avio_rb32(pb);\n\n    if (v == MKBETAG('M', 'L', 'T', 'I')) {\n        int number_of_streams = avio_rb16(pb);\n        int number_of_mdpr;\n        int i;\n        for (i = 0; i<number_of_streams; i++)\n            avio_rb16(pb);\n        number_of_mdpr = avio_rb16(pb);\n        if (number_of_mdpr != 1) {\n            avpriv_request_sample(s, \"MLTI with multiple MDPR\");\n        }\n        avio_rb32(pb);\n        v = avio_rb32(pb);\n    }\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n        /* ra type header */\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n            return -1;\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n        avio_seek(pb, -4, SEEK_CUR);\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n            return ret;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n                                                st->codec->codec_tag);\n    } else if(mime && !strcmp(mime, \"logical-fileinfo\")){\n        int stream_count, rule_count, property_count, i;\n        ff_free_stream(s, st);\n        if (avio_rb16(pb) != 0) {\n            av_log(s, AV_LOG_WARNING, \"Unsupported version\\n\");\n            goto skip;\n        }\n        stream_count = avio_rb16(pb);\n        avio_skip(pb, 6*stream_count);\n        rule_count = avio_rb16(pb);\n        avio_skip(pb, 2*rule_count);\n        property_count = avio_rb16(pb);\n        for(i=0; i<property_count; i++){\n            uint8_t name[128], val[128];\n            avio_rb32(pb);\n            if (avio_rb16(pb) != 0) {\n                av_log(s, AV_LOG_WARNING, \"Unsupported Name value property version\\n\");\n                goto skip; //FIXME skip just this one\n            }\n            get_str8(pb, name, sizeof(name));\n            switch(avio_rb32(pb)) {\n            case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb));\n                av_dict_set(&s->metadata, name, val, 0);\n                break;\n            default: avio_skip(pb, avio_rb16(pb));\n            }\n        }\n    } else {\n        int fps;\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n        fail1:\n            av_log(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n            goto skip;\n        }\n        st->codec->codec_tag = avio_rl32(pb);\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n                                               st->codec->codec_tag);\n        av_dlog(s, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n            goto fail1;\n        st->codec->width  = avio_rb16(pb);\n        st->codec->height = avio_rb16(pb);\n        avio_skip(pb, 2); // looks like bits per sample\n        avio_skip(pb, 4); // always zero?\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n        fps = avio_rb32(pb);\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n            return ret;\n\n        if (fps > 0) {\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n                      0x10000, fps, (1 << 30) - 1);\n#if FF_API_R_FRAME_RATE\n            st->r_frame_rate = st->avg_frame_rate;\n#endif\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\nskip:\n    /* skip codec info */\n    size = avio_tell(pb) - codec_pos;\n    if (codec_data_size >= size) {\n        avio_skip(pb, codec_data_size - size);\n    } else {\n        av_log(s, AV_LOG_WARNING, \"codec_data_size %u < size %d\\n\", codec_data_size, size);\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5649, "func": "static void setup_trace(const char *str)\n{\n    char *val;\n\n    trace_data_stack = sk_tracedata_new_null();\n    val = OPENSSL_strdup(str);\n\n    if (val != NULL) {\n        char *valp = val;\n        char *item;\n\n        for (valp = val; (item = strtok(valp, \",\")) != NULL; valp = NULL) {\n            int category = OSSL_trace_get_category_num(item);\n\n            if (category >= 0) {\n                BIO *channel = BIO_push(BIO_new(apps_bf_prefix()),\n                                        dup_bio_err(FORMAT_TEXT));\n                tracedata *trace_data = OPENSSL_zalloc(sizeof(*trace_data));\n\n                if (trace_data == NULL\n                    || (trace_data->bio = channel) == NULL\n                    || OSSL_trace_set_callback(category, internal_trace_cb,\n                                               trace_data) == 0\n                    || sk_tracedata_push(trace_data_stack, trace_data) == 0) {\n                    OSSL_trace_set_callback(category, NULL, NULL);\n                    BIO_free_all(channel);\n                    fprintf(stderr,\n                            \"warning: unable to setup trace callback for category '%s'.\\n\",\n                            item);\n                }\n            } else {\n                fprintf(stderr,\n                        \"warning: unknown trace category: '%s'.\\n\",\n                        item);\n            }\n        }\n    }\n\n    OPENSSL_free(val);\n    atexit(cleanup_trace);\n}", "target": 1}
{"idx": 5650, "func": "int tls_collect_extensions(SSL *s, PACKET *packet, unsigned int context,\n                           RAW_EXTENSION **res, size_t *len, int init)\n{\n    PACKET extensions = *packet;\n    size_t i = 0;\n    size_t num_exts;\n    custom_ext_methods *exts = &s->cert->custext;\n    RAW_EXTENSION *raw_extensions = NULL;\n    const EXTENSION_DEFINITION *thisexd;\n\n    *res = NULL;\n\n    /*\n     * Initialise server side custom extensions. Client side is done during\n     * construction of extensions for the ClientHello.\n     */\n    if ((context & SSL_EXT_CLIENT_HELLO) != 0)\n        custom_ext_init(&s->cert->custext);\n\n    num_exts = OSSL_NELEM(ext_defs) + (exts != NULL ? exts->meths_count : 0);\n    raw_extensions = OPENSSL_zalloc(num_exts * sizeof(*raw_extensions));\n    if (raw_extensions == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_COLLECT_EXTENSIONS,\n                 ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    i = 0;\n    while (PACKET_remaining(&extensions) > 0) {\n        unsigned int type, idx;\n        PACKET extension;\n        RAW_EXTENSION *thisex;\n\n        if (!PACKET_get_net_2(&extensions, &type) ||\n            !PACKET_get_length_prefixed_2(&extensions, &extension)) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_F_TLS_COLLECT_EXTENSIONS,\n                     SSL_R_BAD_EXTENSION);\n            goto err;\n        }\n        /*\n         * Verify this extension is allowed. We only check duplicates for\n         * extensions that we recognise. We also have a special case for the\n         * PSK extension, which must be the last one in the ClientHello.\n         */\n        if (!verify_extension(s, context, type, exts, raw_extensions, &thisex)\n                || (thisex != NULL && thisex->present == 1)\n                || (type == TLSEXT_TYPE_psk\n                    && (context & SSL_EXT_CLIENT_HELLO) != 0\n                    && PACKET_remaining(&extensions) != 0)) {\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_COLLECT_EXTENSIONS,\n                     SSL_R_BAD_EXTENSION);\n            goto err;\n        }\n        idx = thisex - raw_extensions;\n        /*-\n         * Check that we requested this extension (if appropriate). Requests can\n         * be sent in the ClientHello and CertificateRequest. Unsolicited\n         * extensions can be sent in the NewSessionTicket. We only do this for\n         * the built-in extensions. Custom extensions have a different but\n         * similar check elsewhere.\n         * Special cases:\n         * - The HRR cookie extension is unsolicited\n         * - The renegotiate extension is unsolicited (the client signals\n         *   support via an SCSV)\n         * - The signed_certificate_timestamp extension can be provided by a\n         * custom extension or by the built-in version. We let the extension\n         * itself handle unsolicited response checks.\n         */\n        if (idx < OSSL_NELEM(ext_defs)\n                && (context & (SSL_EXT_CLIENT_HELLO\n                               | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST\n                               | SSL_EXT_TLS1_3_NEW_SESSION_TICKET)) == 0\n                && type != TLSEXT_TYPE_cookie\n                && type != TLSEXT_TYPE_renegotiate\n                && type != TLSEXT_TYPE_signed_certificate_timestamp\n                && (s->ext.extflags[idx] & SSL_EXT_FLAG_SENT) == 0) {\n            SSLfatal(s, SSL_AD_UNSUPPORTED_EXTENSION,\n                     SSL_F_TLS_COLLECT_EXTENSIONS, SSL_R_UNSOLICITED_EXTENSION);\n            goto err;\n        }\n        if (thisex != NULL) {\n            thisex->data = extension;\n            thisex->present = 1;\n            thisex->type = type;\n            thisex->received_order = i++;\n            if (s->ext.debug_cb)\n                s->ext.debug_cb(s, !s->server, thisex->type,\n                                PACKET_data(&thisex->data),\n                                PACKET_remaining(&thisex->data),\n                                s->ext.debug_arg);\n        }\n    }\n\n    if (init) {\n        /*\n         * Initialise all known extensions relevant to this context,\n         * whether we have found them or not\n         */\n        for (thisexd = ext_defs, i = 0; i < OSSL_NELEM(ext_defs);\n             i++, thisexd++) {\n            if (thisexd->init != NULL && (thisexd->context & context) != 0\n                && extension_is_relevant(s, thisexd->context, context)\n                && !thisexd->init(s, context)) {\n                /* SSLfatal() already called */\n                goto err;\n            }\n        }\n    }\n\n    *res = raw_extensions;\n    if (len != NULL)\n        *len = num_exts;\n    return 1;\n\n err:\n    OPENSSL_free(raw_extensions);\n    return 0;\n}", "target": 1}
{"idx": 5651, "func": "static int codec_reinit(AVCodecContext *avctx, int width, int height, int quality) {\n    NuvContext *c = avctx->priv_data;\n    width = (width + 1) & ~1;\n    height = (height + 1) & ~1;\n    if (quality >= 0)\n        get_quant_quality(c, quality);\n    if (width != c->width || height != c->height) {\n        if (av_image_check_size(height, width, 0, avctx) < 0)\n            return 0;\n        avctx->width = c->width = width;\n        avctx->height = c->height = height;\n        av_fast_malloc(&c->decomp_buf, &c->decomp_size, c->height * c->width * 3 / 2);\n        if (!c->decomp_buf) {\n            av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\");\n            return 0;\n        }\n        rtjpeg_decode_init(&c->rtj, &c->dsp, c->width, c->height, c->lq, c->cq);\n    } else if (quality != c->quality)\n        rtjpeg_decode_init(&c->rtj, &c->dsp, c->width, c->height, c->lq, c->cq);\n    return 1;\n}", "target": 0}
{"idx": 5652, "func": "static void flush_encoders(void)\n{\n    int i, ret;\n\n    for (i = 0; i < nb_output_streams; i++) {\n        OutputStream   *ost = output_streams[i];\n        AVCodecContext *enc = ost->st->codec;\n        AVFormatContext *os = output_files[ost->file_index]->ctx;\n        int stop_encoding = 0;\n\n        if (!ost->encoding_needed)\n            continue;\n\n        if (ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO && enc->frame_size <= 1)\n            continue;\n        if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && (os->oformat->flags & AVFMT_RAWPICTURE) && enc->codec->id == CODEC_ID_RAWVIDEO)\n            continue;\n\n        for (;;) {\n            AVPacket pkt;\n            int fifo_bytes, got_packet;\n            av_init_packet(&pkt);\n            pkt.data = NULL;\n            pkt.size = 0;\n\n            switch (ost->st->codec->codec_type) {\n            case AVMEDIA_TYPE_AUDIO:\n                fifo_bytes = av_fifo_size(ost->fifo);\n                if (fifo_bytes > 0) {\n                    /* encode any samples remaining in fifo */\n                    int frame_bytes = fifo_bytes;\n\n                    av_fifo_generic_read(ost->fifo, audio_buf, fifo_bytes, NULL);\n\n                    encode_audio_frame(os, ost, audio_buf, frame_bytes);\n                } else {\n                    /* flush encoder with NULL frames until it is done\n                       returning packets */\n                    if (encode_audio_frame(os, ost, NULL, 0) == 0) {\n                        stop_encoding = 1;\n                        break;\n                    }\n                }\n                break;\n            case AVMEDIA_TYPE_VIDEO:\n                ret = avcodec_encode_video2(enc, &pkt, NULL, &got_packet);\n                if (ret < 0) {\n                    av_log(NULL, AV_LOG_FATAL, \"Video encoding failed\\n\");\n                    exit_program(1);\n                }\n                video_size += ret;\n                if (ost->logfile && enc->stats_out) {\n                    fprintf(ost->logfile, \"%s\", enc->stats_out);\n                }\n                if (!got_packet) {\n                    stop_encoding = 1;\n                    break;\n                }\n                if (pkt.pts != AV_NOPTS_VALUE)\n                    pkt.pts = av_rescale_q(pkt.pts, enc->time_base, ost->st->time_base);\n                if (pkt.dts != AV_NOPTS_VALUE)\n                    pkt.dts = av_rescale_q(pkt.dts, enc->time_base, ost->st->time_base);\n                write_frame(os, &pkt, ost);\n                break;\n            default:\n                stop_encoding = 1;\n            }\n            if (stop_encoding)\n                break;\n        }\n    }\n}", "target": 1}
{"idx": 5653, "func": "static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)\n{\n    int i, len, sz;\n    GetBitContext gb;\n    int code_table[64];\n\n    /* get the rle codes (at most 64 bytes) */\n    init_get_bits(&gb, src, 64 * 8);\n    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {\n        code_table[i] = get_sbits(&gb, 4);\n        sz += FFABS(code_table[i]);\n    }\n    src += (get_bits_count(&gb) + 7) / 8;\n\n    /* do the rle unpacking */\n    for (i = 0; i < 64 && dst_size > 0; i++) {\n        len = code_table[i];\n        if (len < 0) {\n            len = -len;\n            memset(dst, *src++, FFMIN(len, dst_size));\n        } else {\n            memcpy(dst, src, FFMIN(len, dst_size));\n            src += len;\n        }\n        dst += len;\n        dst_size -= len;\n    }\n    return src;\n}", "target": 0}
{"idx": 5654, "func": "static int unpack_modes(Vp3DecodeContext *s, GetBitContext *gb)\n{\n    int i, j, k, sb_x, sb_y;\n    int scheme;\n    int current_macroblock;\n    int current_fragment;\n    int coding_mode;\n    int custom_mode_alphabet[CODING_MODE_COUNT];\n    const int *alphabet;\n\n    if (s->keyframe) {\n        for (i = 0; i < s->fragment_count; i++)\n            s->all_fragments[i].coding_method = MODE_INTRA;\n\n    } else {\n\n        /* fetch the mode coding scheme for this frame */\n        scheme = get_bits(gb, 3);\n\n        /* is it a custom coding scheme? */\n        if (scheme == 0) {\n            for (i = 0; i < 8; i++)\n                custom_mode_alphabet[i] = MODE_INTER_NO_MV;\n            for (i = 0; i < 8; i++)\n                custom_mode_alphabet[get_bits(gb, 3)] = i;\n            alphabet = custom_mode_alphabet;\n        } else\n            alphabet = ModeAlphabet[scheme-1];\n\n        /* iterate through all of the macroblocks that contain 1 or more\n         * coded fragments */\n        for (sb_y = 0; sb_y < s->y_superblock_height; sb_y++) {\n            for (sb_x = 0; sb_x < s->y_superblock_width; sb_x++) {\n\n            for (j = 0; j < 4; j++) {\n                int mb_x = 2*sb_x +   (j>>1);\n                int mb_y = 2*sb_y + (((j>>1)+j)&1);\n                int frags_coded = 0;\n                current_macroblock = mb_y * s->macroblock_width + mb_x;\n\n                if (mb_x >= s->macroblock_width || mb_y >= s->macroblock_height)\n                    continue;\n\n#define BLOCK_X (2*mb_x + (k&1))\n#define BLOCK_Y (2*mb_y + (k>>1))\n                /* coding modes are only stored if the macroblock has at least one\n                 * luma block coded, otherwise it must be INTER_NO_MV */\n                for (k = 0; k < 4; k++) {\n                    current_fragment = BLOCK_Y*s->fragment_width + BLOCK_X;\n                    if (s->all_fragments[current_fragment].coding_method != MODE_COPY)\n                        break;\n                }\n                if (k == 4) {\n                    s->macroblock_coding[current_macroblock] = MODE_INTER_NO_MV;\n                    continue;\n                }\n\n                /* mode 7 means get 3 bits for each coding mode */\n                if (scheme == 7)\n                    coding_mode = get_bits(gb, 3);\n                else\n                    coding_mode = alphabet\n                        [get_vlc2(gb, s->mode_code_vlc.table, 3, 3)];\n\n                s->macroblock_coding[current_macroblock] = coding_mode;\n                for (k = 0; k < 4; k++) {\n                    current_fragment =\n                        BLOCK_Y*s->fragment_width + BLOCK_X;\n                    if (s->all_fragments[current_fragment].coding_method !=\n                        MODE_COPY)\n                        s->all_fragments[current_fragment].coding_method =\n                            coding_mode;\n                }\n                for (k = 0; k < 2; k++) {\n                    current_fragment = s->fragment_start[k+1] +\n                        mb_y*(s->fragment_width>>1) + mb_x;\n                    if (s->all_fragments[current_fragment].coding_method !=\n                        MODE_COPY)\n                        s->all_fragments[current_fragment].coding_method =\n                            coding_mode;\n                }\n            }\n            }\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5655, "func": "static int rv34_decode_slice(RV34DecContext *r, int end, const uint8_t* buf, int buf_size)\n{\n    MpegEncContext *s = &r->s;\n    GetBitContext *gb = &s->gb;\n    int mb_pos;\n    int res;\n\n    init_get_bits(&r->s.gb, buf, buf_size*8);\n    res = r->parse_slice_header(r, gb, &r->si);\n    if(res < 0){\n        av_log(s->avctx, AV_LOG_ERROR, \"Incorrect or unknown slice header\\n\");\n        return -1;\n    }\n\n    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr==NULL) {\n        if (s->width != r->si.width || s->height != r->si.height) {\n            int err;\n\n            av_log(s->avctx, AV_LOG_WARNING, \"Changing dimensions to %dx%d\\n\",\n                   r->si.width, r->si.height);\n            ff_MPV_common_end(s);\n            s->width  = r->si.width;\n            s->height = r->si.height;\n            avcodec_set_dimensions(s->avctx, s->width, s->height);\n            if ((err = ff_MPV_common_init(s)) < 0)\n                return err;\n            if ((err = rv34_decoder_realloc(r)) < 0)\n                return err;\n        }\n        s->pict_type = r->si.type ? r->si.type : AV_PICTURE_TYPE_I;\n        if(ff_MPV_frame_start(s, s->avctx) < 0)\n            return -1;\n        ff_er_frame_start(s);\n        if (!r->tmp_b_block_base) {\n            int i;\n\n            r->tmp_b_block_base = av_malloc(s->linesize * 48);\n            for (i = 0; i < 2; i++)\n                r->tmp_b_block_y[i] = r->tmp_b_block_base + i * 16 * s->linesize;\n            for (i = 0; i < 4; i++)\n                r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize\n                                       + (i >> 1) * 8 * s->uvlinesize + (i & 1) * 16;\n        }\n        r->cur_pts = r->si.pts;\n        if(s->pict_type != AV_PICTURE_TYPE_B){\n            r->last_pts = r->next_pts;\n            r->next_pts = r->cur_pts;\n        }else{\n            int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts);\n            int dist0   = GET_PTS_DIFF(r->cur_pts,  r->last_pts);\n            int dist1   = GET_PTS_DIFF(r->next_pts, r->cur_pts);\n\n            if(!refdist){\n                r->weight1 = r->weight2 = 8192;\n            }else{\n                r->weight1 = (dist0 << 14) / refdist;\n                r->weight2 = (dist1 << 14) / refdist;\n            }\n        }\n        s->mb_x = s->mb_y = 0;\n        ff_thread_finish_setup(s->avctx);\n    } else {\n        int slice_type = r->si.type ? r->si.type : AV_PICTURE_TYPE_I;\n\n        if (slice_type != s->pict_type) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    r->si.end = end;\n    s->qscale = r->si.quant;\n    s->mb_num_left = r->si.end - r->si.start;\n    r->s.mb_skip_run = 0;\n\n    mb_pos = s->mb_x + s->mb_y * s->mb_width;\n    if(r->si.start != mb_pos){\n        av_log(s->avctx, AV_LOG_ERROR, \"Slice indicates MB offset %d, got %d\\n\", r->si.start, mb_pos);\n        s->mb_x = r->si.start % s->mb_width;\n        s->mb_y = r->si.start / s->mb_width;\n    }\n    memset(r->intra_types_hist, -1, r->intra_types_stride * 4 * 2 * sizeof(*r->intra_types_hist));\n    s->first_slice_line = 1;\n    s->resync_mb_x = s->mb_x;\n    s->resync_mb_y = s->mb_y;\n\n    ff_init_block_index(s);\n    while(!check_slice_end(r, s)) {\n        ff_update_block_index(s);\n\n        if(r->si.type)\n            res = rv34_decode_inter_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n        else\n            res = rv34_decode_intra_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n        if(res < 0){\n            ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_ERROR);\n            return -1;\n        }\n        if (++s->mb_x == s->mb_width) {\n            s->mb_x = 0;\n            s->mb_y++;\n            ff_init_block_index(s);\n\n            memmove(r->intra_types_hist, r->intra_types, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n            memset(r->intra_types, -1, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n\n            if(r->loop_filter && s->mb_y >= 2)\n                r->loop_filter(r, s->mb_y - 2);\n\n            if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n                ff_thread_report_progress(&s->current_picture_ptr->f,\n                                          s->mb_y - 2, 0);\n\n        }\n        if(s->mb_x == s->resync_mb_x)\n            s->first_slice_line=0;\n        s->mb_num_left--;\n    }\n    ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END);\n\n    return s->mb_y == s->mb_height;\n}", "target": 1}
{"idx": 5656, "func": "static void vp3_h_loop_filter_c(uint8_t *first_pixel, int stride,\n                                int *bounding_values)\n{\n    unsigned char *end;\n    int filter_value;\n\n    for (end= first_pixel + 8*stride; first_pixel != end; first_pixel += stride) {\n        filter_value =\n            (first_pixel[-2] - first_pixel[ 1])\n         +3*(first_pixel[ 0] - first_pixel[-1]);\n        filter_value = bounding_values[(filter_value + 4) >> 3];\n        first_pixel[-1] = av_clip_uint8(first_pixel[-1] + filter_value);\n        first_pixel[ 0] = av_clip_uint8(first_pixel[ 0] - filter_value);\n    }\n}", "target": 0}
{"idx": 5657, "func": "static int thread_init(AVCodecContext *avctx)\n{\n    int i;\n    ThreadContext *c;\n    int thread_count = avctx->thread_count;\n\n    if (thread_count <= 1)\n        return 0;\n\n    c = av_mallocz(sizeof(ThreadContext));\n    if (!c)\n        return -1;\n\n    c->workers = av_mallocz(sizeof(pthread_t)*thread_count);\n    if (!c->workers) {\n        av_free(c);\n        return -1;\n    }\n\n    avctx->thread_opaque = c;\n    c->current_job = 0;\n    c->job_count = 0;\n    c->job_size = 0;\n    c->done = 0;\n    pthread_cond_init(&c->current_job_cond, NULL);\n    pthread_cond_init(&c->last_job_cond, NULL);\n    pthread_mutex_init(&c->current_job_lock, NULL);\n    pthread_mutex_lock(&c->current_job_lock);\n    for (i=0; i<thread_count; i++) {\n        if(pthread_create(&c->workers[i], NULL, worker, avctx)) {\n           avctx->thread_count = i;\n           pthread_mutex_unlock(&c->current_job_lock);\n           ff_thread_free(avctx);\n           return -1;\n        }\n    }\n\n    avcodec_thread_park_workers(c, thread_count);\n\n    avctx->execute = avcodec_thread_execute;\n    avctx->execute2 = avcodec_thread_execute2;\n    return 0;\n}", "target": 1}
{"idx": 5658, "func": "static void tqi_calculate_qtable(TqiContext *t, int quant)\n{\n    const int64_t qscale = (215 - 2*quant)*5;\n    int i;\n\n    t->intra_matrix[0] = (ff_inv_aanscales[0] * ff_mpeg1_default_intra_matrix[0]) >> 11;\n    for(i=1; i<64; i++)\n        t->intra_matrix[i] = (ff_inv_aanscales[i] * ff_mpeg1_default_intra_matrix[i] * qscale + 32) >> 14;\n}", "target": 0}
{"idx": 5659, "func": "static int64_t mkv_write_seekhead(AVIOContext *pb, MatroskaMuxContext *mkv)\n{\n    mkv_seekhead *seekhead = mkv->main_seekhead;\n    ebml_master metaseek, seekentry;\n    int64_t currentpos;\n    int i;\n\n    currentpos = avio_tell(pb);\n\n    if (seekhead->reserved_size > 0) {\n        if (avio_seek(pb, seekhead->filepos, SEEK_SET) < 0) {\n            currentpos = -1;\n            goto fail;\n        }\n    }\n\n    metaseek = start_ebml_master(pb, MATROSKA_ID_SEEKHEAD, seekhead->reserved_size);\n    for (i = 0; i < seekhead->num_entries; i++) {\n        mkv_seekhead_entry *entry = &seekhead->entries[i];\n\n        seekentry = start_ebml_master(pb, MATROSKA_ID_SEEKENTRY, MAX_SEEKENTRY_SIZE);\n\n        put_ebml_id(pb, MATROSKA_ID_SEEKID);\n        put_ebml_num(pb, ebml_id_size(entry->elementid), 0);\n        put_ebml_id(pb, entry->elementid);\n\n        put_ebml_uint(pb, MATROSKA_ID_SEEKPOSITION, entry->segmentpos);\n        end_ebml_master(pb, seekentry);\n    }\n    end_ebml_master(pb, metaseek);\n\n    if (seekhead->reserved_size > 0) {\n        uint64_t remaining = seekhead->filepos + seekhead->reserved_size - avio_tell(pb);\n        put_ebml_void(pb, remaining);\n        avio_seek(pb, currentpos, SEEK_SET);\n\n        currentpos = seekhead->filepos;\n    }\nfail:\n    av_freep(&mkv->main_seekhead->entries);\n    av_freep(&mkv->main_seekhead);\n\n    return currentpos;\n}", "target": 0}
{"idx": 5660, "func": "static int alloc_frame_buffer(MpegEncContext *s, Picture *pic)\n{\n    int edges_needed = av_codec_is_encoder(s->avctx->codec);\n    int r, ret;\n\n    pic->tf.f = &pic->f;\n    if (s->codec_id != AV_CODEC_ID_WMV3IMAGE &&\n        s->codec_id != AV_CODEC_ID_VC1IMAGE  &&\n        s->codec_id != AV_CODEC_ID_MSS2) {\n        if (edges_needed) {\n            pic->f.width  = s->avctx->width  + 2 * EDGE_WIDTH;\n            pic->f.height = s->avctx->height + 2 * EDGE_WIDTH;\n        }\n\n        r = ff_thread_get_buffer(s->avctx, &pic->tf,\n                                 pic->reference ? AV_GET_BUFFER_FLAG_REF : 0);\n    } else {\n        pic->f.width  = s->avctx->width;\n        pic->f.height = s->avctx->height;\n        pic->f.format = s->avctx->pix_fmt;\n        r = avcodec_default_get_buffer2(s->avctx, &pic->f, 0);\n    }\n\n    if (r < 0 || !pic->f.buf[0]) {\n        av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (%d %p)\\n\",\n               r, pic->f.data[0]);\n        return -1;\n    }\n\n    if (edges_needed) {\n        int i;\n        for (i = 0; pic->f.data[i]; i++) {\n            int offset = (EDGE_WIDTH >> (i ? s->chroma_y_shift : 0)) *\n                         pic->f.linesize[i] +\n                         (EDGE_WIDTH >> (i ? s->chroma_x_shift : 0));\n            pic->f.data[i] += offset;\n        }\n        pic->f.width  = s->avctx->width;\n        pic->f.height = s->avctx->height;\n    }\n\n    if (s->avctx->hwaccel) {\n        assert(!pic->hwaccel_picture_private);\n        if (s->avctx->hwaccel->priv_data_size) {\n            pic->hwaccel_priv_buf = av_buffer_allocz(s->avctx->hwaccel->priv_data_size);\n            if (!pic->hwaccel_priv_buf) {\n                av_log(s->avctx, AV_LOG_ERROR, \"alloc_frame_buffer() failed (hwaccel private data allocation)\\n\");\n                return -1;\n            }\n            pic->hwaccel_picture_private = pic->hwaccel_priv_buf->data;\n        }\n    }\n\n    if (s->linesize && (s->linesize   != pic->f.linesize[0] ||\n                        s->uvlinesize != pic->f.linesize[1])) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"get_buffer() failed (stride changed)\\n\");\n        ff_mpeg_unref_picture(s, pic);\n        return -1;\n    }\n\n    if (pic->f.linesize[1] != pic->f.linesize[2]) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"get_buffer() failed (uv stride mismatch)\\n\");\n        ff_mpeg_unref_picture(s, pic);\n        return -1;\n    }\n\n    if (!s->edge_emu_buffer &&\n        (ret = frame_size_alloc(s, pic->f.linesize[0])) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"get_buffer() failed to allocate context scratch buffers.\\n\");\n        ff_mpeg_unref_picture(s, pic);\n        return ret;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5661, "func": "void ERR_print_errors_cb(int (*cb) (const char *str, size_t len, void *u),\n                         void *u)\n{\n    CRYPTO_THREAD_ID tid = CRYPTO_THREAD_get_current_id();\n    unsigned long l;\n    char buf[256];\n    char buf2[4096], *hex;\n    const char *file, *data;\n    int line, flags;\n\n    while ((l = ERR_get_error_line_data(&file, &line, &data, &flags)) != 0) {\n        ERR_error_string_n(l, buf, sizeof(buf));\n        hex = OPENSSL_buf2hexstr((const unsigned char *)&tid, sizeof(tid));\n        BIO_snprintf(buf2, sizeof(buf2), \"%s:%s:%s:%d:%s\\n\", hex, buf, file,\n                     line, (flags & ERR_TXT_STRING) ? data : \"\");\n        OPENSSL_free(hex);\n        if (cb(buf2, strlen(buf2), u) <= 0)\n            break;              /* abort outputting the error report */\n    }\n}", "target": 0}
{"idx": 5662, "func": "static inline int hpel_motion(MpegEncContext *s,\n                                  uint8_t *dest, uint8_t *src,\n                                  int field_based, int field_select,\n                                  int src_x, int src_y,\n                                  int width, int height, int stride,\n                                  int h_edge_pos, int v_edge_pos,\n                                  int w, int h, op_pixels_func *pix_op,\n                                  int motion_x, int motion_y)\n{\n    int dxy;\n    int emu=0;\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n    src_x += motion_x >> 1;\n    src_y += motion_y >> 1;\n\n    /* WARNING: do no forget half pels */\n    src_x = av_clip(src_x, -16, width); //FIXME unneeded for emu?\n    if (src_x == width)\n        dxy &= ~1;\n    src_y = av_clip(src_y, -16, height);\n    if (src_y == height)\n        dxy &= ~2;\n    src += src_y * stride + src_x;\n\n    if(s->unrestricted_mv && (s->flags&CODEC_FLAG_EMU_EDGE)){\n        if(   (unsigned)src_x > FFMAX(h_edge_pos - (motion_x&1) - w, 0)\n           || (unsigned)src_y > FFMAX(v_edge_pos - (motion_y&1) - h, 0)){\n            s->dsp.emulated_edge_mc(s->edge_emu_buffer, src, s->linesize, w+1, (h+1)<<field_based,\n                             src_x, src_y<<field_based, h_edge_pos, s->v_edge_pos);\n            src= s->edge_emu_buffer;\n            emu=1;\n        }\n    }\n    if(field_select)\n        src += s->linesize;\n    pix_op[dxy](dest, src, stride, h);\n    return emu;\n}", "target": 1}
{"idx": 5663, "func": "AVFilterBufferRef *ff_default_get_video_buffer(AVFilterLink *link, int perms, int w, int h)\n{\n    int linesize[4];\n    uint8_t *data[4];\n    int i;\n    AVFilterBufferRef *picref = NULL;\n    AVFilterPool *pool = link->pool;\n    int full_perms = AV_PERM_READ | AV_PERM_WRITE | AV_PERM_PRESERVE |\n                     AV_PERM_REUSE | AV_PERM_REUSE2 | AV_PERM_ALIGN;\n\n    av_assert1(!(perms & ~(full_perms | AV_PERM_NEG_LINESIZES)));\n\n    if (pool) {\n        for (i = 0; i < POOL_SIZE; i++) {\n            picref = pool->pic[i];\n            if (picref && picref->buf->format == link->format && picref->buf->w == w && picref->buf->h == h) {\n                AVFilterBuffer *pic = picref->buf;\n                pool->pic[i] = NULL;\n                pool->count--;\n                av_assert0(!picref->video->qp_table);\n                picref->video->w = w;\n                picref->video->h = h;\n                picref->perms = full_perms;\n                picref->format = link->format;\n                pic->refcount = 1;\n                memcpy(picref->data,     pic->data,     sizeof(picref->data));\n                memcpy(picref->linesize, pic->linesize, sizeof(picref->linesize));\n                pool->refcount++;\n                return picref;\n            }\n        }\n    } else {\n        pool = link->pool = av_mallocz(sizeof(AVFilterPool));\n        pool->refcount = 1;\n    }\n\n    // align: +2 is needed for swscaler, +16 to be SIMD-friendly\n    if ((i = av_image_alloc(data, linesize, w, h, link->format, 32)) < 0)\n        return NULL;\n\n    picref = avfilter_get_video_buffer_ref_from_arrays(data, linesize,\n                                                       full_perms, w, h, link->format);\n    if (!picref) {\n        av_free(data[0]);\n        return NULL;\n    }\n\n    memset(data[0], 128, i);\n\n    picref->buf->priv = pool;\n    picref->buf->free = NULL;\n    pool->refcount++;\n\n    return picref;\n}", "target": 1}
{"idx": 5664, "func": "int avfilter_graph_queue_command(AVFilterGraph *graph, const char *target, const char *command, const char *arg, int flags, double ts)\n{\n    int i;\n\n    if(!graph)\n        return 0;\n\n    for (i = 0; i < graph->nb_filters; i++) {\n        AVFilterContext *filter = graph->filters[i];\n        if(filter && (!strcmp(target, \"all\") || !strcmp(target, filter->name) || !strcmp(target, filter->filter->name))){\n            AVFilterCommand **queue = &filter->command_queue, *next;\n            while (*queue && (*queue)->time <= ts)\n                queue = &(*queue)->next;\n            next = *queue;\n            *queue = av_mallocz(sizeof(AVFilterCommand));\n            if (!*queue)\n                return AVERROR(ENOMEM);\n\n            (*queue)->command = av_strdup(command);\n            (*queue)->arg     = av_strdup(arg);\n            (*queue)->time    = ts;\n            (*queue)->flags   = flags;\n            (*queue)->next    = next;\n            if(flags & AVFILTER_CMD_FLAG_ONE)\n                return 0;\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5665, "func": "static int vp8_decode_mb_row_sliced(AVCodecContext *avctx, void *tdata,\n                                    int jobnr, int threadnr)\n{\n    VP8Context *s = avctx->priv_data;\n    VP8ThreadData *td = &s->thread_data[jobnr];\n    VP8ThreadData *next_td = NULL, *prev_td = NULL;\n    VP8Frame *curframe = s->curframe;\n    int mb_y, num_jobs = s->num_jobs;\n\n    td->thread_nr = threadnr;\n    for (mb_y = jobnr; mb_y < s->mb_height; mb_y += num_jobs) {\n        if (mb_y >= s->mb_height)\n            break;\n        td->thread_mb_pos = mb_y << 16;\n        vp8_decode_mb_row_no_filter(avctx, tdata, jobnr, threadnr);\n        if (s->deblock_filter)\n            vp8_filter_mb_row(avctx, tdata, jobnr, threadnr);\n        update_pos(td, mb_y, INT_MAX & 0xFFFF);\n\n        s->mv_min.y -= 64;\n        s->mv_max.y -= 64;\n\n        if (avctx->active_thread_type == FF_THREAD_FRAME)\n            ff_thread_report_progress(&curframe->tf, mb_y, 0);\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5666, "func": "int BN_div_recp(BIGNUM *dv, BIGNUM *rem, BIGNUM *m, BN_RECP_CTX *recp,\n\t     BN_CTX *ctx)\n\t{\n\tint i,j,ret=0,ex;\n\tBIGNUM *a,*b,*d,*r;\n\n\tBN_CTX_start(ctx);\n\ta=BN_CTX_get(ctx);\n\tb=BN_CTX_get(ctx);\n\tif (dv != NULL)\n\t\td=dv;\n\telse\n\t\td=BN_CTX_get(ctx);\n\tif (rem != NULL)\n\t\tr=rem;\n\telse\n\t\tr=BN_CTX_get(ctx);\n\tif (a == NULL || b == NULL || d == NULL || r == NULL) goto err;\n\n\tif (BN_ucmp(m,&(recp->N)) < 0)\n\t\t{\n\t\tBN_zero(d);\n\t\tBN_copy(r,m);\n\t\tBN_CTX_end(ctx);\n\t\treturn(1);\n\t\t}\n\n\t/* We want the remainder\n\t * Given input of ABCDEF / ab\n\t * we need multiply ABCDEF by 3 digests of the reciprocal of ab\n\t *\n\t */\n\ti=BN_num_bits(m);\n\tif (i%2) i--;\n\n\tj=recp->num_bits*2;\n\tif (j > i)\n\t\t{\n\t\ti=j;\n\t\tex=0;\n\t\t}\n\telse\n\t\t{\n\t\tex=(i-j)/2;\n\t\t}\n\n\tj=i/2;\n\n\tif (i != recp->shift)\n\t\trecp->shift=BN_reciprocal(&(recp->Nr),&(recp->N),\n\t\t\ti,ctx);\n\n\tif (!BN_rshift(a,m,j-ex)) goto err;\n\tif (!BN_mul(b,a,&(recp->Nr),ctx)) goto err;\n\tif (!BN_rshift(d,b,j+ex)) goto err;\n\td->neg=0;\n\tif (!BN_mul(b,&(recp->N),d,ctx)) goto err;\n\tif (!BN_usub(r,m,b)) goto err;\n\tr->neg=0;\n\n\tj=0;\n#if 1\n\twhile (BN_ucmp(r,&(recp->N)) >= 0)\n\t\t{\n\t\tif (j++ > 2)\n\t\t\t{\n#if 1\n\t\t\t/* work around some bug:\n\t\t\t   -1CC0E177F93042B29D309839F8019DB93404D7A395F1E162\n\t\t\t   5383BF622A20B17E1BAA999336988B82B93F5FB77B55B4B68\n\t\t\t   9412000000000031 / 298EB5957DBFB8CBB2CC2A9F789D2B5\n\t\t\t   fails, for example. */\n\t\t\tret=BN_div(dv,rem,m,&(recp->N),ctx);\n#else\n\t\t\tBNerr(BN_F_BN_MOD_MUL_RECIPROCAL,BN_R_BAD_RECIPROCAL);\n#endif\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!BN_usub(r,r,&(recp->N))) goto err;\n\t\tif (!BN_add_word(d,1)) goto err;\n\t\t}\n#endif\n\n\tr->neg=BN_is_zero(r)?0:m->neg;\n\td->neg=m->neg^recp->N.neg;\n\tret=1;\nerr:\n\tBN_CTX_end(ctx);\n\treturn(ret);\n\t}", "target": 0}
{"idx": 5667, "func": "static void av_always_inline filter_mb_edgev( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h, int intra ) {\n    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;\n    const int alpha = alpha_table[index_a];\n    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];\n    if (alpha ==0 || beta == 0) return;\n\n    if( bS[0] < 4 || !intra ) {\n        int8_t tc[4];\n        tc[0] = tc0_table[index_a][bS[0]];\n        tc[1] = tc0_table[index_a][bS[1]];\n        tc[2] = tc0_table[index_a][bS[2]];\n        tc[3] = tc0_table[index_a][bS[3]];\n        h->h264dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);\n    } else {\n        h->h264dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);\n    }\n}", "target": 1}
{"idx": 5668, "func": "static int decode_rle(AVCodecContext *avctx, AVSubtitleRect *rect,\n                      const uint8_t *buf, unsigned int buf_size)\n{\n    const uint8_t *rle_bitmap_end;\n    int pixel_count, line_count;\n\n    rle_bitmap_end = buf + buf_size;\n\n    rect->pict.data[0] = av_malloc(rect->w * rect->h);\n\n    if (!rect->pict.data[0])\n        return AVERROR(ENOMEM);\n\n    pixel_count = 0;\n    line_count  = 0;\n\n    while (buf < rle_bitmap_end && line_count < rect->h) {\n        uint8_t flags, color;\n        int run;\n\n        color = bytestream_get_byte(&buf);\n        run   = 1;\n\n        if (color == 0x00) {\n            flags = bytestream_get_byte(&buf);\n            run   = flags & 0x3f;\n            if (flags & 0x40)\n                run = (run << 8) + bytestream_get_byte(&buf);\n            color = flags & 0x80 ? bytestream_get_byte(&buf) : 0;\n        }\n\n        if (run > 0 && pixel_count + run <= rect->w * rect->h) {\n            memset(rect->pict.data[0] + pixel_count, color, run);\n            pixel_count += run;\n        } else if (!run) {\n            /*\n             * New Line. Check if correct pixels decoded, if not display warning\n             * and adjust bitmap pointer to correct new line position.\n             */\n            if (pixel_count % rect->w > 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Decoded %d pixels, when line should be %d pixels\\n\",\n                       pixel_count % rect->w, rect->w);\n                if (avctx->err_recognition & AV_EF_EXPLODE) {\n                    return AVERROR_INVALIDDATA;\n                }\n            }\n            line_count++;\n        }\n    }\n\n    if (pixel_count < rect->w * rect->h) {\n        av_log(avctx, AV_LOG_ERROR, \"Insufficient RLE data for subtitle\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    av_dlog(avctx, \"Pixel Count = %d, Area = %d\\n\", pixel_count, rect->w * rect->h);\n\n    return 0;\n}", "target": 0}
{"idx": 5669, "func": "static void vp8_release_frame(VP8Context *s, AVFrame *f, int is_close)\n{\n    if (!is_close) {\n        if (f->ref_index[0]) {\n            assert(s->num_maps_to_be_freed < FF_ARRAY_ELEMS(s->segmentation_maps));\n            s->segmentation_maps[s->num_maps_to_be_freed++] = f->ref_index[0];\n            f->ref_index[0] = NULL;\n        }\n    } else {\n        av_freep(&f->ref_index[0]);\n    }\n    ff_thread_release_buffer(s->avctx, f);\n}", "target": 1}
{"idx": 5670, "func": "static int color_distance(uint32_t a, uint32_t b)\n{\n    int r = 0, d, i;\n    int alpha_a = 8, alpha_b = 8;\n\n    for (i = 24; i >= 0; i -= 8) {\n        d = alpha_a * (int)((a >> i) & 0xFF) -\n            alpha_b * (int)((b >> i) & 0xFF);\n        r += d * d;\n        alpha_a = a >> 28;\n        alpha_b = b >> 28;\n    }\n    return r;\n}", "target": 0}
{"idx": 5671, "func": "static int test_WPACKET_allocate_bytes(void)\n{\n    WPACKET pkt;\n    size_t written;\n    unsigned char *bytes;\n\n    if (!WPACKET_init_len(&pkt, buf, 1)\n            || !WPACKET_allocate_bytes(&pkt, 2, &bytes)) {\n        testfail(\"test_WPACKET_allocate_bytes():1 failed\\n\", &pkt);\n        return 0;\n    }\n    bytes[0] = 0xfe;\n    bytes[1] = 0xff;\n    if (!WPACKET_finish(&pkt)\n            || !WPACKET_get_total_written(&pkt, &written)\n            ||  written != sizeof(alloc)\n            ||  memcmp(buf->data, &alloc, written) != 0) {\n        testfail(\"test_WPACKET_allocate_bytes():2 failed\\n\", &pkt);\n        return 0;\n    }\n\n    /* Repeat with WPACKET_sub_allocate_bytes */\n    if (!WPACKET_init_len(&pkt, buf, 1)\n            || !WPACKET_sub_allocate_bytes_u8(&pkt, 2, &bytes)) {\n        testfail(\"test_WPACKET_allocate_bytes():3 failed\\n\", &pkt);\n        return 0;\n    }\n    bytes[0] = 0xfe;\n    bytes[1] = 0xff;\n    if (!WPACKET_finish(&pkt)\n            || !WPACKET_get_total_written(&pkt, &written)\n            ||  written != sizeof(submem)\n            ||  memcmp(buf->data, &submem, written) != 0) {\n        testfail(\"test_WPACKET_allocate_bytes():4 failed\\n\", &pkt);\n        return 0;\n    }\n\n    return 1;\n}", "target": 1}
{"idx": 5672, "func": "int ssl3_send_finished(SSL *s, int a, int b, const char *sender, int slen)\n\t{\n\tunsigned char *p;\n\tint i;\n\tunsigned long l;\n\n\tif (s->state == a)\n\t\t{\n\t\tp = ssl_handshake_start(s);\n\n\t\ti=s->method->ssl3_enc->final_finish_mac(s,\n\t\t\tsender,slen,s->s3->tmp.finish_md);\n\t\ts->s3->tmp.finish_md_len = i;\n\t\tmemcpy(p, s->s3->tmp.finish_md, i);\n\t\tl=i;\n\n                /* Copy the finished so we can use it for\n                   renegotiation checks */\n                if(s->type == SSL_ST_CONNECT)\n                        {\n                         OPENSSL_assert(i <= EVP_MAX_MD_SIZE);\n                         memcpy(s->s3->previous_client_finished, \n                             s->s3->tmp.finish_md, i);\n                         s->s3->previous_client_finished_len=i;\n                        }\n                else\n                        {\n                        OPENSSL_assert(i <= EVP_MAX_MD_SIZE);\n                        memcpy(s->s3->previous_server_finished, \n                            s->s3->tmp.finish_md, i);\n                        s->s3->previous_server_finished_len=i;\n                        }\n\n#ifdef OPENSSL_SYS_WIN16\n\t\t/* MSVC 1.5 does not clear the top bytes of the word unless\n\t\t * I do this.\n\t\t */\n\t\tl&=0xffff;\n#endif\n\t\tssl_set_handshake_header(s, SSL3_MT_FINISHED, l);\n\t\ts->state=b;\n\t\t}\n\n\t/* SSL3_ST_SEND_xxxxxx_HELLO_B */\n\treturn ssl_do_write(s);\n\t}", "target": 1}
{"idx": 5673, "func": "static av_always_inline void hl_decode_mb_predict_luma(H264Context *h, int mb_type, int is_h264, int simple, int transform_bypass,\n                                                       int pixel_shift, int *block_offset, int linesize, uint8_t *dest_y, int p)\n{\n    MpegEncContext * const s = &h->s;\n    void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride);\n    void (*idct_dc_add)(uint8_t *dst, DCTELEM *block, int stride);\n    int i;\n    int qscale = p == 0 ? s->qscale : h->chroma_qp[p-1];\n    block_offset += 16*p;\n    if(IS_INTRA4x4(mb_type)){\n        if(simple || !s->encoding){\n            if(IS_8x8DCT(mb_type)){\n                if(transform_bypass){\n                    idct_dc_add =\n                    idct_add    = s->dsp.add_pixels8;\n                }else{\n                    idct_dc_add = h->h264dsp.h264_idct8_dc_add;\n                    idct_add    = h->h264dsp.h264_idct8_add;\n                }\n                for(i=0; i<16; i+=4){\n                    uint8_t * const ptr= dest_y + block_offset[i];\n                    const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];\n                    if(transform_bypass && h->sps.profile_idc==244 && dir<=1){\n                        h->hpc.pred8x8l_add[dir](ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);\n                    }else{\n                        const int nnz = h->non_zero_count_cache[ scan8[i+p*16] ];\n                        h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000,\n                                                    (h->topright_samples_available<<i)&0x4000, linesize);\n                        if(nnz){\n                            if(nnz == 1 && dctcoef_get(h->mb, pixel_shift, i*16+p*256))\n                                idct_dc_add(ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);\n                            else\n                                idct_add   (ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);\n                        }\n                    }\n                }\n            }else{\n                if(transform_bypass){\n                    idct_dc_add =\n                    idct_add    = s->dsp.add_pixels4;\n                }else{\n                    idct_dc_add = h->h264dsp.h264_idct_dc_add;\n                    idct_add    = h->h264dsp.h264_idct_add;\n                }\n                for(i=0; i<16; i++){\n                    uint8_t * const ptr= dest_y + block_offset[i];\n                    const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];\n\n                    if(transform_bypass && h->sps.profile_idc==244 && dir<=1){\n                        h->hpc.pred4x4_add[dir](ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);\n                    }else{\n                        uint8_t *topright;\n                        int nnz, tr;\n                        uint64_t tr_high;\n                        if(dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED){\n                            const int topright_avail= (h->topright_samples_available<<i)&0x8000;\n                            assert(s->mb_y || linesize <= block_offset[i]);\n                            if(!topright_avail){\n                                if (pixel_shift) {\n                                    tr_high= ((uint16_t*)ptr)[3 - linesize/2]*0x0001000100010001ULL;\n                                    topright= (uint8_t*) &tr_high;\n                                } else {\n                                    tr= ptr[3 - linesize]*0x01010101u;\n                                    topright= (uint8_t*) &tr;\n                                }\n                            }else\n                                topright= ptr + (4 << pixel_shift) - linesize;\n                        }else\n                            topright= NULL;\n\n                        h->hpc.pred4x4[ dir ](ptr, topright, linesize);\n                        nnz = h->non_zero_count_cache[ scan8[i+p*16] ];\n                        if(nnz){\n                            if(is_h264){\n                                if(nnz == 1 && dctcoef_get(h->mb, pixel_shift, i*16+p*256))\n                                    idct_dc_add(ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);\n                                else\n                                    idct_add   (ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);\n                            }else\n                                ff_svq3_add_idct_c(ptr, h->mb + i*16+p*256, linesize, qscale, 0);\n                        }\n                    }\n                }\n            }\n        }\n    }else{\n        h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize);\n        if(is_h264){\n            if(h->non_zero_count_cache[ scan8[LUMA_DC_BLOCK_INDEX+p] ]){\n                if(!transform_bypass)\n                    h->h264dsp.h264_luma_dc_dequant_idct(h->mb+(p*256 << pixel_shift), h->mb_luma_dc[p], h->dequant4_coeff[p][qscale][0]);\n                else{\n                    static const uint8_t dc_mapping[16] = { 0*16, 1*16, 4*16, 5*16, 2*16, 3*16, 6*16, 7*16,\n                                                            8*16, 9*16,12*16,13*16,10*16,11*16,14*16,15*16};\n                    for(i = 0; i < 16; i++)\n                        dctcoef_set(h->mb+p*256, pixel_shift, dc_mapping[i], dctcoef_get(h->mb_luma_dc[p], pixel_shift, i));\n                }\n            }\n        }else\n            ff_svq3_luma_dc_dequant_idct_c(h->mb+p*256, h->mb_luma_dc[p], qscale);\n    }\n}", "target": 0}
{"idx": 5674, "func": "static int asink_query_formats(AVFilterContext *ctx)\n{\n    BufferSinkContext *buf = ctx->priv;\n    AVFilterFormats *formats = NULL;\n    AVFilterChannelLayouts *layouts = NULL;\n    unsigned i;\n    int ret;\n\n    if (buf->sample_fmts_size     % sizeof(*buf->sample_fmts)     ||\n        buf->sample_rates_size    % sizeof(*buf->sample_rates)    ||\n        buf->channel_layouts_size % sizeof(*buf->channel_layouts) ||\n        buf->channel_counts_size  % sizeof(*buf->channel_counts)) {\n        av_log(ctx, AV_LOG_ERROR, \"Invalid size for format lists\\n\");\n#define LOG_ERROR(field) \\\n        if (buf->field ## _size % sizeof(*buf->field)) \\\n            av_log(ctx, AV_LOG_ERROR, \"  \" #field \" is %d, should be \" \\\n                   \"multiple of %d\\n\", \\\n                   buf->field ## _size, (int)sizeof(*buf->field));\n        LOG_ERROR(sample_fmts);\n        LOG_ERROR(sample_rates);\n        LOG_ERROR(channel_layouts);\n        LOG_ERROR(channel_counts);\n#undef LOG_ERROR\n        return AVERROR(EINVAL);\n    }\n\n    if (buf->sample_fmts_size) {\n        for (i = 0; i < NB_ITEMS(buf->sample_fmts); i++)\n            if ((ret = ff_add_format(&formats, buf->sample_fmts[i])) < 0)\n                return ret;\n        ff_set_common_formats(ctx, formats);\n    }\n\n    if (buf->channel_layouts_size || buf->channel_counts_size ||\n        buf->all_channel_counts) {\n        for (i = 0; i < NB_ITEMS(buf->channel_layouts); i++)\n            if ((ret = ff_add_channel_layout(&layouts, buf->channel_layouts[i])) < 0)\n                return ret;\n        for (i = 0; i < NB_ITEMS(buf->channel_counts); i++)\n            if ((ret = ff_add_channel_layout(&layouts, FF_COUNT2LAYOUT(buf->channel_counts[i]))) < 0)\n                return ret;\n        if (buf->all_channel_counts) {\n            if (layouts)\n                av_log(ctx, AV_LOG_WARNING,\n                       \"Conflicting all_channel_counts and list in options\\n\");\n            else if (!(layouts = ff_all_channel_counts()))\n                return AVERROR(ENOMEM);\n        }\n        ff_set_common_channel_layouts(ctx, layouts);\n    }\n\n    if (buf->sample_rates_size) {\n        formats = NULL;\n        for (i = 0; i < NB_ITEMS(buf->sample_rates); i++)\n            if ((ret = ff_add_format(&formats, buf->sample_rates[i])) < 0)\n                return ret;\n        ff_set_common_samplerates(ctx, formats);\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5675, "func": "int UI_set_result(UI *ui, UI_STRING *uis, const char *result)\n{\n    int l = strlen(result);\n\n    ui->flags &= ~UI_FLAG_REDOABLE;\n\n    switch (uis->type) {\n    case UIT_PROMPT:\n    case UIT_VERIFY:\n        {\n            char number1[DECIMAL_SIZE(uis->_.string_data.result_minsize) + 1];\n            char number2[DECIMAL_SIZE(uis->_.string_data.result_maxsize) + 1];\n\n            BIO_snprintf(number1, sizeof(number1), \"%d\",\n                         uis->_.string_data.result_minsize);\n            BIO_snprintf(number2, sizeof(number2), \"%d\",\n                         uis->_.string_data.result_maxsize);\n\n            if (l < uis->_.string_data.result_minsize) {\n                ui->flags |= UI_FLAG_REDOABLE;\n                UIerr(UI_F_UI_SET_RESULT, UI_R_RESULT_TOO_SMALL);\n                ERR_add_error_data(5, \"You must type in \",\n                                   number1, \" to \", number2, \" characters\");\n                return -1;\n            }\n            if (l > uis->_.string_data.result_maxsize) {\n                ui->flags |= UI_FLAG_REDOABLE;\n                UIerr(UI_F_UI_SET_RESULT, UI_R_RESULT_TOO_LARGE);\n                ERR_add_error_data(5, \"You must type in \",\n                                   number1, \" to \", number2, \" characters\");\n                return -1;\n            }\n        }\n\n        if (uis->result_buf == NULL) {\n            UIerr(UI_F_UI_SET_RESULT, UI_R_NO_RESULT_BUFFER);\n            return -1;\n        }\n\n        OPENSSL_strlcpy(uis->result_buf, result,\n                    uis->_.string_data.result_maxsize + 1);\n        break;\n    case UIT_BOOLEAN:\n        {\n            const char *p;\n\n            if (uis->result_buf == NULL) {\n                UIerr(UI_F_UI_SET_RESULT, UI_R_NO_RESULT_BUFFER);\n                return -1;\n            }\n\n            uis->result_buf[0] = '\\0';\n            for (p = result; *p; p++) {\n                if (strchr(uis->_.boolean_data.ok_chars, *p)) {\n                    uis->result_buf[0] = uis->_.boolean_data.ok_chars[0];\n                    break;\n                }\n                if (strchr(uis->_.boolean_data.cancel_chars, *p)) {\n                    uis->result_buf[0] = uis->_.boolean_data.cancel_chars[0];\n                    break;\n                }\n            }\n        }\n    case UIT_NONE:\n    case UIT_INFO:\n    case UIT_ERROR:\n        break;\n    }\n    return 0;\n}", "target": 1}
{"idx": 5676, "func": "static void do_video_out(AVFormatContext *s,\n                         OutputStream *ost,\n                         AVFrame *in_picture,\n                         float quality)\n{\n    int ret, format_video_sync;\n    AVPacket pkt;\n    AVCodecContext *enc = ost->st->codec;\n    int nb_frames;\n    double sync_ipts, delta;\n    double duration = 0;\n    int frame_size = 0;\n    InputStream *ist = NULL;\n\n    if (ost->source_index >= 0)\n        ist = input_streams[ost->source_index];\n\n    if(ist && ist->st->start_time != AV_NOPTS_VALUE && ist->st->first_dts != AV_NOPTS_VALUE && ost->frame_rate.num)\n        duration = 1/(av_q2d(ost->frame_rate) * av_q2d(enc->time_base));\n\n    sync_ipts = in_picture->pts;\n    delta = sync_ipts - ost->sync_opts + duration;\n\n    /* by default, we output a single frame */\n    nb_frames = 1;\n\n    format_video_sync = video_sync_method;\n    if (format_video_sync == VSYNC_AUTO)\n        format_video_sync = (s->oformat->flags & AVFMT_VARIABLE_FPS) ? ((s->oformat->flags & AVFMT_NOTIMESTAMPS) ? VSYNC_PASSTHROUGH : VSYNC_VFR) : 1;\n\n    switch (format_video_sync) {\n    case VSYNC_CFR:\n        // FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c\n        if (delta < -1.1)\n            nb_frames = 0;\n        else if (delta > 1.1)\n            nb_frames = lrintf(delta);\n        break;\n    case VSYNC_VFR:\n        if (delta <= -0.6)\n            nb_frames = 0;\n        else if (delta > 0.6)\n            ost->sync_opts = lrint(sync_ipts);\n        break;\n    case VSYNC_DROP:\n    case VSYNC_PASSTHROUGH:\n        ost->sync_opts = lrint(sync_ipts);\n        break;\n    default:\n        av_assert0(0);\n    }\n\n    nb_frames = FFMIN(nb_frames, ost->max_frames - ost->frame_number);\n    if (nb_frames == 0) {\n        nb_frames_drop++;\n        av_log(NULL, AV_LOG_VERBOSE, \"*** drop!\\n\");\n        return;\n    } else if (nb_frames > 1) {\n        if (nb_frames > dts_error_threshold * 30) {\n            av_log(NULL, AV_LOG_ERROR, \"%d frame duplication too large, skiping\\n\", nb_frames - 1);\n            nb_frames_drop++;\n            return;\n        }\n        nb_frames_dup += nb_frames - 1;\n        av_log(NULL, AV_LOG_VERBOSE, \"*** %d dup!\\n\", nb_frames - 1);\n    }\n\n\nduplicate_frame:\n    av_init_packet(&pkt);\n    pkt.data = NULL;\n    pkt.size = 0;\n\n    in_picture->pts = ost->sync_opts;\n\n    if (!check_recording_time(ost))\n        return;\n\n    if (s->oformat->flags & AVFMT_RAWPICTURE &&\n        enc->codec->id == CODEC_ID_RAWVIDEO) {\n        /* raw pictures are written as AVPicture structure to\n           avoid any copies. We support temporarily the older\n           method. */\n        enc->coded_frame->interlaced_frame = in_picture->interlaced_frame;\n        enc->coded_frame->top_field_first  = in_picture->top_field_first;\n        pkt.data   = (uint8_t *)in_picture;\n        pkt.size   =  sizeof(AVPicture);\n        pkt.pts    = av_rescale_q(in_picture->pts, enc->time_base, ost->st->time_base);\n        pkt.flags |= AV_PKT_FLAG_KEY;\n\n        write_frame(s, &pkt, ost);\n        video_size += pkt.size;\n    } else {\n        int got_packet;\n        AVFrame big_picture;\n\n        big_picture = *in_picture;\n        /* better than nothing: use input picture interlaced\n           settings */\n        big_picture.interlaced_frame = in_picture->interlaced_frame;\n        if (ost->st->codec->flags & (CODEC_FLAG_INTERLACED_DCT|CODEC_FLAG_INTERLACED_ME)) {\n            if (ost->top_field_first == -1)\n                big_picture.top_field_first = in_picture->top_field_first;\n            else\n                big_picture.top_field_first = !!ost->top_field_first;\n        }\n\n        /* handles same_quant here. This is not correct because it may\n           not be a global option */\n        big_picture.quality = quality;\n        if (!enc->me_threshold)\n            big_picture.pict_type = 0;\n        if (ost->forced_kf_index < ost->forced_kf_count &&\n            big_picture.pts >= ost->forced_kf_pts[ost->forced_kf_index]) {\n            big_picture.pict_type = AV_PICTURE_TYPE_I;\n            ost->forced_kf_index++;\n        }\n        update_benchmark(NULL);\n        ret = avcodec_encode_video2(enc, &pkt, &big_picture, &got_packet);\n        update_benchmark(\"encode_video %d.%d\", ost->file_index, ost->index);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_FATAL, \"Video encoding failed\\n\");\n            exit_program(1);\n        }\n\n        if (got_packet) {\n            if (pkt.pts == AV_NOPTS_VALUE && !(enc->codec->capabilities & CODEC_CAP_DELAY))\n                pkt.pts = ost->sync_opts;\n\n            if (pkt.pts != AV_NOPTS_VALUE)\n                pkt.pts = av_rescale_q(pkt.pts, enc->time_base, ost->st->time_base);\n            if (pkt.dts != AV_NOPTS_VALUE)\n                pkt.dts = av_rescale_q(pkt.dts, enc->time_base, ost->st->time_base);\n\n            if (debug_ts) {\n                av_log(NULL, AV_LOG_INFO, \"encoder -> type:video \"\n                    \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",\n                    av_ts2str(pkt.pts), av_ts2timestr(pkt.pts, &ost->st->time_base),\n                    av_ts2str(pkt.dts), av_ts2timestr(pkt.dts, &ost->st->time_base));\n            }\n\n            write_frame(s, &pkt, ost);\n            frame_size = pkt.size;\n            video_size += pkt.size;\n            av_free_packet(&pkt);\n\n            /* if two pass, output log */\n            if (ost->logfile && enc->stats_out) {\n                fprintf(ost->logfile, \"%s\", enc->stats_out);\n            }\n        }\n    }\n    ost->sync_opts++;\n    /*\n     * For video, number of frames in == number of packets out.\n     * But there may be reordering, so we can't throw away frames on encoder\n     * flush, we need to limit them here, before they go into encoder.\n     */\n    ost->frame_number++;\n\n    if(--nb_frames)\n        goto duplicate_frame;\n\n    if (vstats_filename && frame_size)\n        do_video_stats(output_files[ost->file_index]->ctx, ost, frame_size);\n}", "target": 1}
{"idx": 5677, "func": "static int mem_gets(BIO *bp, char *buf, int size)\n{\n    int i, j;\n    int ret = -1;\n    char *p;\n    BIO_BUF_MEM *bbm = (BIO_BUF_MEM *)bp->ptr;\n    BUF_MEM *bm = bbm->readp;\n\n    BIO_clear_retry_flags(bp);\n    j = bm->length;\n    if ((size - 1) < j)\n        j = size - 1;\n    if (j <= 0) {\n        *buf = '\\0';\n        return 0;\n    }\n    p = bm->data;\n    for (i = 0; i < j; i++) {\n        if (p[i] == '\\n') {\n            i++;\n            break;\n        }\n    }\n\n    /*\n     * i is now the max num of bytes to copy, either j or up to\n     * and including the first newline\n     */\n\n    i = mem_read(bp, buf, i);\n    if (i > 0)\n        buf[i] = '\\0';\n    ret = i;\n    return (ret);\n}", "target": 0}
{"idx": 5678, "func": "void lh_free(LHASH *lh)\n\t{\n\tunsigned int i;\n\tLHASH_NODE *n,*nn;\n\n\tif (lh == NULL)\n\t    return;\n\n\tfor (i=0; i<lh->num_nodes; i++)\n\t\t{\n\t\tn=lh->b[i];\n\t\twhile (n != NULL)\n\t\t\t{\n\t\t\tnn=n->next;\n\t\t\tFree(n);\n\t\t\tn=nn;\n\t\t\t}\n\t\t}\n\tFree(lh->b);\n\tFree(lh);\n\t}", "target": 1}
{"idx": 5679, "func": "static int set_expr(AVExpr **pexpr, const char *expr, void *log_ctx)\n{\n    int ret;\n    AVExpr *old = NULL;\n\n    if (*pexpr)\n        old = *pexpr;\n    ret = av_expr_parse(pexpr, expr, var_names,\n                        NULL, NULL, NULL, NULL, 0, log_ctx);\n    if (ret < 0) {\n        av_log(log_ctx, AV_LOG_ERROR,\n               \"Error when evaluating the expression '%s'\\n\", expr);\n        *pexpr = old;\n        return ret;\n    }\n\n    av_expr_free(old);\n    return 0;\n}", "target": 0}
{"idx": 5680, "func": "static ASN1_INTEGER *x509_load_serial(char *CAfile, char *serialfile, int create)\n\t{\n\tchar *buf = NULL, *p;\n\tASN1_INTEGER *bs = NULL;\n\tBIGNUM *serial = NULL;\n\tsize_t len;\n\n\tlen = ((serialfile == NULL)\n\t\t?(strlen(CAfile)+strlen(POSTFIX)+1)\n\t\t:(strlen(serialfile)))+1;\n\tbuf=OPENSSL_malloc(len);\n\tif (buf == NULL) { BIO_printf(bio_err,\"out of mem\\n\"); goto end; }\n\tif (serialfile == NULL)\n\t\t{\n\t\tBUF_strlcpy(buf,CAfile,len);\n\t\tfor (p=buf; *p; p++)\n\t\t\tif (*p == '.')\n\t\t\t\t{\n\t\t\t\t*p='\\0';\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\tBUF_strlcat(buf,POSTFIX,len);\n\t\t}\n\telse\n\t\tBUF_strlcpy(buf,serialfile,len);\n\n\tserial = load_serial(buf, create, NULL);\n\tif (serial == NULL) goto end;\n\n\tif (!BN_add_word(serial,1))\n\t\t{ BIO_printf(bio_err,\"add_word failure\\n\"); goto end; }\n\n\tif (!save_serial(buf, NULL, serial, &bs)) goto end;\n\n end:\n\tif (buf) OPENSSL_free(buf);\n\tBN_free(serial);\n\treturn bs;\n\t}", "target": 0}
{"idx": 5681, "func": "static int idp_check_scope(X509 *x, X509_CRL *crl, int *pimatch)\n\t{\n\tint i;\n\tif (crl->idp_flags & IDP_ONLYATTR)\n\t\treturn 0;\n\tif (x->ex_flags & EXFLAG_CA)\n\t\t{\n\t\tif (crl->idp_flags & IDP_ONLYUSER)\n\t\t\treturn 0;\n\t\t}\n\telse\n\t\t{\n\t\tif (crl->idp_flags & IDP_ONLYCA)\n\t\t\treturn 0;\n\t\t}\n\tif (!crl->idp->distpoint && *pimatch)\n\t\treturn 1;\n\tfor (i = 0; i < sk_DIST_POINT_num(x->crldp); i++)\n\t\t{\n\t\tDIST_POINT *dp = sk_DIST_POINT_value(x->crldp, i);\n\t\t/* We don't handle these at present */\n\t\tif (dp->reasons)\n\t\t\tcontinue;\n\t\tif (idp_check_dp(dp->distpoint, crl->idp->distpoint))\n\t\t\t{\n\t\t\tif (idp_check_crlissuer(dp, crl, pimatch))\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n\t}", "target": 1}
{"idx": 5682, "func": "void *CRYPTO_secure_zalloc(size_t num, const char *file, int line)\n{\n    void *ret = CRYPTO_secure_malloc(num, file, line);\n\n    if (ret != NULL)\n        memset(ret, 0, num);\n    return ret;\n}", "target": 1}
{"idx": 5683, "func": "static av_always_inline void\nyuv2rgb_full_2_c_template(SwsContext *c, const int16_t *buf[2],\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n                     const int16_t *abuf[2], uint8_t *dest, int dstW,\n                     int yalpha, int uvalpha, int y,\n                     enum AVPixelFormat target, int hasAlpha)\n{\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n    int  yalpha1 = 4096 - yalpha;\n    int uvalpha1 = 4096 - uvalpha;\n    int i;\n    int step = (target == AV_PIX_FMT_RGB24 || target == AV_PIX_FMT_BGR24) ? 3 : 4;\n    int err[4] = {0};\n    int A = 0; // init to silcene warning\n\n    if(   target == AV_PIX_FMT_BGR4_BYTE || target == AV_PIX_FMT_RGB4_BYTE\n       || target == AV_PIX_FMT_BGR8      || target == AV_PIX_FMT_RGB8)\n        step = 1;\n\n    for (i = 0; i < dstW; i++) {\n        int Y = ( buf0[i] * yalpha1  +  buf1[i] * yalpha             ) >> 10; //FIXME rounding\n        int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha-(128 << 19)) >> 10;\n        int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha-(128 << 19)) >> 10;\n\n        if (hasAlpha) {\n            A = (abuf0[i] * yalpha1 + abuf1[i] * yalpha + (1<<18)) >> 19;\n            if (A & 0x100)\n                A = av_clip_uint8(A);\n        }\n\n        yuv2rgb_write_full(c, dest, i, Y, A, U, V, y, target, hasAlpha, err);\n        dest += step;\n    }\n    c->dither_error[0][i] = err[0];\n    c->dither_error[1][i] = err[1];\n    c->dither_error[2][i] = err[2];\n}", "target": 0}
{"idx": 5684, "func": "static void generate_codebook(RoqContext *enc, RoqTempdata *tempdata,\n                              int *points, int inputCount, roq_cell *results,\n                              int size, int cbsize)\n{\n    int i, j, k;\n    int c_size = size*size/4;\n    int *buf;\n    int *codebook = av_malloc(6*c_size*cbsize*sizeof(int));\n    int *closest_cb;\n\n    if (size == 4)\n        closest_cb = av_malloc(6*c_size*inputCount*sizeof(int));\n    else\n        closest_cb = tempdata->closest_cb2;\n\n    ff_init_elbg(points, 6*c_size, inputCount, codebook, cbsize, 1, closest_cb, &enc->randctx);\n    ff_do_elbg(points, 6*c_size, inputCount, codebook, cbsize, 1, closest_cb, &enc->randctx);\n\n    if (size == 4)\n        av_free(closest_cb);\n\n    buf = codebook;\n    for (i=0; i<cbsize; i++)\n        for (k=0; k<c_size; k++) {\n            for(j=0; j<4; j++)\n                results->y[j] = *buf++;\n\n            results->u =    (*buf++ + CHROMA_BIAS/2)/CHROMA_BIAS;\n            results->v =    (*buf++ + CHROMA_BIAS/2)/CHROMA_BIAS;\n            results++;\n        }\n\n    av_free(codebook);\n}", "target": 1}
{"idx": 5685, "func": "static int ec_precompute_mont_data(EC_GROUP *group)\n{\n    BN_CTX *ctx = BN_CTX_new();\n    int ret = 0;\n\n    BN_MONT_CTX_free(group->mont_data);\n    group->mont_data = NULL;\n\n    if (ctx == NULL)\n        goto err;\n\n    group->mont_data = BN_MONT_CTX_new();\n    if (group->mont_data == NULL)\n        goto err;\n\n    if (!BN_MONT_CTX_set(group->mont_data, group->order, ctx)) {\n        BN_MONT_CTX_free(group->mont_data);\n        group->mont_data = NULL;\n        goto err;\n    }\n\n    ret = 1;\n\n err:\n\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"idx": 5686, "func": "void t2p_read_tiff_init(T2P* t2p, TIFF* input){\n\n\ttdir_t directorycount=0;\n\ttdir_t i=0;\n\tuint16 pagen=0;\n\tuint16 paged=0;\n\tuint16 xuint16=0;\n\n\tdirectorycount=TIFFNumberOfDirectories(input);\n\tt2p->tiff_pages = (T2P_PAGE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_PAGE)));\n\tif(t2p->tiff_pages==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory for tiff_pages array, %s\", \n\t\t\t(TIFF_SIZE_T) directorycount * sizeof(T2P_PAGE), \n\t\t\tTIFFFileName(input));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\t_TIFFmemset( t2p->tiff_pages, 0x00, directorycount * sizeof(T2P_PAGE));\n\tt2p->tiff_tiles = (T2P_TILES*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_TILES)));\n\tif(t2p->tiff_tiles==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory for tiff_tiles array, %s\", \n\t\t\t(TIFF_SIZE_T) directorycount * sizeof(T2P_TILES), \n\t\t\tTIFFFileName(input));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\t_TIFFmemset( t2p->tiff_tiles, 0x00, directorycount * sizeof(T2P_TILES));\n\tfor(i=0;i<directorycount;i++){\n\t\tuint32 subfiletype = 0;\n\t\t\n\t\tif(!TIFFSetDirectory(input, i)){\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"Can't set directory %u of input file %s\", \n\t\t\t\ti,\n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tif(TIFFGetField(input, TIFFTAG_PAGENUMBER, &pagen, &paged)){\n\t\t\tif((pagen>paged) && (paged != 0)){\n\t\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number = \n\t\t\t\t\tpaged;\n\t\t\t} else {\n\t\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number = \n\t\t\t\t\tpagen;\n\t\t\t}\n\t\t\tgoto ispage2;\n\t\t}\n\t\tif(TIFFGetField(input, TIFFTAG_SUBFILETYPE, &subfiletype)){\n\t\t\tif ( ((subfiletype & FILETYPE_PAGE) != 0)\n                             || (subfiletype == 0)){\n\t\t\t\tgoto ispage;\n\t\t\t} else {\n\t\t\t\tgoto isnotpage;\n\t\t\t}\n\t\t}\n\t\tif(TIFFGetField(input, TIFFTAG_OSUBFILETYPE, &subfiletype)){\n\t\t\tif ((subfiletype == OFILETYPE_IMAGE) \n\t\t\t\t|| (subfiletype == OFILETYPE_PAGE)\n\t\t\t\t|| (subfiletype == 0) ){\n\t\t\t\tgoto ispage;\n\t\t\t} else {\n\t\t\t\tgoto isnotpage;\n\t\t\t}\n\t\t}\n\t\tispage:\n\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number=t2p->tiff_pagecount;\n\t\tispage2:\n\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_directory=i;\n\t\tif(TIFFIsTiled(input)){\n\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_tilecount = \n\t\t\t\tTIFFNumberOfTiles(input);\n\t\t}\n\t\tt2p->tiff_pagecount++;\n\t\tisnotpage:\n\t\t(void)0;\n\t}\n\t\n\tqsort((void*) t2p->tiff_pages, t2p->tiff_pagecount,\n              sizeof(T2P_PAGE), t2p_cmp_t2p_page);\n\n\tfor(i=0;i<t2p->tiff_pagecount;i++){\n\t\tt2p->pdf_xrefcount += 5;\n\t\tTIFFSetDirectory(input, t2p->tiff_pages[i].page_directory );\n\t\tif((TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &xuint16)\n                    && (xuint16==PHOTOMETRIC_PALETTE))\n\t\t   || TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)) {\n\t\t\tt2p->tiff_pages[i].page_extra++;\n\t\t\tt2p->pdf_xrefcount++;\n\t\t}\n#ifdef ZIP_SUPPORT\n\t\tif (TIFFGetField(input, TIFFTAG_COMPRESSION, &xuint16)) {\n                        if( (xuint16== COMPRESSION_DEFLATE ||\n                             xuint16== COMPRESSION_ADOBE_DEFLATE) && \n                            ((t2p->tiff_pages[i].page_tilecount != 0) \n                             || TIFFNumberOfStrips(input)==1) &&\n                            (t2p->pdf_nopassthrough==0)\t){\n                                if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}\n                        }\n                }\n#endif\n\t\tif (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,\n                                 &(t2p->tiff_transferfunction[0]),\n                                 &(t2p->tiff_transferfunction[1]),\n                                 &(t2p->tiff_transferfunction[2]))) {\n\t\t\tif((t2p->tiff_transferfunction[1] != (float*) NULL) &&\n                           (t2p->tiff_transferfunction[2] != (float*) NULL) &&\n                           (t2p->tiff_transferfunction[1] !=\n                            t2p->tiff_transferfunction[0])) {\n\t\t\t\tt2p->tiff_transferfunctioncount = 3;\n\t\t\t\tt2p->tiff_pages[i].page_extra += 4;\n\t\t\t\tt2p->pdf_xrefcount += 4;\n\t\t\t} else {\n\t\t\t\tt2p->tiff_transferfunctioncount = 1;\n\t\t\t\tt2p->tiff_pages[i].page_extra += 2;\n\t\t\t\tt2p->pdf_xrefcount += 2;\n\t\t\t}\n\t\t\tif(t2p->pdf_minorversion < 2)\n\t\t\t\tt2p->pdf_minorversion = 2;\n                } else {\n\t\t\tt2p->tiff_transferfunctioncount=0;\n\t\t}\n\t\tif( TIFFGetField(\n\t\t\tinput, \n\t\t\tTIFFTAG_ICCPROFILE, \n\t\t\t&(t2p->tiff_iccprofilelength), \n\t\t\t&(t2p->tiff_iccprofile)) != 0){\n\t\t\tt2p->tiff_pages[i].page_extra++;\n\t\t\tt2p->pdf_xrefcount++;\n\t\t\tif(t2p->pdf_minorversion<3){t2p->pdf_minorversion=3;}\n\t\t}\n\t\tt2p->tiff_tiles[i].tiles_tilecount=\n\t\t\tt2p->tiff_pages[i].page_tilecount;\n\t\tif( (TIFFGetField(input, TIFFTAG_PLANARCONFIG, &xuint16) != 0)\n\t\t\t&& (xuint16 == PLANARCONFIG_SEPARATE ) ){\n\t\t\t\tif( !TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &xuint16) )\n\t\t\t\t{\n\t\t\t\t\tTIFFError(\n                        TIFF2PDF_MODULE, \n                        \"Missing SamplesPerPixel, %s\", \n                        TIFFFileName(input));\n                    t2p->t2p_error = T2P_ERR_ERROR;\n                    return;\n\t\t\t\t}\n                if( (t2p->tiff_tiles[i].tiles_tilecount % xuint16) != 0 )\n                {\n                    TIFFError(\n                        TIFF2PDF_MODULE, \n                        \"Invalid tile count, %s\", \n                        TIFFFileName(input));\n                    t2p->t2p_error = T2P_ERR_ERROR;\n                    return;\n                }\n\t\t\t\tt2p->tiff_tiles[i].tiles_tilecount/= xuint16;\n\t\t}\n\t\tif( t2p->tiff_tiles[i].tiles_tilecount > 0){\n\t\t\tt2p->pdf_xrefcount += \n\t\t\t\t(t2p->tiff_tiles[i].tiles_tilecount -1)*2;\n\t\t\tTIFFGetField(input, \n\t\t\t\tTIFFTAG_TILEWIDTH, \n\t\t\t\t&( t2p->tiff_tiles[i].tiles_tilewidth) );\n\t\t\tTIFFGetField(input, \n\t\t\t\tTIFFTAG_TILELENGTH, \n\t\t\t\t&( t2p->tiff_tiles[i].tiles_tilelength) );\n\t\t\tt2p->tiff_tiles[i].tiles_tiles = \n\t\t\t(T2P_TILE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->tiff_tiles[i].tiles_tilecount,\n                                                                 sizeof(T2P_TILE)) );\n\t\t\tif( t2p->tiff_tiles[i].tiles_tiles == NULL){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory for t2p_read_tiff_init, %s\", \n\t\t\t\t\t(TIFF_SIZE_T) t2p->tiff_tiles[i].tiles_tilecount * sizeof(T2P_TILE), \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}", "target": 1}
{"idx": 5687, "func": "static int svq3_decode_slice_header(H264Context *h)\n{\n    MpegEncContext *const s = (MpegEncContext *) h;\n    const int mb_xy = h->mb_xy;\n    int i, header;\n\n    header = get_bits(&s->gb, 8);\n\n    if (((header & 0x9F) != 1 && (header & 0x9F) != 2) || (header & 0x60) == 0) {\n        /* TODO: what? */\n        av_log(h->s.avctx, AV_LOG_ERROR, \"unsupported slice header (%02X)\\n\", header);\n        return -1;\n    } else {\n        int length = (header >> 5) & 3;\n\n        h->next_slice_index = get_bits_count(&s->gb) + 8*show_bits(&s->gb, 8*length) + 8*length;\n\n        if (h->next_slice_index > s->gb.size_in_bits) {\n            av_log(h->s.avctx, AV_LOG_ERROR, \"slice after bitstream end\\n\");\n            return -1;\n    }\n\n        s->gb.size_in_bits = h->next_slice_index - 8*(length - 1);\n        skip_bits(&s->gb, 8);\n\n        if (h->svq3_watermark_key) {\n            uint32_t header = AV_RL32(&s->gb.buffer[(get_bits_count(&s->gb)>>3)+1]);\n            AV_WL32(&s->gb.buffer[(get_bits_count(&s->gb)>>3)+1], header ^ h->svq3_watermark_key);\n        }\n        if (length > 0) {\n            memcpy((uint8_t *) &s->gb.buffer[get_bits_count(&s->gb) >> 3],\n                   &s->gb.buffer[s->gb.size_in_bits >> 3], (length - 1));\n        }\n        skip_bits_long(&s->gb, 0);\n    }\n\n    if ((i = svq3_get_ue_golomb(&s->gb)) == INVALID_VLC || i >= 3){\n        av_log(h->s.avctx, AV_LOG_ERROR, \"illegal slice type %d \\n\", i);\n        return -1;\n    }\n\n    h->slice_type = golomb_to_pict_type[i];\n\n    if ((header & 0x9F) == 2) {\n        i = (s->mb_num < 64) ? 6 : (1 + av_log2 (s->mb_num - 1));\n        s->mb_skip_run = get_bits(&s->gb, i) - (s->mb_x + (s->mb_y * s->mb_width));\n    } else {\n        skip_bits1(&s->gb);\n        s->mb_skip_run = 0;\n    }\n\n    h->slice_num = get_bits(&s->gb, 8);\n    s->qscale = get_bits(&s->gb, 5);\n    s->adaptive_quant = get_bits1(&s->gb);\n\n    /* unknown fields */\n    skip_bits1(&s->gb);\n\n    if (h->unknown_svq3_flag) {\n        skip_bits1(&s->gb);\n    }\n\n    skip_bits1(&s->gb);\n    skip_bits(&s->gb, 2);\n\n    while (get_bits1(&s->gb)) {\n        skip_bits(&s->gb, 8);\n    }\n\n    /* reset intra predictors and invalidate motion vector references */\n    if (s->mb_x > 0) {\n        memset(h->intra4x4_pred_mode+8*h->mb2br_xy[mb_xy - 1      ]+3, -1, 4*sizeof(int8_t));\n        memset(h->intra4x4_pred_mode+8*h->mb2br_xy[mb_xy - s->mb_x]  , -1, 8*sizeof(int8_t)*s->mb_x);\n    }\n    if (s->mb_y > 0) {\n        memset(h->intra4x4_pred_mode+8*h->mb2br_xy[mb_xy - s->mb_stride], -1, 8*sizeof(int8_t)*(s->mb_width - s->mb_x));\n\n        if (s->mb_x > 0) {\n            h->intra4x4_pred_mode[8*h->mb2br_xy[mb_xy - s->mb_stride - 1]+3] = -1;\n        }\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5688, "func": "void SSL_free(SSL *s)\n{\n    int i;\n\n    if (s == NULL)\n        return;\n\n    CRYPTO_DOWN_REF(&s->references, &i, s->lock);\n    REF_PRINT_COUNT(\"SSL\", s);\n    if (i > 0)\n        return;\n    REF_ASSERT_ISNT(i < 0);\n\n    X509_VERIFY_PARAM_free(s->param);\n    dane_final(&s->dane);\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);\n\n    /* Ignore return value */\n    ssl_free_wbio_buffer(s);\n\n    BIO_free_all(s->wbio);\n    BIO_free_all(s->rbio);\n\n    BUF_MEM_free(s->init_buf);\n\n    /* add extra stuff */\n    sk_SSL_CIPHER_free(s->cipher_list);\n    sk_SSL_CIPHER_free(s->cipher_list_by_id);\n\n    /* Make the next call work :-) */\n    if (s->session != NULL) {\n        ssl_clear_bad_session(s);\n        SSL_SESSION_free(s->session);\n    }\n    SSL_SESSION_free(s->psksession);\n    OPENSSL_free(s->psksession_id);\n\n    clear_ciphers(s);\n\n    ssl_cert_free(s->cert);\n    /* Free up if allocated */\n\n    OPENSSL_free(s->ext.hostname);\n    SSL_CTX_free(s->session_ctx);\n#ifndef OPENSSL_NO_EC\n    OPENSSL_free(s->ext.ecpointformats);\n    OPENSSL_free(s->ext.supportedgroups);\n#endif                          /* OPENSSL_NO_EC */\n    sk_X509_EXTENSION_pop_free(s->ext.ocsp.exts, X509_EXTENSION_free);\n#ifndef OPENSSL_NO_OCSP\n    sk_OCSP_RESPID_pop_free(s->ext.ocsp.ids, OCSP_RESPID_free);\n#endif\n#ifndef OPENSSL_NO_CT\n    SCT_LIST_free(s->scts);\n    OPENSSL_free(s->ext.scts);\n#endif\n    OPENSSL_free(s->ext.ocsp.resp);\n    OPENSSL_free(s->ext.alpn);\n    OPENSSL_free(s->ext.tls13_cookie);\n    OPENSSL_free(s->clienthello);\n    OPENSSL_free(s->pha_context);\n    EVP_MD_CTX_free(s->pha_dgst);\n\n    sk_X509_NAME_pop_free(s->ca_names, X509_NAME_free);\n\n    sk_X509_pop_free(s->verified_chain, X509_free);\n\n    if (s->method != NULL)\n        s->method->ssl_free(s);\n\n    RECORD_LAYER_release(&s->rlayer);\n\n    SSL_CTX_free(s->ctx);\n\n    ASYNC_WAIT_CTX_free(s->waitctx);\n\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    OPENSSL_free(s->ext.npn);\n#endif\n\n#ifndef OPENSSL_NO_SRTP\n    sk_SRTP_PROTECTION_PROFILE_free(s->srtp_profiles);\n#endif\n\n    RAND_DRBG_free(s->drbg);\n    CRYPTO_THREAD_lock_free(s->lock);\n\n    OPENSSL_free(s);\n}", "target": 0}
{"idx": 5689, "func": "int WPACKET_allocate_bytes(WPACKET *pkt, size_t len, unsigned char **allocbytes)\n{\n    /* Internal API, so should not fail */\n    assert(pkt->subs != NULL && len != 0);\n    if (pkt->subs == NULL || len == 0)\n        return 0;\n\n    if (pkt->maxsize - pkt->written < len)\n        return 0;\n\n    if (pkt->buf->length - pkt->written < len) {\n        size_t newlen;\n        size_t reflen;\n\n        reflen = (len > pkt->buf->length) ? len : pkt->buf->length;\n\n        if (reflen > SIZE_MAX / 2) {\n            newlen = SIZE_MAX;\n        } else {\n            newlen = reflen * 2;\n            if (newlen < DEFAULT_BUF_SIZE)\n                newlen = DEFAULT_BUF_SIZE;\n        }\n        if (BUF_MEM_grow(pkt->buf, newlen) == 0)\n            return 0;\n    }\n    *allocbytes = (unsigned char *)pkt->buf->data + pkt->curr;\n    pkt->written += len;\n    pkt->curr += len;\n\n    return 1;\n}", "target": 0}
{"idx": 5690, "func": "const AVOption *av_opt_next(FF_CONST_AVUTIL55 void *obj, const AVOption *last)\n{\n    const AVClass *class;\n    if (!obj)\n        return NULL;\n    class = *(const AVClass**)obj;\n    if (!last && class && class->option && class->option[0].name)\n        return class->option;\n    if (last && last[1].name)\n        return ++last;\n    return NULL;\n}", "target": 1}
{"idx": 5691, "func": "static int calc_active_inputs(MixContext *s)\n{\n    int i;\n    int active_inputs = 0;\n    for (i = 0; i < s->nb_inputs; i++)\n        active_inputs += !!(s->input_state[i] & INPUT_ON);\n    s->active_inputs = active_inputs;\n\n    if (!active_inputs ||\n        (s->duration_mode == DURATION_FIRST && !(s->input_state[0] & INPUT_ON)) ||\n        (s->duration_mode == DURATION_SHORTEST && active_inputs != s->nb_inputs))\n        return AVERROR_EOF;\n    return 0;\n}", "target": 1}
{"idx": 5692, "func": "static int twin_decode_frame(AVCodecContext * avctx, void *data,\n                             int *data_size, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    TwinContext *tctx = avctx->priv_data;\n    GetBitContext gb;\n    const ModeTab *mtab = tctx->mtab;\n    float *out = data;\n    enum FrameType ftype;\n    int window_type, out_size;\n    static const enum FrameType wtype_to_ftype_table[] = {\n        FT_LONG,   FT_LONG, FT_SHORT, FT_LONG,\n        FT_MEDIUM, FT_LONG, FT_LONG,  FT_MEDIUM, FT_MEDIUM\n    };\n\n    if (buf_size*8 < avctx->bit_rate*mtab->size/avctx->sample_rate + 8) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Frame too small (%d bytes). Truncated file?\\n\", buf_size);\n        return AVERROR(EINVAL);\n    }\n\n    out_size = mtab->size * avctx->channels *\n               av_get_bytes_per_sample(avctx->sample_fmt);\n    if (*data_size < out_size) {\n        av_log(avctx, AV_LOG_ERROR, \"output buffer is too small\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    init_get_bits(&gb, buf, buf_size * 8);\n    skip_bits(&gb, get_bits(&gb, 8));\n    window_type = get_bits(&gb, WINDOW_TYPE_BITS);\n\n    if (window_type > 8) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid window type, broken sample?\\n\");\n        return -1;\n    }\n\n    ftype = wtype_to_ftype_table[window_type];\n\n    read_and_decode_spectrum(tctx, &gb, tctx->spectrum, ftype);\n\n    imdct_output(tctx, ftype, window_type, out);\n\n    FFSWAP(float*, tctx->curr_frame, tctx->prev_frame);\n\n    if (tctx->avctx->frame_number < 2) {\n        *data_size=0;\n        return buf_size;\n    }\n\n    *data_size = out_size;\n\n    return buf_size;\n}", "target": 0}
{"idx": 5693, "func": "static void free_rendition_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_renditions; i++)\n        av_freep(&c->renditions[i]);\n    av_freep(&c->renditions);\n    c->n_renditions = 0;\n}", "target": 1}
{"idx": 5694, "func": "static int get_bits(J2kDecoderContext *s, int n)\n{\n    int res = 0;\n    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))\n        return AVERROR(EINVAL);\n    while (--n >= 0){\n        res <<= 1;\n        if (s->bit_index == 0){\n            s->bit_index = 7 + (*s->buf != 0xff);\n            s->buf++;\n        }\n        s->bit_index--;\n        res |= (*s->buf >> s->bit_index) & 1;\n    }\n    return res;\n}", "target": 1}
{"idx": 5695, "func": "static int old_codec37(SANMVideoContext *ctx, int top,\n                       int left, int width, int height)\n{\n    int stride = ctx->pitch;\n    int i, j, k, t;\n    int skip_run = 0;\n    int compr, mvoff, seq, flags;\n    uint32_t decoded_size;\n    uint8_t *dst, *prev;\n\n    compr        = bytestream2_get_byte(&ctx->gb);\n    mvoff        = bytestream2_get_byte(&ctx->gb);\n    seq          = bytestream2_get_le16(&ctx->gb);\n    decoded_size = bytestream2_get_le32(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 4);\n    flags        = bytestream2_get_byte(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 3);\n\n    if (decoded_size > height * stride - left - top * stride) {\n        decoded_size = height * stride - left - top * stride;\n        av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n    }\n\n    ctx->rotate_code = 0;\n\n    if (((seq & 1) || !(flags & 1)) && (compr && compr != 2))\n        rotate_bufs(ctx, 1);\n\n    dst  = ((uint8_t*)ctx->frm0) + left + top * stride;\n    prev = ((uint8_t*)ctx->frm2) + left + top * stride;\n\n    if (mvoff > 2) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"invalid motion base value %d\\n\", mvoff);\n        return AVERROR_INVALIDDATA;\n    }\n    av_dlog(ctx->avctx, \"compression %d\\n\", compr);\n    switch (compr) {\n    case 0:\n        for (i = 0; i < height; i++) {\n            bytestream2_get_buffer(&ctx->gb, dst, width);\n            dst += stride;\n        }\n        memset(ctx->frm1, 0, ctx->height * stride);\n        memset(ctx->frm2, 0, ctx->height * stride);\n        break;\n    case 2:\n        if (rle_decode(ctx, dst, decoded_size))\n            return AVERROR_INVALIDDATA;\n        memset(ctx->frm1, 0, ctx->frm1_size);\n        memset(ctx->frm2, 0, ctx->frm2_size);\n        break;\n    case 3:\n    case 4:\n        if (flags & 4) {\n            for (j = 0; j < height; j += 4) {\n                for (i = 0; i < width; i += 4) {\n                    int code;\n                    if (skip_run) {\n                        skip_run--;\n                        copy_block4(dst + i, prev + i, stride, stride, 4);\n                        continue;\n                    }\n                    if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                        return AVERROR_INVALIDDATA;\n                    code = bytestream2_get_byteu(&ctx->gb);\n                    switch (code) {\n                    case 0xFF:\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 16)\n                            return AVERROR_INVALIDDATA;\n                        for (k = 0; k < 4; k++)\n                            bytestream2_get_bufferu(&ctx->gb, dst + i + k * stride, 4);\n                        break;\n                    case 0xFE:\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 4)\n                            return AVERROR_INVALIDDATA;\n                        for (k = 0; k < 4; k++)\n                            memset(dst + i + k * stride, bytestream2_get_byteu(&ctx->gb), 4);\n                        break;\n                    case 0xFD:\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                            return AVERROR_INVALIDDATA;\n                        t = bytestream2_get_byteu(&ctx->gb);\n                        for (k = 0; k < 4; k++)\n                            memset(dst + i + k * stride, t, 4);\n                        break;\n                    default:\n                        if (compr == 4 && !code) {\n                            if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                                return AVERROR_INVALIDDATA;\n                            skip_run = bytestream2_get_byteu(&ctx->gb) + 1;\n                            i -= 4;\n                        } else {\n                            int mx, my;\n\n                            mx = c37_mv[(mvoff * 255 + code) * 2    ];\n                            my = c37_mv[(mvoff * 255 + code) * 2 + 1];\n                            codec37_mv(dst + i, prev + i + mx + my * stride,\n                                       ctx->height, stride, i + mx, j + my);\n                        }\n                    }\n                }\n                dst  += stride * 4;\n                prev += stride * 4;\n            }\n        } else {\n            for (j = 0; j < height; j += 4) {\n                for (i = 0; i < width; i += 4) {\n                    int code;\n                    if (skip_run) {\n                        skip_run--;\n                        copy_block4(dst + i, prev + i, stride, stride, 4);\n                        continue;\n                    }\n                    code = bytestream2_get_byte(&ctx->gb);\n                    if (code == 0xFF) {\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 16)\n                            return AVERROR_INVALIDDATA;\n                        for (k = 0; k < 4; k++)\n                            bytestream2_get_bufferu(&ctx->gb, dst + i + k * stride, 4);\n                    } else if (compr == 4 && !code) {\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                            return AVERROR_INVALIDDATA;\n                        skip_run = bytestream2_get_byteu(&ctx->gb) + 1;\n                        i -= 4;\n                    } else {\n                        int mx, my;\n\n                        mx = c37_mv[(mvoff * 255 + code) * 2];\n                        my = c37_mv[(mvoff * 255 + code) * 2 + 1];\n                        codec37_mv(dst + i, prev + i + mx + my * stride,\n                                   ctx->height, stride, i + mx, j + my);\n                    }\n                }\n                dst  += stride * 4;\n                prev += stride * 4;\n            }\n        }\n        break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"subcodec 37 compression %d not implemented\\n\", compr);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5696, "func": "int ff_lzw_decode(LZWState *p, uint8_t *buf, int len){\n    int l, c, code, oc, fc;\n    uint8_t *sp;\n    struct LZWState *s = (struct LZWState *)p;\n\n    if (s->end_code < 0)\n        return 0;\n\n    l = len;\n    sp = s->sp;\n    oc = s->oc;\n    fc = s->fc;\n\n    for (;;) {\n        while (sp > s->stack) {\n            *buf++ = *(--sp);\n            if ((--l) == 0)\n                goto the_end;\n        }\n        c = lzw_get_code(s);\n        if (c == s->end_code) {\n            break;\n        } else if (c == s->clear_code) {\n            s->cursize = s->codesize + 1;\n            s->curmask = mask[s->cursize];\n            s->slot = s->newcodes;\n            s->top_slot = 1 << s->cursize;\n            fc= oc= -1;\n        } else {\n            code = c;\n            if (code == s->slot && fc>=0) {\n                *sp++ = fc;\n                code = oc;\n            }else if(code >= s->slot)\n                break;\n            while (code >= s->newcodes) {\n                *sp++ = s->suffix[code];\n                code = s->prefix[code];\n            }\n            *sp++ = code;\n            if (s->slot < s->top_slot && oc>=0) {\n                s->suffix[s->slot] = code;\n                s->prefix[s->slot++] = oc;\n            }\n            fc = code;\n            oc = c;\n            if (s->slot >= s->top_slot - s->extra_slot) {\n                if (s->cursize < LZW_MAXBITS) {\n                    s->top_slot <<= 1;\n                    s->curmask = mask[++s->cursize];\n                }\n            }\n        }\n    }\n    s->end_code = -1;\n  the_end:\n    s->sp = sp;\n    s->oc = oc;\n    s->fc = fc;\n    return len - l;\n}", "target": 1}
{"idx": 5697, "func": "int ts_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    char *CAfile = NULL, *untrusted = NULL, *engine = NULL, *prog, **helpp;\n    char *configfile = default_config_file;\n    char *section = NULL, *password = NULL;\n    char *data = NULL, *digest = NULL, *rnd = NULL, *policy = NULL;\n    char *in = NULL, *out = NULL, *queryfile = NULL, *passin = NULL;\n    char *inkey = NULL, *signer = NULL, *chain = NULL, *CApath = NULL;\n    const EVP_MD *md = NULL;\n    OPTION_CHOICE o, mode = OPT_ERR;\n    int ret = 1, no_nonce = 0, cert = 0, text = 0;\n    int vpmtouched = 0;\n    X509_VERIFY_PARAM *vpm = NULL;\n    /* Input is ContentInfo instead of TimeStampResp. */\n    int token_in = 0;\n    /* Output is ContentInfo instead of TimeStampResp. */\n    int token_out = 0;\n\n    if ((vpm = X509_VERIFY_PARAM_new()) == NULL)\n        goto end;\n\n    prog = opt_init(argc, argv, ts_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(ts_options);\n            for (helpp = opt_helplist; *helpp; ++helpp)\n                BIO_printf(bio_err, \"%s\\n\", *helpp);\n            ret = 0;\n            goto end;\n        case OPT_CONFIG:\n            configfile = opt_arg();\n            break;\n        case OPT_SECTION:\n            section = opt_arg();\n            break;\n        case OPT_QUERY:\n        case OPT_REPLY:\n        case OPT_VERIFY:\n            if (mode != OPT_ERR)\n                goto opthelp;\n            mode = o;\n            break;\n        case OPT_DATA:\n            data = opt_arg();\n            break;\n        case OPT_DIGEST:\n            digest = opt_arg();\n            break;\n        case OPT_RAND:\n            rnd = opt_arg();\n            break;\n        case OPT_TSPOLICY:\n            policy = opt_arg();\n            break;\n        case OPT_NO_NONCE:\n            no_nonce = 1;\n            break;\n        case OPT_CERT:\n            cert = 1;\n            break;\n        case OPT_IN:\n            in = opt_arg();\n            break;\n        case OPT_TOKEN_IN:\n            token_in = 1;\n            break;\n        case OPT_OUT:\n            out = opt_arg();\n            break;\n        case OPT_TOKEN_OUT:\n            token_out = 1;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_QUERYFILE:\n            queryfile = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passin = opt_arg();\n            break;\n        case OPT_INKEY:\n            inkey = opt_arg();\n            break;\n        case OPT_SIGNER:\n            signer = opt_arg();\n            break;\n        case OPT_CHAIN:\n            chain = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_UNTRUSTED:\n            untrusted = opt_arg();\n            break;\n        case OPT_ENGINE:\n            engine = opt_arg();\n            break;\n        case OPT_MD:\n            if (!opt_md(opt_unknown(), &md))\n                goto opthelp;\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        }\n    }\n    argc = opt_num_rest();\n    if (mode == OPT_ERR || argc != 0)\n        goto opthelp;\n\n    /* Seed the random number generator if it is going to be used. */\n    if (mode == OPT_QUERY && !no_nonce) {\n        if (!app_RAND_load_file(NULL, 1) && rnd == NULL)\n            BIO_printf(bio_err, \"warning, not much extra random \"\n                       \"data, consider using the -rand option\\n\");\n        if (rnd != NULL)\n            BIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\n                       app_RAND_load_files(rnd));\n    }\n\n    if (mode == OPT_REPLY && passin &&\n        !app_passwd(passin, NULL, &password, NULL)) {\n        BIO_printf(bio_err, \"Error getting password.\\n\");\n        goto end;\n    }\n\n    conf = load_config_file(configfile);\n    if (!app_load_modules(conf))\n        goto end;\n\n    /* Check parameter consistency and execute the appropriate function. */\n    switch (mode) {\n    default:\n    case OPT_ERR:\n        goto opthelp;\n    case OPT_QUERY:\n        if (vpmtouched)\n            goto opthelp;\n        if ((data != NULL) && (digest != NULL))\n            goto opthelp;\n        ret = !query_command(data, digest, md, policy, no_nonce, cert,\n                             in, out, text);\n        break;\n    case OPT_REPLY:\n        if (vpmtouched)\n            goto opthelp;\n        if ((in != NULL) && (queryfile != NULL))\n            goto opthelp;\n        if (in == NULL) {\n            if ((conf == NULL) || (token_in != 0))\n                goto opthelp;\n        }\n        ret = !reply_command(conf, section, engine, queryfile,\n                             password, inkey, md, signer, chain, policy,\n                             in, token_in, out, token_out, text);\n        break;\n    case OPT_VERIFY:\n        if ((in == NULL) || !EXACTLY_ONE(queryfile, data, digest))\n            goto opthelp;\n        ret = !verify_command(data, digest, queryfile, in, token_in,\n                              CApath, CAfile, untrusted, \n                              vpmtouched ? vpm : NULL);\n    }\n\n end:\n    X509_VERIFY_PARAM_free(vpm);\n    app_RAND_write_file(NULL);\n    NCONF_free(conf);\n    OPENSSL_free(password);\n    return (ret);\n}", "target": 0}
{"idx": 5698, "func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n\t{\n\tX509_NAME_ENTRY *ne;\nint i;\n\tint n,lold,l,l1,l2,num,j,type;\n\tconst char *s;\n\tchar *p;\n\tunsigned char *q;\n\tBUF_MEM *b=NULL;\n\tstatic char hex[17]=\"0123456789ABCDEF\";\n\tint gs_doit[4];\n\tchar tmp_buf[80];\n#ifdef CHARSET_EBCDIC\n\tchar ebcdic_buf[1024];\n#endif\n\n\tif (buf == NULL)\n\t\t{\n\t\tif ((b=BUF_MEM_new()) == NULL) goto err;\n\t\tif (!BUF_MEM_grow(b,200)) goto err;\n\t\tb->data[0]='\\0';\n\t\tlen=200;\n\t\t}\n\tif (a == NULL)\n\t    {\n\t    if(b)\n\t\t{\n\t\tbuf=b->data;\n\t\tFree(b);\n\t\t}\n\t    strncpy(buf,\"NO X509_NAME\",len);\n\t    return buf;\n\t    }\n\n\tlen--; /* space for '\\0' */\n\tl=0;\n\tfor (i=0; i<sk_X509_NAME_ENTRY_num(a->entries); i++)\n\t\t{\n\t\tne=sk_X509_NAME_ENTRY_value(a->entries,i);\n\t\tn=OBJ_obj2nid(ne->object);\n\t\tif ((n == NID_undef) || ((s=OBJ_nid2sn(n)) == NULL))\n\t\t\t{\n\t\t\ti2t_ASN1_OBJECT(tmp_buf,sizeof(tmp_buf),ne->object);\n\t\t\ts=tmp_buf;\n\t\t\t}\n\t\tl1=strlen(s);\n\n\t\ttype=ne->value->type;\n\t\tnum=ne->value->length;\n\t\tq=ne->value->data;\n#ifdef CHARSET_EBCDIC\n                if (type == V_ASN1_GENERALSTRING ||\n\t\t    type == V_ASN1_VISIBLESTRING ||\n\t\t    type == V_ASN1_PRINTABLESTRING ||\n\t\t    type == V_ASN1_TELETEXSTRING ||\n\t\t    type == V_ASN1_VISIBLESTRING ||\n\t\t    type == V_ASN1_IA5STRING) {\n                        ascii2ebcdic(ebcdic_buf, q,\n\t\t\t\t     (num > sizeof ebcdic_buf)\n\t\t\t\t     ? sizeof ebcdic_buf : num);\n                        q=ebcdic_buf;\n\t\t}\n#endif\n\n\t\tif ((type == V_ASN1_GENERALSTRING) && ((num%4) == 0))\n\t\t\t{\n\t\t\tgs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=0;\n\t\t\tfor (j=0; j<num; j++)\n\t\t\t\tif (q[j] != 0) gs_doit[j&3]=1;\n\n\t\t\tif (gs_doit[0]|gs_doit[1]|gs_doit[2])\n\t\t\t\tgs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=1;\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tgs_doit[0]=gs_doit[1]=gs_doit[2]=0;\n\t\t\t\tgs_doit[3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\tgs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=1;\n\n\t\tfor (l2=j=0; j<num; j++)\n\t\t\t{\n\t\t\tif (!gs_doit[j&3]) continue;\n\t\t\tl2++;\n#ifndef CHARSET_EBCDIC\n\t\t\tif ((q[j] < ' ') || (q[j] > '~')) l2+=3;\n#else\n\t\t\tif ((os_toascii[q[j]] < os_toascii[' ']) ||\n\t\t\t    (os_toascii[q[j]] > os_toascii['~'])) l2+=3;\n#endif\n\t\t\t}\n\n\t\tlold=l;\n\t\tl+=1+l1+1+l2;\n\t\tif (b != NULL)\n\t\t\t{\n\t\t\tif (!BUF_MEM_grow(b,l+1)) goto err;\n\t\t\tp= &(b->data[lold]);\n\t\t\t}\n\t\telse if (l > len)\n\t\t\t{\n\t\t\tbreak;\n\t\t\t}\n\t\telse\n\t\t\tp= &(buf[lold]);\n\t\t*(p++)='/';\n\t\tmemcpy(p,s,(unsigned int)l1); p+=l1;\n\t\t*(p++)='=';\n\n#ifndef CHARSET_EBCDIC /* q was assigned above already. */\n\t\tq=ne->value->data;\n#endif\n\n\t\tfor (j=0; j<num; j++)\n\t\t\t{\n\t\t\tif (!gs_doit[j&3]) continue;\n#ifndef CHARSET_EBCDIC\n\t\t\tn=q[j];\n\t\t\tif ((n < ' ') || (n > '~'))\n\t\t\t\t{\n\t\t\t\t*(p++)='\\\\';\n\t\t\t\t*(p++)='x';\n\t\t\t\t*(p++)=hex[(n>>4)&0x0f];\n\t\t\t\t*(p++)=hex[n&0x0f];\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t*(p++)=n;\n#else\n\t\t\tn=os_toascii[q[j]];\n\t\t\tif ((n < os_toascii[' ']) ||\n\t\t\t    (n > os_toascii['~']))\n\t\t\t\t{\n\t\t\t\t*(p++)='\\\\';\n\t\t\t\t*(p++)='x';\n\t\t\t\t*(p++)=hex[(n>>4)&0x0f];\n\t\t\t\t*(p++)=hex[n&0x0f];\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t*(p++)=q[j];\n#endif\n\t\t\t}\n\t\t*p='\\0';\n\t\t}\n\tif (b != NULL)\n\t\t{\n\t\tp=b->data;\n\t\tFree(b);\n\t\t}\n\telse\n\t\tp=buf;\n\treturn(p);\nerr:\n\tX509err(X509_F_X509_NAME_ONELINE,ERR_R_MALLOC_FAILURE);\n\tif (b != NULL) BUF_MEM_free(b);\n\treturn(NULL);\n\t}", "target": 1}
{"idx": 5699, "func": "int ff_rv34_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            const uint8_t *buf, int buf_size)\n{\n    RV34DecContext *r = avctx->priv_data;\n    MpegEncContext *s = &r->s;\n    AVFrame *pict = data;\n    SliceInfo si;\n    int i;\n    int slice_count;\n    const uint8_t *slices_hdr = NULL;\n    int last = 0;\n\n    /* no supplementary picture */\n    if (buf_size == 0) {\n        /* special case for last picture */\n        if (s->low_delay==0 && s->next_picture_ptr) {\n            *pict= *(AVFrame*)s->next_picture_ptr;\n            s->next_picture_ptr= NULL;\n\n            *data_size = sizeof(AVFrame);\n        }\n        return 0;\n    }\n\n    if(!avctx->slice_count){\n        slice_count = (*buf++) + 1;\n        slices_hdr = buf + 4;\n        buf += 8 * slice_count;\n    }else\n        slice_count = avctx->slice_count;\n\n    for(i=0; i<slice_count; i++){\n        int offset= get_slice_offset(avctx, slices_hdr, i);\n        int size;\n        if(i+1 == slice_count)\n            size= buf_size - offset;\n        else\n            size= get_slice_offset(avctx, slices_hdr, i+1) - offset;\n\n        if(offset > buf_size){\n            av_log(avctx, AV_LOG_ERROR, \"Slice offset is greater than frame size\\n\");\n            break;\n        }\n\n        r->si.end = s->mb_width * s->mb_height;\n        if(i+1 < slice_count){\n            init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n            if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n                if(i+2 < slice_count)\n                    size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n                else\n                    size = buf_size - offset;\n            }else\n                r->si.end = si.start;\n        }\n        if(!i && si.type == FF_B_TYPE && (!s->last_picture_ptr || !s->last_picture_ptr->data[0]))\n            return -1;\n        last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n        s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n        if(last)\n            break;\n    }\n\n    if(last){\n        if(r->loop_filter)\n            r->loop_filter(r, s->mb_height - 1);\n        ff_er_frame_end(s);\n        MPV_frame_end(s);\n        if (s->pict_type == FF_B_TYPE || s->low_delay) {\n            *pict= *(AVFrame*)s->current_picture_ptr;\n        } else if (s->last_picture_ptr != NULL) {\n            *pict= *(AVFrame*)s->last_picture_ptr;\n        }\n\n        if(s->last_picture_ptr || s->low_delay){\n            *data_size = sizeof(AVFrame);\n            ff_print_debug_info(s, pict);\n        }\n        s->current_picture_ptr= NULL; //so we can detect if frame_end wasnt called (find some nicer solution...)\n    }\n    return buf_size;\n}", "target": 1}
{"idx": 5700, "func": "static void reconstruct_and_encode_image(RoqContext *enc, RoqTempdata *tempData, int w, int h, int numBlocks)\n{\n    int i, j, k;\n    int x, y;\n    int subX, subY;\n    int dist=0;\n\n    roq_qcell *qcell;\n    CelEvaluation *eval;\n\n    CodingSpool spool;\n\n    spool.typeSpool=0;\n    spool.typeSpoolLength=0;\n    spool.args = spool.argumentSpool;\n    spool.pout = &enc->out_buf;\n\n    if (tempData->used_option[RoQ_ID_CCC]%2)\n        tempData->mainChunkSize+=8; //FIXME\n\n    /* Write the video chunk header */\n    bytestream_put_le16(&enc->out_buf, RoQ_QUAD_VQ);\n    bytestream_put_le32(&enc->out_buf, tempData->mainChunkSize/8);\n    bytestream_put_byte(&enc->out_buf, 0x0);\n    bytestream_put_byte(&enc->out_buf, 0x0);\n\n    for (i=0; i<numBlocks; i++) {\n        eval = tempData->cel_evals + i;\n\n        x = eval->sourceX;\n        y = eval->sourceY;\n        dist += eval->eval_dist[eval->best_coding];\n\n        switch (eval->best_coding) {\n        case RoQ_ID_MOT:\n            write_typecode(&spool, RoQ_ID_MOT);\n            break;\n\n        case RoQ_ID_FCC:\n            bytestream_put_byte(&spool.args, motion_arg(eval->motion));\n\n            write_typecode(&spool, RoQ_ID_FCC);\n            ff_apply_motion_8x8(enc, x, y,\n                                eval->motion.d[0], eval->motion.d[1]);\n            break;\n\n        case RoQ_ID_SLD:\n            bytestream_put_byte(&spool.args, tempData->i2f4[eval->cbEntry]);\n            write_typecode(&spool, RoQ_ID_SLD);\n\n            qcell = enc->cb4x4 + eval->cbEntry;\n            ff_apply_vector_4x4(enc, x  , y  , enc->cb2x2 + qcell->idx[0]);\n            ff_apply_vector_4x4(enc, x+4, y  , enc->cb2x2 + qcell->idx[1]);\n            ff_apply_vector_4x4(enc, x  , y+4, enc->cb2x2 + qcell->idx[2]);\n            ff_apply_vector_4x4(enc, x+4, y+4, enc->cb2x2 + qcell->idx[3]);\n            break;\n\n        case RoQ_ID_CCC:\n            write_typecode(&spool, RoQ_ID_CCC);\n\n            for (j=0; j<4; j++) {\n                subX = x + 4*(j&1);\n                subY = y + 2*(j&2);\n\n                switch(eval->subCels[j].best_coding) {\n                case RoQ_ID_MOT:\n                    break;\n\n                case RoQ_ID_FCC:\n                    bytestream_put_byte(&spool.args,\n                                        motion_arg(eval->subCels[j].motion));\n\n                    ff_apply_motion_4x4(enc, subX, subY,\n                                        eval->subCels[j].motion.d[0],\n                                        eval->subCels[j].motion.d[1]);\n                    break;\n\n                case RoQ_ID_SLD:\n                    bytestream_put_byte(&spool.args,\n                                        tempData->i2f4[eval->subCels[j].cbEntry]);\n\n                    qcell = enc->cb4x4 + eval->subCels[j].cbEntry;\n\n                    ff_apply_vector_2x2(enc, subX  , subY  ,\n                                        enc->cb2x2 + qcell->idx[0]);\n                    ff_apply_vector_2x2(enc, subX+2, subY  ,\n                                        enc->cb2x2 + qcell->idx[1]);\n                    ff_apply_vector_2x2(enc, subX  , subY+2,\n                                        enc->cb2x2 + qcell->idx[2]);\n                    ff_apply_vector_2x2(enc, subX+2, subY+2,\n                                        enc->cb2x2 + qcell->idx[3]);\n                    break;\n\n                case RoQ_ID_CCC:\n                    for (k=0; k<4; k++) {\n                        int cb_idx = eval->subCels[j].subCels[k];\n                        bytestream_put_byte(&spool.args,\n                                            tempData->i2f2[cb_idx]);\n\n                        ff_apply_vector_2x2(enc, subX + 2*(k&1), subY + (k&2),\n                                            enc->cb2x2 + cb_idx);\n                    }\n                    break;\n                }\n                write_typecode(&spool, eval->subCels[j].best_coding);\n            }\n            break;\n        }\n    }\n\n    /* Flush the remainder of the argument/type spool */\n    while (spool.typeSpoolLength)\n        write_typecode(&spool, 0x0);\n\n#if 0\n    uint8_t *fdata[3] = {enc->frame_to_enc->data[0],\n                           enc->frame_to_enc->data[1],\n                           enc->frame_to_enc->data[2]};\n    uint8_t *cdata[3] = {enc->current_frame->data[0],\n                           enc->current_frame->data[1],\n                           enc->current_frame->data[2]};\n    av_log(enc->avctx, AV_LOG_ERROR, \"Expected distortion: %i Actual: %i\\n\",\n           dist,\n           block_sse(fdata, cdata, 0, 0, 0, 0,\n                     enc->frame_to_enc->linesize,\n                     enc->current_frame->linesize,\n                     enc->width));  //WARNING: Square dimensions implied...\n#endif\n}", "target": 1}
{"idx": 5701, "func": "static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n                                    const uint8_t *src, const uint8_t *src_end,\n                                    int width, int esc_count)\n{\n    int i = 0;\n    int count;\n    uint8_t zero_run = 0;\n    const uint8_t *src_start = src;\n    uint8_t mask1 = -(esc_count < 2);\n    uint8_t mask2 = -(esc_count < 3);\n    uint8_t *end = dst + (width - 2);\n\n    avpriv_request_sample(l->avctx, \"zero_run_line\");\n    return AVERROR_PATCHWELCOME;\n\noutput_zeros:\n    if (l->zeros_rem) {\n        count = FFMIN(l->zeros_rem, width - i);\n        if (end - dst < count) {\n            av_log(l->avctx, AV_LOG_ERROR, \"Too many zeros remaining.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        memset(dst, 0, count);\n        l->zeros_rem -= count;\n        dst += count;\n    }\n\n    while (dst < end) {\n        i = 0;\n        while (!zero_run && dst + i < end) {\n            i++;\n            if (i+2 >= src_end - src)\n                return AVERROR_INVALIDDATA;\n            zero_run =\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n        }\n        if (zero_run) {\n            zero_run = 0;\n            i += esc_count;\n            memcpy(dst, src, i);\n            dst += i;\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n\n            src += i + 1;\n            goto output_zeros;\n        } else {\n            memcpy(dst, src, i);\n            src += i;\n            dst += i;\n        }\n    }\n    return  src - src_start;\n}", "target": 0}
{"idx": 5702, "func": "static int ea_read_packet(AVFormatContext *s,\n                          AVPacket *pkt)\n{\n    EaDemuxContext *ea = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret = 0;\n    int packet_read = 0;\n    unsigned int chunk_type, chunk_size;\n    int key = 0;\n    int av_uninit(num_samples);\n\n    while (!packet_read) {\n        chunk_type = avio_rl32(pb);\n        chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8;\n\n        switch (chunk_type) {\n        /* audio data */\n        case ISNh_TAG:\n            /* header chunk also contains data; skip over the header portion*/\n            avio_skip(pb, 32);\n            chunk_size -= 32;\n        case ISNd_TAG:\n        case SCDl_TAG:\n        case SNDC_TAG:\n        case SDEN_TAG:\n            if (!ea->audio_codec) {\n                avio_skip(pb, chunk_size);\n                break;\n            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||\n                       ea->audio_codec == CODEC_ID_MP3) {\n                num_samples = avio_rl32(pb);\n                avio_skip(pb, 8);\n                chunk_size -= 12;\n            }\n            ret = av_get_packet(pb, pkt, chunk_size);\n            if (ret < 0)\n                return ret;\n            pkt->stream_index = ea->audio_stream_index;\n\n            switch (ea->audio_codec) {\n            case CODEC_ID_ADPCM_EA:\n            case CODEC_ID_ADPCM_EA_R1:\n            case CODEC_ID_ADPCM_EA_R2:\n            case CODEC_ID_ADPCM_IMA_EA_EACS:\n                pkt->duration = AV_RL32(pkt->data);\n                break;\n            case CODEC_ID_ADPCM_EA_R3:\n                pkt->duration = AV_RB32(pkt->data);\n                break;\n            case CODEC_ID_ADPCM_IMA_EA_SEAD:\n                pkt->duration = ret * 2 / ea->num_channels;\n                break;\n            case CODEC_ID_PCM_S16LE_PLANAR:\n            case CODEC_ID_MP3:\n                pkt->duration = num_samples;\n                break;\n            default:\n                pkt->duration = chunk_size / (ea->bytes * ea->num_channels);\n            }\n\n            packet_read = 1;\n            break;\n\n        /* ending tag */\n        case 0:\n        case ISNe_TAG:\n        case SCEl_TAG:\n        case SEND_TAG:\n        case SEEN_TAG:\n            ret = AVERROR(EIO);\n            packet_read = 1;\n            break;\n\n        case MVIh_TAG:\n        case kVGT_TAG:\n        case pQGT_TAG:\n        case TGQs_TAG:\n        case MADk_TAG:\n            key = AV_PKT_FLAG_KEY;\n        case MVIf_TAG:\n        case fVGT_TAG:\n        case MADm_TAG:\n        case MADe_TAG:\n            avio_seek(pb, -8, SEEK_CUR);     // include chunk preamble\n            chunk_size += 8;\n            goto get_video_packet;\n\n        case mTCD_TAG:\n            avio_skip(pb, 8);  // skip ea dct header\n            chunk_size -= 8;\n            goto get_video_packet;\n\n        case MV0K_TAG:\n        case MPCh_TAG:\n        case pIQT_TAG:\n            key = AV_PKT_FLAG_KEY;\n        case MV0F_TAG:\nget_video_packet:\n            ret = av_get_packet(pb, pkt, chunk_size);\n            if (ret < 0)\n                return ret;\n            pkt->stream_index = ea->video_stream_index;\n            pkt->flags |= key;\n            packet_read = 1;\n            break;\n\n        default:\n            avio_skip(pb, chunk_size);\n            break;\n        }\n    }\n\n    return ret;\n}", "target": 1}
{"idx": 5703, "func": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)\n{\n    MpegEncContext *s = &r->s;\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n    int A[2] = {0}, B[2], C[2];\n    int i, j;\n    int mx, my;\n    int avail_index = avail_indexes[subblock_no];\n    int c_off = part_sizes_w[block_type];\n\n    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*s->b8_stride;\n    if(subblock_no == 3)\n        c_off = -1;\n\n    if(r->avail_cache[avail_index - 1]){\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][0];\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][1];\n    }\n    if(r->avail_cache[avail_index - 4]){\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][0];\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];\n    }else{\n        B[0] = A[0];\n        B[1] = A[1];\n    }\n    if(!r->avail_cache[avail_index - 4 + c_off]){\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][0];\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][1];\n        }else{\n            C[0] = A[0];\n            C[1] = A[1];\n        }\n    }else{\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][0];\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][1];\n    }\n    mx = mid_pred(A[0], B[0], C[0]);\n    my = mid_pred(A[1], B[1], C[1]);\n    mx += r->dmv[dmv_no][0];\n    my += r->dmv[dmv_no][1];\n    for(j = 0; j < part_sizes_h[block_type]; j++){\n        for(i = 0; i < part_sizes_w[block_type]; i++){\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][0] = mx;\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][1] = my;\n        }\n    }\n}", "target": 1}
{"idx": 5704, "func": "static int decode_hq_slice(DiracContext *s, DiracSlice *slice, uint8_t *tmp_buf)\n{\n    int i, level, orientation, quant_idx;\n    int qfactor[MAX_DWT_LEVELS][4], qoffset[MAX_DWT_LEVELS][4];\n    GetBitContext *gb = &slice->gb;\n    SliceCoeffs coeffs_num[MAX_DWT_LEVELS];\n\n    skip_bits_long(gb, 8*s->highquality.prefix_bytes);\n    quant_idx = get_bits(gb, 8);\n\n    if (quant_idx > DIRAC_MAX_QUANT_INDEX) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid quantization index - %i\\n\", quant_idx);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n    for (level = 0; level < s->wavelet_depth; level++) {\n        for (orientation = !!level; orientation < 4; orientation++) {\n            const int quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);\n            qfactor[level][orientation] = ff_dirac_qscale_tab[quant];\n            qoffset[level][orientation] = ff_dirac_qoffset_intra_tab[quant] + 2;\n        }\n    }\n\n    /* Luma + 2 Chroma planes */\n    for (i = 0; i < 3; i++) {\n        int coef_num, coef_par, off = 0;\n        int64_t length = s->highquality.size_scaler*get_bits(gb, 8);\n        int64_t bits_end = get_bits_count(gb) + 8*length;\n        const uint8_t *addr = align_get_bits(gb);\n\n        if (length*8 > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"end too far away\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        coef_num = subband_coeffs(s, slice->slice_x, slice->slice_y, i, coeffs_num);\n\n        if (s->pshift)\n            coef_par = ff_dirac_golomb_read_32bit(s->reader_ctx, addr,\n                                                  length, tmp_buf, coef_num);\n        else\n            coef_par = ff_dirac_golomb_read_16bit(s->reader_ctx, addr,\n                                                  length, tmp_buf, coef_num);\n\n        if (coef_num > coef_par) {\n            const int start_b = coef_par * (1 << (s->pshift + 1));\n            const int end_b   = coef_num * (1 << (s->pshift + 1));\n            memset(&tmp_buf[start_b], 0, end_b - start_b);\n        }\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n            const SliceCoeffs *c = &coeffs_num[level];\n            for (orientation = !!level; orientation < 4; orientation++) {\n                const SubBand *b1 = &s->plane[i].band[level][orientation];\n                uint8_t *buf = b1->ibuf + c->top * b1->stride + (c->left << (s->pshift + 1));\n\n                /* Change to c->tot_h <= 4 for AVX2 dequantization */\n                const int qfunc = s->pshift + 2*(c->tot_h <= 2);\n                s->diracdsp.dequant_subband[qfunc](&tmp_buf[off], buf, b1->stride,\n                                                   qfactor[level][orientation],\n                                                   qoffset[level][orientation],\n                                                   c->tot_v, c->tot_h);\n\n                off += c->tot << (s->pshift + 1);\n            }\n        }\n\n        skip_bits_long(gb, bits_end - get_bits_count(gb));\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5705, "func": "static int matroska_parse_rm_audio(MatroskaDemuxContext *matroska,\n                                   MatroskaTrack *track,\n                                   AVStream *st,\n                                   uint8_t *data, int size,\n                                   uint64_t timecode,\n                                   int64_t pos)\n{\n    int a = st->codec->block_align;\n    int sps = track->audio.sub_packet_size;\n    int cfs = track->audio.coded_framesize;\n    int h = track->audio.sub_packet_h;\n    int y = track->audio.sub_packet_cnt;\n    int w = track->audio.frame_size;\n    int x;\n\n    if (!track->audio.pkt_cnt) {\n        if (track->audio.sub_packet_cnt == 0)\n            track->audio.buf_timecode = timecode;\n        if (st->codec->codec_id == AV_CODEC_ID_RA_288) {\n            if (size < cfs * h / 2) {\n                av_log(matroska->ctx, AV_LOG_ERROR,\n                       \"Corrupt int4 RM-style audio packet size\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            for (x=0; x<h/2; x++)\n                memcpy(track->audio.buf+x*2*w+y*cfs,\n                       data+x*cfs, cfs);\n        } else if (st->codec->codec_id == AV_CODEC_ID_SIPR) {\n            if (size < w) {\n                av_log(matroska->ctx, AV_LOG_ERROR,\n                       \"Corrupt sipr RM-style audio packet size\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            memcpy(track->audio.buf + y*w, data, w);\n        } else {\n            if (size < sps * w / sps || h<=0) {\n                av_log(matroska->ctx, AV_LOG_ERROR,\n                       \"Corrupt generic RM-style audio packet size\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            for (x=0; x<w/sps; x++)\n                memcpy(track->audio.buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n        }\n\n        if (++track->audio.sub_packet_cnt >= h) {\n            if (st->codec->codec_id == AV_CODEC_ID_SIPR)\n                ff_rm_reorder_sipr_data(track->audio.buf, h, w);\n            track->audio.sub_packet_cnt = 0;\n            track->audio.pkt_cnt = h*w / a;\n        }\n    }\n\n    while (track->audio.pkt_cnt) {\n        AVPacket *pkt = NULL;\n        if (!(pkt = av_mallocz(sizeof(AVPacket))) || av_new_packet(pkt, a) < 0){\n            av_free(pkt);\n            return AVERROR(ENOMEM);\n        }\n        memcpy(pkt->data, track->audio.buf\n               + a * (h*w / a - track->audio.pkt_cnt--), a);\n        pkt->pts = track->audio.buf_timecode;\n        track->audio.buf_timecode = AV_NOPTS_VALUE;\n        pkt->pos = pos;\n        pkt->stream_index = st->index;\n        dynarray_add(&matroska->packets,&matroska->num_packets,pkt);\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5706, "func": "int BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\n                    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\n{\n    int i, j, bits, ret = 0, wstart, wend, window, wvalue;\n    int start = 1;\n    BIGNUM *d, *r;\n    const BIGNUM *aa;\n    /* Table of variables obtained from 'ctx' */\n    BIGNUM *val[TABLE_SIZE];\n    BN_MONT_CTX *mont = NULL;\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0\n            || BN_get_flags(a, BN_FLG_CONSTTIME) != 0\n            || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {\n        return BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont);\n    }\n\n    bn_check_top(a);\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return 0;\n    }\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1, or x**0 mod -1 is still zero. */\n        if (BN_abs_is_word(m, 1)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    r = BN_CTX_get(ctx);\n    val[0] = BN_CTX_get(ctx);\n    if (val[0] == NULL)\n        goto err;\n\n    /*\n     * If this is not done, things will break in the montgomery part\n     */\n\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n    if (a->neg || BN_ucmp(a, m) >= 0) {\n        if (!BN_nnmod(val[0], a, m, ctx))\n            goto err;\n        aa = val[0];\n    } else\n        aa = a;\n    if (BN_is_zero(aa)) {\n        BN_zero(rr);\n        ret = 1;\n        goto err;\n    }\n    if (!BN_to_montgomery(val[0], aa, mont, ctx))\n        goto err;               /* 1 */\n\n    window = BN_window_bits_for_exponent_size(bits);\n    if (window > 1) {\n        if (!BN_mod_mul_montgomery(d, val[0], val[0], mont, ctx))\n            goto err;           /* 2 */\n        j = 1 << (window - 1);\n        for (i = 1; i < j; i++) {\n            if (((val[i] = BN_CTX_get(ctx)) == NULL) ||\n                !BN_mod_mul_montgomery(val[i], val[i - 1], d, mont, ctx))\n                goto err;\n        }\n    }\n\n    start = 1;                  /* This is used to avoid multiplication etc\n                                 * when there is only the value '1' in the\n                                 * buffer. */\n    wvalue = 0;                 /* The 'value' of the window */\n    wstart = bits - 1;          /* The top bit of the window */\n    wend = 0;                   /* The bottom bit of the window */\n\n#if 1                           /* by Shay Gueron's suggestion */\n    j = m->top;                 /* borrow j */\n    if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\n        if (bn_wexpand(r, j) == NULL)\n            goto err;\n        /* 2^(top*BN_BITS2) - m */\n        r->d[0] = (0 - m->d[0]) & BN_MASK2;\n        for (i = 1; i < j; i++)\n            r->d[i] = (~m->d[i]) & BN_MASK2;\n        r->top = j;\n        /*\n         * Upper words will be zero if the corresponding words of 'm' were\n         * 0xfff[...], so decrement r->top accordingly.\n         */\n        bn_correct_top(r);\n    } else\n#endif\n    if (!BN_to_montgomery(r, BN_value_one(), mont, ctx))\n        goto err;\n    for (;;) {\n        if (BN_is_bit_set(p, wstart) == 0) {\n            if (!start) {\n                if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\n                    goto err;\n            }\n            if (wstart == 0)\n                break;\n            wstart--;\n            continue;\n        }\n        /*\n         * We now have wstart on a 'set' bit, we now need to work out how bit\n         * a window to do.  To do this we need to scan forward until the last\n         * set bit before the end of the window\n         */\n        j = wstart;\n        wvalue = 1;\n        wend = 0;\n        for (i = 1; i < window; i++) {\n            if (wstart - i < 0)\n                break;\n            if (BN_is_bit_set(p, wstart - i)) {\n                wvalue <<= (i - wend);\n                wvalue |= 1;\n                wend = i;\n            }\n        }\n\n        /* wend is the size of the current window */\n        j = wend + 1;\n        /* add the 'bytes above' */\n        if (!start)\n            for (i = 0; i < j; i++) {\n                if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\n                    goto err;\n            }\n\n        /* wvalue will be an odd number < 2^window */\n        if (!BN_mod_mul_montgomery(r, r, val[wvalue >> 1], mont, ctx))\n            goto err;\n\n        /* move the 'window' down further */\n        wstart -= wend + 1;\n        wvalue = 0;\n        start = 0;\n        if (wstart < 0)\n            break;\n    }\n#if defined(SPARC_T4_MONT)\n    if (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) {\n        j = mont->N.top;        /* borrow j */\n        val[0]->d[0] = 1;       /* borrow val[0] */\n        for (i = 1; i < j; i++)\n            val[0]->d[i] = 0;\n        val[0]->top = j;\n        if (!BN_mod_mul_montgomery(rr, r, val[0], mont, ctx))\n            goto err;\n    } else\n#endif\n    if (!BN_from_montgomery(rr, r, mont, ctx))\n        goto err;\n    ret = 1;\n err:\n    if (in_mont == NULL)\n        BN_MONT_CTX_free(mont);\n    BN_CTX_end(ctx);\n    bn_check_top(rr);\n    return ret;\n}", "target": 1}
{"idx": 5707, "func": "int CRYPTO_add_lock(int *pointer, int amount, int type, const char *file,\n\t     int line)\n\t{\n\tint ret;\n\n\tif (add_lock_callback != NULL)\n\t\t{\n#ifdef LOCK_DEBUG\n\t\tint before= *pointer;\n#endif\n\n\t\tret=add_lock_callback(pointer,amount,type,file,line);\n#ifdef LOCK_DEBUG\n\t\tfprintf(stderr,\"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\\n\",\n\t\t\tCRYPTO_thread_id(),\n\t\t\tbefore,amount,ret,\n\t\t\tCRYPTO_get_lock_name(type),\n\t\t\tfile,line);\n#endif\n\t\t*pointer=ret;\n\t\t}\n\telse\n\t\t{\n\t\tCRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,file,line);\n\n\t\tret= *pointer+amount;\n#ifdef LOCK_DEBUG\n\t\tfprintf(stderr,\"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\\n\",\n\t\t\tCRYPTO_thread_id(),\n\t\t\t*pointer,amount,ret,\n\t\t\tCRYPTO_get_lock_name(type),\n\t\t\tfile,line);\n#endif\n\t\t*pointer=ret;\n\t\tCRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,file,line);\n\t\t}\n\treturn(ret);\n\t}", "target": 1}
{"idx": 5708, "func": "static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n                       Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,\n                       int width, int height, int bandpos)\n{\n    int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n    int clnpass_cnt = 0;\n    int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;\n    int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;\n\n    av_assert0(width  <= JPEG2000_MAX_CBLKW);\n    av_assert0(height <= JPEG2000_MAX_CBLKH);\n\n    for (y = 0; y < height; y++)\n        memset(t1->data[y], 0, width * sizeof(**t1->data));\n\n    /* If code-block contains no compressed data: nothing to do. */\n    if (!cblk->length)\n        return 0;\n\n    for (y = 0; y < height + 2; y++)\n        memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));\n\n    cblk->data[cblk->length] = 0xff;\n    cblk->data[cblk->length+1] = 0xff;\n    ff_mqc_initdec(&t1->mqc, cblk->data, 0, 1);\n\n    while (passno--) {\n        switch(pass_t) {\n        case 0:\n            decode_sigpass(t1, width, height, bpno + 1, bandpos,\n                           bpass_csty_symbol && (clnpass_cnt >= 4),\n                           vert_causal_ctx_csty_symbol);\n            break;\n        case 1:\n            decode_refpass(t1, width, height, bpno + 1);\n            break;\n        case 2:\n            decode_clnpass(s, t1, width, height, bpno + 1, bandpos,\n                           codsty->cblk_style & JPEG2000_CBLK_SEGSYM,\n                           vert_causal_ctx_csty_symbol);\n            break;\n        }\n\n        pass_t++;\n        if (pass_t == 3) {\n            bpno--;\n            pass_t = 0;\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": 5709, "func": "CERT *ssl_cert_new(void)\n\t{\n\tCERT *ret;\n\n\tret=(CERT *)OPENSSL_malloc(sizeof(CERT));\n\tif (ret == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_CERT_NEW,ERR_R_MALLOC_FAILURE);\n\t\treturn(NULL);\n\t\t}\n\tmemset(ret,0,sizeof(CERT));\n\n\tret->key= &(ret->pkeys[SSL_PKEY_RSA_ENC]);\n\tret->references=1;\n\tssl_cert_set_default_md(ret);\n\tret->sec_cb = ssl_security_default_callback;\n\tret->sec_level = OPENSSL_TLS_SECURITY_LEVEL;\n\tret->sec_ex = NULL;\n\treturn(ret);\n\t}", "target": 0}
{"idx": 5710, "func": "static void arith2_normalise(ArithCoder *c)\n{\n    while ((c->high >> 15) - (c->low >> 15) < 2) {\n        if ((c->low ^ c->high) & 0x10000) {\n            c->high  ^= 0x8000;\n            c->value ^= 0x8000;\n            c->low   ^= 0x8000;\n        }\n        c->high  = c->high  << 8 & 0xFFFFFF | 0xFF;\n        c->value = c->value << 8 & 0xFFFFFF | bytestream2_get_byte(c->gbc.gB);\n        c->low   = c->low   << 8 & 0xFFFFFF;\n    }\n}", "target": 1}
{"idx": 5711, "func": "static int sk_reserve(OPENSSL_STACK *st, int n, int exact)\n{\n    const void **tmpdata;\n    int num_alloc;\n\n    /* Check to see the reservation isn't exceeding the hard limit */\n    if (n > max_nodes - st->num)\n        return 0;\n\n    /* Figure out the new size */\n    num_alloc = st->num + n;\n    if (num_alloc < min_nodes)\n        num_alloc = min_nodes;\n\n    /* If |st->data| allocation was postponed */\n    if (st->data == NULL) {\n        /*\n         * At this point, |st->num_alloc| and |st->num| are 0;\n         * so |num_alloc| value is |n| or |min_nodes| if greater than |n|.\n         */\n        if ((st->data = OPENSSL_zalloc(sizeof(void *) * num_alloc)) == NULL) {\n            /* STACKerr(STACK_F_SK_RESERVE, ERR_R_MALLOC_FAILURE); */\n            return 0;\n        }\n        st->num_alloc = num_alloc;\n        return 1;\n    }\n\n    if (!exact) {\n        if (num_alloc <= st->num_alloc)\n            return 1;\n        num_alloc = compute_growth(num_alloc, st->num_alloc);\n        if (num_alloc == 0)\n            return 0;\n    } else if (num_alloc == st->num_alloc) {\n        return 1;\n    }\n\n    tmpdata = OPENSSL_realloc((void *)st->data, sizeof(void *) * num_alloc);\n    if (tmpdata == NULL)\n        return 0;\n\n    st->data = tmpdata;\n    st->num_alloc = num_alloc;\n    return 1;\n}", "target": 1}
{"idx": 5712, "func": "const AVOption *av_next_option(void *obj, const AVOption *last)\n{\n    if (last && last[1].name) return ++last;\n    else if (last || !(*(AVClass**)obj)->option->name) return NULL;\n    else                      return (*(AVClass**)obj)->option;\n}", "target": 1}
{"idx": 5713, "func": "static int mov_text_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_sub_ptr, AVPacket *avpkt)\n{\n    AVSubtitle *sub = data;\n    int ret, ts_start, ts_end;\n    AVBPrint buf;\n    char *ptr = avpkt->data;\n    char *end;\n    //char *ptr_temp;\n    int text_length, tsmb_type, style_entries, tsmb_size;\n    int **style_start = {0,};\n    int **style_end = {0,};\n    int **style_flags = {0,};\n    const uint8_t *tsmb;\n    int index, i;\n    int *flag;\n    int *style_pos;\n\n    if (!ptr || avpkt->size < 2)\n        return AVERROR_INVALIDDATA;\n\n    /*\n     * A packet of size two with value zero is an empty subtitle\n     * used to mark the end of the previous non-empty subtitle.\n     * We can just drop them here as we have duration information\n     * already. If the value is non-zero, then it's technically a\n     * bad packet.\n     */\n    if (avpkt->size == 2)\n        return AV_RB16(ptr) == 0 ? 0 : AVERROR_INVALIDDATA;\n\n    /*\n     * The first two bytes of the packet are the length of the text string\n     * In complex cases, there are style descriptors appended to the string\n     * so we can't just assume the packet size is the string size.\n     */\n    text_length = AV_RB16(ptr);\n    end = ptr + FFMIN(2 + text_length, avpkt->size);\n    ptr += 2;\n\n    ts_start = av_rescale_q(avpkt->pts,\n                            avctx->time_base,\n                            (AVRational){1,100});\n    ts_end   = av_rescale_q(avpkt->pts + avpkt->duration,\n                            avctx->time_base,\n                            (AVRational){1,100});\n\n    tsmb_size = 0;\n    // Note that the spec recommends lines be no longer than 2048 characters.\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);\n    if (text_length + 2 != avpkt->size) {\n        while (text_length + 2 + tsmb_size < avpkt->size)  {\n            tsmb = ptr + text_length + tsmb_size;\n            tsmb_size = AV_RB32(tsmb);\n            tsmb += 4;\n            tsmb_type = AV_RB32(tsmb);\n            tsmb += 4;\n\n            if (tsmb_type == MKBETAG('s','t','y','l')) {\n                style_entries = AV_RB16(tsmb);\n                tsmb += 2;\n\n                for(i = 0; i < style_entries; i++) {\n                    style_pos = av_malloc(4);\n                    *style_pos = AV_RB16(tsmb);\n                    index = i;\n                    av_dynarray_add(&style_start, &index, style_pos);\n                    tsmb += 2;\n                    style_pos = av_malloc(4);\n                    *style_pos = AV_RB16(tsmb);\n                    index = i;\n                    av_dynarray_add(&style_end, &index, style_pos);\n                    tsmb += 2;\n                    // fontID = AV_RB16(tsmb);\n                    tsmb += 2;\n                    flag = av_malloc(4);\n                    *flag = AV_RB8(tsmb);\n                    index = i;\n                    av_dynarray_add(&style_flags, &index, flag);\n                    //fontsize=AV_RB8(tsmb);\n                    tsmb += 2;\n                    // text-color-rgba\n                    tsmb += 4;\n                }\n                text_to_ass(&buf, ptr, end, style_start, style_end, style_flags, style_entries);\n                av_freep(&style_start);\n                av_freep(&style_end);\n                av_freep(&style_flags);\n            }\n        }\n    } else\n        text_to_ass(&buf, ptr, end, NULL, NULL, 0, 0);\n\n    ret = ff_ass_add_rect_bprint(sub, &buf, ts_start, ts_end - ts_start);\n    av_bprint_finalize(&buf, NULL);\n    if (ret < 0)\n        return ret;\n    *got_sub_ptr = sub->num_rects > 0;\n    return avpkt->size;\n}", "target": 1}
{"idx": 5714, "func": "static int add_attribute_object(X509_REQ *req, char *text, const char *def,\n                                char *value, int nid, int n_min,\n                                int n_max, unsigned long chtype)\n{\n    int i;\n    static char buf[1024];\n\n start:\n    if (!batch)\n        BIO_printf(bio_err, \"%s [%s]:\", text, def);\n    (void)BIO_flush(bio_err);\n    if (value != NULL) {\n        strcpy(buf, value);\n        strcat(buf, \"\\n\");\n        BIO_printf(bio_err, \"%s\\n\", value);\n    } else {\n        buf[0] = '\\0';\n        if (!batch) {\n            if (!fgets(buf, sizeof buf, stdin))\n                return 0;\n        } else {\n            buf[0] = '\\n';\n            buf[1] = '\\0';\n        }\n    }\n\n    if (buf[0] == '\\0')\n        return 0;\n    if (buf[0] == '\\n') {\n        if ((def == NULL) || (def[0] == '\\0'))\n            return 1;\n        strcpy(buf, def);\n        strcat(buf, \"\\n\");\n    } else if ((buf[0] == '.') && (buf[1] == '\\n')) {\n        return 1;\n    }\n\n    i = strlen(buf);\n    if (buf[i - 1] != '\\n') {\n        BIO_printf(bio_err, \"weird input :-(\\n\");\n        return 0;\n    }\n    buf[--i] = '\\0';\n#ifdef CHARSET_EBCDIC\n    ebcdic2ascii(buf, buf, i);\n#endif\n    if (!req_check_len(i, n_min, n_max)) {\n        if (batch || value)\n            return 0;\n        goto start;\n    }\n\n    if (!X509_REQ_add1_attr_by_NID(req, nid, chtype,\n                                   (unsigned char *)buf, -1)) {\n        BIO_printf(bio_err, \"Error adding attribute\\n\");\n        ERR_print_errors(bio_err);\n        goto err;\n    }\n\n    return (1);\n err:\n    return (0);\n}", "target": 0}
{"idx": 5715, "func": "static int mp3_write_trailer(struct AVFormatContext *s)\n{\n    uint8_t buf[ID3v1_TAG_SIZE];\n    MP3Context *mp3 = s->priv_data;\n\n    if (mp3->pics_to_write) {\n        av_log(s, AV_LOG_WARNING, \"No packets were sent for some of the \"\n               \"attached pictures.\\n\");\n        mp3_queue_flush(s);\n    }\n\n    /* write the id3v1 tag */\n    if (mp3->write_id3v1 && id3v1_create_tag(s, buf) > 0) {\n        avio_write(s->pb, buf, ID3v1_TAG_SIZE);\n    }\n\n    if (mp3->xing_offset)\n        mp3_update_xing(s);\n\n    av_freep(&mp3->xing_frame);\n\n    return 0;\n}", "target": 0}
{"idx": 5716, "func": "int test_rshift(BIO *bp,BN_CTX *ctx)\n\t{\n\tBIGNUM *a,*b,*c,*d,*e;\n\tint i;\n\n\ta=BN_new();\n\tb=BN_new();\n\tc=BN_new();\n\td=BN_new();\n\te=BN_new();\n\tBN_one(c);\n\n\tBN_bntest_rand(a,200,0,0); /**/\n\ta->neg=rand_neg();\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_rshift(b,a,i+1);\n\t\tBN_add(c,c,c);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,a);\n\t\t\t\tBIO_puts(bp,\" / \");\n\t\t\t\tBN_print(bp,c);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,b);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(d,e,a,c,ctx);\n\t\tBN_sub(d,d,b);\n\t\tif(!BN_is_zero(d))\n\t\t    {\n\t\t    fprintf(stderr,\"Right shift test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(a);\n\tBN_free(b);\n\tBN_free(c);\n\tBN_free(d);\n\tBN_free(e);\n\treturn(1);\n\t}", "target": 1}
{"idx": 5717, "func": "static void value_free_hash(CONF_VALUE *a, LHASH *conf)\n\t{\n\tif (a->name != NULL)\n\t\t{\n\t\ta=(CONF_VALUE *)lh_delete(conf,a);\n\t\t}\n\t}", "target": 1}
{"idx": 5718, "func": "void FUNC(ff_emulated_edge_mc)(uint8_t *buf, const uint8_t *src, int linesize, int block_w, int block_h,\n                                    int src_x, int src_y, int w, int h){\n    int x, y;\n    int start_y, start_x, end_y, end_x;\n\n    if(src_y>= h){\n        src+= (h-1-src_y)*linesize;\n        src_y=h-1;\n    }else if(src_y<=-block_h){\n        src+= (1-block_h-src_y)*linesize;\n        src_y=1-block_h;\n    }\n    if(src_x>= w){\n        src+= (w-1-src_x)*sizeof(pixel);\n        src_x=w-1;\n    }else if(src_x<=-block_w){\n        src+= (1-block_w-src_x)*sizeof(pixel);\n        src_x=1-block_w;\n    }\n\n    start_y= FFMAX(0, -src_y);\n    start_x= FFMAX(0, -src_x);\n    end_y= FFMIN(block_h, h-src_y);\n    end_x= FFMIN(block_w, w-src_x);\n    av_assert2(start_y < end_y && block_h);\n    av_assert2(start_x < end_x && block_w);\n\n    w    = end_x - start_x;\n    src += start_y*linesize + start_x*sizeof(pixel);\n    buf += start_x*sizeof(pixel);\n\n    //top\n    for(y=0; y<start_y; y++){\n        memcpy(buf, src, w*sizeof(pixel));\n        buf += linesize;\n    }\n\n    // copy existing part\n    for(; y<end_y; y++){\n        memcpy(buf, src, w*sizeof(pixel));\n        src += linesize;\n        buf += linesize;\n    }\n\n    //bottom\n    src -= linesize;\n    for(; y<block_h; y++){\n        memcpy(buf, src, w*sizeof(pixel));\n        buf += linesize;\n    }\n\n    buf -= block_h * linesize + start_x*sizeof(pixel);\n    while (block_h--){\n        pixel *bufp = (pixel*)buf;\n       //left\n        for(x=0; x<start_x; x++){\n            bufp[x] = bufp[start_x];\n        }\n\n       //right\n        for(x=end_x; x<block_w; x++){\n            bufp[x] = bufp[end_x - 1];\n        }\n        buf += linesize;\n    }\n}", "target": 1}
{"idx": 5719, "func": "static void sha256_transform(uint32_t *state, const uint8_t buffer[64])\n{\n    unsigned int i, a, b, c, d, e, f, g, h;\n    uint32_t block[64];\n    uint32_t T1;\n\n    a = state[0];\n    b = state[1];\n    c = state[2];\n    d = state[3];\n    e = state[4];\n    f = state[5];\n    g = state[6];\n    h = state[7];\n#if CONFIG_SMALL\n    for (i = 0; i < 64; i++) {\n        uint32_t T2;\n        if (i < 16)\n            T1 = blk0(i);\n        else\n            T1 = blk(i);\n        T1 += h + Sigma1_256(e) + Ch(e, f, g) + K256[i];\n        T2 = Sigma0_256(a) + Maj(a, b, c);\n        h = g;\n        g = f;\n        f = e;\n        e = d + T1;\n        d = c;\n        c = b;\n        b = a;\n        a = T1 + T2;\n    }\n#else\n\n    i = 0;\n#define R256_0 \\\n    ROUND256_0_TO_15(a, b, c, d, e, f, g, h); \\\n    ROUND256_0_TO_15(h, a, b, c, d, e, f, g); \\\n    ROUND256_0_TO_15(g, h, a, b, c, d, e, f); \\\n    ROUND256_0_TO_15(f, g, h, a, b, c, d, e); \\\n    ROUND256_0_TO_15(e, f, g, h, a, b, c, d); \\\n    ROUND256_0_TO_15(d, e, f, g, h, a, b, c); \\\n    ROUND256_0_TO_15(c, d, e, f, g, h, a, b); \\\n    ROUND256_0_TO_15(b, c, d, e, f, g, h, a)\n\n    R256_0; R256_0;\n\n#define R256_16 \\\n    ROUND256_16_TO_63(a, b, c, d, e, f, g, h); \\\n    ROUND256_16_TO_63(h, a, b, c, d, e, f, g); \\\n    ROUND256_16_TO_63(g, h, a, b, c, d, e, f); \\\n    ROUND256_16_TO_63(f, g, h, a, b, c, d, e); \\\n    ROUND256_16_TO_63(e, f, g, h, a, b, c, d); \\\n    ROUND256_16_TO_63(d, e, f, g, h, a, b, c); \\\n    ROUND256_16_TO_63(c, d, e, f, g, h, a, b); \\\n    ROUND256_16_TO_63(b, c, d, e, f, g, h, a)\n\n    R256_16; R256_16; R256_16;\n    R256_16; R256_16; R256_16;\n#endif\n    state[0] += a;\n    state[1] += b;\n    state[2] += c;\n    state[3] += d;\n    state[4] += e;\n    state[5] += f;\n    state[6] += g;\n    state[7] += h;\n}", "target": 0}
{"idx": 5720, "func": "static inline int get_chroma_qp(H264Context *h, int t, int qscale){\n    return h->pps.chroma_qp_table[t][qscale];\n}", "target": 1}
{"idx": 5721, "func": "static int adx_read_header(AVFormatContext *s)\n{\n    ADXDemuxerContext *c = s->priv_data;\n    AVCodecParameters *par;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    par = s->streams[0]->codecpar;\n\n    if (avio_rb16(s->pb) != 0x8000)\n        return AVERROR_INVALIDDATA;\n    c->header_size = avio_rb16(s->pb) + 4;\n    avio_seek(s->pb, -4, SEEK_CUR);\n\n    if (ff_get_extradata(s, par, s->pb, c->header_size) < 0)\n        return AVERROR(ENOMEM);\n\n    if (par->extradata_size < 12) {\n        av_log(s, AV_LOG_ERROR, \"Invalid extradata size.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    par->channels    = AV_RB8 (par->extradata + 7);\n    par->sample_rate = AV_RB32(par->extradata + 8);\n\n    if (par->channels <= 0) {\n        av_log(s, AV_LOG_ERROR, \"invalid number of channels %d\\n\", par->channels);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (par->sample_rate <= 0) {\n        av_log(s, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", par->sample_rate);\n        return AVERROR_INVALIDDATA;\n    }\n\n    par->codec_type  = AVMEDIA_TYPE_AUDIO;\n    par->codec_id    = s->iformat->raw_codec_id;\n    par->bit_rate    = par->sample_rate * par->channels * BLOCK_SIZE * 8LL / BLOCK_SAMPLES;\n\n    avpriv_set_pts_info(st, 64, BLOCK_SAMPLES, par->sample_rate);\n\n    return 0;\n}", "target": 1}
{"idx": 5722, "func": "static void fill_gv_table(int table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize, const int inc)\n{\n    int i;\n    int off    = -(inc >> 9);\n\n    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {\n        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;\n        table[i] = elemsize * (off + (cb >> 16));\n    }\n}", "target": 1}
{"idx": 5723, "func": "static const uint8_t *decode_nal(H264Context *h, const uint8_t *src, int *dst_length, int *consumed, int length){\n    int i, si, di;\n    uint8_t *dst;\n    int bufidx;\n\n//    src[0]&0x80;                //forbidden bit\n    h->nal_ref_idc= src[0]>>5;\n    h->nal_unit_type= src[0]&0x1F;\n\n    src++; length--;\n#if 0\n    for(i=0; i<length; i++)\n        printf(\"%2X \", src[i]);\n#endif\n    for(i=0; i+1<length; i+=2){\n        if(src[i]) continue;\n        if(i>0 && src[i-1]==0) i--;\n        if(i+2<length && src[i+1]==0 && src[i+2]<=3){\n            if(src[i+2]!=3){\n                /* startcode, so we must be past the end */\n                length=i;\n            }\n            break;\n        }\n    }\n\n    if(i>=length-1){ //no escaped 0\n        *dst_length= length;\n        *consumed= length+1; //+1 for the header\n        return src;\n    }\n\n    bufidx = h->nal_unit_type == NAL_DPC ? 1 : 0; // use second escape buffer for inter data\n    h->rbsp_buffer[bufidx]= av_fast_realloc(h->rbsp_buffer[bufidx], &h->rbsp_buffer_size[bufidx], length+FF_INPUT_BUFFER_PADDING_SIZE);\n    dst= h->rbsp_buffer[bufidx];\n\n    if (dst == NULL){\n        return NULL;\n    }\n\n//printf(\"decoding esc\\n\");\n    si=di=0;\n    while(si<length){\n        //remove escapes (very rare 1:2^22)\n        if(si+2<length && src[si]==0 && src[si+1]==0 && src[si+2]<=3){\n            if(src[si+2]==3){ //escape\n                dst[di++]= 0;\n                dst[di++]= 0;\n                si+=3;\n                continue;\n            }else //next start code\n                break;\n        }\n\n        dst[di++]= src[si++];\n    }\n\n    memset(dst+di, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n    *dst_length= di;\n    *consumed= si + 1;//+1 for the header\n//FIXME store exact number of bits in the getbitcontext (it is needed for decoding)\n    return dst;\n}", "target": 0}
{"idx": 5724, "func": "static inline int decode_slice_header(AVSContext *h, GetBitContext *gb) {\n    if(h->stc > 0xAF)\n        av_log(h->s.avctx, AV_LOG_ERROR, \"unexpected start code 0x%02x\\n\", h->stc);\n    h->mby = h->stc;\n    h->mbidx = h->mby*h->mb_width;\n\n    /* mark top macroblocks as unavailable */\n    h->flags &= ~(B_AVAIL|C_AVAIL);\n    if((h->mby == 0) && (!h->qp_fixed)){\n        h->qp_fixed = get_bits1(gb);\n        h->qp = get_bits(gb,6);\n    }\n    /* inter frame or second slice can have weighting params */\n    if((h->pic_type != AV_PICTURE_TYPE_I) || (!h->pic_structure && h->mby >= h->mb_width/2))\n        if(get_bits1(gb)) { //slice_weighting_flag\n            av_log(h->s.avctx, AV_LOG_ERROR,\n                   \"weighted prediction not yet supported\\n\");\n        }\n    return 0;\n}", "target": 1}
{"idx": 5725, "func": "static int mkv_write_attachments(AVFormatContext *s)\n{\n    MatroskaMuxContext *mkv = s->priv_data;\n    AVIOContext *dyn_cp, *pb = s->pb;\n    ebml_master attachments;\n    AVLFG c;\n    int i, ret;\n\n    if (!mkv->have_attachments)\n        return 0;\n\n    mkv->attachments = av_mallocz(sizeof(*mkv->attachments));\n    if (!mkv->attachments)\n        return AVERROR(ENOMEM);\n\n    av_lfg_init(&c, av_get_random_seed());\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_ATTACHMENTS, avio_tell(pb));\n    if (ret < 0) return ret;\n\n    ret = start_ebml_master_crc32(pb, &dyn_cp, mkv, &attachments, MATROSKA_ID_ATTACHMENTS, 0);\n    if (ret < 0) return ret;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        ebml_master attached_file;\n        mkv_attachment *attachment = mkv->attachments->entries;\n        AVDictionaryEntry *t;\n        const char *mimetype = NULL;\n        uint32_t fileuid;\n\n        if (st->codecpar->codec_type != AVMEDIA_TYPE_ATTACHMENT)\n            continue;\n\n        attachment = av_realloc_array(attachment, mkv->attachments->num_entries + 1, sizeof(mkv_attachment));\n        if (!attachment)\n            return AVERROR(ENOMEM);\n        mkv->attachments->entries = attachment;\n\n        attached_file = start_ebml_master(dyn_cp, MATROSKA_ID_ATTACHEDFILE, 0);\n\n        if (t = av_dict_get(st->metadata, \"title\", NULL, 0))\n            put_ebml_string(dyn_cp, MATROSKA_ID_FILEDESC, t->value);\n        if (!(t = av_dict_get(st->metadata, \"filename\", NULL, 0))) {\n            av_log(s, AV_LOG_ERROR, \"Attachment stream %d has no filename tag.\\n\", i);\n            return AVERROR(EINVAL);\n        }\n        put_ebml_string(dyn_cp, MATROSKA_ID_FILENAME, t->value);\n        if (t = av_dict_get(st->metadata, \"mimetype\", NULL, 0))\n            mimetype = t->value;\n        else if (st->codecpar->codec_id != AV_CODEC_ID_NONE ) {\n            int i;\n            for (i = 0; ff_mkv_mime_tags[i].id != AV_CODEC_ID_NONE; i++)\n                if (ff_mkv_mime_tags[i].id == st->codecpar->codec_id) {\n                    mimetype = ff_mkv_mime_tags[i].str;\n                    break;\n                }\n            for (i = 0; ff_mkv_image_mime_tags[i].id != AV_CODEC_ID_NONE; i++)\n                if (ff_mkv_image_mime_tags[i].id == st->codecpar->codec_id) {\n                    mimetype = ff_mkv_image_mime_tags[i].str;\n                    break;\n                }\n        }\n        if (!mimetype) {\n            av_log(s, AV_LOG_ERROR, \"Attachment stream %d has no mimetype tag and \"\n                                    \"it cannot be deduced from the codec id.\\n\", i);\n            return AVERROR(EINVAL);\n        }\n\n        if (s->flags & AVFMT_FLAG_BITEXACT) {\n            struct AVSHA *sha = av_sha_alloc();\n            uint8_t digest[20];\n            if (!sha)\n                return AVERROR(ENOMEM);\n            av_sha_init(sha, 160);\n            av_sha_update(sha, st->codecpar->extradata, st->codecpar->extradata_size);\n            av_sha_final(sha, digest);\n            av_free(sha);\n            fileuid = AV_RL32(digest);\n        } else {\n            fileuid = av_lfg_get(&c);\n        }\n        av_log(s, AV_LOG_VERBOSE, \"Using %.8\"PRIx32\" for attachment %d\\n\",\n               fileuid, mkv->attachments->num_entries);\n\n        put_ebml_string(dyn_cp, MATROSKA_ID_FILEMIMETYPE, mimetype);\n        put_ebml_binary(dyn_cp, MATROSKA_ID_FILEDATA, st->codecpar->extradata, st->codecpar->extradata_size);\n        put_ebml_uint(dyn_cp, MATROSKA_ID_FILEUID, fileuid);\n        end_ebml_master(dyn_cp, attached_file);\n\n        mkv->attachments->entries[mkv->attachments->num_entries].stream_idx = i;\n        mkv->attachments->entries[mkv->attachments->num_entries++].fileuid  = fileuid;\n    }\n    end_ebml_master_crc32(pb, &dyn_cp, mkv, attachments);\n\n    return 0;\n}", "target": 0}
{"idx": 5726, "func": "static char *shorts2str(int16_t *sp, int count, const char *sep)\n{\n    int i;\n    char *ap, *ap0;\n    uint64_t component_len;\n    if (!sep) sep = \", \";\n    component_len = 7LL + strlen(sep);\n    if (count >= (INT_MAX - 1)/component_len)\n        return NULL;\n    ap = av_malloc(component_len * count + 1);\n    if (!ap)\n        return NULL;\n    ap0   = ap;\n    ap[0] = '\\0';\n    for (i = 0; i < count; i++) {\n        unsigned l = snprintf(ap, component_len, \"%d%s\", sp[i], sep);\n        if (l >= component_len) {\n            av_free(ap0);\n            return NULL;\n        }\n        ap += l;\n    }\n    ap0[strlen(ap0) - strlen(sep)] = '\\0';\n    return ap0;\n}", "target": 0}
{"idx": 5727, "func": "static inline int gsm_mult(int a, int b)\n{\n    return (int)(a * (SUINT)b + (1 << 14)) >> 15;\n}", "target": 0}
{"idx": 5728, "func": "static int adx_read_header(AVFormatContext *s)\n{\n    ADXDemuxerContext *c = s->priv_data;\n    AVCodecParameters *par;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    par = s->streams[0]->codecpar;\n\n    if (avio_rb16(s->pb) != 0x8000)\n        return AVERROR_INVALIDDATA;\n    c->header_size = avio_rb16(s->pb) + 4;\n    avio_seek(s->pb, -4, SEEK_CUR);\n\n    if (ff_get_extradata(s, par, s->pb, c->header_size) < 0)\n        return AVERROR(ENOMEM);\n\n    if (par->extradata_size < 12) {\n        av_log(s, AV_LOG_ERROR, \"Invalid extradata size.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    par->channels    = AV_RB8 (par->extradata + 7);\n    par->sample_rate = AV_RB32(par->extradata + 8);\n\n    if (par->channels <= 0) {\n        av_log(s, AV_LOG_ERROR, \"invalid number of channels %d\\n\", par->channels);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (par->sample_rate <= 0) {\n        av_log(s, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", par->sample_rate);\n        return AVERROR_INVALIDDATA;\n    }\n\n    par->codec_type  = AVMEDIA_TYPE_AUDIO;\n    par->codec_id    = s->iformat->raw_codec_id;\n    par->bit_rate    = (int64_t)par->sample_rate * par->channels * BLOCK_SIZE * 8LL / BLOCK_SAMPLES;\n\n    avpriv_set_pts_info(st, 64, BLOCK_SAMPLES, par->sample_rate);\n\n    return 0;\n}", "target": 1}
{"idx": 5729, "func": "int MD2_Update(MD2_CTX *c, const unsigned char *data, unsigned long len)\n\t{\n\tregister UCHAR *p;\n\n\tif (len == 0) return 1;\n\n\tp=c->data;\n\tif (c->num != 0)\n\t\t{\n\t\tif ((c->num+len) >= MD2_BLOCK)\n\t\t\t{\n\t\t\tmemcpy(&(p[c->num]),data,MD2_BLOCK-c->num);\n\t\t\tmd2_block(c,c->data);\n\t\t\tdata+=(MD2_BLOCK - c->num);\n\t\t\tlen-=(MD2_BLOCK - c->num);\n\t\t\tc->num=0;\n\t\t\t/* drop through and do the rest */\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tmemcpy(&(p[c->num]),data,(int)len);\n\t\t\t/* data+=len; */\n\t\t\tc->num+=(int)len;\n\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t/* we now can process the input data in blocks of MD2_BLOCK\n\t * chars and save the leftovers to c->data. */\n\twhile (len >= MD2_BLOCK)\n\t\t{\n\t\tmd2_block(c,data);\n\t\tdata+=MD2_BLOCK;\n\t\tlen-=MD2_BLOCK;\n\t\t}\n\tmemcpy(p,data,(int)len);\n\tc->num=(int)len;\n\treturn 1;\n\t}", "target": 1}
{"idx": 5730, "func": "static int vorbis_parse_audio_packet(vorbis_context *vc)\n{\n    GetBitContext *gb = &vc->gb;\n    FFTContext *mdct;\n    unsigned previous_window = vc->previous_window;\n    unsigned mode_number, blockflag, blocksize;\n    int i, j;\n    uint8_t no_residue[255];\n    uint8_t do_not_decode[255];\n    vorbis_mapping *mapping;\n    float *ch_res_ptr   = vc->channel_residues;\n    float *ch_floor_ptr = vc->channel_floors;\n    uint8_t res_chan[255];\n    unsigned res_num = 0;\n    int retlen  = 0;\n    unsigned ch_left = vc->audio_channels;\n    unsigned vlen;\n\n    if (get_bits1(gb)) {\n        av_log(vc->avccontext, AV_LOG_ERROR, \"Not a Vorbis I audio packet.\\n\");\n        return AVERROR_INVALIDDATA; // packet type not audio\n    }\n\n    if (vc->mode_count == 1) {\n        mode_number = 0;\n    } else {\n        GET_VALIDATED_INDEX(mode_number, ilog(vc->mode_count-1), vc->mode_count)\n    }\n    vc->mode_number = mode_number;\n    mapping = &vc->mappings[vc->modes[mode_number].mapping];\n\n    av_dlog(NULL, \" Mode number: %u , mapping: %d , blocktype %d\\n\", mode_number,\n            vc->modes[mode_number].mapping, vc->modes[mode_number].blockflag);\n\n    blockflag = vc->modes[mode_number].blockflag;\n    blocksize = vc->blocksize[blockflag];\n    vlen = blocksize / 2;\n    if (blockflag)\n        skip_bits(gb, 2); // previous_window, next_window\n\n    memset(ch_res_ptr,   0, sizeof(float) * vc->audio_channels * vlen); //FIXME can this be removed ?\n    memset(ch_floor_ptr, 0, sizeof(float) * vc->audio_channels * vlen); //FIXME can this be removed ?\n\n// Decode floor\n\n    for (i = 0; i < vc->audio_channels; ++i) {\n        vorbis_floor *floor;\n        int ret;\n        if (mapping->submaps > 1) {\n            floor = &vc->floors[mapping->submap_floor[mapping->mux[i]]];\n        } else {\n            floor = &vc->floors[mapping->submap_floor[0]];\n        }\n\n        ret = floor->decode(vc, &floor->data, ch_floor_ptr);\n\n        if (ret < 0) {\n            av_log(vc->avccontext, AV_LOG_ERROR, \"Invalid codebook in vorbis_floor_decode.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        no_residue[i] = ret;\n        ch_floor_ptr += vlen;\n    }\n\n// Nonzero vector propagate\n\n    for (i = mapping->coupling_steps - 1; i >= 0; --i) {\n        if (!(no_residue[mapping->magnitude[i]] & no_residue[mapping->angle[i]])) {\n            no_residue[mapping->magnitude[i]] = 0;\n            no_residue[mapping->angle[i]]     = 0;\n        }\n    }\n\n// Decode residue\n\n    for (i = 0; i < mapping->submaps; ++i) {\n        vorbis_residue *residue;\n        unsigned ch = 0;\n        int ret;\n\n        for (j = 0; j < vc->audio_channels; ++j) {\n            if ((mapping->submaps == 1) || (i == mapping->mux[j])) {\n                res_chan[j] = res_num;\n                if (no_residue[j]) {\n                    do_not_decode[ch] = 1;\n                } else {\n                    do_not_decode[ch] = 0;\n                }\n                ++ch;\n                ++res_num;\n            }\n        }\n        residue = &vc->residues[mapping->submap_residue[i]];\n        if (ch_left < ch) {\n            av_log(vc->avccontext, AV_LOG_ERROR, \"Too many channels in vorbis_floor_decode.\\n\");\n            return -1;\n        }\n        if (ch) {\n            ret = vorbis_residue_decode(vc, residue, ch, do_not_decode, ch_res_ptr, vlen, ch_left);\n            if (ret < 0)\n                return ret;\n        }\n\n        ch_res_ptr += ch * vlen;\n        ch_left -= ch;\n    }\n\n// Inverse coupling\n\n    for (i = mapping->coupling_steps - 1; i >= 0; --i) { //warning: i has to be signed\n        float *mag, *ang;\n\n        mag = vc->channel_residues+res_chan[mapping->magnitude[i]] * blocksize / 2;\n        ang = vc->channel_residues+res_chan[mapping->angle[i]]     * blocksize / 2;\n        vc->dsp.vorbis_inverse_coupling(mag, ang, blocksize / 2);\n    }\n\n// Dotproduct, MDCT\n\n    mdct = &vc->mdct[blockflag];\n\n    for (j = vc->audio_channels-1;j >= 0; j--) {\n        ch_floor_ptr = vc->channel_floors   + j           * blocksize / 2;\n        ch_res_ptr   = vc->channel_residues + res_chan[j] * blocksize / 2;\n        vc->dsp.vector_fmul(ch_floor_ptr, ch_floor_ptr, ch_res_ptr, blocksize / 2);\n        mdct->imdct_half(mdct, ch_res_ptr, ch_floor_ptr);\n    }\n\n// Overlap/add, save data for next overlapping  FPMATH\n\n    retlen = (blocksize + vc->blocksize[previous_window]) / 4;\n    for (j = 0; j < vc->audio_channels; j++) {\n        unsigned bs0 = vc->blocksize[0];\n        unsigned bs1 = vc->blocksize[1];\n        float *residue    = vc->channel_residues + res_chan[j] * blocksize / 2;\n        float *saved      = vc->saved + j * bs1 / 4;\n        float *ret        = vc->channel_floors + j * retlen;\n        float *buf        = residue;\n        const float *win  = vc->win[blockflag & previous_window];\n\n        if (blockflag == previous_window) {\n            vc->dsp.vector_fmul_window(ret, saved, buf, win, blocksize / 4);\n        } else if (blockflag > previous_window) {\n            vc->dsp.vector_fmul_window(ret, saved, buf, win, bs0 / 4);\n            memcpy(ret+bs0/2, buf+bs0/4, ((bs1-bs0)/4) * sizeof(float));\n        } else {\n            memcpy(ret, saved, ((bs1 - bs0) / 4) * sizeof(float));\n            vc->dsp.vector_fmul_window(ret + (bs1 - bs0) / 4, saved + (bs1 - bs0) / 4, buf, win, bs0 / 4);\n        }\n        memcpy(saved, buf + blocksize / 4, blocksize / 4 * sizeof(float));\n    }\n\n    vc->previous_window = blockflag;\n    return retlen;\n}", "target": 0}
{"idx": 5731, "func": "static void put_residue_header(PutBitContext *pb, vorbis_enc_residue *rc)\n{\n    int i;\n\n    put_bits(pb, 16, rc->type);\n\n    put_bits(pb, 24, rc->begin);\n    put_bits(pb, 24, rc->end);\n    put_bits(pb, 24, rc->partition_size - 1);\n    put_bits(pb, 6, rc->classifications - 1);\n    put_bits(pb, 8, rc->classbook);\n\n    for (i = 0; i < rc->classifications; i++) {\n        int j, tmp = 0;\n        for (j = 0; j < 8; j++)\n            tmp |= (rc->books[i][j] != -1) << j;\n\n        put_bits(pb, 3, tmp & 7);\n        put_bits(pb, 1, tmp > 7);\n\n        if (tmp > 7)\n            put_bits(pb, 5, tmp >> 3);\n    }\n\n    for (i = 0; i < rc->classifications; i++) {\n        int j;\n        for (j = 0; j < 8; j++)\n            if (rc->books[i][j] != -1)\n                put_bits(pb, 8, rc->books[i][j]);\n    }\n}", "target": 1}
{"idx": 5732, "func": "static int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    MOVStts *ctts_data;\n    uint64_t offset;\n    int64_t dts;\n    int data_offset = 0;\n    unsigned entries, first_sample_flags = frag->flags;\n    int flags, distance, i;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding track id %u\\n\", frag->track_id);\n        return AVERROR_INVALIDDATA;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id+1 != frag->stsd_id && sc->pseudo_stream_id != -1)\n        return 0;\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n    entries = avio_rb32(pb);\n    av_log(c->fc, AV_LOG_TRACE, \"flags 0x%x entries %u\\n\", flags, entries);\n\n    /* Always assume the presence of composition time offsets.\n     * Without this assumption, for instance, we cannot deal with a track in fragmented movies that meet the following.\n     *  1) in the initial movie, there are no samples.\n     *  2) in the first movie fragment, there is only one sample without composition time offset.\n     *  3) in the subsequent movie fragments, there are samples with composition time offset. */\n    if (!sc->ctts_count && sc->sample_count)\n    {\n        /* Complement ctts table if moov atom doesn't have ctts atom. */\n        ctts_data = av_fast_realloc(NULL, &sc->ctts_allocated_size, sizeof(*sc->ctts_data) * sc->sample_count);\n        if (!ctts_data)\n            return AVERROR(ENOMEM);\n        /* Don't use a count greater than 1 here since it will leave a gap in\n         * the ctts index which the code below relies on being sequential. */\n        sc->ctts_data = ctts_data;\n        for (i = 0; i < sc->sample_count; i++) {\n            sc->ctts_data[sc->ctts_count].count = 1;\n            sc->ctts_data[sc->ctts_count].duration = 0;\n            sc->ctts_count++;\n        }\n    }\n    if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    if (flags & MOV_TRUN_DATA_OFFSET)        data_offset        = avio_rb32(pb);\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb);\n    dts    = sc->track_end - sc->time_offset;\n    offset = frag->base_data_offset + data_offset;\n    distance = 0;\n    av_log(c->fc, AV_LOG_TRACE, \"first sample flags 0x%x\\n\", first_sample_flags);\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        unsigned sample_size = frag->size;\n        int sample_flags = i ? frag->flags : first_sample_flags;\n        unsigned sample_duration = frag->duration;\n        unsigned ctts_duration = 0;\n        int keyframe = 0;\n        int ctts_index = 0;\n        int old_nb_index_entries = st->nb_index_entries;\n\n        if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_SIZE)     sample_size     = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)    sample_flags    = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_CTS)      ctts_duration   = avio_rb32(pb);\n\n        mov_update_dts_shift(sc, ctts_duration);\n        if (frag->time != AV_NOPTS_VALUE) {\n            if (c->use_mfra_for == FF_MOV_FLAG_MFRA_PTS) {\n                int64_t pts = frag->time;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \" sc->dts_shift %d ctts.duration %d\"\n                        \" sc->time_offset %\"PRId64\" flags & MOV_TRUN_SAMPLE_CTS %d\\n\", pts,\n                        sc->dts_shift, ctts_duration,\n                        sc->time_offset, flags & MOV_TRUN_SAMPLE_CTS);\n                dts = pts - sc->dts_shift;\n                if (flags & MOV_TRUN_SAMPLE_CTS) {\n                    dts -= ctts_duration;\n                } else {\n                    dts -= sc->time_offset;\n                }\n                av_log(c->fc, AV_LOG_DEBUG, \"calculated into dts %\"PRId64\"\\n\", dts);\n            } else {\n                dts = frag->time - sc->time_offset;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \", using it for dts\\n\", dts);\n            }\n            frag->time = AV_NOPTS_VALUE;\n        }\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n            keyframe = 1;\n        else\n            keyframe =\n                !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC |\n                                  MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES));\n        if (keyframe)\n            distance = 0;\n        ctts_index = av_add_index_entry(st, offset, dts, sample_size, distance,\n                                        keyframe ? AVINDEX_KEYFRAME : 0);\n        if (ctts_index >= 0 && old_nb_index_entries < st->nb_index_entries) {\n            unsigned int size_needed = st->nb_index_entries * sizeof(*sc->ctts_data);\n            unsigned int request_size = size_needed > sc->ctts_allocated_size ?\n                FFMAX(size_needed, 2 * sc->ctts_allocated_size) : size_needed;\n            ctts_data = av_fast_realloc(sc->ctts_data, &sc->ctts_allocated_size, request_size);\n            if (!ctts_data) {\n                av_freep(&sc->ctts_data);\n                return AVERROR(ENOMEM);\n            }\n\n            sc->ctts_data = ctts_data;\n            if (ctts_index != old_nb_index_entries) {\n                memmove(sc->ctts_data + ctts_index + 1, sc->ctts_data + ctts_index,\n                        sizeof(*sc->ctts_data) * (sc->ctts_count - ctts_index));\n                if (ctts_index <= sc->current_sample) {\n                    // if we inserted a new item before the current sample, move the\n                    // counter ahead so it is still pointing to the same sample.\n                    sc->current_sample++;\n                }\n            }\n\n            sc->ctts_data[ctts_index].count = 1;\n            sc->ctts_data[ctts_index].duration = ctts_duration;\n            sc->ctts_count++;\n        } else {\n            av_log(c->fc, AV_LOG_ERROR, \"Failed to add index entry\\n\");\n        }\n\n        av_log(c->fc, AV_LOG_TRACE, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                \"size %u, distance %d, keyframe %d\\n\", st->index, ctts_index,\n                offset, dts, sample_size, distance, keyframe);\n        distance++;\n        dts += sample_duration;\n        offset += sample_size;\n        sc->data_size += sample_size;\n        sc->duration_for_fps += sample_duration;\n        sc->nb_frames_for_fps ++;\n    }\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    frag->implicit_offset = offset;\n\n    sc->track_end = dts + sc->time_offset;\n    if (st->duration < sc->track_end)\n        st->duration = sc->track_end;\n\n    return 0;\n}", "target": 1}
{"idx": 5733, "func": "static int movie_get_frame(AVFilterLink *outlink)\n{\n    MovieContext *movie = outlink->src->priv;\n    AVPacket pkt;\n    int ret = 0, frame_decoded;\n    AVStream *st = movie->format_ctx->streams[movie->stream_index];\n\n    if (movie->state == STATE_DONE)\n        return 0;\n\n    while (1) {\n        if (movie->state == STATE_DECODING) {\n        ret = av_read_frame(movie->format_ctx, &pkt);\n        if (ret == AVERROR_EOF) {\n            int64_t timestamp;\n            if (movie->loop_count != 1) {\n                timestamp = movie->seek_point;\n                if (movie->format_ctx->start_time != AV_NOPTS_VALUE)\n                    timestamp += movie->format_ctx->start_time;\n                if (av_seek_frame(movie->format_ctx, -1, timestamp, AVSEEK_FLAG_BACKWARD) < 0) {\n                    movie->state = STATE_FLUSHING;\n                } else if (movie->loop_count>1)\n                    movie->loop_count--;\n                continue;\n            } else {\n                movie->state = STATE_FLUSHING;\n            }\n        } else if (ret < 0)\n            break;\n        }\n\n        // Is this a packet from the video stream?\n        if (pkt.stream_index == movie->stream_index || movie->state == STATE_FLUSHING) {\n            avcodec_decode_video2(movie->codec_ctx, movie->frame, &frame_decoded, &pkt);\n\n            if (frame_decoded) {\n                /* FIXME: avoid the memcpy */\n                movie->picref = ff_get_video_buffer(outlink, AV_PERM_WRITE | AV_PERM_PRESERVE |\n                                                    AV_PERM_REUSE2, outlink->w, outlink->h);\n                av_image_copy(movie->picref->data, movie->picref->linesize,\n                              (void*)movie->frame->data,  movie->frame->linesize,\n                              movie->picref->format, outlink->w, outlink->h);\n                avfilter_copy_frame_props(movie->picref, movie->frame);\n\n                /* FIXME: use a PTS correction mechanism as that in\n                 * ffplay.c when some API will be available for that */\n                /* use pkt_dts if pkt_pts is not available */\n                movie->picref->pts = movie->frame->pkt_pts == AV_NOPTS_VALUE ?\n                    movie->frame->pkt_dts : movie->frame->pkt_pts;\n\n                if (!movie->frame->sample_aspect_ratio.num)\n                    movie->picref->video->sample_aspect_ratio = st->sample_aspect_ratio;\n                av_dlog(outlink->src,\n                        \"movie_get_frame(): file:'%s' pts:%\"PRId64\" time:%lf pos:%\"PRId64\" aspect:%d/%d\\n\",\n                        movie->file_name, movie->picref->pts,\n                        (double)movie->picref->pts * av_q2d(st->time_base),\n                        movie->picref->pos,\n                        movie->picref->video->sample_aspect_ratio.num,\n                        movie->picref->video->sample_aspect_ratio.den);\n                // We got it. Free the packet since we are returning\n                av_free_packet(&pkt);\n\n                return 0;\n            } else if (movie->state == STATE_FLUSHING) {\n                movie->state = STATE_DONE;\n                av_free_packet(&pkt);\n                return AVERROR_EOF;\n            }\n        }\n        // Free the packet that was allocated by av_read_frame\n        av_free_packet(&pkt);\n    }\n\n    return ret;\n}", "target": 0}
{"idx": 5734, "func": "void ff_channel_layouts_ref(AVFilterChannelLayouts *f, AVFilterChannelLayouts **ref)\n{\n    FORMATS_REF(f, ref);\n}", "target": 1}
{"idx": 5735, "func": "int X509_NAME_add_entry(X509_NAME *name, X509_NAME_ENTRY *ne, int loc,\n\t     int set)\n\t{\n\tX509_NAME_ENTRY *new_name=NULL;\n\tint n,i,inc;\n\tSTACK_OF(X509_NAME_ENTRY) *sk;\n\n\tif (name == NULL) return(0);\n\tsk=name->entries;\n\tn=sk_X509_NAME_ENTRY_num(sk);\n\tif (loc > n) loc=n;\n\telse if (loc < 0) loc=n;\n\n\tname->modified=1;\n\n\tif (set == -1)\n\t\t{\n\t\tif (loc == 0)\n\t\t\t{\n\t\t\tset=0;\n\t\t\tinc=1;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tset=sk_X509_NAME_ENTRY_value(sk,loc-1)->set;\n\t\t\tinc=0;\n\t\t\t}\n\t\t}\n\telse /* if (set >= 0) */\n\t\t{\n\t\tif (loc >= n)\n\t\t\t{\n\t\t\tif (loc != 0)\n\t\t\t\tset=sk_X509_NAME_ENTRY_value(sk,loc-1)->set+1;\n\t\t\telse\n\t\t\t\tset=0;\n\t\t\t}\n\t\telse\n\t\t\tset=sk_X509_NAME_ENTRY_value(sk,loc)->set;\n\t\tinc=(set == 0)?1:0;\n\t\t}\n\n\tif ((new_name=X509_NAME_ENTRY_dup(ne)) == NULL)\n\t\tgoto err;\n\tnew_name->set=set;\n\tif (!sk_X509_NAME_ENTRY_insert(sk,new_name,loc))\n\t\t{\n\t\tX509err(X509_F_X509_NAME_ADD_ENTRY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tif (inc)\n\t\t{\n\t\tn=sk_X509_NAME_ENTRY_num(sk);\n\t\tfor (i=loc+1; i<n; i++)\n\t\t\tsk_X509_NAME_ENTRY_value(sk,i-1)->set+=1;\n\t\t}\t\n\treturn(1);\nerr:\n\tif (new_name != NULL)\n\t\tX509_NAME_ENTRY_free(new_name);\n\treturn(0);\n\t}", "target": 1}
{"idx": 5736, "func": "static void draw_blank_frame(AVFilterContext *ctx, AVFilterBufferRef *out_buf)\n{\n    TileContext *tile    = ctx->priv;\n    AVFilterLink *inlink  = ctx->inputs[0];\n    unsigned x0 = inlink->w * (tile->current % tile->w);\n    unsigned y0 = inlink->h * (tile->current / tile->w);\n\n    ff_fill_rectangle(&tile->draw, &tile->blank,\n                      out_buf->data, out_buf->linesize,\n                      x0, y0, inlink->w, inlink->h);\n    tile->current++;\n}", "target": 1}
{"idx": 5737, "func": "int ff_mpv_common_init(MpegEncContext *s)\n{\n    int i;\n    int nb_slices = (HAVE_THREADS &&\n                     s->avctx->active_thread_type & FF_THREAD_SLICE) ?\n                    s->avctx->thread_count : 1;\n\n    clear_context(s);\n\n    if (s->encoding && s->avctx->slices)\n        nb_slices = s->avctx->slices;\n\n    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n        s->mb_height = (s->height + 31) / 32 * 2;\n    else\n        s->mb_height = (s->height + 15) / 16;\n\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"decoding to AV_PIX_FMT_NONE is not supported.\\n\");\n        return -1;\n    }\n\n    if (nb_slices > MAX_THREADS || (nb_slices > s->mb_height && s->mb_height)) {\n        int max_slices;\n        if (s->mb_height)\n            max_slices = FFMIN(MAX_THREADS, s->mb_height);\n        else\n            max_slices = MAX_THREADS;\n        av_log(s->avctx, AV_LOG_WARNING, \"too many threads/slices (%d),\"\n               \" reducing to %d\\n\", nb_slices, max_slices);\n        nb_slices = max_slices;\n    }\n\n    if ((s->width || s->height) &&\n        av_image_check_size(s->width, s->height, 0, s->avctx))\n        return -1;\n\n    dct_init(s);\n\n    /* set chroma shifts */\n    avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,\n                                  &s->chroma_x_shift,\n                                  &s->chroma_y_shift);\n\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->picture,\n                      MAX_PICTURE_COUNT * sizeof(Picture), fail);\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        s->picture[i].f = av_frame_alloc();\n        if (!s->picture[i].f)\n            goto fail;\n    }\n    s->next_picture.f = av_frame_alloc();\n    if (!s->next_picture.f)\n        goto fail;\n    s->last_picture.f = av_frame_alloc();\n    if (!s->last_picture.f)\n        goto fail;\n    s->current_picture.f = av_frame_alloc();\n    if (!s->current_picture.f)\n        goto fail;\n    s->new_picture.f = av_frame_alloc();\n    if (!s->new_picture.f)\n        goto fail;\n\n        if (init_context_frame(s))\n            goto fail;\n\n        s->parse_context.state = -1;\n\n        s->context_initialized = 1;\n        memset(s->thread_context, 0, sizeof(s->thread_context));\n        s->thread_context[0]   = s;\n\n//     if (s->width && s->height) {\n        if (nb_slices > 1) {\n            for (i = 0; i < nb_slices; i++) {\n                if (i) {\n                    s->thread_context[i] = av_memdup(s, sizeof(MpegEncContext));\n                    if (!s->thread_context[i])\n                        goto fail;\n                }\n                if (init_duplicate_context(s->thread_context[i]) < 0)\n                    goto fail;\n                    s->thread_context[i]->start_mb_y =\n                        (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n                    s->thread_context[i]->end_mb_y   =\n                        (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n            }\n        } else {\n            if (init_duplicate_context(s) < 0)\n                goto fail;\n            s->start_mb_y = 0;\n            s->end_mb_y   = s->mb_height;\n        }\n        s->slice_context_count = nb_slices;\n//     }\n\n    return 0;\n fail:\n    ff_mpv_common_end(s);\n    return -1;\n}", "target": 0}
{"idx": 5738, "func": "static int64_t mp3_sync(AVFormatContext *s, int64_t target_pos, int flags)\n{\n    int dir = (flags&AVSEEK_FLAG_BACKWARD) ? -1 : 1;\n    int64_t best_pos;\n    int best_score, i, j;\n    int64_t ret;\n\n    avio_seek(s->pb, FFMAX(target_pos - SEEK_WINDOW, 0), SEEK_SET);\n    ret = avio_seek(s->pb, target_pos, SEEK_SET);\n    if (ret < 0)\n        return ret;\n\n#define MIN_VALID 3\n    best_pos = target_pos;\n    best_score = 999;\n    for(i=0; i<SEEK_WINDOW; i++) {\n        int64_t pos = target_pos + (dir > 0 ? i - SEEK_WINDOW/4 : -i);\n        int64_t candidate = -1;\n        int score = 999;\n\n        if (pos < 0)\n            continue;\n\n        for(j=0; j<MIN_VALID; j++) {\n            ret = check(s->pb, pos, NULL);\n            if(ret < 0) {\n                if (ret == CHECK_WRONG_HEADER) {\n                    break;\n                } else if (ret == CHECK_SEEK_FAILED) {\n                    av_log(s, AV_LOG_ERROR, \"Could not seek to %\"PRId64\".\\n\", pos);\n                    return AVERROR(EINVAL);\n                }\n            }\n            if ((target_pos - pos)*dir <= 0 && abs(MIN_VALID/2-j) < score) {\n                candidate = pos;\n                score = abs(MIN_VALID/2-j);\n            }\n            pos += ret;\n        }\n        if (best_score > score && j == MIN_VALID) {\n            best_pos = candidate;\n            best_score = score;\n            if(score == 0)\n                break;\n        }\n    }\n\n    return avio_seek(s->pb, best_pos, SEEK_SET);\n}", "target": 0}
{"idx": 5739, "func": "int ASN1_TIME_set_string_X509(ASN1_TIME *s, const char *str)\n{\n    ASN1_TIME t;\n    struct tm tm;\n    int rv = 0;\n\n    t.length = strlen(str);\n    t.data = (unsigned char *)str;\n    t.flags = ASN1_STRING_FLAG_X509_TIME;\n\n    t.type = V_ASN1_UTCTIME;\n\n    if (!ASN1_TIME_check(&t)) {\n        t.type = V_ASN1_GENERALIZEDTIME;\n        if (!ASN1_TIME_check(&t))\n            goto out;\n    }\n\n    /*\n     * Per RFC 5280 (section 4.1.2.5.), the valid input time\n     * strings should be encoded with the following rules:\n     *\n     * 1. UTC: YYMMDDHHMMSSZ, if YY < 50 (20YY) --> UTC: YYMMDDHHMMSSZ\n     * 2. UTC: YYMMDDHHMMSSZ, if YY >= 50 (19YY) --> UTC: YYMMDDHHMMSSZ\n     * 3. G'd: YYYYMMDDHHMMSSZ, if YYYY >= 2050 --> G'd: YYYYMMDDHHMMSSZ\n     * 4. G'd: YYYYMMDDHHMMSSZ, if YYYY < 2050 --> UTC: YYMMDDHHMMSSZ\n     *\n     * Only strings of the 4th rule should be reformatted, but since a\n     * UTC can only present [1950, 2050), so if the given time string\n     * is less than 1950 (e.g. 19230419000000Z), we do nothing...\n     */\n\n    if (s != NULL && t.type == V_ASN1_GENERALIZEDTIME) {\n        if (!asn1_time_to_tm(&tm, &t))\n            goto out;\n        if (tm.tm_year >= 50 && tm.tm_year < 150) {\n            t.length -= 2;\n            /*\n             * it's OK to let original t.data go since that's assigned\n             * to a piece of memory allocated outside of this function.\n             * new t.data would be freed after ASN1_STRING_copy is done.\n             */\n            t.data = OPENSSL_zalloc(t.length + 1);\n            if (t.data == NULL)\n                goto out;\n            memcpy(t.data, str + 2, t.length);\n            t.type = V_ASN1_UTCTIME;\n        }\n    }\n\n    if (s == NULL || ASN1_STRING_copy((ASN1_STRING *)s, (ASN1_STRING *)&t))\n        rv = 1;\n\n    if (t.data != (unsigned char *)str)\n        OPENSSL_free(t.data);\nout:\n    return rv;\n}", "target": 0}
{"idx": 5740, "func": "static void filter1(int32_t *dst, const int32_t *src, int32_t coeff, ptrdiff_t len)\n{\n    int i;\n\n    for (i = 0; i < len; i++)\n        dst[i] -= mul23(src[i], coeff);\n}", "target": 1}
{"idx": 5741, "func": "static int encode_audio_frame(AVFormatContext *s, OutputStream *ost,\n                              const uint8_t *buf, int buf_size)\n{\n    AVCodecContext *enc = ost->st->codec;\n    AVFrame *frame = NULL;\n    AVPacket pkt;\n    int ret, got_packet;\n\n    av_init_packet(&pkt);\n    pkt.data = NULL;\n    pkt.size = 0;\n\n    if (buf) {\n        if (!ost->output_frame) {\n            ost->output_frame = avcodec_alloc_frame();\n            if (!ost->output_frame) {\n                av_log(NULL, AV_LOG_FATAL, \"out-of-memory in encode_audio_frame()\\n\");\n                exit_program(1);\n            }\n        }\n        frame = ost->output_frame;\n        if (frame->extended_data != frame->data)\n            av_freep(&frame->extended_data);\n        avcodec_get_frame_defaults(frame);\n\n        frame->nb_samples  = buf_size /\n                             (enc->channels * av_get_bytes_per_sample(enc->sample_fmt));\n        if ((ret = avcodec_fill_audio_frame(frame, enc->channels, enc->sample_fmt,\n                                            buf, buf_size, 1)) < 0) {\n            av_log(NULL, AV_LOG_FATAL, \"Audio encoding failed\\n\");\n            exit_program(1);\n        }\n\n        frame->pts = ost->sync_opts;\n        ost->sync_opts += frame->nb_samples;\n    }\n\n    got_packet = 0;\n    if (avcodec_encode_audio2(enc, &pkt, frame, &got_packet) < 0) {\n        av_log(NULL, AV_LOG_FATAL, \"Audio encoding failed\\n\");\n        exit_program(1);\n    }\n\n    ret = pkt.size;\n\n    if (got_packet) {\n        if (pkt.pts != AV_NOPTS_VALUE)\n            pkt.pts      = av_rescale_q(pkt.pts,      enc->time_base, ost->st->time_base);\n        if (pkt.dts != AV_NOPTS_VALUE)\n            pkt.dts      = av_rescale_q(pkt.dts,      enc->time_base, ost->st->time_base);\n        if (pkt.duration > 0)\n            pkt.duration = av_rescale_q(pkt.duration, enc->time_base, ost->st->time_base);\n\n        write_frame(s, &pkt, ost);\n\n        audio_size += pkt.size;\n\n        av_free_packet(&pkt);\n    }\n\n    if (debug_ts) {\n        av_log(NULL, AV_LOG_INFO, \"encoder -> type:audio \"\n               \"pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\\n\",\n               av_ts2str(pkt.pts), av_ts2timestr(pkt.pts, &ost->st->time_base),\n               av_ts2str(pkt.dts), av_ts2timestr(pkt.dts, &ost->st->time_base));\n    }\n\n    return ret;\n}", "target": 1}
{"idx": 5742, "func": "static int find_and_decode_index(NUTContext *nut){\n    AVFormatContext *s= nut->avf;\n    ByteIOContext *bc = s->pb;\n    uint64_t tmp, end;\n    int i, j, syncpoint_count;\n    int64_t filesize= url_fsize(bc);\n    int64_t *syncpoints;\n    int8_t *has_keyframe;\n\n    url_fseek(bc, filesize-12, SEEK_SET);\n    url_fseek(bc, filesize-get_be64(bc), SEEK_SET);\n    if(get_be64(bc) != INDEX_STARTCODE){\n        av_log(s, AV_LOG_ERROR, \"no index at the end\\n\");\n        return -1;\n    }\n\n    end= get_packetheader(nut, bc, 1, INDEX_STARTCODE);\n    end += url_ftell(bc);\n\n    ff_get_v(bc); //max_pts\n    GET_V(syncpoint_count, tmp < INT_MAX/8 && tmp > 0)\n    syncpoints= av_malloc(sizeof(int64_t)*syncpoint_count);\n    has_keyframe= av_malloc(sizeof(int8_t)*(syncpoint_count+1));\n    for(i=0; i<syncpoint_count; i++){\n        GET_V(syncpoints[i], tmp>0)\n        if(i)\n            syncpoints[i] += syncpoints[i-1];\n    }\n\n    for(i=0; i<s->nb_streams; i++){\n        int64_t last_pts= -1;\n        for(j=0; j<syncpoint_count;){\n            uint64_t x= ff_get_v(bc);\n            int type= x&1;\n            int n= j;\n            x>>=1;\n            if(type){\n                int flag= x&1;\n                x>>=1;\n                if(n+x >= syncpoint_count + 1){\n                    av_log(s, AV_LOG_ERROR, \"index overflow A\\n\");\n                    return -1;\n                }\n                while(x--)\n                    has_keyframe[n++]= flag;\n                has_keyframe[n++]= !flag;\n            }else{\n                while(x != 1){\n                    if(n>=syncpoint_count + 1){\n                        av_log(s, AV_LOG_ERROR, \"index overflow B\\n\");\n                        return -1;\n                    }\n                    has_keyframe[n++]= x&1;\n                    x>>=1;\n                }\n            }\n            if(has_keyframe[0]){\n                av_log(s, AV_LOG_ERROR, \"keyframe before first syncpoint in index\\n\");\n                return -1;\n            }\n            assert(n<=syncpoint_count+1);\n            for(; j<n; j++){\n                if(has_keyframe[j]){\n                    uint64_t B, A= ff_get_v(bc);\n                    if(!A){\n                        A= ff_get_v(bc);\n                        B= ff_get_v(bc);\n                        //eor_pts[j][i] = last_pts + A + B\n                    }else\n                        B= 0;\n                    av_add_index_entry(\n                        s->streams[i],\n                        16*syncpoints[j-1],\n                        last_pts + A,\n                        0,\n                        0,\n                        AVINDEX_KEYFRAME);\n                    last_pts += A + B;\n                }\n            }\n        }\n    }\n\n    if(skip_reserved(bc, end) || get_checksum(bc)){\n        av_log(s, AV_LOG_ERROR, \"index checksum mismatch\\n\");\n        return -1;\n    }\n    return 0;\n}", "target": 1}
{"idx": 5743, "func": "int ossl_namemap_add(OSSL_NAMEMAP *namemap, int number, const char *name)\n{\n    NAMENUM_ENTRY *namenum = NULL;\n    int tmp_number;\n\n#ifndef FIPS_MODE\n    if (namemap == NULL)\n        namemap = ossl_namemap_stored(NULL);\n#endif\n\n    if (name == NULL || namemap == NULL)\n        return 0;\n\n    if ((tmp_number = ossl_namemap_name2num(namemap, name)) != 0)\n        return tmp_number;       /* Pretend success */\n\n    CRYPTO_THREAD_write_lock(namemap->lock);\n\n    if ((namenum = OPENSSL_zalloc(sizeof(*namenum))) == NULL\n        || (namenum->name = OPENSSL_strdup(name)) == NULL)\n        goto err;\n\n    namenum->number = tmp_number =\n        number != 0 ? number : ++namemap->max_number;\n    (void)lh_NAMENUM_ENTRY_insert(namemap->namenum, namenum);\n\n    if (lh_NAMENUM_ENTRY_error(namemap->namenum))\n        goto err;\n\n    CRYPTO_THREAD_unlock(namemap->lock);\n\n    return tmp_number;\n\n err:\n    namenum_free(namenum);\n\n    CRYPTO_THREAD_unlock(namemap->lock);\n    return 0;\n}", "target": 0}
{"idx": 5744, "func": "static int verify_extension(SSL *s, unsigned int context, unsigned int type,\n                            custom_ext_methods *meths, RAW_EXTENSION *rawexlist,\n                            RAW_EXTENSION **found)\n{\n    size_t i;\n    size_t builtin_num = OSSL_NELEM(ext_defs);\n    const EXTENSION_DEFINITION *thisext;\n\n    for (i = 0, thisext = ext_defs; i < builtin_num; i++, thisext++) {\n        if (type == thisext->type) {\n            if (!validate_context(s, thisext->context, context))\n                return 0;\n\n            *found = &rawexlist[i];\n            return 1;\n        }\n    }\n\n    /* Check the custom extensions */\n    if (meths != NULL) {\n        size_t offset = 0;\n        ENDPOINT role = ENDPOINT_BOTH;\n        custom_ext_method *meth = NULL;\n\n        if ((context & SSL_EXT_CLIENT_HELLO) != 0)\n            role = ENDPOINT_SERVER;\n        else if ((context & SSL_EXT_TLS1_2_SERVER_HELLO) != 0)\n            role = ENDPOINT_CLIENT;\n\n        meth = custom_ext_find(meths, role, type, &offset);\n        if (meth != NULL) {\n            if (!validate_context(s, meth->context, context))\n                return 0;\n            *found = &rawexlist[offset + builtin_num];\n            return 1;\n        }\n    }\n\n    /* Unknown extension. We allow it */\n    *found = NULL;\n    return 1;\n}", "target": 1}
{"idx": 5745, "func": "int ffio_open_dyn_packet_buf(AVIOContext **s, int max_packet_size)\n{\n    if (max_packet_size <= 0)\n        return -1;\n    return url_open_dyn_buf_internal(s, max_packet_size);\n}", "target": 0}
{"idx": 5746, "func": "static int mp3_seek(AVFormatContext *s, int stream_index, int64_t timestamp,\n                    int flags)\n{\n    MP3Context *mp3 = s->priv_data;\n    AVIndexEntry *ie;\n    AVStream *st = s->streams[0];\n    int64_t ret  = av_index_search_timestamp(st, timestamp, flags);\n    uint32_t header = 0;\n\n    if (!mp3->xing_toc) {\n        st->skip_samples = timestamp <= 0 ? mp3->start_pad + 528 + 1 : 0;\n\n        return -1;\n    }\n\n    if (ret < 0)\n        return ret;\n\n    ie = &st->index_entries[ret];\n    ret = avio_seek(s->pb, ie->pos, SEEK_SET);\n    if (ret < 0)\n        return ret;\n\n    while (!s->pb->eof_reached) {\n        header = (header << 8) + avio_r8(s->pb);\n        if (ff_mpa_check_header(header) >= 0) {\n            ff_update_cur_dts(s, st, ie->timestamp);\n            ret = avio_seek(s->pb, -4, SEEK_CUR);\n\n            st->skip_samples = ie->timestamp <= 0 ? mp3->start_pad + 528 + 1 : 0;\n\n            return (ret >= 0) ? 0 : ret;\n        }\n    }\n\n    return AVERROR_EOF;\n}", "target": 1}
{"idx": 5747, "func": "static int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\n                           long max)\n{\n    const unsigned char *p = *pp;\n    unsigned long ret = 0;\n    unsigned long i;\n\n    if (max-- < 1)\n        return 0;\n    if (*p == 0x80) {\n        *inf = 1;\n        ret = 0;\n        p++;\n    } else {\n        *inf = 0;\n        i = *p & 0x7f;\n        if (*(p++) & 0x80) {\n            if (max < (long)i + 1)\n                return 0;\n            /* Skip leading zeroes */\n            while (i && *p == 0) {\n                p++;\n                i--;\n            }\n            if (i > sizeof(long))\n                return 0;\n            while (i-- > 0) {\n                ret <<= 8L;\n                ret |= *(p++);\n            }\n        } else\n            ret = i;\n    }\n    if (ret > LONG_MAX)\n        return 0;\n    *pp = p;\n    *rl = (long)ret;\n    return 1;\n}", "target": 0}
{"idx": 5748, "func": "static int compute_pair_key_le(unsigned char *pair_key,BIGNUM *pub_key,DH *dh) \n\t{\n\tunsigned char be_key[128];\n\tint i,key_size;\n\tkey_size=DH_compute_key(be_key,pub_key,dh);\n\tif (!key_size) return 0;\n\tmemset(pair_key,0,128);\n\tfor (i=0;i<key_size;i++)\n\t\t{\n\t\tpair_key[i]=be_key[key_size-1-i];\n\t\t}\n\treturn key_size;\t\n\t}", "target": 1}
{"idx": 5749, "func": "int\nTIFFFillStrip(TIFF* tif, uint32 strip)\n{\n\tstatic const char module[] = \"TIFFFillStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tif ((tif->tif_flags&TIFF_NOREADRAW)==0)\n\t{\n\t\tuint64 bytecount = TIFFGetStrileByteCount(tif, strip);\n\t\tif( bytecount == 0 || bytecount > (uint64)TIFF_INT64_MAX ) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %I64u, strip %lu\",\n\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %llu, strip %lu\",\n\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#endif\n\t\t\treturn (0);\n\t\t}\n\n\t\t/* To avoid excessive memory allocations: */\n\t\t/* Byte count should normally not be larger than a number of */\n\t\t/* times the uncompressed size plus some margin */\n                if( bytecount > 1024 * 1024 )\n                {\n\t\t\t/* 10 and 4096 are just values that could be adjusted. */\n\t\t\t/* Hopefully they are safe enough for all codecs */\n\t\t\ttmsize_t stripsize = TIFFStripSize(tif);\n\t\t\tif( stripsize != 0 &&\n\t\t\t    (bytecount - 4096) / 10 > (uint64)stripsize  )\n\t\t\t{\n\t\t\t\tuint64 newbytecount = (uint64)stripsize * 10 + 4096;\n\t\t\t\tif( newbytecount == 0 || newbytecount > (uint64)TIFF_INT64_MAX )\n\t\t\t\t{\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t  \"Too large strip byte count %I64u, strip %lu. Limiting to %I64u\",\n\t\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t\t     (unsigned long) strip,\n\t\t\t\t\t     (unsigned __int64) newbytecount);\n#else\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t  \"Too large strip byte count %llu, strip %lu. Limiting to %llu\",\n\t\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t\t     (unsigned long) strip,\n\t\t\t\t\t     (unsigned long long) newbytecount);\n#endif\n\t\t\t\t\tbytecount = newbytecount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isMapped(tif)) {\n\t\t\t/*\n\t\t\t * We must check for overflow, potentially causing\n\t\t\t * an OOB read. Instead of simple\n\t\t\t *\n\t\t\t *  TIFFGetStrileOffset(tif, strip)+bytecount > tif->tif_size\n\t\t\t *\n\t\t\t * comparison (which can overflow) we do the following\n\t\t\t * two comparisons:\n\t\t\t */\n\t\t\tif (bytecount > (uint64)tif->tif_size ||\n\t\t\t    TIFFGetStrileOffset(tif, strip) > (uint64)tif->tif_size - bytecount) {\n\t\t\t\t/*\n\t\t\t\t * This error message might seem strange, but\n\t\t\t\t * it's what would happen if a read were done\n\t\t\t\t * instead.\n\t\t\t\t */\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %I64u bytes, expected %I64u\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned __int64) tif->tif_size - TIFFGetStrileOffset(tif, strip),\n\t\t\t\t\t(unsigned __int64) bytecount);\n#else\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %llu bytes, expected %llu\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned long long) tif->tif_size - TIFFGetStrileOffset(tif, strip),\n\t\t\t\t\t(unsigned long long) bytecount);\n#endif\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\n\t\tif (isMapped(tif) &&\n\t\t    (isFillOrder(tif, td->td_fillorder)\n\t\t    || (tif->tif_flags & TIFF_NOBITREV))) {\n\t\t\t/*\n\t\t\t * The image is mapped into memory and we either don't\n\t\t\t * need to flip bits or the compression routine is\n\t\t\t * going to handle this operation itself.  In this\n\t\t\t * case, avoid copying the raw data and instead just\n\t\t\t * reference the data from the memory mapped file\n\t\t\t * image.  This assumes that the decompression\n\t\t\t * routines do not modify the contents of the raw data\n\t\t\t * buffer (if they try to, the application will get a\n\t\t\t * fault since the file is mapped read-only).\n\t\t\t */\n\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\n\t\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t}\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\t\t\ttif->tif_rawdatasize = (tmsize_t)bytecount;\n\t\t\ttif->tif_rawdata = tif->tif_base + (tmsize_t)TIFFGetStrileOffset(tif, strip);\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = (tmsize_t) bytecount;\n\n\t\t\t/* \n\t\t\t * When we have tif_rawdata reference directly into the memory mapped file\n\t\t\t * we need to be pretty careful about how we use the rawdata.  It is not\n\t\t\t * a general purpose working buffer as it normally otherwise is.  So we\n\t\t\t * keep track of this fact to avoid using it improperly.\n\t\t\t */\n\t\t\ttif->tif_flags |= TIFF_BUFFERMMAP;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Expand raw data buffer, if needed, to hold data\n\t\t\t * strip coming from file (perhaps should set upper\n\t\t\t * bound on the size of a buffer we'll use?).\n\t\t\t */\n\t\t\ttmsize_t bytecountm;\n\t\t\tbytecountm=(tmsize_t)bytecount;\n\t\t\tif ((uint64)bytecountm!=bytecount)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (bytecountm > tif->tif_rawdatasize) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Data buffer too small to hold strip %lu\",\n\t\t\t\t\t    (unsigned long) strip);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tif->tif_flags&TIFF_BUFFERMMAP) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t\ttif->tif_flags &= ~TIFF_BUFFERMMAP;\n\t\t\t}\n\n\t\t\tif( isMapped(tif) )\n\t\t\t{\n\t\t\t\tif (bytecountm > tif->tif_rawdatasize &&\n\t\t\t\t    !TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (TIFFReadRawStrip1(tif, strip, tif->tif_rawdata,\n\t\t\t\t    bytecountm, module) != bytecountm)\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (TIFFReadRawStripOrTile2(tif, strip, 1,\n\t\t\t\t    bytecountm, module) != bytecountm)\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\n\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = bytecountm;\n                        \n\t\t\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\t\tTIFFReverseBits(tif->tif_rawdata, bytecountm);\n                }\n\t}\n\treturn (TIFFStartStrip(tif, strip));\n}", "target": 0}
{"idx": 5750, "func": "static HWDevice *hw_device_match_by_codec(const AVCodec *codec)\n{\n    const AVCodecHWConfig *config;\n    HWDevice *dev;\n    int i;\n    for (i = 0;; i++) {\n        config = avcodec_get_hw_config(codec, i);\n        if (!config)\n            return NULL;\n        if (!(config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX))\n            continue;\n        dev = hw_device_get_by_type(config->device_type);\n        if (dev)\n            return dev;\n    }\n}", "target": 0}
{"idx": 5751, "func": "int X509_supported_extension(X509_EXTENSION *ex)\n\t{\n\t/* This table is a list of the NIDs of supported extensions:\n\t * that is those which are used by the verify process. If\n\t * an extension is critical and doesn't appear in this list\n\t * then the verify process will normally reject the certificate.\n\t * The list must be kept in numerical order because it will be\n\t * searched using bsearch.\n\t */\n\n\tstatic int supported_nids[] = {\n\t\tNID_netscape_cert_type, /* 71 */\n        \tNID_key_usage,\t\t/* 83 */\n\t\tNID_subject_alt_name,\t/* 85 */\n\t\tNID_basic_constraints,\t/* 87 */\n\t\tNID_certificate_policies, /* 89 */\n        \tNID_ext_key_usage,\t/* 126 */\n#ifndef OPENSSL_NO_RFC3779\n\t\tNID_sbgp_ipAddrBlock,\t/* 290 */\n\t\tNID_sbgp_autonomousSysNum, /* 291 */\n#endif\n\t\tNID_policy_constraints,\t/* 401 */\n\t\tNID_proxyCertInfo\t/* 663 */\n\t};\n\n\tint ex_nid;\n\n\tex_nid = OBJ_obj2nid(X509_EXTENSION_get_object(ex));\n\n\tif (ex_nid == NID_undef) \n\t\treturn 0;\n\n\tif (OBJ_bsearch((char *)&ex_nid, (char *)supported_nids,\n\t\tsizeof(supported_nids)/sizeof(int), sizeof(int),\n\t\t(int (*)(const void *, const void *))nid_cmp))\n\t\treturn 1;\n\treturn 0;\n\t}", "target": 0}
{"idx": 5752, "func": "int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n                                         H264ParamSets *ps, int bit_length)\n{\n    AVBufferRef *pps_buf;\n    SPS *sps;\n    unsigned int pps_id = get_ue_golomb(gb);\n    PPS *pps;\n    int qp_bd_offset;\n    int bits_left;\n    int ret;\n\n    if (pps_id >= MAX_PPS_COUNT) {\n        av_log(avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n\n    pps_buf = av_buffer_allocz(sizeof(*pps));\n    if (!pps_buf)\n        return AVERROR(ENOMEM);\n    pps = (PPS*)pps_buf->data;\n\n    pps->sps_id = get_ue_golomb_31(gb);\n    if ((unsigned)pps->sps_id >= MAX_SPS_COUNT ||\n        !ps->sps_list[pps->sps_id]) {\n        av_log(avctx, AV_LOG_ERROR, \"sps_id %u out of range\\n\", pps->sps_id);\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    sps = (SPS*)ps->sps_list[pps->sps_id]->data;\n\n    if (sps->bit_depth_luma > 10) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Unimplemented luma bit depth=%d (max=10)\\n\",\n               sps->bit_depth_luma);\n        ret = AVERROR_PATCHWELCOME;\n        goto fail;\n    }\n\n    pps->cabac             = get_bits1(gb);\n    pps->pic_order_present = get_bits1(gb);\n    pps->slice_group_count = get_ue_golomb(gb) + 1;\n    if (pps->slice_group_count > 1) {\n        pps->mb_slice_group_map_type = get_ue_golomb(gb);\n        av_log(avctx, AV_LOG_ERROR, \"FMO not supported\\n\");\n        switch (pps->mb_slice_group_map_type) {\n        case 0:\n#if 0\n    |       for (i = 0; i <= num_slice_groups_minus1; i++)  |   |      |\n    |           run_length[i]                               |1  |ue(v) |\n#endif\n            break;\n        case 2:\n#if 0\n    |       for (i = 0; i < num_slice_groups_minus1; i++) { |   |      |\n    |           top_left_mb[i]                              |1  |ue(v) |\n    |           bottom_right_mb[i]                          |1  |ue(v) |\n    |       }                                               |   |      |\n#endif\n            break;\n        case 3:\n        case 4:\n        case 5:\n#if 0\n    |       slice_group_change_direction_flag               |1  |u(1)  |\n    |       slice_group_change_rate_minus1                  |1  |ue(v) |\n#endif\n            break;\n        case 6:\n#if 0\n    |       slice_group_id_cnt_minus1                       |1  |ue(v) |\n    |       for (i = 0; i <= slice_group_id_cnt_minus1; i++)|   |      |\n    |           slice_group_id[i]                           |1  |u(v)  |\n#endif\n            break;\n        }\n    }\n    pps->ref_count[0] = get_ue_golomb(gb) + 1;\n    pps->ref_count[1] = get_ue_golomb(gb) + 1;\n    if (pps->ref_count[0] - 1 > 32 - 1 || pps->ref_count[1] - 1 > 32 - 1) {\n        av_log(avctx, AV_LOG_ERROR, \"reference overflow (pps)\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    qp_bd_offset = 6 * (sps->bit_depth_luma - 8);\n\n    pps->weighted_pred                        = get_bits1(gb);\n    pps->weighted_bipred_idc                  = get_bits(gb, 2);\n    pps->init_qp                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->init_qs                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->chroma_qp_index_offset[0]            = get_se_golomb(gb);\n    pps->deblocking_filter_parameters_present = get_bits1(gb);\n    pps->constrained_intra_pred               = get_bits1(gb);\n    pps->redundant_pic_cnt_present            = get_bits1(gb);\n\n    pps->transform_8x8_mode = 0;\n    memcpy(pps->scaling_matrix4, sps->scaling_matrix4,\n           sizeof(pps->scaling_matrix4));\n    memcpy(pps->scaling_matrix8, sps->scaling_matrix8,\n           sizeof(pps->scaling_matrix8));\n\n    bits_left = bit_length - get_bits_count(gb);\n    if (bits_left && (bits_left > 8 ||\n                      show_bits(gb, bits_left) != 1 << (bits_left - 1))) {\n        pps->transform_8x8_mode = get_bits1(gb);\n        decode_scaling_matrices(gb, sps, pps, 0,\n                                pps->scaling_matrix4, pps->scaling_matrix8);\n        // second_chroma_qp_index_offset\n        pps->chroma_qp_index_offset[1] = get_se_golomb(gb);\n    } else {\n        pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0];\n    }\n\n    build_qp_table(pps, 0, pps->chroma_qp_index_offset[0],\n                   sps->bit_depth_luma);\n    build_qp_table(pps, 1, pps->chroma_qp_index_offset[1],\n                   sps->bit_depth_luma);\n\n    init_dequant_tables(pps, sps);\n\n    if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])\n        pps->chroma_qp_diff = 1;\n\n    if (avctx->debug & FF_DEBUG_PICT_INFO) {\n        av_log(avctx, AV_LOG_DEBUG,\n               \"pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\\n\",\n               pps_id, pps->sps_id,\n               pps->cabac ? \"CABAC\" : \"CAVLC\",\n               pps->slice_group_count,\n               pps->ref_count[0], pps->ref_count[1],\n               pps->weighted_pred ? \"weighted\" : \"\",\n               pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1],\n               pps->deblocking_filter_parameters_present ? \"LPAR\" : \"\",\n               pps->constrained_intra_pred ? \"CONSTR\" : \"\",\n               pps->redundant_pic_cnt_present ? \"REDU\" : \"\",\n               pps->transform_8x8_mode ? \"8x8DCT\" : \"\");\n    }\n\n    remove_pps(ps, pps_id);\n    ps->pps_list[pps_id] = pps_buf;\n\n    return 0;\n\nfail:\n    av_buffer_unref(&pps_buf);\n    return ret;\n}", "target": 0}
{"idx": 5753, "func": "static int test_gf2m_mul()\n{\n    BIGNUM *a, *b[2], *c, *d, *e, *f, *g, *h;\n    int i, j, st = 0;\n    int p0[] = { 163, 7, 6, 3, 0, -1 };\n    int p1[] = { 193, 15, 0, -1 };\n\n    a = BN_new();\n    b[0] = BN_new();\n    b[1] = BN_new();\n    c = BN_new();\n    d = BN_new();\n    e = BN_new();\n    f = BN_new();\n    g = BN_new();\n    h = BN_new();\n\n    BN_GF2m_arr2poly(p0, b[0]);\n    BN_GF2m_arr2poly(p1, b[1]);\n\n    for (i = 0; i < NUM0; i++) {\n        BN_bntest_rand(a, 1024, 0, 0);\n        BN_bntest_rand(c, 1024, 0, 0);\n        BN_bntest_rand(d, 1024, 0, 0);\n        for (j = 0; j < 2; j++) {\n            BN_GF2m_mod_mul(e, a, c, b[j], ctx);\n            BN_GF2m_add(f, a, d);\n            BN_GF2m_mod_mul(g, f, c, b[j], ctx);\n            BN_GF2m_mod_mul(h, d, c, b[j], ctx);\n            BN_GF2m_add(f, e, g);\n            BN_GF2m_add(f, f, h);\n            /* Test that (a+d)*c = a*c + d*c. */\n            if (!BN_is_zero(f)) {\n                printf(\"GF(2^m) modular multiplication test failed!\\n\");\n                goto err;\n            }\n        }\n    }\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(b[0]);\n    BN_free(b[1]);\n    BN_free(c);\n    BN_free(d);\n    BN_free(e);\n    BN_free(f);\n    BN_free(g);\n    BN_free(h);\n    return st;\n}", "target": 0}
{"idx": 5754, "func": "static int xwma_read_header(AVFormatContext *s)\n{\n    int64_t size;\n    int ret = 0;\n    uint32_t dpds_table_size = 0;\n    uint32_t *dpds_table = NULL;\n    unsigned int tag;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    XWMAContext *xwma = s->priv_data;\n    int i;\n\n    /* The following code is mostly copied from wav.c, with some\n     * minor alterations.\n     */\n\n    /* check RIFF header */\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('R', 'I', 'F', 'F'))\n        return -1;\n    avio_rl32(pb); /* file size */\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('X', 'W', 'M', 'A'))\n        return -1;\n\n    /* parse fmt header */\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('f', 'm', 't', ' '))\n        return -1;\n    size = avio_rl32(pb);\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    ret = ff_get_wav_header(pb, st->codec, size, 0);\n    if (ret < 0)\n        return ret;\n    st->need_parsing = AVSTREAM_PARSE_NONE;\n\n    /* All xWMA files I have seen contained WMAv2 data. If there are files\n     * using WMA Pro or some other codec, then we need to figure out the right\n     * extradata for that. Thus, ask the user for feedback, but try to go on\n     * anyway.\n     */\n    if (st->codec->codec_id != AV_CODEC_ID_WMAV2) {\n        avpriv_request_sample(s, \"Unexpected codec (tag 0x04%x; id %d)\",\n                              st->codec->codec_tag, st->codec->codec_id);\n    } else {\n        /* In all xWMA files I have seen, there is no extradata. But the WMA\n         * codecs require extradata, so we provide our own fake extradata.\n         *\n         * First, check that there really was no extradata in the header. If\n         * there was, then try to use it, after asking the user to provide a\n         * sample of this unusual file.\n         */\n        if (st->codec->extradata_size != 0) {\n            /* Surprise, surprise: We *did* get some extradata. No idea\n             * if it will work, but just go on and try it, after asking\n             * the user for a sample.\n             */\n            avpriv_request_sample(s, \"Unexpected extradata (%d bytes)\",\n                                  st->codec->extradata_size);\n        } else {\n            if (ff_alloc_extradata(st->codec, 6))\n                return AVERROR(ENOMEM);\n\n            memset(st->codec->extradata, 0, st->codec->extradata_size);\n            /* setup extradata with our experimentally obtained value */\n            st->codec->extradata[4] = 31;\n        }\n    }\n\n    if (!st->codec->channels) {\n        av_log(s, AV_LOG_WARNING, \"Invalid channel count: %d\\n\",\n               st->codec->channels);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!st->codec->bits_per_coded_sample) {\n        av_log(s, AV_LOG_WARNING, \"Invalid bits_per_coded_sample: %d\\n\",\n               st->codec->bits_per_coded_sample);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* set the sample rate */\n    avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n    /* parse the remaining RIFF chunks */\n    for (;;) {\n        if (pb->eof_reached) {\n            ret = AVERROR_EOF;\n            goto fail;\n        }\n        /* read next chunk tag */\n        tag = avio_rl32(pb);\n        size = avio_rl32(pb);\n        if (tag == MKTAG('d', 'a', 't', 'a')) {\n            /* We assume that the data chunk comes last. */\n            break;\n        } else if (tag == MKTAG('d','p','d','s')) {\n            /* Quoting the MSDN xWMA docs on the dpds chunk: \"Contains the\n             * decoded packet cumulative data size array, each element is the\n             * number of bytes accumulated after the corresponding xWMA packet\n             * is decoded in order.\"\n             *\n             * Each packet has size equal to st->codec->block_align, which in\n             * all cases I saw so far was always 2230. Thus, we can use the\n             * dpds data to compute a seeking index.\n             */\n\n            /* Error out if there is more than one dpds chunk. */\n            if (dpds_table) {\n                av_log(s, AV_LOG_ERROR, \"two dpds chunks present\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n\n            /* Compute the number of entries in the dpds chunk. */\n            if (size & 3) {  /* Size should be divisible by four */\n                av_log(s, AV_LOG_WARNING,\n                       \"dpds chunk size %\"PRId64\" not divisible by 4\\n\", size);\n            }\n            dpds_table_size = size / 4;\n            if (dpds_table_size == 0 || dpds_table_size >= INT_MAX / 4) {\n                av_log(s, AV_LOG_ERROR,\n                       \"dpds chunk size %\"PRId64\" invalid\\n\", size);\n                return AVERROR_INVALIDDATA;\n            }\n\n            /* Allocate some temporary storage to keep the dpds data around.\n             * for processing later on.\n             */\n            dpds_table = av_malloc(dpds_table_size * sizeof(uint32_t));\n            if (!dpds_table) {\n                return AVERROR(ENOMEM);\n            }\n\n            for (i = 0; i < dpds_table_size; ++i) {\n                dpds_table[i] = avio_rl32(pb);\n                size -= 4;\n            }\n        }\n        avio_skip(pb, size);\n    }\n\n    /* Determine overall data length */\n    if (size < 0) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    if (!size) {\n        xwma->data_end = INT64_MAX;\n    } else\n        xwma->data_end = avio_tell(pb) + size;\n\n\n    if (dpds_table && dpds_table_size) {\n        int64_t cur_pos;\n        const uint32_t bytes_per_sample\n                = (st->codec->channels * st->codec->bits_per_coded_sample) >> 3;\n\n        /* Estimate the duration from the total number of output bytes. */\n        const uint64_t total_decoded_bytes = dpds_table[dpds_table_size - 1];\n\n        if (!bytes_per_sample) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Invalid bits_per_coded_sample %d for %d channels\\n\",\n                   st->codec->bits_per_coded_sample, st->codec->channels);\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        st->duration = total_decoded_bytes / bytes_per_sample;\n\n        /* Use the dpds data to build a seek table.  We can only do this after\n         * we know the offset to the data chunk, as we need that to determine\n         * the actual offset to each input block.\n         * Note: If we allowed ourselves to assume that the data chunk always\n         * follows immediately after the dpds block, we could of course guess\n         * the data block's start offset already while reading the dpds chunk.\n         * I decided against that, just in case other chunks ever are\n         * discovered.\n         */\n        cur_pos = avio_tell(pb);\n        for (i = 0; i < dpds_table_size; ++i) {\n            /* From the number of output bytes that would accumulate in the\n             * output buffer after decoding the first (i+1) packets, we compute\n             * an offset / timestamp pair.\n             */\n            av_add_index_entry(st,\n                               cur_pos + (i+1) * st->codec->block_align, /* pos */\n                               dpds_table[i] / bytes_per_sample,         /* timestamp */\n                               st->codec->block_align,                   /* size */\n                               0,                                        /* duration */\n                               AVINDEX_KEYFRAME);\n        }\n    } else if (st->codec->bit_rate) {\n        /* No dpds chunk was present (or only an empty one), so estimate\n         * the total duration using the average bits per sample and the\n         * total data length.\n         */\n        st->duration = (size<<3) * st->codec->sample_rate / st->codec->bit_rate;\n    }\n\nfail:\n    av_free(dpds_table);\n\n    return ret;\n}", "target": 0}
{"idx": 5755, "func": "static inline void encode_dc(MpegEncContext *s, int diff, int component)\n{\n    unsigned int diff_u = diff + 255;\n    if (diff_u >= 511) {\n        int index;\n\n        if (diff < 0) {\n            index = av_log2_16bit(-2 * diff);\n            diff--;\n        } else {\n            index = av_log2_16bit(2 * diff);\n        }\n        if (component == 0)\n            put_bits(&s->pb,\n                     ff_mpeg12_vlc_dc_lum_bits[index] + index,\n                     (ff_mpeg12_vlc_dc_lum_code[index] << index) +\n                     (diff & ((1 << index) - 1)));\n        else\n            put_bits(&s->pb,\n                     ff_mpeg12_vlc_dc_chroma_bits[index] + index,\n                     (ff_mpeg12_vlc_dc_chroma_code[index] << index) +\n                     (diff & ((1 << index) - 1)));\n    } else {\n        if (component == 0)\n            put_bits(&s->pb,\n                     mpeg1_lum_dc_uni[diff + 255] & 0xFF,\n                     mpeg1_lum_dc_uni[diff + 255] >> 8);\n        else\n            put_bits(&s->pb,\n                     mpeg1_chr_dc_uni[diff + 255] & 0xFF,\n                     mpeg1_chr_dc_uni[diff + 255] >> 8);\n    }\n}", "target": 0}
{"idx": 5756, "func": "static void block_out(BIO* b)\n\t{\n\tBIO_OK_CTX *ctx;\n\tEVP_MD_CTX *md;\n\tunsigned long tl;\n\n\tctx=(BIO_OK_CTX *)b->ptr;\n\tmd= &(ctx->md);\n\n\ttl= ctx->buf_len- OK_BLOCK_BLOCK;\n\ttl= swapem(tl);\n\tmemcpy(ctx->buf, &tl, OK_BLOCK_BLOCK);\n\ttl= swapem(tl);\n\tEVP_DigestUpdate(md, (unsigned char*) &(ctx->buf[OK_BLOCK_BLOCK]), tl);\n\tEVP_DigestFinal(md, &(ctx->buf[ctx->buf_len]), NULL);\n\tctx->buf_len+= md->digest->md_size;\n\tctx->blockout= 1;\n\t}", "target": 0}
{"idx": 5757, "func": "static int\nOJPEGReadHeaderInfoSecStreamDht(TIFF* tif)\n{\n\t/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */\n\t/* TODO: the following assumes there is only one table in this marker... but i'm not quite sure that assumption is guaranteed correct */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDht\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint32 na;\n\tuint8* nb;\n\tuint8 o;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<=2)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect!=0)\n\t{\n\t\tOJPEGReadSkip(sp,m-2);\n\t}\n\telse\n\t{\n\t\tna=sizeof(uint32)+2+m;\n\t\tnb=_TIFFmalloc(na);\n\t\tif (nb==0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\t*(uint32*)nb=na;\n\t\tnb[sizeof(uint32)]=255;\n\t\tnb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\tnb[sizeof(uint32)+2]=(m>>8);\n\t\tnb[sizeof(uint32)+3]=(m&255);\n\t\tif (OJPEGReadBlock(sp,m-2,&nb[sizeof(uint32)+4])==0) {\n                        _TIFFfree(nb);\n\t\t\treturn(0);\n                }\n\t\to=nb[sizeof(uint32)+4];\n\t\tif ((o&240)==0)\n\t\t{\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n                                _TIFFfree(nb);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->dctable[o]!=0)\n\t\t\t\t_TIFFfree(sp->dctable[o]);\n\t\t\tsp->dctable[o]=nb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((o&240)!=16)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n                                _TIFFfree(nb);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\to&=15;\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n                                _TIFFfree(nb);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->actable[o]!=0)\n\t\t\t\t_TIFFfree(sp->actable[o]);\n\t\t\tsp->actable[o]=nb;\n\t\t}\n\t}\n\treturn(1);\n}", "target": 0}
{"idx": 5758, "func": "void ff_rgb24toyv12_c(const uint8_t *src, uint8_t *ydst, uint8_t *udst,\n                   uint8_t *vdst, int width, int height, int lumStride,\n                   int chromStride, int srcStride, int32_t *rgb2yuv)\n{\n    int32_t ry = rgb2yuv[RY_IDX], gy = rgb2yuv[GY_IDX], by = rgb2yuv[BY_IDX];\n    int32_t ru = rgb2yuv[RU_IDX], gu = rgb2yuv[GU_IDX], bu = rgb2yuv[BU_IDX];\n    int32_t rv = rgb2yuv[RV_IDX], gv = rgb2yuv[GV_IDX], bv = rgb2yuv[BV_IDX];\n    int y;\n    const int chromWidth = width >> 1;\n\n    for (y = 0; y < height; y += 2) {\n        int i;\n        for (i = 0; i < chromWidth; i++) {\n            unsigned int b = src[6 * i + 0];\n            unsigned int g = src[6 * i + 1];\n            unsigned int r = src[6 * i + 2];\n\n            unsigned int Y = ((ry * r + gy * g + by * b) >> RGB2YUV_SHIFT) +  16;\n            unsigned int V = ((rv * r + gv * g + bv * b) >> RGB2YUV_SHIFT) + 128;\n            unsigned int U = ((ru * r + gu * g + bu * b) >> RGB2YUV_SHIFT) + 128;\n\n            udst[i]     = U;\n            vdst[i]     = V;\n            ydst[2 * i] = Y;\n\n            b = src[6 * i + 3];\n            g = src[6 * i + 4];\n            r = src[6 * i + 5];\n\n            Y = ((ry * r + gy * g + by * b) >> RGB2YUV_SHIFT) + 16;\n            ydst[2 * i + 1] = Y;\n        }\n        ydst += lumStride;\n        src  += srcStride;\n\n        if (y+1 == height)\n            break;\n\n        for (i = 0; i < chromWidth; i++) {\n            unsigned int b = src[6 * i + 0];\n            unsigned int g = src[6 * i + 1];\n            unsigned int r = src[6 * i + 2];\n\n            unsigned int Y = ((ry * r + gy * g + by * b) >> RGB2YUV_SHIFT) + 16;\n\n            ydst[2 * i] = Y;\n\n            b = src[6 * i + 3];\n            g = src[6 * i + 4];\n            r = src[6 * i + 5];\n\n            Y = ((ry * r + gy * g + by * b) >> RGB2YUV_SHIFT) + 16;\n            ydst[2 * i + 1] = Y;\n        }\n        udst += chromStride;\n        vdst += chromStride;\n        ydst += lumStride;\n        src  += srcStride;\n    }\n}", "target": 0}
{"idx": 5759, "func": "BIGNUM *bn_expand2(BIGNUM *b, int words)\n{\n    bn_check_top(b);\n\n    if (words > b->dmax) {\n        BN_ULONG *a = bn_expand_internal(b, words);\n        if (!a)\n            return NULL;\n        if (b->d) {\n            OPENSSL_cleanse(b->d, b->dmax * sizeof(b->d[0]));\n            bn_free_d(b);\n        }\n        b->d = a;\n        b->dmax = words;\n    }\n\n    bn_check_top(b);\n    return b;\n}", "target": 1}
{"idx": 5760, "func": "static int v410_encode_frame(AVCodecContext *avctx, uint8_t *buf,\n                             int buf_size, void *data)\n{\n    AVFrame *pic = data;\n    uint8_t *dst = buf;\n    uint16_t *y, *u, *v;\n    uint32_t val;\n    int i, j;\n    int output_size = 0;\n\n    if (buf_size < avctx->width * avctx->height * 3) {\n        av_log(avctx, AV_LOG_ERROR, \"Out buffer is too small.\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    avctx->coded_frame->reference = 0;\n    avctx->coded_frame->key_frame = 1;\n    avctx->coded_frame->pict_type = FF_I_TYPE;\n\n    y = (uint16_t *)pic->data[0];\n    u = (uint16_t *)pic->data[1];\n    v = (uint16_t *)pic->data[2];\n\n    for (i = 0; i < avctx->height; i++) {\n        for (j = 0; j < avctx->width; j++) {\n            val  = u[j] << 2;\n            val |= y[j] << 12;\n            val |= v[j] << 22;\n            AV_WL32(dst, val);\n            dst += 4;\n            output_size += 4;\n        }\n        y += pic->linesize[0] >> 1;\n        u += pic->linesize[1] >> 1;\n        v += pic->linesize[2] >> 1;\n    }\n\n    return output_size;\n}", "target": 1}
{"idx": 5761, "func": "static int ffserver_parse_config_feed(FFServerConfig *config, const char *cmd, const char **p,\n                                      FFServerStream **pfeed)\n{\n    FFServerStream *feed;\n    char arg[1024];\n    av_assert0(pfeed);\n    feed = *pfeed;\n    if (!av_strcasecmp(cmd, \"<Feed\")) {\n        char *q;\n        FFServerStream *s;\n        feed = av_mallocz(sizeof(FFServerStream));\n        if (!feed)\n            return AVERROR(ENOMEM);\n        ffserver_get_arg(feed->filename, sizeof(feed->filename), p);\n        q = strrchr(feed->filename, '>');\n        if (*q)\n            *q = '\\0';\n\n        for (s = config->first_feed; s; s = s->next) {\n            if (!strcmp(feed->filename, s->filename))\n                ERROR(\"Feed '%s' already registered\\n\", s->filename);\n        }\n\n        feed->fmt = av_guess_format(\"ffm\", NULL, NULL);\n        /* default feed file */\n        snprintf(feed->feed_filename, sizeof(feed->feed_filename),\n                 \"/tmp/%s.ffm\", feed->filename);\n        feed->feed_max_size = 5 * 1024 * 1024;\n        feed->is_feed = 1;\n        feed->feed = feed; /* self feeding :-) */\n        *pfeed = feed;\n        return 0;\n    }\n    av_assert0(feed);\n    if (!av_strcasecmp(cmd, \"Launch\")) {\n        int i;\n\n        feed->child_argv = av_mallocz_array(MAX_CHILD_ARGS, sizeof(char *));\n        if (!feed->child_argv)\n            return AVERROR(ENOMEM);\n        for (i = 0; i < MAX_CHILD_ARGS - 2; i++) {\n            ffserver_get_arg(arg, sizeof(arg), p);\n            if (!arg[0])\n                break;\n\n            feed->child_argv[i] = av_strdup(arg);\n            if (!feed->child_argv[i])\n                return AVERROR(ENOMEM);\n        }\n\n        feed->child_argv[i] =\n            av_asprintf(\"http://%s:%d/%s\",\n                        (config->http_addr.sin_addr.s_addr == INADDR_ANY) ? \"127.0.0.1\" :\n                        inet_ntoa(config->http_addr.sin_addr), ntohs(config->http_addr.sin_port),\n                        feed->filename);\n        if (!feed->child_argv[i])\n            return AVERROR(ENOMEM);\n    } else if (!av_strcasecmp(cmd, \"ACL\")) {\n        ffserver_parse_acl_row(NULL, feed, NULL, *p, config->filename,\n                config->line_num);\n    } else if (!av_strcasecmp(cmd, \"File\") || !av_strcasecmp(cmd, \"ReadOnlyFile\")) {\n        ffserver_get_arg(feed->feed_filename, sizeof(feed->feed_filename), p);\n        feed->readonly = !av_strcasecmp(cmd, \"ReadOnlyFile\");\n    } else if (!av_strcasecmp(cmd, \"Truncate\")) {\n        ffserver_get_arg(arg, sizeof(arg), p);\n        /* assume Truncate is true in case no argument is specified */\n        if (!arg[0]) {\n            feed->truncate = 1;\n        } else {\n            WARNING(\"Truncate N syntax in configuration file is deprecated, \"\n                    \"use Truncate alone with no arguments\\n\");\n            feed->truncate = strtod(arg, NULL);\n        }\n    } else if (!av_strcasecmp(cmd, \"FileMaxSize\")) {\n        char *p1;\n        double fsize;\n\n        ffserver_get_arg(arg, sizeof(arg), p);\n        p1 = arg;\n        fsize = strtod(p1, &p1);\n        switch(av_toupper(*p1)) {\n        case 'K':\n            fsize *= 1024;\n            break;\n        case 'M':\n            fsize *= 1024 * 1024;\n            break;\n        case 'G':\n            fsize *= 1024 * 1024 * 1024;\n            break;\n        default:\n            ERROR(\"Invalid file size: %s\\n\", arg);\n            break;\n        }\n        feed->feed_max_size = (int64_t)fsize;\n        if (feed->feed_max_size < FFM_PACKET_SIZE*4)\n            ERROR(\"Feed max file size is too small, must be at least %d\\n\",\n                    FFM_PACKET_SIZE*4);\n    } else if (!av_strcasecmp(cmd, \"</Feed>\")) {\n        *pfeed = NULL;\n    } else {\n        ERROR(\"Invalid entry '%s' inside <Feed></Feed>\\n\", cmd);\n    }\n    return 0;\n}", "target": 0}
{"idx": 5762, "func": "static inline float scalar_product_float(const float * v1, const float * v2,\n                                         int size)\n{\n    float res = 0.;\n\n    while (size--)\n        res += *v1++ * *v2++;\n\n    return res;\n}", "target": 1}
{"idx": 5763, "func": "static void delta_decode(uint8_t *dst, const uint8_t *src, int src_size,\n                         uint8_t *state, const int8_t *table)\n{\n    uint8_t val = *state;\n\n    while (src_size--) {\n        uint8_t d = *src++;\n        val = av_clip_uint8(val + table[d & 0xF]);\n        *dst++ = val;\n        val = av_clip_uint8(val + table[d >> 4]);\n        *dst++ = val;\n    }\n\n    *state = val;\n}", "target": 0}
{"idx": 5764, "func": "static void clear_comments(char *p)\n\t{\n\tchar *to;\n\n\tto=p;\n\tfor (;;)\n\t\t{\n\t\tif (IS_COMMENT(*p))\n\t\t\t{\n\t\t\t*p='\\0';\n\t\t\treturn;\n\t\t\t}\n\t\tif (IS_QUOTE(*p))\n\t\t\t{\n\t\t\tp=scan_quote(p);\n\t\t\tcontinue;\n\t\t\t}\n\t\tif (IS_ESC(*p))\n\t\t\t{\n\t\t\tp=scan_esc(p);\n\t\t\tcontinue;\n\t\t\t}\n\t\tif (IS_EOF(*p))\n\t\t\treturn;\n\t\telse\n\t\t\tp++;\n\t\t}\n\t}", "target": 1}
{"idx": 5765, "func": "static int do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509, const EVP_MD *dgst,\n\t     STACK_OF(CONF_VALUE) *policy, TXT_DB *db, BIGNUM *serial, char *subj,\n\t     int email_dn, char *startdate, char *enddate, long days, int batch,\n\t     int verbose, X509_REQ *req, char *ext_sect, CONF *lconf,\n\t     unsigned long certopt, unsigned long nameopt, int default_op,\n\t     int ext_copy)\n\t{\n\tX509_NAME *name=NULL,*CAname=NULL,*subject=NULL, *dn_subject=NULL;\n\tASN1_UTCTIME *tm,*tmptm;\n\tASN1_STRING *str,*str2;\n\tASN1_OBJECT *obj;\n\tX509 *ret=NULL;\n\tX509_CINF *ci;\n\tX509_NAME_ENTRY *ne;\n\tX509_NAME_ENTRY *tne,*push;\n\tEVP_PKEY *pktmp;\n\tint ok= -1,i,j,last,nid;\n\tchar *p;\n\tCONF_VALUE *cv;\n\tchar *row[DB_NUMBER],**rrow,**irow=NULL;\n\tchar buf[25];\n\n\ttmptm=ASN1_UTCTIME_new();\n\tif (tmptm == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"malloc error\\n\");\n\t\treturn(0);\n\t\t}\n\n\tfor (i=0; i<DB_NUMBER; i++)\n\t\trow[i]=NULL;\n\n\tif (subj)\n\t\t{\n\t\tX509_NAME *n = do_subject(subj, email_dn);\n\n\t\tif (!n)\n\t\t\t{\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto err;\n\t\t\t}\n\t\tX509_REQ_set_subject_name(req,n);\n\t\treq->req_info->enc.modified = 1;\n\t\tX509_NAME_free(n);\n\t\t}\n\n\tif (default_op)\n\t\tBIO_printf(bio_err,\"The Subject's Distinguished Name is as follows\\n\");\n\n\tname=X509_REQ_get_subject_name(req);\n\tfor (i=0; i<X509_NAME_entry_count(name); i++)\n\t\t{\n\t\tne= X509_NAME_get_entry(name,i);\n\t\tstr=X509_NAME_ENTRY_get_data(ne);\n\t\tobj=X509_NAME_ENTRY_get_object(ne);\n\n\t\tif (msie_hack)\n\t\t\t{\n\t\t\t/* assume all type should be strings */\n\t\t\tnid=OBJ_obj2nid(ne->object);\n\n\t\t\tif (str->type == V_ASN1_UNIVERSALSTRING)\n\t\t\t\tASN1_UNIVERSALSTRING_to_string(str);\n\n\t\t\tif ((str->type == V_ASN1_IA5STRING) &&\n\t\t\t\t(nid != NID_pkcs9_emailAddress))\n\t\t\t\tstr->type=V_ASN1_T61STRING;\n\n\t\t\tif ((nid == NID_pkcs9_emailAddress) &&\n\t\t\t\t(str->type == V_ASN1_PRINTABLESTRING))\n\t\t\t\tstr->type=V_ASN1_IA5STRING;\n\t\t\t}\n\n\t\t/* If no EMAIL is wanted in the subject */\n\t\tif ((OBJ_obj2nid(obj) == NID_pkcs9_emailAddress) && (!email_dn))\n\t\t\tcontinue;\n\n\t\t/* check some things */\n\t\tif ((OBJ_obj2nid(obj) == NID_pkcs9_emailAddress) &&\n\t\t\t(str->type != V_ASN1_IA5STRING))\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"\\nemailAddress type needs to be of type IA5STRING\\n\");\n\t\t\tgoto err;\n\t\t\t}\n\t\tj=ASN1_PRINTABLE_type(str->data,str->length);\n\t\tif (\t((j == V_ASN1_T61STRING) &&\n\t\t\t (str->type != V_ASN1_T61STRING)) ||\n\t\t\t((j == V_ASN1_IA5STRING) &&\n\t\t\t (str->type == V_ASN1_PRINTABLESTRING)))\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"\\nThe string contains characters that are illegal for the ASN.1 type\\n\");\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tif (default_op)\n\t\t\told_entry_print(bio_err, obj, str);\n\t\t}\n\n\t/* Ok, now we check the 'policy' stuff. */\n\tif ((subject=X509_NAME_new()) == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\tgoto err;\n\t\t}\n\n\t/* take a copy of the issuer name before we mess with it. */\n\tCAname=X509_NAME_dup(x509->cert_info->subject);\n\tif (CAname == NULL) goto err;\n\tstr=str2=NULL;\n\n\tfor (i=0; i<sk_CONF_VALUE_num(policy); i++)\n\t\t{\n\t\tcv=sk_CONF_VALUE_value(policy,i); /* get the object id */\n\t\tif ((j=OBJ_txt2nid(cv->name)) == NID_undef)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"%s:unknown object type in 'policy' configuration\\n\",cv->name);\n\t\t\tgoto err;\n\t\t\t}\n\t\tobj=OBJ_nid2obj(j);\n\n\t\tlast= -1;\n\t\tfor (;;)\n\t\t\t{\n\t\t\t/* lookup the object in the supplied name list */\n\t\t\tj=X509_NAME_get_index_by_OBJ(name,obj,last);\n\t\t\tif (j < 0)\n\t\t\t\t{\n\t\t\t\tif (last != -1) break;\n\t\t\t\ttne=NULL;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ttne=X509_NAME_get_entry(name,j);\n\t\t\t\t}\n\t\t\tlast=j;\n\n\t\t\t/* depending on the 'policy', decide what to do. */\n\t\t\tpush=NULL;\n\t\t\tif (strcmp(cv->value,\"optional\") == 0)\n\t\t\t\t{\n\t\t\t\tif (tne != NULL)\n\t\t\t\t\tpush=tne;\n\t\t\t\t}\n\t\t\telse if (strcmp(cv->value,\"supplied\") == 0)\n\t\t\t\t{\n\t\t\t\tif (tne == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\"The %s field needed to be supplied and was missing\\n\",cv->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpush=tne;\n\t\t\t\t}\n\t\t\telse if (strcmp(cv->value,\"match\") == 0)\n\t\t\t\t{\n\t\t\t\tint last2;\n\n\t\t\t\tif (tne == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\"The mandatory %s field was missing\\n\",cv->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\tlast2= -1;\n\nagain2:\n\t\t\t\tj=X509_NAME_get_index_by_OBJ(CAname,obj,last2);\n\t\t\t\tif ((j < 0) && (last2 == -1))\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\"The %s field does not exist in the CA certificate,\\nthe 'policy' is misconfigured\\n\",cv->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\tif (j >= 0)\n\t\t\t\t\t{\n\t\t\t\t\tpush=X509_NAME_get_entry(CAname,j);\n\t\t\t\t\tstr=X509_NAME_ENTRY_get_data(tne);\n\t\t\t\t\tstr2=X509_NAME_ENTRY_get_data(push);\n\t\t\t\t\tlast2=j;\n\t\t\t\t\tif (ASN1_STRING_cmp(str,str2) != 0)\n\t\t\t\t\t\tgoto again2;\n\t\t\t\t\t}\n\t\t\t\tif (j < 0)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\"The %s field needed to be the same in the\\nCA certificate (%s) and the request (%s)\\n\",cv->name,((str2 == NULL)?\"NULL\":(char *)str2->data),((str == NULL)?\"NULL\":(char *)str->data));\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err,\"%s:invalid type in 'policy' configuration\\n\",cv->value);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\tif (push != NULL)\n\t\t\t\t{\n\t\t\t\tif (!X509_NAME_add_entry(subject,push, -1, 0))\n\t\t\t\t\t{\n\t\t\t\t\tif (push != NULL)\n\t\t\t\t\t\tX509_NAME_ENTRY_free(push);\n\t\t\t\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (j < 0) break;\n\t\t\t}\n\t\t}\n\n\tif (preserve)\n\t\t{\n\t\tX509_NAME_free(subject);\n\t\t/* subject=X509_NAME_dup(X509_REQ_get_subject_name(req)); */\n\t\tsubject=X509_NAME_dup(name);\n\t\tif (subject == NULL) goto err;\n\t\t}\n\n\tif (verbose)\n\t\tBIO_printf(bio_err,\"The subject name appears to be ok, checking data base for clashes\\n\");\n\n\t/* Build the correct Subject if no e-mail is wanted in the subject */\n\t/* and add it later on because of the method extensions are added (altName) */\n\t \n\tif (!email_dn)\n\t\t{\n\t\tif ((dn_subject=X509_NAME_new()) == NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tfor (i=0; i<X509_NAME_entry_count(subject); i++)\n\t\t\t{\n\t\t\tne= X509_NAME_get_entry(subject,i);\n\t\t\tobj=X509_NAME_ENTRY_get_object(ne);\n\t\t\tnid=OBJ_obj2nid(obj);\n\n\t\t\tstr=X509_NAME_ENTRY_get_data(ne);\n\n\t\t\tif (nid == NID_pkcs9_emailAddress) continue;\n\n\t\t\tif (!X509_NAME_add_entry(dn_subject,ne, -1, 0))\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\trow[DB_name]=X509_NAME_oneline(dn_subject,NULL,0);\n\trow[DB_serial]=BN_bn2hex(serial);\n\tif ((row[DB_name] == NULL) || (row[DB_serial] == NULL))\n\t\t{\n\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\tgoto err;\n\t\t}\n\n\trrow=TXT_DB_get_by_index(db,DB_name,row);\n\tif (rrow != NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"ERROR:There is already a certificate for %s\\n\",\n\t\t\trow[DB_name]);\n\t\t}\n\telse\n\t\t{\n\t\trrow=TXT_DB_get_by_index(db,DB_serial,row);\n\t\tif (rrow != NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"ERROR:Serial number %s has already been issued,\\n\",\n\t\t\t\trow[DB_serial]);\n\t\t\tBIO_printf(bio_err,\"      check the database/serial_file for corruption\\n\");\n\t\t\t}\n\t\t}\n\n\tif (rrow != NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\n\t\t\t\"The matching entry has the following details\\n\");\n\t\tif (rrow[DB_type][0] == 'E')\n\t\t\tp=\"Expired\";\n\t\telse if (rrow[DB_type][0] == 'R')\n\t\t\tp=\"Revoked\";\n\t\telse if (rrow[DB_type][0] == 'V')\n\t\t\tp=\"Valid\";\n\t\telse\n\t\t\tp=\"\\ninvalid type, Data base error\\n\";\n\t\tBIO_printf(bio_err,\"Type\t  :%s\\n\",p);;\n\t\tif (rrow[DB_type][0] == 'R')\n\t\t\t{\n\t\t\tp=rrow[DB_exp_date]; if (p == NULL) p=\"undef\";\n\t\t\tBIO_printf(bio_err,\"Was revoked on:%s\\n\",p);\n\t\t\t}\n\t\tp=rrow[DB_exp_date]; if (p == NULL) p=\"undef\";\n\t\tBIO_printf(bio_err,\"Expires on    :%s\\n\",p);\n\t\tp=rrow[DB_serial]; if (p == NULL) p=\"undef\";\n\t\tBIO_printf(bio_err,\"Serial Number :%s\\n\",p);\n\t\tp=rrow[DB_file]; if (p == NULL) p=\"undef\";\n\t\tBIO_printf(bio_err,\"File name     :%s\\n\",p);\n\t\tp=rrow[DB_name]; if (p == NULL) p=\"undef\";\n\t\tBIO_printf(bio_err,\"Subject Name  :%s\\n\",p);\n\t\tok= -1; /* This is now a 'bad' error. */\n\t\tgoto err;\n\t\t}\n\n\t/* We are now totally happy, lets make and sign the certificate */\n\tif (verbose)\n\t\tBIO_printf(bio_err,\"Everything appears to be ok, creating and signing the certificate\\n\");\n\n\tif ((ret=X509_new()) == NULL) goto err;\n\tci=ret->cert_info;\n\n#ifdef X509_V3\n\t/* Make it an X509 v3 certificate. */\n\tif (!X509_set_version(x509,2)) goto err;\n#endif\n\n\tif (BN_to_ASN1_INTEGER(serial,ci->serialNumber) == NULL)\n\t\tgoto err;\n\tif (!X509_set_issuer_name(ret,X509_get_subject_name(x509)))\n\t\tgoto err;\n\n\tif (strcmp(startdate,\"today\") == 0)\n\t\tX509_gmtime_adj(X509_get_notBefore(ret),0);\n\telse ASN1_UTCTIME_set_string(X509_get_notBefore(ret),startdate);\n\n\tif (enddate == NULL)\n\t\tX509_gmtime_adj(X509_get_notAfter(ret),(long)60*60*24*days);\n\telse ASN1_UTCTIME_set_string(X509_get_notAfter(ret),enddate);\n\n\tif (!X509_set_subject_name(ret,subject)) goto err;\n\n\tpktmp=X509_REQ_get_pubkey(req);\n\ti = X509_set_pubkey(ret,pktmp);\n\tEVP_PKEY_free(pktmp);\n\tif (!i) goto err;\n\n\t/* Lets add the extensions, if there are any */\n\tif (ext_sect)\n\t\t{\n\t\tX509V3_CTX ctx;\n\t\tif (ci->version == NULL)\n\t\t\tif ((ci->version=ASN1_INTEGER_new()) == NULL)\n\t\t\t\tgoto err;\n\t\tASN1_INTEGER_set(ci->version,2); /* version 3 certificate */\n\n\t\t/* Free the current entries if any, there should not\n\t\t * be any I believe */\n\t\tif (ci->extensions != NULL)\n\t\t\tsk_X509_EXTENSION_pop_free(ci->extensions,\n\t\t\t\t\t\t   X509_EXTENSION_free);\n\n\t\tci->extensions = NULL;\n\n\t\t/* Initialize the context structure */\n\t\tX509V3_set_ctx(&ctx, x509, ret, req, NULL, 0);\n\n\t\tif (extconf)\n\t\t\t{\n\t\t\tif (verbose)\n\t\t\t\tBIO_printf(bio_err, \"Extra configuration file found\\n\");\n \n\t\t\t/* Use the extconf configuration db LHASH */\n\t\t\tX509V3_set_nconf(&ctx, extconf);\n \n\t\t\t/* Test the structure (needed?) */\n\t\t\t/* X509V3_set_ctx_test(&ctx); */\n\n\t\t\t/* Adds exts contained in the configuration file */\n\t\t\tif (!X509V3_EXT_add_nconf(extconf, &ctx, ext_sect,ret))\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t    \"ERROR: adding extensions in section %s\\n\",\n\t\t\t\t\t\t\t\text_sect);\n\t\t\t\tERR_print_errors(bio_err);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (verbose)\n\t\t\t\tBIO_printf(bio_err, \"Successfully added extensions from file.\\n\");\n\t\t\t}\n\t\telse if (ext_sect)\n\t\t\t{\n\t\t\t/* We found extensions to be set from config file */\n\t\t\tX509V3_set_nconf(&ctx, lconf);\n\n\t\t\tif(!X509V3_EXT_add_nconf(lconf, &ctx, ext_sect, ret))\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err, \"ERROR: adding extensions in section %s\\n\", ext_sect);\n\t\t\t\tERR_print_errors(bio_err);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\tif (verbose) \n\t\t\t\tBIO_printf(bio_err, \"Successfully added extensions from config\\n\");\n\t\t\t}\n\t\t}\n\n\t/* Copy extensions from request (if any) */\n\n\tif (!copy_extensions(ret, req, ext_copy))\n\t\t{\n\t\tBIO_printf(bio_err, \"ERROR: adding extensions from request\\n\");\n\t\tERR_print_errors(bio_err);\n\t\tgoto err;\n\t\t}\n\n\t/* Set the right value for the noemailDN option */\n\tif( email_dn == 0 )\n\t\t{\n\t\tif (!X509_set_subject_name(ret,dn_subject)) goto err;\n\t\t}\n\n\tif (!default_op)\n\t\t{\n\t\tBIO_printf(bio_err, \"Certificate Details:\\n\");\n\t\t/* Never print signature details because signature not present */\n\t\tcertopt |= X509_FLAG_NO_SIGDUMP | X509_FLAG_NO_SIGNAME;\n\t\tX509_print_ex(bio_err, ret, nameopt, certopt); \n\t\t}\n\n\tBIO_printf(bio_err,\"Certificate is to be certified until \");\n\tASN1_UTCTIME_print(bio_err,X509_get_notAfter(ret));\n\tif (days) BIO_printf(bio_err,\" (%d days)\",days);\n\tBIO_printf(bio_err, \"\\n\");\n\n\tif (!batch)\n\t\t{\n\n\t\tBIO_printf(bio_err,\"Sign the certificate? [y/n]:\");\n\t\t(void)BIO_flush(bio_err);\n\t\tbuf[0]='\\0';\n\t\tfgets(buf,sizeof(buf)-1,stdin);\n\t\tif (!((buf[0] == 'y') || (buf[0] == 'Y')))\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"CERTIFICATE WILL NOT BE CERTIFIED\\n\");\n\t\t\tok=0;\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\n#ifndef OPENSSL_NO_DSA\n\tif (pkey->type == EVP_PKEY_DSA) dgst=EVP_dss1();\n\tpktmp=X509_get_pubkey(ret);\n\tif (EVP_PKEY_missing_parameters(pktmp) &&\n\t\t!EVP_PKEY_missing_parameters(pkey))\n\t\tEVP_PKEY_copy_parameters(pktmp,pkey);\n\tEVP_PKEY_free(pktmp);\n#endif\n\n\tif (!X509_sign(ret,pkey,dgst))\n\t\tgoto err;\n\n\t/* We now just add it to the database */\n\trow[DB_type]=(char *)OPENSSL_malloc(2);\n\n\ttm=X509_get_notAfter(ret);\n\trow[DB_exp_date]=(char *)OPENSSL_malloc(tm->length+1);\n\tmemcpy(row[DB_exp_date],tm->data,tm->length);\n\trow[DB_exp_date][tm->length]='\\0';\n\n\trow[DB_rev_date]=NULL;\n\n\t/* row[DB_serial] done already */\n\trow[DB_file]=(char *)OPENSSL_malloc(8);\n\t/* row[DB_name] done already */\n\n\tif ((row[DB_type] == NULL) || (row[DB_exp_date] == NULL) ||\n\t\t(row[DB_file] == NULL))\n\t\t{\n\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\tgoto err;\n\t\t}\n\tstrcpy(row[DB_file],\"unknown\");\n\trow[DB_type][0]='V';\n\trow[DB_type][1]='\\0';\n\n\tif ((irow=(char **)OPENSSL_malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\tgoto err;\n\t\t}\n\n\tfor (i=0; i<DB_NUMBER; i++)\n\t\t{\n\t\tirow[i]=row[i];\n\t\trow[i]=NULL;\n\t\t}\n\tirow[DB_NUMBER]=NULL;\n\n\tif (!TXT_DB_insert(db,irow))\n\t\t{\n\t\tBIO_printf(bio_err,\"failed to update database\\n\");\n\t\tBIO_printf(bio_err,\"TXT_DB error number %ld\\n\",db->error);\n\t\tgoto err;\n\t\t}\n\tok=1;\nerr:\n\tfor (i=0; i<DB_NUMBER; i++)\n\t\tif (row[i] != NULL) OPENSSL_free(row[i]);\n\n\tif (CAname != NULL)\n\t\tX509_NAME_free(CAname);\n\tif (subject != NULL)\n\t\tX509_NAME_free(subject);\n\tif (tmptm != NULL)\n\t\tASN1_UTCTIME_free(tmptm);\n\tif (ok <= 0)\n\t\t{\n\t\tif (ret != NULL) X509_free(ret);\n\t\tret=NULL;\n\t\t}\n\telse\n\t\t*xret=ret;\n\treturn(ok);\n\t}", "target": 1}
{"idx": 5766, "func": "X509_STORE_CTX *X509_STORE_CTX_new(void)\n{\n\tX509_STORE_CTX *ctx;\n\tctx = (X509_STORE_CTX *)OPENSSL_malloc(sizeof(X509_STORE_CTX));\n\tif (!ctx)\n\t\t{\n\t\tX509err(X509_F_X509_STORE_CTX_NEW,ERR_R_MALLOC_FAILURE);\n\t\treturn NULL;\n\t\t}\n\tmemset(ctx, 0, sizeof(X509_STORE_CTX));\n\treturn ctx;\n}", "target": 1}
{"idx": 5767, "func": "static int derive_secret_key_and_iv(SSL *s, int sending, const EVP_MD *md,\n                                    const EVP_CIPHER *ciph,\n                                    const unsigned char *insecret,\n                                    const unsigned char *hash,\n                                    const unsigned char *label,\n                                    size_t labellen, unsigned char *secret,\n                                    unsigned char *iv, EVP_CIPHER_CTX *ciph_ctx)\n{\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    size_t ivlen, keylen, taglen;\n    int hashleni = EVP_MD_size(md);\n    size_t hashlen;\n\n    /* Ensure cast to size_t is safe */\n    if (!ossl_assert(hashleni >= 0)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_DERIVE_SECRET_KEY_AND_IV,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n    hashlen = (size_t)hashleni;\n\n    if (!tls13_hkdf_expand(s, md, insecret, label, labellen, hash, hashlen,\n                           secret, hashlen, 1)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    /* TODO(size_t): convert me */\n    keylen = EVP_CIPHER_key_length(ciph);\n    if (EVP_CIPHER_mode(ciph) == EVP_CIPH_CCM_MODE) {\n        uint32_t algenc;\n\n        ivlen = EVP_CCM_TLS_IV_LEN;\n        if (s->s3->tmp.new_cipher == NULL) {\n            /* We've not selected a cipher yet - we must be doing early data */\n            algenc = s->session->cipher->algorithm_enc;\n        } else {\n            algenc = s->s3->tmp.new_cipher->algorithm_enc;\n        }\n        if (algenc & (SSL_AES128CCM8 | SSL_AES256CCM8))\n            taglen = EVP_CCM8_TLS_TAG_LEN;\n         else\n            taglen = EVP_CCM_TLS_TAG_LEN;\n    } else {\n        ivlen = EVP_CIPHER_iv_length(ciph);\n        taglen = 0;\n    }\n\n    if (!tls13_derive_key(s, md, secret, key, keylen)\n            || !tls13_derive_iv(s, md, secret, iv, ivlen)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    if (EVP_CipherInit_ex(ciph_ctx, ciph, NULL, NULL, NULL, sending) <= 0\n        || !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)\n        || (taglen != 0 && !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_TAG,\n                                                taglen, NULL))\n        || EVP_CipherInit_ex(ciph_ctx, NULL, NULL, key, NULL, -1) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_DERIVE_SECRET_KEY_AND_IV,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    return 1;\n err:\n    OPENSSL_cleanse(key, sizeof(key));\n    return 0;\n}", "target": 0}
{"idx": 5768, "func": "static int alloc_scratch_buffers(H264SliceContext *sl, int linesize)\n{\n    const H264Context *h = sl->h264;\n    int alloc_size = FFALIGN(FFABS(linesize) + 32, 32);\n\n    av_fast_malloc(&sl->bipred_scratchpad, &sl->bipred_scratchpad_allocated, 16 * 6 * alloc_size);\n    // edge emu needs blocksize + filter length - 1\n    // (= 21x21 for  h264)\n    av_fast_malloc(&sl->edge_emu_buffer, &sl->edge_emu_buffer_allocated, alloc_size * 2 * 21);\n\n    av_fast_mallocz(&sl->top_borders[0], &sl->top_borders_allocated[0],\n                   h->mb_width * 16 * 3 * sizeof(uint8_t) * 2);\n    av_fast_mallocz(&sl->top_borders[1], &sl->top_borders_allocated[1],\n                   h->mb_width * 16 * 3 * sizeof(uint8_t) * 2);\n\n    if (!sl->bipred_scratchpad || !sl->edge_emu_buffer ||\n        !sl->top_borders[0]    || !sl->top_borders[1]) {\n        av_freep(&sl->bipred_scratchpad);\n        av_freep(&sl->edge_emu_buffer);\n        av_freep(&sl->top_borders[0]);\n        av_freep(&sl->top_borders[1]);\n\n        sl->bipred_scratchpad_allocated = 0;\n        sl->edge_emu_buffer_allocated   = 0;\n        sl->top_borders_allocated[0]    = 0;\n        sl->top_borders_allocated[1]    = 0;\n        return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5769, "func": "static int check_intra_pred_mode(H264Context *h, int mode, int is_chroma){\n    MpegEncContext * const s = &h->s;\n    static const int8_t top [7]= {LEFT_DC_PRED8x8, 1,-1,-1};\n    static const int8_t left[7]= { TOP_DC_PRED8x8,-1, 2,-1,DC_128_PRED8x8};\n\n    if(mode > 6U) {\n        av_log(h->s.avctx, AV_LOG_ERROR, \"out of range intra chroma pred mode at %d %d\\n\", s->mb_x, s->mb_y);\n        return -1;\n    }\n\n    if(!(h->top_samples_available&0x8000)){\n        mode= top[ mode ];\n        if(mode<0){\n            av_log(h->s.avctx, AV_LOG_ERROR, \"top block unavailable for requested intra mode at %d %d\\n\", s->mb_x, s->mb_y);\n            return -1;\n        }\n    }\n\n    if((h->left_samples_available&0x8080) != 0x8080){\n        mode= left[ mode ];\n        if(is_chroma && (h->left_samples_available&0x8080)){ //mad cow disease mode, aka MBAFF + constrained_intra_pred\n            mode= ALZHEIMER_DC_L0T_PRED8x8 + (!(h->left_samples_available&0x8000)) + 2*(mode == DC_128_PRED8x8);\n        }\n        if(mode<0){\n            av_log(h->s.avctx, AV_LOG_ERROR, \"left block unavailable for requested intra mode at %d %d\\n\", s->mb_x, s->mb_y);\n            return -1;\n        }\n    }\n\n    return mode;\n}", "target": 0}
{"idx": 5770, "func": "void av_packet_free_side_data(AVPacket *pkt)\n{\n    int i;\n    for (i = 0; i < pkt->side_data_elems; i++)\n        av_freep(&pkt->side_data[i].data);\n    av_freep(&pkt->side_data);\n    pkt->side_data_elems = 0;\n}", "target": 1}
{"idx": 5771, "func": "int ERR_load_strings(int lib, ERR_STRING_DATA *str)\n{\n    if (ERR_load_ERR_strings() == 0)\n        return 0;\n\n    err_patch(lib, str);\n    err_load_strings(str);\n    return 1;\n}", "target": 0}
{"idx": 5772, "func": "static ngx_int_t\nngx_http_file_cache_lock(ngx_http_request_t *r, ngx_http_cache_t *c)\n{\n    ngx_msec_t                 now, timer;\n    ngx_http_file_cache_t     *cache;\n\n    if (!c->lock) {\n        return NGX_DECLINED;\n    }\n\n    now = ngx_current_msec;\n\n    cache = c->file_cache;\n\n    ngx_shmtx_lock(&cache->shpool->mutex);\n\n    timer = c->node->lock_time - now;\n\n    if (!c->node->updating || (ngx_msec_int_t) timer <= 0) {\n        c->node->updating = 1;\n        c->node->lock_time = now + c->lock_age;\n        c->updating = 1;\n        c->lock_time = c->node->lock_time;\n    }\n\n    ngx_shmtx_unlock(&cache->shpool->mutex);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http file cache lock u:%d wt:%M\",\n                   c->updating, c->wait_time);\n\n    if (c->updating) {\n        return NGX_DECLINED;\n    }\n\n    if (c->lock_timeout == 0) {\n        return NGX_HTTP_CACHE_SCARCE;\n    }\n\n    c->waiting = 1;\n\n    if (c->wait_time == 0) {\n        c->wait_time = now + c->lock_timeout;\n\n        c->wait_event.handler = ngx_http_file_cache_lock_wait_handler;\n        c->wait_event.data = r;\n        c->wait_event.log = r->connection->log;\n    }\n\n    timer = c->wait_time - now;\n\n    ngx_add_timer(&c->wait_event, (timer > 500) ? 500 : timer);\n\n    r->main->blocked++;\n\n    return NGX_AGAIN;\n}", "target": 0}
{"idx": 5773, "func": "static int normalize_samples(AC3EncodeContext *s)\n{\n    int v = 14 - log2_tab(s, s->windowed_samples, AC3_WINDOW_SIZE);\n    lshift_tab(s->windowed_samples, AC3_WINDOW_SIZE, v);\n    return v - 9;\n}", "target": 1}
{"idx": 5774, "func": "SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth)\n\t{\n\tSSL_CTX *ret=NULL;\n\n\tif (meth == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_NULL_SSL_METHOD_PASSED);\n\t\treturn(NULL);\n\t\t}\n\n#ifdef OPENSSL_FIPS\n\tif (FIPS_mode() && (meth->version < TLS1_VERSION))\t\n\t\t{\n\t\tSSLerr(SSL_F_SSL_CTX_NEW, SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);\n\t\treturn NULL;\n\t\t}\n#endif\n\n\tif (SSL_get_ex_data_X509_STORE_CTX_idx() < 0)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_X509_VERIFICATION_SETUP_PROBLEMS);\n\t\tgoto err;\n\t\t}\n\tret=(SSL_CTX *)OPENSSL_malloc(sizeof(SSL_CTX));\n\tif (ret == NULL)\n\t\tgoto err;\n\n\tmemset(ret,0,sizeof(SSL_CTX));\n\n\tret->method=meth;\n\n\tret->cert_store=NULL;\n\tret->session_cache_mode=SSL_SESS_CACHE_SERVER;\n\tret->session_cache_size=SSL_SESSION_CACHE_MAX_SIZE_DEFAULT;\n\tret->session_cache_head=NULL;\n\tret->session_cache_tail=NULL;\n\n\t/* We take the system default */\n\tret->session_timeout=meth->get_timeout();\n\n\tret->new_session_cb=0;\n\tret->remove_session_cb=0;\n\tret->get_session_cb=0;\n\tret->generate_session_id=0;\n\n\tmemset((char *)&ret->stats,0,sizeof(ret->stats));\n\n\tret->references=1;\n\tret->quiet_shutdown=0;\n\n/*\tret->cipher=NULL;*/\n/*\tret->s2->challenge=NULL;\n\tret->master_key=NULL;\n\tret->key_arg=NULL;\n\tret->s2->conn_id=NULL; */\n\n\tret->info_callback=NULL;\n\n\tret->app_verify_callback=0;\n\tret->app_verify_arg=NULL;\n\n\tret->max_cert_list=SSL_MAX_CERT_LIST_DEFAULT;\n\tret->read_ahead=0;\n\tret->msg_callback=0;\n\tret->msg_callback_arg=NULL;\n\tret->verify_mode=SSL_VERIFY_NONE;\n#if 0\n\tret->verify_depth=-1; /* Don't impose a limit (but x509_lu.c does) */\n#endif\n\tret->sid_ctx_length=0;\n\tret->default_verify_callback=NULL;\n\tif ((ret->cert=ssl_cert_new()) == NULL)\n\t\tgoto err;\n\n\tret->default_passwd_callback=0;\n\tret->default_passwd_callback_userdata=NULL;\n\tret->client_cert_cb=0;\n\tret->app_gen_cookie_cb=0;\n\tret->app_verify_cookie_cb=0;\n\n\tret->sessions=lh_SSL_SESSION_new();\n\tif (ret->sessions == NULL) goto err;\n\tret->cert_store=X509_STORE_new();\n\tif (ret->cert_store == NULL) goto err;\n\n\tssl_create_cipher_list(ret->method,\n\t\t&ret->cipher_list,&ret->cipher_list_by_id,\n\t\tmeth->version == SSL2_VERSION ? \"SSLv2\" : SSL_DEFAULT_CIPHER_LIST, ret->cert);\n\tif (ret->cipher_list == NULL\n\t    || sk_SSL_CIPHER_num(ret->cipher_list) <= 0)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_LIBRARY_HAS_NO_CIPHERS);\n\t\tgoto err2;\n\t\t}\n\n\tret->param = X509_VERIFY_PARAM_new();\n\tif (!ret->param)\n\t\tgoto err;\n\n\tif ((ret->rsa_md5=EVP_get_digestbyname(\"ssl2-md5\")) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL2_MD5_ROUTINES);\n\t\tgoto err2;\n\t\t}\n\tif ((ret->md5=EVP_get_digestbyname(\"ssl3-md5\")) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES);\n\t\tgoto err2;\n\t\t}\n\tif ((ret->sha1=EVP_get_digestbyname(\"ssl3-sha1\")) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES);\n\t\tgoto err2;\n\t\t}\n\n\tif ((ret->client_CA=sk_X509_NAME_new_null()) == NULL)\n\t\tgoto err;\n\n\tCRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_CTX, ret, &ret->ex_data);\n\n\tret->extra_certs=NULL;\n\t/* No compression for DTLS */\n\tif (!(meth->ssl3_enc->enc_flags & SSL_ENC_FLAG_DTLS))\n\t\tret->comp_methods=SSL_COMP_get_compression_methods();\n\n\tret->max_send_fragment = SSL3_RT_MAX_PLAIN_LENGTH;\n\n#ifndef OPENSSL_NO_TLSEXT\n\tret->tlsext_servername_callback = 0;\n\tret->tlsext_servername_arg = NULL;\n\t/* Setup RFC4507 ticket keys */\n\tif ((RAND_pseudo_bytes(ret->tlsext_tick_key_name, 16) <= 0)\n\t\t|| (RAND_bytes(ret->tlsext_tick_hmac_key, 16) <= 0)\n\t\t|| (RAND_bytes(ret->tlsext_tick_aes_key, 16) <= 0))\n\t\tret->options |= SSL_OP_NO_TICKET;\n\n\tret->tlsext_status_cb = 0;\n\tret->tlsext_status_arg = NULL;\n\n# ifndef OPENSSL_NO_NEXTPROTONEG\n\tret->next_protos_advertised_cb = 0;\n\tret->next_proto_select_cb = 0;\n# endif\n#endif\n#ifndef OPENSSL_NO_PSK\n\tret->psk_identity_hint=NULL;\n\tret->psk_client_callback=NULL;\n\tret->psk_server_callback=NULL;\n#endif\n#ifndef OPENSSL_NO_SRP\n\tSSL_CTX_SRP_CTX_init(ret);\n#endif\n\tret->custom_cli_ext_records = NULL;\n\tret->custom_cli_ext_records_count = 0;\n\tret->custom_srv_ext_records = NULL;\n\tret->custom_srv_ext_records_count = 0;\n\tret->cli_supp_data_records = NULL;\n\tret->cli_supp_data_records_count = 0;\n\tret->srv_supp_data_records = NULL;\n\tret->srv_supp_data_records_count = 0;\n#ifndef OPENSSL_NO_BUF_FREELISTS\n\tret->freelist_max_len = SSL_MAX_BUF_FREELIST_LEN_DEFAULT;\n\tret->rbuf_freelist = OPENSSL_malloc(sizeof(SSL3_BUF_FREELIST));\n\tif (!ret->rbuf_freelist)\n\t\tgoto err;\n\tret->rbuf_freelist->chunklen = 0;\n\tret->rbuf_freelist->len = 0;\n\tret->rbuf_freelist->head = NULL;\n\tret->wbuf_freelist = OPENSSL_malloc(sizeof(SSL3_BUF_FREELIST));\n\tif (!ret->wbuf_freelist)\n\t\t{\n\t\tOPENSSL_free(ret->rbuf_freelist);\n\t\tgoto err;\n\t\t}\n\tret->wbuf_freelist->chunklen = 0;\n\tret->wbuf_freelist->len = 0;\n\tret->wbuf_freelist->head = NULL;\n#endif\n#ifndef OPENSSL_NO_ENGINE\n\tret->client_cert_engine = NULL;\n#ifdef OPENSSL_SSL_CLIENT_ENGINE_AUTO\n#define eng_strx(x)\t#x\n#define eng_str(x)\teng_strx(x)\n\t/* Use specific client engine automatically... ignore errors */\n\t{\n\tENGINE *eng;\n\teng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));\n\tif (!eng)\n\t\t{\n\t\tERR_clear_error();\n\t\tENGINE_load_builtin_engines();\n\t\teng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));\n\t\t}\n\tif (!eng || !SSL_CTX_set_client_cert_engine(ret, eng))\n\t\tERR_clear_error();\n\t}\n#endif\n#endif\n\t/* Default is to connect to non-RI servers. When RI is more widely\n\t * deployed might change this.\n\t */\n\tret->options |= SSL_OP_LEGACY_SERVER_CONNECT;\n\n\treturn(ret);\nerr:\n\tSSLerr(SSL_F_SSL_CTX_NEW,ERR_R_MALLOC_FAILURE);\nerr2:\n\tif (ret != NULL) SSL_CTX_free(ret);\n\treturn(NULL);\n\t}", "target": 0}
{"idx": 5775, "func": "static int dca_decode_frame(AVCodecContext * avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n\n    int lfe_samples;\n    int num_core_channels = 0;\n    int i;\n    int xch_present = 0;\n    int16_t *samples = data;\n    DCAContext *s = avctx->priv_data;\n    int channels;\n\n\n    s->dca_buffer_size = dca_convert_bitstream(buf, buf_size, s->dca_buffer, DCA_MAX_FRAME_SIZE);\n    if (s->dca_buffer_size == -1) {\n        av_log(avctx, AV_LOG_ERROR, \"Not a valid DCA frame\\n\");\n        return -1;\n    }\n\n    init_get_bits(&s->gb, s->dca_buffer, s->dca_buffer_size * 8);\n    if (dca_parse_frame_header(s) < 0) {\n        //seems like the frame is corrupt, try with the next one\n        *data_size=0;\n        return buf_size;\n    }\n    //set AVCodec values with parsed data\n    avctx->sample_rate = s->sample_rate;\n    avctx->bit_rate = s->bit_rate;\n\n    for (i = 0; i < (s->sample_blocks / 8); i++) {\n        dca_decode_block(s, 0, i);\n    }\n\n    /* record number of core channels incase less than max channels are requested */\n    num_core_channels = s->prim_channels;\n\n    /* extensions start at 32-bit boundaries into bitstream */\n    skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n\n    while(get_bits_left(&s->gb) >= 32) {\n        uint32_t bits = get_bits_long(&s->gb, 32);\n\n        switch(bits) {\n        case 0x5a5a5a5a: {\n            int ext_base_ch = s->prim_channels;\n            int ext_amode, xch_fsize;\n\n            /* validate sync word using XCHFSIZE field */\n            xch_fsize = show_bits(&s->gb, 10);\n            if((s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize) &&\n               (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize + 1))\n                continue;\n\n            /* skip length-to-end-of-frame field for the moment */\n            skip_bits(&s->gb, 10);\n\n            /* extension amode should == 1, number of channels in extension */\n            /* AFAIK XCh is not used for more channels */\n            if ((ext_amode = get_bits(&s->gb, 4)) != 1) {\n                av_log(avctx, AV_LOG_ERROR, \"XCh extension amode %d not\"\n                       \" supported!\\n\",ext_amode);\n                continue;\n            }\n\n            /* much like core primary audio coding header */\n            dca_parse_audio_coding_header(s, ext_base_ch);\n\n            for (i = 0; i < (s->sample_blocks / 8); i++) {\n                dca_decode_block(s, ext_base_ch, i);\n            }\n\n            xch_present = 1;\n            break;\n        }\n        case 0x1d95f262:\n            av_log(avctx, AV_LOG_DEBUG, \"Possible X96 extension found at %d bits\\n\", get_bits_count(&s->gb));\n            av_log(avctx, AV_LOG_DEBUG, \"FSIZE96 = %d bytes\\n\", get_bits(&s->gb, 12)+1);\n            av_log(avctx, AV_LOG_DEBUG, \"REVNO = %d\\n\", get_bits(&s->gb, 4));\n            break;\n        }\n\n        skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n    }\n\n    channels = s->prim_channels + !!s->lfe;\n\n    if (s->amode<16) {\n        avctx->channel_layout = dca_core_channel_layout[s->amode];\n\n        if (xch_present && (!avctx->request_channels ||\n                            avctx->request_channels > num_core_channels)) {\n            avctx->channel_layout |= CH_BACK_CENTER;\n            if (s->lfe) {\n                avctx->channel_layout |= CH_LOW_FREQUENCY;\n                s->channel_order_tab = dca_channel_reorder_lfe_xch[s->amode];\n            } else {\n                s->channel_order_tab = dca_channel_reorder_nolfe_xch[s->amode];\n            }\n        } else {\n            if (s->lfe) {\n                avctx->channel_layout |= CH_LOW_FREQUENCY;\n                s->channel_order_tab = dca_channel_reorder_lfe[s->amode];\n            } else\n                s->channel_order_tab = dca_channel_reorder_nolfe[s->amode];\n        }\n\n        if (s->prim_channels > 0 &&\n            s->channel_order_tab[s->prim_channels - 1] < 0)\n            return -1;\n\n        if (avctx->request_channels == 2 && s->prim_channels > 2) {\n            channels = 2;\n            s->output = DCA_STEREO;\n            avctx->channel_layout = CH_LAYOUT_STEREO;\n        }\n    } else {\n        av_log(avctx, AV_LOG_ERROR, \"Non standard configuration %d !\\n\",s->amode);\n        return -1;\n    }\n\n\n    /* There is nothing that prevents a dts frame to change channel configuration\n       but FFmpeg doesn't support that so only set the channels if it is previously\n       unset. Ideally during the first probe for channels the crc should be checked\n       and only set avctx->channels when the crc is ok. Right now the decoder could\n       set the channels based on a broken first frame.*/\n    if (!avctx->channels)\n        avctx->channels = channels;\n\n    if (*data_size < (s->sample_blocks / 8) * 256 * sizeof(int16_t) * channels)\n        return -1;\n    *data_size = 256 / 8 * s->sample_blocks * sizeof(int16_t) * channels;\n\n    /* filter to get final output */\n    for (i = 0; i < (s->sample_blocks / 8); i++) {\n        dca_filter_channels(s, i);\n        s->dsp.float_to_int16_interleave(samples, s->samples_chanptr, 256, channels);\n        samples += 256 * channels;\n    }\n\n    /* update lfe history */\n    lfe_samples = 2 * s->lfe * (s->sample_blocks / 8);\n    for (i = 0; i < 2 * s->lfe * 4; i++) {\n        s->lfe_data[i] = s->lfe_data[i + lfe_samples];\n    }\n\n    return buf_size;\n}", "target": 0}
{"idx": 5776, "func": "static int64_t *concat_channels_lists(const int64_t *layouts, const int *counts)\n{\n    int nb_layouts = 0, nb_counts = 0, i;\n    int64_t *list;\n\n    if (layouts)\n        for (; layouts[nb_layouts] != -1; nb_layouts++);\n    if (counts)\n        for (; counts[nb_counts] != -1; nb_counts++);\n    if (nb_counts > INT_MAX - 1 - nb_layouts)\n        return NULL;\n    if (!(list = av_calloc(nb_layouts + nb_counts + 1, sizeof(*list))))\n        return NULL;\n    for (i = 0; i < nb_layouts; i++)\n        list[i] = layouts[i];\n    for (i = 0; i < nb_counts; i++)\n        list[nb_layouts + i] = FF_COUNT2LAYOUT(counts[i]);\n    list[nb_layouts + nb_counts] = -1;\n    return list;\n}", "target": 1}
{"idx": 5777, "func": "static int mov2textsub(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const char *args,\n                     uint8_t **poutbuf, int *poutbuf_size,\n                     const uint8_t *buf, int buf_size, int keyframe){\n    if (buf_size < 2) return 0;\n    *poutbuf_size = FFMIN(buf_size - 2, AV_RB16(buf));\n    *poutbuf = av_malloc(*poutbuf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!*poutbuf)\n        return AVERROR(ENOMEM);\n    memcpy(*poutbuf, buf + 2, *poutbuf_size);\n    return 1;\n}", "target": 0}
{"idx": 5778, "func": "static void block_in(BIO* b)\n\t{\n\tBIO_OK_CTX *ctx;\n\tEVP_MD_CTX *md;\n\tlong tl= 0;\n\tunsigned char tmp[EVP_MAX_MD_SIZE];\n\n\tctx=(BIO_OK_CTX *)b->ptr;\n\tmd= &(ctx->md);\n\n\tmemcpy(&tl, ctx->buf, OK_BLOCK_BLOCK);\n\ttl= swapem(tl);\n\tif (ctx->buf_len < tl+ OK_BLOCK_BLOCK+ md->digest->md_size) return;\n \n\tEVP_DigestUpdate(md, (unsigned char*) &(ctx->buf[OK_BLOCK_BLOCK]), tl);\n\tEVP_DigestFinal(md, tmp, NULL);\n\tif(memcmp(&(ctx->buf[tl+ OK_BLOCK_BLOCK]), tmp, md->digest->md_size) == 0)\n\t\t{\n\t\t/* there might be parts from next block lurking around ! */\n\t\tctx->buf_off_save= tl+ OK_BLOCK_BLOCK+ md->digest->md_size;\n\t\tctx->buf_len_save= ctx->buf_len;\n\t\tctx->buf_off= OK_BLOCK_BLOCK;\n\t\tctx->buf_len= tl+ OK_BLOCK_BLOCK;\n\t\tctx->blockout= 1;\n\t\t}\n\telse\n\t\t{\n\t\tctx->cont= 0;\n\t\t}\n\t}", "target": 0}
{"idx": 5779, "func": "int ssl_get_prev_session(SSL *s, CLIENTHELLO_MSG *hello)\n{\n    /* This is used only by servers. */\n\n    SSL_SESSION *ret = NULL;\n    int fatal = 0;\n    int try_session_cache = 0;\n    int r;\n\n    if (SSL_IS_TLS13(s)) {\n        int al;\n\n        if (!tls_parse_extension(s, TLSEXT_IDX_psk, EXT_CLIENT_HELLO,\n                                 hello->pre_proc_exts, NULL, 0, &al))\n            return -1;\n\n        ret = s->session;\n    } else {\n        /* sets s->ext.ticket_expected */\n        r = tls_get_ticket_from_client(s, hello, &ret);\n        switch (r) {\n        case -1:                   /* Error during processing */\n            fatal = 1;\n            goto err;\n        case 0:                    /* No ticket found */\n        case 1:                    /* Zero length ticket found */\n            try_session_cache = 1;\n            break;                  /* Ok to carry on processing session id. */\n        case 2:                    /* Ticket found but not decrypted. */\n        case 3:                    /* Ticket decrypted, *ret has been set. */\n            break;\n        default:\n            abort();\n        }\n    }\n\n    if (try_session_cache &&\n        ret == NULL &&\n        !(s->session_ctx->session_cache_mode &\n          SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)) {\n        SSL_SESSION data;\n\n        data.ssl_version = s->version;\n        memset(data.session_id, 0, sizeof(data.session_id));\n        memcpy(data.session_id, hello->session_id, hello->session_id_len);\n        data.session_id_length = hello->session_id_len;\n\n        CRYPTO_THREAD_read_lock(s->session_ctx->lock);\n        ret = lh_SSL_SESSION_retrieve(s->session_ctx->sessions, &data);\n        if (ret != NULL) {\n            /* don't allow other threads to steal it: */\n            SSL_SESSION_up_ref(ret);\n        }\n        CRYPTO_THREAD_unlock(s->session_ctx->lock);\n        if (ret == NULL)\n            s->session_ctx->stats.sess_miss++;\n    }\n\n    if (try_session_cache &&\n        ret == NULL && s->session_ctx->get_session_cb != NULL) {\n        int copy = 1;\n\n        ret = s->session_ctx->get_session_cb(s, hello->session_id,\n                                             hello->session_id_len,\n                                             &copy);\n\n        if (ret != NULL) {\n            s->session_ctx->stats.sess_cb_hit++;\n\n            /*\n             * Increment reference count now if the session callback asks us\n             * to do so (note that if the session structures returned by the\n             * callback are shared between threads, it must handle the\n             * reference count itself [i.e. copy == 0], or things won't be\n             * thread-safe).\n             */\n            if (copy)\n                SSL_SESSION_up_ref(ret);\n\n            /*\n             * Add the externally cached session to the internal cache as\n             * well if and only if we are supposed to.\n             */\n            if (!\n                (s->session_ctx->session_cache_mode &\n                 SSL_SESS_CACHE_NO_INTERNAL_STORE)) {\n                /*\n                 * The following should not return 1, otherwise, things are\n                 * very strange\n                 */\n                if (SSL_CTX_add_session(s->session_ctx, ret))\n                    goto err;\n            }\n        }\n    }\n\n    if (ret == NULL)\n        goto err;\n\n    /* Now ret is non-NULL and we own one of its reference counts. */\n\n    /* Check TLS version consistency */\n    if (ret->ssl_version != s->version)\n        goto err;\n\n    if (ret->sid_ctx_length != s->sid_ctx_length\n        || memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length)) {\n        /*\n         * We have the session requested by the client, but we don't want to\n         * use it in this context.\n         */\n        goto err;               /* treat like cache miss */\n    }\n\n    if ((s->verify_mode & SSL_VERIFY_PEER) && s->sid_ctx_length == 0) {\n        /*\n         * We can't be sure if this session is being used out of context,\n         * which is especially important for SSL_VERIFY_PEER. The application\n         * should have used SSL[_CTX]_set_session_id_context. For this error\n         * case, we generate an error instead of treating the event like a\n         * cache miss (otherwise it would be easy for applications to\n         * effectively disable the session cache by accident without anyone\n         * noticing).\n         */\n\n        SSLerr(SSL_F_SSL_GET_PREV_SESSION,\n               SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);\n        fatal = 1;\n        goto err;\n    }\n\n    if (ret->cipher == NULL) {\n        unsigned char buf[5], *p;\n        unsigned long l;\n\n        p = buf;\n        l = ret->cipher_id;\n        l2n(l, p);\n        if ((ret->ssl_version >> 8) >= SSL3_VERSION_MAJOR)\n            ret->cipher = ssl_get_cipher_by_char(s, &(buf[2]));\n        else\n            ret->cipher = ssl_get_cipher_by_char(s, &(buf[1]));\n        if (ret->cipher == NULL)\n            goto err;\n    }\n\n    if (ret->timeout < (long)(time(NULL) - ret->time)) { /* timeout */\n        s->session_ctx->stats.sess_timeout++;\n        if (try_session_cache) {\n            /* session was from the cache, so remove it */\n            SSL_CTX_remove_session(s->session_ctx, ret);\n        }\n        goto err;\n    }\n\n    /* Check extended master secret extension consistency */\n    if (ret->flags & SSL_SESS_FLAG_EXTMS) {\n        /* If old session includes extms, but new does not: abort handshake */\n        if (!(s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS)) {\n            SSLerr(SSL_F_SSL_GET_PREV_SESSION, SSL_R_INCONSISTENT_EXTMS);\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n            fatal = 1;\n            goto err;\n        }\n    } else if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) {\n        /* If new session includes extms, but old does not: do not resume */\n        goto err;\n    }\n\n    if (!SSL_IS_TLS13(s)) {\n        /* We already did this for TLS1.3 */\n        SSL_SESSION_free(s->session);\n        s->session = ret;\n    }\n\n    s->session_ctx->stats.sess_hit++;\n    s->verify_result = s->session->verify_result;\n\n    return 1;\n\n err:\n    if (ret != NULL) {\n        SSL_SESSION_free(ret);\n        /* In TLSv1.3 we already set s->session, so better NULL it out */\n        if (SSL_IS_TLS13(s))\n            s->session = NULL;\n\n        if (!try_session_cache) {\n            /*\n             * The session was from a ticket, so we should issue a ticket for\n             * the new session\n             */\n            s->ext.ticket_expected = 1;\n        }\n    }\n    if (fatal)\n        return -1;\n    else\n        return 0;\n}", "target": 1}
{"idx": 5780, "func": "static av_always_inline void\nyuv2422_2_c_template(SwsContext *c, const int16_t *buf[2],\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n                     const int16_t *abuf[2], uint8_t *dest, int dstW,\n                     int yalpha, int uvalpha, int y,\n                     enum PixelFormat target)\n{\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1];\n    int  yalpha1 = 4095 - yalpha;\n    int uvalpha1 = 4095 - uvalpha;\n    int i;\n\n    for (i = 0; i < (dstW >> 1); i++) {\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n        output_pixels(i * 4, Y1, U, Y2, V);\n    }\n}", "target": 0}
{"idx": 5781, "func": "int opt_default(const char *opt, const char *arg)\n{\n    const AVOption *oc, *of, *os, *oswr;\n    char opt_stripped[128];\n    const char *p;\n    const AVClass *cc = avcodec_get_class(), *fc = avformat_get_class(), *sc, *swr_class;\n\n    if (!(p = strchr(opt, ':')))\n        p = opt + strlen(opt);\n    av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));\n\n    if ((oc = av_opt_find(&cc, opt_stripped, NULL, 0,\n                         AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) ||\n        ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&\n         (oc = av_opt_find(&cc, opt + 1, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ))))\n        av_dict_set(&codec_opts, opt, arg, FLAGS(oc));\n    if ((of = av_opt_find(&fc, opt, NULL, 0,\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)))\n        av_dict_set(&format_opts, opt, arg, FLAGS(of));\n#if CONFIG_SWSCALE\n    sc = sws_get_class();\n    if ((os = av_opt_find(&sc, opt, NULL, 0,\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n        // XXX we only support sws_flags, not arbitrary sws options\n        int ret = av_opt_set(sws_opts, opt, arg, 0);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n            return ret;\n        }\n    }\n#endif\n    swr_class = swr_get_class();\n    if (!oc && !of && !os && (oswr = av_opt_find(&swr_class, opt, NULL, 0,\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n        int ret = av_opt_set(swr_opts, opt, arg, 0);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n            return ret;\n        }\n    }\n\n    if (oc || of || os || oswr)\n        return 0;\n    av_log(NULL, AV_LOG_ERROR, \"Unrecognized option '%s'\\n\", opt);\n    return AVERROR_OPTION_NOT_FOUND;\n}", "target": 1}
{"idx": 5782, "func": "static int poll_filters(void)\n{\n    AVFilterBufferRef *picref;\n    AVFrame *filtered_frame = NULL;\n    int i, ret, ret_all;\n    unsigned nb_success, nb_eof;\n    int64_t frame_pts;\n\n    while (1) {\n        /* Reap all buffers present in the buffer sinks */\n        for (i = 0; i < nb_output_streams; i++) {\n            OutputStream *ost = output_streams[i];\n            OutputFile    *of = output_files[ost->file_index];\n            int ret = 0;\n\n            if (!ost->filter || ost->is_past_recording_time)\n                continue;\n\n            if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) {\n                return AVERROR(ENOMEM);\n            } else\n                avcodec_get_frame_defaults(ost->filtered_frame);\n            filtered_frame = ost->filtered_frame;\n\n            while (1) {\n                AVRational ist_pts_tb = ost->filter->filter->inputs[0]->time_base;\n                if (ost->enc->type == AVMEDIA_TYPE_AUDIO &&\n                    !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE))\n                    ret = av_buffersink_read_samples(ost->filter->filter, &picref,\n                                                    ost->st->codec->frame_size);\n                else\n#ifdef SINKA\n                    ret = av_buffersink_read(ost->filter->filter, &picref);\n#else\n                    ret = av_buffersink_get_buffer_ref(ost->filter->filter, &picref,\n                                                       AV_BUFFERSINK_FLAG_NO_REQUEST);\n#endif\n                if (ret < 0) {\n                    if (ret != AVERROR(EAGAIN) && ret != AVERROR_EOF) {\n                        char buf[256];\n                        av_strerror(ret, buf, sizeof(buf));\n                        av_log(NULL, AV_LOG_WARNING,\n                               \"Error in av_buffersink_get_buffer_ref(): %s\\n\", buf);\n                    }\n                    break;\n                }\n                if (ost->enc->type == AVMEDIA_TYPE_VIDEO)\n                    filtered_frame->pts = frame_pts = av_rescale_q(picref->pts, ist_pts_tb, AV_TIME_BASE_Q);\n                else if (picref->pts != AV_NOPTS_VALUE)\n                    filtered_frame->pts = frame_pts = av_rescale_q(picref->pts,\n                                                    ost->filter->filter->inputs[0]->time_base,\n                                                    ost->st->codec->time_base) -\n                                        av_rescale_q(of->start_time,\n                                                    AV_TIME_BASE_Q,\n                                                    ost->st->codec->time_base);\n                //if (ost->source_index >= 0)\n                //    *filtered_frame= *input_streams[ost->source_index]->decoded_frame; //for me_threshold\n\n                if (of->start_time && filtered_frame->pts < of->start_time) {\n                    avfilter_unref_buffer(picref);\n                    continue;\n                }\n\n                switch (ost->filter->filter->inputs[0]->type) {\n                case AVMEDIA_TYPE_VIDEO:\n                    avfilter_fill_frame_from_video_buffer_ref(filtered_frame, picref);\n                    filtered_frame->pts = frame_pts;\n                    if (!ost->frame_aspect_ratio)\n                        ost->st->codec->sample_aspect_ratio = picref->video->sample_aspect_ratio;\n\n                    do_video_out(of->ctx, ost, filtered_frame,\n                                 same_quant ? ost->last_quality :\n                                              ost->st->codec->global_quality);\n                    break;\n                case AVMEDIA_TYPE_AUDIO:\n                    avfilter_copy_buf_props(filtered_frame, picref);\n                    filtered_frame->pts = frame_pts;\n                    do_audio_out(of->ctx, ost, filtered_frame);\n                    break;\n                default:\n                    // TODO support subtitle filters\n                    av_assert0(0);\n                }\n\n                avfilter_unref_buffer(picref);\n            }\n        }\n        /* Request frames through all the graphs */\n        ret_all = nb_success = nb_eof = 0;\n        for (i = 0; i < nb_filtergraphs; i++) {\n            ret = avfilter_graph_request_oldest(filtergraphs[i]->graph);\n            if (!ret) {\n                nb_success++;\n            } else if (ret == AVERROR_EOF) {\n                nb_eof++;\n            } else if (ret != AVERROR(EAGAIN)) {\n                char buf[256];\n                av_strerror(ret, buf, sizeof(buf));\n                av_log(NULL, AV_LOG_WARNING,\n                       \"Error in request_frame(): %s\\n\", buf);\n                ret_all = ret;\n            }\n        }\n        if (!nb_success)\n            break;\n        /* Try again if anything succeeded */\n    }\n    return nb_eof == nb_filtergraphs ? AVERROR_EOF : ret_all;\n}", "target": 0}
{"idx": 5783, "func": "BIGNUM *SRP_Calc_server_key(const BIGNUM *A, const BIGNUM *v, const BIGNUM *u,\n                            const BIGNUM *b, const BIGNUM *N)\n{\n    BIGNUM *tmp = NULL, *S = NULL;\n    BN_CTX *bn_ctx;\n\n    if (u == NULL || A == NULL || v == NULL || b == NULL || N == NULL)\n        return NULL;\n\n    if ((bn_ctx = BN_CTX_new()) == NULL || (tmp = BN_new()) == NULL)\n        goto err;\n\n    /* S = (A*v**u) ** b */\n\n    if (!BN_mod_exp(tmp, v, u, N, bn_ctx))\n        goto err;\n    if (!BN_mod_mul(tmp, A, tmp, N, bn_ctx))\n        goto err;\n\n    S = BN_new();\n    if (S != NULL && !BN_mod_exp(S, tmp, b, N, bn_ctx)) {\n        BN_free(S);\n        S = NULL;\n    }\n err:\n    BN_CTX_free(bn_ctx);\n    BN_clear_free(tmp);\n    return S;\n}", "target": 1}
{"idx": 5784, "func": "static void init_block_index(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    ff_init_block_index(s);\n    if (v->field_mode && !(v->second_field ^ v->tff)) {\n        s->dest[0] += s->current_picture_ptr->f->linesize[0];\n        s->dest[1] += s->current_picture_ptr->f->linesize[1];\n        s->dest[2] += s->current_picture_ptr->f->linesize[2];\n    }\n}", "target": 0}
{"idx": 5785, "func": "static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int i, v, offset, count, segments;\n\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return -1;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n        if (frame_end - frame < 2)\n            return -1;\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 2;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count*2 + width)\n                return -1;\n            for (i = 0; i < count; i++) {\n                frame[0] = frame[1] =\n                frame[width] = frame[width + 1] = frame[-offset];\n\n                frame += 2;\n            }\n        } else if (bitbuf & (mask << 1)) {\n            frame += bytestream2_get_le16(gb) * 2;\n        } else {\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n        }\n        mask <<= 2;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5786, "func": "static int dts_probe(AVProbeData *p)\n{\n    const uint8_t *buf, *bufp;\n    uint32_t state = -1;\n    int markers[4*16] = {0};\n    int exss_markers = 0, exss_nextpos = 0;\n    int sum, max, pos, ret, i;\n    int64_t diff = 0;\n    uint8_t hdr[DCA_CORE_FRAME_HEADER_SIZE + AV_INPUT_BUFFER_PADDING_SIZE] = { 0 };\n\n    for (pos = FFMIN(4096, p->buf_size); pos < p->buf_size - 2; pos += 2) {\n        int marker, wide_hdr, hdr_size, framesize;\n        DCACoreFrameHeader h;\n        GetBitContext gb;\n\n        bufp = buf = p->buf + pos;\n        state = (state << 16) | bytestream_get_be16(&bufp);\n\n        if (pos >= 4)\n            diff += FFABS(((int16_t)AV_RL16(buf)) - (int16_t)AV_RL16(buf-4));\n\n        /* extension substream (EXSS) */\n        if (state == DCA_SYNCWORD_SUBSTREAM) {\n            if (pos < exss_nextpos)\n                continue;\n\n            init_get_bits(&gb, buf - 2, 96);\n            skip_bits_long(&gb, 42);\n\n            wide_hdr  = get_bits1(&gb);\n            hdr_size  = get_bits(&gb,  8 + 4 * wide_hdr) + 1;\n            framesize = get_bits(&gb, 16 + 4 * wide_hdr) + 1;\n            if (hdr_size & 3 || framesize & 3)\n                continue;\n            if (hdr_size < 16 || framesize < hdr_size)\n                continue;\n            if (pos - 2 + hdr_size > p->buf_size)\n                continue;\n            if (av_crc(av_crc_get_table(AV_CRC_16_CCITT), 0xffff, buf + 3, hdr_size - 5))\n                continue;\n\n            if (pos == exss_nextpos)\n                exss_markers++;\n            else\n                exss_markers = FFMAX(1, exss_markers - 1);\n            exss_nextpos = pos + framesize;\n            continue;\n        }\n\n        /* regular bitstream */\n        if (state == DCA_SYNCWORD_CORE_BE &&\n            (bytestream_get_be16(&bufp) & 0xFC00) == 0xFC00)\n            marker = 0;\n        else if (state == DCA_SYNCWORD_CORE_LE &&\n                 (bytestream_get_be16(&bufp) & 0x00FC) == 0x00FC)\n            marker = 1;\n\n        /* 14 bits big-endian bitstream */\n        else if (state == DCA_SYNCWORD_CORE_14B_BE &&\n                 (bytestream_get_be16(&bufp) & 0xFFF0) == 0x07F0)\n            marker = 2;\n\n        /* 14 bits little-endian bitstream */\n        else if (state == DCA_SYNCWORD_CORE_14B_LE &&\n                 (bytestream_get_be16(&bufp) & 0xF0FF) == 0xF007)\n            marker = 3;\n        else\n            continue;\n\n        if ((ret = avpriv_dca_convert_bitstream(buf - 2, DCA_CORE_FRAME_HEADER_SIZE,\n                                                hdr,     DCA_CORE_FRAME_HEADER_SIZE)) < 0)\n            continue;\n        if (init_get_bits8(&gb, hdr, ret) < 0)\n            continue;\n        if (avpriv_dca_parse_core_frame_header(&gb, &h) < 0)\n            continue;\n\n        marker += 4 * h.sr_code;\n\n        markers[marker] ++;\n    }\n\n    if (exss_markers > 3)\n        return AVPROBE_SCORE_EXTENSION + 1;\n\n    sum = max = 0;\n    for (i=0; i<FF_ARRAY_ELEMS(markers); i++) {\n        sum += markers[i];\n        if (markers[max] < markers[i])\n            max = i;\n    }\n\n    if (markers[max] > 3 && p->buf_size / markers[max] < 32*1024 &&\n        markers[max] * 4 > sum * 3 &&\n        diff / p->buf_size > 200)\n        return AVPROBE_SCORE_EXTENSION + 1;\n\n    return 0;\n}", "target": 0}
{"idx": 5787, "func": "char *BUF_strndup(const char *str, size_t siz)\n{\n    char *ret;\n\n    if (str == NULL)\n        return NULL;\n\n    siz = BUF_strnlen(str, siz);\n\n    if (siz >= INT_MAX)\n        return NULL;\n\n    ret = OPENSSL_malloc(siz + 1);\n    if (ret == NULL) {\n        BUFerr(BUF_F_BUF_STRNDUP, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    memcpy(ret, str, siz);\n    ret[siz] = '\\0';\n\n    return (ret);\n}", "target": 1}
{"idx": 5788, "func": "static void x8_init_block_index(MpegEncContext *s){ //FIXME maybe merge with ff_*\n//not s->linesize as this would be wrong for field pics\n//not that IntraX8 has interlacing support ;)\n    const int linesize   = s->current_picture.f->linesize[0];\n    const int uvlinesize = s->current_picture.f->linesize[1];\n\n    s->dest[0] = s->current_picture.f->data[0];\n    s->dest[1] = s->current_picture.f->data[1];\n    s->dest[2] = s->current_picture.f->data[2];\n\n    s->dest[0] +=   s->mb_y        *   linesize << 3;\n    s->dest[1] += ( s->mb_y&(~1) ) * uvlinesize << 2;//chroma blocks are on add rows\n    s->dest[2] += ( s->mb_y&(~1) ) * uvlinesize << 2;\n}", "target": 0}
{"idx": 5789, "func": "static int dxtory_decode_v1_444(AVCodecContext *avctx, AVFrame *pic,\n                                const uint8_t *src, int src_size)\n{\n    int h, w;\n    uint8_t *Y, *U, *V;\n    int ret;\n\n    if (src_size < avctx->width * avctx->height * 3L) {\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    Y = pic->data[0];\n    U = pic->data[1];\n    V = pic->data[2];\n    for (h = 0; h < avctx->height; h++) {\n        for (w = 0; w < avctx->width; w++) {\n            Y[w] = *src++;\n            U[w] = *src++ ^ 0x80;\n            V[w] = *src++ ^ 0x80;\n        }\n        Y += pic->linesize[0];\n        U += pic->linesize[1];\n        V += pic->linesize[2];\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5790, "func": "ENGINE *ENGINE_new(void)\n\t{\n\tENGINE *ret;\n\n\tret = (ENGINE *)OPENSSL_malloc(sizeof(ENGINE));\n\tif(ret == NULL)\n\t\t{\n\t\tENGINEerr(ENGINE_F_ENGINE_NEW, ERR_R_MALLOC_FAILURE);\n\t\treturn NULL;\n\t\t}\n\tmemset(ret, 0, sizeof(ENGINE));\n\tret->struct_ref = 1;\n\treturn ret;\n\t}", "target": 1}
{"idx": 5791, "func": "void rgb24toyv12_c(const uint8_t *src, uint8_t *ydst, uint8_t *udst,\n                   uint8_t *vdst, int width, int height, int lumStride,\n                   int chromStride, int srcStride)\n{\n    int y;\n    const int chromWidth = width >> 1;\n\n    for (y = 0; y < height; y += 2) {\n        int i;\n        for (i = 0; i < chromWidth; i++) {\n            unsigned int b = src[6 * i + 0];\n            unsigned int g = src[6 * i + 1];\n            unsigned int r = src[6 * i + 2];\n\n            unsigned int Y = ((RY * r + GY * g + BY * b) >> RGB2YUV_SHIFT) +  16;\n            unsigned int V = ((RV * r + GV * g + BV * b) >> RGB2YUV_SHIFT) + 128;\n            unsigned int U = ((RU * r + GU * g + BU * b) >> RGB2YUV_SHIFT) + 128;\n\n            udst[i]     = U;\n            vdst[i]     = V;\n            ydst[2 * i] = Y;\n\n            b = src[6 * i + 3];\n            g = src[6 * i + 4];\n            r = src[6 * i + 5];\n\n            Y = ((RY * r + GY * g + BY * b) >> RGB2YUV_SHIFT) + 16;\n            ydst[2 * i + 1] = Y;\n        }\n        ydst += lumStride;\n        src  += srcStride;\n\n        if (y+1 == height)\n            break;\n\n        for (i = 0; i < chromWidth; i++) {\n            unsigned int b = src[6 * i + 0];\n            unsigned int g = src[6 * i + 1];\n            unsigned int r = src[6 * i + 2];\n\n            unsigned int Y = ((RY * r + GY * g + BY * b) >> RGB2YUV_SHIFT) + 16;\n\n            ydst[2 * i] = Y;\n\n            b = src[6 * i + 3];\n            g = src[6 * i + 4];\n            r = src[6 * i + 5];\n\n            Y = ((RY * r + GY * g + BY * b) >> RGB2YUV_SHIFT) + 16;\n            ydst[2 * i + 1] = Y;\n        }\n        udst += chromStride;\n        vdst += chromStride;\n        ydst += lumStride;\n        src  += srcStride;\n    }\n}", "target": 0}
{"idx": 5792, "func": "static void mdct512(AC3MDCTContext *mdct, int32_t *out, int16_t *in)\n{\n    int i, re, im, n, n2, n4;\n    int16_t *rot = mdct->rot_tmp;\n    IComplex *x  = mdct->cplx_tmp;\n\n    n  = 1 << mdct->nbits;\n    n2 = n >> 1;\n    n4 = n >> 2;\n\n    /* shift to simplify computations */\n    for (i = 0; i <n4; i++)\n        rot[i] = -in[i + 3*n4];\n    memcpy(&rot[n4], &in[0], 3*n4*sizeof(*in));\n\n    /* pre rotation */\n    for (i = 0; i < n4; i++) {\n        re =  ((int)rot[   2*i] - (int)rot[ n-1-2*i]) >> 1;\n        im = -((int)rot[n2+2*i] - (int)rot[n2-1-2*i]) >> 1;\n        CMUL(x[i].re, x[i].im, re, im, -mdct->xcos1[i], mdct->xsin1[i], 15);\n    }\n\n    fft(mdct, x, mdct->nbits - 2);\n\n    /* post rotation */\n    for (i = 0; i < n4; i++) {\n        re = x[i].re;\n        im = x[i].im;\n        CMUL(out[n2-1-2*i], out[2*i], re, im, mdct->xsin1[i], mdct->xcos1[i], 0);\n    }\n}", "target": 1}
{"idx": 5793, "func": "static int execute_decode_slices(H264Context *h, int context_count)\n{\n    MpegEncContext *const s     = &h->s;\n    AVCodecContext *const avctx = s->avctx;\n    H264Context *hx;\n    int i;\n\n    if (s->avctx->hwaccel ||\n        s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        return 0;\n    if (context_count == 1) {\n        return decode_slice(avctx, &h);\n    } else {\n        for (i = 1; i < context_count; i++) {\n            hx                    = h->thread_context[i];\n            hx->s.err_recognition = avctx->err_recognition;\n            hx->s.error_count     = 0;\n            hx->x264_build        = h->x264_build;\n        }\n\n        avctx->execute(avctx, decode_slice, h->thread_context,\n                       NULL, context_count, sizeof(void *));\n\n        /* pull back stuff from slices to master context */\n        hx                   = h->thread_context[context_count - 1];\n        s->mb_x              = hx->s.mb_x;\n        s->mb_y              = hx->s.mb_y;\n        s->dropable          = hx->s.dropable;\n        s->picture_structure = hx->s.picture_structure;\n        for (i = 1; i < context_count; i++)\n            h->s.error_count += h->thread_context[i]->s.error_count;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5794, "func": "static int applehttp_read_header(AVFormatContext *s, AVFormatParameters *ap)\n{\n    AppleHTTPContext *c = s->priv_data;\n    int ret = 0, i, j, stream_offset = 0;\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n        goto fail;\n\n    if (c->n_variants == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n    /* If the playlist only contained variants, parse each individual\n     * variant playlist. */\n    if (c->n_variants > 1 || c->variants[0]->n_segments == 0) {\n        for (i = 0; i < c->n_variants; i++) {\n            struct variant *v = c->variants[i];\n            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0)\n                goto fail;\n        }\n    }\n\n    if (c->variants[0]->n_segments == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n\n    /* If this isn't a live stream, calculate the total duration of the\n     * stream. */\n    if (c->finished) {\n        int duration = 0;\n        for (i = 0; i < c->variants[0]->n_segments; i++)\n            duration += c->variants[0]->segments[i]->duration;\n        s->duration = duration * AV_TIME_BASE;\n    }\n\n    c->min_end_seq = INT_MAX;\n    /* Open the demuxer for each variant */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n        if (v->n_segments == 0)\n            continue;\n        c->max_start_seq = FFMAX(c->max_start_seq, v->start_seq_no);\n        c->min_end_seq   = FFMIN(c->min_end_seq,   v->start_seq_no +\n                                                   v->n_segments);\n        ret = av_open_input_file(&v->ctx, v->segments[0]->url, NULL, 0, NULL);\n        if (ret < 0)\n            goto fail;\n        url_fclose(v->ctx->pb);\n        v->ctx->pb = NULL;\n        v->stream_offset = stream_offset;\n        /* Create new AVStreams for each stream in this variant */\n        for (j = 0; j < v->ctx->nb_streams; j++) {\n            AVStream *st = av_new_stream(s, i);\n            if (!st) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n            avcodec_copy_context(st->codec, v->ctx->streams[j]->codec);\n        }\n        stream_offset += v->ctx->nb_streams;\n    }\n    c->last_packet_dts = AV_NOPTS_VALUE;\n\n    c->cur_seq_no = c->max_start_seq;\n    /* If this is a live stream with more than 3 segments, start at the\n     * third last segment. */\n    if (!c->finished && c->min_end_seq - c->max_start_seq > 3)\n        c->cur_seq_no = c->min_end_seq - 2;\n\n    return 0;\nfail:\n    free_variant_list(c);\n    return ret;\n}", "target": 1}
{"idx": 5795, "func": "static int test_gf2m_modsolvequad()\n{\n    BIGNUM *a, *b[2], *c, *d, *e;\n    int i, j, s = 0, t, st = 0;\n    int p0[] = { 163, 7, 6, 3, 0, -1 };\n    int p1[] = { 193, 15, 0, -1 };\n\n    a = BN_new();\n    b[0] = BN_new();\n    b[1] = BN_new();\n    c = BN_new();\n    d = BN_new();\n    e = BN_new();\n\n    BN_GF2m_arr2poly(p0, b[0]);\n    BN_GF2m_arr2poly(p1, b[1]);\n\n    for (i = 0; i < NUM0; i++) {\n        BN_bntest_rand(a, 512, 0, 0);\n        for (j = 0; j < 2; j++) {\n            t = BN_GF2m_mod_solve_quad(c, a, b[j], ctx);\n            if (t) {\n                s++;\n                BN_GF2m_mod_sqr(d, c, b[j], ctx);\n                BN_GF2m_add(d, c, d);\n                BN_GF2m_mod(e, a, b[j]);\n                BN_GF2m_add(e, e, d);\n                /*\n                 * Test that solution of quadratic c satisfies c^2 + c = a.\n                 */\n                if (!BN_is_zero(e)) {\n                    printf(\"GF(2^m) modular solve quadratic test failed!\\n\");\n                    goto err;\n                }\n\n            }\n        }\n    }\n    if (s == 0) {\n        printf(\"All %i tests of GF(2^m) modular solve quadratic resulted in no roots;\\n\",\n                NUM0);\n        printf(\"this is very unlikely and probably indicates an error.\\n\");\n        goto err;\n    }\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(b[0]);\n    BN_free(b[1]);\n    BN_free(c);\n    BN_free(d);\n    BN_free(e);\n    return st;\n}", "target": 0}
{"idx": 5796, "func": "static void mdct512(int32_t *out, int16_t *in)\n{\n    int i, re, im, re1, im1;\n    int16_t rot[MDCT_SAMPLES];\n    IComplex x[MDCT_SAMPLES/4];\n\n    /* shift to simplify computations */\n    for (i = 0; i < MDCT_SAMPLES/4; i++)\n        rot[i] = -in[i + 3*MDCT_SAMPLES/4];\n    memcpy(&rot[MDCT_SAMPLES/4], &in[0], 3*MDCT_SAMPLES/4*sizeof(*in));\n\n    /* pre rotation */\n    for (i = 0; i < MDCT_SAMPLES/4; i++) {\n        re =  ((int)rot[               2*i] - (int)rot[MDCT_SAMPLES  -1-2*i]) >> 1;\n        im = -((int)rot[MDCT_SAMPLES/2+2*i] - (int)rot[MDCT_SAMPLES/2-1-2*i]) >> 1;\n        CMUL(x[i].re, x[i].im, re, im, -xcos1[i], xsin1[i]);\n    }\n\n    fft(x, MDCT_NBITS - 2);\n\n    /* post rotation */\n    for (i = 0; i < MDCT_SAMPLES/4; i++) {\n        re = x[i].re;\n        im = x[i].im;\n        CMUL(re1, im1, re, im, xsin1[i], xcos1[i]);\n        out[                 2*i] = im1;\n        out[MDCT_SAMPLES/2-1-2*i] = re1;\n    }\n}", "target": 0}
{"idx": 5797, "func": "void ff_tak_parse_streaminfo(TAKStreamInfo *s, GetBitContext *gb)\n{\n    uint64_t channel_mask = 0;\n    int frame_type, i;\n\n    s->codec = get_bits(gb, TAK_ENCODER_CODEC_BITS);\n    skip_bits(gb, TAK_ENCODER_PROFILE_BITS);\n\n    frame_type = get_bits(gb, TAK_SIZE_FRAME_DURATION_BITS);\n    s->samples = get_bits64(gb, TAK_SIZE_SAMPLES_NUM_BITS);\n\n    s->data_type   = get_bits(gb, TAK_FORMAT_DATA_TYPE_BITS);\n    s->sample_rate = get_bits(gb, TAK_FORMAT_SAMPLE_RATE_BITS) +\n                     TAK_SAMPLE_RATE_MIN;\n    s->bps         = get_bits(gb, TAK_FORMAT_BPS_BITS) +\n                     TAK_BPS_MIN;\n    s->channels    = get_bits(gb, TAK_FORMAT_CHANNEL_BITS) +\n                     TAK_CHANNELS_MIN;\n\n    if (get_bits1(gb)) {\n        skip_bits(gb, TAK_FORMAT_VALID_BITS);\n        if (get_bits1(gb)) {\n            for (i = 0; i < s->channels; i++) {\n                int value = get_bits(gb, TAK_FORMAT_CH_LAYOUT_BITS);\n\n                if (value < FF_ARRAY_ELEMS(tak_channel_layouts))\n                    channel_mask |= tak_channel_layouts[value];\n            }\n        }\n    }\n\n    s->ch_layout     = channel_mask;\n    s->frame_samples = tak_get_nb_samples(s->sample_rate, frame_type);\n}", "target": 0}
{"idx": 5798, "func": "void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    /* let's disallow possible ambiguous cases */\n    if (size > (max_alloc_size-32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    //FIXME this isn't aligned correctly, though it probably isn't needed\n    if(!ptr) return av_malloc(size);\n    diff= ((char*)ptr)[-1];\n    ptr= realloc((char*)ptr - diff, size + diff);\n    if(ptr) ptr = (char*)ptr + diff;\n    return ptr;\n#else\n    return realloc(ptr, size + !size);\n#endif\n}", "target": 1}
{"idx": 5799, "func": "static void codebook_trellis_rate(AACEncContext *s, SingleChannelElement *sce,\n                                  int win, int group_len, const float lambda)\n{\n    BandCodingPath path[120][12];\n    int w, swb, cb, start, size;\n    int i, j;\n    const int max_sfb  = sce->ics.max_sfb;\n    const int run_bits = sce->ics.num_windows == 1 ? 5 : 3;\n    const int run_esc  = (1 << run_bits) - 1;\n    int idx, ppos, count;\n    int stackrun[120], stackcb[120], stack_len;\n    float next_minbits = INFINITY;\n    int next_mincb = 0;\n\n    abs_pow34_v(s->scoefs, sce->coeffs, 1024);\n    start = win*128;\n    for (cb = 0; cb < 12; cb++) {\n        path[0][cb].cost     = run_bits+4;\n        path[0][cb].prev_idx = -1;\n        path[0][cb].run      = 0;\n    }\n    for (swb = 0; swb < max_sfb; swb++) {\n        size = sce->ics.swb_sizes[swb];\n        if (sce->zeroes[win*16 + swb]) {\n            float cost_stay_here = path[swb][0].cost;\n            float cost_get_here  = next_minbits + run_bits + 4;\n            if (   run_value_bits[sce->ics.num_windows == 8][path[swb][0].run]\n                != run_value_bits[sce->ics.num_windows == 8][path[swb][0].run+1])\n                cost_stay_here += run_bits;\n            if (cost_get_here < cost_stay_here) {\n                path[swb+1][0].prev_idx = next_mincb;\n                path[swb+1][0].cost     = cost_get_here;\n                path[swb+1][0].run      = 1;\n            } else {\n                path[swb+1][0].prev_idx = 0;\n                path[swb+1][0].cost     = cost_stay_here;\n                path[swb+1][0].run      = path[swb][0].run + 1;\n            }\n            next_minbits = path[swb+1][0].cost;\n            next_mincb = 0;\n            for (cb = 1; cb < 12; cb++) {\n                path[swb+1][cb].cost = 61450;\n                path[swb+1][cb].prev_idx = -1;\n                path[swb+1][cb].run = 0;\n            }\n        } else {\n            float minbits = next_minbits;\n            int mincb = next_mincb;\n            int startcb = sce->band_type[win*16+swb];\n            next_minbits = INFINITY;\n            next_mincb = 0;\n            for (cb = 0; cb < startcb; cb++) {\n                path[swb+1][cb].cost = 61450;\n                path[swb+1][cb].prev_idx = -1;\n                path[swb+1][cb].run = 0;\n            }\n            for (cb = startcb; cb < 12; cb++) {\n                float cost_stay_here, cost_get_here;\n                float bits = 0.0f;\n                for (w = 0; w < group_len; w++) {\n                    bits += quantize_band_cost(s, sce->coeffs + start + w*128,\n                                               s->scoefs + start + w*128, size,\n                                               sce->sf_idx[(win+w)*16+swb], cb,\n                                               0, INFINITY, NULL);\n                }\n                cost_stay_here = path[swb][cb].cost + bits;\n                cost_get_here  = minbits            + bits + run_bits + 4;\n                if (   run_value_bits[sce->ics.num_windows == 8][path[swb][cb].run]\n                    != run_value_bits[sce->ics.num_windows == 8][path[swb][cb].run+1])\n                    cost_stay_here += run_bits;\n                if (cost_get_here < cost_stay_here) {\n                    path[swb+1][cb].prev_idx = mincb;\n                    path[swb+1][cb].cost     = cost_get_here;\n                    path[swb+1][cb].run      = 1;\n                } else {\n                    path[swb+1][cb].prev_idx = cb;\n                    path[swb+1][cb].cost     = cost_stay_here;\n                    path[swb+1][cb].run      = path[swb][cb].run + 1;\n                }\n                if (path[swb+1][cb].cost < next_minbits) {\n                    next_minbits = path[swb+1][cb].cost;\n                    next_mincb = cb;\n                }\n            }\n        }\n        start += sce->ics.swb_sizes[swb];\n    }\n\n    //convert resulting path from backward-linked list\n    stack_len = 0;\n    idx       = 0;\n    for (cb = 1; cb < 12; cb++)\n        if (path[max_sfb][cb].cost < path[max_sfb][idx].cost)\n            idx = cb;\n    ppos = max_sfb;\n    while (ppos > 0) {\n        av_assert1(idx >= 0);\n        cb = idx;\n        stackrun[stack_len] = path[ppos][cb].run;\n        stackcb [stack_len] = cb;\n        idx = path[ppos-path[ppos][cb].run+1][cb].prev_idx;\n        ppos -= path[ppos][cb].run;\n        stack_len++;\n    }\n    //perform actual band info encoding\n    start = 0;\n    for (i = stack_len - 1; i >= 0; i--) {\n        put_bits(&s->pb, 4, stackcb[i]);\n        count = stackrun[i];\n        memset(sce->zeroes + win*16 + start, !stackcb[i], count);\n        //XXX: memset when band_type is also uint8_t\n        for (j = 0; j < count; j++) {\n            sce->band_type[win*16 + start] =  stackcb[i];\n            start++;\n        }\n        while (count >= run_esc) {\n            put_bits(&s->pb, run_bits, run_esc);\n            count -= run_esc;\n        }\n        put_bits(&s->pb, run_bits, count);\n    }\n}", "target": 0}
{"idx": 5800, "func": "int ff_h264_field_end(H264Context *h, H264SliceContext *sl, int in_setup)\n{\n    AVCodecContext *const avctx = h->avctx;\n    int err = 0;\n    h->mb_y = 0;\n\n#if FF_API_CAP_VDPAU\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & AV_CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_set_reference_frames(h);\n#endif\n\n    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (!h->droppable) {\n            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n            h->prev_poc_msb = h->poc_msb;\n            h->prev_poc_lsb = h->poc_lsb;\n        }\n        h->prev_frame_num_offset = h->frame_num_offset;\n        h->prev_frame_num        = h->frame_num;\n    }\n\n    if (avctx->hwaccel) {\n        err = avctx->hwaccel->end_frame(avctx);\n        if (err < 0)\n            av_log(avctx, AV_LOG_ERROR,\n                   \"hardware accelerator failed to decode picture\\n\");\n    }\n\n#if FF_API_CAP_VDPAU\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & AV_CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_picture_complete(h);\n#endif\n\n    if (!in_setup && !h->droppable)\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    emms_c();\n\n    h->current_slice = 0;\n\n    return err;\n}", "target": 0}
{"idx": 5801, "func": "static inline void chroma_4mv_motion_lowres(MpegEncContext *s,\n                                            uint8_t *dest_cb, uint8_t *dest_cr,\n                                            uint8_t **ref_picture,\n                                            h264_chroma_mc_func * pix_op,\n                                            int mx, int my)\n{\n    const int lowres     = s->avctx->lowres;\n    const int op_index   = FFMIN(lowres, 3);\n    const int block_s    = 8 >> lowres;\n    const int s_mask     = (2 << lowres) - 1;\n    const int h_edge_pos = s->h_edge_pos >> lowres + 1;\n    const int v_edge_pos = s->v_edge_pos >> lowres + 1;\n    int emu = 0, src_x, src_y, offset, sx, sy;\n    uint8_t *ptr;\n\n    if (s->quarter_sample) {\n        mx /= 2;\n        my /= 2;\n    }\n\n    /* In case of 8X8, we construct a single chroma motion vector\n       with a special rounding */\n    mx = ff_h263_round_chroma(mx);\n    my = ff_h263_round_chroma(my);\n\n    sx = mx & s_mask;\n    sy = my & s_mask;\n    src_x = s->mb_x * block_s + (mx >> lowres + 1);\n    src_y = s->mb_y * block_s + (my >> lowres + 1);\n\n    offset = src_y * s->uvlinesize + src_x;\n    ptr = ref_picture[1] + offset;\n    if ((unsigned) src_x > FFMAX(h_edge_pos - (!!sx) - block_s, 0) ||\n        (unsigned) src_y > FFMAX(v_edge_pos - (!!sy) - block_s, 0)) {\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize,\n                                9, 9, src_x, src_y, h_edge_pos, v_edge_pos);\n        ptr = s->edge_emu_buffer;\n        emu = 1;\n    }\n    sx = (sx << 2) >> lowres;\n    sy = (sy << 2) >> lowres;\n    pix_op[op_index](dest_cb, ptr, s->uvlinesize, block_s, sx, sy);\n\n    ptr = ref_picture[2] + offset;\n    if (emu) {\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n                                src_x, src_y, h_edge_pos, v_edge_pos);\n        ptr = s->edge_emu_buffer;\n    }\n    pix_op[op_index](dest_cr, ptr, s->uvlinesize, block_s, sx, sy);\n}", "target": 1}
{"idx": 5802, "func": "static void flac_lpc_16_c(int32_t *decoded, const int coeffs[32],\n                          int pred_order, int qlevel, int len)\n{\n    int i, j;\n\n    for (i = pred_order; i < len - 1; i += 2, decoded += 2) {\n        int c = coeffs[0];\n        int d = decoded[0];\n        int s0 = 0, s1 = 0;\n        for (j = 1; j < pred_order; j++) {\n            s0 += c*d;\n            d = decoded[j];\n            s1 += c*d;\n            c = coeffs[j];\n        }\n        s0 += c*d;\n        d = decoded[j] += s0 >> qlevel;\n        s1 += c*d;\n        decoded[j + 1] += s1 >> qlevel;\n    }\n    if (i < len) {\n        int sum = 0;\n        for (j = 0; j < pred_order; j++)\n            sum += coeffs[j] * decoded[j];\n        decoded[j] += sum >> qlevel;\n    }\n}", "target": 1}
{"idx": 5803, "func": "int BIO_write(BIO *b, const void *in, int inl)\n{\n    int i;\n    long (*cb) (BIO *, int, const char *, int, long, long);\n\n    if (b == NULL)\n        return (0);\n\n    cb = b->callback;\n    if ((b->method == NULL) || (b->method->bwrite == NULL)) {\n        BIOerr(BIO_F_BIO_WRITE, BIO_R_UNSUPPORTED_METHOD);\n        return (-2);\n    }\n\n    if ((cb != NULL) &&\n        ((i = (int)cb(b, BIO_CB_WRITE, in, inl, 0L, 1L)) <= 0))\n        return (i);\n\n    if (!b->init) {\n        BIOerr(BIO_F_BIO_WRITE, BIO_R_UNINITIALIZED);\n        return (-2);\n    }\n\n    i = b->method->bwrite(b, in, inl);\n\n    if (i > 0)\n        b->num_write += (uint64_t)i;\n\n    if (cb != NULL)\n        i = (int)cb(b, BIO_CB_WRITE | BIO_CB_RETURN, in, inl, 0L, (long)i);\n    return (i);\n}", "target": 1}
{"idx": 5804, "func": "BIO *cms_EnvelopedData_init_bio(CMS_ContentInfo *cms)\n\t{\n\tCMS_EncryptedContentInfo *ec;\n\tSTACK_OF(CMS_RecipientInfo) *rinfos;\n\tCMS_RecipientInfo *ri;\n\tint i, ok = 0;\n\tBIO *ret;\n\n\t/* Get BIO first to set up key */\n\n\tec = cms->d.envelopedData->encryptedContentInfo;\n\tret = cms_EncryptedContent_init_bio(ec);\n\n\t/* If error or no cipher end of processing */\n\n\tif (!ret || !ec->cipher)\n\t\treturn ret;\n\n\t/* Now encrypt content key according to each RecipientInfo type */\n\n\trinfos = cms->d.envelopedData->recipientInfos;\n\n\tfor (i = 0; i < sk_CMS_RecipientInfo_num(rinfos); i++)\n\t\t{\n\t\tri = sk_CMS_RecipientInfo_value(rinfos, i);\n\t\tif (CMS_RecipientInfo_encrypt(cms, ri) <= 0)\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_ENVELOPEDDATA_INIT_BIO,\n\t\t\t\tCMS_R_ERROR_SETTING_RECIPIENTINFO);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\tok = 1;\n\n\terr:\n\tec->cipher = NULL;\n\tif (ec->key)\n\t\t{\n\t\tOPENSSL_cleanse(ec->key, ec->keylen);\n\t\tOPENSSL_free(ec->key);\n\t\tec->key = NULL;\n\t\tec->keylen = 0;\n\t\t}\n\tif (ok)\n\t\treturn ret;\n\tBIO_free(ret);\n\treturn NULL;\n\n\t}", "target": 0}
{"idx": 5805, "func": "void\nngx_rbtree_insert_timer_value(ngx_rbtree_node_t *temp, ngx_rbtree_node_t *node,\n    ngx_rbtree_node_t *sentinel)\n{\n    ngx_rbtree_node_t  **p;\n\n    for ( ;; ) {\n\n        /*\n         * Timer values\n         * 1) are spread in small range, usually several minutes,\n         * 2) and overflow each 49 days, if milliseconds are stored in 32 bits.\n         * The comparison takes into account that overflow.\n         */\n\n        /*  node->key < temp->key */\n\n        p = ((ngx_rbtree_key_int_t) node->key - (ngx_rbtree_key_int_t) temp->key\n              < 0)\n            ? &temp->left : &temp->right;\n\n        if (*p == sentinel) {\n            break;\n        }\n\n        temp = *p;\n    }\n\n    *p = node;\n    node->parent = temp;\n    node->left = sentinel;\n    node->right = sentinel;\n    ngx_rbt_red(node);\n}", "target": 0}
{"idx": 5806, "func": "int ff_h264_decode_sei(H264Context *h){\n    while (get_bits_left(&h->gb) > 16) {\n        int type;\n        unsigned size;\n\n        type=0;\n        do{\n            if (get_bits_left(&h->gb) < 8)\n                return AVERROR_INVALIDDATA;\n            type+= show_bits(&h->gb, 8);\n        }while(get_bits(&h->gb, 8) == 255);\n\n        size=0;\n        do{\n            if (get_bits_left(&h->gb) < 8)\n                return AVERROR_INVALIDDATA;\n            size+= show_bits(&h->gb, 8);\n        }while(get_bits(&h->gb, 8) == 255);\n\n        if(h->avctx->debug&FF_DEBUG_STARTCODE)\n            av_log(h->avctx, AV_LOG_DEBUG, \"SEI %d len:%d\\n\", type, size);\n\n        switch(type){\n        case SEI_TYPE_PIC_TIMING: // Picture timing SEI\n            if(decode_picture_timing(h) < 0)\n                return -1;\n            break;\n        case SEI_TYPE_USER_DATA_ITU_T_T35:\n            if(decode_user_data_itu_t_t35(h, size) < 0)\n                return -1;\n            break;\n        case SEI_TYPE_USER_DATA_UNREGISTERED:\n            if(decode_unregistered_user_data(h, size) < 0)\n                return -1;\n            break;\n        case SEI_TYPE_RECOVERY_POINT:\n            if(decode_recovery_point(h) < 0)\n                return -1;\n            break;\n        case SEI_BUFFERING_PERIOD:\n            if(decode_buffering_period(h) < 0)\n                return -1;\n            break;\n        case SEI_TYPE_FRAME_PACKING:\n            if(decode_frame_packing(h, size) < 0)\n                return -1;\n        default:\n            skip_bits(&h->gb, 8*size);\n        }\n\n        //FIXME check bits here\n        align_get_bits(&h->gb);\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5807, "func": "static int pcm_dvd_decode_frame(AVCodecContext *avctx, void *data,\n                                int *got_frame_ptr, AVPacket *avpkt)\n{\n    AVFrame *frame     = data;\n    const uint8_t *src = avpkt->data;\n    int buf_size       = avpkt->size;\n    PCMDVDContext *s   = avctx->priv_data;\n    int retval;\n    int blocks;\n    void *dst;\n\n    if (buf_size < 3) {\n        av_log(avctx, AV_LOG_ERROR, \"PCM packet too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((retval = pcm_dvd_parse_header(avctx, src)))\n        return retval;\n    src      += 3;\n    buf_size -= 3;\n\n    blocks = (buf_size + s->extra_sample_count) / s->block_size;\n\n    /* get output buffer */\n    frame->nb_samples = blocks * s->samples_per_block;\n    if ((retval = ff_get_buffer(avctx, frame, 0)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return retval;\n    }\n    dst = frame->data[0];\n\n    /* consume leftover samples from last packet */\n    if (s->extra_sample_count) {\n        int missing_samples = s->block_size - s->extra_sample_count;\n        if (buf_size >= missing_samples) {\n            memcpy(s->extra_samples + s->extra_sample_count, src,\n                   missing_samples);\n            dst = pcm_dvd_decode_samples(avctx, s->extra_samples, dst, 1);\n            src += missing_samples;\n            buf_size -= missing_samples;\n            s->extra_sample_count = 0;\n            blocks--;\n        } else {\n            /* new packet still doesn't have enough samples */\n            memcpy(s->extra_samples + s->extra_sample_count, src, buf_size);\n            s->extra_sample_count += buf_size;\n            return avpkt->size;\n        }\n    }\n\n    /* decode remaining complete samples */\n    if (blocks) {\n        pcm_dvd_decode_samples(avctx, src, dst, blocks);\n        buf_size -= blocks * s->block_size;\n    }\n\n    /* store leftover samples */\n    if (buf_size) {\n        src += blocks * s->block_size;\n        memcpy(s->extra_samples, src, buf_size);\n        s->extra_sample_count = buf_size;\n    }\n\n    *got_frame_ptr = 1;\n\n    return avpkt->size;\n}", "target": 1}
{"idx": 5808, "func": "static int\nOJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n\tstatic const char module[]=\"OJPEGDecodeRaw\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8* m;\n\ttmsize_t n;\n\tuint8* oy;\n\tuint8* ocb;\n\tuint8* ocr;\n\tuint8* p;\n\tuint32 q;\n\tuint8* r;\n\tuint8 sx,sy;\n\tif (cc%sp->bytes_per_line!=0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\");\n\t\treturn(0);\n\t}\n\tassert(cc>0);\n\tm=buf;\n\tn=cc;\n\tdo\n\t{\n\t\tif (sp->subsampling_convert_state==0)\n\t\t{\n\t\t\tconst jpeg_decompress_struct* cinfo = &sp->libjpeg_jpeg_decompress_struct;\n\t\t\tint width = 0;\n\t\t\tint last_col_width = 0;\n\t\t\tint jpeg_bytes;\n\t\t\tint expected_bytes;\n\t\t\tint i;\n\t\t\tif (cinfo->MCUs_per_row == 0)\n\t\t\t{\n\t\t\t\tsp->error_in_raw_data_decoding = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < cinfo->comps_in_scan; ++i)\n\t\t\t{\n\t\t\t\tconst jpeg_component_info* info = cinfo->cur_comp_info[i];\n#if JPEG_LIB_VERSION >= 70\n\t\t\t\twidth += info->MCU_width * info->DCT_h_scaled_size;\n\t\t\t\tlast_col_width += info->last_col_width * info->DCT_h_scaled_size;\n#else\n\t\t\t\twidth += info->MCU_width * info->DCT_scaled_size;\n\t\t\t\tlast_col_width += info->last_col_width * info->DCT_scaled_size;\n#endif\n\t\t\t}\n\t\t\tjpeg_bytes = (cinfo->MCUs_per_row - 1) * width + last_col_width;\n\t\t\texpected_bytes = sp->subsampling_convert_clinelenout * sp->subsampling_ver * sp->subsampling_hor;\n\t\t\tif (jpeg_bytes != expected_bytes)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Inconsistent number of MCU in codestream\");\n\t\t\t\tsp->error_in_raw_data_decoding = 1;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\n\t\t\t{\n\t\t\t\tsp->error_in_raw_data_decoding = 1;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\t\toy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen;\n\t\tocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\n\t\tocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\n\t\tp=m;\n\t\tfor (q=0; q<sp->subsampling_convert_clinelenout; q++)\n\t\t{\n\t\t\tr=oy;\n\t\t\tfor (sy=0; sy<sp->subsampling_ver; sy++)\n\t\t\t{\n\t\t\t\tfor (sx=0; sx<sp->subsampling_hor; sx++)\n\t\t\t\t\t*p++=*r++;\n\t\t\t\tr+=sp->subsampling_convert_ylinelen-sp->subsampling_hor;\n\t\t\t}\n\t\t\toy+=sp->subsampling_hor;\n\t\t\t*p++=*ocb++;\n\t\t\t*p++=*ocr++;\n\t\t}\n\t\tsp->subsampling_convert_state++;\n\t\tif (sp->subsampling_convert_state==sp->subsampling_convert_clines)\n\t\t\tsp->subsampling_convert_state=0;\n\t\tm+=sp->bytes_per_line;\n\t\tn-=sp->bytes_per_line;\n\t} while(n>0);\n\treturn(1);\n}", "target": 1}
{"idx": 5809, "func": "static int decode_lt_rps(HEVCContext *s, LongTermRPS *rps, GetBitContext *gb)\n{\n    const HEVCSPS *sps = s->ps.sps;\n    int max_poc_lsb    = 1 << sps->log2_max_poc_lsb;\n    int prev_delta_msb = 0;\n    unsigned int nb_sps = 0, nb_sh;\n    int i;\n\n    rps->nb_refs = 0;\n    if (!sps->long_term_ref_pics_present_flag)\n        return 0;\n\n    if (sps->num_long_term_ref_pics_sps > 0)\n        nb_sps = get_ue_golomb_long(gb);\n    nb_sh = get_ue_golomb_long(gb);\n\n    if (nb_sps > sps->num_long_term_ref_pics_sps)\n        return AVERROR_INVALIDDATA;\n    if (nb_sh + (uint64_t)nb_sps > FF_ARRAY_ELEMS(rps->poc))\n        return AVERROR_INVALIDDATA;\n\n    rps->nb_refs = nb_sh + nb_sps;\n\n    for (i = 0; i < rps->nb_refs; i++) {\n        uint8_t delta_poc_msb_present;\n\n        if (i < nb_sps) {\n            uint8_t lt_idx_sps = 0;\n\n            if (sps->num_long_term_ref_pics_sps > 1)\n                lt_idx_sps = get_bits(gb, av_ceil_log2(sps->num_long_term_ref_pics_sps));\n\n            rps->poc[i]  = sps->lt_ref_pic_poc_lsb_sps[lt_idx_sps];\n            rps->used[i] = sps->used_by_curr_pic_lt_sps_flag[lt_idx_sps];\n        } else {\n            rps->poc[i]  = get_bits(gb, sps->log2_max_poc_lsb);\n            rps->used[i] = get_bits1(gb);\n        }\n\n        delta_poc_msb_present = get_bits1(gb);\n        if (delta_poc_msb_present) {\n            int64_t delta = get_ue_golomb_long(gb);\n            int64_t poc;\n\n            if (i && i != nb_sps)\n                delta += prev_delta_msb;\n\n            poc = rps->poc[i] + s->poc - delta * max_poc_lsb - s->sh.pic_order_cnt_lsb;\n            if (poc != (int32_t)poc)\n                return AVERROR_INVALIDDATA;\n            rps->poc[i] = poc;\n            prev_delta_msb = delta;\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5810, "func": "int EVP_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, unsigned int *siglen,\n\t     EVP_PKEY *pkey)\n\t{\n\tunsigned char m[EVP_MAX_MD_SIZE];\n\tunsigned int m_len;\n\tint i,ok=0,v;\n\tMS_STATIC EVP_MD_CTX tmp_ctx;\n\n\t*siglen=0;\n\tEVP_MD_CTX_init(&tmp_ctx);\n\tif (!EVP_MD_CTX_copy_ex(&tmp_ctx,ctx))\n\t\tgoto err;  \n\tif (!EVP_DigestFinal_ex(&tmp_ctx,&(m[0]),&m_len))\n\t\tgoto err;\n\tEVP_MD_CTX_cleanup(&tmp_ctx);\n\n\tif (ctx->digest->flags & EVP_MD_FLAG_PKEY_METHOD_SIGNATURE)\n\t\t{\n\t\tEVP_PKEY_CTX *pkctx = NULL;\n\t\tsize_t sltmp = (size_t)EVP_PKEY_size(pkey);\n\t\ti = 0;\n\t\tpkctx = EVP_PKEY_CTX_new(pkey, NULL);\n\t\tif (!pkctx)\n\t\t\tgoto err;\n\t\tif (EVP_PKEY_sign_init(pkctx) <= 0)\n\t\t\tgoto err;\n\t\tif (EVP_PKEY_CTX_set_signature_md(pkctx, ctx->digest) <= 0)\n\t\t\tgoto err;\n\t\tif (EVP_PKEY_sign(pkctx, sigret, &sltmp, m, m_len) <= 0)\n\t\t\tgoto err;\n\t\t*siglen = sltmp;\n\t\ti = 1;\n\t\terr:\n\t\tEVP_PKEY_CTX_free(pkctx);\n\t\treturn i;\n\t\t}\n\n\tfor (i=0; i<4; i++)\n\t\t{\n\t\tv=ctx->digest->required_pkey_type[i];\n\t\tif (v == 0) break;\n\t\tif (pkey->type == v)\n\t\t\t{\n\t\t\tok=1;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tif (!ok)\n\t\t{\n\t\tEVPerr(EVP_F_EVP_SIGNFINAL,EVP_R_WRONG_PUBLIC_KEY_TYPE);\n\t\treturn(0);\n\t\t}\n\n\tif (ctx->digest->sign == NULL)\n\t\t{\n\t\tEVPerr(EVP_F_EVP_SIGNFINAL,EVP_R_NO_SIGN_FUNCTION_CONFIGURED);\n\t\treturn(0);\n\t\t}\n\treturn(ctx->digest->sign(ctx->digest->type,m,m_len,sigret,siglen,\n\t\tpkey->pkey.ptr));\n\t}", "target": 1}
{"idx": 5811, "func": "static int execute_decode_slices(H264Context *h, int context_count)\n{\n    MpegEncContext *const s     = &h->s;\n    AVCodecContext *const avctx = s->avctx;\n    H264Context *hx;\n    int i;\n\n    if (s->avctx->hwaccel ||\n        s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        return 0;\n    if (context_count == 1) {\n        return decode_slice(avctx, &h);\n    } else {\n        av_assert0(context_count > 0);\n        for (i = 1; i < context_count; i++) {\n            hx                    = h->thread_context[i];\n            hx->s.err_recognition = avctx->err_recognition;\n            hx->s.error_count     = 0;\n            hx->x264_build        = h->x264_build;\n        }\n\n        avctx->execute(avctx, decode_slice, h->thread_context,\n                       NULL, context_count, sizeof(void *));\n\n        /* pull back stuff from slices to master context */\n        hx                   = h->thread_context[context_count - 1];\n        s->mb_x              = hx->s.mb_x;\n        s->mb_y              = hx->s.mb_y;\n        s->droppable         = hx->s.droppable;\n        s->picture_structure = hx->s.picture_structure;\n        for (i = 1; i < context_count; i++)\n            h->s.error_count += h->thread_context[i]->s.error_count;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5812, "func": "static inline void skip_remaining(BitstreamContext *bc, unsigned n)\n{\n#ifdef BITSTREAM_READER_LE\n    bc->bits >>= n;\n#else\n    bc->bits <<= n;\n#endif\n    bc->bits_left -= n;\n}", "target": 1}
{"idx": 5813, "func": "void av_freep(void *arg)\n{\n    void *val;\n\n    memcpy(&val, arg, sizeof(val));\n    memcpy(arg, &(void *){ NULL }, sizeof(val));\n    av_free(val);\n}", "target": 1}
{"idx": 5814, "func": "HANDSHAKE_RESULT *do_handshake(SSL_CTX *server_ctx, SSL_CTX *server2_ctx,\n                               SSL_CTX *client_ctx, SSL_CTX *resume_server_ctx,\n                               SSL_CTX *resume_client_ctx,\n                               const SSL_TEST_CTX *test_ctx)\n{\n    HANDSHAKE_RESULT *result;\n    SSL_SESSION *session = NULL;\n\n    result = do_handshake_internal(server_ctx, server2_ctx, client_ctx,\n                                   &test_ctx->extra, NULL, &session);\n    if (test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_SIMPLE)\n        goto end;\n\n    OPENSSL_assert(test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_RESUME);\n\n    if (result->result != SSL_TEST_SUCCESS) {\n        result->result = SSL_TEST_FIRST_HANDSHAKE_FAILED;\n        return result;\n    }\n\n    HANDSHAKE_RESULT_free(result);\n    /* We don't support SNI on second handshake yet, so server2_ctx is NULL. */\n    result = do_handshake_internal(resume_server_ctx, NULL, resume_client_ctx,\n                                   &test_ctx->resume_extra, session, NULL);\n end:\n    SSL_SESSION_free(session);\n    return result;\n}", "target": 0}
{"idx": 5815, "func": "int ff_rv34_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            const uint8_t *buf, int buf_size)\n{\n    RV34DecContext *r = avctx->priv_data;\n    MpegEncContext *s = &r->s;\n    AVFrame *pict = data;\n    SliceInfo si;\n    int i;\n    int slice_count;\n    const uint8_t *slices_hdr = NULL;\n    int last = 0;\n\n    /* no supplementary picture */\n    if (buf_size == 0) {\n        /* special case for last picture */\n        if (s->low_delay==0 && s->next_picture_ptr) {\n            *pict= *(AVFrame*)s->next_picture_ptr;\n            s->next_picture_ptr= NULL;\n\n            *data_size = sizeof(AVFrame);\n        }\n        return 0;\n    }\n\n    if(!avctx->slice_count){\n        slice_count = (*buf++) + 1;\n        slices_hdr = buf + 4;\n        buf += 8 * slice_count;\n    }else\n        slice_count = avctx->slice_count;\n\n    //parse first slice header to check whether this frame can be decoded\n    if(get_slice_offset(avctx, slices_hdr, 0) > buf_size){\n        av_log(avctx, AV_LOG_ERROR, \"Slice offset is greater than frame size\\n\");\n        return -1;\n    }\n    init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), buf_size-get_slice_offset(avctx, slices_hdr, 0));\n    if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n        av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");\n        return -1;\n    }\n    if((!s->last_picture_ptr || !s->last_picture_ptr->data[0]) && si.type == FF_B_TYPE)\n        return -1;\n\n    for(i=0; i<slice_count; i++){\n        int offset= get_slice_offset(avctx, slices_hdr, i);\n        int size;\n        if(i+1 == slice_count)\n            size= buf_size - offset;\n        else\n            size= get_slice_offset(avctx, slices_hdr, i+1) - offset;\n\n        if(offset > buf_size){\n            av_log(avctx, AV_LOG_ERROR, \"Slice offset is greater than frame size\\n\");\n            break;\n        }\n\n        r->si.end = s->mb_width * s->mb_height;\n        if(i+1 < slice_count){\n            init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n            if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n                if(i+2 < slice_count)\n                    size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n                else\n                    size = buf_size - offset;\n            }else\n                r->si.end = si.start;\n        }\n        last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n        s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n        if(last)\n            break;\n    }\n\n    if(last){\n        if(r->loop_filter)\n            r->loop_filter(r, s->mb_height - 1);\n        ff_er_frame_end(s);\n        MPV_frame_end(s);\n        if (s->pict_type == FF_B_TYPE || s->low_delay) {\n            *pict= *(AVFrame*)s->current_picture_ptr;\n        } else if (s->last_picture_ptr != NULL) {\n            *pict= *(AVFrame*)s->last_picture_ptr;\n        }\n\n        if(s->last_picture_ptr || s->low_delay){\n            *data_size = sizeof(AVFrame);\n            ff_print_debug_info(s, pict);\n        }\n        s->current_picture_ptr= NULL; //so we can detect if frame_end wasnt called (find some nicer solution...)\n    }\n    return buf_size;\n}", "target": 0}
{"idx": 5816, "func": "static void show_packets(AVFormatContext *fmt_ctx)\n{\n    AVPacket pkt;\n\n    av_init_packet(&pkt);\n    probe_array_header(\"packets\", 0);\n    while (!av_read_frame(fmt_ctx, &pkt)) {\n        show_packet(fmt_ctx, &pkt);\n        av_packet_unref(&pkt);\n    }\n    probe_array_footer(\"packets\", 0);\n}", "target": 0}
{"idx": 5817, "func": "static int ftp_status(FTPContext *s, char **line, const int response_codes[])\n{\n    int err, i, result = 0, pref_code_found = 0, wait_count = 100;\n    char buf[CONTROL_BUFFER_SIZE];\n\n    /* Set blocking mode */\n    s->conn_control_block_flag = 0;\n    for (;;) {\n        if ((err = ftp_get_line(s, buf, sizeof(buf))) < 0) {\n            if (err == AVERROR_EXIT) {\n                if (!pref_code_found && wait_count--) {\n                    av_usleep(10000);\n                    continue;\n                }\n            }\n            return result;\n        }\n\n        av_log(s, AV_LOG_DEBUG, \"%s\\n\", buf);\n\n        if (!pref_code_found) {\n            if (strlen(buf) < 3)\n                continue;\n\n            err = 0;\n            for (i = 0; i < 3; ++i) {\n                if (buf[i] < '0' || buf[i] > '9')\n                    continue;\n                err *= 10;\n                err += buf[i] - '0';\n            }\n\n            for (i = 0; response_codes[i]; ++i) {\n                if (err == response_codes[i]) {\n                    /* first code received. Now get all lines in non blocking mode */\n                    s->conn_control_block_flag = 1;\n                    pref_code_found = 1;\n                    result = err;\n                    if (line)\n                        *line = av_strdup(buf);\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"idx": 5818, "func": "static av_cold int init_buffers(SANMVideoContext *ctx)\n{\n    av_fast_padded_mallocz(&ctx->frm0, &ctx->frm0_size, ctx->buf_size);\n    av_fast_padded_mallocz(&ctx->frm1, &ctx->frm1_size, ctx->buf_size);\n    av_fast_padded_mallocz(&ctx->frm2, &ctx->frm2_size, ctx->buf_size);\n    if (!ctx->version)\n        av_fast_padded_mallocz(&ctx->stored_frame,\n                              &ctx->stored_frame_size, ctx->buf_size);\n\n    if (!ctx->frm0 || !ctx->frm1 || !ctx->frm2 ||\n        (!ctx->stored_frame && !ctx->version)) {\n        destroy_buffers(ctx);\n        return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5819, "func": "int ff_init_poc(H264Context *h, int pic_field_poc[2], int *pic_poc)\n{\n    const int max_frame_num = 1 << h->sps.log2_max_frame_num;\n    int field_poc[2];\n\n    h->frame_num_offset = h->prev_frame_num_offset;\n    if (h->frame_num < h->prev_frame_num)\n        h->frame_num_offset += max_frame_num;\n\n    if (h->sps.poc_type == 0) {\n        const int max_poc_lsb = 1 << h->sps.log2_max_poc_lsb;\n\n        if (h->poc_lsb < h->prev_poc_lsb &&\n            h->prev_poc_lsb - h->poc_lsb >= max_poc_lsb / 2)\n            h->poc_msb = h->prev_poc_msb + max_poc_lsb;\n        else if (h->poc_lsb > h->prev_poc_lsb &&\n                 h->prev_poc_lsb - h->poc_lsb < -max_poc_lsb / 2)\n            h->poc_msb = h->prev_poc_msb - max_poc_lsb;\n        else\n            h->poc_msb = h->prev_poc_msb;\n        field_poc[0] =\n        field_poc[1] = h->poc_msb + h->poc_lsb;\n        if (h->picture_structure == PICT_FRAME)\n            field_poc[1] += h->delta_poc_bottom;\n    } else if (h->sps.poc_type == 1) {\n        int abs_frame_num, expected_delta_per_poc_cycle, expectedpoc;\n        int i;\n\n        if (h->sps.poc_cycle_length != 0)\n            abs_frame_num = h->frame_num_offset + h->frame_num;\n        else\n            abs_frame_num = 0;\n\n        if (h->nal_ref_idc == 0 && abs_frame_num > 0)\n            abs_frame_num--;\n\n        expected_delta_per_poc_cycle = 0;\n        for (i = 0; i < h->sps.poc_cycle_length; i++)\n            // FIXME integrate during sps parse\n            expected_delta_per_poc_cycle += h->sps.offset_for_ref_frame[i];\n\n        if (abs_frame_num > 0) {\n            int poc_cycle_cnt          = (abs_frame_num - 1) / h->sps.poc_cycle_length;\n            int frame_num_in_poc_cycle = (abs_frame_num - 1) % h->sps.poc_cycle_length;\n\n            expectedpoc = poc_cycle_cnt * expected_delta_per_poc_cycle;\n            for (i = 0; i <= frame_num_in_poc_cycle; i++)\n                expectedpoc = expectedpoc + h->sps.offset_for_ref_frame[i];\n        } else\n            expectedpoc = 0;\n\n        if (h->nal_ref_idc == 0)\n            expectedpoc = expectedpoc + h->sps.offset_for_non_ref_pic;\n\n        field_poc[0] = expectedpoc + h->delta_poc[0];\n        field_poc[1] = field_poc[0] + h->sps.offset_for_top_to_bottom_field;\n\n        if (h->picture_structure == PICT_FRAME)\n            field_poc[1] += h->delta_poc[1];\n    } else {\n        int poc = 2 * (h->frame_num_offset + h->frame_num);\n\n        if (!h->nal_ref_idc)\n            poc--;\n\n        field_poc[0] = poc;\n        field_poc[1] = poc;\n    }\n\n    if (h->picture_structure != PICT_BOTTOM_FIELD)\n        pic_field_poc[0] = field_poc[0];\n    if (h->picture_structure != PICT_TOP_FIELD)\n        pic_field_poc[1] = field_poc[1];\n    *pic_poc = FFMIN(pic_field_poc[0], pic_field_poc[1]);\n\n    return 0;\n}", "target": 1}
{"idx": 5820, "func": "int asn1_valid_host(const ASN1_STRING *host)\n{\n    int hostlen = host->length;\n    const unsigned char *hostptr = host->data;\n    int type = host->type;\n    int i;\n    signed char width = -1;\n    unsigned short chflags = 0, prevchflags;\n\n    if (type > 0 && type < 31)\n        width = tag2nbyte[type];\n    if (width == -1 || hostlen == 0)\n        return 0;\n    /* Treat UTF8String as width 1 as any MSB set is invalid */\n    if (width == 0)\n        width = 1;\n    for (i = 0 ; i < hostlen; i+= width) {\n        prevchflags = chflags;\n        /* Value must be <= 0x7F: check upper bytes are all zeroes */\n        if (width == 4) {\n            if (*hostptr++ != 0 || *hostptr++ != 0 || *hostptr++ != 0)\n                return 0;\n        } else if (width == 2) {\n            if (*hostptr++ != 0)\n                return 0;\n        }\n        if (*hostptr > 0x7f)\n            return 0;\n        chflags = char_type[*hostptr++];\n        if (!(chflags & (CHARTYPE_HOST_ANY | CHARTYPE_HOST_WILD))) {\n            /* Nothing else allowed at start or end of string */\n            if (i == 0 || i == hostlen - 1)\n                return 0;\n            /* Otherwise invalid if not dot or hyphen */\n            if (!(chflags & (CHARTYPE_HOST_DOT | CHARTYPE_HOST_HYPHEN)))\n                return 0;\n            /*\n             * If previous is dot or hyphen then illegal unless both\n             * are hyphens: as .- -. .. are all illegal\n             */\n            if (prevchflags & (CHARTYPE_HOST_DOT | CHARTYPE_HOST_HYPHEN)\n                && ((prevchflags & CHARTYPE_HOST_DOT)\n                    || (chflags & CHARTYPE_HOST_DOT)))\n                return 0;\n        }\n    }\n    return 1;\n}", "target": 1}
{"idx": 5821, "func": "static void common_uninit(ShowCQTContext *s)\n{\n    int k;\n    int level = AV_LOG_DEBUG;\n    int64_t plot_time;\n\n    if (s->fft_time)\n        av_log(s->ctx, level, \"fft_time         = %16.3f s.\\n\", s->fft_time * 1e-6);\n    if (s->cqt_time)\n        av_log(s->ctx, level, \"cqt_time         = %16.3f s.\\n\", s->cqt_time * 1e-6);\n    if (s->process_cqt_time)\n        av_log(s->ctx, level, \"process_cqt_time = %16.3f s.\\n\", s->process_cqt_time * 1e-6);\n    if (s->update_sono_time)\n        av_log(s->ctx, level, \"update_sono_time = %16.3f s.\\n\", s->update_sono_time * 1e-6);\n    if (s->alloc_time)\n        av_log(s->ctx, level, \"alloc_time       = %16.3f s.\\n\", s->alloc_time * 1e-6);\n    if (s->bar_time)\n        av_log(s->ctx, level, \"bar_time         = %16.3f s.\\n\", s->bar_time * 1e-6);\n    if (s->axis_time)\n        av_log(s->ctx, level, \"axis_time        = %16.3f s.\\n\", s->axis_time * 1e-6);\n    if (s->sono_time)\n        av_log(s->ctx, level, \"sono_time        = %16.3f s.\\n\", s->sono_time * 1e-6);\n\n    plot_time = s->fft_time + s->cqt_time + s->process_cqt_time + s->update_sono_time\n              + s->alloc_time + s->bar_time + s->axis_time + s->sono_time;\n    if (plot_time)\n        av_log(s->ctx, level, \"plot_time        = %16.3f s.\\n\", plot_time * 1e-6);\n\n    s->fft_time = s->cqt_time = s->process_cqt_time = s->update_sono_time\n                = s->alloc_time = s->bar_time = s->axis_time = s->sono_time = 0;\n    /* axis_frame may be non reference counted frame */\n    if (s->axis_frame && !s->axis_frame->buf[0]) {\n        av_freep(s->axis_frame->data);\n        for (k = 0; k < 4; k++)\n            s->axis_frame->data[k] = NULL;\n    }\n\n    av_frame_free(&s->axis_frame);\n    av_frame_free(&s->sono_frame);\n    av_fft_end(s->fft_ctx);\n    s->fft_ctx = NULL;\n    if (s->coeffs)\n        for (k = 0; k < s->cqt_len; k++)\n            av_freep(&s->coeffs[k].val);\n    av_freep(&s->coeffs);\n    av_freep(&s->fft_data);\n    av_freep(&s->fft_result);\n    av_freep(&s->cqt_result);\n    av_freep(&s->c_buf);\n    av_freep(&s->h_buf);\n    av_freep(&s->rcp_h_buf);\n    av_freep(&s->freq);\n    av_freep(&s->sono_v_buf);\n    av_freep(&s->bar_v_buf);\n}", "target": 1}
{"idx": 5822, "func": "static AVCodec *choose_decoder(OptionsContext *o, AVFormatContext *s, AVStream *st)\n{\n    char *codec_name = NULL;\n\n    MATCH_PER_STREAM_OPT(codec_names, str, codec_name, s, st);\n    if (codec_name) {\n        AVCodec *codec = find_codec_or_die(codec_name, st->codec->codec_type, 0);\n        st->codec->codec_id = codec->id;\n        return codec;\n    } else\n        return avcodec_find_decoder(st->codec->codec_id);\n}", "target": 0}
{"idx": 5823, "func": "int ff_bgmc_init(AVCodecContext *avctx, uint8_t **cf_lut, int **cf_lut_status)\n{\n    *cf_lut        = av_malloc(sizeof(**cf_lut)        * LUT_BUFF * 16 * LUT_SIZE);\n    *cf_lut_status = av_malloc(sizeof(**cf_lut_status) * LUT_BUFF);\n\n    if (!cf_lut || !cf_lut_status) {\n        ff_bgmc_end(cf_lut, cf_lut_status);\n        av_log(avctx, AV_LOG_ERROR, \"Allocating buffer memory failed.\\n\");\n        return AVERROR(ENOMEM);\n    } else {\n        // initialize lut_status buffer to a value never used to compare against\n        memset(*cf_lut_status, -1, sizeof(**cf_lut_status) * LUT_BUFF);\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5824, "func": "static int dvbsub_parse_clut_segment(AVCodecContext *avctx,\n                                        const uint8_t *buf, int buf_size)\n{\n    DVBSubContext *ctx = avctx->priv_data;\n\n    const uint8_t *buf_end = buf + buf_size;\n    int i, clut_id;\n    int version;\n    DVBSubCLUT *clut;\n    int entry_id, depth , full_range;\n    int y, cr, cb, alpha;\n    int r, g, b, r_add, g_add, b_add;\n\n    av_dlog(avctx, \"DVB clut packet:\\n\");\n\n    for (i=0; i < buf_size; i++) {\n        av_dlog(avctx, \"%02x \", buf[i]);\n        if (i % 16 == 15)\n            av_dlog(avctx, \"\\n\");\n    }\n\n    if (i % 16)\n        av_dlog(avctx, \"\\n\");\n\n    clut_id = *buf++;\n    version = ((*buf)>>4)&15;\n    buf += 1;\n\n    clut = get_clut(ctx, clut_id);\n\n    if (!clut) {\n        clut = av_malloc(sizeof(DVBSubCLUT));\n        if (!clut)\n            return AVERROR(ENOMEM);\n\n        memcpy(clut, &default_clut, sizeof(DVBSubCLUT));\n\n        clut->id = clut_id;\n        clut->version = -1;\n\n        clut->next = ctx->clut_list;\n        ctx->clut_list = clut;\n    }\n\n    if (clut->version != version) {\n\n    clut->version = version;\n\n    while (buf + 4 < buf_end) {\n        entry_id = *buf++;\n\n        depth = (*buf) & 0xe0;\n\n        if (depth == 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid clut depth 0x%x!\\n\", *buf);\n            return 0;\n        }\n\n        full_range = (*buf++) & 1;\n\n        if (full_range) {\n            y = *buf++;\n            cr = *buf++;\n            cb = *buf++;\n            alpha = *buf++;\n        } else {\n            y = buf[0] & 0xfc;\n            cr = (((buf[0] & 3) << 2) | ((buf[1] >> 6) & 3)) << 4;\n            cb = (buf[1] << 2) & 0xf0;\n            alpha = (buf[1] << 6) & 0xc0;\n\n            buf += 2;\n        }\n\n        if (y == 0)\n            alpha = 0xff;\n\n        YUV_TO_RGB1_CCIR(cb, cr);\n        YUV_TO_RGB2_CCIR(r, g, b, y);\n\n        av_dlog(avctx, \"clut %d := (%d,%d,%d,%d)\\n\", entry_id, r, g, b, alpha);\n        if (!!(depth & 0x80) + !!(depth & 0x40) + !!(depth & 0x20) > 1) {\n            av_dlog(avctx, \"More than one bit level marked: %x\\n\", depth);\n            if (avctx->strict_std_compliance > FF_COMPLIANCE_NORMAL)\n                return AVERROR_INVALIDDATA;\n        }\n\n        if (depth & 0x80)\n            clut->clut4[entry_id] = RGBA(r,g,b,255 - alpha);\n        else if (depth & 0x40)\n            clut->clut16[entry_id] = RGBA(r,g,b,255 - alpha);\n        else if (depth & 0x20)\n            clut->clut256[entry_id] = RGBA(r,g,b,255 - alpha);\n    }\n    }\n    return 0;\n}", "target": 0}
{"idx": 5825, "func": "static inline int get_duration(AVIStream *ast, int len)\n{\n    if (ast->sample_size)\n        return len;\n    else if (ast->dshow_block_align)\n        return (len + ast->dshow_block_align - 1) / ast->dshow_block_align;\n    else\n        return 1;\n}", "target": 1}
{"idx": 5826, "func": "static int ape_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    APEContext *s = avctx->priv_data;\n    int16_t *samples = data;\n    uint32_t nblocks;\n    int i;\n    int blockstodecode, out_size;\n    int bytes_used;\n\n    /* this should never be negative, but bad things will happen if it is, so\n       check it just to make sure. */\n    av_assert0(s->samples >= 0);\n\n    if(!s->samples){\n        uint32_t offset;\n        void *tmp_data;\n\n        if (buf_size < 8) {\n            av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        tmp_data = av_realloc(s->data, FFALIGN(buf_size, 4));\n        if (!tmp_data)\n            return AVERROR(ENOMEM);\n        s->data = tmp_data;\n        s->dsp.bswap_buf((uint32_t*)s->data, (const uint32_t*)buf, buf_size >> 2);\n        s->ptr = s->last_ptr = s->data;\n        s->data_end = s->data + buf_size;\n\n        nblocks = bytestream_get_be32(&s->ptr);\n        offset  = bytestream_get_be32(&s->ptr);\n        if (offset > 3) {\n            av_log(avctx, AV_LOG_ERROR, \"Incorrect offset passed\\n\");\n            s->data = NULL;\n            return AVERROR_INVALIDDATA;\n        }\n        if (s->data_end - s->ptr < offset) {\n            av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        s->ptr += offset;\n\n        if (!nblocks || nblocks > INT_MAX) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %u.\\n\", nblocks);\n            return AVERROR_INVALIDDATA;\n        }\n        s->samples = nblocks;\n\n        memset(s->decoded0,  0, sizeof(s->decoded0));\n        memset(s->decoded1,  0, sizeof(s->decoded1));\n\n        /* Initialize the frame decoder */\n        if (init_frame_decoder(s) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Error reading frame header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (!s->data) {\n        *data_size = 0;\n        return buf_size;\n    }\n\n    nblocks = s->samples;\n    blockstodecode = FFMIN(BLOCKS_PER_LOOP, nblocks);\n\n    out_size = blockstodecode * avctx->channels *\n               av_get_bytes_per_sample(avctx->sample_fmt);\n    if (*data_size < out_size) {\n        av_log(avctx, AV_LOG_ERROR, \"Output buffer is too small.\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    s->error=0;\n\n    if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))\n        ape_unpack_mono(s, blockstodecode);\n    else\n        ape_unpack_stereo(s, blockstodecode);\n    emms_c();\n\n    if (s->error) {\n        s->samples=0;\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding frame\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < blockstodecode; i++) {\n        *samples++ = s->decoded0[i];\n        if(s->channels == 2)\n            *samples++ = s->decoded1[i];\n    }\n\n    s->samples -= blockstodecode;\n\n    bytes_used = s->samples ? s->ptr - s->last_ptr : buf_size;\n    s->last_ptr = s->ptr;\n\n    *data_size = out_size;\n    return bytes_used;\n}", "target": 0}
{"idx": 5827, "func": "static void fft(AC3MDCTContext *mdct, IComplex *z, int ln)\n{\n    int j, l, np, np2;\n    int nblocks, nloops;\n    register IComplex *p,*q;\n    int tmp_re, tmp_im;\n\n    np = 1 << ln;\n\n    /* reverse */\n    for (j = 0; j < np; j++) {\n        int k = av_reverse[j] >> (8 - ln);\n        if (k < j)\n            FFSWAP(IComplex, z[k], z[j]);\n    }\n\n    /* pass 0 */\n\n    p = &z[0];\n    j = np >> 1;\n    do {\n        BF(p[0].re, p[0].im, p[1].re, p[1].im,\n           p[0].re, p[0].im, p[1].re, p[1].im);\n        p += 2;\n    } while (--j);\n\n    /* pass 1 */\n\n    p = &z[0];\n    j = np >> 2;\n    do {\n        BF(p[0].re, p[0].im, p[2].re,  p[2].im,\n           p[0].re, p[0].im, p[2].re,  p[2].im);\n        BF(p[1].re, p[1].im, p[3].re,  p[3].im,\n           p[1].re, p[1].im, p[3].im, -p[3].re);\n        p+=4;\n    } while (--j);\n\n    /* pass 2 .. ln-1 */\n\n    nblocks = np >> 3;\n    nloops  =  1 << 2;\n    np2     = np >> 1;\n    do {\n        p = z;\n        q = z + nloops;\n        for (j = 0; j < nblocks; j++) {\n            BF(p->re, p->im, q->re, q->im,\n               p->re, p->im, q->re, q->im);\n            p++;\n            q++;\n            for(l = nblocks; l < np2; l += nblocks) {\n                CMUL(tmp_re, tmp_im, mdct->costab[l], -mdct->sintab[l], q->re, q->im, 15);\n                BF(p->re, p->im, q->re,  q->im,\n                   p->re, p->im, tmp_re, tmp_im);\n                p++;\n                q++;\n            }\n            p += nloops;\n            q += nloops;\n        }\n        nblocks = nblocks >> 1;\n        nloops  = nloops  << 1;\n    } while (nblocks);\n}", "target": 1}
{"idx": 5828, "func": "static int read_high_coeffs(AVCodecContext *avctx, uint8_t *src, int16_t *dst, int size,\n                            int c, int a, int d,\n                            int width, ptrdiff_t stride)\n{\n    PixletContext *ctx = avctx->priv_data;\n    GetBitContext *b = &ctx->gbit;\n    unsigned cnt1, shbits, rlen, nbits, length, i = 0, j = 0, k;\n    int ret, escape, pfx, value, yflag, xflag, flag = 0;\n    int64_t state = 3, tmp;\n\n    if ((ret = init_get_bits8(b, src, bytestream2_get_bytes_left(&ctx->gb))) < 0)\n      return ret;\n\n    if ((a >= 0) + (a ^ (a >> 31)) - (a >> 31) != 1) {\n        nbits = 33 - ff_clz((a >= 0) + (a ^ (a >> 31)) - (a >> 31) - 1);\n        if (nbits > 16)\n            return AVERROR_INVALIDDATA;\n    } else {\n        nbits = 1;\n    }\n\n    length = 25 - nbits;\n\n    while (i < size) {\n        if (state >> 8 != -3) {\n            value = ff_clz((state >> 8) + 3) ^ 0x1F;\n        } else {\n            value = -1;\n        }\n\n        cnt1 = get_unary(b, 0, length);\n\n        if (cnt1 >= length) {\n            cnt1 = get_bits(b, nbits);\n        } else {\n            pfx = 14 + ((((uint64_t)(value - 14)) >> 32) & (value - 14));\n            cnt1 *= (1 << pfx) - 1;\n            shbits = show_bits(b, pfx);\n            if (shbits <= 1) {\n                skip_bits(b, pfx - 1);\n            } else {\n                skip_bits(b, pfx);\n                cnt1 += shbits - 1;\n            }\n        }\n\n        xflag = flag + cnt1;\n        yflag = xflag;\n\n        if (flag + cnt1 == 0) {\n            value = 0;\n        } else {\n            xflag &= 1u;\n            tmp = (int64_t)c * ((yflag + 1) >> 1) + (c >> 1);\n            value = xflag + (tmp ^ -xflag);\n        }\n\n        i++;\n        dst[j++] = value;\n        if (j == width) {\n            j = 0;\n            dst += stride;\n        }\n        state += (int64_t)d * yflag - (d * state >> 8);\n\n        flag = 0;\n\n        if (state * 4ULL > 0xFF || i >= size)\n            continue;\n\n        pfx = ((state + 8) >> 5) + (state ? ff_clz(state): 32) - 24;\n        escape = av_mod_uintp2(16383, pfx);\n        cnt1 = get_unary(b, 0, 8);\n        if (cnt1 < 8) {\n            if (pfx < 1 || pfx > 25)\n                return AVERROR_INVALIDDATA;\n            value = show_bits(b, pfx);\n            if (value > 1) {\n                skip_bits(b, pfx);\n                rlen = value + escape * cnt1 - 1;\n            } else {\n                skip_bits(b, pfx - 1);\n                rlen = escape * cnt1;\n            }\n        } else {\n            if (get_bits1(b))\n                value = get_bits(b, 16);\n            else\n                value = get_bits(b, 8);\n\n            rlen = value + 8 * escape;\n        }\n\n        if (rlen > 0xFFFF || i + rlen > size)\n            return AVERROR_INVALIDDATA;\n        i += rlen;\n\n        for (k = 0; k < rlen; k++) {\n            dst[j++] = 0;\n            if (j == width) {\n                j = 0;\n                dst += stride;\n            }\n        }\n\n        state = 0;\n        flag = rlen < 0xFFFF ? 1 : 0;\n    }\n\n    align_get_bits(b);\n    return get_bits_count(b) >> 3;\n}", "target": 0}
{"idx": 5829, "func": "static void wipe_side_data(AVFrame *frame)\n{\n    int i;\n\n    for (i = 0; i < frame->nb_side_data; i++) {\n        free_side_data(&frame->side_data[i]);\n    }\n    frame->nb_side_data = 0;\n\n    av_freep(&frame->side_data);\n}", "target": 0}
{"idx": 5830, "func": "void av_frame_unref(AVFrame *frame)\n{\n    int i;\n\n    if (!frame)\n        return;\n\n    wipe_side_data(frame);\n\n    for (i = 0; i < FF_ARRAY_ELEMS(frame->buf); i++)\n        av_buffer_unref(&frame->buf[i]);\n    for (i = 0; i < frame->nb_extended_buf; i++)\n        av_buffer_unref(&frame->extended_buf[i]);\n    av_freep(&frame->extended_buf);\n    av_dict_free(&frame->metadata);\n    av_buffer_unref(&frame->qp_table_buf);\n\n    get_frame_defaults(frame);\n}", "target": 0}
{"idx": 5831, "func": "static void bprint_bytes(AVBPrint *bp, const uint8_t *ubuf, size_t ubuf_size)\n{\n    int i;\n    av_bprintf(bp, \"0X\");\n    for (i = 0; i < ubuf_size; i++)\n        av_bprintf(bp, \"%02X\", ubuf[i]);\n}", "target": 1}
{"idx": 5832, "func": "void *CRYPTO_malloc(int num, const char *file, int line)\n\t{\n\tvoid *ret = NULL;\n\n\tif (num <= 0) return NULL;\n\n\tif(allow_customize)\n\t\tallow_customize = 0;\n\tif (malloc_debug_func != NULL)\n\t\t{\n\t\tif(allow_customize_debug)\n\t\t\tallow_customize_debug = 0;\n\t\tmalloc_debug_func(NULL, num, file, line, 0);\n\t\t}\n\tret = malloc_ex_func(num,file,line);\n#ifdef LEVITTE_DEBUG_MEM\n\tfprintf(stderr, \"LEVITTE_DEBUG_MEM:         > 0x%p (%d)\\n\", ret, num);\n#endif\n\tif (malloc_debug_func != NULL)\n\t\tmalloc_debug_func(ret, num, file, line, 1);\n\n#ifndef OPENSSL_CPUID_OBJ\n        /* Create a dependency on the value of 'cleanse_ctr' so our memory\n         * sanitisation function can't be optimised out. NB: We only do\n         * this for >2Kb so the overhead doesn't bother us. */\n        if(ret && (num > 2048))\n\t{\textern unsigned char cleanse_ctr;\n                ((unsigned char *)ret)[0] = cleanse_ctr;\n\t}\n#endif\n\n\treturn ret;\n\t}", "target": 0}
{"idx": 5833, "func": "static int vmdaudio_decode_frame(AVCodecContext *avctx,\n                                 void *data, int *data_size,\n                                 AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    VmdAudioContext *s = avctx->priv_data;\n    int block_type, silent_chunks;\n    unsigned char *output_samples = (unsigned char *)data;\n\n    if (buf_size < 16) {\n        av_log(avctx, AV_LOG_WARNING, \"skipping small junk packet\\n\");\n        *data_size = 0;\n        return buf_size;\n    }\n\n    block_type = buf[6];\n    if (block_type < BLOCK_TYPE_AUDIO || block_type > BLOCK_TYPE_SILENCE) {\n        av_log(avctx, AV_LOG_ERROR, \"unknown block type: %d\\n\", block_type);\n        return AVERROR(EINVAL);\n    }\n    buf      += 16;\n    buf_size -= 16;\n\n    silent_chunks = 0;\n    if (block_type == BLOCK_TYPE_INITIAL) {\n        uint32_t flags = AV_RB32(buf);\n        silent_chunks  = av_popcount(flags);\n        buf      += 4;\n        buf_size -= 4;\n    } else if (block_type == BLOCK_TYPE_SILENCE) {\n        silent_chunks = 1;\n        buf_size = 0; // should already be zero but set it just to be sure\n    }\n\n    /* ensure output buffer is large enough */\n    if (*data_size < (avctx->block_align*silent_chunks + buf_size) * s->out_bps)\n        return -1;\n\n    *data_size = vmdaudio_loadsound(s, output_samples, buf, silent_chunks, buf_size);\n\n    return avpkt->size;\n}", "target": 1}
{"idx": 5834, "func": "unsigned long ssl3_output_cert_chain(SSL *s, CERT_PKEY *cpk)\n\t{\n\tunsigned char *p;\n\tunsigned long l = 3 + SSL_HM_HEADER_LENGTH(s);\n\n\tif (!ssl_add_cert_chain(s, cpk, &l))\n\t\treturn 0;\n\n\tl -= 3 + SSL_HM_HEADER_LENGTH(s);\n\tp = ssl_handshake_start(s);\n\tl2n3(l,p);\n\tl += 3;\n\tssl_set_handshake_header(s, SSL3_MT_CERTIFICATE, l);\n\treturn l + SSL_HM_HEADER_LENGTH(s);\n\t}", "target": 0}
{"idx": 5835, "func": "static void adjust_frame_information(ChannelElement *cpe, int chans)\n{\n    int i, w, w2, g, ch;\n    int start, maxsfb, cmaxsfb;\n\n    for (ch = 0; ch < chans; ch++) {\n        IndividualChannelStream *ics = &cpe->ch[ch].ics;\n        start = 0;\n        maxsfb = 0;\n        cpe->ch[ch].pulse.num_pulse = 0;\n        for (w = 0; w < ics->num_windows*16; w += 16) {\n            for (g = 0; g < ics->num_swb; g++) {\n                //apply M/S\n                if (cpe->common_window && !ch && cpe->ms_mask[w + g]) {\n                    for (i = 0; i < ics->swb_sizes[g]; i++) {\n                        cpe->ch[0].coeffs[start+i] = (cpe->ch[0].coeffs[start+i] + cpe->ch[1].coeffs[start+i]) / 2.0;\n                        cpe->ch[1].coeffs[start+i] =  cpe->ch[0].coeffs[start+i] - cpe->ch[1].coeffs[start+i];\n                    }\n                }\n                start += ics->swb_sizes[g];\n            }\n            for (cmaxsfb = ics->num_swb; cmaxsfb > 0 && cpe->ch[ch].zeroes[w+cmaxsfb-1]; cmaxsfb--)\n                ;\n            maxsfb = FFMAX(maxsfb, cmaxsfb);\n        }\n        ics->max_sfb = maxsfb;\n\n        //adjust zero bands for window groups\n        for (w = 0; w < ics->num_windows; w += ics->group_len[w]) {\n            for (g = 0; g < ics->max_sfb; g++) {\n                i = 1;\n                for (w2 = w; w2 < w + ics->group_len[w]; w2++) {\n                    if (!cpe->ch[ch].zeroes[w2*16 + g]) {\n                        i = 0;\n                        break;\n                    }\n                }\n                cpe->ch[ch].zeroes[w*16 + g] = i;\n            }\n        }\n    }\n\n    if (chans > 1 && cpe->common_window) {\n        IndividualChannelStream *ics0 = &cpe->ch[0].ics;\n        IndividualChannelStream *ics1 = &cpe->ch[1].ics;\n        int msc = 0;\n        ics0->max_sfb = FFMAX(ics0->max_sfb, ics1->max_sfb);\n        ics1->max_sfb = ics0->max_sfb;\n        for (w = 0; w < ics0->num_windows*16; w += 16)\n            for (i = 0; i < ics0->max_sfb; i++)\n                if (cpe->ms_mask[w+i])\n                    msc++;\n        if (msc == 0 || ics0->max_sfb == 0)\n            cpe->ms_mode = 0;\n        else\n            cpe->ms_mode = msc < ics0->max_sfb * ics0->num_windows ? 1 : 2;\n    }\n}", "target": 1}
{"idx": 5836, "func": "static void dv_decode_ac(GetBitContext *gb, BlockInfo *mb, DCTELEM *block)\n{\n    int last_index = gb->size_in_bits;\n    const uint8_t  *scan_table   = mb->scan_table;\n    const uint32_t *factor_table = mb->factor_table;\n    int pos               = mb->pos;\n    int partial_bit_count = mb->partial_bit_count;\n    int level, run, vlc_len, index;\n\n    OPEN_READER(re, gb);\n    UPDATE_CACHE(re, gb);\n\n    /* if we must parse a partial VLC, we do it here */\n    if (partial_bit_count > 0) {\n        re_cache = re_cache >> partial_bit_count | mb->partial_bit_buffer;\n        re_index -= partial_bit_count;\n        mb->partial_bit_count = 0;\n    }\n\n    /* get the AC coefficients until last_index is reached */\n    for (;;) {\n        av_dlog(NULL, \"%2d: bits=%04x index=%d\\n\", pos, SHOW_UBITS(re, gb, 16),\n                re_index);\n        /* our own optimized GET_RL_VLC */\n        index   = NEG_USR32(re_cache, TEX_VLC_BITS);\n        vlc_len = dv_rl_vlc[index].len;\n        if (vlc_len < 0) {\n            index = NEG_USR32((unsigned)re_cache << TEX_VLC_BITS, -vlc_len) + dv_rl_vlc[index].level;\n            vlc_len = TEX_VLC_BITS - vlc_len;\n        }\n        level = dv_rl_vlc[index].level;\n        run   = dv_rl_vlc[index].run;\n\n        /* gotta check if we're still within gb boundaries */\n        if (re_index + vlc_len > last_index) {\n            /* should be < 16 bits otherwise a codeword could have been parsed */\n            mb->partial_bit_count = last_index - re_index;\n            mb->partial_bit_buffer = re_cache & ~(-1u >> mb->partial_bit_count);\n            re_index = last_index;\n            break;\n        }\n        re_index += vlc_len;\n\n        av_dlog(NULL, \"run=%d level=%d\\n\", run, level);\n        pos += run;\n        if (pos >= 64)\n            break;\n\n        level = (level * factor_table[pos] + (1 << (dv_iweight_bits - 1))) >> dv_iweight_bits;\n        block[scan_table[pos]] = level;\n\n        UPDATE_CACHE(re, gb);\n    }\n    CLOSE_READER(re, gb);\n    mb->pos = pos;\n}", "target": 0}
{"idx": 5837, "func": "static av_always_inline\nvoid MPV_decode_mb_internal(MpegEncContext *s, int16_t block[12][64],\n                            int is_mpeg12)\n{\n    const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;\n\n#if FF_API_XVMC\nFF_DISABLE_DEPRECATION_WARNINGS\n    if(CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration){\n        ff_xvmc_decode_mb(s);//xvmc uses pblocks\n        return;\n    }\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif /* FF_API_XVMC */\n\n    if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {\n       /* print DCT coefficients */\n       int i,j;\n       av_log(s->avctx, AV_LOG_DEBUG, \"DCT coeffs of MB at %dx%d:\\n\", s->mb_x, s->mb_y);\n       for(i=0; i<6; i++){\n           for(j=0; j<64; j++){\n               av_log(s->avctx, AV_LOG_DEBUG, \"%5d\", block[i][s->dsp.idct_permutation[j]]);\n           }\n           av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n       }\n    }\n\n    s->current_picture.qscale_table[mb_xy] = s->qscale;\n\n    /* update DC predictors for P macroblocks */\n    if (!s->mb_intra) {\n        if (!is_mpeg12 && (s->h263_pred || s->h263_aic)) {\n            if(s->mbintra_table[mb_xy])\n                ff_clean_intra_table_entries(s);\n        } else {\n            s->last_dc[0] =\n            s->last_dc[1] =\n            s->last_dc[2] = 128 << s->intra_dc_precision;\n        }\n    }\n    else if (!is_mpeg12 && (s->h263_pred || s->h263_aic))\n        s->mbintra_table[mb_xy]=1;\n\n    if ((s->flags&CODEC_FLAG_PSNR) || !(s->encoding && (s->intra_only || s->pict_type==AV_PICTURE_TYPE_B) && s->avctx->mb_decision != FF_MB_DECISION_RD)) { //FIXME precalc\n        uint8_t *dest_y, *dest_cb, *dest_cr;\n        int dct_linesize, dct_offset;\n        op_pixels_func (*op_pix)[4];\n        qpel_mc_func (*op_qpix)[16];\n        const int linesize   = s->current_picture.f->linesize[0]; //not s->linesize as this would be wrong for field pics\n        const int uvlinesize = s->current_picture.f->linesize[1];\n        const int readable= s->pict_type != AV_PICTURE_TYPE_B || s->encoding || s->avctx->draw_horiz_band;\n        const int block_size = 8;\n\n        /* avoid copy if macroblock skipped in last frame too */\n        /* skip only during decoding as we might trash the buffers during encoding a bit */\n        if(!s->encoding){\n            uint8_t *mbskip_ptr = &s->mbskip_table[mb_xy];\n\n            if (s->mb_skipped) {\n                s->mb_skipped= 0;\n                assert(s->pict_type!=AV_PICTURE_TYPE_I);\n                *mbskip_ptr = 1;\n            } else if(!s->current_picture.reference) {\n                *mbskip_ptr = 1;\n            } else{\n                *mbskip_ptr = 0; /* not skipped */\n            }\n        }\n\n        dct_linesize = linesize << s->interlaced_dct;\n        dct_offset   = s->interlaced_dct ? linesize : linesize * block_size;\n\n        if(readable){\n            dest_y=  s->dest[0];\n            dest_cb= s->dest[1];\n            dest_cr= s->dest[2];\n        }else{\n            dest_y = s->b_scratchpad;\n            dest_cb= s->b_scratchpad+16*linesize;\n            dest_cr= s->b_scratchpad+32*linesize;\n        }\n\n        if (!s->mb_intra) {\n            /* motion handling */\n            /* decoding or more than one mb_type (MC was already done otherwise) */\n            if(!s->encoding){\n\n                if(HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_FRAME) {\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n                        ff_thread_await_progress(&s->last_picture_ptr->tf,\n                                                 ff_MPV_lowest_referenced_row(s, 0),\n                                                 0);\n                    }\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n                        ff_thread_await_progress(&s->next_picture_ptr->tf,\n                                                 ff_MPV_lowest_referenced_row(s, 1),\n                                                 0);\n                    }\n                }\n\n                op_qpix= s->me.qpel_put;\n                if ((!s->no_rounding) || s->pict_type==AV_PICTURE_TYPE_B){\n                    op_pix = s->hdsp.put_pixels_tab;\n                }else{\n                    op_pix = s->hdsp.put_no_rnd_pixels_tab;\n                }\n                if (s->mv_dir & MV_DIR_FORWARD) {\n                    ff_MPV_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix, op_qpix);\n                    op_pix = s->hdsp.avg_pixels_tab;\n                    op_qpix= s->me.qpel_avg;\n                }\n                if (s->mv_dir & MV_DIR_BACKWARD) {\n                    ff_MPV_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix, op_qpix);\n                }\n            }\n\n            /* skip dequant / idct if we are really late ;) */\n            if(s->avctx->skip_idct){\n                if(  (s->avctx->skip_idct >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B)\n                   ||(s->avctx->skip_idct >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I)\n                   || s->avctx->skip_idct >= AVDISCARD_ALL)\n                    goto skip_idct;\n            }\n\n            /* add dct residue */\n            if(s->encoding || !(   s->msmpeg4_version || s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO\n                                || (s->codec_id==AV_CODEC_ID_MPEG4 && !s->mpeg_quant))){\n                add_dequant_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);\n                add_dequant_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);\n                add_dequant_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);\n                add_dequant_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);\n\n                if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n                    if (s->chroma_y_shift){\n                        add_dequant_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);\n                    }else{\n                        dct_linesize >>= 1;\n                        dct_offset >>=1;\n                        add_dequant_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);\n                        add_dequant_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);\n                    }\n                }\n            } else if(is_mpeg12 || (s->codec_id != AV_CODEC_ID_WMV2)){\n                add_dct(s, block[0], 0, dest_y                          , dct_linesize);\n                add_dct(s, block[1], 1, dest_y              + block_size, dct_linesize);\n                add_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize);\n                add_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize);\n\n                if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n                    if(s->chroma_y_shift){//Chroma420\n                        add_dct(s, block[4], 4, dest_cb, uvlinesize);\n                        add_dct(s, block[5], 5, dest_cr, uvlinesize);\n                    }else{\n                        //chroma422\n                        dct_linesize = uvlinesize << s->interlaced_dct;\n                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize * 8;\n\n                        add_dct(s, block[4], 4, dest_cb, dct_linesize);\n                        add_dct(s, block[5], 5, dest_cr, dct_linesize);\n                        add_dct(s, block[6], 6, dest_cb+dct_offset, dct_linesize);\n                        add_dct(s, block[7], 7, dest_cr+dct_offset, dct_linesize);\n                        if(!s->chroma_x_shift){//Chroma444\n                            add_dct(s, block[8], 8, dest_cb+8, dct_linesize);\n                            add_dct(s, block[9], 9, dest_cr+8, dct_linesize);\n                            add_dct(s, block[10], 10, dest_cb+8+dct_offset, dct_linesize);\n                            add_dct(s, block[11], 11, dest_cr+8+dct_offset, dct_linesize);\n                        }\n                    }\n                }//fi gray\n            }\n            else if (CONFIG_WMV2_DECODER || CONFIG_WMV2_ENCODER) {\n                ff_wmv2_add_mb(s, block, dest_y, dest_cb, dest_cr);\n            }\n        } else {\n            /* dct only in intra block */\n            if(s->encoding || !(s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO)){\n                put_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);\n                put_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);\n                put_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);\n                put_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);\n\n                if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n                    if(s->chroma_y_shift){\n                        put_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);\n                        put_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);\n                    }else{\n                        dct_offset >>=1;\n                        dct_linesize >>=1;\n                        put_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);\n                        put_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);\n                        put_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);\n                        put_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);\n                    }\n                }\n            }else{\n                s->dsp.idct_put(dest_y                          , dct_linesize, block[0]);\n                s->dsp.idct_put(dest_y              + block_size, dct_linesize, block[1]);\n                s->dsp.idct_put(dest_y + dct_offset             , dct_linesize, block[2]);\n                s->dsp.idct_put(dest_y + dct_offset + block_size, dct_linesize, block[3]);\n\n                if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n                    if(s->chroma_y_shift){\n                        s->dsp.idct_put(dest_cb, uvlinesize, block[4]);\n                        s->dsp.idct_put(dest_cr, uvlinesize, block[5]);\n                    }else{\n\n                        dct_linesize = uvlinesize << s->interlaced_dct;\n                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize * 8;\n\n                        s->dsp.idct_put(dest_cb,              dct_linesize, block[4]);\n                        s->dsp.idct_put(dest_cr,              dct_linesize, block[5]);\n                        s->dsp.idct_put(dest_cb + dct_offset, dct_linesize, block[6]);\n                        s->dsp.idct_put(dest_cr + dct_offset, dct_linesize, block[7]);\n                        if(!s->chroma_x_shift){//Chroma444\n                            s->dsp.idct_put(dest_cb + 8,              dct_linesize, block[8]);\n                            s->dsp.idct_put(dest_cr + 8,              dct_linesize, block[9]);\n                            s->dsp.idct_put(dest_cb + 8 + dct_offset, dct_linesize, block[10]);\n                            s->dsp.idct_put(dest_cr + 8 + dct_offset, dct_linesize, block[11]);\n                        }\n                    }\n                }//gray\n            }\n        }\nskip_idct:\n        if(!readable){\n            s->hdsp.put_pixels_tab[0][0](s->dest[0], dest_y ,   linesize,16);\n            s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[1], dest_cb, uvlinesize,16 >> s->chroma_y_shift);\n            s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[2], dest_cr, uvlinesize,16 >> s->chroma_y_shift);\n        }\n    }\n}", "target": 0}
{"idx": 5838, "func": "unsigned char *OPENSSL_asc2uni(const char *asc, int asclen,\n                               unsigned char **uni, int *unilen)\n{\n    int ulen, i;\n    unsigned char *unitmp;\n\n    if (asclen == -1)\n        asclen = strlen(asc);\n    ulen = asclen * 2 + 2;\n    if ((unitmp = OPENSSL_malloc(ulen)) == NULL)\n        return NULL;\n    for (i = 0; i < ulen - 2; i += 2) {\n        unitmp[i] = 0;\n        unitmp[i + 1] = asc[i >> 1];\n    }\n    /* Make result double null terminated */\n    unitmp[ulen - 2] = 0;\n    unitmp[ulen - 1] = 0;\n    if (unilen)\n        *unilen = ulen;\n    if (uni)\n        *uni = unitmp;\n    return unitmp;\n}", "target": 1}
{"idx": 5839, "func": "static int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    MOVStts *ctts_data;\n    uint64_t offset;\n    int64_t dts;\n    int data_offset = 0;\n    unsigned entries, first_sample_flags = frag->flags;\n    int flags, distance, i;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding track id %u\\n\", frag->track_id);\n        return AVERROR_INVALIDDATA;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id+1 != frag->stsd_id && sc->pseudo_stream_id != -1)\n        return 0;\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n    entries = avio_rb32(pb);\n    av_log(c->fc, AV_LOG_TRACE, \"flags 0x%x entries %u\\n\", flags, entries);\n\n    if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    if (flags & MOV_TRUN_DATA_OFFSET)        data_offset        = avio_rb32(pb);\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb);\n    dts    = sc->track_end - sc->time_offset;\n    offset = frag->base_data_offset + data_offset;\n    distance = 0;\n    av_log(c->fc, AV_LOG_TRACE, \"first sample flags 0x%x\\n\", first_sample_flags);\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        unsigned sample_size = frag->size;\n        int sample_flags = i ? frag->flags : first_sample_flags;\n        unsigned sample_duration = frag->duration;\n        unsigned ctts_duration = 0;\n        int keyframe = 0;\n        int ctts_index = 0;\n        int old_nb_index_entries = st->nb_index_entries;\n\n        if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_SIZE)     sample_size     = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)    sample_flags    = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_CTS)      ctts_duration   = avio_rb32(pb);\n\n        mov_update_dts_shift(sc, ctts_duration);\n        if (frag->time != AV_NOPTS_VALUE) {\n            if (c->use_mfra_for == FF_MOV_FLAG_MFRA_PTS) {\n                int64_t pts = frag->time;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \" sc->dts_shift %d ctts.duration %d\"\n                        \" sc->time_offset %\"PRId64\" flags & MOV_TRUN_SAMPLE_CTS %d\\n\", pts,\n                        sc->dts_shift, ctts_duration,\n                        sc->time_offset, flags & MOV_TRUN_SAMPLE_CTS);\n                dts = pts - sc->dts_shift;\n                if (flags & MOV_TRUN_SAMPLE_CTS) {\n                    dts -= ctts_duration;\n                } else {\n                    dts -= sc->time_offset;\n                }\n                av_log(c->fc, AV_LOG_DEBUG, \"calculated into dts %\"PRId64\"\\n\", dts);\n            } else {\n                dts = frag->time - sc->time_offset;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \", using it for dts\\n\", dts);\n            }\n            frag->time = AV_NOPTS_VALUE;\n        }\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n            keyframe = 1;\n        else\n            keyframe =\n                !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC |\n                                  MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES));\n        if (keyframe)\n            distance = 0;\n        ctts_index = av_add_index_entry(st, offset, dts, sample_size, distance,\n                                        keyframe ? AVINDEX_KEYFRAME : 0);\n        if (ctts_index >= 0 && old_nb_index_entries < st->nb_index_entries) {\n            unsigned int size_needed = st->nb_index_entries * sizeof(*sc->ctts_data);\n            unsigned int request_size = size_needed > sc->ctts_allocated_size ?\n                FFMAX(size_needed, 2 * sc->ctts_allocated_size) : size_needed;\n            unsigned int old_ctts_size = sc->ctts_allocated_size;\n            ctts_data = av_fast_realloc(sc->ctts_data, &sc->ctts_allocated_size, request_size);\n            if (!ctts_data) {\n                av_freep(&sc->ctts_data);\n                return AVERROR(ENOMEM);\n            }\n            sc->ctts_data = ctts_data;\n\n            // In case there were samples without ctts entries, ensure they get\n            // zero valued entries. This ensures clips which mix boxes with and\n            // without ctts entries don't pickup uninitialized data.\n            memset((uint8_t*)(sc->ctts_data) + old_ctts_size, 0, sc->ctts_allocated_size - old_ctts_size);\n\n            if (ctts_index != old_nb_index_entries) {\n                memmove(sc->ctts_data + ctts_index + 1, sc->ctts_data + ctts_index,\n                        sizeof(*sc->ctts_data) * (sc->ctts_count - ctts_index));\n                if (ctts_index <= sc->current_sample) {\n                    // if we inserted a new item before the current sample, move the\n                    // counter ahead so it is still pointing to the same sample.\n                    sc->current_sample++;\n                }\n            }\n\n            sc->ctts_data[ctts_index].count = 1;\n            sc->ctts_data[ctts_index].duration = ctts_duration;\n            sc->ctts_count++;\n        } else {\n            av_log(c->fc, AV_LOG_ERROR, \"Failed to add index entry\\n\");\n        }\n\n        av_log(c->fc, AV_LOG_TRACE, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                \"size %u, distance %d, keyframe %d\\n\", st->index, ctts_index,\n                offset, dts, sample_size, distance, keyframe);\n        distance++;\n        dts += sample_duration;\n        offset += sample_size;\n        sc->data_size += sample_size;\n        sc->duration_for_fps += sample_duration;\n        sc->nb_frames_for_fps ++;\n    }\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    frag->implicit_offset = offset;\n\n    sc->track_end = dts + sc->time_offset;\n    if (st->duration < sc->track_end)\n        st->duration = sc->track_end;\n\n    return 0;\n}", "target": 0}
{"idx": 5840, "func": "int ff_MPV_common_init(MpegEncContext *s)\n{\n    int i;\n    int nb_slices = (HAVE_THREADS &&\n                     s->avctx->active_thread_type & FF_THREAD_SLICE) ?\n                    s->avctx->thread_count : 1;\n\n    if (s->encoding && s->avctx->slices)\n        nb_slices = s->avctx->slices;\n\n    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n        s->mb_height = (s->height + 31) / 32 * 2;\n    else\n        s->mb_height = (s->height + 15) / 16;\n\n    if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"decoding to AV_PIX_FMT_NONE is not supported.\\n\");\n        return -1;\n    }\n\n    if (nb_slices > MAX_THREADS || (nb_slices > s->mb_height && s->mb_height)) {\n        int max_slices;\n        if (s->mb_height)\n            max_slices = FFMIN(MAX_THREADS, s->mb_height);\n        else\n            max_slices = MAX_THREADS;\n        av_log(s->avctx, AV_LOG_WARNING, \"too many threads/slices (%d),\"\n               \" reducing to %d\\n\", nb_slices, max_slices);\n        nb_slices = max_slices;\n    }\n\n    if ((s->width || s->height) &&\n        av_image_check_size(s->width, s->height, 0, s->avctx))\n        return -1;\n\n    ff_dct_common_init(s);\n\n    s->flags  = s->avctx->flags;\n    s->flags2 = s->avctx->flags2;\n\n    /* set chroma shifts */\n    avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,\n                                  &s->chroma_x_shift,\n                                  &s->chroma_y_shift);\n\n    /* convert fourcc to upper case */\n    s->codec_tag        = avpriv_toupper4(s->avctx->codec_tag);\n    s->stream_codec_tag = avpriv_toupper4(s->avctx->stream_codec_tag);\n\n    s->avctx->coded_frame = &s->current_picture.f;\n\n    if (s->encoding) {\n        if (s->msmpeg4_version) {\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats,\n                                2 * 2 * (MAX_LEVEL + 1) *\n                                (MAX_RUN + 1) * 2 * sizeof(int), fail);\n        }\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->avctx->stats_out, 256, fail);\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix,          64 * 32   * sizeof(int), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->q_chroma_intra_matrix,   64 * 32   * sizeof(int), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix,          64 * 32   * sizeof(int), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16,        64 * 32 * 2 * sizeof(uint16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->q_chroma_intra_matrix16, 64 * 32 * 2 * sizeof(uint16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16,        64 * 32 * 2 * sizeof(uint16_t), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture,           MAX_PICTURE_COUNT * sizeof(Picture *), fail)\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture *), fail)\n\n        if (s->avctx->noise_reduction) {\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail);\n        }\n    }\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->picture,\n                      MAX_PICTURE_COUNT * sizeof(Picture), fail);\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        avcodec_get_frame_defaults(&s->picture[i].f);\n    }\n    memset(&s->next_picture, 0, sizeof(s->next_picture));\n    memset(&s->last_picture, 0, sizeof(s->last_picture));\n    memset(&s->current_picture, 0, sizeof(s->current_picture));\n    avcodec_get_frame_defaults(&s->next_picture.f);\n    avcodec_get_frame_defaults(&s->last_picture.f);\n    avcodec_get_frame_defaults(&s->current_picture.f);\n\n        if (init_context_frame(s))\n            goto fail;\n\n        s->parse_context.state = -1;\n\n        s->context_initialized = 1;\n        s->thread_context[0]   = s;\n\n//     if (s->width && s->height) {\n        if (nb_slices > 1) {\n            for (i = 1; i < nb_slices; i++) {\n                s->thread_context[i] = av_malloc(sizeof(MpegEncContext));\n                memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n            }\n\n            for (i = 0; i < nb_slices; i++) {\n                if (init_duplicate_context(s->thread_context[i]) < 0)\n                    goto fail;\n                    s->thread_context[i]->start_mb_y =\n                        (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n                    s->thread_context[i]->end_mb_y   =\n                        (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n            }\n        } else {\n            if (init_duplicate_context(s) < 0)\n                goto fail;\n            s->start_mb_y = 0;\n            s->end_mb_y   = s->mb_height;\n        }\n        s->slice_context_count = nb_slices;\n//     }\n\n    return 0;\n fail:\n    ff_MPV_common_end(s);\n    return -1;\n}", "target": 1}
{"idx": 5841, "func": "static int decode_p_frame(FourXContext *f, const uint8_t *buf, int length){\n    int x, y;\n    const int width= f->avctx->width;\n    const int height= f->avctx->height;\n    uint16_t *src= (uint16_t*)f->last_picture.data[0];\n    uint16_t *dst= (uint16_t*)f->current_picture.data[0];\n    const int stride= f->current_picture.linesize[0]>>1;\n    unsigned int bitstream_size, bytestream_size, wordstream_size, extra;\n\n    if(f->version>1){\n        extra=20;\n        if (length < extra)\n            return -1;\n        bitstream_size= AV_RL32(buf+8);\n        wordstream_size= AV_RL32(buf+12);\n        bytestream_size= AV_RL32(buf+16);\n    }else{\n        extra=0;\n        bitstream_size = AV_RL16(buf-4);\n        wordstream_size= AV_RL16(buf-2);\n        bytestream_size= FFMAX(length - bitstream_size - wordstream_size, 0);\n    }\n\n    if (bitstream_size > length ||\n        bytestream_size > length - bitstream_size ||\n        wordstream_size > length - bytestream_size - bitstream_size ||\n        extra > length - bytestream_size - bitstream_size - wordstream_size){\n        av_log(f->avctx, AV_LOG_ERROR, \"lengths %d %d %d %d\\n\", bitstream_size, bytestream_size, wordstream_size,\n        bitstream_size+ bytestream_size+ wordstream_size - length);\n        return -1;\n    }\n\n    av_fast_malloc(&f->bitstream_buffer, &f->bitstream_buffer_size, bitstream_size + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!f->bitstream_buffer)\n        return AVERROR(ENOMEM);\n    f->dsp.bswap_buf(f->bitstream_buffer, (const uint32_t*)(buf + extra), bitstream_size/4);\n    memset((uint8_t*)f->bitstream_buffer + bitstream_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n    init_get_bits(&f->gb, f->bitstream_buffer, 8*bitstream_size);\n\n    f->wordstream= (const uint16_t*)(buf + extra + bitstream_size);\n    f->wordstream_end= f->wordstream + wordstream_size/2;\n    f->bytestream= buf + extra + bitstream_size + wordstream_size;\n    f->bytestream_end = f->bytestream + bytestream_size;\n\n    init_mv(f);\n\n    for(y=0; y<height; y+=8){\n        for(x=0; x<width; x+=8){\n            decode_p_block(f, dst + x, src + x, 3, 3, stride);\n        }\n        src += 8*stride;\n        dst += 8*stride;\n    }\n\n    if(   bitstream_size != (get_bits_count(&f->gb)+31)/32*4\n       || (((const char*)f->wordstream - (const char*)buf + 2)&~2) != extra + bitstream_size + wordstream_size\n       || (((const char*)f->bytestream - (const char*)buf + 3)&~3) != extra + bitstream_size + wordstream_size + bytestream_size)\n        av_log(f->avctx, AV_LOG_ERROR, \" %d %td %td bytes left\\n\",\n            bitstream_size - (get_bits_count(&f->gb)+31)/32*4,\n            -(((const char*)f->bytestream - (const char*)buf + 3)&~3) + (extra + bitstream_size + wordstream_size + bytestream_size),\n            -(((const char*)f->wordstream - (const char*)buf + 2)&~2) + (extra + bitstream_size + wordstream_size)\n        );\n\n    return 0;\n}", "target": 0}
{"idx": 5842, "func": "static int nsv_read_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    int i, err;\n\n    av_dlog(s, \"%s()\\n\", __FUNCTION__);\n    av_dlog(s, \"filename '%s'\\n\", s->filename);\n\n    nsv->state = NSV_UNSYNC;\n    nsv->ahead[0].data = nsv->ahead[1].data = NULL;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES; i++) {\n        if (nsv_resync(s) < 0)\n            return -1;\n        if (nsv->state == NSV_FOUND_NSVF)\n            err = nsv_parse_NSVf_header(s);\n            /* we need the first NSVs also... */\n        if (nsv->state == NSV_FOUND_NSVS) {\n            err = nsv_parse_NSVs_header(s);\n            break; /* we just want the first one */\n        }\n    }\n    if (s->nb_streams < 1) /* no luck so far */\n        return -1;\n    /* now read the first chunk, so we can attempt to decode more info */\n    err = nsv_read_chunk(s, 1);\n\n    av_dlog(s, \"parsed header\\n\");\n    return err;\n}", "target": 1}
{"idx": 5843, "func": "static void\nChopUpSingleUncompressedStrip(TIFF* tif)\n{\n\tregister TIFFDirectory *td = &tif->tif_dir;\n\tuint64 bytecount;\n\tuint64 offset;\n\tuint32 rowblock;\n\tuint64 rowblockbytes;\n\tuint64 stripbytes;\n\tuint32 nstrips;\n\tuint32 rowsperstrip;\n\n\tbytecount = TIFFGetStrileByteCount(tif, 0);\n        /* On a newly created file, just re-opened to be filled, we */\n        /* don't want strip chop to trigger as it is going to cause issues */\n        /* later ( StripOffsets and StripByteCounts improperly filled) . */\n        if( bytecount == 0 && tif->tif_mode != O_RDONLY )\n            return;\n\toffset = TIFFGetStrileByteCount(tif, 0);\n\tassert(td->td_planarconfig == PLANARCONFIG_CONTIG);\n\tif ((td->td_photometric == PHOTOMETRIC_YCBCR)&&\n\t    (!isUpSampled(tif)))\n\t\trowblock = td->td_ycbcrsubsampling[1];\n\telse\n\t\trowblock = 1;\n\trowblockbytes = TIFFVTileSize64(tif, rowblock);\n\t/*\n\t * Make the rows hold at least one scanline, but fill specified amount\n\t * of data if possible.\n\t */\n\tif (rowblockbytes > STRIP_SIZE_DEFAULT) {\n\t\tstripbytes = rowblockbytes;\n\t\trowsperstrip = rowblock;\n\t} else if (rowblockbytes > 0 ) {\n\t\tuint32 rowblocksperstrip;\n\t\trowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);\n\t\trowsperstrip = rowblocksperstrip * rowblock;\n\t\tstripbytes = rowblocksperstrip * rowblockbytes;\n\t}\n\telse\n\t    return;\n\n\t/*\n\t * never increase the number of rows per strip\n\t */\n\tif (rowsperstrip >= td->td_rowsperstrip)\n\t\treturn;\n        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);\n        if( nstrips == 0 )\n            return;\n\n        /* If we are going to allocate a lot of memory, make sure that the */\n        /* file is as big as needed */\n        if( tif->tif_mode == O_RDONLY &&\n            nstrips > 1000000 &&\n            (offset >= TIFFGetFileSize(tif) ||\n             stripbytes > (TIFFGetFileSize(tif) - offset) / (nstrips - 1)) )\n        {\n            return;\n        }\n\n        allocChoppedUpStripArrays(tif, nstrips, stripbytes, rowsperstrip);\n}", "target": 0}
{"idx": 5844, "func": "static void update(uint8_t *target, int max, int intensity)\n{\n    if (*target <= max)\n        *target += intensity;\n    else\n        *target = 255;\n}", "target": 1}
{"idx": 5845, "func": "static int\nFax3SetupState(TIFF* tif)\n{\n\tstatic const char module[] = \"Fax3SetupState\";\n\tTIFFDirectory* td = &tif->tif_dir;\n\tFax3BaseState* sp = Fax3State(tif);\n\tint needsRefLine;\n\tFax3CodecState* dsp = (Fax3CodecState*) Fax3State(tif);\n\ttmsize_t rowbytes;\n\tuint32 rowpixels, nruns;\n\n\tif (td->td_bitspersample != 1) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Bits/sample must be 1 for Group 3/4 encoding/decoding\");\n\t\treturn (0);\n\t}\n\t/*\n\t * Calculate the scanline/tile widths.\n\t */\n\tif (isTiled(tif)) {\n\t\trowbytes = TIFFTileRowSize(tif);\n\t\trowpixels = td->td_tilewidth;\n\t} else {\n\t\trowbytes = TIFFScanlineSize(tif);\n\t\trowpixels = td->td_imagewidth;\n\t}\n\tsp->rowbytes = rowbytes;\n\tsp->rowpixels = rowpixels;\n\t/*\n\t * Allocate any additional space required for decoding/encoding.\n\t */\n\tneedsRefLine = (\n\t    (sp->groupoptions & GROUP3OPT_2DENCODING) ||\n\t    td->td_compression == COMPRESSION_CCITTFAX4\n\t);\n\n\t/* TIFFroundup_32 returns zero on internal overflow */\n\tnruns = TIFFroundup_32(rowpixels,32);\n\tif (needsRefLine) {\n\t\tnruns *= 2;\n\t}\n\tdsp->runs = (uint32*) _TIFFCheckMalloc(tif, 2*nruns, sizeof (uint32),\n\t\t\t\t\t  \"for Group 3/4 run arrays\");\n\tif (dsp->runs == NULL)\n\t\treturn (0);\n\tdsp->curruns = dsp->runs;\n\tif (needsRefLine)\n\t\tdsp->refruns = dsp->runs + nruns;\n\telse\n\t\tdsp->refruns = NULL;\n\tif (td->td_compression == COMPRESSION_CCITTFAX3\n\t    && is2DEncoding(dsp)) {\t/* NB: default is 1D routine */\n\t\ttif->tif_decoderow = Fax3Decode2D;\n\t\ttif->tif_decodestrip = Fax3Decode2D;\n\t\ttif->tif_decodetile = Fax3Decode2D;\n\t}\n\n\tif (needsRefLine) {\t\t/* 2d encoding */\n\t\tFax3CodecState* esp = EncoderState(tif);\n\t\t/*\n\t\t * 2d encoding requires a scanline\n\t\t * buffer for the ``reference line''; the\n\t\t * scanline against which delta encoding\n\t\t * is referenced.  The reference line must\n\t\t * be initialized to be ``white'' (done elsewhere).\n\t\t */\n\t\tesp->refline = (unsigned char*) _TIFFmalloc(rowbytes);\n\t\tif (esp->refline == NULL) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"No space for Group 3/4 reference line\");\n\t\t\treturn (0);\n\t\t}\n\t} else\t\t\t\t\t/* 1d encoding */\n\t\tEncoderState(tif)->refline = NULL;\n\n\treturn (1);\n}", "target": 0}
{"idx": 5846, "func": "static void\nngx_http_upstream_process_header(ngx_http_request_t *r, ngx_http_upstream_t *u)\n{\n    ssize_t            n;\n    ngx_int_t          rc;\n    ngx_connection_t  *c;\n\n    c = u->peer.connection;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                   \"http upstream process header\");\n\n    c->log->action = \"reading response header from upstream\";\n\n    if (c->read->timedout) {\n        ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);\n        return;\n    }\n\n    if (!u->request_sent && ngx_http_upstream_test_connect(c) != NGX_OK) {\n        ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);\n        return;\n    }\n\n    if (u->buffer.start == NULL) {\n        u->buffer.start = ngx_palloc(r->pool, u->conf->buffer_size);\n        if (u->buffer.start == NULL) {\n            ngx_http_upstream_finalize_request(r, u,\n                                               NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return;\n        }\n\n        u->buffer.pos = u->buffer.start;\n        u->buffer.last = u->buffer.start;\n        u->buffer.end = u->buffer.start + u->conf->buffer_size;\n        u->buffer.temporary = 1;\n\n        u->buffer.tag = u->output.tag;\n\n        if (ngx_list_init(&u->headers_in.headers, r->pool, 8,\n                          sizeof(ngx_table_elt_t))\n            != NGX_OK)\n        {\n            ngx_http_upstream_finalize_request(r, u,\n                                               NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return;\n        }\n\n#if (NGX_HTTP_CACHE)\n\n        if (r->cache) {\n            u->buffer.pos += r->cache->header_start;\n            u->buffer.last = u->buffer.pos;\n        }\n#endif\n    }\n\n    for ( ;; ) {\n\n        n = c->recv(c, u->buffer.last, u->buffer.end - u->buffer.last);\n\n        if (n == NGX_AGAIN) {\n#if 0\n            ngx_add_timer(rev, u->read_timeout);\n#endif\n\n            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n                ngx_http_upstream_finalize_request(r, u,\n                                               NGX_HTTP_INTERNAL_SERVER_ERROR);\n                return;\n            }\n\n            return;\n        }\n\n        if (n == 0) {\n            ngx_log_error(NGX_LOG_ERR, c->log, 0,\n                          \"upstream prematurely closed connection\");\n        }\n\n        if (n == NGX_ERROR || n == 0) {\n            ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);\n            return;\n        }\n\n        u->buffer.last += n;\n\n#if 0\n        u->valid_header_in = 0;\n\n        u->peer.cached = 0;\n#endif\n\n        rc = u->process_header(r);\n\n        if (rc == NGX_AGAIN) {\n\n            if (u->buffer.last == u->buffer.end) {\n                ngx_log_error(NGX_LOG_ERR, c->log, 0,\n                              \"upstream sent too big header\");\n\n                ngx_http_upstream_next(r, u,\n                                       NGX_HTTP_UPSTREAM_FT_INVALID_HEADER);\n                return;\n            }\n\n            continue;\n        }\n\n        break;\n    }\n\n    if (rc == NGX_HTTP_UPSTREAM_INVALID_HEADER) {\n        ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_INVALID_HEADER);\n        return;\n    }\n\n    if (rc == NGX_ERROR) {\n        ngx_http_upstream_finalize_request(r, u,\n                                           NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return;\n    }\n\n    /* rc == NGX_OK */\n\n    if (u->headers_in.status_n >= NGX_HTTP_SPECIAL_RESPONSE) {\n\n        if (ngx_http_upstream_test_next(r, u) == NGX_OK) {\n            return;\n        }\n\n        if (ngx_http_upstream_intercept_errors(r, u) == NGX_OK) {\n            return;\n        }\n    }\n\n    if (ngx_http_upstream_process_headers(r, u) != NGX_OK) {\n        return;\n    }\n\n    if (!r->subrequest_in_memory) {\n        ngx_http_upstream_send_response(r, u);\n        return;\n    }\n\n    /* subrequest content in memory */\n\n    if (u->input_filter == NULL) {\n        u->input_filter_init = ngx_http_upstream_non_buffered_filter_init;\n        u->input_filter = ngx_http_upstream_non_buffered_filter;\n        u->input_filter_ctx = r;\n    }\n\n    if (u->input_filter_init(u->input_filter_ctx) == NGX_ERROR) {\n        ngx_http_upstream_finalize_request(r, u, NGX_ERROR);\n        return;\n    }\n\n    n = u->buffer.last - u->buffer.pos;\n\n    if (n) {\n        u->buffer.last = u->buffer.pos;\n\n        u->state->response_length += n;\n\n        if (u->input_filter(u->input_filter_ctx, n) == NGX_ERROR) {\n            ngx_http_upstream_finalize_request(r, u, NGX_ERROR);\n            return;\n        }\n    }\n\n    if (u->length == 0) {\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    u->read_event_handler = ngx_http_upstream_process_body_in_memory;\n\n    ngx_http_upstream_process_body_in_memory(r, u);\n}", "target": 0}
{"idx": 5847, "func": "static int compat_decode(AVCodecContext *avctx, AVFrame *frame,\n                         int *got_frame, AVPacket *pkt)\n{\n    AVCodecInternal *avci = avctx->internal;\n    int ret = 0;\n\n    av_assert0(avci->compat_decode_consumed == 0);\n\n    *got_frame = 0;\n    avci->compat_decode = 1;\n\n    if (avci->compat_decode_partial_size > 0 &&\n        avci->compat_decode_partial_size != pkt->size) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Got unexpected packet size after a partial decode\\n\");\n        ret = AVERROR(EINVAL);\n        goto finish;\n    }\n\n    if (!avci->compat_decode_partial_size) {\n        ret = avcodec_send_packet(avctx, pkt);\n        if (ret == AVERROR_EOF)\n            ret = 0;\n        else if (ret == AVERROR(EAGAIN)) {\n            /* we fully drain all the output in each decode call, so this should not\n             * ever happen */\n            ret = AVERROR_BUG;\n            goto finish;\n        } else if (ret < 0)\n            goto finish;\n    }\n\n    while (ret >= 0) {\n        ret = avcodec_receive_frame(avctx, frame);\n        if (ret < 0) {\n            if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)\n                ret = 0;\n            goto finish;\n        }\n\n        if (frame != avci->compat_decode_frame) {\n            if (!avctx->refcounted_frames) {\n                ret = unrefcount_frame(avci, frame);\n                if (ret < 0)\n                    goto finish;\n            }\n\n            *got_frame = 1;\n            frame = avci->compat_decode_frame;\n        } else {\n            if (!avci->compat_decode_warned) {\n                av_log(avctx, AV_LOG_WARNING, \"The deprecated avcodec_decode_* \"\n                       \"API cannot return all the frames for this decoder. \"\n                       \"Some frames will be dropped. Update your code to the \"\n                       \"new decoding API to fix this.\\n\");\n                avci->compat_decode_warned = 1;\n            }\n        }\n\n        if (avci->draining || (!avctx->codec->bsfs && avci->compat_decode_consumed < pkt->size))\n            break;\n    }\n\nfinish:\n    if (ret == 0) {\n        /* if there are any bsfs then assume full packet is always consumed */\n        if (avctx->codec->bsfs)\n            ret = pkt->size;\n        else\n            ret = FFMIN(avci->compat_decode_consumed, pkt->size);\n    }\n    avci->compat_decode_consumed = 0;\n    avci->compat_decode_partial_size = (ret >= 0) ? pkt->size - ret : 0;\n\n    return ret;\n}", "target": 0}
{"idx": 5848, "func": "static void wiener_denoise(WMAVoiceContext *s, int fcb_type,\n                           float *synth_pf, int size,\n                           const float *lpcs)\n{\n    int remainder, lim, n;\n\n    if (fcb_type != FCB_TYPE_SILENCE) {\n        float *tilted_lpcs = s->tilted_lpcs_pf,\n              *coeffs = s->denoise_coeffs_pf, tilt_mem = 0;\n\n        tilted_lpcs[0]           = 1.0;\n        memcpy(&tilted_lpcs[1], lpcs, sizeof(lpcs[0]) * s->lsps);\n        memset(&tilted_lpcs[s->lsps + 1], 0,\n               sizeof(tilted_lpcs[0]) * (128 - s->lsps - 1));\n        ff_tilt_compensation(&tilt_mem, 0.7 * tilt_factor(lpcs, s->lsps),\n                             tilted_lpcs, s->lsps + 2);\n\n        /* The IRDFT output (127 samples for 7-bit filter) beyond the frame\n         * size is applied to the next frame. All input beyond this is zero,\n         * and thus all output beyond this will go towards zero, hence we can\n         * limit to min(size-1, 127-size) as a performance consideration. */\n        remainder = FFMIN(127 - size, size - 1);\n        calc_input_response(s, tilted_lpcs, fcb_type, coeffs, remainder);\n\n        /* apply coefficients (in frequency spectrum domain), i.e. complex\n         * number multiplication */\n        memset(&synth_pf[size], 0, sizeof(synth_pf[0]) * (128 - size));\n        ff_rdft_calc(&s->rdft, synth_pf);\n        ff_rdft_calc(&s->rdft, coeffs);\n        synth_pf[0] *= coeffs[0];\n        synth_pf[1] *= coeffs[1];\n        for (n = 1; n < 128; n++) {\n            float v1 = synth_pf[n * 2], v2 = synth_pf[n * 2 + 1];\n            synth_pf[n * 2]     = v1 * coeffs[n * 2] - v2 * coeffs[n * 2 + 1];\n            synth_pf[n * 2 + 1] = v2 * coeffs[n * 2] + v1 * coeffs[n * 2 + 1];\n        }\n        ff_rdft_calc(&s->irdft, synth_pf);\n    }\n\n    /* merge filter output with the history of previous runs */\n    if (s->denoise_filter_cache_size) {\n        lim = FFMIN(s->denoise_filter_cache_size, size);\n        for (n = 0; n < lim; n++)\n            synth_pf[n] += s->denoise_filter_cache[n];\n        s->denoise_filter_cache_size -= lim;\n        memmove(s->denoise_filter_cache, &s->denoise_filter_cache[size],\n                sizeof(s->denoise_filter_cache[0]) * s->denoise_filter_cache_size);\n    }\n\n    /* move remainder of filter output into a cache for future runs */\n    if (fcb_type != FCB_TYPE_SILENCE) {\n        lim = FFMIN(remainder, s->denoise_filter_cache_size);\n        for (n = 0; n < lim; n++)\n            s->denoise_filter_cache[n] += synth_pf[size + n];\n        if (lim < remainder) {\n            memcpy(&s->denoise_filter_cache[lim], &synth_pf[size + lim],\n                   sizeof(s->denoise_filter_cache[0]) * (remainder - lim));\n            s->denoise_filter_cache_size = remainder;\n        }\n    }\n}", "target": 1}
{"idx": 5849, "func": "static int def_destroy_data(CONF *conf)\n\t{\n\tif (conf == NULL)\n\t\treturn 0;\n\t_CONF_free_data(conf);\n\treturn 1;\n\t}", "target": 0}
{"idx": 5850, "func": "void av_aes_crypt(AVAES *a, uint8_t *dst_, const uint8_t *src_,\n                  int count, uint8_t *iv_, int decrypt)\n{\n    av_aes_block       *dst = (av_aes_block *) dst_;\n    const av_aes_block *src = (const av_aes_block *) src_;\n    av_aes_block        *iv = (av_aes_block *) iv_;\n\n    while (count--) {\n        addkey(&a->state[1], src, &a->round_key[a->rounds]);\n        if (decrypt) {\n            crypt(a, 0, inv_sbox, dec_multbl);\n            if (iv) {\n                addkey(&a->state[0], &a->state[0], iv);\n                memcpy(iv, src, 16);\n            }\n            addkey(dst, &a->state[0], &a->round_key[0]);\n        } else {\n            if (iv)\n                addkey(&a->state[1], &a->state[1], iv);\n            crypt(a, 2, sbox, enc_multbl);\n            addkey(dst, &a->state[0], &a->round_key[0]);\n            if (iv)\n                memcpy(iv, dst, 16);\n        }\n        src++;\n        dst++;\n    }\n}", "target": 1}
{"idx": 5851, "func": "static inline void gmc1_motion(MpegEncContext *s,\n                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n                               uint8_t **ref_picture)\n{\n    uint8_t *ptr;\n    int offset, src_x, src_y, linesize, uvlinesize;\n    int motion_x, motion_y;\n    int emu=0;\n\n    motion_x= s->sprite_offset[0][0];\n    motion_y= s->sprite_offset[0][1];\n    src_x = s->mb_x * 16 + (motion_x >> (s->sprite_warping_accuracy+1));\n    src_y = s->mb_y * 16 + (motion_y >> (s->sprite_warping_accuracy+1));\n    motion_x<<=(3-s->sprite_warping_accuracy);\n    motion_y<<=(3-s->sprite_warping_accuracy);\n    src_x = av_clip(src_x, -16, s->width);\n    if (src_x == s->width)\n        motion_x =0;\n    src_y = av_clip(src_y, -16, s->height);\n    if (src_y == s->height)\n        motion_y =0;\n\n    linesize = s->linesize;\n    uvlinesize = s->uvlinesize;\n\n    ptr = ref_picture[0] + (src_y * linesize) + src_x;\n\n    if(s->flags&CODEC_FLAG_EMU_EDGE){\n        if(   (unsigned)src_x >= FFMAX(s->h_edge_pos - 17, 0)\n           || (unsigned)src_y >= FFMAX(s->v_edge_pos - 17, 0)){\n            s->dsp.emulated_edge_mc(s->edge_emu_buffer, ptr, linesize, 17, 17, src_x, src_y, s->h_edge_pos, s->v_edge_pos);\n            ptr= s->edge_emu_buffer;\n        }\n    }\n\n    if((motion_x|motion_y)&7){\n        s->dsp.gmc1(dest_y  , ptr  , linesize, 16, motion_x&15, motion_y&15, 128 - s->no_rounding);\n        s->dsp.gmc1(dest_y+8, ptr+8, linesize, 16, motion_x&15, motion_y&15, 128 - s->no_rounding);\n    }else{\n        int dxy;\n\n        dxy= ((motion_x>>3)&1) | ((motion_y>>2)&2);\n        if (s->no_rounding){\n            s->dsp.put_no_rnd_pixels_tab[0][dxy](dest_y, ptr, linesize, 16);\n        }else{\n            s->dsp.put_pixels_tab       [0][dxy](dest_y, ptr, linesize, 16);\n        }\n    }\n\n    if(CONFIG_GRAY && s->flags&CODEC_FLAG_GRAY) return;\n\n    motion_x= s->sprite_offset[1][0];\n    motion_y= s->sprite_offset[1][1];\n    src_x = s->mb_x * 8 + (motion_x >> (s->sprite_warping_accuracy+1));\n    src_y = s->mb_y * 8 + (motion_y >> (s->sprite_warping_accuracy+1));\n    motion_x<<=(3-s->sprite_warping_accuracy);\n    motion_y<<=(3-s->sprite_warping_accuracy);\n    src_x = av_clip(src_x, -8, s->width>>1);\n    if (src_x == s->width>>1)\n        motion_x =0;\n    src_y = av_clip(src_y, -8, s->height>>1);\n    if (src_y == s->height>>1)\n        motion_y =0;\n\n    offset = (src_y * uvlinesize) + src_x;\n    ptr = ref_picture[1] + offset;\n    if(s->flags&CODEC_FLAG_EMU_EDGE){\n        if(   (unsigned)src_x >= FFMAX((s->h_edge_pos>>1) - 9, 0)\n           || (unsigned)src_y >= FFMAX((s->v_edge_pos>>1) - 9, 0)){\n            s->dsp.emulated_edge_mc(s->edge_emu_buffer, ptr, uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n            ptr= s->edge_emu_buffer;\n            emu=1;\n        }\n    }\n    s->dsp.gmc1(dest_cb, ptr, uvlinesize, 8, motion_x&15, motion_y&15, 128 - s->no_rounding);\n\n    ptr = ref_picture[2] + offset;\n    if(emu){\n        s->dsp.emulated_edge_mc(s->edge_emu_buffer, ptr, uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n        ptr= s->edge_emu_buffer;\n    }\n    s->dsp.gmc1(dest_cr, ptr, uvlinesize, 8, motion_x&15, motion_y&15, 128 - s->no_rounding);\n\n    return;\n}", "target": 1}
