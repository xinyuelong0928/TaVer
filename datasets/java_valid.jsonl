{"idx": 902, "func": "// Copyright (C) 2012 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage com.google.json;\n\nimport static com.google.json.JsonSanitizer.DEFAULT_NESTING_DEPTH;\nimport static com.google.json.JsonSanitizer.sanitize;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport junit.framework.TestCase;\nimport org.junit.Test;\n\n@SuppressWarnings(\"javadoc\")\npublic final class JsonSanitizerTest extends TestCase {\n\n  private static void assertSanitized(String golden, String input) {\n    assertSanitized(golden, input, DEFAULT_NESTING_DEPTH);\n  }\n\n  private static void assertSanitized(String golden, String input, int maximumNestingDepth) {\n    String actual = sanitize(input, maximumNestingDepth);\n    assertEquals(input, golden, actual);\n    if (actual.equals(input)) {\n      assertSame(input, input, actual);\n    }\n  }\n\n  private static void assertSanitized(String sanitary) {\n    assertSanitized(sanitary, sanitary);\n  }\n\n  @Test\n  public static final void testSanitize() {\n    // On the left is the sanitized output, and on the right the input.\n    // If there is a single string, then the input is fine as-is.\n    assertSanitized(\"null\", null);\n    assertSanitized(\"null\", \"\");\n    assertSanitized(\"null\");\n    assertSanitized(\"false\");\n    assertSanitized(\"true\");\n    assertSanitized(\" false \");\n    assertSanitized(\"  false\");\n    assertSanitized(\"false\\n\");\n    assertSanitized(\"false\", \"false,true\");\n    assertSanitized(\"\\\"foo\\\"\");\n    assertSanitized(\"\\\"foo\\\"\", \"'foo'\");\n    assertSanitized(\n        \"\\\"\\\\u003cscript>foo()\\\\u003c/script>\\\"\", \"\\\"<script>foo()</script>\\\"\");\n    assertSanitized(\"\\\"\\\\u003c/SCRIPT\\\\n>\\\"\", \"\\\"</SCRIPT\\n>\\\"\");\n    assertSanitized(\"\\\"\\\\u003c/ScRIpT\\\"\", \"\\\"</ScRIpT\\\"\");\n    // \\u0130 is a Turkish dotted upper-case 'I' so the lower case version of\n    // the tag name is \"script\".\n    assertSanitized(\"\\\"\\\\u003c/ScR\\u0130pT\\\"\", \"\\\"</ScR\\u0130pT\\\"\");\n    assertSanitized(\"\\\"<b>Hello</b>\\\"\");\n    assertSanitized(\"\\\"<s>Hello</s>\\\"\");\n    assertSanitized(\"\\\"<[[\\\\u005d]>\\\"\", \"'<[[]]>'\");\n    assertSanitized(\"\\\"\\\\u005d]>\\\"\", \"']]>'\");\n    assertSanitized(\"[[0]]\", \"[[0]]>\");\n    assertSanitized(\"[1,-1,0.0,-0.5,1e2]\", \"[1,-1,0.0,-0.5,1e2,\");\n    assertSanitized(\"[1,2,3]\", \"[1,2,3,]\");\n    assertSanitized(\"[1,null,3]\", \"[1,,3,]\");\n    assertSanitized(\"[1 ,2 ,3]\", \"[1 2 3]\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ \\\"foo\\\": \\\"bar\\\", }\");\n    assertSanitized(\"{\\\"foo\\\":\\\"bar\\\"}\", \"{\\\"foo\\\",\\\"bar\\\"}\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ foo: \\\"bar\\\" }\");\n    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\"}\", \"{ foo: 'bar\");\n    assertSanitized(\"{ \\\"foo\\\": [\\\"bar\\\"]}\", \"{ foo: ['bar\");\n    assertSanitized(\"false\", \"// comment\\nfalse\");\n    assertSanitized(\"false\", \"false// comment\");\n    assertSanitized(\"false\", \"false// comment\\n\");\n    assertSanitized(\"false\", \"false/* comment */\");\n    assertSanitized(\"false\", \"false/* comment *\");\n    assertSanitized(\"false\", \"false/* comment \");\n    assertSanitized(\"false\", \"/*/true**/false\");\n    assertSanitized(\"1\");\n    assertSanitized(\"-1\");\n    assertSanitized(\"1.0\");\n    assertSanitized(\"-1.0\");\n    assertSanitized(\"1.05\");\n    assertSanitized(\"427.0953333\");\n    assertSanitized(\"6.0221412927e+23\");\n    assertSanitized(\"6.0221412927e23\");\n    assertSanitized(\"6.0221412927e0\", \"6.0221412927e\");\n    assertSanitized(\"6.0221412927e-0\", \"6.0221412927e-\");\n    assertSanitized(\"6.0221412927e+0\", \"6.0221412927e+\");\n    assertSanitized(\"1.660538920287695E-24\");\n    assertSanitized(\"-6.02e-23\");\n    assertSanitized(\"1.0\", \"1.\");\n    assertSanitized(\"0.5\", \".5\");\n    assertSanitized(\"-0.5\", \"-.5\");\n    assertSanitized(\"0.5\", \"+.5\");\n    assertSanitized(\"0.5e2\", \"+.5e2\");\n    assertSanitized(\"1.5e+2\", \"+1.5e+2\");\n    assertSanitized(\"0.5e-2\", \"+.5e-2\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{0:0}\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{-0:0}\");\n    assertSanitized(\"{\\\"0\\\":0}\", \"{+0:0}\");\n    assertSanitized(\"{\\\"1\\\":0}\", \"{1.0:0}\");\n    assertSanitized(\"{\\\"1\\\":0}\", \"{1.:0}\");\n    assertSanitized(\"{\\\"0.5\\\":0}\", \"{.5:0}\");\n    assertSanitized(\"{\\\"-0.5\\\":0}\", \"{-.5:0}\");\n    assertSanitized(\"{\\\"0.5\\\":0}\", \"{+.5:0}\");\n    assertSanitized(\"{\\\"50\\\":0}\", \"{+.5e2:0}\");\n    assertSanitized(\"{\\\"150\\\":0}\", \"{+1.5e+2:0}\");\n    assertSanitized(\"{\\\"0.1\\\":0}\", \"{+.1:0}\");\n    assertSanitized(\"{\\\"0.01\\\":0}\", \"{+.01:0}\");\n    assertSanitized(\"{\\\"0.005\\\":0}\", \"{+.5e-2:0}\");\n    assertSanitized(\"{\\\"1e+101\\\":0}\", \"{10e100:0}\");\n    assertSanitized(\"{\\\"1e-99\\\":0}\", \"{10e-100:0}\");\n    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.5e-100:0}\");\n    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.500e-100:0}\");\n    assertSanitized(\"{\\\"1.234e+101\\\":0}\", \"{12.34e100:0}\");\n    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");\n    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");\n    assertSanitized(\"{}\");\n    // Remove grouping parentheses.\n    assertSanitized(\"{}\", \"({})\");\n    // Escape code-points and isolated surrogates which are not XML embeddable.\n    assertSanitized(\"\\\"\\\\u0000\\\\u0008\\\\u001f\\\"\", \"'\\u0000\\u0008\\u001f'\");\n    assertSanitized(\"\\\"\\ud800\\udc00\\\\udc00\\\\ud800\\\"\",\n                    \"'\\ud800\\udc00\\udc00\\ud800'\");\n    assertSanitized(\"\\\"\\ufffd\\\\ufffe\\\\uffff\\\"\", \"'\\ufffd\\ufffe\\uffff'\");\n    // These control characters should be elided if they appear outside a string\n    // literal.\n    assertSanitized(\"42\", \"\\uffef\\u000042\\u0008\\ud800\\uffff\\udc00\");\n    assertSanitized(\"null\", \"\\uffef\\u0000\\u0008\\ud800\\uffff\\udc00\");\n    assertSanitized(\"[null]\", \"[,]\");\n    assertSanitized(\"[null]\", \"[null,]\");\n    assertSanitized(\"{\\\"a\\\":0,\\\"false\\\":\\\"x\\\",\\\"\\\":{\\\"\\\":-1}}\",\n                    \"{\\\"a\\\":0,false\\\"x\\\":{\\\"\\\":-1}}\");\n    assertSanitized(\"[true ,false]\", \"[true false]\");\n    assertSanitized(\"[\\\"\\\\u00a0\\\\u1234\\\"]\");\n    assertSanitized(\"{\\\"a\\\\b\\\":\\\"c\\\"}\", \"{a\\\\b\\\"c\");\n    assertSanitized(\"{\\\"a\\\":\\\"b\\\",\\\"c\\\":null}\", \"{\\\"a\\\":\\\"b\\\",\\\"c\\\":\");\n    assertSanitized(\n        \"{\\\"1e0001234567890123456789123456789123456789\\\":0}\",\n        // Exponent way out of representable range in a JS double.\n        \"{1e0001234567890123456789123456789123456789:0}\"\n                    );\n    // Our octal recoder interprets an octal-like literal that includes a digit '8' or '9' as\n    // decimal.\n    assertSanitized(\"-16923547559\", \"-016923547559\");\n  }\n\n  @Test\n  public static final void testIssue3() {\n    // These triggered index out of bounds and assertion errors.\n    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{},\\u00E4\");\n    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{\\u00E4\\u00E4},\\u00E4\");\n  }\n\n  @Test\n  public static final void testIssue4() {\n    // Make sure that bare words are quoted.\n    assertSanitized(\"\\\"dev\\\"\", \"dev\");\n    assertSanitized(\"\\\"eval\\\"\", \"eval\");\n    assertSanitized(\"\\\"comment\\\"\", \"comment\");\n    assertSanitized(\"\\\"fasle\\\"\", \"fasle\");\n    assertSanitized(\"\\\"FALSE\\\"\", \"FALSE\");\n    assertSanitized(\"\\\"dev/comment\\\"\", \"dev/comment\");\n    assertSanitized(\"\\\"devcomment\\\"\", \"dev\\\\comment\");\n    assertSanitized(\"\\\"dev\\\\ncomment\\\"\", \"dev\\\\ncomment\");\n    assertSanitized(\"[\\\"dev\\\", \\\"comment\\\"]\", \"[dev\\\\, comment]\");\n  }\n\n  @Test\n  public static final void testMaximumNestingLevel() {\n    String nestedMaps = \"{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";\n    String sanitizedNestedMaps = \"{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";\n\n    boolean exceptionIfTooMuchNesting = false;\n    try {\n      assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      Logger.getAnonymousLogger().log(Level.FINEST, \"Expected exception in testing maximum nesting level\", e);\n      exceptionIfTooMuchNesting = true;\n    }\n    assertTrue(\"Expecting failure for too nested JSON\", exceptionIfTooMuchNesting);\n    assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH + 1);\n  }\n\n  @Test\n  public static final void testMaximumNestingLevelAssignment() {\n    assertEquals(1, new JsonSanitizer(\"\", Integer.MIN_VALUE).getMaximumNestingDepth());\n    assertEquals(JsonSanitizer.MAXIMUM_NESTING_DEPTH, new JsonSanitizer(\"\", Integer.MAX_VALUE).getMaximumNestingDepth());\n  }\n\n  @Test\n  public static final void testClosedArray() {\n    // Discovered by fuzzer with seed -Dfuzz.seed=df3b4778ce54d00a\n    assertSanitized(\"-1742461140214282\", \"\\ufeff-01742461140214282]\");\n  }\n\n  @Test\n  public static final void testIssue13() {\n    assertSanitized(\n        \"[ { \\\"description\\\": \\\"aa##############aa\\\" }, 1 ]\",\n        \"[ { \\\"description\\\": \\\"aa##############aa\\\" }, 1 ]\");\n  }\n\n  @Test\n  public static final void testHtmlParserStateChanges() {\n    assertSanitized(\"\\\"\\\\u003cscript\\\"\", \"\\\"<script\\\"\");\n    assertSanitized(\"\\\"\\\\u003cScript\\\"\", \"\\\"<Script\\\"\");\n    // \\u0130 is a Turkish dotted upper-case 'I' so the lower case version of\n    // the tag name is \"script\".\n    assertSanitized(\"\\\"\\\\u003cScR\\u0130pT\\\"\", \"\\\"<ScR\\u0130pT\\\"\");\n    assertSanitized(\"\\\"\\\\u003cSCRIPT\\\\n>\\\"\", \"\\\"<SCRIPT\\n>\\\"\");\n    assertSanitized(\"\\\"script\\\"\", \"<script\");\n\n    assertSanitized(\"\\\"\\\\u003c!--\\\"\", \"\\\"<!--\\\"\");\n    assertSanitized(\"-0\", \"<!--\");\n\n    assertSanitized(\"\\\"--\\\\u003e\\\"\", \"\\\"-->\\\"\");\n    assertSanitized(\"-0\", \"-->\");\n\n    assertSanitized(\"\\\"\\\\u003c!--\\\\u003cscript>\\\"\", \"\\\"<!--<script>\\\"\");\n  }\n}\n", "target": 1}
{"idx": 903, "func": "/*\n * JBoss, Home of Professional Open Source\n * Copyright 2010, Red Hat, Inc. and individual contributors\n * by the @authors tag. See the copyright.txt in the distribution for a\n * full listing of individual contributors.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.richfaces.webapp;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.text.MessageFormat;\nimport java.util.Collections;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.atmosphere.cpr.BroadcastFilter;\nimport org.atmosphere.cpr.Broadcaster.SCOPE;\nimport org.atmosphere.cpr.Meteor;\nimport org.richfaces.application.push.PushContext;\nimport org.richfaces.application.push.Request;\nimport org.richfaces.application.push.Session;\nimport org.richfaces.application.push.impl.RequestImpl;\nimport org.richfaces.log.Logger;\nimport org.richfaces.log.RichfacesLogger;\n\n/**\n * Serves as delegate for Atmposphere servlets - should not be used directly\n *\n * @author Nick Belaevski\n *\n */\npublic class PushHandlerFilter implements Filter, Serializable {\n    public static final String SESSION_ATTRIBUTE_NAME = Session.class.getName();\n    public static final String REQUEST_ATTRIBUTE_NAME = Request.class.getName();\n    private static final long serialVersionUID = 5724886106704391903L;\n    public static final String PUSH_SESSION_ID_PARAM = \"pushSessionId\";\n    private static final Logger LOGGER = RichfacesLogger.WEBAPP.getLogger();\n\n    private int servletMajorVersion;\n    private transient ServletContext servletContext;\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n        servletContext = filterConfig.getServletContext();\n        servletMajorVersion = servletContext.getMajorVersion();\n    }\n\n    /**\n     * Note: Filter does not delegate to chain, since it would lead into cycle by calling\n     * {@link PushServlet#service(ServletRequest, ServletResponse)}.\n     */\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,\n            ServletException {\n        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n            HttpServletRequest httpReq = (HttpServletRequest) request;\n            HttpServletResponse httpResp = (HttpServletResponse) response;\n\n            if (\"GET\".equals(httpReq.getMethod())) {\n                String pushSessionId = httpReq.getParameter(PUSH_SESSION_ID_PARAM);\n\n                Session session = null;\n\n                if (pushSessionId != null) {\n                    ensureServletContextAvailable(request);\n                    PushContext pushContext = (PushContext) servletContext.getAttribute(PushContext.INSTANCE_KEY_NAME);\n                    session = pushContext.getSessionManager().getPushSession(pushSessionId);\n                }\n\n                if (session == null) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(MessageFormat.format(\"Session {0} was not found\", pushSessionId));\n                    }\n                    httpResp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                    return;\n                }\n\n                httpResp.setContentType(\"text/plain\");\n\n                Meteor meteor = Meteor.build(httpReq, SCOPE.REQUEST, Collections.<BroadcastFilter>emptyList(), null);\n\n                try {\n                    Request pushRequest = new RequestImpl(meteor, session);\n\n                    httpReq.setAttribute(SESSION_ATTRIBUTE_NAME, session);\n                    httpReq.setAttribute(REQUEST_ATTRIBUTE_NAME, pushRequest);\n\n                    pushRequest.suspend();\n                } catch (Exception e) {\n                    LOGGER.error(e.getMessage(), e);\n                }\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Ensures that servletContext instance is available, or throws exception.\n     *\n     * This method ensures compatibility with Servlet &lt;3.0, which doesn't support obtaining {@link ServletContext} from\n     * {@link ServletRequest}.\n     *\n     * @param request {@link ServletRequest}\n     * @throws {@link IllegalStateException} when {@link ServletContext} won't be available in Servlets &lt;3.0 environments.\n     *         This can happen when this filter was serialized.\n     */\n    private void ensureServletContextAvailable(ServletRequest request) {\n        if (servletContext == null) {\n            if (servletMajorVersion >= 3) {\n                servletContext = request.getServletContext();\n            } else {\n                throw new IllegalStateException(\n                        \"ServletContext is not available (you are using Servlets API <3.0; it might be caused by \"\n                                + PushHandlerFilter.class.getName() + \" in distributed environment)\");\n            }\n        }\n    }\n\n    public void destroy() {\n        servletContext = null;\n    }\n}\n", "target": 0}
{"idx": 904, "func": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.facebook.thrift;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.Assert.assertThat;\n\nimport com.facebook.thrift.java.test.BigEnum;\nimport com.facebook.thrift.java.test.MySimpleStruct;\nimport com.facebook.thrift.java.test.SmallEnum;\nimport junit.framework.TestCase;\nimport org.junit.Test;\n\npublic class StructTest extends TestCase {\n  @Test\n  public void testStructHashcode() throws Exception {\n    MySimpleStruct defaultStruct = new MySimpleStruct();\n    assertThat(defaultStruct.hashCode(), is(not(equalTo(0))));\n\n    MySimpleStruct struct1 = new MySimpleStruct(1, \"Foo\");\n    MySimpleStruct struct2 = new MySimpleStruct(2, \"Bar\");\n\n    assertThat(struct1.hashCode(), is(not(equalTo(0))));\n    assertThat(struct2.hashCode(), is(not(equalTo(0))));\n    assertThat(struct1.hashCode(), is(not(equalTo(struct2.hashCode()))));\n  }\n\n  @Test\n  public void testSmallEnum() throws Exception {\n    assertThat(SmallEnum.findByValue(SmallEnum.RED.getValue()), equalTo(SmallEnum.RED));\n    assertThat(SmallEnum.findByValue(Integer.MAX_VALUE), equalTo(null));\n  }\n\n  @Test\n  public void testBigEnum() throws Exception {\n    assertThat(BigEnum.findByValue(BigEnum.ONE.getValue()), equalTo(BigEnum.ONE));\n    assertThat(BigEnum.findByValue(Integer.MAX_VALUE), equalTo(null));\n  }\n}\n", "target": 0}
{"idx": 905, "func": "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.kernel.security;\n\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.security.authentication.encoding.PasswordEncoder;\nimport org.springframework.security.crypto.bcrypt.BCrypt;\n\n/**\n *\n */\npublic class CustomPasswordEncoder implements PasswordEncoder {\n  private Logger logger = LoggerFactory.getLogger(CustomPasswordEncoder.class);\n\n  /**\n   * Encode the raw password for storage using BCrypt.\n   * @param rawPassword raw password to encrypt/hash\n   * @return hashed password\n   */\n  public String encodePassword(final String rawPassword) {\n    return encodePassword(rawPassword, null);\n  }\n\n  /**\n   * Encode the raw password for storage using BCrypt.\n   * @param rawPassword raw password to encrypt/hash\n   * @param ignored This parameter will not be used. A random salt is generated by BCrypt.\n   * @return hashed password\n   */\n  @Override\n  public String encodePassword(final String rawPassword, final Object ignored) {\n    return BCrypt.hashpw(rawPassword, BCrypt.gensalt());\n  }\n\n  /**\n   * Verify the encoded password obtained from storage matches the submitted raw\n   * password after it too is encoded. Returns true if the passwords match, false if\n   * they do not. The stored password itself is never decoded.\n   *\n   * @param rawPassword the raw password to encode and match\n   * @param encodedPassword the encoded password from storage to compare with\n   * @return true if the raw password, after encoding, matches the encoded password from storage\n   */\n  @Override\n  public boolean isPasswordValid(String encodedPassword, String rawPassword, Object salt) {\n    // Test MD5 encoded hash\n    if (encodedPassword.length() == 32) {\n      final String hash = md5Encode(rawPassword, salt);\n      logger.debug(\"Checking md5 hashed password '{}' against encoded password '{}'\", hash, encodedPassword);\n      return hash.equals(encodedPassword);\n    }\n\n    // Test BCrypt encoded hash\n    logger.debug(\"Verifying BCrypt hash {}\", encodedPassword);\n    return BCrypt.checkpw(rawPassword, encodedPassword);\n  }\n\n  /**\n   * Encode a clear text password using Opencast's legacy MD5 based hashing with salt.\n   * The username was used as salt for this.\n   *\n   * @param clearText\n   *          the password\n   * @param salt\n   *          the salt\n   * @return the hashed password\n   * @throws IllegalArgumentException\n   *           if clearText or salt are null\n   */\n  public static String md5Encode(String clearText, Object salt) throws IllegalArgumentException {\n    if (clearText == null || salt == null)\n      throw new IllegalArgumentException(\"clearText and salt must not be null\");\n    return DigestUtils.md5Hex(clearText + \"{\" + salt.toString() + \"}\");\n  }\n}\n", "target": 0}
{"idx": 906, "func": "package org.bouncycastle.pqc.crypto.xmss;\n\nimport java.io.IOException;\n\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.util.Arrays;\n\n/**\n * XMSS^MT Private Key.\n */\npublic final class XMSSMTPrivateKeyParameters\n    extends AsymmetricKeyParameter\n    implements XMSSStoreableObjectInterface\n{\n\n    private final XMSSMTParameters params;\n    private final long index;\n    private final byte[] secretKeySeed;\n    private final byte[] secretKeyPRF;\n    private final byte[] publicSeed;\n    private final byte[] root;\n    private final BDSStateMap bdsState;\n\n    private XMSSMTPrivateKeyParameters(Builder builder)\n    {\n        super(true);\n        params = builder.params;\n        if (params == null)\n        {\n            throw new NullPointerException(\"params == null\");\n        }\n        int n = params.getDigestSize();\n        byte[] privateKey = builder.privateKey;\n        if (privateKey != null)\n        {\n            if (builder.xmss == null)\n            {\n                throw new NullPointerException(\"xmss == null\");\n            }\n            /* import */\n            int totalHeight = params.getHeight();\n            int indexSize = (totalHeight + 7) / 8;\n            int secretKeySize = n;\n            int secretKeyPRFSize = n;\n            int publicSeedSize = n;\n            int rootSize = n;\n            /*\n            int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n\t\t\tif (privateKey.length != totalSize) {\n\t\t\t\tthrow new ParseException(\"private key has wrong size\", 0);\n\t\t\t}\n\t\t\t*/\n            int position = 0;\n            index = XMSSUtil.bytesToXBigEndian(privateKey, position, indexSize);\n            if (!XMSSUtil.isIndexValid(totalHeight, index))\n            {\n                throw new IllegalArgumentException(\"index out of bounds\");\n            }\n            position += indexSize;\n            secretKeySeed = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeySize);\n            position += secretKeySize;\n            secretKeyPRF = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeyPRFSize);\n            position += secretKeyPRFSize;\n            publicSeed = XMSSUtil.extractBytesAtOffset(privateKey, position, publicSeedSize);\n            position += publicSeedSize;\n            root = XMSSUtil.extractBytesAtOffset(privateKey, position, rootSize);\n            position += rootSize;\n\t\t\t/* import BDS state */\n            byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);\n\n            BDSStateMap bdsImport = null;\n            try\n            {\n                bdsImport = (BDSStateMap)XMSSUtil.deserialize(bdsStateBinary);\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            catch (ClassNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n            bdsImport.setXMSS(builder.xmss);\n            bdsState = bdsImport;\n        }\n        else\n        {\n\t\t\t/* set */\n            index = builder.index;\n            byte[] tmpSecretKeySeed = builder.secretKeySeed;\n            if (tmpSecretKeySeed != null)\n            {\n                if (tmpSecretKeySeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeySeed needs to be equal size of digest\");\n                }\n                secretKeySeed = tmpSecretKeySeed;\n            }\n            else\n            {\n                secretKeySeed = new byte[n];\n            }\n            byte[] tmpSecretKeyPRF = builder.secretKeyPRF;\n            if (tmpSecretKeyPRF != null)\n            {\n                if (tmpSecretKeyPRF.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeyPRF needs to be equal size of digest\");\n                }\n                secretKeyPRF = tmpSecretKeyPRF;\n            }\n            else\n            {\n                secretKeyPRF = new byte[n];\n            }\n            byte[] tmpPublicSeed = builder.publicSeed;\n            if (tmpPublicSeed != null)\n            {\n                if (tmpPublicSeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of publicSeed needs to be equal size of digest\");\n                }\n                publicSeed = tmpPublicSeed;\n            }\n            else\n            {\n                publicSeed = new byte[n];\n            }\n            byte[] tmpRoot = builder.root;\n            if (tmpRoot != null)\n            {\n                if (tmpRoot.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of root needs to be equal size of digest\");\n                }\n                root = tmpRoot;\n            }\n            else\n            {\n                root = new byte[n];\n            }\n            BDSStateMap tmpBDSState = builder.bdsState;\n            if (tmpBDSState != null)\n            {\n                bdsState = tmpBDSState;\n            }\n            else\n            {\n                long globalIndex = builder.index;\n                int totalHeight = params.getHeight();\n\n                if (XMSSUtil.isIndexValid(totalHeight, globalIndex) && tmpPublicSeed != null && tmpSecretKeySeed != null)\n                {\n                    bdsState = new BDSStateMap(params, builder.index, tmpPublicSeed, tmpSecretKeySeed);\n                }\n                else\n                {\n                    bdsState = new BDSStateMap();\n                }\n            }\n        }\n    }\n\n    public static class Builder\n    {\n\n        /* mandatory */\n        private final XMSSMTParameters params;\n        /* optional */\n        private long index = 0L;\n        private byte[] secretKeySeed = null;\n        private byte[] secretKeyPRF = null;\n        private byte[] publicSeed = null;\n        private byte[] root = null;\n        private BDSStateMap bdsState = null;\n        private byte[] privateKey = null;\n        private XMSSParameters xmss = null;\n\n        public Builder(XMSSMTParameters params)\n        {\n            super();\n            this.params = params;\n        }\n\n        public Builder withIndex(long val)\n        {\n            index = val;\n            return this;\n        }\n\n        public Builder withSecretKeySeed(byte[] val)\n        {\n            secretKeySeed = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withSecretKeyPRF(byte[] val)\n        {\n            secretKeyPRF = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withPublicSeed(byte[] val)\n        {\n            publicSeed = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withRoot(byte[] val)\n        {\n            root = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withBDSState(BDSStateMap val)\n        {\n            bdsState = val;\n            return this;\n        }\n\n        public Builder withPrivateKey(byte[] privateKeyVal, XMSSParameters xmssVal)\n        {\n            privateKey = XMSSUtil.cloneArray(privateKeyVal);\n            xmss = xmssVal;\n            return this;\n        }\n\n        public XMSSMTPrivateKeyParameters build()\n        {\n            return new XMSSMTPrivateKeyParameters(this);\n        }\n    }\n\n    public byte[] toByteArray()\n    {\n\t\t/* index || secretKeySeed || secretKeyPRF || publicSeed || root */\n        int n = params.getDigestSize();\n        int indexSize = (params.getHeight() + 7) / 8;\n        int secretKeySize = n;\n        int secretKeyPRFSize = n;\n        int publicSeedSize = n;\n        int rootSize = n;\n        int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n        byte[] out = new byte[totalSize];\n        int position = 0;\n\t\t/* copy index */\n        byte[] indexBytes = XMSSUtil.toBytesBigEndian(index, indexSize);\n        XMSSUtil.copyBytesAtOffset(out, indexBytes, position);\n        position += indexSize;\n\t\t/* copy secretKeySeed */\n        XMSSUtil.copyBytesAtOffset(out, secretKeySeed, position);\n        position += secretKeySize;\n\t\t/* copy secretKeyPRF */\n        XMSSUtil.copyBytesAtOffset(out, secretKeyPRF, position);\n        position += secretKeyPRFSize;\n\t\t/* copy publicSeed */\n        XMSSUtil.copyBytesAtOffset(out, publicSeed, position);\n        position += publicSeedSize;\n\t\t/* copy root */\n        XMSSUtil.copyBytesAtOffset(out, root, position);\n\t\t/* concatenate bdsState */\n        byte[] bdsStateOut = null;\n        try\n        {\n            bdsStateOut = XMSSUtil.serialize(bdsState);\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n            throw new RuntimeException(\"error serializing bds state\");\n        }\n        return Arrays.concatenate(out, bdsStateOut);\n    }\n\n    public long getIndex()\n    {\n        return index;\n    }\n\n    public byte[] getSecretKeySeed()\n    {\n        return XMSSUtil.cloneArray(secretKeySeed);\n    }\n\n    public byte[] getSecretKeyPRF()\n    {\n        return XMSSUtil.cloneArray(secretKeyPRF);\n    }\n\n    public byte[] getPublicSeed()\n    {\n        return XMSSUtil.cloneArray(publicSeed);\n    }\n\n    public byte[] getRoot()\n    {\n        return XMSSUtil.cloneArray(root);\n    }\n\n    BDSStateMap getBDSState()\n    {\n        return bdsState;\n    }\n\n    public XMSSMTParameters getParameters()\n    {\n        return params;\n    }\n\n    public XMSSMTPrivateKeyParameters getNextKey()\n    {\n        BDSStateMap newState = new BDSStateMap(bdsState, params, this.getIndex(), publicSeed, secretKeySeed);\n\n        return new XMSSMTPrivateKeyParameters.Builder(params).withIndex(index + 1)\n            .withSecretKeySeed(secretKeySeed).withSecretKeyPRF(secretKeyPRF)\n            .withPublicSeed(publicSeed).withRoot(root)\n            .withBDSState(newState).build();\n    }\n}\n", "target": 1}
{"idx": 907, "func": "/*\n * Copyright (c) 2007 innoSysTec (R) GmbH, Germany. All rights reserved.\n * Original author: Edmund Wagner\n * Creation date: 22.05.2007\n *\n * Source: $HeadURL$\n * Last changed: $LastChangedDate$\n *\n * the unrar licence applies to all junrar source and binary distributions\n * you are not allowed to use this source to re-create the RAR compression\n * algorithm\n *\n * Here some html entities which can be used for escaping javadoc tags:\n * \"&\":  \"&#038;\" or \"&amp;\"\n * \"<\":  \"&#060;\" or \"&lt;\"\n * \">\":  \"&#062;\" or \"&gt;\"\n * \"@\":  \"&#064;\"\n */\npackage com.github.junrar;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport com.github.junrar.exception.RarException;\nimport com.github.junrar.exception.RarException.RarExceptionType;\nimport com.github.junrar.impl.FileVolumeManager;\nimport com.github.junrar.io.IReadOnlyAccess;\nimport com.github.junrar.rarfile.AVHeader;\nimport com.github.junrar.rarfile.BaseBlock;\nimport com.github.junrar.rarfile.BlockHeader;\nimport com.github.junrar.rarfile.CommentHeader;\nimport com.github.junrar.rarfile.EAHeader;\nimport com.github.junrar.rarfile.EndArcHeader;\nimport com.github.junrar.rarfile.FileHeader;\nimport com.github.junrar.rarfile.MacInfoHeader;\nimport com.github.junrar.rarfile.MainHeader;\nimport com.github.junrar.rarfile.MarkHeader;\nimport com.github.junrar.rarfile.ProtectHeader;\nimport com.github.junrar.rarfile.SignHeader;\nimport com.github.junrar.rarfile.SubBlockHeader;\nimport com.github.junrar.rarfile.UnixOwnersHeader;\nimport com.github.junrar.rarfile.UnrarHeadertype;\nimport com.github.junrar.unpack.ComprDataIO;\nimport com.github.junrar.unpack.Unpack;\n\n\n/**\n * The Main Rar Class; represents a rar Archive\n * \n * @author $LastChangedBy$\n * @version $LastChangedRevision$\n */\npublic class Archive implements Closeable {\n\tprivate static Logger logger = Logger.getLogger(Archive.class.getName());\n\n\tprivate IReadOnlyAccess rof;\n\n\tprivate final UnrarCallback unrarCallback;\n\n\tprivate final ComprDataIO dataIO;\n\n\tprivate final List<BaseBlock> headers = new ArrayList<BaseBlock>();\n\n\tprivate MarkHeader markHead = null;\n\n\tprivate MainHeader newMhd = null;\n\n\tprivate Unpack unpack;\n\n\tprivate int currentHeaderIndex;\n\n\t/** Size of packed data in current file. */\n\tprivate long totalPackedSize = 0L;\n\n\t/** Number of bytes of compressed data read from current file. */\n\tprivate long totalPackedRead = 0L;\n\n\tprivate VolumeManager volumeManager;\n\tprivate Volume volume;\n\n\tpublic Archive(VolumeManager volumeManager) throws RarException,\n\t\t\tIOException {\n\t\tthis(volumeManager, null);\n\t}\n\n\t/**\n\t * create a new archive object using the given {@link VolumeManager}\n\t * \n\t * @param volumeManager\n\t *            the the {@link VolumeManager} that will provide volume stream\n\t *            data\n\t * @throws RarException\n\t */\n\tpublic Archive(VolumeManager volumeManager, UnrarCallback unrarCallback)\n\t\t\tthrows RarException, IOException {\n\t\tthis.volumeManager = volumeManager;\n\t\tthis.unrarCallback = unrarCallback;\n\n\t\tsetVolume(this.volumeManager.nextArchive(this, null));\n\t\tdataIO = new ComprDataIO(this);\n\t}\n\n\tpublic Archive(File firstVolume) throws RarException, IOException {\n\t\tthis(new FileVolumeManager(firstVolume), null);\n\t}\n\n\tpublic Archive(File firstVolume, UnrarCallback unrarCallback)\n\t\t\tthrows RarException, IOException {\n\t\tthis(new FileVolumeManager(firstVolume), unrarCallback);\n\t}\n\n\t// public File getFile() {\n\t// return file;\n\t// }\n\t//\n\t// void setFile(File file) throws IOException {\n\t// this.file = file;\n\t// setFile(new ReadOnlyAccessFile(file), file.length());\n\t// }\n\n\tprivate void setFile(IReadOnlyAccess file, long length) throws IOException {\n\t\ttotalPackedSize = 0L;\n\t\ttotalPackedRead = 0L;\n\t\tclose();\n\t\trof = file;\n\t\ttry {\n\t\t\treadHeaders(length);\n\t\t} catch (Exception e) {\n\t\t\tlogger.log(Level.WARNING,\n\t\t\t\t\t\"exception in archive constructor maybe file is encrypted \"\n\t\t\t\t\t\t\t+ \"or currupt\", e);\n\t\t\t// ignore exceptions to allow exraction of working files in\n\t\t\t// corrupt archive\n\t\t}\n\t\t// Calculate size of packed data\n\t\tfor (BaseBlock block : headers) {\n\t\t\tif (block.getHeaderType() == UnrarHeadertype.FileHeader) {\n\t\t\t\ttotalPackedSize += ((FileHeader) block).getFullPackSize();\n\t\t\t}\n\t\t}\n\t\tif (unrarCallback != null) {\n\t\t\tunrarCallback.volumeProgressChanged(totalPackedRead,\n\t\t\t\t\ttotalPackedSize);\n\t\t}\n\t}\n\n\tpublic void bytesReadRead(int count) {\n\t\tif (count > 0) {\n\t\t\ttotalPackedRead += count;\n\t\t\tif (unrarCallback != null) {\n\t\t\t\tunrarCallback.volumeProgressChanged(totalPackedRead,\n\t\t\t\t\t\ttotalPackedSize);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic IReadOnlyAccess getRof() {\n\t\treturn rof;\n\t}\n\n\t/**\n\t * Gets all of the headers in the archive.\n\t *\n\t * @return returns the headers.\n\t */\n\tpublic List<BaseBlock> getHeaders() {\n\t\treturn new ArrayList<BaseBlock>(headers);\n\t}\n\n\t/**\n\t * @return returns all file headers of the archive\n\t */\n\tpublic List<FileHeader> getFileHeaders() {\n\t\tList<FileHeader> list = new ArrayList<FileHeader>();\n\t\tfor (BaseBlock block : headers) {\n\t\t\tif (block.getHeaderType().equals(UnrarHeadertype.FileHeader)) {\n\t\t\t\tlist.add((FileHeader) block);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic FileHeader nextFileHeader() {\n\t\tint n = headers.size();\n\t\twhile (currentHeaderIndex < n) {\n\t\t\tBaseBlock block = headers.get(currentHeaderIndex++);\n\t\t\tif (block.getHeaderType() == UnrarHeadertype.FileHeader) {\n\t\t\t\treturn (FileHeader) block;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic UnrarCallback getUnrarCallback() {\n\t\treturn unrarCallback;\n\t}\n\n\t/**\n\t * \n\t * @return whether the archive is encrypted\n\t */\n\tpublic boolean isEncrypted() {\n\t\tif (newMhd != null) {\n\t\t\treturn newMhd.isEncrypted();\n\t\t} else {\n\t\t\tthrow new NullPointerException(\"mainheader is null\");\n\t\t}\n\t}\n\n\t/**\n\t * Read the headers of the archive\n\t * \n\t * @param fileLength\n\t *            Length of file.\n\t * @throws RarException\n\t */\n\tprivate void readHeaders(long fileLength) throws IOException, RarException {\n\t\tmarkHead = null;\n\t\tnewMhd = null;\n\t\theaders.clear();\n\t\tcurrentHeaderIndex = 0;\n\t\tint toRead = 0;\n\n\t\twhile (true) {\n\t\t\tint size = 0;\n\t\t\tlong newpos = 0;\n\t\t\tbyte[] baseBlockBuffer = new byte[BaseBlock.BaseBlockSize];\n\n\t\t\tlong position = rof.getPosition();\n\n\t\t\t// Weird, but is trying to read beyond the end of the file\n\t\t\tif (position >= fileLength) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// logger.info(\"\\n--------reading header--------\");\n\t\t\tsize = rof.readFully(baseBlockBuffer, BaseBlock.BaseBlockSize);\n\t\t\tif (size == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBaseBlock block = new BaseBlock(baseBlockBuffer);\n\n\t\t\tblock.setPositionInFile(position);\n\n\t\t\tswitch (block.getHeaderType()) {\n\n\t\t\tcase MarkHeader:\n\t\t\t\tmarkHead = new MarkHeader(block);\n\t\t\t\tif (!markHead.isSignature()) {\n\t\t\t\t\tthrow new RarException(\n\t\t\t\t\t\t\tRarException.RarExceptionType.badRarArchive);\n\t\t\t\t}\n\t\t\t\theaders.add(markHead);\n\t\t\t\t// markHead.print();\n\t\t\t\tbreak;\n\n\t\t\tcase MainHeader:\n\t\t\t\ttoRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc\n\t\t\t\t\t\t: MainHeader.mainHeaderSize;\n\t\t\t\tbyte[] mainbuff = new byte[toRead];\n\t\t\t\trof.readFully(mainbuff, toRead);\n\t\t\t\tMainHeader mainhead = new MainHeader(block, mainbuff);\n\t\t\t\theaders.add(mainhead);\n\t\t\t\tthis.newMhd = mainhead;\n\t\t\t\tif (newMhd.isEncrypted()) {\n\t\t\t\t\tthrow new RarException(\n\t\t\t\t\t\t\tRarExceptionType.rarEncryptedException);\n\t\t\t\t}\n\t\t\t\t// mainhead.print();\n\t\t\t\tbreak;\n\n\t\t\tcase SignHeader:\n\t\t\t\ttoRead = SignHeader.signHeaderSize;\n\t\t\t\tbyte[] signBuff = new byte[toRead];\n\t\t\t\trof.readFully(signBuff, toRead);\n\t\t\t\tSignHeader signHead = new SignHeader(block, signBuff);\n\t\t\t\theaders.add(signHead);\n\t\t\t\t// logger.info(\"HeaderType: SignHeader\");\n\n\t\t\t\tbreak;\n\n\t\t\tcase AvHeader:\n\t\t\t\ttoRead = AVHeader.avHeaderSize;\n\t\t\t\tbyte[] avBuff = new byte[toRead];\n\t\t\t\trof.readFully(avBuff, toRead);\n\t\t\t\tAVHeader avHead = new AVHeader(block, avBuff);\n\t\t\t\theaders.add(avHead);\n\t\t\t\t// logger.info(\"headertype: AVHeader\");\n\t\t\t\tbreak;\n\n\t\t\tcase CommHeader:\n\t\t\t\ttoRead = CommentHeader.commentHeaderSize;\n\t\t\t\tbyte[] commBuff = new byte[toRead];\n\t\t\t\trof.readFully(commBuff, toRead);\n\t\t\t\tCommentHeader commHead = new CommentHeader(block, commBuff);\n\t\t\t\theaders.add(commHead);\n\t\t\t\t// logger.info(\"method: \"+commHead.getUnpMethod()+\"; 0x\"+\n\t\t\t\t// Integer.toHexString(commHead.getUnpMethod()));\n\t\t\t\tnewpos = commHead.getPositionInFile()\n\t\t\t\t\t\t+ commHead.getHeaderSize();\n\t\t\t\trof.setPosition(newpos);\n\n\t\t\t\tbreak;\n\t\t\tcase EndArcHeader:\n\n\t\t\t\ttoRead = 0;\n\t\t\t\tif (block.hasArchiveDataCRC()) {\n\t\t\t\t\ttoRead += EndArcHeader.endArcArchiveDataCrcSize;\n\t\t\t\t}\n\t\t\t\tif (block.hasVolumeNumber()) {\n\t\t\t\t\ttoRead += EndArcHeader.endArcVolumeNumberSize;\n\t\t\t\t}\n\t\t\t\tEndArcHeader endArcHead;\n\t\t\t\tif (toRead > 0) {\n\t\t\t\t\tbyte[] endArchBuff = new byte[toRead];\n\t\t\t\t\trof.readFully(endArchBuff, toRead);\n\t\t\t\t\tendArcHead = new EndArcHeader(block, endArchBuff);\n\t\t\t\t\t// logger.info(\"HeaderType: endarch\\ndatacrc:\"+\n\t\t\t\t\t// endArcHead.getArchiveDataCRC());\n\t\t\t\t} else {\n\t\t\t\t\t// logger.info(\"HeaderType: endarch - no Data\");\n\t\t\t\t\tendArcHead = new EndArcHeader(block, null);\n\t\t\t\t}\n\t\t\t\theaders.add(endArcHead);\n\t\t\t\t// logger.info(\"\\n--------end header--------\");\n\t\t\t\treturn;\n\n\t\t\tdefault:\n\t\t\t\tbyte[] blockHeaderBuffer = new byte[BlockHeader.blockHeaderSize];\n\t\t\t\trof.readFully(blockHeaderBuffer, BlockHeader.blockHeaderSize);\n\t\t\t\tBlockHeader blockHead = new BlockHeader(block,\n\t\t\t\t\t\tblockHeaderBuffer);\n\n\t\t\t\tswitch (blockHead.getHeaderType()) {\n\t\t\t\tcase NewSubHeader:\n\t\t\t\tcase FileHeader:\n\t\t\t\t\ttoRead = blockHead.getHeaderSize()\n\t\t\t\t\t\t\t- BlockHeader.BaseBlockSize\n\t\t\t\t\t\t\t- BlockHeader.blockHeaderSize;\n\t\t\t\t\tbyte[] fileHeaderBuffer = new byte[toRead];\n\t\t\t\t\trof.readFully(fileHeaderBuffer, toRead);\n\n\t\t\t\t\tFileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);\n\t\t\t\t\theaders.add(fh);\n\t\t\t\t\tnewpos = fh.getPositionInFile() + fh.getHeaderSize()\n\t\t\t\t\t\t\t+ fh.getFullPackSize();\n\t\t\t\t\trof.setPosition(newpos);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ProtectHeader:\n\t\t\t\t\ttoRead = blockHead.getHeaderSize()\n\t\t\t\t\t\t\t- BlockHeader.BaseBlockSize\n\t\t\t\t\t\t\t- BlockHeader.blockHeaderSize;\n\t\t\t\t\tbyte[] protectHeaderBuffer = new byte[toRead];\n\t\t\t\t\trof.readFully(protectHeaderBuffer, toRead);\n\t\t\t\t\tProtectHeader ph = new ProtectHeader(blockHead,\n\t\t\t\t\t\t\tprotectHeaderBuffer);\n\n\t\t\t\t\tnewpos = ph.getPositionInFile() + ph.getHeaderSize()\n\t\t\t\t\t\t\t+ ph.getDataSize();\n\t\t\t\t\trof.setPosition(newpos);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SubHeader: {\n\t\t\t\t\tbyte[] subHeadbuffer = new byte[SubBlockHeader.SubBlockHeaderSize];\n\t\t\t\t\trof.readFully(subHeadbuffer,\n\t\t\t\t\t\t\tSubBlockHeader.SubBlockHeaderSize);\n\t\t\t\t\tSubBlockHeader subHead = new SubBlockHeader(blockHead,\n\t\t\t\t\t\t\tsubHeadbuffer);\n\t\t\t\t\tsubHead.print();\n\t\t\t\t\tswitch (subHead.getSubType()) {\n\t\t\t\t\tcase MAC_HEAD: {\n\t\t\t\t\t\tbyte[] macHeaderbuffer = new byte[MacInfoHeader.MacInfoHeaderSize];\n\t\t\t\t\t\trof.readFully(macHeaderbuffer,\n\t\t\t\t\t\t\t\tMacInfoHeader.MacInfoHeaderSize);\n\t\t\t\t\t\tMacInfoHeader macHeader = new MacInfoHeader(subHead,\n\t\t\t\t\t\t\t\tmacHeaderbuffer);\n\t\t\t\t\t\tmacHeader.print();\n\t\t\t\t\t\theaders.add(macHeader);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// TODO implement other subheaders\n\t\t\t\t\tcase BEEA_HEAD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EA_HEAD: {\n\t\t\t\t\t\tbyte[] eaHeaderBuffer = new byte[EAHeader.EAHeaderSize];\n\t\t\t\t\t\trof.readFully(eaHeaderBuffer, EAHeader.EAHeaderSize);\n\t\t\t\t\t\tEAHeader eaHeader = new EAHeader(subHead,\n\t\t\t\t\t\t\t\teaHeaderBuffer);\n\t\t\t\t\t\teaHeader.print();\n\t\t\t\t\t\theaders.add(eaHeader);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase NTACL_HEAD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase STREAM_HEAD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UO_HEAD:\n\t\t\t\t\t\ttoRead = subHead.getHeaderSize();\n\t\t\t\t\t\ttoRead -= BaseBlock.BaseBlockSize;\n\t\t\t\t\t\ttoRead -= BlockHeader.blockHeaderSize;\n\t\t\t\t\t\ttoRead -= SubBlockHeader.SubBlockHeaderSize;\n\t\t\t\t\t\tbyte[] uoHeaderBuffer = new byte[toRead];\n\t\t\t\t\t\trof.readFully(uoHeaderBuffer, toRead);\n\t\t\t\t\t\tUnixOwnersHeader uoHeader = new UnixOwnersHeader(\n\t\t\t\t\t\t\t\tsubHead, uoHeaderBuffer);\n\t\t\t\t\t\tuoHeader.print();\n\t\t\t\t\t\theaders.add(uoHeader);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.warning(\"Unknown Header\");\n\t\t\t\t\tthrow new RarException(RarExceptionType.notRarArchive);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t// logger.info(\"\\n--------end header--------\");\n\t\t}\n\t}\n\n\t/**\n\t * Extract the file specified by the given header and write it to the\n\t * supplied output stream\n\t * \n\t * @param hd\n\t *            the header to be extracted\n\t * @param os\n\t *            the outputstream\n\t * @throws RarException\n\t */\n\tpublic void extractFile(FileHeader hd, OutputStream os) throws RarException {\n\t\tif (!headers.contains(hd)) {\n\t\t\tthrow new RarException(RarExceptionType.headerNotInArchive);\n\t\t}\n\t\ttry {\n\t\t\tdoExtractFile(hd, os);\n\t\t} catch (Exception e) {\n\t\t\tif (e instanceof RarException) {\n\t\t\t\tthrow (RarException) e;\n\t\t\t} else {\n\t\t\t\tthrow new RarException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns an {@link InputStream} that will allow to read the file and\n\t * stream it. Please note that this method will create a new Thread and an a\n\t * pair of Pipe streams.\n\t * \n\t * @param hd\n\t *            the header to be extracted\n\t * @throws RarException\n\t * @throws IOException\n\t *             if any IO error occur\n\t */\n\tpublic InputStream getInputStream(final FileHeader hd) throws RarException,\n\t\t\tIOException {\n\t\tfinal PipedInputStream in = new PipedInputStream(32 * 1024);\n\t\tfinal PipedOutputStream out = new PipedOutputStream(in);\n\n\t\t// creates a new thread that will write data to the pipe. Data will be\n\t\t// available in another InputStream, connected to the OutputStream.\n\t\tnew Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\textractFile(hd, out);\n\t\t\t\t} catch (RarException e) {\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}).start();\n\n\t\treturn in;\n\t}\n\n\tprivate void doExtractFile(FileHeader hd, OutputStream os)\n\t\t\tthrows RarException, IOException {\n\t\tdataIO.init(os);\n\t\tdataIO.init(hd);\n\t\tdataIO.setUnpFileCRC(this.isOldFormat() ? 0 : 0xffFFffFF);\n\t\tif (unpack == null) {\n\t\t\tunpack = new Unpack(dataIO);\n\t\t}\n\t\tif (!hd.isSolid()) {\n\t\t\tunpack.init(null);\n\t\t}\n\t\tunpack.setDestSize(hd.getFullUnpackSize());\n\t\ttry {\n\t\t\tunpack.doUnpack(hd.getUnpVersion(), hd.isSolid());\n\t\t\t// Verify file CRC\n\t\t\thd = dataIO.getSubHeader();\n\t\t\tlong actualCRC = hd.isSplitAfter() ? ~dataIO.getPackedCRC()\n\t\t\t\t\t: ~dataIO.getUnpFileCRC();\n\t\t\tint expectedCRC = hd.getFileCRC();\n\t\t\tif (actualCRC != expectedCRC) {\n\t\t\t\tthrow new RarException(RarExceptionType.crcError);\n\t\t\t}\n\t\t\t// if (!hd.isSplitAfter()) {\n\t\t\t// // Verify file CRC\n\t\t\t// if(~dataIO.getUnpFileCRC() != hd.getFileCRC()){\n\t\t\t// throw new RarException(RarExceptionType.crcError);\n\t\t\t// }\n\t\t\t// }\n\t\t} catch (Exception e) {\n\t\t\tunpack.cleanUp();\n\t\t\tif (e instanceof RarException) {\n\t\t\t\t// throw new RarException((RarException)e);\n\t\t\t\tthrow (RarException) e;\n\t\t\t} else {\n\t\t\t\tthrow new RarException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return returns the main header of this archive\n\t */\n\tpublic MainHeader getMainHeader() {\n\t\treturn newMhd;\n\t}\n\n\t/**\n\t * @return whether the archive is old format\n\t */\n\tpublic boolean isOldFormat() {\n\t\treturn markHead.isOldFormat();\n\t}\n\n\t/** Close the underlying compressed file. */\n\tpublic void close() throws IOException {\n\t\tif (rof != null) {\n\t\t\trof.close();\n\t\t\trof = null;\n\t\t}\n\t\tif (unpack != null) {\n\t\t\tunpack.cleanUp();\n\t\t}\n\t}\n\n\t/**\n\t * @return the volumeManager\n\t */\n\tpublic VolumeManager getVolumeManager() {\n\t\treturn volumeManager;\n\t}\n\n\t/**\n\t * @param volumeManager\n\t *            the volumeManager to set\n\t */\n\tpublic void setVolumeManager(VolumeManager volumeManager) {\n\t\tthis.volumeManager = volumeManager;\n\t}\n\n\t/**\n\t * @return the volume\n\t */\n\tpublic Volume getVolume() {\n\t\treturn volume;\n\t}\n\n\t/**\n\t * @param volume\n\t *            the volume to set\n\t * @throws IOException\n\t */\n\tpublic void setVolume(Volume volume) throws IOException {\n\t\tthis.volume = volume;\n\t\tsetFile(volume.getReadOnlyAccess(), volume.getLength());\n\t}\n}\n", "target": 1}
{"idx": 908, "func": "package jenkins.security;\n\nimport hudson.Extension;\nimport hudson.init.InitMilestone;\nimport hudson.init.Initializer;\nimport hudson.model.TaskListener;\nimport hudson.util.HttpResponses;\nimport hudson.util.SecretRewriter;\nimport hudson.util.VersionNumber;\nimport jenkins.management.AsynchronousAdministrativeMonitor;\nimport jenkins.model.Jenkins;\nimport jenkins.util.io.FileBoolean;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.StaplerProxy;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.security.GeneralSecurityException;\nimport java.util.Date;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Warns the administrator to run {@link SecretRewriter}\n *\n * @author Kohsuke Kawaguchi\n */\n@Extension\npublic class RekeySecretAdminMonitor extends AsynchronousAdministrativeMonitor implements StaplerProxy {\n\n    /**\n     * Whether we detected a need to run the rewrite program.\n     * Once we set it to true, we'll never turn it off.\n     *\n     * If the admin decides to dismiss this warning, we use {@link #isEnabled()} for that.\n     *\n     * In this way we can correctly differentiate all the different states.\n     */\n    private final FileBoolean needed = state(\"needed\");\n\n    /**\n     * If the scanning process has run to the completion, we set to this true.\n     */\n    private final FileBoolean done = state(\"done\");\n\n    /**\n     * If the rewrite process is scheduled upon the next boot.\n     */\n    private final FileBoolean scanOnBoot = state(\"scanOnBoot\");\n\n    public RekeySecretAdminMonitor() throws IOException {\n        // if JENKINS_HOME existed <1.497, we need to offer rewrite\n        // this computation needs to be done and the value be captured,\n        // since $JENKINS_HOME/config.xml can be saved later before the user has\n        // actually rewritten XML files.\n        Jenkins j = Jenkins.getInstance();\n        if (j.isUpgradedFromBefore(new VersionNumber(\"1.496.*\"))\n        &&  new FileBoolean(new File(j.getRootDir(),\"secret.key.not-so-secret\")).isOff())\n            needed.on();\n    }\n\n    /**\n     * Requires ADMINISTER permission for any operation in here.\n     */\n    public Object getTarget() {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n        return this;\n    }\n\n    @Override\n    public boolean isActivated() {\n        return needed.isOn();\n    }\n\n    /**\n     * Indicates that the re-keying has run to the completion.\n     */\n    public boolean isDone() {\n        return done.isOn();\n    }\n\n    public void setNeeded() {\n        needed.on();\n    }\n\n    public boolean isScanOnBoot() {\n        return scanOnBoot.isOn();\n    }\n\n    @RequirePOST\n    public HttpResponse doScan(StaplerRequest req) throws IOException, GeneralSecurityException {\n        if(req.hasParameter(\"background\")) {\n            start(false);\n        } else\n        if(req.hasParameter(\"schedule\")) {\n            scanOnBoot.on();\n        } else\n        if(req.hasParameter(\"dismiss\")) {\n            disable(true);\n        } else\n            throw HttpResponses.error(400,\"Invalid request submission: \" + req.getParameterMap());\n\n        return HttpResponses.redirectViaContextPath(\"/manage\");\n    }\n\n\n    private FileBoolean state(String name) {\n        return new FileBoolean(new File(getBaseDir(),name));\n    }\n\n    @Initializer(fatal=false,after=InitMilestone.PLUGINS_STARTED,before=InitMilestone.EXTENSIONS_AUGMENTED)\n    // as early as possible, but this needs to be late enough that the ConfidentialStore is available\n    public static void scanOnReboot() throws InterruptedException, IOException, GeneralSecurityException {\n        RekeySecretAdminMonitor m = new RekeySecretAdminMonitor();  // throw-away instance\n\n        FileBoolean flag = m.scanOnBoot;\n        if (flag.isOn()) {\n            flag.off();\n            m.start(false).join();\n            // block the boot until the rewrite process is complete\n            // don't let the failure in RekeyThread block Jenkins boot.\n        }\n    }\n\n    @Override\n    public String getDisplayName() {\n        return Messages.RekeySecretAdminMonitor_DisplayName();\n    }\n\n    /**\n     * Rewrite log file.\n     */\n    @Override\n    protected File getLogFile() {\n        return new File(getBaseDir(),\"rekey.log\");\n    }\n\n    @Override\n    protected void fix(TaskListener listener) throws Exception {\n        LOGGER.info(\"Initiating a re-keying of secrets. See \"+getLogFile());\n\n        SecretRewriter rewriter = new SecretRewriter(new File(getBaseDir(),\"backups\"));\n\n        try {\n            PrintStream log = listener.getLogger();\n            log.println(\"Started re-keying \" + new Date());\n            int count = rewriter.rewriteRecursive(Jenkins.getInstance().getRootDir(), listener);\n            log.printf(\"Completed re-keying %d files on %s\\n\",count,new Date());\n            new RekeySecretAdminMonitor().done.on();\n            LOGGER.info(\"Secret re-keying completed\");\n        } catch (Exception e) {\n            LOGGER.log(Level.SEVERE, \"Fatal failure in re-keying secrets\",e);\n            e.printStackTrace(listener.error(\"Fatal failure in rewriting secrets\"));\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(RekeySecretAdminMonitor.class.getName());\n\n}\n", "target": 1}
{"idx": 909, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.security.GeneralSecurityException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\nimport java.util.logging.Level;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.TestAuthorization.AuthzStatefulService.AuthzState;\nimport com.vmware.xenon.common.test.AuthorizationHelper;\nimport com.vmware.xenon.common.test.QueryTestUtils;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.TestRequestSender.FailureResponse;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.AuthorizationCacheUtils;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.GuestUserService;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Builder;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.RoleService;\nimport com.vmware.xenon.services.common.RoleService.Policy;\nimport com.vmware.xenon.services.common.RoleService.RoleState;\nimport com.vmware.xenon.services.common.SystemUserService;\nimport com.vmware.xenon.services.common.UserGroupService;\nimport com.vmware.xenon.services.common.UserGroupService.UserGroupState;\nimport com.vmware.xenon.services.common.UserService.UserState;\n\npublic class TestAuthorization extends BasicTestCase {\n\n    public static class AuthzStatelessService extends StatelessService {\n        @Override\n        public void handleRequest(Operation op) {\n            if (op.getAction() == Action.PATCH) {\n                op.complete();\n                return;\n            }\n            super.handleRequest(op);\n        }\n    }\n\n    public static class AuthzStatefulService extends StatefulService {\n\n        public static class AuthzState extends ServiceDocument {\n            public String userLink;\n        }\n\n        public AuthzStatefulService() {\n            super(AuthzState.class);\n        }\n\n        @Override\n        public void handleStart(Operation post) {\n            AuthzState body = post.getBody(AuthzState.class);\n            AuthorizationContext authorizationContext = getAuthorizationContextForSubject(\n                    body.userLink);\n\n            if (authorizationContext == null ||\n                    !authorizationContext.getClaims().getSubject().equals(body.userLink)) {\n                post.fail(Operation.STATUS_CODE_INTERNAL_ERROR);\n                return;\n            }\n            post.complete();\n        }\n    }\n\n    public int serviceCount = 10;\n\n    private String userServicePath;\n    private AuthorizationHelper authHelper;\n\n    @Override\n    public void beforeHostStart(VerificationHost host) {\n        // Enable authorization service; this is an end to end test\n        host.setAuthorizationService(new AuthorizationContextService());\n        host.setAuthorizationEnabled(true);\n        CommandLineArgumentParser.parseFromProperties(this);\n    }\n\n    @Before\n    public void enableTracing() throws Throwable {\n        // Enable operation tracing to verify tracing does not error out with auth enabled.\n        this.host.toggleOperationTracing(this.host.getUri(), true);\n    }\n\n    @After\n    public void disableTracing() throws Throwable {\n        this.host.toggleOperationTracing(this.host.getUri(), false);\n    }\n\n    @Before\n    public void setupRoles() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        this.authHelper = new AuthorizationHelper(this.host);\n        this.userServicePath = this.authHelper.createUserService(this.host, \"jane@doe.com\");\n        this.authHelper.createRoles(this.host, \"jane@doe.com\");\n        this.host.resetAuthorizationContext();\n    }\n\n    @Test\n    public void factoryGetWithOData() {\n        // GET with ODATA will be implicitly converted to a query task. Query tasks\n        // require explicit authorization for the principal to be able to create them\n        URI exampleFactoryUriWithOData = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK,\n                \"$limit=10\");\n        TestRequestSender sender = this.host.getTestRequestSender();\n        FailureResponse rsp = sender.sendAndWaitFailure(Operation.createGet(exampleFactoryUriWithOData));\n        ServiceErrorResponse errorRsp = rsp.op.getErrorResponseBody();\n        assertTrue(errorRsp.message.toLowerCase().contains(\"forbidden\"));\n        assertTrue(errorRsp.message.contains(UriUtils.URI_PARAM_ODATA_TENANTLINKS));\n\n        exampleFactoryUriWithOData = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK,\n                \"$filter=name eq someone\");\n        rsp = sender.sendAndWaitFailure(Operation.createGet(exampleFactoryUriWithOData));\n        errorRsp = rsp.op.getErrorResponseBody();\n        assertTrue(errorRsp.message.toLowerCase().contains(\"forbidden\"));\n        assertTrue(errorRsp.message.contains(UriUtils.URI_PARAM_ODATA_TENANTLINKS));\n\n        // GET without ODATA should succeed but return empty result set\n        URI exampleFactoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Operation rspOp = sender.sendAndWait(Operation.createGet(exampleFactoryUri));\n        ServiceDocumentQueryResult queryRsp = rspOp.getBody(ServiceDocumentQueryResult.class);\n        assertEquals(0L, (long) queryRsp.documentCount);\n    }\n\n    @Test\n    public void statelessServiceAuthorization() throws Throwable {\n        // assume system identity so we can create roles\n        this.host.setSystemAuthorizationContext();\n\n        String serviceLink = UUID.randomUUID().toString();\n\n        // create a specific role for a stateless service\n        String resourceGroupLink = this.authHelper.createResourceGroup(this.host,\n                \"stateless-service-group\", Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                UriUtils.URI_PATH_CHAR + serviceLink)\n                        .build());\n        this.authHelper.createRole(this.host, this.authHelper.getUserGroupLink(),\n                resourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH, Action.DELETE)));\n        this.host.resetAuthorizationContext();\n\n        CompletionHandler ch = (o, e) -> {\n            if (e == null || o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                this.host.failIteration(new IllegalStateException(\n                        \"Operation did not fail with proper status code\"));\n                return;\n            }\n            this.host.completeIteration();\n        };\n\n        // assume authorized user identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // Verify startService\n        Operation post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        // do not supply a body, authorization should still be applied\n        this.host.testStart(1);\n        post.setCompletion(this.host.getCompletion());\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // stop service so we can attempt restart\n        this.host.testStart(1);\n        Operation delete = Operation.createDelete(post.getUri())\n                .setCompletion(this.host.getCompletion());\n        this.host.send(delete);\n        this.host.testWait();\n\n        // Verify DENY startService\n        this.host.resetAuthorizationContext();\n        this.host.testStart(1);\n        post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        post.setCompletion(ch);\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // assume authorized user identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // restart service\n        post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        // do not supply a body, authorization should still be applied\n        this.host.testStart(1);\n        post.setCompletion(this.host.getCompletion());\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // Verify PATCH\n        Operation patch = Operation.createPatch(UriUtils.buildUri(this.host, serviceLink));\n        patch.setBody(new ServiceDocument());\n        this.host.testStart(1);\n        patch.setCompletion(this.host.getCompletion());\n        this.host.send(patch);\n        this.host.testWait();\n\n        // Verify DENY PATCH\n        this.host.resetAuthorizationContext();\n        patch = Operation.createPatch(UriUtils.buildUri(this.host, serviceLink));\n        patch.setBody(new ServiceDocument());\n        this.host.testStart(1);\n        patch.setCompletion(ch);\n        this.host.send(patch);\n        this.host.testWait();\n    }\n\n    @Test\n    public void queryTasksDirectAndContinuous() throws Throwable {\n        this.host.assumeIdentity(this.userServicePath);\n        createExampleServices(\"jane\");\n\n        // do a direct, simple query first\n        this.host.createAndWaitSimpleDirectQuery(ServiceDocument.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                this.userServicePath, this.serviceCount, this.serviceCount);\n\n        // now do a paginated query to verify we can get to paged results with authz enabled\n        QueryTask qt = QueryTask.Builder.create().setResultLimit(this.serviceCount / 2)\n                .build();\n        qt.querySpec.query = Query.Builder.create()\n                .addFieldClause(ServiceDocument.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                        this.userServicePath)\n                .build();\n\n        URI taskUri = this.host.createQueryTaskService(qt);\n        this.host.waitFor(\"task not finished in time\", () -> {\n            QueryTask r = this.host.getServiceState(null, QueryTask.class, taskUri);\n            if (TaskState.isFailed(r.taskInfo)) {\n                throw new IllegalStateException(\"task failed\");\n            }\n            if (TaskState.isFinished(r.taskInfo)) {\n                qt.taskInfo = r.taskInfo;\n                qt.results = r.results;\n                return true;\n            }\n            return false;\n        });\n\n\n        TestContext ctx = this.host.testCreate(1);\n        Operation get = Operation.createGet(UriUtils.buildUri(this.host, qt.results.nextPageLink))\n                .setCompletion(ctx.getCompletion());\n        this.host.send(get);\n        ctx.await();\n\n        TestContext kryoCtx = this.host.testCreate(1);\n        Operation patchOp = Operation.createPatch(this.host, ExampleService.FACTORY_LINK + \"/foo\")\n                .setBody(new ServiceDocument())\n                .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                .setCompletion((o, e) -> {\n                    if (e != null && o.getStatusCode() == Operation.STATUS_CODE_UNAUTHORIZED) {\n                        kryoCtx.completeIteration();\n                        return;\n                    }\n                    kryoCtx.failIteration(new IllegalStateException(\"expected a failure\"));\n                });\n        this.host.send(patchOp);\n        kryoCtx.await();\n\n        int requestCount = this.serviceCount;\n        TestContext notifyCtx = this.testCreate(requestCount);\n\n        // Verify that even though updates to the index are performed\n        // as a system user; the notification received by the subscriber of\n        // the continuous query has the same authorization context as that of\n        // user that created the continuous query.\n        Consumer<Operation> notify = (o) -> {\n            o.complete();\n            String subject = o.getAuthorizationContext().getClaims().getSubject();\n            if (!this.userServicePath.equals(subject)) {\n                notifyCtx.fail(new IllegalStateException(\n                        \"Invalid auth subject in notification: \" + subject));\n                return;\n            }\n            this.host.log(\"Received authorized notification for index patch: %s\", o.toString());\n            notifyCtx.complete();\n        };\n\n        Query q = Query.Builder.create()\n                .addKindFieldClause(ExampleServiceState.class)\n                .build();\n        QueryTask cqt = QueryTask.Builder.create().setQuery(q).build();\n\n        // Create and subscribe to the continous query as an ordinary user.\n        // do a continuous query, verify we receive some notifications\n        URI notifyURI = QueryTestUtils.startAndSubscribeToContinuousQuery(\n                this.host.getTestRequestSender(), this.host, cqt,\n                notify);\n\n        // issue updates, create some services as the system user\n        this.host.setSystemAuthorizationContext();\n        createExampleServices(\"jane\");\n        this.host.log(\"Waiting on continiuous query task notifications (%d)\", requestCount);\n        notifyCtx.await();\n        this.host.resetSystemAuthorizationContext();\n\n        this.host.assumeIdentity(this.userServicePath);\n        QueryTestUtils.stopContinuousQuerySubscription(\n                this.host.getTestRequestSender(), this.host, notifyURI,\n                cqt);\n\n    }\n\n    @Test\n    public void validateKryoOctetStreamRequests() throws Throwable {\n        Consumer<Boolean> validate = (expectUnauthorizedResponse) -> {\n            TestContext kryoCtx = this.host.testCreate(1);\n            Operation patchOp = Operation.createPatch(this.host, ExampleService.FACTORY_LINK + \"/foo\")\n                    .setBody(new ServiceDocument())\n                    .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                    .setCompletion((o, e) -> {\n                        boolean isUnauthorizedResponse = o.getStatusCode() == Operation.STATUS_CODE_UNAUTHORIZED;\n                        if (expectUnauthorizedResponse == isUnauthorizedResponse) {\n                            kryoCtx.completeIteration();\n                            return;\n                        }\n                        kryoCtx.failIteration(new IllegalStateException(\"Response did not match expectation\"));\n                    });\n            this.host.send(patchOp);\n            kryoCtx.await();\n        };\n\n        // Validate GUEST users are not authorized for sending kryo-octet-stream requests.\n        this.host.resetAuthorizationContext();\n        validate.accept(true);\n\n        // Validate non-Guest, non-System users are also not authorized.\n        this.host.assumeIdentity(this.userServicePath);\n        validate.accept(true);\n\n        // Validate System users are allowed.\n        this.host.assumeIdentity(SystemUserService.SELF_LINK);\n        validate.accept(false);\n    }\n\n    @Test\n    public void contextPropagationOnScheduleAndRunContext() throws Throwable {\n        this.host.assumeIdentity(this.userServicePath);\n\n        AuthorizationContext callerAuthContext = OperationContext.getAuthorizationContext();\n        Runnable task = () -> {\n            if (OperationContext.getAuthorizationContext().equals(callerAuthContext)) {\n                this.host.completeIteration();\n                return;\n            }\n            this.host.failIteration(new IllegalStateException(\"Incorrect auth context obtained\"));\n        };\n\n        this.host.testStart(1);\n        this.host.schedule(task, 1, TimeUnit.MILLISECONDS);\n        this.host.testWait();\n\n        this.host.testStart(1);\n        this.host.run(task);\n        this.host.testWait();\n    }\n\n    @Test\n    public void guestAuthorization() throws Throwable {\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n\n        // Create user group for guest user\n        String userGroupLink =\n                this.authHelper.createUserGroup(this.host, \"guest-user-group\", Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                GuestUserService.SELF_LINK)\n                        .build());\n\n        // Create resource group for example service state\n        String exampleServiceResourceGroupLink =\n                this.authHelper.createResourceGroup(this.host, \"guest-resource-group\", Builder.create()\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_KIND,\n                                Utils.buildKind(ExampleServiceState.class))\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_NAME,\n                                \"guest\")\n                        .build());\n\n        // Create roles tying these together\n        this.authHelper.createRole(this.host, userGroupLink, exampleServiceResourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH)));\n\n        // Create some example services; some accessible, some not\n        Map<URI, ExampleServiceState> exampleServices = new HashMap<>();\n        exampleServices.putAll(createExampleServices(\"jane\"));\n        exampleServices.putAll(createExampleServices(\"guest\"));\n\n        OperationContext.setAuthorizationContext(null);\n\n        TestRequestSender sender = this.host.getTestRequestSender();\n        Operation responseOp = sender.sendAndWait(Operation.createGet(this.host, ExampleService.FACTORY_LINK));\n\n        // Make sure only the authorized services were returned\n        ServiceDocumentQueryResult getResult = responseOp.getBody(ServiceDocumentQueryResult.class);\n        assertAuthorizedServicesInResult(\"guest\", exampleServices, getResult);\n        String guestLink = getResult.documentLinks.iterator().next();\n\n        // Make sure we are able to PATCH the example service.\n        ExampleServiceState state = new ExampleServiceState();\n        state.counter = 2L;\n        responseOp = sender.sendAndWait(Operation.createPatch(this.host, guestLink).setBody(state));\n        assertEquals(Operation.STATUS_CODE_OK, responseOp.getStatusCode());\n\n        // Let's try to do another PATCH using kryo-octet-stream\n        state.counter = 3L;\n        FailureResponse failureResponse = sender.sendAndWaitFailure(\n                Operation.createPatch(this.host, guestLink)\n                        .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                        .setBody(state));\n        assertEquals(Operation.STATUS_CODE_UNAUTHORIZED, failureResponse.op.getStatusCode());\n\n    }\n\n    @Test\n    public void testInvalidUserAndResourceGroup() throws Throwable {\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        AuthorizationHelper authsetupHelper = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String userLink = authsetupHelper.createUserService(this.host, email);\n        Query userGroupQuery = Query.Builder.create().addFieldClause(UserState.FIELD_NAME_EMAIL, email).build();\n        String userGroupLink = authsetupHelper.createUserGroup(this.host, email, userGroupQuery);\n        authsetupHelper.createRole(this.host, userGroupLink, \"foo\", EnumSet.allOf(Action.class));\n        // Assume identity\n        this.host.assumeIdentity(userLink);\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n        // set an invalid userGroupLink for the user\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        UserState patchUserState = new UserState();\n        patchUserState.userGroupLinks = Collections.singleton(\"foo\");\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPatch(UriUtils.buildUri(this.host, userLink)).setBody(patchUserState));\n        this.host.assumeIdentity(userLink);\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n    }\n\n    @Test\n    public void actionBasedAuthorization() throws Throwable {\n\n        // Assume Jane's identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // add docs accessible by jane\n        Map<URI, ExampleServiceState> exampleServices = createExampleServices(\"jane\");\n\n        // Execute get on factory trying to get all example services\n        final ServiceDocumentQueryResult[] factoryGetResult = new ServiceDocumentQueryResult[1];\n        Operation getFactory = Operation.createGet(\n                UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(e);\n                        return;\n                    }\n\n                    factoryGetResult[0] = o.getBody(ServiceDocumentQueryResult.class);\n                    this.host.completeIteration();\n                });\n\n        this.host.testStart(1);\n        this.host.send(getFactory);\n        this.host.testWait();\n\n        // DELETE operation should be denied\n        Set<String> selfLinks = new HashSet<>(factoryGetResult[0].documentLinks);\n        for (String selfLink : selfLinks) {\n            Operation deleteOperation =\n                    Operation.createDelete(UriUtils.buildUri(this.host, selfLink))\n                            .setCompletion((o, e) -> {\n                                if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                    String message = String.format(\"Expected %d, got %s\",\n                                            Operation.STATUS_CODE_FORBIDDEN,\n                                            o.getStatusCode());\n                                    this.host.failIteration(new IllegalStateException(message));\n                                    return;\n                                }\n\n                                this.host.completeIteration();\n                            });\n            this.host.testStart(1);\n            this.host.send(deleteOperation);\n            this.host.testWait();\n        }\n\n        // PATCH operation should be allowed\n        for (String selfLink : selfLinks) {\n            Operation patchOperation =\n                    Operation.createPatch(UriUtils.buildUri(this.host, selfLink))\n                        .setBody(exampleServices.get(selfLink))\n                        .setCompletion((o, e) -> {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_OK) {\n                                String message = String.format(\"Expected %d, got %s\",\n                                        Operation.STATUS_CODE_OK,\n                                        o.getStatusCode());\n                                this.host.failIteration(new IllegalStateException(message));\n                                return;\n                            }\n\n                            this.host.completeIteration();\n                        });\n            this.host.testStart(1);\n            this.host.send(patchOperation);\n            this.host.testWait();\n        }\n    }\n\n    @Test\n    public void testAllowAndDenyRoles() throws Exception {\n        // 1) Create example services state as the system user\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        ExampleServiceState state = createExampleServiceState(\"testExampleOK\", 1L);\n\n        Operation response = this.host.waitForResponse(\n                Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                        .setBody(state));\n        assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        state = response.getBody(ExampleServiceState.class);\n\n        // 2) verify Jane cannot POST or GET\n        assertAccess(Policy.DENY);\n\n        // 3) build ALLOW role and verify access\n        buildRole(\"AllowRole\", Policy.ALLOW);\n        assertAccess(Policy.ALLOW);\n\n        // 4) build DENY role and verify access\n        buildRole(\"DenyRole\", Policy.DENY);\n        assertAccess(Policy.DENY);\n\n        // 5) build another ALLOW role and verify access\n        buildRole(\"AnotherAllowRole\", Policy.ALLOW);\n        assertAccess(Policy.DENY);\n\n        // 6) delete deny role and verify access\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        response = this.host.waitForResponse(Operation.createDelete(\n                UriUtils.buildUri(this.host,\n                        UriUtils.buildUriPath(RoleService.FACTORY_LINK, \"DenyRole\"))));\n        assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        assertAccess(Policy.ALLOW);\n    }\n\n    private void buildRole(String roleName, Policy policy) {\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        TestContext ctx = this.host.testCreate(1);\n        AuthorizationSetupHelper.create().setHost(this.host)\n                .setRoleName(roleName)\n                .setUserGroupQuery(Query.Builder.create()\n                        .addCollectionItemClause(UserState.FIELD_NAME_EMAIL, \"jane@doe.com\")\n                        .build())\n                .setResourceQuery(Query.Builder.create()\n                        .addFieldClause(ServiceDocument.FIELD_NAME_SELF_LINK,\n                                ExampleService.FACTORY_LINK,\n                                MatchType.PREFIX)\n                        .build())\n                .setVerbs(EnumSet.of(Action.POST, Action.PUT, Action.PATCH, Action.GET,\n                        Action.DELETE))\n                .setPolicy(policy)\n                .setCompletion((authEx) -> {\n                    if (authEx != null) {\n                        ctx.failIteration(authEx);\n                        return;\n                    }\n                    ctx.completeIteration();\n                }).setupRole();\n        this.host.testWait(ctx);\n    }\n\n    private void assertAccess(Policy policy) throws Exception {\n        this.host.assumeIdentity(this.userServicePath);\n        Operation response = this.host.waitForResponse(\n                Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                        .setBody(createExampleServiceState(\"testExampleDeny\", 2L)));\n        if (policy == Policy.DENY) {\n            assertEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n        } else {\n            assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        }\n\n        response = this.host.waitForResponse(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n        assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        ServiceDocumentQueryResult result = response.getBody(ServiceDocumentQueryResult.class);\n        if (policy == Policy.DENY) {\n            assertEquals(Long.valueOf(0L), result.documentCount);\n        } else {\n            assertNotNull(result.documentCount);\n            assertNotEquals(Long.valueOf(0L), result.documentCount);\n        }\n    }\n\n    @Test\n    public void statefulServiceAuthorization() throws Throwable {\n        // Create example services not accessible by jane (as the system user)\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        Map<URI, ExampleServiceState> exampleServices = createExampleServices(\"john\");\n\n        // try to create services with no user context set; we should get a 403\n        OperationContext.setAuthorizationContext(null);\n        ExampleServiceState state = createExampleServiceState(\"jane\", new Long(\"100\"));\n        TestContext ctx1 = this.host.testCreate(1);\n        this.host.send(\n                Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                        .setBody(state)\n                        .setCompletion((o, e) -> {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                String message = String.format(\"Expected %d, got %s\",\n                                        Operation.STATUS_CODE_FORBIDDEN,\n                                        o.getStatusCode());\n                                ctx1.failIteration(new IllegalStateException(message));\n                                return;\n                            }\n\n                            ctx1.completeIteration();\n                        }));\n        this.host.testWait(ctx1);\n\n        // issue a GET on a factory with no auth context, no documents should be returned\n        TestContext ctx2 = this.host.testCreate(1);\n        this.host.send(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx2.failIteration(new IllegalStateException(e));\n                        return;\n                    }\n                    ServiceDocumentQueryResult res = o\n                            .getBody(ServiceDocumentQueryResult.class);\n                    if (!res.documentLinks.isEmpty()) {\n                        String message = String.format(\"Expected 0 results; Got %d\",\n                                res.documentLinks.size());\n                        ctx2.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n\n                    ctx2.completeIteration();\n                }));\n        this.host.testWait(ctx2);\n\n        // do GET on factory /stats, we should get 403\n        Operation statsGet = Operation.createGet(this.host,\n                ExampleService.FACTORY_LINK + ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        this.host.sendAndWaitExpectFailure(statsGet, Operation.STATUS_CODE_FORBIDDEN);\n\n        // do GET on factory /config, we should get 403\n        Operation configGet = Operation.createGet(this.host,\n                ExampleService.FACTORY_LINK + ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n        this.host.sendAndWaitExpectFailure(configGet, Operation.STATUS_CODE_FORBIDDEN);\n\n        // Assume Jane's identity\n        this.host.assumeIdentity(this.userServicePath);\n        // add docs accessible by jane\n        exampleServices.putAll(createExampleServices(\"jane\"));\n\n        verifyJaneAccess(exampleServices, null);\n\n        // Execute get on factory trying to get all example services\n        TestContext ctx3 = this.host.testCreate(1);\n        final ServiceDocumentQueryResult[] factoryGetResult = new ServiceDocumentQueryResult[1];\n        Operation getFactory = Operation.createGet(\n                UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx3.failIteration(e);\n                        return;\n                    }\n\n                    factoryGetResult[0] = o.getBody(ServiceDocumentQueryResult.class);\n                    ctx3.completeIteration();\n                });\n        this.host.send(getFactory);\n        this.host.testWait(ctx3);\n\n        // Make sure only the authorized services were returned\n        assertAuthorizedServicesInResult(\"jane\", exampleServices, factoryGetResult[0]);\n\n        // Execute query task trying to get all example services\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND)\n                .setTermMatchValue(Utils.buildKind(ExampleServiceState.class));\n        URI u = this.host.createQueryTaskService(QueryTask.create(q));\n        QueryTask task = this.host.waitForQueryTaskCompletion(q, 1, 1, u, false, true, false);\n        assertEquals(TaskState.TaskStage.FINISHED, task.taskInfo.stage);\n\n        // Make sure only the authorized services were returned\n        assertAuthorizedServicesInResult(\"jane\", exampleServices, task.results);\n\n        // reset the auth context\n        OperationContext.setAuthorizationContext(null);\n\n        // do GET on utility suffixes in example child services, we should get 403\n        for (URI childUri : exampleServices.keySet()) {\n            statsGet = Operation.createGet(this.host,\n                    childUri.getPath() + ServiceHost.SERVICE_URI_SUFFIX_STATS);\n            this.host.sendAndWaitExpectFailure(statsGet, Operation.STATUS_CODE_FORBIDDEN);\n            configGet = Operation.createGet(this.host,\n                    childUri.getPath() + ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n            this.host.sendAndWaitExpectFailure(configGet, Operation.STATUS_CODE_FORBIDDEN);\n        }\n\n        // Assume Jane's identity through header auth token\n        String authToken = generateAuthToken(this.userServicePath);\n\n        // do GET on utility suffixes in example child services, we should get 200\n        for (URI childUri : exampleServices.keySet()) {\n            statsGet = Operation.createGet(this.host,\n                    childUri.getPath() + ServiceHost.SERVICE_URI_SUFFIX_STATS);\n            statsGet.addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken);\n            this.host.sendAndWaitExpectSuccess(statsGet);\n        }\n\n        verifyJaneAccess(exampleServices, authToken);\n\n        // test user impersonation\n        this.host.setSystemAuthorizationContext();\n        AuthzStatefulService s = new AuthzStatefulService();\n        this.host.addPrivilegedService(AuthzStatefulService.class);\n\n        AuthzState body = new AuthzState();\n        body.userLink = this.userServicePath;\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), body);\n        this.host.resetSystemAuthorizationContext();\n    }\n\n    private AuthorizationContext assumeIdentityAndGetContext(String userLink,\n            Service privilegedService, boolean populateCache) throws Throwable {\n        AuthorizationContext authContext = this.host.assumeIdentity(userLink);\n        if (populateCache) {\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n        }\n        return this.host.getAuthorizationContext(privilegedService, authContext.getToken());\n    }\n\n    @Test\n    public void authCacheClearToken() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        AuthorizationHelper authHelperForFoo = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String fooUserLink = authHelperForFoo.createUserService(this.host, email);\n        // spin up a privileged service to query for auth context\n        MinimalTestService s = new MinimalTestService();\n        this.host.addPrivilegedService(MinimalTestService.class);\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n        this.host.resetSystemAuthorizationContext();\n\n        AuthorizationContext authContext1 = assumeIdentityAndGetContext(fooUserLink, s, true);\n        AuthorizationContext authContext2 = assumeIdentityAndGetContext(fooUserLink, s, true);\n        assertNotNull(authContext1);\n        assertNotNull(authContext2);\n\n        this.host.setSystemAuthorizationContext();\n        Operation clearAuthOp = new Operation();\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, fooUserLink));\n        TestContext ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUser(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n\n        assertNull(this.host.getAuthorizationContext(s, authContext1.getToken()));\n        assertNull(this.host.getAuthorizationContext(s, authContext2.getToken()));\n    }\n\n    @Test\n    public void updateAuthzCache() throws Throwable {\n        ExecutorService executor = null;\n        try {\n            this.host.setSystemAuthorizationContext();\n            AuthorizationHelper authsetupHelper = new AuthorizationHelper(this.host);\n            String email = \"foo@foo.com\";\n            String userLink = authsetupHelper.createUserService(this.host, email);\n            Query userGroupQuery = Query.Builder.create().addFieldClause(UserState.FIELD_NAME_EMAIL, email).build();\n            String userGroupLink = authsetupHelper.createUserGroup(this.host, email, userGroupQuery);\n            UserState patchState = new UserState();\n            patchState.userGroupLinks = Collections.singleton(userGroupLink);\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createPatch(UriUtils.buildUri(this.host, userLink))\n                    .setBody(patchState));\n            TestContext ctx = this.host.testCreate(this.serviceCount);\n            Service s = this.host.startServiceAndWait(MinimalTestService.class, UUID.randomUUID()\n                    .toString());\n            executor = this.host.allocateExecutor(s);\n            this.host.resetSystemAuthorizationContext();\n            for (int i = 0; i < this.serviceCount; i++) {\n                this.host.run(executor, () -> {\n                    String serviceName = UUID.randomUUID().toString();\n                    try {\n                        this.host.setSystemAuthorizationContext();\n                        Query resourceQuery = Query.Builder.create().addFieldClause(ExampleServiceState.FIELD_NAME_NAME,\n                                serviceName).build();\n                        String resourceGroupLink = authsetupHelper.createResourceGroup(this.host, serviceName, resourceQuery);\n                        authsetupHelper.createRole(this.host, userGroupLink, resourceGroupLink, EnumSet.allOf(Action.class));\n                        this.host.resetSystemAuthorizationContext();\n                        this.host.assumeIdentity(userLink);\n                        ExampleServiceState exampleState = new ExampleServiceState();\n                        exampleState.name = serviceName;\n                        exampleState.documentSelfLink = serviceName;\n                        // Issue: https://www.pivotaltracker.com/story/show/131520613\n                        // We have a potential race condition in the code where the role\n                        // created above is not being reflected in the auth context for\n                        // the user; We are retrying the operation to mitigate the issue\n                        // till we have a fix for the issue\n                        for (int retryCounter = 0; retryCounter < 3; retryCounter++) {\n                            try {\n                                this.host.sendAndWaitExpectSuccess(\n                                        Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                                        .setBody(exampleState));\n                                break;\n                            } catch (Throwable t) {\n                                this.host.log(Level.WARNING, \"Error creating example service: \" + t.getMessage());\n                                if (retryCounter == 2) {\n                                    ctx.fail(new IllegalStateException(\"Example service creation failed thrice\"));\n                                    return;\n                                }\n                            }\n                        }\n                        this.host.sendAndWaitExpectSuccess(\n                                Operation.createDelete(UriUtils.buildUri(this.host,\n                                        UriUtils.buildUriPath(ExampleService.FACTORY_LINK, serviceName))));\n                        ctx.complete();\n                    } catch (Throwable e) {\n                        this.host.log(Level.WARNING, e.getMessage());\n                        ctx.fail(e);\n                    }\n                });\n            }\n            this.host.testWait(ctx);\n        } finally {\n            if (executor != null) {\n                executor.shutdown();\n            }\n        }\n    }\n\n    @Test\n    public void testAuthzUtils() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        AuthorizationHelper authHelperForFoo = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String fooUserLink = authHelperForFoo.createUserService(this.host, email);\n        UserState patchState = new UserState();\n        patchState.userGroupLinks = new HashSet<String>();\n        patchState.userGroupLinks.add(UriUtils.buildUriPath(\n                UserGroupService.FACTORY_LINK, authHelperForFoo.getUserGroupName(email)));\n        authHelperForFoo.patchUserService(this.host, fooUserLink, patchState);\n        // create a user group based on a query for userGroupLink\n        authHelperForFoo.createRoles(this.host, email);\n        // spin up a privileged service to query for auth context\n        MinimalTestService s = new MinimalTestService();\n        this.host.addPrivilegedService(MinimalTestService.class);\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n        this.host.resetSystemAuthorizationContext();\n\n        String userGroupLink = authHelperForFoo.getUserGroupLink();\n        String resourceGroupLink = authHelperForFoo.getResourceGroupLink();\n        String roleLink = authHelperForFoo.getRoleLink();\n\n\n        // get the user group service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        Operation getUserGroupStateOp =\n                Operation.createGet(UriUtils.buildUri(this.host, userGroupLink));\n        Operation resultOp = this.host.waitForResponse(getUserGroupStateOp);\n        UserGroupState userGroupState = resultOp.getBody(UserGroupState.class);\n        Operation clearAuthOp = new Operation();\n        TestContext ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUserGroup(s, clearAuthOp, userGroupState);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // get the resource group and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        clearAuthOp = new Operation();\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, resourceGroupLink));\n        AuthorizationCacheUtils.clearAuthzCacheForResourceGroup(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // get the role service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        Operation getRoleStateOp =\n                Operation.createGet(UriUtils.buildUri(this.host, roleLink));\n        resultOp = this.host.waitForResponse(getRoleStateOp);\n        RoleState roleState = resultOp.getBody(RoleState.class);\n        clearAuthOp = new Operation();\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForRole(s, clearAuthOp, roleState);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // finally, get the user service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        clearAuthOp = new Operation();\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, fooUserLink));\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUser(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n    }\n\n    private void verifyJaneAccess(Map<URI, ExampleServiceState> exampleServices, String authToken) throws Throwable {\n        // Try to GET all example services\n        this.host.testStart(exampleServices.size());\n        for (Entry<URI, ExampleServiceState> entry : exampleServices.entrySet()) {\n            Operation get = Operation.createGet(entry.getKey());\n            // force to create a remote context\n            if (authToken != null) {\n                get.forceRemote();\n                get.getRequestHeaders().put(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken);\n            }\n            if (entry.getValue().name.equals(\"jane\")) {\n                // Expect 200 OK\n                get.setCompletion((o, e) -> {\n                    if (o.getStatusCode() != Operation.STATUS_CODE_OK) {\n                        String message = String.format(\"Expected %d, got %s\",\n                                Operation.STATUS_CODE_OK,\n                                o.getStatusCode());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n                    ExampleServiceState body = o.getBody(ExampleServiceState.class);\n                    if (!body.documentAuthPrincipalLink.equals(this.userServicePath)) {\n                        String message = String.format(\"Expected %s, got %s\",\n                                this.userServicePath, body.documentAuthPrincipalLink);\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n                    this.host.completeIteration();\n                });\n            } else {\n                // Expect 403 Forbidden\n                get.setCompletion((o, e) -> {\n                    if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                        String message = String.format(\"Expected %d, got %s\",\n                                Operation.STATUS_CODE_FORBIDDEN,\n                                o.getStatusCode());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n\n                    this.host.completeIteration();\n                });\n            }\n\n            this.host.send(get);\n        }\n        this.host.testWait();\n    }\n\n    private void assertAuthorizedServicesInResult(String name,\n            Map<URI, ExampleServiceState> exampleServices,\n            ServiceDocumentQueryResult result) {\n        Set<String> selfLinks = new HashSet<>(result.documentLinks);\n        for (Entry<URI, ExampleServiceState> entry : exampleServices.entrySet()) {\n            String selfLink = entry.getKey().getPath();\n            if (entry.getValue().name.equals(name)) {\n                assertTrue(selfLinks.contains(selfLink));\n            } else {\n                assertFalse(selfLinks.contains(selfLink));\n            }\n        }\n    }\n\n    private String generateAuthToken(String userServicePath) throws GeneralSecurityException {\n        Claims.Builder builder = new Claims.Builder();\n        builder.setSubject(userServicePath);\n        Claims claims = builder.getResult();\n        return this.host.getTokenSigner().sign(claims);\n    }\n\n    private ExampleServiceState createExampleServiceState(String name, Long counter) {\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = name;\n        state.counter = counter;\n        state.documentAuthPrincipalLink = \"stringtooverwrite\";\n        return state;\n    }\n\n    private Map<URI, ExampleServiceState> createExampleServices(String userName) throws Throwable {\n        Collection<ExampleServiceState> bodies = new LinkedList<>();\n        for (int i = 0; i < this.serviceCount; i++) {\n            bodies.add(createExampleServiceState(userName, 1L));\n        }\n\n        Iterator<ExampleServiceState> it = bodies.iterator();\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(it.next());\n        };\n\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(\n                null,\n                bodies.size(),\n                ExampleServiceState.class,\n                bodySetter,\n                UriUtils.buildFactoryUri(this.host, ExampleService.class));\n\n        return states;\n    }\n}\n", "target": 0}
{"idx": 910, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.ServiceStatLogHistogram;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.AggregationType;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.TimeBin;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService;\n\npublic class TestUtilityService extends BasicReusableHostTestCase {\n\n    private List<Service> createServices(int count) throws Throwable {\n        List<Service> services = this.host.doThroughputServiceStart(\n                count, MinimalTestService.class,\n                this.host.buildMinimalTestState(),\n                null, null);\n        return services;\n    }\n\n    @Before\n    public void setUp() {\n        // We tell the verification host that we re-use it across test methods. This enforces\n        // the use of TestContext, to isolate test methods from each other.\n        // In this test class we host.testCreate(count) to get an isolated test context and\n        // then either wait on the context itself, or ask the convenience method host.testWait(ctx)\n        // to do it for us.\n        this.host.setSingleton(true);\n    }\n\n    @Test\n    public void patchConfiguration() throws Throwable {\n        int count = 10;\n\n        host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n        // try config patch on a factory\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.removeOptions = EnumSet.of(ServiceOption.IDEMPOTENT_POST);\n        TestContext ctx = this.testCreate(1);\n\n        URI configUri = UriUtils.buildConfigUri(host, ExampleService.FACTORY_LINK);\n        this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                .setCompletion(ctx.getCompletion()));\n\n        this.testWait(ctx);\n\n        TestContext ctx2 = this.testCreate(1);\n        // verify option removed\n        this.host.send(Operation.createGet(configUri).setCompletion((o, e) -> {\n            if (e != null) {\n                ctx2.failIteration(e);\n                return;\n            }\n\n            ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n            if (!cfg.options.contains(ServiceOption.IDEMPOTENT_POST)) {\n                ctx2.completeIteration();\n            } else {\n                ctx2.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n            }\n\n        }));\n\n        this.testWait(ctx2);\n\n        List<Service> services = createServices(count);\n        // verify no stats exist before we enable that capability\n        for (Service s : services) {\n            Map<String, ServiceStat> stats = this.host.getServiceStats(s.getUri());\n            assertTrue(stats != null);\n            assertTrue(stats.isEmpty());\n        }\n\n        updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.addOptions = EnumSet.of(ServiceOption.INSTRUMENTATION);\n        ctx = this.testCreate(services.size());\n        for (Service s : services) {\n            configUri = UriUtils.buildConfigUri(s.getUri());\n            this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                    .setCompletion(ctx.getCompletion()));\n        }\n        this.testWait(ctx);\n\n        // get configuration and verify options\n        TestContext ctx3 = testCreate(services.size());\n        for (Service s : services) {\n            URI u = UriUtils.buildConfigUri(s.getUri());\n            host.send(Operation.createGet(u).setCompletion((o, e) -> {\n                if (e != null) {\n                    ctx3.failIteration(e);\n                    return;\n                }\n\n                ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n                if (cfg.options.contains(ServiceOption.INSTRUMENTATION)) {\n                    ctx3.completeIteration();\n                } else {\n                    ctx3.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n                }\n\n            }));\n        }\n        testWait(ctx3);\n\n        ctx = testCreate(services.size());\n        // issue some updates so stats get updated\n        for (Service s : services) {\n            this.host.send(Operation.createPatch(s.getUri())\n                    .setBody(this.host.buildMinimalTestState())\n                    .setCompletion(ctx.getCompletion()));\n        }\n        testWait(ctx);\n\n        for (Service s : services) {\n            Map<String, ServiceStat> stats = this.host.getServiceStats(s.getUri());\n            assertTrue(stats != null);\n            assertTrue(!stats.isEmpty());\n        }\n    }\n\n    @Test\n    public void redirectToUiServiceIndex() throws Throwable {\n        // create an example child service and also verify it has a default UI html page\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = UUID.randomUUID().toString();\n        s.documentSelfLink = s.name;\n        Operation post = Operation\n                .createPost(UriUtils.buildFactoryUri(this.host, ExampleService.class))\n                .setBody(s);\n        this.host.sendAndWaitExpectSuccess(post);\n\n        // do a get on examples/ui and examples/<uuid>/ui, twice to test the code path that caches\n        // the resource file lookup\n        for (int i = 0; i < 2; i++) {\n            Operation htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n\n            htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK, s.name,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n        }\n    }\n\n    @Test\n    public void statRESTActions() throws Throwable {\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        long c = 2;\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        stat.unit = \"unit\";\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 3 - POST a stat with the same key again and verify that the\n        // version and accumulated value are updated\n        stat.latestValue = 50;\n        stat.unit = \"unit1\";\n        Long updatedMicrosUtc1 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc1;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        // Step 4 - POST a stat with a new key and verify that the\n        // previously posted stat is not updated\n        stat.name = \"key2\";\n        stat.latestValue = 50;\n        stat.unit = \"unit2\";\n        Long updatedMicrosUtc2 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc2;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        retStatEntry = allStats.entries.get(\"key2\");\n        assertTrue(retStatEntry.accumulatedValue == 50);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit2\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc2);\n\n        // Step 5 - Issue a PUT for the first stat key and verify that the doc state is replaced\n        stat.name = \"key1\";\n        stat.latestValue = 75;\n        stat.unit = \"replaceUnit\";\n        stat.sourceTimeMicrosUtc = null;\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 75);\n        assertTrue(retStatEntry.latestValue == 75);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"replaceUnit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 6 - Issue a bulk PUT and verify that the complete set of stats is updated\n        ServiceStats stats = new ServiceStats();\n        stat.name = \"key3\";\n        stat.latestValue = 200;\n        stat.unit = \"unit3\";\n        stats.entries.put(\"key3\", stat);\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stats));\n        allStats = getStats(exampleServiceState);\n        if (allStats.entries.size() != 1) {\n            // there is a possibility of node group maintenance kicking in and adding a stat\n            ServiceStat nodeGroupStat = allStats.entries.get(\n                    Service.STAT_NAME_NODE_GROUP_CHANGE_MAINTENANCE_COUNT);\n\n            if (nodeGroupStat == null) {\n                throw new IllegalStateException(\n                        \"Expected single stat, got: \" + Utils.toJsonHtml(allStats));\n            }\n        }\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.accumulatedValue == 200);\n        assertTrue(retStatEntry.latestValue == 200);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit3\"));\n\n        // Step 7 - Issue a PATCH and verify that the latestValue is updated\n        stat.latestValue = 25;\n        this.host.sendAndWaitExpectSuccess(Operation.createPatch(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.latestValue == 225);\n        assertTrue(retStatEntry.version == 2);\n\n        verifyGetWithODataOnStats(exampleServiceState);\n\n        verifyStatCreationAttemptAfterGet();\n\n    }\n\n    private void verifyGetWithODataOnStats(ExampleServiceState exampleServiceState) {\n        URI exampleStatsUri = UriUtils.buildStatsUri(this.host,\n                exampleServiceState.documentSelfLink);\n        // bulk PUT to set stats to a known state\n        ServiceStats stats = new ServiceStats();\n        stats.kind = ServiceStats.KIND;\n        ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"key2\";\n        stat.latestValue = 0.0;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"key3\";\n        stat.latestValue = -200;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY;\n        stat.latestValue = 1000;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"someOtherKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY;\n        stat.latestValue = 2000;\n        stats.entries.put(stat.name, stat);\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(exampleStatsUri).setBody(stats));\n\n        // negative tests\n        URI exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_COUNT, Boolean.TRUE.toString());\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_ORDER_BY, \"name\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_SKIP_TO, \"100\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_TOP, \"100\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        // attempt long value LE on latestVersion, should fail\n        String odataFilterValue = String.format(\"%s le %d\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1001);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        // Positive filter tests\n        String statName = \"key1\";\n        // test filter for exact match\n        odataFilterValue = String.format(\"%s eq %s\",\n                ServiceStat.FIELD_NAME_NAME,\n                statName);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        ServiceStats filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 1);\n        assertTrue(filteredStats.entries.containsKey(statName));\n\n        // test filter with prefix match\n        odataFilterValue = String.format(\"%s eq %s*\",\n                ServiceStat.FIELD_NAME_NAME,\n                \"key\");\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // three entries start with \"key\"\n        assertTrue(filteredStats.entries.size() == 3);\n        assertTrue(filteredStats.entries.containsKey(\"key1\"));\n        assertTrue(filteredStats.entries.containsKey(\"key2\"));\n        assertTrue(filteredStats.entries.containsKey(\"key3\"));\n\n        // test filter with suffix match, common for time series filtering\n        odataFilterValue = String.format(\"%s eq *%s\",\n                ServiceStat.FIELD_NAME_NAME,\n                ServiceStats.STAT_NAME_SUFFIX_PER_DAY);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // two entries end with \"Day\"\n        assertTrue(filteredStats.entries.size() == 2);\n        assertTrue(filteredStats.entries\n                .containsKey(\"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n        assertTrue(filteredStats.entries\n                .containsKey(\"someOtherKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n\n        // filter on latestValue, GE\n        odataFilterValue = String.format(\"%s ge %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                0.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 4);\n\n        // filter on latestValue, GT\n        odataFilterValue = String.format(\"%s gt %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                0.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 3);\n\n        // filter on latestValue, eq\n        odataFilterValue = String.format(\"%s eq %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                -200.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 1);\n\n        // filter on latestValue, le\n        odataFilterValue = String.format(\"%s le %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1000.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 2);\n\n        // filter on latestValue, lt AND gt\n        odataFilterValue = String.format(\"%s lt %f and %s gt %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                2000.0,\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1000.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // two entries end with \"Day\"\n        assertTrue(filteredStats.entries.size() == 0);\n\n        // test dual filter with suffix match, and latest value LEQ\n        odataFilterValue = String.format(\"%s eq *%s and %s le %f\",\n                ServiceStat.FIELD_NAME_NAME,\n                ServiceStats.STAT_NAME_SUFFIX_PER_DAY,\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1001.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // single entry ends with \"Day\" and has latestValue <= 1000\n        assertTrue(filteredStats.entries.size() == 1);\n        assertTrue(filteredStats.entries\n                .containsKey(\"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n\n    }\n\n    private void verifyStatCreationAttemptAfterGet() throws Throwable {\n        // Create a stat without a log histogram or time series, then try to recreate with\n        // the extra features and make sure its updated\n\n        List<Service> services = this.host.doThroughputServiceStart(\n                1, MinimalTestService.class,\n                this.host.buildMinimalTestState(), EnumSet.of(ServiceOption.INSTRUMENTATION), null);\n\n        final String statName = \"foo\";\n        for (Service service : services) {\n            service.setStat(statName, 1.0);\n            ServiceStat st = service.getStat(statName);\n            assertTrue(st.timeSeriesStats == null);\n            assertTrue(st.logHistogram == null);\n            ServiceStat stNew = new ServiceStat();\n            stNew.name = statName;\n            stNew.logHistogram = new ServiceStatLogHistogram();\n            stNew.timeSeriesStats = new TimeSeriesStats(60,\n                    TimeUnit.MINUTES.toMillis(1), EnumSet.of(AggregationType.AVG));\n            service.setStat(stNew, 11.0);\n            st = service.getStat(statName);\n            assertTrue(st.timeSeriesStats != null);\n            assertTrue(st.logHistogram != null);\n        }\n    }\n\n    private ServiceStats getStats(ExampleServiceState exampleServiceState) {\n        return this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n    }\n\n    private ServiceStats getStats(URI statsUri) {\n        return this.host.getServiceState(null, ServiceStats.class, statsUri);\n    }\n\n    @Test\n    public void testTimeSeriesStats() throws Throwable {\n        long startTime = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());\n        int numBins = 4;\n        long interval = 1000;\n        double value = 100;\n        // set data to fill up the specified number of bins\n        TimeSeriesStats timeSeriesStats = new TimeSeriesStats(numBins, interval,\n                EnumSet.allOf(AggregationType.class));\n        for (int i = 0; i < numBins; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value, 1);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n        // insert additional unique datapoints; the earliest entries should be dropped\n        for (int i = 0; i < numBins / 2; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value, 1);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n        long timeMicros = startTime - TimeUnit.MILLISECONDS.toMicros(interval * (numBins - 1));\n        long timeMillis = TimeUnit.MICROSECONDS.toMillis(timeMicros);\n        timeMillis -= (timeMillis % interval);\n        assertTrue(timeSeriesStats.bins.firstKey() == timeMillis);\n\n        // insert additional datapoints for an existing bin. The count should increase,\n        // min, max, average computed appropriately\n        double origValue = value;\n        double accumulatedValue = value;\n        double newValue = value;\n        double count = 1;\n        for (int i = 0; i < numBins / 2; i++) {\n            newValue++;\n            count++;\n            timeSeriesStats.add(startTime, newValue, 2);\n            accumulatedValue += newValue;\n        }\n        TimeBin lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg.equals(accumulatedValue / count));\n        assertTrue(lastBin.sum.equals((2 * count) - 1));\n        assertTrue(lastBin.count == count);\n        assertTrue(lastBin.max.equals(newValue));\n        assertTrue(lastBin.min.equals(origValue));\n        assertTrue(lastBin.latest.equals(newValue));\n\n        // test with a subset of the aggregation types specified\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.AVG));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg != null);\n        assertTrue(lastBin.count != 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max == null);\n        assertTrue(lastBin.min == null);\n\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.MIN,\n                AggregationType.MAX));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg == null);\n        assertTrue(lastBin.count == 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max != null);\n        assertTrue(lastBin.min != null);\n\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.LATEST));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg == null);\n        assertTrue(lastBin.count == 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max == null);\n        assertTrue(lastBin.min == null);\n        assertTrue(lastBin.latest.equals(value));\n\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        // set bin size to 1ms\n        stat.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        for (int i = 0; i < numBins; i++) {\n            Thread.sleep(1);\n            this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                    this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        }\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(stat.name);\n        assertTrue(retStatEntry.accumulatedValue == 100 * (numBins + 1));\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == numBins + 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == numBins);\n\n        // Step 3 - POST a stat to the service instance with sourceTimeMicrosUtc and verify we can fetch the stat just posted\n        String statName = UUID.randomUUID().toString();\n        ExampleServiceState exampleState = new ExampleServiceState();\n        exampleState.name = statName;\n        Consumer<Operation> setter = (o) -> {\n            o.setBody(exampleState);\n        };\n        Map<URI, ExampleServiceState> stateMap = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, setter,\n                UriUtils.buildFactoryUri(this.host, ExampleService.class));\n        ExampleServiceState returnExampleState = stateMap.values().iterator().next();\n        ServiceStats.ServiceStat sourceStat1 = new ServiceStat();\n        sourceStat1.name = \"sourceKey1\";\n        sourceStat1.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 1, 2000\n        Long sourceTimeMicrosUtc1 = 946713600000000L;\n        sourceStat1.sourceTimeMicrosUtc = sourceTimeMicrosUtc1;\n        ServiceStats.ServiceStat sourceStat2 = new ServiceStat();\n        sourceStat2.name = \"sourceKey2\";\n        sourceStat2.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 2, 2000\n        Long sourceTimeMicrosUtc2 = 946800000000000L;\n        sourceStat2.sourceTimeMicrosUtc = sourceTimeMicrosUtc2;\n        // set bucket size to 1ms\n        sourceStat1.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        sourceStat2.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat1));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat2));\n        allStats = getStats(returnExampleState);\n        retStatEntry = allStats.entries.get(sourceStat1.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc1)));\n\n        retStatEntry = allStats.entries.get(sourceStat2.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc2)));\n    }\n\n    public static class SetAvailableValidationService extends StatefulService {\n\n        public SetAvailableValidationService() {\n            super(ExampleServiceState.class);\n        }\n\n        @Override\n        public void handleStart(Operation op) {\n            setAvailable(false);\n            // we will transition to available only when we receive a special PATCH.\n            // This simulates a service that starts, but then self patch itself sometime\n            // later to indicate its done with some complex init. It does not do it in handle\n            // start, since it wants to make POST quick.\n            op.complete();\n        }\n\n        @Override\n        public void handlePatch(Operation op) {\n            // regardless of body, just become available\n            setAvailable(true);\n            op.complete();\n        }\n    }\n\n    @Test\n    public void failureOnReservedSuffixServiceStart() throws Throwable {\n        TestContext ctx = this.testCreate(ServiceHost.RESERVED_SERVICE_URI_PATHS.length);\n        for (String reservedSuffix : ServiceHost.RESERVED_SERVICE_URI_PATHS) {\n            Operation post = Operation.createPost(this.host,\n                    UUID.randomUUID().toString() + \"/\" + reservedSuffix)\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.startService(post, new MinimalTestService());\n        }\n        this.testWait(ctx);\n    }\n\n    @Test\n    public void testIsAvailableStatAndSuffix() throws Throwable {\n        long c = 1;\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        // first verify that service that do not explicitly use the setAvailable method,\n        // appear available. Both a factory and a child service\n        this.host.waitForServiceAvailable(factoryURI);\n\n        // expect 200 from /factory/<child>/available\n        TestContext ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            Operation get = Operation.createGet(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // verify that PUT on /available can make it switch to unavailable (503)\n        ServiceStat body = new ServiceStat();\n        body.name = Service.STAT_NAME_AVAILABLE;\n        body.latestValue = 0.0;\n\n        Operation put = Operation.createPut(\n                UriUtils.buildAvailableUri(this.host, factoryURI.getPath()))\n                .setBody(body);\n        this.host.sendAndWaitExpectSuccess(put);\n\n        // verify factory now appears unavailable\n        Operation get = Operation.createGet(UriUtils.buildAvailableUri(factoryURI));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // verify PUT on child services makes them unavailable\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            put = put.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setBody(body)\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(put);\n        }\n        testWait(ctx);\n\n        // expect 503 from /factory/<child>/available\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            get = get.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // now validate a stateful service that is in memory, and explicitly calls setAvailable\n        // sometime after it starts\n        Service service = this.host.startServiceAndWait(new SetAvailableValidationService(),\n                UUID.randomUUID().toString(), new ExampleServiceState());\n\n        // verify service is NOT available, since we have not yet poked it, to become available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // send a PATCH to this special test service, to make it switch to available\n        Operation patch = Operation.createPatch(service.getUri())\n                .setBody(new ExampleServiceState());\n        this.host.sendAndWaitExpectSuccess(patch);\n\n        // verify service now appears available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectSuccess(get);\n    }\n\n    public void validateServiceUiHtmlResponse(Operation op) {\n        assertTrue(op.getStatusCode() == Operation.STATUS_CODE_MOVED_TEMP);\n        assertTrue(op.getResponseHeader(\"Location\").contains(\n                \"/core/ui/default/#\"));\n    }\n\n    public static void validateTimeSeriesStat(ServiceStat stat, long expectedBinDurationMillis) {\n        assertTrue(stat != null);\n        assertTrue(stat.timeSeriesStats != null);\n        assertTrue(stat.version >= 1);\n        assertEquals(expectedBinDurationMillis, stat.timeSeriesStats.binDurationMillis);\n        if (stat.timeSeriesStats.aggregationType.contains(AggregationType.AVG)) {\n            double maxCount = 0;\n            for (TimeBin bin : stat.timeSeriesStats.bins.values()) {\n                if (bin.count > maxCount) {\n                    maxCount = bin.count;\n                }\n            }\n            assertTrue(maxCount >= 1);\n        }\n    }\n}\n", "target": 1}
{"idx": 911, "func": "/*\n * $Id$\n *\n * Copyright 2000-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.struts.action;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.*;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.UnavailableException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.sql.DataSource;\n\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.apache.commons.beanutils.ConvertUtils;\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.apache.commons.beanutils.SuppressPropertiesBeanIntrospector;\nimport org.apache.commons.beanutils.converters.BigDecimalConverter;\nimport org.apache.commons.beanutils.converters.BigIntegerConverter;\nimport org.apache.commons.beanutils.converters.BooleanConverter;\nimport org.apache.commons.beanutils.converters.ByteConverter;\nimport org.apache.commons.beanutils.converters.CharacterConverter;\nimport org.apache.commons.beanutils.converters.DoubleConverter;\nimport org.apache.commons.beanutils.converters.FloatConverter;\nimport org.apache.commons.beanutils.converters.IntegerConverter;\nimport org.apache.commons.beanutils.converters.LongConverter;\nimport org.apache.commons.beanutils.converters.ShortConverter;\nimport org.apache.commons.collections.FastHashMap;\nimport org.apache.commons.digester.Digester;\nimport org.apache.commons.digester.RuleSet;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.struts.Globals;\nimport org.apache.struts.config.ConfigRuleSet;\nimport org.apache.struts.config.DataSourceConfig;\nimport org.apache.struts.config.FormBeanConfig;\nimport org.apache.struts.config.MessageResourcesConfig;\nimport org.apache.struts.config.ModuleConfig;\nimport org.apache.struts.config.ModuleConfigFactory;\nimport org.apache.struts.config.PlugInConfig;\nimport org.apache.struts.util.MessageResources;\nimport org.apache.struts.util.MessageResourcesFactory;\nimport org.apache.struts.util.ModuleUtils;\nimport org.apache.struts.util.RequestUtils;\nimport org.apache.struts.util.ServletContextWriter;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * <p><strong>ActionServlet</strong> provides the \"controller\" in the\n * Model-View-Controller (MVC) design pattern for web applications that is\n * commonly known as \"Model 2\".  This nomenclature originated with a\n * description in the JavaServerPages Specification, version 0.92, and has\n * persisted ever since (in the absence of a better name).</p>\n *\n * <p>Generally, a \"Model 2\" application is architected as follows:</p>\n * <ul>\n * <li>The user interface will generally be created with server pages, which\n *     will not themselves contain any business logic. These pages represent\n *     the \"view\" component of an MVC architecture.</li>\n * <li>Forms and hyperlinks in the user interface that require business logic\n *     to be executed will be submitted to a request URI that is mapped to this\n *     servlet.</li>\n * <li>There can be <b>one</b> instance of this servlet class,\n *     which receives and processes all requests that change the state of\n *     a user's interaction with the application.  The servlet delegates the\n *     handling of a request to a {@link RequestProcessor} object. This component\n *     represents the \"controller\" component of an MVC architecture.</li>\n * <li>The <code>RequestProcessor</code> selects and invokes an {@link Action} class to perform\n *     the requested business logic, or delegates the response to another resource.</li>\n * <li>The <code>Action</code> classes can manipulate the state of the application's\n *     interaction with the user, typically by creating or modifying JavaBeans\n *     that are stored as request or session attributes (depending on how long\n *     they need to be available). Such JavaBeans represent the \"model\"\n *     component of an MVC architecture.</li>\n * <li>Instead of producing the next page of the user interface directly,\n *     <code>Action</code> classes generally return an {@link ActionForward} to indicate\n *     which resource should handle the response. If the <code>Action</code>\n *     does not return null, the <code>RequestProcessor</code> forwards or\n *     redirects to the specified resource (by utilizing\n *     <code>RequestDispatcher.forward</code> or <code>Response.sendRedirect</code>)\n *     so as to produce the next page of the user interface.</li>\n * </ul>\n *\n * <p>The standard version of <code>RequestsProcessor</code> implements the\n *    following logic for each incoming HTTP request. You can override\n *    some or all of this functionality by subclassing this object and\n *    implementing your own version of the processing.</p>\n * <ul>\n * <li>Identify, from the incoming request URI, the substring that will be\n *     used to select an action procedure.</li>\n * <li>Use this substring to map to the Java class name of the corresponding\n *     action class (an implementation of the <code>Action</code> interface).\n *     </li>\n * <li>If this is the first request for a particular <code>Action</code> class,\n *     instantiate an instance of that class and cache it for future use.</li>\n * <li>Optionally populate the properties of an <code>ActionForm</code> bean\n *     associated with this mapping.</li>\n * <li>Call the <code>execute</code> method of this <code>Action</code> class, passing\n *     on a reference to the mapping that was used, the relevant form-bean\n *     (if any), and the request and the response that were passed to the\n *     controller by the servlet container (thereby providing access to any\n *     specialized properties of the mapping itself as well as to the\n *     ServletContext).\n *     </li>\n * </ul>\n *\n * <p>The standard version of <code>ActionServlet</code> is configured based\n * on the following servlet initialization parameters, which you will specify\n * in the web application deployment descriptor (<code>/WEB-INF/web.xml</code>)\n * for your application.  Subclasses that specialize this servlet are free to\n * define additional initialization parameters. </p>\n * <ul>\n * <li><strong>config</strong> - Comma-separated list of context-relative\n *     path(s) to the XML resource(s) containing the configuration information\n *     for the default module.  (Multiple files support since Struts 1.1)\n *     [/WEB-INF/struts-config.xml].</li>\n * <li><strong>config/${module}</strong> - Comma-separated list of\n *     Context-relative path(s) to the XML resource(s)\n *     containing the configuration information for the module that\n *     will use the specified prefix (/${module}). This can be repeated as many\n *     times as required for multiple modules. (Since Struts 1.1)</li>\n * <li><strong>configFactory</strong> - The Java class name of the\n *     <code>ModuleConfigFactory</code> used to create the implementation of the\n *     <code>ModuleConfig</code> interface.\n *     [org.apache.struts.config.impl.DefaultModuleConfigFactory]\n * </li>\n * <li><strong>convertNull</strong> - Force simulation of the Struts 1.0 behavior\n *     when populating forms. If set to true, the numeric Java wrapper class types\n *     (like <code>java.lang.Integer</code>) will default to null (rather than 0).\n *     (Since Struts 1.1) [false] </li>\n * <li><strong>rulesets</strong> - Comma-delimited list of fully qualified\n *     classnames of additional <code>org.apache.commons.digester.RuleSet</code>\n *     instances that should be added to the <code>Digester</code> that will\n *     be processing <code>struts-config.xml</code> files.  By default, only\n *     the <code>RuleSet</code> for the standard configuration elements is\n *     loaded.  (Since Struts 1.1)</li>\n * <li><strong>validating</strong> - Should we use a validating XML parser to\n *     process the configuration file (strongly recommended)? [true]</li>\n * </ul>\n *\n * @version $Rev$ $Date$\n */\npublic class ActionServlet extends HttpServlet {\n\n\n    // ----------------------------------------------------- Instance Variables\n\n\n    /**\n     * <p>Comma-separated list of context-relative path(s) to our configuration\n     * resource(s) for the default module.</p>\n     */\n    protected String config = \"/WEB-INF/struts-config.xml\";\n\n\n    /**\n     * <p>The Digester used to produce ModuleConfig objects from a\n     * Struts configuration file.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected Digester configDigester = null;\n\n\n    /**\n     * <p>The flag to request backwards-compatible conversions for form bean\n     * properties of the Java wrapper class types.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected boolean convertNull = false;\n\n\n    /**\n     * <p>The JDBC data sources that has been configured for this module,\n     * if any, keyed by the servlet context attribute under which they are\n     * stored.</p>\n     */\n    protected FastHashMap dataSources = new FastHashMap();\n\n\n    /**\n     * <p>The resources object for our internal resources.</p>\n     */\n    protected MessageResources internal = null;\n\n\n    /**\n     * <p>The Java base name of our internal resources.</p>\n     * @since Struts 1.1\n     */\n    protected String internalName = \"org.apache.struts.action.ActionResources\";\n\n\n    /**\n     * <p>Commons Logging instance.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected static Log log = LogFactory.getLog(ActionServlet.class);\n\n\n    /**\n     * <p>The <code>RequestProcessor</code> instance we will use to process\n     * all incoming requests.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected RequestProcessor processor = null;\n\n\n    /**\n     * <p>The set of public identifiers, and corresponding resource names, for\n     * the versions of the configuration file DTDs that we know about.  There\n     * <strong>MUST</strong> be an even number of Strings in this list!</p>\n     */\n    protected String registrations[] = {\n        \"-//Apache Software Foundation//DTD Struts Configuration 1.0//EN\",\n        \"/org/apache/struts/resources/struts-config_1_0.dtd\",\n        \"-//Apache Software Foundation//DTD Struts Configuration 1.1//EN\",\n        \"/org/apache/struts/resources/struts-config_1_1.dtd\",\n        \"-//Apache Software Foundation//DTD Struts Configuration 1.2//EN\",\n        \"/org/apache/struts/resources/struts-config_1_2.dtd\",\n        \"-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN\",\n        \"/org/apache/struts/resources/web-app_2_2.dtd\",\n        \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\",\n        \"/org/apache/struts/resources/web-app_2_3.dtd\"\n    };\n\n\n    /**\n     * <p>The URL pattern to which we are mapped in our web application\n     * deployment descriptor.</p>\n     */\n    protected String servletMapping = null; // :FIXME: - multiples?\n\n\n    /**\n     * <p>The servlet name under which we are registered in our web application\n     * deployment descriptor.</p>\n     */\n    protected String servletName = null;\n\n\n    // ---------------------------------------------------- HttpServlet Methods\n\n\n    /**\n     * <p>Gracefully shut down this controller servlet, releasing any resources\n     * that were allocated at initialization.</p>\n     */\n    public void destroy() {\n\n        if (log.isDebugEnabled()) {\n            log.debug(internal.getMessage(\"finalizing\"));\n        }\n\n        destroyModules();\n        destroyInternal();\n        getServletContext().removeAttribute(Globals.ACTION_SERVLET_KEY);\n\n        // Release our LogFactory and Log instances (if any)\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        if (classLoader == null) {\n            classLoader = ActionServlet.class.getClassLoader();\n        }\n        try {\n            LogFactory.release(classLoader);\n        } catch (Throwable t) {\n            ; // Servlet container doesn't have the latest version\n            ; // of commons-logging-api.jar installed\n\n            // :FIXME: Why is this dependent on the container's version of commons-logging?\n            // Shouldn't this depend on the version packaged with Struts?\n            /*\n              Reason: LogFactory.release(classLoader); was added as\n              an attempt to investigate the OutOfMemory error reported on Bugzilla #14042.\n              It was committed for version 1.136 by craigmcc\n            */\n        }\n\n        PropertyUtils.clearDescriptors();\n\n    }\n\n\n    /**\n     * <p>Initialize this servlet.  Most of the processing has been factored into\n     * support methods so that you can override particular functionality at a\n     * fairly granular level.</p>\n     *\n     * @exception ServletException if we cannot configure ourselves correctly\n     */\n    public void init() throws ServletException {\n\n        // Wraps the entire initialization in a try/catch to better handle\n        // unexpected exceptions and errors to provide better feedback\n        // to the developer\n        try {\n            initInternal();\n            initOther();\n            initServlet();\n\n            getServletContext().setAttribute(Globals.ACTION_SERVLET_KEY, this);\n            initModuleConfigFactory();\n            // Initialize modules as needed\n            ModuleConfig moduleConfig = initModuleConfig(\"\", config);\n            initModuleMessageResources(moduleConfig);\n            initModuleDataSources(moduleConfig);\n            initModulePlugIns(moduleConfig);\n            moduleConfig.freeze();\n\n            Enumeration names = getServletConfig().getInitParameterNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                if (!name.startsWith(\"config/\")) {\n                    continue;\n                }\n                String prefix = name.substring(6);\n                moduleConfig = initModuleConfig\n                    (prefix, getServletConfig().getInitParameter(name));\n                initModuleMessageResources(moduleConfig);\n                initModuleDataSources(moduleConfig);\n                initModulePlugIns(moduleConfig);\n                moduleConfig.freeze();\n            }\n\n            this.initModulePrefixes(this.getServletContext());\n\n            this.destroyConfigDigester();\n        } catch (UnavailableException ex) {\n            throw ex;\n        } catch (Throwable t) {\n\n            // The follow error message is not retrieved from internal message\n            // resources as they may not have been able to have been\n            // initialized\n            log.error(\"Unable to initialize Struts ActionServlet due to an \"\n                + \"unexpected exception or error thrown, so marking the \"\n                + \"servlet as unavailable.  Most likely, this is due to an \"\n                + \"incorrect or missing library dependency.\", t);\n            throw new UnavailableException(t.getMessage());\n        }\n    }\n\n    /**\n     * <p>Saves a String[] of module prefixes in the ServletContext under\n     * Globals.MODULE_PREFIXES_KEY.  <strong>NOTE</strong> -\n     * the \"\" prefix for the default module is not included in this list.</p>\n     *\n     * @param context The servlet context.\n     * @since Struts 1.2\n     */\n    protected void initModulePrefixes(ServletContext context) {\n        ArrayList prefixList = new ArrayList();\n\n        Enumeration names = context.getAttributeNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            if (!name.startsWith(Globals.MODULE_KEY)) {\n                continue;\n            }\n\n            String prefix = name.substring(Globals.MODULE_KEY.length());\n            if (prefix.length() > 0) {\n                prefixList.add(prefix);\n            }\n        }\n\n        String[] prefixes = (String[]) prefixList.toArray(new String[prefixList.size()]);\n        context.setAttribute(Globals.MODULE_PREFIXES_KEY, prefixes);\n    }\n\n\n    /**\n     * <p>Process an HTTP \"GET\" request.</p>\n     *\n     * @param request The servlet request we are processing\n     * @param response The servlet response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet exception occurs\n     */\n    public void doGet(HttpServletRequest request,\n              HttpServletResponse response)\n        throws IOException, ServletException {\n\n        process(request, response);\n\n    }\n\n\n    /**\n     * <p>Process an HTTP \"POST\" request.</p>\n     *\n     * @param request The servlet request we are processing\n     * @param response The servlet response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet exception occurs\n     */\n    public void doPost(HttpServletRequest request,\n               HttpServletResponse response)\n        throws IOException, ServletException {\n\n        process(request, response);\n\n    }\n\n\n    // --------------------------------------------------------- Public Methods\n\n\n    /**\n     * <p>Remember a servlet mapping from our web application deployment\n     * descriptor, if it is for this servlet.</p>\n     *\n     * @param servletName The name of the servlet being mapped\n     * @param urlPattern The URL pattern to which this servlet is mapped\n     */\n    public void addServletMapping(String servletName, String urlPattern) {\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Process servletName=\" + servletName +\n                      \", urlPattern=\" + urlPattern);\n        }\n        if (servletName == null) {\n            return;\n        }\n        if (servletName.equals(this.servletName)) {\n            this.servletMapping = urlPattern;\n        }\n\n    }\n\n\n    /**\n     * <p>Return the <code>MessageResources</code> instance containing our\n     * internal message strings.</p>\n     *\n     * @since Struts 1.1\n     */\n    public MessageResources getInternal() {\n\n        return (this.internal);\n\n    }\n\n\n    // ------------------------------------------------------ Protected Methods\n\n    /**\n     * <p>Gracefully terminate use of any modules associated with this\n     * application (if any).</p>\n     *\n     * @since Struts 1.1\n     */\n    protected void destroyModules() {\n\n        ArrayList values = new ArrayList();\n        Enumeration names = getServletContext().getAttributeNames();\n        while (names.hasMoreElements()) {\n            values.add(names.nextElement());\n        }\n\n        Iterator keys = values.iterator();\n        while (keys.hasNext()) {\n            String name = (String) keys.next();\n            Object value = getServletContext().getAttribute(name);\n\n            if (!(value instanceof ModuleConfig)) {\n                continue;\n            }\n\n            ModuleConfig config = (ModuleConfig) value;\n\n            if (this.getProcessorForModule(config) != null) {\n                this.getProcessorForModule(config).destroy();\n            }\n\n            getServletContext().removeAttribute(name);\n\n            PlugIn plugIns[] =\n                (PlugIn[]) getServletContext().getAttribute(\n                    Globals.PLUG_INS_KEY + config.getPrefix());\n\n            if (plugIns != null) {\n                for (int i = 0; i < plugIns.length; i++) {\n                    int j = plugIns.length - (i + 1);\n                    plugIns[j].destroy();\n                }\n\n                getServletContext().removeAttribute(\n                    Globals.PLUG_INS_KEY + config.getPrefix());\n            }\n\n        }\n\n    }\n\n\n    /**\n     * <p>Gracefully release any configDigester instance that we have created.</p>\n     *\n     * @since Struts 1.1\n     */\n    protected void destroyConfigDigester() {\n\n        configDigester = null;\n\n    }\n\n\n    /**\n     * <p>Gracefully terminate use of the internal MessageResources.</p>\n     */\n    protected void destroyInternal() {\n\n        internal = null;\n\n    }\n\n    /**\n     * <p>Return the module configuration object for the currently selected\n     * module.</p>\n     *\n     * @param request The servlet request we are processing\n     * @since Struts 1.1\n     */\n    protected ModuleConfig getModuleConfig\n        (HttpServletRequest request) {\n\n        ModuleConfig config = (ModuleConfig)\n            request.getAttribute(Globals.MODULE_KEY);\n        if (config == null) {\n            config = (ModuleConfig)\n                getServletContext().getAttribute(Globals.MODULE_KEY);\n        }\n        return (config);\n\n    }\n\n\n    /**\n     * <p>Look up and return the {@link RequestProcessor} responsible for the\n     * specified module, creating a new one if necessary.</p>\n     *\n     * @param config The module configuration for which to\n     *  acquire and return a RequestProcessor.\n     *\n     * @exception ServletException if we cannot instantiate a RequestProcessor\n     *  instance\n     * @since Struts 1.1\n     */\n    protected synchronized RequestProcessor getRequestProcessor(ModuleConfig config)\n        throws ServletException {\n\n        // :FIXME: Document UnavailableException?\n\n        RequestProcessor processor = this.getProcessorForModule(config);\n\n        if (processor == null) {\n            try {\n                processor =\n                    (RequestProcessor) RequestUtils.applicationInstance(\n                        config.getControllerConfig().getProcessorClass());\n\n            } catch (Exception e) {\n                throw new UnavailableException(\n                    \"Cannot initialize RequestProcessor of class \"\n                        + config.getControllerConfig().getProcessorClass()\n                        + \": \"\n                        + e);\n            }\n\n            processor.init(this, config);\n\n            String key = Globals.REQUEST_PROCESSOR_KEY + config.getPrefix();\n            getServletContext().setAttribute(key, processor);\n\n        }\n\n        return (processor);\n\n    }\n\n\n    /**\n     * <p>Returns the RequestProcessor for the given module or null if one does not\n     * exist.  This method will not create a RequestProcessor.</p>\n     *\n     * @param config The ModuleConfig.\n     */\n    private RequestProcessor getProcessorForModule(ModuleConfig config) {\n        String key = Globals.REQUEST_PROCESSOR_KEY + config.getPrefix();\n        return (RequestProcessor) getServletContext().getAttribute(key);\n    }\n\n\n    /**\n     * <p>Initialize the factory used to create the module configuration.</p>\n     * @since Struts 1.2\n     */\n    protected void initModuleConfigFactory(){\n        String configFactory = getServletConfig().getInitParameter(\"configFactory\");\n        if (configFactory != null) {\n            ModuleConfigFactory.setFactoryClass(configFactory);\n        }\n    }\n\n\n    /**\n     * <p>Initialize the module configuration information for the\n     * specified module.</p>\n     *\n     * @param prefix Module prefix for this module\n     * @param paths Comma-separated list of context-relative resource path(s)\n     *  for this modules's configuration resource(s)\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected ModuleConfig initModuleConfig(String prefix, String paths)\n        throws ServletException {\n\n        // :FIXME: Document UnavailableException? (Doesn't actually throw anything)\n\n        if (log.isDebugEnabled()) {\n            log.debug(\n                \"Initializing module path '\"\n                    + prefix\n                    + \"' configuration from '\"\n                    + paths\n                    + \"'\");\n        }\n\n        // Parse the configuration for this module\n        ModuleConfigFactory factoryObject = ModuleConfigFactory.createFactory();\n        ModuleConfig config = factoryObject.createModuleConfig(prefix);\n\n        // Configure the Digester instance we will use\n        Digester digester = initConfigDigester();\n\n        // Process each specified resource path\n        while (paths.length() > 0) {\n            digester.push(config);\n            String path = null;\n            int comma = paths.indexOf(',');\n            if (comma >= 0) {\n                path = paths.substring(0, comma).trim();\n                paths = paths.substring(comma + 1);\n            } else {\n                path = paths.trim();\n                paths = \"\";\n            }\n\n            if (path.length() < 1) {\n                break;\n            }\n\n            this.parseModuleConfigFile(digester, path);\n        }\n\n        getServletContext().setAttribute(\n            Globals.MODULE_KEY + config.getPrefix(),\n            config);\n\n        // Force creation and registration of DynaActionFormClass instances\n        // for all dynamic form beans we wil be using\n        FormBeanConfig fbs[] = config.findFormBeanConfigs();\n        for (int i = 0; i < fbs.length; i++) {\n            if (fbs[i].getDynamic()) {\n                fbs[i].getDynaActionFormClass();\n            }\n        }\n\n        return config;\n    }\n\n\n    /**\n     * <p>Parses one module config file.</p>\n     *\n     * @param digester Digester instance that does the parsing\n     * @param path The path to the config file to parse.\n     *\n     * @throws UnavailableException if file cannot be read or parsed\n     * @since Struts 1.2\n     */\n    protected void parseModuleConfigFile(Digester digester, String path)\n        throws UnavailableException {\n\n        InputStream input = null;\n        try {\n            URL url = getServletContext().getResource(path);\n\n            // If the config isn't in the servlet context, try the class loader\n            // which allows the config files to be stored in a jar\n            if (url == null) {\n                url = getClass().getResource(path);\n            }\n\n            if (url == null) {\n                String msg = internal.getMessage(\"configMissing\", path);\n                log.error(msg);\n                throw new UnavailableException(msg);\n            }\n\n            InputSource is = new InputSource(url.toExternalForm());\n            input = url.openStream();\n            is.setByteStream(input);\n            digester.parse(is);\n\n        } catch (MalformedURLException e) {\n            handleConfigException(path, e);\n        } catch (IOException e) {\n            handleConfigException(path, e);\n        } catch (SAXException e) {\n            handleConfigException(path, e);\n        } finally {\n            if (input != null) {\n                try {\n                    input.close();\n                } catch (IOException e) {\n                    throw new UnavailableException(e.getMessage());\n                }\n            }\n        }\n    }\n\n\n    /**\n     * <p>Simplifies exception handling in the <code>parseModuleConfigFile</code> method.<p>\n     * @param path\n     * @param e\n     * @throws UnavailableException as a wrapper around Exception\n     */\n    private void handleConfigException(String path, Exception e)\n        throws UnavailableException {\n\n        String msg = internal.getMessage(\"configParse\", path);\n        log.error(msg, e);\n        throw new UnavailableException(msg);\n    }\n\n\n    /**\n     * <p>Initialize the data sources for the specified module.</p>\n     *\n     * @param config ModuleConfig information for this module\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected void initModuleDataSources(ModuleConfig config) throws ServletException {\n\n        // :FIXME: Document UnavailableException?\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Initializing module path '\" + config.getPrefix() +\n                \"' data sources\");\n        }\n\n        ServletContextWriter scw =\n            new ServletContextWriter(getServletContext());\n        DataSourceConfig dscs[] = config.findDataSourceConfigs();\n        if (dscs == null) {\n            dscs = new DataSourceConfig[0];\n        }\n\n        dataSources.setFast(false);\n        for (int i = 0; i < dscs.length; i++) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Initializing module path '\" + config.getPrefix() +\n                    \"' data source '\" + dscs[i].getKey() + \"'\");\n            }\n            DataSource ds = null;\n            try {\n                ds = (DataSource)\n                    RequestUtils.applicationInstance(dscs[i].getType());\n                BeanUtils.populate(ds, dscs[i].getProperties());\n                ds.setLogWriter(scw);\n\n            } catch (Exception e) {\n                log.error(internal.getMessage(\"dataSource.init\", dscs[i].getKey()), e);\n                throw new UnavailableException\n                    (internal.getMessage(\"dataSource.init\", dscs[i].getKey()));\n            }\n            getServletContext().setAttribute\n                (dscs[i].getKey() + config.getPrefix(), ds);\n            dataSources.put(dscs[i].getKey(), ds);\n        }\n\n        dataSources.setFast(true);\n\n    }\n\n\n    /**\n     * <p>Initialize the plug ins for the specified module.</p>\n     *\n     * @param config ModuleConfig information for this module\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected void initModulePlugIns\n        (ModuleConfig config) throws ServletException {\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Initializing module path '\" + config.getPrefix() + \"' plug ins\");\n        }\n\n        PlugInConfig plugInConfigs[] = config.findPlugInConfigs();\n        PlugIn plugIns[] = new PlugIn[plugInConfigs.length];\n\n        getServletContext().setAttribute(Globals.PLUG_INS_KEY + config.getPrefix(), plugIns);\n        for (int i = 0; i < plugIns.length; i++) {\n            try {\n                plugIns[i] =\n                    (PlugIn)RequestUtils.applicationInstance(plugInConfigs[i].getClassName());\n                 BeanUtils.populate(plugIns[i], plugInConfigs[i].getProperties());\n                  // Pass the current plugIn config object to the PlugIn.\n                  // The property is set only if the plugin declares it.\n                  // This plugin config object is needed by Tiles\n                try {\n                    PropertyUtils.setProperty(\n                        plugIns[i],\n                        \"currentPlugInConfigObject\",\n                        plugInConfigs[i]);\n                } catch (Exception e) {\n                  // FIXME Whenever we fail silently, we must document a valid reason\n                  // for doing so.  Why should we fail silently if a property can't be set on\n                  // the plugin?\n                    /**\n                     * Between version 1.138-1.140 cedric made these changes.\n                     * The exceptions are caught to deal with containers applying strict security.\n                     * This was in response to bug #15736\n                     *\n                     * Recommend that we make the currentPlugInConfigObject part of the PlugIn Interface if we can, Rob\n                     */\n                }\n                plugIns[i].init(this, config);\n\n            } catch (ServletException e) {\n                throw e;\n            } catch (Exception e) {\n                String errMsg =\n                    internal.getMessage(\n                        \"plugIn.init\",\n                        plugInConfigs[i].getClassName());\n\n                log(errMsg, e);\n                throw new UnavailableException(errMsg);\n            }\n        }\n\n    }\n\n\n    /**\n     * <p>Initialize the application <code>MessageResources</code> for the specified\n     * module.</p>\n     *\n     * @param config ModuleConfig information for this module\n     *\n     * @exception ServletException if initialization cannot be performed\n     * @since Struts 1.1\n     */\n    protected void initModuleMessageResources(ModuleConfig config)\n        throws ServletException {\n\n        MessageResourcesConfig mrcs[] = config.findMessageResourcesConfigs();\n        for (int i = 0; i < mrcs.length; i++) {\n            if ((mrcs[i].getFactory() == null)\n                || (mrcs[i].getParameter() == null)) {\n                continue;\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\n                    \"Initializing module path '\"\n                        + config.getPrefix()\n                        + \"' message resources from '\"\n                        + mrcs[i].getParameter()\n                        + \"'\");\n            }\n\n            String factory = mrcs[i].getFactory();\n            MessageResourcesFactory.setFactoryClass(factory);\n            MessageResourcesFactory factoryObject =\n                MessageResourcesFactory.createFactory();\n            factoryObject.setConfig(mrcs[i]);\n\n            MessageResources resources =\n                factoryObject.createResources(mrcs[i].getParameter());\n            resources.setReturnNull(mrcs[i].getNull());\n            resources.setEscape(mrcs[i].isEscape());\n            getServletContext().setAttribute(\n                mrcs[i].getKey() + config.getPrefix(),\n                resources);\n        }\n\n    }\n\n\n    /**\n     * <p>Create (if needed) and return a new <code>Digester</code>\n     * instance that has been initialized to process Struts module\n     * configuration files and configure a corresponding <code>ModuleConfig</code>\n     * object (which must be pushed on to the evaluation stack before parsing\n     * begins).</p>\n     *\n     * @exception ServletException if a Digester cannot be configured\n     * @since Struts 1.1\n     */\n    protected Digester initConfigDigester() throws ServletException {\n\n        // :FIXME: Where can ServletException be thrown?\n\n        // Do we have an existing instance?\n        if (configDigester != null) {\n            return (configDigester);\n        }\n\n        // Create a new Digester instance with standard capabilities\n        configDigester = new Digester();\n        configDigester.setNamespaceAware(true);\n        configDigester.setValidating(this.isValidating());\n        configDigester.setUseContextClassLoader(true);\n        configDigester.addRuleSet(new ConfigRuleSet());\n\n        for (int i = 0; i < registrations.length; i += 2) {\n            URL url = this.getClass().getResource(registrations[i+1]);\n            if (url != null) {\n                configDigester.register(registrations[i], url.toString());\n            }\n        }\n\n        this.addRuleSets();\n\n        // Return the completely configured Digester instance\n        return (configDigester);\n    }\n\n\n    /**\n     * <p>Add any custom RuleSet instances to configDigester that have\n     * been specified in the <code>rulesets</code> init parameter.</p>\n     *\n     * @throws ServletException\n     */\n    private void addRuleSets() throws ServletException {\n\n        String rulesets = getServletConfig().getInitParameter(\"rulesets\");\n        if (rulesets == null) {\n            rulesets = \"\";\n        }\n\n        rulesets = rulesets.trim();\n        String ruleset = null;\n        while (rulesets.length() > 0) {\n            int comma = rulesets.indexOf(\",\");\n            if (comma < 0) {\n                ruleset = rulesets.trim();\n                rulesets = \"\";\n            } else {\n                ruleset = rulesets.substring(0, comma).trim();\n                rulesets = rulesets.substring(comma + 1).trim();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Configuring custom Digester Ruleset of type \" + ruleset);\n            }\n\n            try {\n                RuleSet instance = (RuleSet) RequestUtils.applicationInstance(ruleset);\n                this.configDigester.addRuleSet(instance);\n            } catch (Exception e) {\n                log.error(\"Exception configuring custom Digester RuleSet\", e);\n                throw new ServletException(e);\n            }\n        }\n    }\n\n\n    /**\n     * <p>Check the status of the <code>validating</code> initialization parameter.</p>\n     *\n     * @return true if the module Digester should validate.\n     */\n    private boolean isValidating() {\n\n        boolean validating = true;\n        String value = getServletConfig().getInitParameter(\"validating\");\n\n        if (\"false\".equalsIgnoreCase(value)\n            || \"no\".equalsIgnoreCase(value)\n            || \"n\".equalsIgnoreCase(value)\n            || \"0\".equalsIgnoreCase(value)) {\n\n            validating = false;\n        }\n\n        return validating;\n    }\n\n\n\n    /**\n     * <p>Initialize our internal MessageResources bundle.</p>\n     *\n     * @exception ServletException if we cannot initialize these resources\n     */\n    protected void initInternal() throws ServletException {\n\n        // :FIXME: Document UnavailableException\n\n        try {\n            internal = MessageResources.getMessageResources(internalName);\n        } catch (MissingResourceException e) {\n            log.error(\"Cannot load internal resources from '\" + internalName + \"'\",\n                e);\n            throw new UnavailableException\n                (\"Cannot load internal resources from '\" + internalName + \"'\");\n        }\n\n    }\n\n\n    /**\n     * <p>Initialize other global characteristics of the controller servlet.</p>\n     *\n     * @exception ServletException if we cannot initialize these resources\n     */\n    protected void initOther() throws ServletException {\n        HashSet suppressProperties = new HashSet();\n        suppressProperties.add(\"class\");\n        suppressProperties.add(\"multipartRequestHandler\");\n        suppressProperties.add(\"resultValueMap\");\n\n        PropertyUtils.addBeanIntrospector(\n                new SuppressPropertiesBeanIntrospector(suppressProperties));\n        PropertyUtils.clearDescriptors();\n\n        String value = null;\n        value = getServletConfig().getInitParameter(\"config\");\n        if (value != null) {\n            config = value;\n        }\n\n        // Backwards compatibility for form beans of Java wrapper classes\n        // Set to true for strict Struts 1.0 compatibility\n        value = getServletConfig().getInitParameter(\"convertNull\");\n        if (\"true\".equalsIgnoreCase(value)\n            || \"yes\".equalsIgnoreCase(value)\n            || \"on\".equalsIgnoreCase(value)\n            || \"y\".equalsIgnoreCase(value)\n            || \"1\".equalsIgnoreCase(value)) {\n\n            convertNull = true;\n        }\n\n        if (convertNull) {\n            ConvertUtils.deregister();\n            ConvertUtils.register(new BigDecimalConverter(null), BigDecimal.class);\n            ConvertUtils.register(new BigIntegerConverter(null), BigInteger.class);\n            ConvertUtils.register(new BooleanConverter(null), Boolean.class);\n            ConvertUtils.register(new ByteConverter(null), Byte.class);\n            ConvertUtils.register(new CharacterConverter(null), Character.class);\n            ConvertUtils.register(new DoubleConverter(null), Double.class);\n            ConvertUtils.register(new FloatConverter(null), Float.class);\n            ConvertUtils.register(new IntegerConverter(null), Integer.class);\n            ConvertUtils.register(new LongConverter(null), Long.class);\n            ConvertUtils.register(new ShortConverter(null), Short.class);\n        }\n\n    }\n\n\n    /**\n     * <p>Initialize the servlet mapping under which our controller servlet\n     * is being accessed.  This will be used in the <code>&html:form&gt;</code>\n     * tag to generate correct destination URLs for form submissions.</p>\n     *\n     * @throws ServletException if error happens while scanning web.xml\n     */\n    protected void initServlet() throws ServletException {\n\n        // Remember our servlet name\n        this.servletName = getServletConfig().getServletName();\n\n        // Prepare a Digester to scan the web application deployment descriptor\n        Digester digester = new Digester();\n        digester.push(this);\n        digester.setNamespaceAware(true);\n        digester.setValidating(false);\n\n        // Register our local copy of the DTDs that we can find\n        for (int i = 0; i < registrations.length; i += 2) {\n            URL url = this.getClass().getResource(registrations[i+1]);\n            if (url != null) {\n                digester.register(registrations[i], url.toString());\n            }\n        }\n\n        // Configure the processing rules that we need\n        digester.addCallMethod(\"web-app/servlet-mapping\",\n                               \"addServletMapping\", 2);\n        digester.addCallParam(\"web-app/servlet-mapping/servlet-name\", 0);\n        digester.addCallParam(\"web-app/servlet-mapping/url-pattern\", 1);\n\n        // Process the web application deployment descriptor\n        if (log.isDebugEnabled()) {\n            log.debug(\"Scanning web.xml for controller servlet mapping\");\n        }\n\n        InputStream input =\n            getServletContext().getResourceAsStream(\"/WEB-INF/web.xml\");\n\n        if (input == null) {\n            log.error(internal.getMessage(\"configWebXml\"));\n            throw new ServletException(internal.getMessage(\"configWebXml\"));\n        }\n\n        try {\n            digester.parse(input);\n\n        } catch (IOException e) {\n            log.error(internal.getMessage(\"configWebXml\"), e);\n            throw new ServletException(e);\n\n        } catch (SAXException e) {\n            log.error(internal.getMessage(\"configWebXml\"), e);\n            throw new ServletException(e);\n\n        } finally {\n            try {\n                input.close();\n            } catch (IOException e) {\n                log.error(internal.getMessage(\"configWebXml\"), e);\n                throw new ServletException(e);\n            }\n        }\n\n        // Record a servlet context attribute (if appropriate)\n        if (log.isDebugEnabled()) {\n            log.debug(\"Mapping for servlet '\" + servletName + \"' = '\" +\n                servletMapping + \"'\");\n        }\n\n        if (servletMapping != null) {\n            getServletContext().setAttribute(Globals.SERVLET_KEY, servletMapping);\n        }\n\n    }\n\n\n    /**\n     * <p>Perform the standard request processing for this request, and create\n     * the corresponding response.</p>\n     *\n     * @param request The servlet request we are processing\n     * @param response The servlet response we are creating\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet exception is thrown\n     */\n    protected void process(HttpServletRequest request, HttpServletResponse response)\n        throws IOException, ServletException {\n\n        ModuleUtils.getInstance().selectModule(request, getServletContext());\n        ModuleConfig config = getModuleConfig(request);\n\n        RequestProcessor processor = getProcessorForModule(config);\n        if (processor == null) {\n           processor = getRequestProcessor(config);\n        }\n        processor.process(request, response);\n\n    }\n\n}\n", "target": 0}
{"idx": 912, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.search;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.fail;\n\nimport hudson.model.FreeStyleProject;\nimport hudson.model.ListView;\n\nimport java.net.URL;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport net.sf.json.JSONArray;\nimport net.sf.json.JSONObject;\nimport net.sf.json.JSONSerializer;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.JenkinsRule.WebClient;\nimport org.jvnet.hudson.test.MockFolder;\n\nimport com.gargoylesoftware.htmlunit.AlertHandler;\nimport com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;\nimport com.gargoylesoftware.htmlunit.Page;\n\n/**\n * @author Kohsuke Kawaguchi\n */\npublic class SearchTest {\n  \n    @Rule public JenkinsRule j = new JenkinsRule();\n    \n    /**\n     * No exact match should result in a failure status code.\n     */\n    @Test\n    public void testFailure() throws Exception {\n        try {\n            j.search(\"no-such-thing\");\n            fail(\"404 expected\");\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(404,e.getResponse().getStatusCode());\n        }\n    }\n\n    /**\n     * Makes sure the script doesn't execute.\n     */\n    @Issue(\"JENKINS-3415\")\n    @Test\n    public void testXSS() throws Exception {\n        try {\n            WebClient wc = j.createWebClient();\n            wc.setAlertHandler(new AlertHandler() {\n                public void handleAlert(Page page, String message) {\n                    throw new AssertionError();\n                }\n            });\n            wc.search(\"<script>alert('script');</script>\");\n            fail(\"404 expected\");\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(404,e.getResponse().getStatusCode());\n        }\n    }\n    \n    @Test\n    public void testSearchByProjectName() throws Exception {\n        final String projectName = \"testSearchByProjectName\";\n        \n        j.createFreeStyleProject(projectName);\n        \n        Page result = j.search(projectName);\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n        \n        // make sure we've fetched the testSearchByDisplayName project page\n        String contents = result.getWebResponse().getContentAsString();\n        assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]</title>\", projectName)));\n    }\n\n    @Issue(\"JENKINS-24433\")\n    @Test\n    public void testSearchByProjectNameBehindAFolder() throws Exception {\n        FreeStyleProject myFreeStyleProject = j.createFreeStyleProject(\"testSearchByProjectName\");\n        MockFolder myMockFolder = j.createFolder(\"my-folder-1\");\n\n        Page result = j.createWebClient().goTo(myMockFolder.getUrl() + \"search?q=\"+ myFreeStyleProject.getName());\n\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        URL resultUrl = result.getUrl();\n        assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));\n    }\n\n    @Issue(\"JENKINS-24433\")\n    @Test\n    public void testSearchByProjectNameInAFolder() throws Exception {\n\n        MockFolder myMockFolder = j.createFolder(\"my-folder-1\");\n        FreeStyleProject myFreeStyleProject = myMockFolder.createProject(FreeStyleProject.class, \"my-job-1\");\n\n        Page result = j.createWebClient().goTo(myMockFolder.getUrl() + \"search?q=\" + myFreeStyleProject.getFullName());\n\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        URL resultUrl = result.getUrl();\n        assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));\n    }\n\n    @Test\n    public void testSearchByDisplayName() throws Exception {\n        final String displayName = \"displayName9999999\";\n        \n        FreeStyleProject project = j.createFreeStyleProject(\"testSearchByDisplayName\");\n        project.setDisplayName(displayName);\n        \n        Page result = j.search(displayName);\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n        \n        // make sure we've fetched the testSearchByDisplayName project page\n        String contents = result.getWebResponse().getContentAsString();\n        assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]</title>\", displayName)));\n    }\n    \n    @Test\n    public void testSearch2ProjectsWithSameDisplayName() throws Exception {\n        // create 2 freestyle projects with the same display name\n        final String projectName1 = \"projectName1\";\n        final String projectName2 = \"projectName2\";\n        final String projectName3 = \"projectName3\";\n        final String displayName = \"displayNameFoo\";\n        final String otherDisplayName = \"otherDisplayName\";\n        \n        FreeStyleProject project1 = j.createFreeStyleProject(projectName1);\n        project1.setDisplayName(displayName);\n        FreeStyleProject project2 = j.createFreeStyleProject(projectName2);\n        project2.setDisplayName(displayName);\n        FreeStyleProject project3 = j.createFreeStyleProject(projectName3);\n        project3.setDisplayName(otherDisplayName);\n\n        // make sure that on search we get back one of the projects, it doesn't\n        // matter which one as long as the one that is returned has displayName\n        // as the display name\n        Page result = j.search(displayName);\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        // make sure we've fetched the testSearchByDisplayName project page\n        String contents = result.getWebResponse().getContentAsString();\n        assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]</title>\", displayName)));\n        assertFalse(contents.contains(otherDisplayName));\n    }\n    \n    @Test\n    public void testProjectNamePrecedesDisplayName() throws Exception {\n        final String project1Name = \"foo\";\n        final String project1DisplayName = \"project1DisplayName\";\n        final String project2Name = \"project2Name\";\n        final String project2DisplayName = project1Name;\n        final String project3Name = \"project3Name\";\n        final String project3DisplayName = \"project3DisplayName\";\n        \n        // create 1 freestyle project with the name foo\n        FreeStyleProject project1 = j.createFreeStyleProject(project1Name);\n        project1.setDisplayName(project1DisplayName);\n        \n        // create another with the display name foo\n        FreeStyleProject project2 = j.createFreeStyleProject(project2Name);\n        project2.setDisplayName(project2DisplayName);\n\n        // create a third project and make sure it's not picked up by search\n        FreeStyleProject project3 = j.createFreeStyleProject(project3Name);\n        project3.setDisplayName(project3DisplayName);\n        \n        // search for foo\n        Page result = j.search(project1Name);\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n        \n        // make sure we get the project with the name foo\n        String contents = result.getWebResponse().getContentAsString();\n        assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]</title>\", project1DisplayName)));\n        // make sure projects 2 and 3 were not picked up\n        assertFalse(contents.contains(project2Name));\n        assertFalse(contents.contains(project3Name));\n        assertFalse(contents.contains(project3DisplayName));\n    }\n    \n    @Test\n    public void testGetSuggestionsHasBothNamesAndDisplayNames() throws Exception {\n        final String projectName = \"project name\";\n        final String displayName = \"display name\";\n\n        FreeStyleProject project1 = j.createFreeStyleProject(projectName);\n        project1.setDisplayName(displayName);\n        \n        WebClient wc = j.createWebClient();\n        Page result = wc.goTo(\"search/suggest?query=name\", \"application/json\");\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n        \n        String content = result.getWebResponse().getContentAsString();\n        System.out.println(content);\n        JSONObject jsonContent = (JSONObject)JSONSerializer.toJSON(content);\n        assertNotNull(jsonContent);\n        JSONArray jsonArray = jsonContent.getJSONArray(\"suggestions\");\n        assertNotNull(jsonArray);\n        \n        assertEquals(2, jsonArray.size());\n        \n        boolean foundProjectName = false;\n        boolean foundDispayName = false;\n        for(Object suggestion : jsonArray) {\n            JSONObject jsonSuggestion = (JSONObject)suggestion;\n            \n            String name = (String)jsonSuggestion.get(\"name\");\n            if(projectName.equals(name)) {\n                foundProjectName = true;\n            }\n            else if(displayName.equals(name)) {\n                foundDispayName = true;\n            }\n        }\n\n        assertTrue(foundProjectName);\n        assertTrue(foundDispayName);\n    }\n\n    @Issue(\"JENKINS-24433\")\n    @Test\n    public void testProjectNameBehindAFolderDisplayName() throws Exception {\n        final String projectName1 = \"job-1\";\n        final String displayName1 = \"job-1 display\";\n\n        final String projectName2 = \"job-2\";\n        final String displayName2 = \"job-2 display\";\n\n        FreeStyleProject project1 = j.createFreeStyleProject(projectName1);\n        project1.setDisplayName(displayName1);\n\n        MockFolder myMockFolder = j.createFolder(\"my-folder-1\");\n\n        FreeStyleProject project2 = myMockFolder.createProject(FreeStyleProject.class, projectName2);\n        project2.setDisplayName(displayName2);\n\n        WebClient wc = j.createWebClient();\n        Page result = wc.goTo(myMockFolder.getUrl() + \"search/suggest?query=\" + projectName1, \"application/json\");\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        String content = result.getWebResponse().getContentAsString();\n        JSONObject jsonContent = (JSONObject)JSONSerializer.toJSON(content);\n        assertNotNull(jsonContent);\n        JSONArray jsonArray = jsonContent.getJSONArray(\"suggestions\");\n        assertNotNull(jsonArray);\n\n        assertEquals(2, jsonArray.size());\n\n        boolean foundDisplayName = false;\n        for(Object suggestion : jsonArray) {\n            JSONObject jsonSuggestion = (JSONObject)suggestion;\n\n            String name = (String)jsonSuggestion.get(\"name\");\n            if(projectName1.equals(name)) {\n                foundDisplayName = true;\n            }\n        }\n\n        assertTrue(foundDisplayName);\n    }\n\n    @Issue(\"JENKINS-24433\")\n    @Test\n    public void testProjectNameInAFolderDisplayName() throws Exception {\n        final String projectName1 = \"job-1\";\n        final String displayName1 = \"job-1 display\";\n\n        final String projectName2 = \"job-2\";\n        final String displayName2 = \"my-folder-1 job-2\";\n\n        FreeStyleProject project1 = j.createFreeStyleProject(projectName1);\n        project1.setDisplayName(displayName1);\n\n        MockFolder myMockFolder = j.createFolder(\"my-folder-1\");\n\n        FreeStyleProject project2 = myMockFolder.createProject(FreeStyleProject.class, projectName2);\n        project2.setDisplayName(displayName2);\n\n        WebClient wc = j.createWebClient();\n        Page result = wc.goTo(myMockFolder.getUrl() + \"search/suggest?query=\" + projectName2, \"application/json\");\n        assertNotNull(result);\n        j.assertGoodStatus(result);\n\n        String content = result.getWebResponse().getContentAsString();\n        JSONObject jsonContent = (JSONObject)JSONSerializer.toJSON(content);\n        assertNotNull(jsonContent);\n        JSONArray jsonArray = jsonContent.getJSONArray(\"suggestions\");\n        assertNotNull(jsonArray);\n\n        assertEquals(1, jsonArray.size());\n\n        boolean foundDisplayName = false;\n        for(Object suggestion : jsonArray) {\n            JSONObject jsonSuggestion = (JSONObject)suggestion;\n\n            String name = (String)jsonSuggestion.get(\"name\");\n\n            if(displayName2.equals(name)) {\n                foundDisplayName = true;\n            }\n        }\n\n        assertTrue(foundDisplayName);\n    }\n\n    /**\n     * Disable/enable status shouldn't affect the search\n     */\n    @Issue(\"JENKINS-13148\")\n    @Test\n    public void testDisabledJobShouldBeSearchable() throws Exception {\n        FreeStyleProject p = j.createFreeStyleProject(\"foo-bar\");\n        assertTrue(suggest(j.jenkins.getSearchIndex(), \"foo\").contains(p));\n\n        p.disable();\n        assertTrue(suggest(j.jenkins.getSearchIndex(), \"foo\").contains(p));\n    }\n\n    /**\n     * All top-level jobs should be searchable, not just jobs in the current view.\n     */\n    @Issue(\"JENKINS-13148\")\n    @Test\n    public void testCompletionOutsideView() throws Exception {\n        FreeStyleProject p = j.createFreeStyleProject(\"foo-bar\");\n        ListView v = new ListView(\"empty1\",j.jenkins);\n        ListView w = new ListView(\"empty2\",j.jenkins);\n        j.jenkins.addView(v);\n        j.jenkins.addView(w);\n        j.jenkins.setPrimaryView(w);\n\n        // new view should be empty\n        assertFalse(v.contains(p));\n        assertFalse(w.contains(p));\n        assertFalse(j.jenkins.getPrimaryView().contains(p));\n\n        assertTrue(suggest(j.jenkins.getSearchIndex(),\"foo\").contains(p));\n    }\n    \n    @Test\n    public void testSearchWithinFolders() throws Exception {\n        MockFolder folder1 = j.createFolder(\"folder1\");\n        FreeStyleProject p1 = folder1.createProject(FreeStyleProject.class, \"myjob\");\n        MockFolder folder2 = j.createFolder(\"folder2\");\n        FreeStyleProject p2 = folder2.createProject(FreeStyleProject.class, \"myjob\");\n        List<SearchItem> suggest = suggest(j.jenkins.getSearchIndex(), \"myjob\");\n        assertTrue(suggest.contains(p1));\n        assertTrue(suggest.contains(p2));\n    }\n\n    private List<SearchItem> suggest(SearchIndex index, String term) {\n        List<SearchItem> result = new ArrayList<SearchItem>();\n        index.suggest(term, result);\n        return result;\n    }\n}\n", "target": 1}
{"idx": 913, "func": "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.kernel.security;\n\nimport org.apache.commons.io.IOUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.crypto.codec.Hex;\nimport org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.Objects;\n\n/**\n * This implements a zero-configuration version Spring Security's token based remember-me service. While the key can\n * still be augmented by configuration, it is generally generated based on seldom changing but unique system\n * properties like hostname, IP address, file system information and Linux kernel.\n */\npublic class SystemTokenBasedRememberMeService extends TokenBasedRememberMeServices {\n  private Logger logger = LoggerFactory.getLogger(SystemTokenBasedRememberMeService.class);\n  private String key;\n\n  @Deprecated\n  public SystemTokenBasedRememberMeService() {\n    super();\n    setKey(null);\n  }\n\n  public SystemTokenBasedRememberMeService(String key, UserDetailsService userDetailsService) {\n    super(key, userDetailsService);\n    setKey(key);\n  }\n\n  /**\n   * Set a new key to be used when generating remember-me tokens.\n   *\n   * Note that the key passed to this method will be augmented by seldom changing but generally unique system\n   * properties like hostname, IP address, file system information and Linux kernel. Hence, even setting no custom\n   * key should be save.\n   */\n  @Override\n  public void setKey(String key) {\n    // Start with a user key if provided\n    StringBuilder keyBuilder = new StringBuilder(Objects.toString(key, \"\"));\n\n    // This will give us the hostname and IP address as something which should be unique per system.\n    // For example: lk.elan-ev.de/10.10.10.31\n    try {\n      keyBuilder.append(InetAddress.getLocalHost());\n    } catch (UnknownHostException e) {\n      // silently ignore this\n    }\n\n    // Gather additional system properties as key\n    // This requires a proc-fs which should generally be available under Linux.\n    // But even without, we have fallbacks above and below.\n    for (String procFile: Arrays.asList(\"/proc/version\", \"/proc/partitions\")) {\n      try (FileInputStream fileInputStream = new FileInputStream(new File(procFile))) {\n        keyBuilder.append(IOUtils.toString(fileInputStream, StandardCharsets.UTF_8));\n      } catch (IOException e) {\n        // ignore this\n      }\n    }\n\n    // If we still have no proper key, just generate a random one.\n    // This will work just fine with the single drawback that restarting Opencast invalidates all remember-me tokens.\n    // But it should be a sufficiently good fallback.\n    key = keyBuilder.toString();\n    if (key.isEmpty()) {\n      logger.warn(\"Could not generate semi-persistent remember-me key. Will generate a non-persistent random one.\");\n      key = Double.toString(Math.random());\n    }\n    logger.debug(\"Remember me key before hashing: {}\", key);\n\n    // Use a SHA-512 hash as key to have a more sane key.\n    try {\n      MessageDigest digest = MessageDigest.getInstance(\"SHA-512\");\n      key = new String(Hex.encode(digest.digest(key.getBytes())));\n    } catch (NoSuchAlgorithmException e) {\n      logger.warn(\"No SHA-512 algorithm available!\");\n    }\n    logger.debug(\"Calculated remember me key: {}\", key);\n    this.key = key;\n    super.setKey(key);\n  }\n\n  @Override\n  public String getKey() {\n    return this.key;\n  }\n\n  /**\n   * Calculates the digital signature to be put in the cookie. Default value is\n   * SHA-512 (\"username:tokenExpiryTime:password:key\")\n   */\n  @Override\n  protected String makeTokenSignature(long tokenExpiryTime, String username, String password) {\n    String data = username + \":\" + tokenExpiryTime + \":\" + password + \":\" + getKey();\n    MessageDigest digest;\n    try {\n      digest = MessageDigest.getInstance(\"SHA-512\");\n    } catch (NoSuchAlgorithmException e) {\n      throw new IllegalStateException(\"No SHA-512 algorithm available!\");\n    }\n\n    return new String(Hex.encode(digest.digest(data.getBytes())));\n  }\n}\n", "target": 0}
{"idx": 914, "func": "/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n * \n * Copyright (c) 1997-2016 Oracle and/or its affiliates. All rights reserved.\n * \n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common Development\n * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n * may not use this file except in compliance with the License.  You can\n * obtain a copy of the License at\n * https://glassfish.java.net/public/CDDL+GPL_1_1.html\n * or packager/legal/LICENSE.txt.  See the License for the specific\n * language governing permissions and limitations under the License.\n * \n * When distributing the software, include this License Header Notice in each\n * file and include the License file at packager/legal/LICENSE.txt.\n * \n * GPL Classpath Exception:\n * Oracle designates this particular file as subject to the \"Classpath\"\n * exception as provided by Oracle in the GPL Version 2 section of the License\n * file that accompanied this code.\n * \n * Modifications:\n * If applicable, add the following below the License Header, with the fields\n * enclosed by brackets [] replaced by your own identifying information:\n * \"Portions Copyright [year] [name of copyright owner]\"\n * \n * Contributor(s):\n * If you wish your version of this file to be governed by only the CDDL or\n * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n * elects to include this software in this distribution under the [CDDL or GPL\n * Version 2] license.\"  If you don't indicate a single choice of license, a\n * recipient has the option to distribute your version of this file under\n * either the CDDL, the GPL Version 2 or to extend the choice of license to\n * its licensees as provided above.  However, if you add GPL Version 2 code\n * and therefore, elected the GPL Version 2 license, then the option applies\n * only if the new code is made subject to such option by the copyright\n * holder.\n\n */\npackage com.sun.faces.lifecycle;\n\nimport static com.sun.faces.renderkit.RenderKitUtils.PredefinedPostbackParameter.CLIENT_WINDOW_PARAM;\n\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport javax.faces.component.UINamingContainer;\nimport javax.faces.context.ExternalContext;\nimport javax.faces.context.FacesContext;\nimport javax.faces.lifecycle.ClientWindow;\nimport javax.faces.render.ResponseStateManager;\nimport javax.faces.FacesException;\n\npublic class ClientWindowImpl extends ClientWindow {\n    \n    String id;\n\n    public ClientWindowImpl() {\n    }\n\n    @Override\n    public Map<String, String> getQueryURLParameters(FacesContext context) {\n        return null;\n    }\n    \n    \n\n    @Override\n    public void decode(FacesContext context) {\n        Map<String, String> requestParamMap = context.getExternalContext().getRequestParameterMap();\n        if (isClientWindowRenderModeEnabled(context)) {\n            id = requestParamMap.get(ResponseStateManager.CLIENT_WINDOW_URL_PARAM);\n        }\n        // The hidden field always takes precedence, if present.\n        String paramName = CLIENT_WINDOW_PARAM.getName(context);\n        if (requestParamMap.containsKey(paramName)) {\n            id = requestParamMap.get(paramName);\n            Pattern safePattern = Pattern.compile(\".*<(.*:script|script).*>[^&]*</\\\\s*\\\\1\\\\s*>.*\");\n            if (safePattern.matcher(id).matches()) {\n                throw new FacesException(\"ClientWindow is illegal: \" + id);\n            }\n        }\n        if (null == id) {\n            id = calculateClientWindow(context);\n        }\n    }\n    \n    private String calculateClientWindow(FacesContext context) {\n        synchronized(context.getExternalContext().getSession(true)) {\n            final String clientWindowCounterKey = \"com.sun.faces.lifecycle.ClientWindowCounterKey\";\n            ExternalContext extContext = context.getExternalContext();\n            Map<String, Object> sessionAttrs = extContext.getSessionMap();\n            Integer counter = (Integer) sessionAttrs.get(clientWindowCounterKey);\n            if (null == counter) {\n                counter = Integer.valueOf(0);\n            }\n            char sep = UINamingContainer.getSeparatorChar(context);\n            id = extContext.getSessionId(true) + sep +\n                    + counter;\n\n            sessionAttrs.put(clientWindowCounterKey, ++counter);\n        }\n        return id;\n    }\n\n    @Override\n    public String getId() {\n        return id;\n    }\n}\n", "target": 1}
{"idx": 915, "func": "package org.airsonic.player.security;\n\nimport org.airsonic.player.service.JWTSecurityService;\nimport org.airsonic.player.service.SecurityService;\nimport org.airsonic.player.service.SettingsService;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.security.SecurityProperties;\nimport org.springframework.context.ApplicationEventPublisher;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;\nimport org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter;\nimport org.springframework.security.web.util.matcher.AntPathRequestMatcher;\n\n@Configuration\n@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)\n@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true)\npublic class GlobalSecurityConfig extends GlobalAuthenticationConfigurerAdapter {\n\n    private static Logger logger = LoggerFactory.getLogger(GlobalSecurityConfig.class);\n\n    static final String FAILURE_URL = \"/login?error=1\";\n\n    @Autowired\n    private SecurityService securityService;\n\n    @Autowired\n    private CsrfSecurityRequestMatcher csrfSecurityRequestMatcher;\n\n    @Autowired\n    SettingsService settingsService;\n\n    @Autowired\n    CustomUserDetailsContextMapper customUserDetailsContextMapper;\n\n    @Autowired\n    ApplicationEventPublisher eventPublisher;\n\n    @Autowired\n    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n        if (settingsService.isLdapEnabled()) {\n            auth.ldapAuthentication()\n                    .contextSource()\n                        .managerDn(settingsService.getLdapManagerDn())\n                        .managerPassword(settingsService.getLdapManagerPassword())\n                        .url(settingsService.getLdapUrl())\n                    .and()\n                    .userSearchFilter(settingsService.getLdapSearchFilter())\n                    .userDetailsContextMapper(customUserDetailsContextMapper);\n        }\n        auth.userDetailsService(securityService);\n        String jwtKey = settingsService.getJWTKey();\n        if(StringUtils.isBlank(jwtKey)) {\n            logger.warn(\"Generating new jwt key\");\n            jwtKey = JWTSecurityService.generateKey();\n            settingsService.setJWTKey(jwtKey);\n            settingsService.save();\n        }\n        auth.authenticationProvider(new JWTAuthenticationProvider(jwtKey));\n    }\n\n\n    @Configuration\n    @Order(1)\n    public class ExtSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n        public ExtSecurityConfiguration() {\n            super(true);\n        }\n\n        @Bean(name = \"jwtAuthenticationFilter\")\n        public JWTRequestParameterProcessingFilter jwtAuthFilter() throws Exception {\n            return new JWTRequestParameterProcessingFilter(authenticationManager(), FAILURE_URL);\n        }\n\n        @Override\n        protected void configure(HttpSecurity http) throws Exception {\n\n            http = http.addFilter(new WebAsyncManagerIntegrationFilter());\n            http = http.addFilterBefore(jwtAuthFilter(), UsernamePasswordAuthenticationFilter.class);\n\n            http\n                    .antMatcher(\"/ext/**\")\n                    .csrf().requireCsrfProtectionMatcher(csrfSecurityRequestMatcher).and()\n                    .headers().frameOptions().sameOrigin().and()\n                    .authorizeRequests()\n                    .antMatchers(\"/ext/stream/**\", \"/ext/coverArt*\", \"/ext/share/**\", \"/ext/hls/**\")\n                    .hasAnyRole(\"TEMP\", \"USER\").and()\n                    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n                    .exceptionHandling().and()\n                    .securityContext().and()\n                    .requestCache().and()\n                    .anonymous().and()\n                    .servletApi();\n        }\n    }\n\n    @Configuration\n    @Order(2)\n    public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n        @Override\n        protected void configure(HttpSecurity http) throws Exception {\n\n            RESTRequestParameterProcessingFilter restAuthenticationFilter = new RESTRequestParameterProcessingFilter();\n            restAuthenticationFilter.setAuthenticationManager(authenticationManagerBean());\n            restAuthenticationFilter.setSecurityService(securityService);\n            restAuthenticationFilter.setEventPublisher(eventPublisher);\n            http = http.addFilterBefore(restAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);\n\n            http\n                    .csrf()\n                    .requireCsrfProtectionMatcher(csrfSecurityRequestMatcher)\n                    .and().headers()\n                    .frameOptions()\n                    .sameOrigin()\n                    .and().authorizeRequests()\n                    .antMatchers(\"/recover*\", \"/accessDenied*\",\n                            \"/style/**\", \"/icons/**\", \"/flash/**\", \"/script/**\",\n                            \"/sonos/**\", \"/crossdomain.xml\", \"/login\", \"/error\")\n                    .permitAll()\n                    .antMatchers(\"/personalSettings*\", \"/passwordSettings*\",\n                            \"/playerSettings*\", \"/shareSettings*\", \"/passwordSettings*\")\n                    .hasRole(\"SETTINGS\")\n                    .antMatchers(\"/generalSettings*\", \"/advancedSettings*\", \"/userSettings*\",\n                            \"/musicFolderSettings*\", \"/databaseSettings*\", \"/transcodeSettings*\", \"/rest/startScan*\")\n                    .hasRole(\"ADMIN\")\n                    .antMatchers(\"/deletePlaylist*\", \"/savePlaylist*\", \"/db*\")\n                    .hasRole(\"PLAYLIST\")\n                    .antMatchers(\"/download*\")\n                    .hasRole(\"DOWNLOAD\")\n                    .antMatchers(\"/upload*\")\n                    .hasRole(\"UPLOAD\")\n                    .antMatchers(\"/createShare*\")\n                    .hasRole(\"SHARE\")\n                    .antMatchers(\"/changeCoverArt*\", \"/editTags*\")\n                    .hasRole(\"COVERART\")\n                    .antMatchers(\"/setMusicFileInfo*\")\n                    .hasRole(\"COMMENT\")\n                    .antMatchers(\"/podcastReceiverAdmin*\")\n                    .hasRole(\"PODCAST\")\n                    .antMatchers(\"/**\")\n                    .hasRole(\"USER\")\n                    .anyRequest().authenticated()\n                    .and().formLogin()\n                    .loginPage(\"/login\")\n                    .permitAll()\n                    .defaultSuccessUrl(\"/index\", true)\n                    .failureUrl(FAILURE_URL)\n                    .usernameParameter(\"j_username\")\n                    .passwordParameter(\"j_password\")\n                    // see http://docs.spring.io/spring-security/site/docs/3.2.4.RELEASE/reference/htmlsingle/#csrf-logout\n                    .and().logout().logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\", \"GET\")).logoutSuccessUrl(\n                    \"/login?logout\")\n                    .and().rememberMe().key(\"airsonic\");\n        }\n\n    }\n}", "target": 1}
{"idx": 916, "func": "/*\n * Copyright (c) 2020 Gobierno de Espaa\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * SPDX-License-Identifier: MPL-2.0\n */\npackage org.dpppt.backend.sdk.ws.radarcovid.config;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.dpppt.backend.sdk.ws.radarcovid.annotation.ResponseRetention;\nimport org.dpppt.backend.sdk.ws.radarcovid.exception.RadarCovidServerException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.core.env.Environment;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.stereotype.Component;\n\n/**\n * Aspect in charge of controlling the minimum response time of a service.\n */\n@Configuration\n@ConditionalOnProperty(name = \"application.response.retention.enabled\", havingValue = \"true\", matchIfMissing = true)\npublic class ResponseRetentionAspectConfiguration {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(\"org.dpppt.backend.sdk.ws.radarcovid.annotation.ResponseRetention\");\n\t\n\t@Autowired\n\tprivate Environment environment;\n\t\n    @Aspect\n    @Order(0)\n    @Component\n    public class ControllerTimeResponseControlAspect {\n\n        @Pointcut(\"@annotation(responseRetention)\")\n        public void annotationPointCutDefinition(ResponseRetention responseRetention){\n        }\n        \n\t\t@Around(\"execution(@org.dpppt.backend.sdk.ws.radarcovid.annotation.ResponseRetention * *..controller..*(..)) && annotationPointCutDefinition(responseRetention)\")\n        public Object logAround(ProceedingJoinPoint joinPoint, ResponseRetention responseRetention) throws Throwable {\n\n        \tlog.debug(\"************************* INIT TIME RESPONSE CONTROL *********************************\");\n            long start = System.currentTimeMillis();\n            try {\n                String className = joinPoint.getSignature().getDeclaringTypeName();\n                String methodName = joinPoint.getSignature().getName();\n                Object result = joinPoint.proceed();\n                long elapsedTime = System.currentTimeMillis() - start;\n                long responseRetentionTimeMillis = getTimeMillis(responseRetention.time());\n                log.debug(\"Controller : Controller {}.{} () execution time : {} ms\", className, methodName, elapsedTime);\n                if (elapsedTime < responseRetentionTimeMillis) {\n                \ttry {\n                \t\tThread.sleep(responseRetentionTimeMillis - elapsedTime);\n                \t} catch (InterruptedException e) {\n                \t\tlog.warn(\"Controller : Controller {}.{} () Thread sleep interrupted\", className, methodName);\n                \t}\n                }\n                elapsedTime = System.currentTimeMillis() - start;\n                log.debug(\"Controller : Controller {}.{} () NEW execution time : {} ms\", className, methodName, elapsedTime);\n                log.debug(\"************************* END TIME RESPONSE CONTROL **********************************\");\n                return result;\n\n            } catch (IllegalArgumentException e) {\n\t\t\t\tlog.error(\"Controller : Illegal argument {} in {} ()\", Arrays.toString(joinPoint.getArgs()),\n\t\t\t\t\t\tjoinPoint.getSignature().getName());\n\t\t\t\tlog.debug(\"************************* END TIME RESPONSE CONTROL **********************************\");\n                throw e;\n            }\n        }\n        \n\t\tprivate long getTimeMillis(String timeMillisString) {\n\t\t\tString stringValue = environment.getProperty(timeMillisString);\n\t\t\tif (NumberUtils.isCreatable(stringValue)) {\n\t\t\t\treturn Long.parseLong(stringValue);\n\t\t\t} else {\n\t\t\t\tthrow new RadarCovidServerException(HttpStatus.INTERNAL_SERVER_ERROR,\n\t\t\t\t\t\t\"Invalid timeMillisString value \\\"\" + timeMillisString + \"\\\" - not found or cannot parse into long\");\n\t\t\t}\n\t\t}\n    }\n\n}\n", "target": 0}
{"idx": 917, "func": "/*\n * The MIT License\n *\n * Copyright (c) 2004-2011, Yahoo!, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage jenkins.model;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.containsString;\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.fail;\n\nimport com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;\nimport com.gargoylesoftware.htmlunit.HttpMethod;\nimport com.gargoylesoftware.htmlunit.Page;\nimport com.gargoylesoftware.htmlunit.WebRequest;\nimport com.gargoylesoftware.htmlunit.WebResponse;\nimport com.gargoylesoftware.htmlunit.html.HtmlForm;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\n\nimport hudson.maven.MavenModuleSet;\nimport hudson.maven.MavenModuleSetBuild;\nimport hudson.model.Failure;\nimport hudson.model.RestartListener;\nimport hudson.model.RootAction;\nimport hudson.model.UnprotectedRootAction;\nimport hudson.model.User;\nimport hudson.security.FullControlOnceLoggedInAuthorizationStrategy;\nimport hudson.security.HudsonPrivateSecurityRealm;\nimport hudson.util.HttpResponses;\nimport hudson.model.FreeStyleProject;\nimport hudson.security.GlobalMatrixAuthorizationStrategy;\nimport hudson.security.LegacySecurityRealm;\nimport hudson.security.Permission;\nimport hudson.slaves.ComputerListener;\nimport hudson.slaves.DumbSlave;\nimport hudson.slaves.OfflineCause;\nimport hudson.util.FormValidation;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.ExtractResourceSCM;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.JenkinsRule.WebClient;\nimport org.jvnet.hudson.test.TestExtension;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mockito;\n\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n/**\n * @author kingfai\n *\n */\npublic class JenkinsTest {\n\n    @Rule public JenkinsRule j = new JenkinsRule();\n\n    @Test\n    public void testIsDisplayNameUniqueTrue() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(\"displayName\");\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertTrue(jenkins.isDisplayNameUnique(\"displayName1\", curJobName));\n        assertTrue(jenkins.isDisplayNameUnique(jobName, curJobName));\n    }\n\n    @Test\n    public void testIsDisplayNameUniqueFalse() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        final String displayName = \"displayName\";\n        \n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertFalse(jenkins.isDisplayNameUnique(displayName, curJobName));\n    }\n    \n    @Test\n    public void testIsDisplayNameUniqueSameAsCurrentJob() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String displayName = \"currentProjectDisplayName\";\n        \n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        // should be true as we don't test against the current job\n        assertTrue(jenkins.isDisplayNameUnique(displayName, curJobName));\n    }\n    \n    @Test\n    public void testIsNameUniqueTrue() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        j.createFreeStyleProject(curJobName);\n        j.createFreeStyleProject(jobName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertTrue(jenkins.isNameUnique(\"jobName1\", curJobName));\n    }\n\n    @Test\n    public void testIsNameUniqueFalse() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        j.createFreeStyleProject(curJobName);\n        j.createFreeStyleProject(jobName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertFalse(jenkins.isNameUnique(jobName, curJobName));\n    }\n\n    @Test\n    public void testIsNameUniqueSameAsCurrentJob() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        j.createFreeStyleProject(curJobName);\n        j.createFreeStyleProject(jobName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        // true because we don't test against the current job\n        assertTrue(jenkins.isNameUnique(curJobName, curJobName));\n    }\n    \n    @Test\n    public void testDoCheckDisplayNameUnique() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(\"displayName\");\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        FormValidation v = jenkins.doCheckDisplayName(\"1displayName\", curJobName);\n        assertEquals(FormValidation.ok(), v);\n    }\n\n    @Test\n    public void testDoCheckDisplayNameSameAsDisplayName() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        final String displayName = \"displayName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        FormValidation v = jenkins.doCheckDisplayName(displayName, curJobName);\n        assertEquals(FormValidation.Kind.WARNING, v.kind);\n    }\n\n    @Test\n    public void testDoCheckDisplayNameSameAsJobName() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        final String displayName = \"displayName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        FormValidation v = jenkins.doCheckDisplayName(jobName, curJobName);\n        assertEquals(FormValidation.Kind.WARNING, v.kind);\n    }\n\n    @Test\n    public void testDoCheckViewName_GoodName() throws Exception {\n        String[] viewNames = new String[] {\n            \"\", \"Jenkins\"    \n        };\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        for (String viewName : viewNames) {\n            FormValidation v = jenkins.doCheckViewName(viewName);\n            assertEquals(FormValidation.Kind.OK, v.kind);\n        }\n    }\n\n    @Test\n    public void testDoCheckViewName_NotGoodName() throws Exception {\n        String[] viewNames = new String[] {\n            \"Jenkins?\", \"Jenkins*\", \"Jenkin/s\", \"Jenkin\\\\s\", \"jenkins%\", \n            \"Jenkins!\", \"Jenkins[]\", \"Jenkin<>s\", \"^Jenkins\", \"..\"    \n        };\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        \n        for (String viewName : viewNames) {\n            FormValidation v = jenkins.doCheckViewName(viewName);\n            assertEquals(FormValidation.Kind.ERROR, v.kind);\n        }\n    }\n    \n    @Test @Issue(\"JENKINS-12251\")\n    public void testItemFullNameExpansion() throws Exception {\n        HtmlForm f = j.createWebClient().goTo(\"configure\").getFormByName(\"config\");\n        f.getInputByName(\"_.rawBuildsDir\").setValueAttribute(\"${JENKINS_HOME}/test12251_builds/${ITEM_FULL_NAME}\");\n        f.getInputByName(\"_.rawWorkspaceDir\").setValueAttribute(\"${JENKINS_HOME}/test12251_ws/${ITEM_FULL_NAME}\");\n        j.submit(f);\n\n        // build a dummy project\n        MavenModuleSet m = j.createMavenProject();\n        m.setScm(new ExtractResourceSCM(getClass().getResource(\"/simple-projects.zip\")));\n        MavenModuleSetBuild b = m.scheduleBuild2(0).get();\n\n        // make sure these changes are effective\n        assertTrue(b.getWorkspace().getRemote().contains(\"test12251_ws\"));\n        assertTrue(b.getRootDir().toString().contains(\"test12251_builds\"));\n    }\n\n    /**\n     * Makes sure access to \"/foobar\" for UnprotectedRootAction gets through.\n     */\n    @Test @Issue(\"JENKINS-14113\")\n    public void testUnprotectedRootAction() throws Exception {\n        j.jenkins.setSecurityRealm(j.createDummySecurityRealm());\n        j.jenkins.setAuthorizationStrategy(new FullControlOnceLoggedInAuthorizationStrategy());\n        WebClient wc = j.createWebClient();\n        wc.goTo(\"foobar\");\n        wc.goTo(\"foobar/\");\n        wc.goTo(\"foobar/zot\");\n\n        // and make sure this fails\n        wc.assertFails(\"foobar-zot/\", HttpURLConnection.HTTP_INTERNAL_ERROR);\n\n        assertEquals(3,j.jenkins.getExtensionList(RootAction.class).get(RootActionImpl.class).count);\n    }\n\n    @Test\n    public void testDoScript() throws Exception {\n        j.jenkins.setSecurityRealm(new LegacySecurityRealm());\n        GlobalMatrixAuthorizationStrategy gmas = new GlobalMatrixAuthorizationStrategy() {\n            @Override public boolean hasPermission(String sid, Permission p) {\n                return p == Jenkins.RUN_SCRIPTS ? hasExplicitPermission(sid, p) : super.hasPermission(sid, p);\n            }\n        };\n        gmas.add(Jenkins.ADMINISTER, \"alice\");\n        gmas.add(Jenkins.RUN_SCRIPTS, \"alice\");\n        gmas.add(Jenkins.READ, \"bob\");\n        gmas.add(Jenkins.ADMINISTER, \"charlie\");\n        j.jenkins.setAuthorizationStrategy(gmas);\n        WebClient wc = j.createWebClient();\n        wc.login(\"alice\");\n        wc.goTo(\"script\");\n        wc.assertFails(\"script?script=System.setProperty('hack','me')\", HttpURLConnection.HTTP_BAD_METHOD);\n        assertNull(System.getProperty(\"hack\"));\n        WebRequest req = new WebRequest(new URL(wc.getContextPath() + \"script?script=System.setProperty('hack','me')\"), HttpMethod.POST);\n        wc.getPage(wc.addCrumb(req));\n        assertEquals(\"me\", System.getProperty(\"hack\"));\n        wc.assertFails(\"scriptText?script=System.setProperty('hack','me')\", HttpURLConnection.HTTP_BAD_METHOD);\n        req = new WebRequest(new URL(wc.getContextPath() + \"scriptText?script=System.setProperty('huck','you')\"), HttpMethod.POST);\n        wc.getPage(wc.addCrumb(req));\n        assertEquals(\"you\", System.getProperty(\"huck\"));\n        wc.login(\"bob\");\n        wc.assertFails(\"script\", HttpURLConnection.HTTP_FORBIDDEN);\n        wc.login(\"charlie\");\n        wc.assertFails(\"script\", HttpURLConnection.HTTP_FORBIDDEN);\n    }\n\n    @Test\n    public void testDoEval() throws Exception {\n        j.jenkins.setSecurityRealm(new LegacySecurityRealm());\n        GlobalMatrixAuthorizationStrategy gmas = new GlobalMatrixAuthorizationStrategy() {\n            @Override public boolean hasPermission(String sid, Permission p) {\n                return p == Jenkins.RUN_SCRIPTS ? hasExplicitPermission(sid, p) : super.hasPermission(sid, p);\n            }\n        };\n        gmas.add(Jenkins.ADMINISTER, \"alice\");\n        gmas.add(Jenkins.RUN_SCRIPTS, \"alice\");\n        gmas.add(Jenkins.READ, \"bob\");\n        gmas.add(Jenkins.ADMINISTER, \"charlie\");\n        j.jenkins.setAuthorizationStrategy(gmas);\n        WebClient wc = j.createWebClient();\n        wc.login(\"alice\");\n        wc.assertFails(\"eval\", HttpURLConnection.HTTP_BAD_METHOD);\n        assertEquals(\"3\", eval(wc));\n        wc.login(\"bob\");\n        try {\n            eval(wc);\n            fail(\"bob has only READ\");\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(HttpURLConnection.HTTP_FORBIDDEN, e.getStatusCode());\n        }\n        wc.login(\"charlie\");\n        try {\n            eval(wc);\n            fail(\"charlie has ADMINISTER but not RUN_SCRIPTS\");\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(HttpURLConnection.HTTP_FORBIDDEN, e.getStatusCode());\n        }\n    }\n    private String eval(WebClient wc) throws Exception {\n        WebRequest req = new WebRequest(wc.createCrumbedUrl(\"eval\"), HttpMethod.POST);\n        req.setEncodingType(null);\n        req.setRequestBody(\"<j:jelly xmlns:j='jelly:core'>${1+2}</j:jelly>\");\n        return wc.getPage(req).getWebResponse().getContentAsString();\n    }\n\n    @TestExtension(\"testUnprotectedRootAction\")\n    public static class RootActionImpl implements UnprotectedRootAction {\n        private int count;\n\n        public String getIconFileName() {\n            return null;\n        }\n\n        public String getDisplayName() {\n            return null;\n        }\n\n        public String getUrlName() {\n            return \"foobar\";\n        }\n\n        public HttpResponse doDynamic() {\n            assertTrue(Jenkins.getInstance().getAuthentication().getName().equals(\"anonymous\"));\n            count++;\n            return HttpResponses.html(\"OK\");\n        }\n    }\n\n    @TestExtension(\"testUnprotectedRootAction\")\n    public static class ProtectedRootActionImpl implements RootAction {\n        public String getIconFileName() {\n            return null;\n        }\n\n        public String getDisplayName() {\n            return null;\n        }\n\n        public String getUrlName() {\n            return \"foobar-zot\";\n        }\n\n        public HttpResponse doDynamic() {\n            throw new AssertionError();\n        }\n    }\n\n    @Test @Issue(\"JENKINS-20866\")\n    public void testErrorPageShouldBeAnonymousAccessible() throws Exception {\n        HudsonPrivateSecurityRealm s = new HudsonPrivateSecurityRealm(false, false, null);\n        User alice = s.createAccount(\"alice\", \"alice\");\n        j.jenkins.setSecurityRealm(s);\n\n        GlobalMatrixAuthorizationStrategy auth = new GlobalMatrixAuthorizationStrategy();\n        j.jenkins.setAuthorizationStrategy(auth);\n\n        // no anonymous read access\n        assertTrue(!Jenkins.getInstance().getACL().hasPermission(Jenkins.ANONYMOUS,Jenkins.READ));\n\n        WebClient wc = j.createWebClient();\n        wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n        HtmlPage p = wc.goTo(\"error/reportError\");\n\n        assertEquals(p.asText(), 400, p.getWebResponse().getStatusCode());  // not 403 forbidden\n        assertTrue(p.getWebResponse().getContentAsString().contains(\"My car is black\"));\n    }\n\n    @TestExtension(\"testErrorPageShouldBeAnonymousAccessible\")\n    public static class ReportError implements UnprotectedRootAction {\n\n        public String getIconFileName() {\n            return null;\n        }\n\n        public String getDisplayName() {\n            return null;\n        }\n\n        public String getUrlName() {\n            return \"error\";\n        }\n\n        public HttpResponse doReportError() {\n            return new Failure(\"My car is black\");\n        }\n    }\n\n    @Test @Issue(\"JENKINS-23551\")\n    public void testComputerListenerNotifiedOnRestart() {\n        // Simulate restart calling listeners\n        for (RestartListener listener : RestartListener.all())\n            listener.onRestart();\n\n        ArgumentCaptor<OfflineCause> captor = ArgumentCaptor.forClass(OfflineCause.class);\n        Mockito.verify(listenerMock).onOffline(Mockito.eq(j.jenkins.toComputer()), captor.capture());\n        assertTrue(captor.getValue().toString().contains(\"restart\"));\n    }\n\n    @TestExtension(value = \"testComputerListenerNotifiedOnRestart\")\n    public static final ComputerListener listenerMock = Mockito.mock(ComputerListener.class);\n\n    @Test\n    public void runScriptOnOfflineComputer() throws Exception {\n        DumbSlave slave = j.createSlave(true);\n        j.disconnectSlave(slave);\n\n        URL url = new URL(j.getURL(), \"computer/\" + slave.getNodeName() + \"/scriptText?script=println(42)\");\n\n        WebClient wc = j.createWebClient();\n        wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n\n        WebRequest req = new WebRequest(url, HttpMethod.POST);\n        Page page = wc.getPage(wc.addCrumb(req));\n        WebResponse rsp = page.getWebResponse();\n\n        assertThat(rsp.getContentAsString(), containsString(\"Node is offline\"));\n        assertThat(rsp.getStatusCode(), equalTo(404));\n    }\n}\n", "target": 1}
{"idx": 918, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static com.vmware.xenon.common.Service.Action.DELETE;\nimport static com.vmware.xenon.common.Service.Action.POST;\n\nimport java.io.NotActiveException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.logging.Level;\n\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Operation.OperationOption;\nimport com.vmware.xenon.common.ServiceDocumentDescription.TypeName;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceSubscriptionState.ServiceSubscriber;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.NumericRange;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Occurance;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.SynchronizationRequest;\nimport com.vmware.xenon.services.common.UiContentService;\n\n/**\n * Utility service managing the various URI control REST APIs for each service instance. A single\n * utility service instance manages operations on multiple URI suffixes (/stats, /subscriptions,\n * etc) in order to reduce runtime overhead per service instance\n */\npublic class UtilityService implements Service {\n    private transient Service parent;\n    private ServiceStats stats;\n    private ServiceSubscriptionState subscriptions;\n    private UiContentService uiService;\n\n    /**\n     * Dedupes most well-known strings used as stat names.\n     */\n    private static class StatsKeyDeduper {\n        private final Map<String, String> map = new HashMap<>();\n\n        StatsKeyDeduper() {\n            register(Service.STAT_NAME_REQUEST_COUNT);\n            register(Service.STAT_NAME_PRE_AVAILABLE_OP_COUNT);\n            register(Service.STAT_NAME_AVAILABLE);\n            register(Service.STAT_NAME_FAILURE_COUNT);\n            register(Service.STAT_NAME_REQUEST_OUT_OF_ORDER_COUNT);\n            register(Service.STAT_NAME_REQUEST_FAILURE_QUEUE_LIMIT_EXCEEDED_COUNT);\n            register(Service.STAT_NAME_STATE_PERSIST_LATENCY);\n            register(Service.STAT_NAME_OPERATION_QUEUEING_LATENCY);\n            register(Service.STAT_NAME_SERVICE_HANDLER_LATENCY);\n            register(Service.STAT_NAME_CREATE_COUNT);\n            register(Service.STAT_NAME_OPERATION_DURATION);\n            register(Service.STAT_NAME_SERVICE_HOST_MAINTENANCE_COUNT);\n            register(Service.STAT_NAME_MAINTENANCE_COUNT);\n            register(Service.STAT_NAME_NODE_GROUP_CHANGE_MAINTENANCE_COUNT);\n            register(Service.STAT_NAME_NODE_GROUP_SYNCH_DELAYED_COUNT);\n            register(Service.STAT_NAME_MAINTENANCE_COMPLETION_DELAYED_COUNT);\n            register(Service.STAT_NAME_DOCUMENT_OWNER_TOGGLE_ON_MAINT_COUNT);\n            register(Service.STAT_NAME_DOCUMENT_OWNER_TOGGLE_OFF_MAINT_COUNT);\n            register(Service.STAT_NAME_CACHE_MISS_COUNT);\n            register(Service.STAT_NAME_CACHE_CLEAR_COUNT);\n            register(Service.STAT_NAME_VERSION_CONFLICT_COUNT);\n            register(Service.STAT_NAME_VERSION_IN_CONFLICT);\n            register(Service.STAT_NAME_MAINTENANCE_DURATION);\n            register(Service.STAT_NAME_SYNCH_TASK_RETRY_COUNT);\n            register(Service.STAT_NAME_CHILD_SYNCH_FAILURE_COUNT);\n\n            register(ServiceStatUtils.GET_DURATION);\n            register(ServiceStatUtils.POST_DURATION);\n            register(ServiceStatUtils.PATCH_DURATION);\n            register(ServiceStatUtils.PUT_DURATION);\n            register(ServiceStatUtils.DELETE_DURATION);\n            register(ServiceStatUtils.OPTIONS_DURATION);\n\n            register(ServiceStatUtils.GET_REQUEST_COUNT);\n            register(ServiceStatUtils.POST_REQUEST_COUNT);\n            register(ServiceStatUtils.PATCH_REQUEST_COUNT);\n            register(ServiceStatUtils.PUT_REQUEST_COUNT);\n            register(ServiceStatUtils.DELETE_REQUEST_COUNT);\n            register(ServiceStatUtils.OPTIONS_REQUEST_COUNT);\n\n            register(ServiceStatUtils.GET_QLATENCY);\n            register(ServiceStatUtils.POST_QLATENCY);\n            register(ServiceStatUtils.PATCH_QLATENCY);\n            register(ServiceStatUtils.PUT_QLATENCY);\n            register(ServiceStatUtils.DELETE_QLATENCY);\n            register(ServiceStatUtils.OPTIONS_QLATENCY);\n\n            register(ServiceStatUtils.GET_HANDLER_LATENCY);\n            register(ServiceStatUtils.POST_HANDLER_LATENCY);\n            register(ServiceStatUtils.PATCH_HANDLER_LATENCY);\n            register(ServiceStatUtils.PUT_HANDLER_LATENCY);\n            register(ServiceStatUtils.DELETE_HANDLER_LATENCY);\n            register(ServiceStatUtils.OPTIONS_HANDLER_LATENCY);\n        }\n\n        private void register(String s) {\n            this.map.put(s, s);\n        }\n\n        public String getStatKey(String s) {\n            return this.map.getOrDefault(s, s);\n        }\n    }\n\n    private static final StatsKeyDeduper STATS_KEY_DICT = new StatsKeyDeduper();\n\n    public UtilityService() {\n    }\n\n    public UtilityService setParent(Service parent) {\n        this.parent = parent;\n        return this;\n    }\n\n    @Override\n    public void authorizeRequest(Operation op) {\n\n        String suffix = UriUtils.buildUriPath(UriUtils.URI_PATH_CHAR, UriUtils.getLastPathSegment(op.getUri()));\n\n        // allow access to ui endpoint\n        if (ServiceHost.SERVICE_URI_SUFFIX_UI.equals(suffix)) {\n            op.complete();\n            return;\n        }\n\n        ServiceDocument doc = new ServiceDocument();\n        if (this.parent.getOptions().contains(ServiceOption.FACTORY_ITEM)) {\n            doc.documentSelfLink = UriUtils.buildUriPath(UriUtils.getParentPath(this.parent.getSelfLink()), suffix);\n        } else {\n            doc.documentSelfLink = UriUtils.buildUriPath(this.parent.getSelfLink(), suffix);\n        }\n\n        doc.documentKind = Utils.buildKind(this.parent.getStateType());\n        if (getHost().isAuthorized(this.parent, doc, op)) {\n            op.complete();\n            return;\n        }\n\n        op.fail(Operation.STATUS_CODE_FORBIDDEN);\n    }\n\n    @Override\n    public void handleRequest(Operation op) {\n        String uriPrefix = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n\n        if (op.getUri().getPath().startsWith(uriPrefix)) {\n            // startsWith catches all /factory/instance/ui/some-script.js\n            handleUiRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_STATS)) {\n            handleStatsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS)) {\n            handleSubscriptionsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_TEMPLATE)) {\n            handleDocumentTemplateRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_CONFIG)) {\n            this.parent.handleConfigurationRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_SYNCHRONIZATION)) {\n            handleSynchRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_AVAILABLE)) {\n            handleAvailableRequest(op);\n        } else {\n            op.fail(new UnknownHostException());\n        }\n    }\n\n    @Override\n    public void handleCreate(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void handleStart(Operation startPost) {\n        startPost.complete();\n    }\n\n    @Override\n    public void handleStop(Operation op) {\n        op.complete();\n    }\n\n    @Override\n    public void handleRequest(Operation op, OperationProcessingStage opProcessingStage) {\n        handleRequest(op);\n    }\n\n    private void handleSynchRequest(Operation op) {\n        if (op.getAction() != Action.PATCH && op.getAction() != Action.PUT) {\n            Operation.failActionNotSupported(op);\n            return;\n        }\n\n        if (this.parent.getProcessingStage() != ProcessingStage.AVAILABLE) {\n            // processing stage takes precedence over isAvailable statistic\n            op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n            return;\n        }\n\n        if (!op.hasBody()) {\n            op.fail(new IllegalArgumentException(\"body is required\"));\n            return;\n        }\n\n        SynchronizationRequest synchRequest = op.getBody(SynchronizationRequest.class);\n        if (synchRequest.kind == null || !synchRequest.kind.equals(Utils.buildKind(SynchronizationRequest.class))) {\n            op.fail(new IllegalArgumentException(String.format(\n                    \"Invalid 'kind' in the request body\")));\n            return;\n        }\n\n        if (!synchRequest.documentSelfLink.equals(this.parent.getSelfLink())) {\n            op.fail(new IllegalArgumentException(\"Invalid param in the body: \" + synchRequest.documentSelfLink));\n            return;\n        }\n\n        // Synchronize the FactoryService\n        if (this.parent instanceof FactoryService) {\n            ((FactoryService)this.parent).synchronizeChildServicesIfOwner(new Operation());\n            op.complete();\n            return;\n        }\n\n        if (this.parent instanceof StatelessService) {\n            op.fail(new IllegalArgumentException(\"Nothing to synchronize for stateless service: \" +\n                    synchRequest.documentSelfLink));\n            return;\n        }\n\n        // Synchronize the single child service.\n        synchronizeChildService(this.parent.getSelfLink(), op);\n    }\n\n    private void synchronizeChildService(String link, Operation op) {\n        // To trigger synchronization of the child-service, we make\n        // a SYNCH-OWNER request. The request body is an empty document\n        // with just the documentSelfLink property set to the link\n        // of the child-service. This is done so that the FactoryService\n        // routes the request to the DOCUMENT_OWNER.\n        ServiceDocument d = new ServiceDocument();\n        d.documentSelfLink = UriUtils.getLastPathSegment(link);\n        String factoryLink = UriUtils.getParentPath(link);\n\n        Operation.CompletionHandler c = (o, e) -> {\n            if (e != null) {\n                String msg = String.format(\"Synchronization failed for service %s with status code %d, message %s\",\n                        o.getUri().getPath(), o.getStatusCode(), e.getMessage());\n                this.parent.getHost().log(Level.WARNING, msg);\n                op.fail(new IllegalStateException(msg));\n                return;\n            }\n\n            op.complete();\n        };\n\n        Operation.createPost(this, factoryLink)\n                .setBody(d)\n                .setCompletion(c)\n                .setReferer(getUri())\n                .setConnectionSharing(true)\n                .setConnectionTag(ServiceClient.CONNECTION_TAG_SYNCHRONIZATION)\n                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_SYNCH_OWNER)\n                .sendWith(this.parent);\n    }\n\n    private void handleAvailableRequest(Operation op) {\n        if (op.getAction() == Action.GET) {\n            if (this.parent.getProcessingStage() != ProcessingStage.AVAILABLE) {\n                // processing stage takes precedence over isAvailable statistic\n                op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n                return;\n            }\n            if (this.stats == null) {\n                op.complete();\n                return;\n            }\n            ServiceStat st = this.getStat(STAT_NAME_AVAILABLE, false);\n            if (st == null || st.latestValue == 1.0) {\n                op.complete();\n                return;\n            }\n            op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n        } else if (op.getAction() == Action.PATCH || op.getAction() == Action.PUT) {\n            if (!op.hasBody()) {\n                op.fail(new IllegalArgumentException(\"body is required\"));\n                return;\n            }\n            ServiceStat st = op.getBody(ServiceStat.class);\n            if (!STAT_NAME_AVAILABLE.equals(st.name)) {\n                op.fail(new IllegalArgumentException(\n                        \"body must be of type ServiceStat and name must be \"\n                                + STAT_NAME_AVAILABLE));\n                return;\n            }\n            handleStatsRequest(op);\n        } else {\n            Operation.failActionNotSupported(op);\n        }\n    }\n\n    private void handleSubscriptionsRequest(Operation op) {\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                this.subscriptions = new ServiceSubscriptionState();\n                this.subscriptions.subscribers = new ConcurrentSkipListMap<>();\n            }\n        }\n\n        ServiceSubscriber body = null;\n\n        // validate and populate body for POST & DELETE\n        Action action = op.getAction();\n        if (action == POST || action == DELETE) {\n            if (!op.hasBody()) {\n                op.fail(new IllegalStateException(\"body is required\"));\n                return;\n            }\n            body = op.getBody(ServiceSubscriber.class);\n            if (body.reference == null) {\n                op.fail(new IllegalArgumentException(\"reference is required\"));\n                return;\n            }\n        }\n\n        switch (action) {\n        case POST:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.put(body.reference, body);\n            }\n            if (!body.replayState) {\n                break;\n            }\n            // if replayState is set, replay the current state to the subscriber\n            URI notificationURI = body.reference;\n            this.parent.sendRequest(Operation.createGet(this, this.parent.getSelfLink())\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e != null) {\n                                    op.fail(new IllegalStateException(\n                                            \"Unable to get current state\"));\n                                    return;\n                                }\n                                Operation putOp = Operation\n                                        .createPut(notificationURI)\n                                        .setBodyNoCloning(o.getBody(this.parent.getStateType()))\n                                        .addPragmaDirective(\n                                                Operation.PRAGMA_DIRECTIVE_NOTIFICATION)\n                                        .setReferer(getUri());\n                                this.parent.sendRequest(putOp);\n                            }));\n\n            break;\n        case DELETE:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.remove(body.reference);\n            }\n            break;\n        case GET:\n            ServiceDocument rsp;\n            synchronized (this.subscriptions) {\n                rsp = Utils.clone(this.subscriptions);\n            }\n            op.setBody(rsp);\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n\n        op.complete();\n    }\n\n    public boolean hasSubscribers() {\n        ServiceSubscriptionState subscriptions = this.subscriptions;\n        return subscriptions != null\n                && subscriptions.subscribers != null\n                && !subscriptions.subscribers.isEmpty();\n    }\n\n    public boolean hasStats() {\n        ServiceStats stats = this.stats;\n        return stats != null && stats.entries != null && !stats.entries.isEmpty();\n    }\n\n    public void notifySubscribers(Operation op) {\n        try {\n            if (op.getAction() == Action.GET) {\n                return;\n            }\n\n            if (!this.hasSubscribers()) {\n                return;\n            }\n\n            long now = Utils.getNowMicrosUtc();\n\n            Operation clone = op.clone();\n            clone.toggleOption(OperationOption.REMOTE, false);\n            clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NOTIFICATION);\n            for (Entry<URI, ServiceSubscriber> e : this.subscriptions.subscribers.entrySet()) {\n                ServiceSubscriber s = e.getValue();\n                notifySubscriber(now, clone, s);\n            }\n\n            if (!performSubscriptionsMaintenance(now)) {\n                return;\n            }\n        } catch (Exception e) {\n            this.parent.getHost().log(Level.WARNING,\n                    \"Uncaught exception notifying subscribers for %s: %s\",\n                    this.parent.getSelfLink(), Utils.toString(e));\n        }\n    }\n\n    private void notifySubscriber(long now, Operation clone, ServiceSubscriber s) {\n        synchronized (s) {\n            if (s.failedNotificationCount != null) {\n                // indicate to the subscriber that they missed notifications and should retrieve latest state\n                clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_SKIPPED_NOTIFICATIONS);\n            }\n        }\n\n        CompletionHandler c = (o, ex) -> {\n            s.documentUpdateTimeMicros = Utils.getNowMicrosUtc();\n            synchronized (s) {\n                if (ex != null) {\n                    if (s.failedNotificationCount == null) {\n                        s.failedNotificationCount = 0L;\n                        s.initialFailedNotificationTimeMicros = now;\n                    }\n                    s.failedNotificationCount++;\n                    return;\n                }\n\n                if (s.failedNotificationCount != null) {\n                    // the subscriber is available again.\n                    s.failedNotificationCount = null;\n                    s.initialFailedNotificationTimeMicros = null;\n                }\n            }\n        };\n\n        this.parent.sendRequest(clone.setUri(s.reference).setCompletion(c));\n    }\n\n    private boolean performSubscriptionsMaintenance(long now) {\n        List<URI> subscribersToDelete = null;\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                return false;\n            }\n\n            Iterator<Entry<URI, ServiceSubscriber>> it = this.subscriptions.subscribers.entrySet()\n                    .iterator();\n            while (it.hasNext()) {\n                Entry<URI, ServiceSubscriber> e = it.next();\n                ServiceSubscriber s = e.getValue();\n                boolean remove = false;\n                synchronized (s) {\n                    if (s.documentExpirationTimeMicros != 0 && s.documentExpirationTimeMicros < now) {\n                        remove = true;\n                    } else if (s.notificationLimit != null) {\n                        if (s.notificationCount == null) {\n                            s.notificationCount = 0L;\n                        }\n                        if (++s.notificationCount >= s.notificationLimit) {\n                            remove = true;\n                        }\n                    } else if (s.failedNotificationCount != null\n                            && s.failedNotificationCount > ServiceSubscriber.NOTIFICATION_FAILURE_LIMIT) {\n                        if (now - s.initialFailedNotificationTimeMicros > getHost()\n                                .getMaintenanceIntervalMicros()) {\n                            getHost().log(Level.INFO,\n                                    \"removing subscriber, failed notifications: %d\",\n                                    s.failedNotificationCount);\n                            remove = true;\n                        }\n                    }\n                }\n\n                if (!remove) {\n                    continue;\n                }\n\n                it.remove();\n                if (subscribersToDelete == null) {\n                    subscribersToDelete = new ArrayList<>();\n                }\n                subscribersToDelete.add(s.reference);\n                continue;\n            }\n        }\n\n        if (subscribersToDelete != null) {\n            for (URI subscriber : subscribersToDelete) {\n                this.parent.sendRequest(Operation.createDelete(subscriber));\n            }\n        }\n\n        return true;\n    }\n\n    private void handleUiRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new IllegalArgumentException(\"Action not supported\"));\n            return;\n        }\n\n        if (!this.parent.hasOption(ServiceOption.HTML_USER_INTERFACE)) {\n            String servicePath = UriUtils.buildUriPath(ServiceUriPaths.UI_SERVICE_BASE_URL, op\n                    .getUri().getPath());\n            String defaultHtmlPath = UriUtils.buildUriPath(servicePath.substring(0,\n                    servicePath.length() - ServiceUriPaths.UI_PATH_SUFFIX.length()),\n                    ServiceUriPaths.UI_SERVICE_HOME);\n\n            redirectGetToHtmlUiResource(op, defaultHtmlPath);\n            return;\n        }\n\n        if (this.uiService == null) {\n            this.uiService = new UiContentService() {\n            };\n            this.uiService.setHost(this.parent.getHost());\n        }\n\n        // simulate a full service deployed at the utility endpoint /service/ui\n        String selfLink = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n        this.uiService.handleUiGet(selfLink, this.parent, op);\n    }\n\n    public void redirectGetToHtmlUiResource(Operation op, String htmlResourcePath) {\n        // redirect using relative url without host:port\n        // not so much optimization as handling the case of port forwarding/containers\n        try {\n            op.addResponseHeader(Operation.LOCATION_HEADER,\n                    URLDecoder.decode(htmlResourcePath, Utils.CHARSET));\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e);\n        }\n\n        op.setStatusCode(Operation.STATUS_CODE_MOVED_TEMP);\n        op.complete();\n    }\n\n    private void handleStatsRequest(Operation op) {\n        switch (op.getAction()) {\n        case PUT:\n            ServiceStats.ServiceStat stat = op\n                    .getBody(ServiceStats.ServiceStat.class);\n            if (stat.kind == null) {\n                op.fail(new IllegalArgumentException(\"kind is required\"));\n                return;\n            }\n            if (stat.kind.equals(ServiceStats.ServiceStat.KIND)) {\n                if (stat.name == null) {\n                    op.fail(new IllegalArgumentException(\"stat name is required\"));\n                    return;\n                }\n                replaceSingleStat(stat);\n            } else if (stat.kind.equals(ServiceStats.KIND)) {\n                ServiceStats stats = op.getBody(ServiceStats.class);\n                if (stats.entries == null || stats.entries.isEmpty()) {\n                    op.fail(new IllegalArgumentException(\"stats entries need to be defined\"));\n                    return;\n                }\n                replaceAllStats(stats);\n            } else {\n                op.fail(new IllegalArgumentException(\"operation not supported for kind\"));\n                return;\n            }\n            op.complete();\n            break;\n        case POST:\n            ServiceStats.ServiceStat newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // create a stat object if one does not exist\n            ServiceStats.ServiceStat existingStat = this.getStat(newStat.name);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat does not exist\"));\n                return;\n            }\n            initializeOrSetStat(existingStat, newStat);\n            op.complete();\n            break;\n        case DELETE:\n            // TODO support removing stats externally - do we need this?\n            op.fail(new NotActiveException());\n            break;\n        case PATCH:\n            newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // if an existing stat by this name exists, adjust the stat value, else this is a no-op\n            existingStat = this.getStat(newStat.name, false);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat to patch does not exist\"));\n                return;\n            }\n            adjustStat(existingStat, newStat.latestValue);\n            op.complete();\n            break;\n        case GET:\n            if (this.stats == null) {\n                ServiceStats s = new ServiceStats();\n                populateDocumentProperties(s);\n                op.setBody(s).complete();\n            } else {\n                ServiceStats rsp;\n                synchronized (this.stats) {\n                    rsp = populateDocumentProperties(this.stats);\n                    rsp = Utils.clone(rsp);\n                }\n\n                if (handleStatsGetWithODataRequest(op, rsp)) {\n                    return;\n                }\n\n                op.setBodyNoCloning(rsp);\n                op.complete();\n            }\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n    }\n\n    /**\n     * Selects statistics entries that satisfy a simple sub set of ODATA filter expressions\n     */\n    private boolean handleStatsGetWithODataRequest(Operation op, ServiceStats rsp) {\n        if (UriUtils.getODataCountParamValue(op.getUri())) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_COUNT + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataOrderByParamValue(op.getUri()) != null) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_ORDER_BY + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataSkipToParamValue(op.getUri()) != null) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_SKIP_TO + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataTopParamValue(op.getUri()) != null) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_TOP + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataFilterParamValue(op.getUri()) == null) {\n            return false;\n        }\n\n        QueryTask task = ODataUtils.toQuery(op, false, null);\n        if (task == null || task.querySpec.query == null) {\n            return false;\n        }\n\n        List<Query> clauses = task.querySpec.query.booleanClauses;\n        if (clauses == null || clauses.size() == 0) {\n            clauses = new ArrayList<Query>();\n            if (task.querySpec.query.term == null) {\n                return false;\n            }\n            clauses.add(task.querySpec.query);\n        }\n\n        return processStatsODataQueryClauses(op, rsp, clauses);\n    }\n\n    private boolean processStatsODataQueryClauses(Operation op, ServiceStats rsp,\n            List<Query> clauses) {\n        for (Query q : clauses) {\n            if (!Occurance.MUST_OCCUR.equals(q.occurance)) {\n                op.fail(new IllegalArgumentException(\"only AND expressions are supported\"));\n                return true;\n            }\n\n            QueryTerm term = q.term;\n\n            if (term == null) {\n                return processStatsODataQueryClauses(op, rsp, q.booleanClauses);\n            }\n\n            // prune entries using the filter match value and property\n            Iterator<Entry<String, ServiceStat>> statIt = rsp.entries.entrySet().iterator();\n            while (statIt.hasNext()) {\n                Entry<String, ServiceStat> e = statIt.next();\n                if (ServiceStat.FIELD_NAME_NAME.equals(term.propertyName)) {\n                    // match against the name property which is the also the key for the\n                    // entry table\n                    if (term.matchType.equals(MatchType.TERM)\n                            && e.getKey().equals(term.matchValue)) {\n                        continue;\n                    }\n                    if (term.matchType.equals(MatchType.PREFIX)\n                            && e.getKey().startsWith(term.matchValue)) {\n                        continue;\n                    }\n                    if (term.matchType.equals(MatchType.WILDCARD)) {\n                        // we only support two types of wild card queries:\n                        // *something or something*\n                        if (term.matchValue.endsWith(UriUtils.URI_WILDCARD_CHAR)) {\n                            // prefix match\n                            String mv = term.matchValue.replace(UriUtils.URI_WILDCARD_CHAR, \"\");\n                            if (e.getKey().startsWith(mv)) {\n                                continue;\n                            }\n                        } else if (term.matchValue.startsWith(UriUtils.URI_WILDCARD_CHAR)) {\n                            // suffix match\n                            String mv = term.matchValue.replace(UriUtils.URI_WILDCARD_CHAR, \"\");\n\n                            if (e.getKey().endsWith(mv)) {\n                                continue;\n                            }\n                        }\n                    }\n                } else if (ServiceStat.FIELD_NAME_LATEST_VALUE.equals(term.propertyName)) {\n                    // support numeric range queries on latest value\n                    if (term.range == null || term.range.type != TypeName.DOUBLE) {\n                        op.fail(new IllegalArgumentException(\n                                ServiceStat.FIELD_NAME_LATEST_VALUE\n                                        + \"requires double numeric range\"));\n                        return true;\n                    }\n                    @SuppressWarnings(\"unchecked\")\n                    NumericRange<Double> nr = (NumericRange<Double>) term.range;\n                    ServiceStat st = e.getValue();\n                    boolean withinMax = nr.isMaxInclusive && st.latestValue <= nr.max ||\n                            st.latestValue < nr.max;\n                    boolean withinMin = nr.isMinInclusive && st.latestValue >= nr.min ||\n                            st.latestValue > nr.min;\n                    if (withinMin && withinMax) {\n                        continue;\n                    }\n                }\n                statIt.remove();\n            }\n        }\n        return false;\n    }\n\n    private ServiceStats populateDocumentProperties(ServiceStats stats) {\n        ServiceStats clone = new ServiceStats();\n        // sort entries by key (natural ordering)\n        clone.entries = new TreeMap<>(stats.entries);\n        clone.documentUpdateTimeMicros = stats.documentUpdateTimeMicros;\n        clone.documentSelfLink = UriUtils.buildUriPath(this.parent.getSelfLink(),\n                ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        clone.documentOwner = getHost().getId();\n        clone.documentKind = Utils.buildKind(ServiceStats.class);\n        return clone;\n    }\n\n    private void handleDocumentTemplateRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new NotActiveException());\n            return;\n        }\n        ServiceDocument template = this.parent.getDocumentTemplate();\n        String serializedTemplate = Utils.toJsonHtml(template);\n        op.setBody(serializedTemplate).complete();\n    }\n\n    @Override\n    public void handleConfigurationRequest(Operation op) {\n        this.parent.handleConfigurationRequest(op);\n    }\n\n    public void handlePatchConfiguration(Operation op, ServiceConfigUpdateRequest updateBody) {\n        if (updateBody == null) {\n            updateBody = op.getBody(ServiceConfigUpdateRequest.class);\n        }\n\n        if (!ServiceConfigUpdateRequest.KIND.equals(updateBody.kind)) {\n            op.fail(new IllegalArgumentException(\"Unrecognized kind: \" + updateBody.kind));\n            return;\n        }\n\n        if (updateBody.maintenanceIntervalMicros == null\n                && updateBody.peerNodeSelectorPath == null\n                && updateBody.operationQueueLimit == null\n                && updateBody.epoch == null\n                && (updateBody.addOptions == null || updateBody.addOptions.isEmpty())\n                && (updateBody.removeOptions == null || updateBody.removeOptions\n                .isEmpty())\n                && updateBody.versionRetentionLimit == null) {\n            op.fail(new IllegalArgumentException(\n                    \"At least one configuraton field must be specified\"));\n            return;\n        }\n\n        if (updateBody.versionRetentionLimit != null) {\n            // Fail the request for immutable service as it is not allowed to change the version\n            // retention.\n            if (this.parent.getOptions().contains(ServiceOption.IMMUTABLE)) {\n                op.fail(new IllegalArgumentException(String.format(\n                        \"Service %s has option %s, retention limit cannot be modified\",\n                        this.parent.getSelfLink(), ServiceOption.IMMUTABLE)));\n                return;\n            }\n            ServiceDocumentDescription serviceDocumentDescription = this.parent\n                    .getDocumentTemplate().documentDescription;\n            serviceDocumentDescription.versionRetentionLimit = updateBody.versionRetentionLimit;\n            if (updateBody.versionRetentionFloor != null) {\n                serviceDocumentDescription.versionRetentionFloor = updateBody.versionRetentionFloor;\n            } else {\n                serviceDocumentDescription.versionRetentionFloor =\n                        updateBody.versionRetentionLimit / 2;\n            }\n        }\n\n        // service might fail a capability toggle if the capability can not be changed after start\n        if (updateBody.addOptions != null) {\n            for (ServiceOption c : updateBody.addOptions) {\n                this.parent.toggleOption(c, true);\n            }\n        }\n\n        if (updateBody.removeOptions != null) {\n            for (ServiceOption c : updateBody.removeOptions) {\n                this.parent.toggleOption(c, false);\n            }\n        }\n\n        if (updateBody.maintenanceIntervalMicros != null) {\n            this.parent.setMaintenanceIntervalMicros(updateBody.maintenanceIntervalMicros);\n        }\n\n        if (updateBody.peerNodeSelectorPath != null) {\n            this.parent.setPeerNodeSelectorPath(updateBody.peerNodeSelectorPath);\n        }\n\n        op.complete();\n    }\n\n    private void initializeOrSetStat(ServiceStat stat, ServiceStat newValue) {\n        synchronized (stat) {\n            if (stat.timeSeriesStats == null && newValue.timeSeriesStats != null) {\n                stat.timeSeriesStats = new TimeSeriesStats(newValue.timeSeriesStats.numBins,\n                        newValue.timeSeriesStats.binDurationMillis, newValue.timeSeriesStats.aggregationType);\n            }\n            stat.unit = newValue.unit;\n            stat.sourceTimeMicrosUtc = newValue.sourceTimeMicrosUtc;\n            setStat(stat, newValue.latestValue);\n        }\n    }\n\n    @Override\n    public void setStat(ServiceStat stat, double newValue) {\n        allocateStats();\n        findStat(stat.name, true, stat);\n        synchronized (stat) {\n            stat.version++;\n            stat.accumulatedValue += newValue;\n            stat.latestValue = newValue;\n            addHistogram(stat, newValue);\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, newValue, newValue);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, newValue, newValue);\n                }\n            }\n        }\n    }\n\n    private void addHistogram(ServiceStat stat, double newValue) {\n        if (stat.logHistogram != null) {\n            int binIndex = 0;\n            if (newValue > 0.0) {\n                binIndex = (int) Math.log10(newValue);\n            }\n            if (binIndex >= 0 && binIndex < stat.logHistogram.bins.length) {\n                stat.logHistogram.bins[binIndex]++;\n            }\n        }\n    }\n\n    @Override\n    public void adjustStat(ServiceStat stat, double delta) {\n        allocateStats();\n        synchronized (stat) {\n            stat.latestValue += delta;\n            stat.version++;\n            addHistogram(stat, stat.latestValue);\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, stat.latestValue, delta);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, stat.latestValue, delta);\n                }\n            }\n        }\n    }\n\n    @Override\n    public ServiceStat getStat(String name) {\n        return getStat(name, true);\n    }\n\n    private ServiceStat getStat(String name, boolean create) {\n        if (!allocateStats(true)) {\n            return null;\n        }\n        return findStat(name, create, null);\n    }\n\n    private void replaceSingleStat(ServiceStat stat) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // create a new stat with the default values\n            ServiceStat newStat = new ServiceStat();\n            newStat.name = stat.name;\n            initializeOrSetStat(newStat, stat);\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            // add it to the list of stats for this service\n            this.stats.entries.put(stat.name, newStat);\n        }\n    }\n\n    private void replaceAllStats(ServiceStats newStats) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // reset the current set of stats\n            this.stats.entries.clear();\n            for (ServiceStats.ServiceStat currentStat : newStats.entries.values()) {\n                replaceSingleStat(currentStat);\n            }\n\n        }\n    }\n\n    private ServiceStat findStat(String name, boolean create, ServiceStat initialStat) {\n        synchronized (this.stats) {\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            ServiceStat st = this.stats.entries.get(name);\n            if (st == null && create) {\n                st = initialStat != null ? initialStat : new ServiceStat();\n                name = STATS_KEY_DICT.getStatKey(name);\n                st.name = name;\n                this.stats.entries.put(name, st);\n            }\n\n            if (create && st != null && initialStat != null) {\n                // if the statistic already exists make sure it has the same features\n                // as the statistic we are trying to create\n                if (st.timeSeriesStats == null && initialStat.timeSeriesStats != null) {\n                    st.timeSeriesStats = initialStat.timeSeriesStats;\n                }\n                if (st.logHistogram == null && initialStat.logHistogram != null) {\n                    st.logHistogram = initialStat.logHistogram;\n                }\n            }\n            return st;\n        }\n    }\n\n    private void allocateStats() {\n        allocateStats(true);\n    }\n\n    private synchronized boolean allocateStats(boolean mustAllocate) {\n        if (!mustAllocate && this.stats == null) {\n            return false;\n        }\n        if (this.stats != null) {\n            return true;\n        }\n        this.stats = new ServiceStats();\n        return true;\n    }\n\n    @Override\n    public ServiceHost getHost() {\n        return this.parent.getHost();\n    }\n\n    @Override\n    public String getSelfLink() {\n        return null;\n    }\n\n    @Override\n    public URI getUri() {\n        return null;\n    }\n\n    @Override\n    public OperationProcessingChain getOperationProcessingChain() {\n        return null;\n    }\n\n    @Override\n    public ProcessingStage getProcessingStage() {\n        return ProcessingStage.AVAILABLE;\n    }\n\n    @Override\n    public EnumSet<ServiceOption> getOptions() {\n        return EnumSet.of(ServiceOption.UTILITY);\n    }\n\n    @Override\n    public boolean hasOption(ServiceOption cap) {\n        return false;\n    }\n\n    @Override\n    public void toggleOption(ServiceOption cap, boolean enable) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public void adjustStat(String name, double delta) {\n    }\n\n    @Override\n    public void setStat(String name, double newValue) {\n    }\n\n    @Override\n    public void handleMaintenance(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void setHost(ServiceHost serviceHost) {\n\n    }\n\n    @Override\n    public void setSelfLink(String path) {\n\n    }\n\n    @Override\n    public void setOperationProcessingChain(OperationProcessingChain opProcessingChain) {\n\n    }\n\n    @Override\n    public void setProcessingStage(ProcessingStage initialized) {\n\n    }\n\n    @Override\n    public ServiceDocument setInitialState(Object state, Long initialVersion) {\n        return null;\n    }\n\n    @Override\n    public Service getUtilityService(String uriPath) {\n        return null;\n    }\n\n    @Override\n    public boolean queueRequest(Operation op) {\n        return false;\n    }\n\n    @Override\n    public void sendRequest(Operation op) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public ServiceDocument getDocumentTemplate() {\n        return null;\n    }\n\n    @Override\n    public void setPeerNodeSelectorPath(String uriPath) {\n\n    }\n\n    @Override\n    public String getPeerNodeSelectorPath() {\n        return null;\n    }\n\n    @Override\n    public void setDocumentIndexPath(String uriPath) {\n\n    }\n\n    @Override\n    public String getDocumentIndexPath() {\n        return null;\n    }\n\n    @Override\n    public void setState(Operation op, ServiceDocument newState) {\n        op.linkState(newState);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends ServiceDocument> T getState(Operation op) {\n        return (T) op.getLinkedState();\n    }\n\n    @Override\n    public void setMaintenanceIntervalMicros(long micros) {\n        throw new RuntimeException(\"not implemented\");\n    }\n\n    @Override\n    public long getMaintenanceIntervalMicros() {\n        return 0;\n    }\n\n    @Override\n    public Operation dequeueRequest() {\n        return null;\n    }\n\n    @Override\n    public Class<? extends ServiceDocument> getStateType() {\n        return null;\n    }\n\n    @Override\n    public final void setAuthorizationContext(Operation op, AuthorizationContext ctx) {\n        throw new RuntimeException(\"Service not allowed to set authorization context\");\n    }\n\n    @Override\n    public final AuthorizationContext getSystemAuthorizationContext() {\n        throw new RuntimeException(\"Service not allowed to get system authorization context\");\n    }\n}\n", "target": 0}
{"idx": 919, "func": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.cxf.fediz.core.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Text;\n\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Few simple utils to read DOM. This is originally from the Jakarta Commons Modeler.\n *\n * @author Costin Manolache\n */\npublic final class DOMUtils {\n    private static final Logger LOG = LoggerFactory.getLogger(DOMUtils.class);\n\n    private static final String XMLNAMESPACE = \"xmlns\";\n\n    private static final DocumentBuilderFactory DBF = DocumentBuilderFactory.newInstance();\n\n    static {\n        try {\n            DBF.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            DBF.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n            DBF.setValidating(false);\n            DBF.setIgnoringComments(false);\n            DBF.setIgnoringElementContentWhitespace(true);\n            DBF.setNamespaceAware(true);\n            // DBF.setCoalescing(true);\n            // DBF.setExpandEntityReferences(true);\n        } catch (ParserConfigurationException ex) {\n            LOG.error(\"Error configuring DocumentBuilderFactory\", ex);\n        }\n    }\n\n    private DOMUtils() {\n    }\n\n    /**\n     * This function is much like getAttribute, but returns null, not \"\", for a nonexistent attribute.\n     *\n     * @param e\n     * @param attributeName\n     */\n    public static String getAttributeValueEmptyNull(Element e, String attributeName) {\n        Attr node = e.getAttributeNode(attributeName);\n        if (node == null) {\n            return null;\n        }\n        return node.getValue();\n    }\n\n    /**\n     * Get the trimmed text content of a node or null if there is no text\n     */\n    public static String getContent(Node n) {\n        String s = getRawContent(n);\n        if (s != null) {\n            s = s.trim();\n        }\n        return s;\n    }\n\n    /**\n     * Get the raw text content of a node or null if there is no text\n     */\n    public static String getRawContent(Node n) {\n        if (n == null) {\n            return null;\n        }\n        StringBuilder b = null;\n        String s = null;\n        Node n1 = n.getFirstChild();\n        while (n1 != null) {\n            if (n1.getNodeType() == Node.TEXT_NODE) {\n                if (b != null) {\n                    b.append(((Text)n1).getNodeValue());\n                } else if (s == null) {\n                    s = ((Text)n1).getNodeValue();\n                } else {\n                    b = new StringBuilder(s).append(((Text)n1).getNodeValue());\n                    s = null;\n                }\n            }\n            n1 = n1.getNextSibling();\n        }\n        if (b != null) {\n            return b.toString();\n        }\n        return s;\n    }\n\n    /**\n     * Get the first element child.\n     *\n     * @param parent lookup direct childs\n     * @param name name of the element. If null return the first element.\n     */\n    public static Node getChild(Node parent, String name) {\n        if (parent == null) {\n            return null;\n        }\n\n        Node first = parent.getFirstChild();\n        if (first == null) {\n            return null;\n        }\n\n        for (Node node = first; node != null; node = node.getNextSibling()) {\n            // System.out.println(\"getNode: \" + name + \" \" +\n            // node.getNodeName());\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            if (name != null && name.equals(node.getNodeName())) {\n                return node;\n            }\n            if (name == null) {\n                return node;\n            }\n        }\n        return null;\n    }\n\n    public static String getAttribute(Node element, String attName) {\n        NamedNodeMap attrs = element.getAttributes();\n        if (attrs == null) {\n            return null;\n        }\n        Node attN = attrs.getNamedItem(attName);\n        if (attN == null) {\n            return null;\n        }\n        return attN.getNodeValue();\n    }\n\n    public static String getAttribute(Element element, QName attName) {\n        Attr attr;\n        if (StringUtils.isEmpty(attName.getNamespaceURI())) {\n            attr = element.getAttributeNode(attName.getLocalPart());\n        } else {\n            attr = element.getAttributeNodeNS(attName.getNamespaceURI(), attName.getLocalPart());\n        }\n        return attr == null ? null : attr.getValue();\n    }\n\n    public static void setAttribute(Node node, String attName, String val) {\n        NamedNodeMap attributes = node.getAttributes();\n        Node attNode = node.getOwnerDocument().createAttributeNS(null, attName);\n        attNode.setNodeValue(val);\n        attributes.setNamedItem(attNode);\n    }\n\n    public static void removeAttribute(Node node, String attName) {\n        NamedNodeMap attributes = node.getAttributes();\n        attributes.removeNamedItem(attName);\n    }\n\n    /**\n     * Set or replace the text value\n     */\n    public static void setText(Node node, String val) {\n        Node chld = DOMUtils.getChild(node, Node.TEXT_NODE);\n        if (chld == null) {\n            Node textN = node.getOwnerDocument().createTextNode(val);\n            node.appendChild(textN);\n            return;\n        }\n        // change the value\n        chld.setNodeValue(val);\n    }\n\n    /**\n     * Find the first direct child with a given attribute.\n     *\n     * @param parent\n     * @param elemName name of the element, or null for any\n     * @param attName attribute we're looking for\n     * @param attVal attribute value or null if we just want any\n     */\n    public static Node findChildWithAtt(Node parent, String elemName, String attName, String attVal) {\n\n        Node child = DOMUtils.getChild(parent, Node.ELEMENT_NODE);\n        if (attVal == null) {\n            while (child != null && (elemName == null || elemName.equals(child.getNodeName()))\n                   && DOMUtils.getAttribute(child, attName) != null) {\n                child = getNext(child, elemName, Node.ELEMENT_NODE);\n            }\n        } else {\n            while (child != null && (elemName == null || elemName.equals(child.getNodeName()))\n                   && !attVal.equals(DOMUtils.getAttribute(child, attName))) {\n                child = getNext(child, elemName, Node.ELEMENT_NODE);\n            }\n        }\n        return child;\n    }\n\n    /**\n     * Get the first child's content ( ie it's included TEXT node ).\n     */\n    public static String getChildContent(Node parent, String name) {\n        Node first = parent.getFirstChild();\n        if (first == null) {\n            return null;\n        }\n        for (Node node = first; node != null; node = node.getNextSibling()) {\n            // System.out.println(\"getNode: \" + name + \" \" +\n            // node.getNodeName());\n            if (name.equals(node.getNodeName())) {\n                return getRawContent(node);\n            }\n        }\n        return null;\n    }\n\n    public static QName getElementQName(Element el) {\n        return new QName(el.getNamespaceURI(), el.getLocalName());\n    }\n\n    /**\n     * Get the first direct child with a given type\n     */\n    public static Element getFirstElement(Node parent) {\n        Node n = parent.getFirstChild();\n        while (n != null && Node.ELEMENT_NODE != n.getNodeType()) {\n            n = n.getNextSibling();\n        }\n        if (n == null) {\n            return null;\n        }\n        return (Element)n;\n    }\n\n    public static Element getNextElement(Element el) {\n        Node nd = el.getNextSibling();\n        while (nd != null) {\n            if (nd.getNodeType() == Node.ELEMENT_NODE) {\n                return (Element)nd;\n            }\n            nd = nd.getNextSibling();\n        }\n        return null;\n    }\n\n    /**\n     * Return the first element child with the specified qualified name.\n     *\n     * @param parent\n     * @param q\n     */\n    public static Element getFirstChildWithName(Element parent, QName q) {\n        String ns = q.getNamespaceURI();\n        String lp = q.getLocalPart();\n        return getFirstChildWithName(parent, ns, lp);\n    }\n\n    /**\n     * Return the first element child with the specified qualified name.\n     *\n     * @param parent\n     * @param ns\n     * @param lp\n     */\n    public static Element getFirstChildWithName(Element parent, String ns, String lp) {\n        for (Node n = parent.getFirstChild(); n != null; n = n.getNextSibling()) {\n            if (n instanceof Element) {\n                Element e = (Element)n;\n                String ens = (e.getNamespaceURI() == null) ? \"\" : e.getNamespaceURI();\n                if (ns.equals(ens) && lp.equals(e.getLocalName())) {\n                    return e;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Return child elements with specified name.\n     *\n     * @param parent\n     * @param ns\n     * @param localName\n     */\n    public static List<Element> getChildrenWithName(Element parent, String ns, String localName) {\n        List<Element> r = new ArrayList<>();\n        for (Node n = parent.getFirstChild(); n != null; n = n.getNextSibling()) {\n            if (n instanceof Element) {\n                Element e = (Element)n;\n                String eNs = (e.getNamespaceURI() == null) ? \"\" : e.getNamespaceURI();\n                if (ns.equals(eNs) && localName.equals(e.getLocalName())) {\n                    r.add(e);\n                }\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Returns all child elements with specified namespace.\n     *\n     * @param parent the element to search under\n     * @param ns the namespace to find elements in\n     * @return all child elements with specified namespace\n     */\n    public static List<Element> getChildrenWithNamespace(Element parent, String ns) {\n        List<Element> r = new ArrayList<>();\n        for (Node n = parent.getFirstChild(); n != null; n = n.getNextSibling()) {\n            if (n instanceof Element) {\n                Element e = (Element)n;\n                String eNs = (e.getNamespaceURI() == null) ? \"\" : e.getNamespaceURI();\n                if (ns.equals(eNs)) {\n                    r.add(e);\n                }\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Get the first child of the specified type.\n     *\n     * @param parent\n     * @param type\n     */\n    public static Node getChild(Node parent, int type) {\n        Node n = parent.getFirstChild();\n        while (n != null && type != n.getNodeType()) {\n            n = n.getNextSibling();\n        }\n        if (n == null) {\n            return null;\n        }\n        return n;\n    }\n\n    /**\n     * Get the next sibling with the same name and type\n     */\n    public static Node getNext(Node current) {\n        String name = current.getNodeName();\n        int type = current.getNodeType();\n        return getNext(current, name, type);\n    }\n\n    /**\n     * Return the next sibling with a given name and type\n     */\n    public static Node getNext(Node current, String name, int type) {\n        Node first = current.getNextSibling();\n        if (first == null) {\n            return null;\n        }\n\n        for (Node node = first; node != null; node = node.getNextSibling()) {\n\n            if (type >= 0 && node.getNodeType() != type) {\n                continue;\n            }\n\n            if (name == null) {\n                return node;\n            }\n            if (name.equals(node.getNodeName())) {\n                return node;\n            }\n        }\n        return null;\n    }\n\n    public static class NullResolver implements EntityResolver {\n        public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n            return new InputSource(new StringReader(\"\"));\n        }\n    }\n\n    /**\n     * Read XML as DOM.\n     */\n    public static Document readXml(InputStream is) throws SAXException, IOException,\n        ParserConfigurationException {\n        DocumentBuilder db = DBF.newDocumentBuilder();\n        return db.parse(is);\n    }\n\n    public static Document readXml(Reader is) throws SAXException, IOException, ParserConfigurationException {\n        InputSource ips = new InputSource(is);\n        DocumentBuilder db = DBF.newDocumentBuilder();\n        return db.parse(ips);\n    }\n\n    public static Document readXml(StreamSource is) throws SAXException, IOException,\n        ParserConfigurationException {\n        InputSource is2 = new InputSource();\n        is2.setSystemId(is.getSystemId());\n        is2.setByteStream(is.getInputStream());\n        is2.setCharacterStream(is.getReader());\n\n        DocumentBuilder db = DBF.newDocumentBuilder();\n        return db.parse(is2);\n    }\n\n    public static void writeXml(Node n, OutputStream os) throws TransformerException {\n        TransformerFactory tf = TransformerFactory.newInstance();\n        tf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        // identity\n        Transformer t = tf.newTransformer();\n        t.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        t.transform(new DOMSource(n), new StreamResult(os));\n    }\n\n    public static DocumentBuilder createDocumentBuilder() {\n        try {\n            return DBF.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new RuntimeException(\"Couldn't find a DOM parser.\", e);\n        }\n    }\n\n    public static Document createDocument() {\n        try {\n            return DBF.newDocumentBuilder().newDocument();\n        } catch (ParserConfigurationException e) {\n            throw new RuntimeException(\"Couldn't find a DOM parser.\", e);\n        }\n    }\n\n    public static String getPrefixRecursive(Element el, String ns) {\n        String prefix = getPrefix(el, ns);\n        if (prefix == null && el.getParentNode() instanceof Element) {\n            prefix = getPrefixRecursive((Element)el.getParentNode(), ns);\n        }\n        return prefix;\n    }\n\n    public static String getPrefix(Element el, String ns) {\n        NamedNodeMap atts = el.getAttributes();\n        for (int i = 0; i < atts.getLength(); i++) {\n            Node node = atts.item(i);\n            String name = node.getNodeName();\n            if (ns.equals(node.getNodeValue())\n                && (name != null && (XMLNAMESPACE.equals(name) || name.startsWith(XMLNAMESPACE + \":\")))) {\n                return node.getLocalName();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get all prefixes defined, up to the root, for a namespace URI.\n     *\n     * @param element\n     * @param namespaceUri\n     * @param prefixes\n     */\n    public static void getPrefixesRecursive(Element element, String namespaceUri, List<String> prefixes) {\n        getPrefixes(element, namespaceUri, prefixes);\n        Node parent = element.getParentNode();\n        if (parent instanceof Element) {\n            getPrefixesRecursive((Element)parent, namespaceUri, prefixes);\n        }\n    }\n\n    /**\n     * Get all prefixes defined on this element for the specified namespace.\n     *\n     * @param element\n     * @param namespaceUri\n     * @param prefixes\n     */\n    public static void getPrefixes(Element element, String namespaceUri, List<String> prefixes) {\n        NamedNodeMap atts = element.getAttributes();\n        for (int i = 0; i < atts.getLength(); i++) {\n            Node node = atts.item(i);\n            String name = node.getNodeName();\n            if (namespaceUri.equals(node.getNodeValue())\n                && (name != null && (XMLNAMESPACE.equals(name) || name.startsWith(XMLNAMESPACE + \":\")))) {\n                prefixes.add(node.getPrefix());\n            }\n        }\n    }\n\n    public static String createNamespace(Element el, String ns) {\n        String p = \"ns1\";\n        int i = 1;\n        while (getPrefix(el, ns) != null) {\n            p = \"ns\" + i;\n            i++;\n        }\n        addNamespacePrefix(el, ns, p);\n        return p;\n    }\n\n    /**\n     * Starting from a node, find the namespace declaration for a prefix. for a matching namespace\n     * declaration.\n     *\n     * @param node search up from here to search for namespace definitions\n     * @param searchPrefix the prefix we are searching for\n     * @return the namespace if found.\n     */\n    public static String getNamespace(Node node, String searchPrefix) {\n\n        Element el;\n        while (!(node instanceof Element)) {\n            node = node.getParentNode();\n        }\n        el = (Element)node;\n\n        NamedNodeMap atts = el.getAttributes();\n        for (int i = 0; i < atts.getLength(); i++) {\n            Node currentAttribute = atts.item(i);\n            String currentLocalName = currentAttribute.getLocalName();\n            String currentPrefix = currentAttribute.getPrefix();\n            if (searchPrefix.equals(currentLocalName) && XMLNAMESPACE.equals(currentPrefix)) {\n                return currentAttribute.getNodeValue();\n            } else if (StringUtils.isEmpty(searchPrefix) && XMLNAMESPACE.equals(currentLocalName)\n                       && StringUtils.isEmpty(currentPrefix)) {\n                return currentAttribute.getNodeValue();\n            }\n        }\n\n        Node parent = el.getParentNode();\n        if (parent instanceof Element) {\n            return getNamespace((Element)parent, searchPrefix);\n        }\n\n        return null;\n    }\n\n    public static List<Element> findAllElementsByTagNameNS(Element elem, String nameSpaceURI, String localName) {\n        List<Element> ret = new LinkedList<>();\n        findAllElementsByTagNameNS(elem, nameSpaceURI, localName, ret);\n        return ret;\n    }\n\n    private static void findAllElementsByTagNameNS(Element el, String nameSpaceURI, String localName,\n                                                   List<Element> elementList) {\n\n        if (localName.equals(el.getLocalName()) && nameSpaceURI.contains(el.getNamespaceURI())) {\n            elementList.add(el);\n        }\n        Element elem = getFirstElement(el);\n        while (elem != null) {\n            findAllElementsByTagNameNS(elem, nameSpaceURI, localName, elementList);\n            elem = getNextElement(elem);\n        }\n    }\n\n    public static List<Element> findAllElementsByTagName(Element elem, String tagName) {\n        List<Element> ret = new LinkedList<>();\n        findAllElementsByTagName(elem, tagName, ret);\n        return ret;\n    }\n\n    private static void findAllElementsByTagName(Element el, String tagName, List<Element> elementList) {\n\n        if (tagName.equals(el.getTagName())) {\n            elementList.add(el);\n        }\n        Element elem = getFirstElement(el);\n        while (elem != null) {\n            findAllElementsByTagName(elem, tagName, elementList);\n            elem = getNextElement(elem);\n        }\n    }\n\n    public static boolean hasElementInNS(Element el, String namespace) {\n\n        if (namespace.equals(el.getNamespaceURI())) {\n            return true;\n        }\n        Element elem = getFirstElement(el);\n        while (elem != null) {\n            if (hasElementInNS(elem, namespace)) {\n                return true;\n            }\n            elem = getNextElement(elem);\n        }\n        return false;\n    }\n\n    /**\n     * Set a namespace/prefix on an element if it is not set already. First off, it searches for the element\n     * for the prefix associated with the specified namespace. If the prefix isn't null, then this is\n     * returned. Otherwise, it creates a new attribute using the namespace/prefix passed as parameters.\n     *\n     * @param element\n     * @param namespace\n     * @param prefix\n     * @return the prefix associated with the set namespace\n     */\n    public static String setNamespace(Element element, String namespace, String prefix) {\n        String pre = getPrefixRecursive(element, namespace);\n        if (pre != null) {\n            return pre;\n        }\n        element.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, \"xmlns:\" + prefix, namespace);\n        return prefix;\n    }\n\n    /**\n     * Add a namespace prefix definition to an element.\n     *\n     * @param element\n     * @param namespaceUri\n     * @param prefix\n     */\n    public static void addNamespacePrefix(Element element, String namespaceUri, String prefix) {\n        element.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, \"xmlns:\" + prefix, namespaceUri);\n    }\n}\n", "target": 0}
{"idx": 920, "func": "/*\n\n    Copyright 2018-2020 Accenture Technology\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n */\n\npackage com.accenture.examples.rest;\n\nimport org.platformlambda.core.exception.AppException;\nimport org.platformlambda.core.models.EventEnvelope;\nimport org.platformlambda.core.models.Kv;\nimport org.platformlambda.core.system.Platform;\nimport org.platformlambda.core.system.PostOffice;\nimport org.platformlambda.models.ObjectWithGenericType;\nimport org.platformlambda.models.SamplePoJo;\n\nimport javax.ws.rs.*;\nimport javax.ws.rs.core.MediaType;\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\n@Path(\"/hello\")\npublic class HelloPoJo {\n\n    @GET\n    @Path(\"/pojo/{id}\")\n    @Produces({MediaType.TEXT_PLAIN, MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON, MediaType.TEXT_HTML})\n    public Object getPoJo(@PathParam(\"id\") Integer id) throws TimeoutException, AppException, IOException {\n\n        PostOffice po = PostOffice.getInstance();\n        EventEnvelope response = po.request(\"hello.pojo\", 3000, new Kv(\"id\", id));\n        // confirm that the PoJo object is transported correctly over the event stream system\n        if (response.getBody() instanceof SamplePoJo) {\n            return response.getBody();\n        } else {\n            if (response.getBody() == null) {\n                throw new AppException(500, \"Invalid service response. Expect: \" +\n                        SamplePoJo.class.getName() + \", actual: null\");\n            } else {\n                throw new AppException(500, \"Invalid service response. Expect: \" +\n                        SamplePoJo.class.getName() + \", actual: \" + response.getBody().getClass().getName());\n            }\n        }\n\n    }\n\n    @GET\n    @Path(\"/generic/{id}\")\n    @Produces({MediaType.TEXT_PLAIN, MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON, MediaType.TEXT_HTML})\n    public Object getGeneric(@PathParam(\"id\") Integer id) throws TimeoutException, AppException, IOException {\n\n        PostOffice po = PostOffice.getInstance();\n        EventEnvelope response = po.request(\"hello.generic\", 3000, new Kv(\"id\", id.toString()));\n        // demonstrate error handling\n        if (response.hasError()) {\n            throw new AppException(response.getStatus(), response.getError());\n        }\n        // confirm that the PoJo object is transported correctly over the event stream system\n        if (response.getBody() instanceof ObjectWithGenericType) {\n            ObjectWithGenericType result = (ObjectWithGenericType) response.getBody();\n            if (result.getContent() instanceof SamplePoJo) {\n                return response.getBody();\n            } else {\n                throw new AppException(500, \"Invalid service response. Expect: \" +\n                        SamplePoJo.class.getSimpleName() + \" as a parametric type of \" +\n                        ObjectWithGenericType.class.getName()+\", actual: \" + response.getBody().getClass().getName());\n            }\n        } else {\n            if (response.getBody() == null) {\n                throw new AppException(500, \"Invalid service response. Expect: \" +\n                        ObjectWithGenericType.class.getName() + \", actual: null\");\n            } else {\n                throw new AppException(500, \"Invalid service response. Expect: \" +\n                        ObjectWithGenericType.class.getName() + \", actual: \" + response.getBody().getClass().getName());\n            }\n        }\n    }\n\n    @POST\n    @Path(\"/echo\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})\n    public Object echoPojo(SamplePoJo pojo) {\n        // this demonstrates that you can send a PoJo and receive a PoJo\n        pojo.setOrigin(Platform.getInstance().getOrigin());\n        return pojo;\n    }\n\n}\n", "target": 1}
{"idx": 921, "func": "package org.junit.rules;\n\nimport static org.hamcrest.CoreMatchers.hasItem;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.IsNot.not;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeTrue;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.failureCountIs;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.junit.After;\nimport org.junit.AssumptionViolatedException;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class TempFolderRuleTest {\n    private static File[] createdFiles = new File[20];\n\n    public static class HasTempFolder {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingTempFolder() throws IOException {\n            createdFiles[0] = folder.newFile(\"myfile.txt\");\n            assertTrue(createdFiles[0].exists());\n        }\n\n        @Test\n        public void testTempFolderLocation() throws IOException {\n            File folderRoot = folder.getRoot();\n            String tmpRoot = System.getProperty(\"java.io.tmpdir\");\n            assertTrue(folderRoot.toString().startsWith(tmpRoot));\n        }\n    }\n\n    @Test\n    public void tempFolderIsDeleted() {\n        assertThat(testResult(HasTempFolder.class), isSuccessful());\n        assertFalse(createdFiles[0].exists());\n    }\n\n    public static class CreatesSubFolder {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingTempFolderStringReflection() throws Exception {\n            String subfolder = \"subfolder\";\n            String filename = \"a.txt\";\n            // force usage of folder.newFolder(String),\n            // check is available and works, to avoid a potential NoSuchMethodError with non-recompiled code.\n            Method method = folder.getClass().getMethod(\"newFolder\", new Class<?>[]{String.class});\n            createdFiles[0] = (File) method.invoke(folder, subfolder);\n            new File(createdFiles[0], filename).createNewFile();\n\n            File expectedFile = new File(folder.getRoot(), join(subfolder, filename));\n\n            assertTrue(expectedFile.exists());\n        }\n\n        @Test\n        public void testUsingTempFolderString() throws IOException {\n            String subfolder = \"subfolder\";\n            String filename = \"a.txt\";\n            // this uses newFolder(String), ensure that a single String works\n            createdFiles[0] = folder.newFolder(subfolder);\n            new File(createdFiles[0], filename).createNewFile();\n\n            File expectedFile = new File(folder.getRoot(), join(subfolder, filename));\n\n            assertTrue(expectedFile.exists());\n        }\n\n        @Test\n        public void testUsingTempTreeFolders() throws IOException {\n            String subfolder = \"subfolder\";\n            String anotherfolder = \"anotherfolder\";\n            String filename = \"a.txt\";\n\n            createdFiles[0] = folder.newFolder(subfolder, anotherfolder);\n            new File(createdFiles[0], filename).createNewFile();\n\n            File expectedFile = new File(folder.getRoot(), join(subfolder, anotherfolder, filename));\n\n            assertTrue(expectedFile.exists());\n        }\n\n        private String join(String... folderNames) {\n            StringBuilder path = new StringBuilder();\n            for (String folderName : folderNames) {\n                path.append(File.separator).append(folderName);\n            }\n            return path.toString();\n        }\n    }\n\n    @Test\n    public void subFolderIsDeleted() {\n        assertThat(testResult(CreatesSubFolder.class), isSuccessful());\n        assertFalse(createdFiles[0].exists());\n    }\n\n    public static class CreatesRandomSubFolders {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingRandomTempFolders() throws IOException {\n            for (int i = 0; i < 20; i++) {\n                File newFolder = folder.newFolder();\n                assertThat(Arrays.asList(createdFiles), not(hasItem(newFolder)));\n                createdFiles[i] = newFolder;\n                new File(newFolder, \"a.txt\").createNewFile();\n                assertTrue(newFolder.exists());\n            }\n        }\n    }\n\n    @Test\n    public void randomSubFoldersAreDeleted() {\n        assertThat(testResult(CreatesRandomSubFolders.class), isSuccessful());\n        for (File f : createdFiles) {\n            assertFalse(f.exists());\n        }\n    }\n\n    public static class CreatesRandomFiles {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingRandomTempFiles() throws IOException {\n            for (int i = 0; i < 20; i++) {\n                File newFile = folder.newFile();\n                assertThat(Arrays.asList(createdFiles), not(hasItem(newFile)));\n                createdFiles[i] = newFile;\n                assertTrue(newFile.exists());\n            }\n        }\n    }\n\n    @Test\n    public void randomFilesAreDeleted() {\n        assertThat(testResult(CreatesRandomFiles.class), isSuccessful());\n        for (File f : createdFiles) {\n            assertFalse(f.exists());\n        }\n    }\n\n    @Test\n    public void recursiveDeleteFolderWithOneElement() throws IOException {\n        TemporaryFolder folder = new TemporaryFolder();\n        folder.create();\n        File file = folder.newFile(\"a\");\n        folder.delete();\n        assertFalse(file.exists());\n        assertFalse(folder.getRoot().exists());\n    }\n\n    @Test\n    public void recursiveDeleteFolderWithOneRandomElement() throws IOException {\n        TemporaryFolder folder = new TemporaryFolder();\n        folder.create();\n        File file = folder.newFile();\n        folder.delete();\n        assertFalse(file.exists());\n        assertFalse(folder.getRoot().exists());\n    }\n\n    @Test\n    public void recursiveDeleteFolderWithZeroElements() throws IOException {\n        TemporaryFolder folder = new TemporaryFolder();\n        folder.create();\n        folder.delete();\n        assertFalse(folder.getRoot().exists());\n    }\n\n    @Test\n    public void tempFolderIsOnlyAccessibleByOwner() throws IOException {\n        TemporaryFolder folder = new TemporaryFolder();\n        folder.create();\n\n        Set<String> expectedPermissions = new TreeSet<String>(Arrays.asList(\"OWNER_READ\", \"OWNER_WRITE\", \"OWNER_EXECUTE\"));\n        Set<String> actualPermissions = getPosixFilePermissions(folder.getRoot());\n        assertEquals(expectedPermissions, actualPermissions);\n    }\n\n    private Set<String> getPosixFilePermissions(File root) {\n        try {\n            Class<?> pathClass = Class.forName(\"java.nio.file.Path\");\n            Object linkOptionArray = Array.newInstance(Class.forName(\"java.nio.file.LinkOption\"), 0);\n            Class<?> filesClass = Class.forName(\"java.nio.file.Files\");\n            Object path = File.class.getDeclaredMethod(\"toPath\").invoke(root);\n            Method posixFilePermissionsMethod = filesClass.getDeclaredMethod(\"getPosixFilePermissions\", pathClass, linkOptionArray.getClass());\n            Set<?> permissions = (Set<?>) posixFilePermissionsMethod.invoke(null, path, linkOptionArray);\n            SortedSet<String> convertedPermissions = new TreeSet<String>();\n            for (Object item : permissions) {\n                convertedPermissions.add(item.toString());\n            }\n            return convertedPermissions;\n        } catch (Exception e) {\n            throw new AssumptionViolatedException(\"Test requires at least Java 1.7\", e);\n        }\n    }\n\n    public static class NameClashes {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void fileWithFileClash() throws IOException {\n            folder.newFile(\"something.txt\");\n            folder.newFile(\"something.txt\");\n        }\n\n        @Test\n        public void fileWithFolderTest() throws IOException {\n            folder.newFolder(\"dummy\");\n            folder.newFile(\"dummy\");\n        }\n    }\n\n    @Test\n    public void nameClashesResultInTestFailures() {\n        assertThat(testResult(NameClashes.class), failureCountIs(2));\n    }\n\n    private static final String GET_ROOT_DUMMY = \"dummy-getRoot\";\n\n    private static final String NEW_FILE_DUMMY = \"dummy-newFile\";\n\n    private static final String NEW_FOLDER_DUMMY = \"dummy-newFolder\";\n\n    public static class IncorrectUsage {\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testGetRoot() throws IOException {\n            new File(folder.getRoot(), GET_ROOT_DUMMY).createNewFile();\n        }\n\n        @Test\n        public void testNewFile() throws IOException {\n            folder.newFile(NEW_FILE_DUMMY);\n        }\n\n        @Test\n        public void testNewFolder() throws IOException {\n            folder.newFolder(NEW_FOLDER_DUMMY);\n        }\n    }\n\n    @Test\n    public void incorrectUsageWithoutApplyingTheRuleShouldNotPolluteTheCurrentWorkingDirectory() {\n        assertThat(testResult(IncorrectUsage.class), failureCountIs(3));\n        assertFalse(\"getRoot should have failed early\", new File(GET_ROOT_DUMMY).exists());\n        assertFalse(\"newFile should have failed early\", new File(NEW_FILE_DUMMY).exists());\n        assertFalse(\"newFolder should have failed early\", new File(NEW_FOLDER_DUMMY).exists());\n    }\n\n    @After\n    public void cleanCurrentWorkingDirectory() {\n        new File(GET_ROOT_DUMMY).delete();\n        new File(NEW_FILE_DUMMY).delete();\n        new File(NEW_FOLDER_DUMMY).delete();\n    }\n}\n", "target": 0}
{"idx": 922, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport static com.vmware.xenon.services.common.authn.BasicAuthenticationUtils.constructBasicAuth;\n\nimport java.net.URI;\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.services.common.ExampleServiceHost;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UserService;\nimport com.vmware.xenon.services.common.authn.AuthenticationRequest;\nimport com.vmware.xenon.services.common.authn.BasicAuthenticationService;\n\npublic class TestExampleServiceHost extends BasicReusableHostTestCase {\n\n    private static final String adminUser = \"admin@localhost\";\n    private static final String exampleUser = \"example@localhost\";\n\n    /**\n     * Verify that the example service host creates users as expected.\n     *\n     * In theory we could test that authentication and authorization works correctly\n     * for these users. It's not critical to do here since we already test it in\n     * TestAuthSetupHelper.\n     */\n    @Test\n    public void createUsers() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        TemporaryFolder tmpFolder = new TemporaryFolder();\n        tmpFolder.create();\n        try {\n            String bindAddress = \"127.0.0.1\";\n\n            String[] args = {\n                    \"--sandbox=\"\n                            + tmpFolder.getRoot().getAbsolutePath(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--isAuthorizationEnabled=\" + Boolean.TRUE.toString(),\n                    \"--adminUser=\" + adminUser,\n                    \"--adminUserPassword=\" + adminUser,\n                    \"--exampleUser=\" + exampleUser,\n                    \"--exampleUserPassword=\" + exampleUser,\n            };\n\n            h.initialize(args);\n            h.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n            h.start();\n\n            URI hostUri = h.getUri();\n            String authToken = loginUser(hostUri);\n            waitForUsers(hostUri, authToken);\n\n        } finally {\n            h.stop();\n            tmpFolder.delete();\n        }\n    }\n\n    /**\n     * Supports createUsers() by logging in as the admin. The admin user\n     * isn't created immediately, so this polls.\n     */\n    private String loginUser(URI hostUri) throws Throwable {\n        URI usersLink = UriUtils.buildUri(hostUri, UserService.FACTORY_LINK);\n        // wait for factory availability\n        this.host.setSystemAuthorizationContext();\n        this.host.waitForReplicatedFactoryServiceAvailable(usersLink);\n        this.host.resetAuthorizationContext();\n\n        String basicAuth = constructBasicAuth(adminUser, adminUser);\n        URI loginUri = UriUtils.buildUri(hostUri, ServiceUriPaths.CORE_AUTHN_BASIC);\n        AuthenticationRequest login = new AuthenticationRequest();\n        login.requestType = AuthenticationRequest.AuthenticationRequestType.LOGIN;\n\n        String[] authToken = new String[1];\n        authToken[0] = null;\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            Operation loginPost = Operation.createPost(loginUri)\n                    .setBody(login)\n                    .addRequestHeader(BasicAuthenticationService.AUTHORIZATION_HEADER_NAME,\n                            basicAuth)\n                    .forceRemote()\n                    .setCompletion((op, ex) -> {\n                        if (ex != null) {\n                            this.host.completeIteration();\n                            return;\n                        }\n                        authToken[0] = op.getResponseHeader(Operation.REQUEST_AUTH_TOKEN_HEADER);\n                        this.host.completeIteration();\n                    });\n\n            this.host.testStart(1);\n            this.host.send(loginPost);\n            this.host.testWait();\n\n            if (authToken[0] != null) {\n                break;\n            }\n            Thread.sleep(250);\n        }\n\n        if (new Date().after(exp)) {\n            throw new TimeoutException();\n        }\n\n        assertNotNull(authToken[0]);\n\n        return authToken[0];\n    }\n\n    /**\n     * Supports createUsers() by waiting for two users to be created. They aren't created immediately,\n     * so this polls.\n     */\n    private void waitForUsers(URI hostUri, String authToken) throws Throwable {\n        URI usersLink = UriUtils.buildUri(hostUri, UserService.FACTORY_LINK);\n        Integer[] numberUsers = new Integer[1];\n        for (int i = 0; i < 20; i++) {\n            Operation get = Operation.createGet(usersLink)\n                    .forceRemote()\n                    .addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken)\n                    .setCompletion((op, ex) -> {\n                        if (ex != null) {\n                            if (op.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                this.host.failIteration(ex);\n                                return;\n                            } else {\n                                numberUsers[0] = 0;\n                                this.host.completeIteration();\n                                return;\n                            }\n                        }\n                        ServiceDocumentQueryResult response = op\n                                .getBody(ServiceDocumentQueryResult.class);\n                        assertTrue(response != null && response.documentLinks != null);\n                        numberUsers[0] = response.documentLinks.size();\n                        this.host.completeIteration();\n                    });\n\n            this.host.testStart(1);\n            this.host.send(get);\n            this.host.testWait();\n\n            if (numberUsers[0] == 2) {\n                break;\n            }\n            Thread.sleep(250);\n        }\n        assertTrue(numberUsers[0] == 2);\n    }\n\n}\n", "target": 0}
{"idx": 923, "func": "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\n\npackage org.opencastproject.search.impl.solr;\n\nimport static org.opencastproject.security.api.Permissions.Action.READ;\nimport static org.opencastproject.security.api.Permissions.Action.WRITE;\nimport static org.opencastproject.util.RequireUtil.notNull;\nimport static org.opencastproject.util.data.Collections.flatMap;\nimport static org.opencastproject.util.data.Collections.head;\nimport static org.opencastproject.util.data.Collections.map;\nimport static org.opencastproject.util.data.Option.option;\n\nimport org.opencastproject.mediapackage.Attachment;\nimport org.opencastproject.mediapackage.Catalog;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageElement;\nimport org.opencastproject.mediapackage.MediaPackageElements;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.MediaPackageReference;\nimport org.opencastproject.metadata.api.MetadataValue;\nimport org.opencastproject.metadata.api.StaticMetadata;\nimport org.opencastproject.metadata.api.StaticMetadataService;\nimport org.opencastproject.metadata.api.util.Interval;\nimport org.opencastproject.metadata.dublincore.DCMIPeriod;\nimport org.opencastproject.metadata.dublincore.DublinCore;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalog;\nimport org.opencastproject.metadata.dublincore.DublinCoreValue;\nimport org.opencastproject.metadata.dublincore.EncodingSchemeUtils;\nimport org.opencastproject.metadata.dublincore.Temporal;\nimport org.opencastproject.metadata.mpeg7.AudioVisual;\nimport org.opencastproject.metadata.mpeg7.FreeTextAnnotation;\nimport org.opencastproject.metadata.mpeg7.KeywordAnnotation;\nimport org.opencastproject.metadata.mpeg7.MediaDuration;\nimport org.opencastproject.metadata.mpeg7.MediaTime;\nimport org.opencastproject.metadata.mpeg7.MediaTimePoint;\nimport org.opencastproject.metadata.mpeg7.Mpeg7Catalog;\nimport org.opencastproject.metadata.mpeg7.Mpeg7CatalogService;\nimport org.opencastproject.metadata.mpeg7.MultimediaContent;\nimport org.opencastproject.metadata.mpeg7.MultimediaContentType;\nimport org.opencastproject.metadata.mpeg7.SpatioTemporalDecomposition;\nimport org.opencastproject.metadata.mpeg7.TextAnnotation;\nimport org.opencastproject.metadata.mpeg7.Video;\nimport org.opencastproject.metadata.mpeg7.VideoSegment;\nimport org.opencastproject.metadata.mpeg7.VideoText;\nimport org.opencastproject.search.api.SearchResultItem.SearchResultItemType;\nimport org.opencastproject.search.impl.persistence.SearchServiceDatabaseException;\nimport org.opencastproject.security.api.AccessControlEntry;\nimport org.opencastproject.security.api.AccessControlList;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.series.api.SeriesException;\nimport org.opencastproject.series.api.SeriesService;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.SolrUtils;\nimport org.opencastproject.util.data.Function;\nimport org.opencastproject.util.data.Option;\nimport org.opencastproject.workspace.api.Workspace;\n\nimport org.apache.solr.client.solrj.SolrQuery;\nimport org.apache.solr.client.solrj.SolrServer;\nimport org.apache.solr.client.solrj.SolrServerException;\nimport org.apache.solr.client.solrj.response.QueryResponse;\nimport org.apache.solr.client.solrj.util.ClientUtils;\nimport org.apache.solr.common.SolrDocument;\nimport org.apache.solr.common.SolrInputDocument;\nimport org.apache.solr.common.params.SolrParams;\nimport org.apache.solr.servlet.SolrRequestParsers;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\n/**\n * Utility class used to manage the search index.\n */\npublic class SolrIndexManager {\n\n  /** Logging facility */\n  private static final Logger logger = LoggerFactory.getLogger(SolrIndexManager.class);\n\n  /** Connection to the database */\n  private SolrServer solrServer = null;\n\n  /**\n   * Factor multiplied to fine tune relevance and confidence impact on important keyword decision. importance =\n   * RELEVANCE_BOOST * relevance + confidence\n   */\n  private static final double RELEVANCE_BOOST = 2.0;\n\n  /** Number of characters an important should have at least. */\n  private static final int MAX_CHAR = 3;\n\n  /** Maximum number of important keywords to detect. */\n  private static final int MAX_IMPORTANT_COUNT = 10;\n\n  /** List of metadata services sorted by priority in reverse order. */\n  private List<StaticMetadataService> mdServices;\n\n  private SeriesService seriesService;\n\n  private Mpeg7CatalogService mpeg7CatalogService;\n\n  private Workspace workspace;\n\n  private SecurityService securityService;\n\n  /** Convert a DublinCoreValue into a date. */\n  private static Function<DublinCoreValue, Option<Date>> toDateF = new Function<DublinCoreValue, Option<Date>>() {\n    @Override\n    public Option<Date> apply(DublinCoreValue v) {\n      return EncodingSchemeUtils.decodeTemporal(v).fold(new Temporal.Match<Option<Date>>() {\n        @Override\n        public Option<Date> period(DCMIPeriod period) {\n          return option(period.getStart());\n        }\n\n        @Override\n        public Option<Date> instant(Date instant) {\n          return Option.some(instant);\n        }\n\n        @Override\n        public Option<Date> duration(long duration) {\n          return Option.none();\n        }\n      });\n    }\n  };\n\n  /** Convert a DublinCoreValue into a duration (long). */\n  private static Function<DublinCoreValue, Option<Long>> toDurationF = new Function<DublinCoreValue, Option<Long>>() {\n    @Override\n    public Option<Long> apply(DublinCoreValue dublinCoreValue) {\n      return option(EncodingSchemeUtils.decodeDuration(dublinCoreValue));\n    }\n  };\n\n  /** Dynamic reference. */\n  public void setStaticMetadataServices(List<StaticMetadataService> mdServices) {\n    this.mdServices = new ArrayList<StaticMetadataService>(mdServices);\n    Collections.sort(this.mdServices, new Comparator<StaticMetadataService>() {\n      @Override\n      public int compare(StaticMetadataService a, StaticMetadataService b) {\n        return b.getPriority() - a.getPriority();\n      }\n    });\n  }\n\n  /**\n   * Creates a new management instance for the search index.\n   *\n   * @param connection\n   *          connection to the database\n   */\n  public SolrIndexManager(SolrServer connection, Workspace workspace, List<StaticMetadataService> mdServices,\n          SeriesService seriesService, Mpeg7CatalogService mpeg7CatalogService, SecurityService securityService) {\n\n    this.solrServer = notNull(connection, \"solr connection\");\n    this.workspace = notNull(workspace, \"workspace\");\n    this.seriesService = notNull(seriesService, \"series service\");\n    this.mpeg7CatalogService = notNull(mpeg7CatalogService, \"mpeg7 service\");\n    this.securityService = notNull(securityService, \"security service\");\n    setStaticMetadataServices(notNull(mdServices, \"metadata service\"));\n  }\n\n  /**\n   * Clears the search index. Make sure you know what you are doing.\n   *\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public void clear() throws SolrServerException {\n    try {\n      solrServer.deleteByQuery(\"*:*\");\n      solrServer.commit();\n    } catch (IOException e) {\n      throw new SolrServerException(e);\n    }\n  }\n\n  /**\n   * Removes the entry with the given <code>id</code> from the database. The entry can either be a series or an episode.\n   *\n   * @param id\n   *          identifier of the series or episode to delete\n   * @param deletionDate\n   *          the deletion date\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public boolean delete(String id, Date deletionDate) throws SolrServerException {\n    try {\n      // Load the existing episode\n      QueryResponse solrResponse = null;\n      try {\n        SolrQuery query = new SolrQuery(Schema.ID + \":\" + ClientUtils.escapeQueryChars(id) + \" AND -\"\n                + Schema.OC_DELETED + \":[* TO *]\");\n        solrResponse = solrServer.query(query);\n      } catch (Exception e1) {\n        throw new SolrServerException(e1);\n      }\n\n      // Did we find the episode?\n      if (solrResponse.getResults().size() == 0) {\n        logger.warn(\"Trying to delete non-existing media package {} from the search index\", id);\n        return false;\n      }\n\n      // Use all existing fields\n      SolrDocument doc = solrResponse.getResults().get(0);\n      SolrInputDocument inputDocument = new SolrInputDocument();\n      for (String field : doc.getFieldNames()) {\n        inputDocument.setField(field, doc.get(field));\n      }\n\n      // Set the oc_deleted field to the current date, then update\n      Schema.setOcDeleted(inputDocument, deletionDate);\n      solrServer.add(inputDocument);\n      solrServer.commit();\n      return true;\n    } catch (IOException e) {\n      throw new SolrServerException(e);\n    }\n  }\n\n  /**\n   * Posts the media package to solr. Depending on what is referenced in the media package, the method might create one\n   * or two entries: one for the episode and one for the series that the episode belongs to.\n   *\n   * This implementation of the search service removes all references to non \"engage/download\" media tracks\n   *\n   * @param sourceMediaPackage\n   *          the media package to post\n   * @param acl\n   *          the access control list for this mediapackage\n   * @param now\n   *          current date\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public boolean add(MediaPackage sourceMediaPackage, AccessControlList acl, Date now) throws SolrServerException,\n          UnauthorizedException {\n    try {\n      SolrInputDocument episodeDocument = createEpisodeInputDocument(sourceMediaPackage, acl);\n      Schema.setOcModified(episodeDocument, now);\n\n      SolrInputDocument seriesDocument = createSeriesInputDocument(sourceMediaPackage.getSeries(), acl);\n      if (seriesDocument != null)\n        Schema.enrich(episodeDocument, seriesDocument);\n\n      // If neither an episode nor a series was contained, there is no point in trying to update\n      if (episodeDocument == null && seriesDocument == null) {\n        logger.warn(\"Neither episode nor series metadata found\");\n        return false;\n      }\n\n      // Post everything to the search index\n      if (episodeDocument != null)\n        solrServer.add(episodeDocument);\n      if (seriesDocument != null)\n        solrServer.add(seriesDocument);\n      solrServer.commit();\n      return true;\n    } catch (Exception e) {\n      logger.error(\"Unable to add mediapackage {} to index\", sourceMediaPackage.getIdentifier());\n      throw new SolrServerException(e);\n    }\n  }\n\n  /**\n   * Posts the media package to solr. Depending on what is referenced in the media package, the method might create one\n   * or two entries: one for the episode and one for the series that the episode belongs to.\n   *\n   * This implementation of the search service removes all references to non \"engage/download\" media tracks\n   *\n   * @param sourceMediaPackage\n   *          the media package to post\n   * @param acl\n   *          the access control list for this mediapackage\n   * @param deletionDate\n   *          the deletion date\n   * @param modificationDate\n   *          the modification date\n   * @return <code>true</code> if successfully added\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public boolean add(MediaPackage sourceMediaPackage, AccessControlList acl, Date deletionDate, Date modificationDate)\n          throws SolrServerException {\n    try {\n      SolrInputDocument episodeDocument = createEpisodeInputDocument(sourceMediaPackage, acl);\n\n      SolrInputDocument seriesDocument = createSeriesInputDocument(sourceMediaPackage.getSeries(), acl);\n      if (seriesDocument != null)\n        Schema.enrich(episodeDocument, seriesDocument);\n\n      Schema.setOcModified(episodeDocument, modificationDate);\n      if (deletionDate != null)\n        Schema.setOcDeleted(episodeDocument, deletionDate);\n\n      solrServer.add(episodeDocument);\n      solrServer.add(seriesDocument);\n      solrServer.commit();\n      return true;\n    } catch (Exception e) {\n      logger.error(\"Unable to add mediapackage {} to index\", sourceMediaPackage.getIdentifier());\n      try {\n        solrServer.rollback();\n      } catch (IOException e1) {\n        throw new SolrServerException(e1);\n      }\n      throw new SolrServerException(e);\n    }\n  }\n\n  /**\n   * Creates a solr input document for the episode metadata of the media package.\n   *\n   * @param mediaPackage\n   *          the media package\n   * @param acl\n   *          the access control list for this mediapackage\n   * @return an input document ready to be posted to solr\n   * @throws MediaPackageException\n   *           if serialization of the media package fails\n   */\n  private SolrInputDocument createEpisodeInputDocument(MediaPackage mediaPackage, AccessControlList acl)\n          throws MediaPackageException, IOException {\n\n    SolrInputDocument doc = new SolrInputDocument();\n    String mediaPackageId = mediaPackage.getIdentifier().toString();\n\n    // Fill the input document\n    Schema.setId(doc, mediaPackageId);\n    // /\n    // OC specific fields\n    Schema.setOcMediatype(doc, SearchResultItemType.AudioVisual.toString());\n    Schema.setOrganization(doc, securityService.getOrganization().getId());\n    Schema.setOcMediapackage(doc, MediaPackageParser.getAsXml(mediaPackage));\n    Schema.setOcElementtags(doc, tags(mediaPackage));\n    Schema.setOcElementflavors(doc, flavors(mediaPackage));\n    // Add cover\n    Attachment[] cover = mediaPackage.getAttachments(MediaPackageElements.MEDIAPACKAGE_COVER_FLAVOR);\n    if (cover != null && cover.length > 0) {\n      Schema.setOcCover(doc, cover[0].getURI().toString());\n    }\n\n    // /\n    // Add standard dublin core fields\n    // naive approach. works as long as only setters, not adders are available in the schema\n    for (StaticMetadata md : getMetadata(mdServices, mediaPackage))\n      addEpisodeMetadata(doc, md);\n\n    // /\n    // Add mpeg7\n    logger.debug(\"Looking for mpeg-7 catalogs containing segment texts\");\n    Catalog[] mpeg7Catalogs = mediaPackage.getCatalogs(MediaPackageElements.TEXTS);\n    if (mpeg7Catalogs.length == 0) {\n      logger.debug(\"No text catalogs found, trying segments only\");\n      mpeg7Catalogs = mediaPackage.getCatalogs(MediaPackageElements.SEGMENTS);\n    }\n    // TODO: merge the segments from each mpeg7 if there is more than one mpeg7 catalog\n    if (mpeg7Catalogs.length > 0) {\n      try {\n        Mpeg7Catalog mpeg7Catalog = loadMpeg7Catalog(mpeg7Catalogs[0]);\n        addMpeg7Metadata(doc, mediaPackage, mpeg7Catalog);\n      } catch (IOException e) {\n        logger.error(\"Error loading mpeg7 catalog. Skipping catalog\", e);\n      }\n    } else {\n      logger.debug(\"No segmentation catalog found\");\n    }\n\n    // /\n    // Add authorization\n    setAuthorization(doc, securityService, acl);\n\n    return doc;\n  }\n\n  static void addEpisodeMetadata(final SolrInputDocument doc, final StaticMetadata md) {\n    Schema.fill(doc, new Schema.FieldCollector() {\n      @Override\n      public Option<String> getId() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOrganization() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getDcCreated() {\n        return md.getCreated();\n      }\n\n      @Override\n      public Option<Long> getDcExtent() {\n        return md.getExtent();\n      }\n\n      @Override\n      public Option<String> getDcLanguage() {\n        return md.getLanguage();\n      }\n\n      @Override\n      public Option<String> getDcIsPartOf() {\n        return md.getIsPartOf();\n      }\n\n      @Override\n      public Option<String> getDcReplaces() {\n        return md.getReplaces();\n      }\n\n      @Override\n      public Option<String> getDcType() {\n        return md.getType();\n      }\n\n      @Override\n      public Option<Date> getDcAvailableFrom() {\n        return md.getAvailable().flatMap(new Function<Interval, Option<Date>>() {\n          @Override\n          public Option<Date> apply(Interval interval) {\n            return interval.fold(new Interval.Match<Option<Date>>() {\n              @Override\n              public Option<Date> bounded(Date leftBound, Date rightBound) {\n                return Option.some(leftBound);\n              }\n\n              @Override\n              public Option<Date> leftInfinite(Date rightBound) {\n                return Option.none();\n              }\n\n              @Override\n              public Option<Date> rightInfinite(Date leftBound) {\n                return Option.some(leftBound);\n              }\n            });\n          }\n        });\n      }\n\n      @Override\n      public Option<Date> getDcAvailableTo() {\n        return md.getAvailable().flatMap(new Function<Interval, Option<Date>>() {\n          @Override\n          public Option<Date> apply(Interval interval) {\n            return interval.fold(new Interval.Match<Option<Date>>() {\n              @Override\n              public Option<Date> bounded(Date leftBound, Date rightBound) {\n                return Option.some(rightBound);\n              }\n\n              @Override\n              public Option<Date> leftInfinite(Date rightBound) {\n                return Option.some(rightBound);\n              }\n\n              @Override\n              public Option<Date> rightInfinite(Date leftBound) {\n                return Option.none();\n              }\n            });\n          }\n        });\n      }\n\n      @Override\n      public List<DField<String>> getDcTitle() {\n        return fromMValue(md.getTitles());\n      }\n\n      @Override\n      public List<DField<String>> getDcSubject() {\n        return fromMValue(md.getSubjects());\n      }\n\n      @Override\n      public List<DField<String>> getDcCreator() {\n        return fromMValue(md.getCreators());\n      }\n\n      @Override\n      public List<DField<String>> getDcPublisher() {\n        return fromMValue(md.getPublishers());\n      }\n\n      @Override\n      public List<DField<String>> getDcContributor() {\n        return fromMValue(md.getContributors());\n      }\n\n      @Override\n      public List<DField<String>> getDcDescription() {\n        return fromMValue(md.getDescription());\n      }\n\n      @Override\n      public List<DField<String>> getDcRightsHolder() {\n        return fromMValue(md.getRightsHolders());\n      }\n\n      @Override\n      public List<DField<String>> getDcSpatial() {\n        return fromMValue(md.getSpatials());\n      }\n\n      @Override\n      public List<DField<String>> getDcAccessRights() {\n        return fromMValue(md.getAccessRights());\n      }\n\n      @Override\n      public List<DField<String>> getDcLicense() {\n        return fromMValue(md.getLicenses());\n      }\n\n      @Override\n      public Option<String> getOcMediatype() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcMediapackage() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcKeywords() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcCover() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<Date> getOcModified() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<Date> getOcDeleted() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcElementtags() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcElementflavors() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public List<DField<String>> getOcAcl() {\n        return Collections.EMPTY_LIST; // set elsewhere\n      }\n\n      @Override\n      public List<DField<String>> getSegmentText() {\n        return Collections.EMPTY_LIST; // set elsewhere\n      }\n\n      @Override\n      public List<DField<String>> getSegmentHint() {\n        return Collections.EMPTY_LIST; // set elsewhere\n      }\n    });\n  }\n\n  static List<DField<String>> fromMValue(List<MetadataValue<String>> as) {\n    return map(as, new ArrayList<DField<String>>(), new Function<MetadataValue<String>, DField<String>>() {\n      @Override\n      public DField<String> apply(MetadataValue<String> v) {\n        return new DField<String>(v.getValue(), v.getLanguage());\n      }\n    });\n  }\n\n  static List<DField<String>> fromDCValue(List<DublinCoreValue> as) {\n    return map(as, new ArrayList<DField<String>>(), new Function<DublinCoreValue, DField<String>>() {\n      @Override\n      public DField<String> apply(DublinCoreValue v) {\n        return new DField<String>(v.getValue(), v.getLanguage());\n      }\n    });\n  }\n\n  /**\n   * Adds authorization fields to the solr document.\n   *\n   * @param doc\n   *          the solr document\n   * @param acl\n   *          the access control list\n   */\n  static void setAuthorization(SolrInputDocument doc, SecurityService securityService, AccessControlList acl) {\n    Map<String, List<String>> permissions = new HashMap<String, List<String>>();\n\n    // Define containers for common permissions\n    List<String> reads = new ArrayList<String>();\n    permissions.put(READ.toString(), reads);\n    List<String> writes = new ArrayList<String>();\n    permissions.put(WRITE.toString(), writes);\n\n    String adminRole = securityService.getOrganization().getAdminRole();\n\n    // The admin user can read and write\n    if (adminRole != null) {\n      reads.add(adminRole);\n      writes.add(adminRole);\n    }\n\n    for (AccessControlEntry entry : acl.getEntries()) {\n      if (!entry.isAllow()) {\n        logger.warn(\"Search service does not support denial via ACL, ignoring {}\", entry);\n        continue;\n      }\n      List<String> actionPermissions = permissions.get(entry.getAction());\n      /*\n       * MH-8353 a series could have a permission defined we don't know how to handle -DH\n       */\n      if (actionPermissions == null) {\n        logger.warn(\"Search service doesn't know how to handle action: \" + entry.getAction());\n        continue;\n      }\n      if (acl == null) {\n        actionPermissions = new ArrayList<String>();\n        permissions.put(entry.getAction(), actionPermissions);\n      }\n      actionPermissions.add(entry.getRole());\n\n    }\n\n    // Write the permissions to the solr document\n    for (Map.Entry<String, List<String>> entry : permissions.entrySet()) {\n      Schema.setOcAcl(doc, new DField<String>(mkString(entry.getValue(), \" \"), entry.getKey()));\n    }\n  }\n\n  static String mkString(Collection<?> as, String sep) {\n    StringBuffer b = new StringBuffer();\n    for (Object a : as) {\n      b.append(a).append(sep);\n    }\n    return b.substring(0, b.length() - sep.length());\n  }\n\n  private Mpeg7Catalog loadMpeg7Catalog(Catalog catalog) throws IOException {\n    try (InputStream in = workspace.read(catalog.getURI())) {\n      return mpeg7CatalogService.load(in);\n    } catch (NotFoundException e) {\n      throw new IOException(\"Unable to load metadata from mpeg7 catalog \" + catalog);\n    }\n  }\n\n  /**\n   * Creates a solr input document for the series metadata of the media package.\n   *\n   * @param seriesId\n   *          the id of the series\n   * @param acl\n   *          the access control list for this mediapackage\n   * @return an input document ready to be posted to solr or null\n   */\n  private SolrInputDocument createSeriesInputDocument(String seriesId, AccessControlList acl) throws IOException,\n          UnauthorizedException {\n\n    if (seriesId == null)\n      return null;\n    DublinCoreCatalog dc = null;\n    try {\n      dc = seriesService.getSeries(seriesId);\n    } catch (SeriesException e) {\n      logger.debug(\"No series dublincore found for series id \" + seriesId);\n      return null;\n    } catch (NotFoundException e) {\n      logger.debug(\"No series dublincore found for series id \" + seriesId);\n      return null;\n    }\n\n    SolrInputDocument doc = new SolrInputDocument();\n\n    // Populate document with existing data\n    try {\n      StringBuffer query = new StringBuffer(\"q=\");\n      query = query.append(Schema.ID).append(\":\").append(SolrUtils.clean(seriesId));\n      SolrParams params = SolrRequestParsers.parseQueryString(query.toString());\n      QueryResponse solrResponse = solrServer.query(params);\n      if (solrResponse.getResults().size() > 0) {\n        SolrDocument existingSolrDocument = solrResponse.getResults().get(0);\n        for (String fieldName : existingSolrDocument.getFieldNames()) {\n          doc.addField(fieldName, existingSolrDocument.getFieldValue(fieldName));\n        }\n      }\n    } catch (Exception e) {\n      logger.error(\"Error trying to load series \" + seriesId, e);\n    }\n\n    // Fill document\n    Schema.setId(doc, seriesId);\n\n    // OC specific fields\n    Schema.setOrganization(doc, securityService.getOrganization().getId());\n    Schema.setOcMediatype(doc, SearchResultItemType.Series.toString());\n    Schema.setOcModified(doc, new Date());\n\n    // DC fields\n    addSeriesMetadata(doc, dc);\n\n    // Authorization\n    setAuthorization(doc, securityService, acl);\n\n    return doc;\n  }\n\n  /**\n   * Add the standard dublin core fields to a series document.\n   *\n   * @param doc\n   *          the solr document to fill\n   * @param dc\n   *          the dublin core catalog to get the data from\n   */\n  static void addSeriesMetadata(final SolrInputDocument doc, final DublinCoreCatalog dc) throws IOException {\n    Schema.fill(doc, new Schema.FieldCollector() {\n      @Override\n      public Option<String> getId() {\n        return Option.some(dc.getFirst(DublinCore.PROPERTY_IDENTIFIER));\n      }\n\n      @Override\n      public Option<String> getOrganization() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getDcCreated() {\n        return head(dc.get(DublinCore.PROPERTY_CREATED)).flatMap(toDateF);\n      }\n\n      @Override\n      public Option<Long> getDcExtent() {\n        return head(dc.get(DublinCore.PROPERTY_EXTENT)).flatMap(toDurationF);\n      }\n\n      @Override\n      public Option<String> getDcLanguage() {\n        return option(dc.getFirst(DublinCore.PROPERTY_LANGUAGE));\n      }\n\n      @Override\n      public Option<String> getDcIsPartOf() {\n        return option(dc.getFirst(DublinCore.PROPERTY_IS_PART_OF));\n      }\n\n      @Override\n      public Option<String> getDcReplaces() {\n        return option(dc.getFirst(DublinCore.PROPERTY_REPLACES));\n      }\n\n      @Override\n      public Option<String> getDcType() {\n        return option(dc.getFirst(DublinCore.PROPERTY_TYPE));\n      }\n\n      @Override\n      public Option<Date> getDcAvailableFrom() {\n        return option(dc.getFirst(DublinCore.PROPERTY_AVAILABLE)).flatMap(new Function<String, Option<Date>>() {\n          @Override\n          public Option<Date> apply(String s) {\n            return option(EncodingSchemeUtils.decodePeriod(s).getStart());\n          }\n        });\n      }\n\n      @Override\n      public Option<Date> getDcAvailableTo() {\n        return option(dc.getFirst(DublinCore.PROPERTY_AVAILABLE)).flatMap(new Function<String, Option<Date>>() {\n          @Override\n          public Option<Date> apply(String s) {\n            return option(EncodingSchemeUtils.decodePeriod(s).getEnd());\n          }\n        });\n      }\n\n      @Override\n      public List<DField<String>> getDcTitle() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_TITLE));\n      }\n\n      @Override\n      public List<DField<String>> getDcSubject() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_SUBJECT));\n      }\n\n      @Override\n      public List<DField<String>> getDcCreator() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_CREATOR));\n      }\n\n      @Override\n      public List<DField<String>> getDcPublisher() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_PUBLISHER));\n      }\n\n      @Override\n      public List<DField<String>> getDcContributor() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_CONTRIBUTOR));\n\n      }\n\n      @Override\n      public List<DField<String>> getDcDescription() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_DESCRIPTION));\n      }\n\n      @Override\n      public List<DField<String>> getDcRightsHolder() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_RIGHTS_HOLDER));\n      }\n\n      @Override\n      public List<DField<String>> getDcSpatial() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_SPATIAL));\n      }\n\n      @Override\n      public List<DField<String>> getDcAccessRights() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_ACCESS_RIGHTS));\n      }\n\n      @Override\n      public List<DField<String>> getDcLicense() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_LICENSE));\n      }\n\n      @Override\n      public Option<String> getOcMediatype() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcMediapackage() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcKeywords() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcCover() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getOcModified() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getOcDeleted() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcElementtags() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcElementflavors() {\n        return Option.none();\n      }\n\n      @Override\n      public List<DField<String>> getOcAcl() {\n        return Collections.EMPTY_LIST;\n      }\n\n      @Override\n      public List<DField<String>> getSegmentText() {\n        return Collections.EMPTY_LIST;\n      }\n\n      @Override\n      public List<DField<String>> getSegmentHint() {\n        return Collections.EMPTY_LIST;\n      }\n    });\n  }\n\n  /**\n   * Add the mpeg 7 catalog data to the solr document.\n   *\n   * @param doc\n   *          the input document to the solr index\n   * @param mpeg7\n   *          the mpeg7 catalog\n   */\n  @SuppressWarnings(\"unchecked\")\n  static void addMpeg7Metadata(SolrInputDocument doc, MediaPackage mediaPackage, Mpeg7Catalog mpeg7) {\n\n    // Check for multimedia content\n    if (!mpeg7.multimediaContent().hasNext()) {\n      logger.warn(\"Mpeg-7 doesn't contain  multimedia content\");\n      return;\n    }\n\n    // Get the content duration by looking at the first content track. This\n    // of course assumes that all tracks are equally long.\n    MultimediaContent<? extends MultimediaContentType> mc = mpeg7.multimediaContent().next();\n    MultimediaContentType mct = mc.elements().next();\n    MediaTime mediaTime = mct.getMediaTime();\n    Schema.setDcExtent(doc, mediaTime.getMediaDuration().getDurationInMilliseconds());\n\n    // Check if the keywords have been filled by (manually) added dublin\n    // core data. If not, look for the most relevant fields in mpeg-7.\n    SortedSet<TextAnnotation> sortedAnnotations = null;\n    if (!\"\".equals(Schema.getOcKeywords(doc))) {\n      sortedAnnotations = new TreeSet<TextAnnotation>(new Comparator<TextAnnotation>() {\n        @Override\n        public int compare(TextAnnotation a1, TextAnnotation a2) {\n          if ((RELEVANCE_BOOST * a1.getRelevance() + a1.getConfidence()) > (RELEVANCE_BOOST * a2.getRelevance() + a2\n                  .getConfidence()))\n            return -1;\n          else if ((RELEVANCE_BOOST * a1.getRelevance() + a1.getConfidence()) < (RELEVANCE_BOOST * a2.getRelevance() + a2\n                  .getConfidence()))\n            return 1;\n          return 0;\n        }\n      });\n    }\n\n    // Iterate over the tracks and extract keywords and hints\n    Iterator<MultimediaContent<? extends MultimediaContentType>> mmIter = mpeg7.multimediaContent();\n    int segmentCount = 0;\n\n    while (mmIter.hasNext()) {\n      MultimediaContent<?> multimediaContent = mmIter.next();\n\n      // We need to process visual segments first, due to the way they are handled in the ui.\n      for (Iterator<?> iterator = multimediaContent.elements(); iterator.hasNext();) {\n\n        MultimediaContentType type = (MultimediaContentType) iterator.next();\n        if (!(type instanceof Video) && !(type instanceof AudioVisual))\n          continue;\n\n        // for every segment in the current multimedia content track\n\n        Video video = (Video) type;\n        Iterator<VideoSegment> vsegments = (Iterator<VideoSegment>) video.getTemporalDecomposition().segments();\n        while (vsegments.hasNext()) {\n          VideoSegment segment = vsegments.next();\n\n          StringBuffer segmentText = new StringBuffer();\n          StringBuffer hintField = new StringBuffer();\n\n          // Collect the video text elements to a segment text\n          SpatioTemporalDecomposition spt = segment.getSpatioTemporalDecomposition();\n          if (spt != null) {\n            for (VideoText videoText : spt.getVideoText()) {\n              if (segmentText.length() > 0)\n                segmentText.append(\" \");\n              segmentText.append(videoText.getText().getText());\n              // TODO: Add hint on bounding box\n            }\n          }\n\n          // Add keyword annotations\n          Iterator<TextAnnotation> textAnnotations = segment.textAnnotations();\n          while (textAnnotations.hasNext()) {\n            TextAnnotation textAnnotation = textAnnotations.next();\n            Iterator<?> kwIter = textAnnotation.keywordAnnotations();\n            while (kwIter.hasNext()) {\n              KeywordAnnotation keywordAnnotation = (KeywordAnnotation) kwIter.next();\n              if (segmentText.length() > 0)\n                segmentText.append(\" \");\n              segmentText.append(keywordAnnotation.getKeyword());\n            }\n          }\n\n          // Add free text annotations\n          Iterator<TextAnnotation> freeIter = segment.textAnnotations();\n          if (freeIter.hasNext()) {\n            Iterator<FreeTextAnnotation> freeTextIter = freeIter.next().freeTextAnnotations();\n            while (freeTextIter.hasNext()) {\n              FreeTextAnnotation freeTextAnnotation = freeTextIter.next();\n              if (segmentText.length() > 0)\n                segmentText.append(\" \");\n              segmentText.append(freeTextAnnotation.getText());\n            }\n          }\n\n          // add segment text to solr document\n          Schema.setSegmentText(doc, new DField<String>(segmentText.toString(), Integer.toString(segmentCount)));\n\n          // get the segments time properties\n          MediaTimePoint timepoint = segment.getMediaTime().getMediaTimePoint();\n          MediaDuration duration = segment.getMediaTime().getMediaDuration();\n\n          // TODO: define a class with hint field constants\n          hintField.append(\"time=\" + timepoint.getTimeInMilliseconds() + \"\\n\");\n          hintField.append(\"duration=\" + duration.getDurationInMilliseconds() + \"\\n\");\n\n          // Look for preview images. Their characteristics are that they are\n          // attached as attachments with a flavor of preview/<something>.\n          String time = timepoint.toString();\n          for (Attachment slide : mediaPackage.getAttachments(MediaPackageElements.PRESENTATION_SEGMENT_PREVIEW)) {\n            MediaPackageReference ref = slide.getReference();\n            if (ref != null && time.equals(ref.getProperty(\"time\"))) {\n              hintField.append(\"preview\");\n              hintField.append(\".\");\n              hintField.append(ref.getIdentifier());\n              hintField.append(\"=\");\n              hintField.append(slide.getURI().toString());\n              hintField.append(\"\\n\");\n            }\n          }\n\n          logger.trace(\"Adding segment: \" + timepoint.toString());\n          Schema.setSegmentHint(doc, new DField<String>(hintField.toString(), Integer.toString(segmentCount)));\n\n          // increase segment counter\n          segmentCount++;\n        }\n      }\n    }\n\n    // Put the most important keywords into a special solr field\n    if (sortedAnnotations != null) {\n      Schema.setOcKeywords(doc, importantKeywordsString(sortedAnnotations).toString());\n    }\n  }\n\n  /**\n   * Generates a string with the most important kewords from the text annotation.\n   *\n   * @param sortedAnnotations\n   * @return The keyword string.\n   */\n  static StringBuffer importantKeywordsString(SortedSet<TextAnnotation> sortedAnnotations) {\n\n    // important keyword:\n    // - high relevance\n    // - high confidence\n    // - occur often\n    // - more than MAX_CHAR chars\n\n    // calculate keyword occurences (histogram) and importance\n    ArrayList<String> list = new ArrayList<String>();\n    Iterator<TextAnnotation> textAnnotations = sortedAnnotations.iterator();\n    TextAnnotation textAnnotation = null;\n    String keyword = null;\n\n    HashMap<String, Integer> histogram = new HashMap<String, Integer>();\n    HashMap<String, Double> importance = new HashMap<String, Double>();\n    int occ = 0;\n    double imp;\n    while (textAnnotations.hasNext()) {\n      textAnnotation = textAnnotations.next();\n      Iterator<KeywordAnnotation> keywordAnnotations = textAnnotation.keywordAnnotations();\n      while (keywordAnnotations.hasNext()) {\n        KeywordAnnotation annotation = keywordAnnotations.next();\n        keyword = annotation.getKeyword().toLowerCase();\n        if (keyword.length() > MAX_CHAR) {\n          occ = 0;\n          if (histogram.keySet().contains(keyword)) {\n            occ = histogram.get(keyword);\n          }\n          histogram.put(keyword, occ + 1);\n\n          // here the importance value is calculated\n          // from relevance, confidence and frequency of occurence.\n          imp = (RELEVANCE_BOOST * getMaxRelevance(keyword, sortedAnnotations) + getMaxConfidence(keyword,\n                  sortedAnnotations)) * (occ + 1);\n          importance.put(keyword, imp);\n        }\n      }\n    }\n\n    // get the MAX_IMPORTANT_COUNT most important keywords\n    StringBuffer buf = new StringBuffer();\n\n    while (list.size() < MAX_IMPORTANT_COUNT && importance.size() > 0) {\n      double max = 0.0;\n      String maxKeyword = null;\n\n      // get maximum from importance list\n      for (Entry<String, Double> entry : importance.entrySet()) {\n        keyword = entry.getKey();\n        if (max < entry.getValue()) {\n          max = entry.getValue();\n          maxKeyword = keyword;\n        }\n      }\n\n      // pop maximum\n      importance.remove(maxKeyword);\n\n      // append keyword to string\n      if (buf.length() > 0)\n        buf.append(\" \");\n      buf.append(maxKeyword);\n    }\n\n    return buf;\n  }\n\n  /**\n   * Gets the maximum confidence for a given keyword in the text annotation.\n   *\n   * @param keyword\n   * @param sortedAnnotations\n   * @return The maximum confidence value.\n   */\n  static double getMaxConfidence(String keyword, SortedSet<TextAnnotation> sortedAnnotations) {\n    double max = 0.0;\n    String needle = null;\n    TextAnnotation textAnnotation = null;\n    Iterator<TextAnnotation> textAnnotations = sortedAnnotations.iterator();\n    while (textAnnotations.hasNext()) {\n      textAnnotation = textAnnotations.next();\n      Iterator<KeywordAnnotation> keywordAnnotations = textAnnotation.keywordAnnotations();\n      while (keywordAnnotations.hasNext()) {\n        KeywordAnnotation ann = keywordAnnotations.next();\n        needle = ann.getKeyword().toLowerCase();\n        if (keyword.equals(needle)) {\n          if (max < textAnnotation.getConfidence()) {\n            max = textAnnotation.getConfidence();\n          }\n        }\n      }\n    }\n    return max;\n  }\n\n  /**\n   * Gets the maximum relevance for a given keyword in the text annotation.\n   *\n   * @param keyword\n   * @param sortedAnnotations\n   * @return The maximum relevance value.\n   */\n  static double getMaxRelevance(String keyword, SortedSet<TextAnnotation> sortedAnnotations) {\n    double max = 0.0;\n    String needle = null;\n    TextAnnotation textAnnotation = null;\n    Iterator<TextAnnotation> textAnnotations = sortedAnnotations.iterator();\n    while (textAnnotations.hasNext()) {\n      textAnnotation = textAnnotations.next();\n      Iterator<KeywordAnnotation> keywordAnnotations = textAnnotation.keywordAnnotations();\n      while (keywordAnnotations.hasNext()) {\n        KeywordAnnotation ann = keywordAnnotations.next();\n        needle = ann.getKeyword().toLowerCase();\n        if (keyword.equals(needle)) {\n          if (max < textAnnotation.getRelevance()) {\n            max = textAnnotation.getRelevance();\n          }\n        }\n      }\n    }\n    return max;\n  }\n\n  /**\n   * Get metadata from all registered metadata services.\n   */\n  static List<StaticMetadata> getMetadata(final List<StaticMetadataService> mdServices, final MediaPackage mp) {\n    return flatMap(mdServices, new ArrayList<StaticMetadata>(),\n            new Function<StaticMetadataService, Collection<StaticMetadata>>() {\n              @Override\n              public Collection<StaticMetadata> apply(StaticMetadataService s) {\n                StaticMetadata md = s.getMetadata(mp);\n                return md != null ? Arrays.asList(md) : Collections.<StaticMetadata> emptyList();\n              }\n            });\n  }\n\n  /**\n   * Return all media package tags as a space separated string.\n   */\n  static String tags(MediaPackage mp) {\n    StringBuilder sb = new StringBuilder();\n    for (MediaPackageElement element : mp.getElements()) {\n      for (String tag : element.getTags()) {\n        sb.append(tag);\n        sb.append(\" \");\n      }\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Return all media package flavors as a space separated string.\n   */\n  static String flavors(MediaPackage mp) {\n    StringBuilder sb = new StringBuilder();\n    for (MediaPackageElement element : mp.getElements()) {\n      if (element.getFlavor() != null) {\n        sb.append(element.getFlavor().toString());\n        sb.append(\" \");\n      }\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Returns number of entries in search index, across all organizations.\n   *\n   * @return number of entries in search index\n   * @throws SearchServiceDatabaseException\n   *           if count cannot be retrieved\n   */\n  public long count() throws SearchServiceDatabaseException {\n    try {\n      QueryResponse response = solrServer.query(new SolrQuery(\"*:*\"));\n      return response.getResults().getNumFound();\n    } catch (SolrServerException e) {\n      throw new SearchServiceDatabaseException(e);\n    }\n  }\n}\n", "target": 1}
{"idx": 924, "func": "package org.bouncycastle.jcajce.provider.asymmetric.rsa;\n\nimport java.io.ByteArrayOutputStream;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.InvalidParameterException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.security.spec.MGF1ParameterSpec;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.OAEPParameterSpec;\nimport javax.crypto.spec.PSource;\n\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.crypto.AsymmetricBlockCipher;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.encodings.ISO9796d1Encoding;\nimport org.bouncycastle.crypto.encodings.OAEPEncoding;\nimport org.bouncycastle.crypto.encodings.PKCS1Encoding;\nimport org.bouncycastle.crypto.engines.RSABlindedEngine;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.BaseCipherSpi;\nimport org.bouncycastle.jcajce.provider.util.BadBlockException;\nimport org.bouncycastle.jcajce.provider.util.DigestFactory;\nimport org.bouncycastle.jcajce.util.BCJcaJceHelper;\nimport org.bouncycastle.jcajce.util.JcaJceHelper;\nimport org.bouncycastle.util.Strings;\n\npublic class CipherSpi\n    extends BaseCipherSpi\n{\n    private final JcaJceHelper helper = new BCJcaJceHelper();\n\n    private AsymmetricBlockCipher cipher;\n    private AlgorithmParameterSpec paramSpec;\n    private AlgorithmParameters engineParams;\n    private boolean                 publicKeyOnly = false;\n    private boolean                 privateKeyOnly = false;\n    private ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n\n    public CipherSpi(\n        AsymmetricBlockCipher engine)\n    {\n        cipher = engine;\n    }\n\n    public CipherSpi(\n        OAEPParameterSpec pSpec)\n    {\n        try\n        {\n            initFromSpec(pSpec);\n        }\n        catch (NoSuchPaddingException e)\n        {\n            throw new IllegalArgumentException(e.getMessage());\n        }\n    }\n\n    public CipherSpi(\n        boolean publicKeyOnly,\n        boolean privateKeyOnly,\n        AsymmetricBlockCipher engine)\n    {\n        this.publicKeyOnly = publicKeyOnly;\n        this.privateKeyOnly = privateKeyOnly;\n        cipher = engine;\n    }\n     \n    private void initFromSpec(\n        OAEPParameterSpec pSpec)\n        throws NoSuchPaddingException\n    {\n        MGF1ParameterSpec mgfParams = (MGF1ParameterSpec)pSpec.getMGFParameters();\n        Digest digest = DigestFactory.getDigest(mgfParams.getDigestAlgorithm());\n        \n        if (digest == null)\n        {\n            throw new NoSuchPaddingException(\"no match on OAEP constructor for digest algorithm: \"+ mgfParams.getDigestAlgorithm());\n        }\n\n        cipher = new OAEPEncoding(new RSABlindedEngine(), digest, ((PSource.PSpecified)pSpec.getPSource()).getValue());\n        paramSpec = pSpec;\n    }\n    \n    protected int engineGetBlockSize() \n    {\n        try\n        {\n            return cipher.getInputBlockSize();\n        }\n        catch (NullPointerException e)\n        {\n            throw new IllegalStateException(\"RSA Cipher not initialised\");\n        }\n    }\n\n    protected int engineGetKeySize(\n        Key key)\n    {\n        if (key instanceof RSAPrivateKey)\n        {\n            RSAPrivateKey k = (RSAPrivateKey)key;\n\n            return k.getModulus().bitLength();\n        }\n        else if (key instanceof RSAPublicKey)\n        {\n            RSAPublicKey k = (RSAPublicKey)key;\n\n            return k.getModulus().bitLength();\n        }\n\n        throw new IllegalArgumentException(\"not an RSA key!\");\n    }\n\n    protected int engineGetOutputSize(\n        int     inputLen) \n    {\n        try\n        {\n            return cipher.getOutputBlockSize();\n        }\n        catch (NullPointerException e)\n        {\n            throw new IllegalStateException(\"RSA Cipher not initialised\");\n        }\n    }\n\n    protected AlgorithmParameters engineGetParameters()\n    {\n        if (engineParams == null)\n        {\n            if (paramSpec != null)\n            {\n                try\n                {\n                    engineParams = helper.createAlgorithmParameters(\"OAEP\");\n                    engineParams.init(paramSpec);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e.toString());\n                }\n            }\n        }\n\n        return engineParams;\n    }\n\n    protected void engineSetMode(\n        String mode)\n        throws NoSuchAlgorithmException\n    {\n        String md = Strings.toUpperCase(mode);\n        \n        if (md.equals(\"NONE\") || md.equals(\"ECB\"))\n        {\n            return;\n        }\n        \n        if (md.equals(\"1\"))\n        {\n            privateKeyOnly = true;\n            publicKeyOnly = false;\n            return;\n        }\n        else if (md.equals(\"2\"))\n        {\n            privateKeyOnly = false;\n            publicKeyOnly = true;\n            return;\n        }\n        \n        throw new NoSuchAlgorithmException(\"can't support mode \" + mode);\n    }\n\n    protected void engineSetPadding(\n        String padding)\n        throws NoSuchPaddingException\n    {\n        String pad = Strings.toUpperCase(padding);\n\n        if (pad.equals(\"NOPADDING\"))\n        {\n            cipher = new RSABlindedEngine();\n        }\n        else if (pad.equals(\"PKCS1PADDING\"))\n        {\n            cipher = new PKCS1Encoding(new RSABlindedEngine());\n        }\n        else if (pad.equals(\"ISO9796-1PADDING\"))\n        {\n            cipher = new ISO9796d1Encoding(new RSABlindedEngine());\n        }\n        else if (pad.equals(\"OAEPWITHMD5ANDMGF1PADDING\"))\n        {\n            initFromSpec(new OAEPParameterSpec(\"MD5\", \"MGF1\", new MGF1ParameterSpec(\"MD5\"), PSource.PSpecified.DEFAULT));\n        }\n        else if (pad.equals(\"OAEPPADDING\"))\n        {\n            initFromSpec(OAEPParameterSpec.DEFAULT);\n        }\n        else if (pad.equals(\"OAEPWITHSHA1ANDMGF1PADDING\") || pad.equals(\"OAEPWITHSHA-1ANDMGF1PADDING\"))\n        {\n            initFromSpec(OAEPParameterSpec.DEFAULT);\n        }\n        else if (pad.equals(\"OAEPWITHSHA224ANDMGF1PADDING\") || pad.equals(\"OAEPWITHSHA-224ANDMGF1PADDING\"))\n        {\n            initFromSpec(new OAEPParameterSpec(\"SHA-224\", \"MGF1\", new MGF1ParameterSpec(\"SHA-224\"), PSource.PSpecified.DEFAULT));\n        }\n        else if (pad.equals(\"OAEPWITHSHA256ANDMGF1PADDING\") || pad.equals(\"OAEPWITHSHA-256ANDMGF1PADDING\"))\n        {\n            initFromSpec(new OAEPParameterSpec(\"SHA-256\", \"MGF1\", MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT));\n        }\n        else if (pad.equals(\"OAEPWITHSHA384ANDMGF1PADDING\") || pad.equals(\"OAEPWITHSHA-384ANDMGF1PADDING\"))\n        {\n            initFromSpec(new OAEPParameterSpec(\"SHA-384\", \"MGF1\", MGF1ParameterSpec.SHA384, PSource.PSpecified.DEFAULT));\n        }\n        else if (pad.equals(\"OAEPWITHSHA512ANDMGF1PADDING\") || pad.equals(\"OAEPWITHSHA-512ANDMGF1PADDING\"))\n        {\n            initFromSpec(new OAEPParameterSpec(\"SHA-512\", \"MGF1\", MGF1ParameterSpec.SHA512, PSource.PSpecified.DEFAULT));\n        }\n        else if (pad.equals(\"OAEPWITHSHA3-224ANDMGF1PADDING\"))\n        {\n            initFromSpec(new OAEPParameterSpec(\"SHA3-224\", \"MGF1\", new MGF1ParameterSpec(\"SHA3-224\"), PSource.PSpecified.DEFAULT));\n        }\n        else if (pad.equals(\"OAEPWITHSHA3-256ANDMGF1PADDING\"))\n        {\n            initFromSpec(new OAEPParameterSpec(\"SHA3-256\", \"MGF1\", new MGF1ParameterSpec(\"SHA3-256\"), PSource.PSpecified.DEFAULT));\n        }\n        else if (pad.equals(\"OAEPWITHSHA3-384ANDMGF1PADDING\"))\n        {\n            initFromSpec(new OAEPParameterSpec(\"SHA3-384\", \"MGF1\", new MGF1ParameterSpec(\"SHA3-384\"), PSource.PSpecified.DEFAULT));\n        }\n        else if (pad.equals(\"OAEPWITHSHA3-512ANDMGF1PADDING\"))\n        {\n            initFromSpec(new OAEPParameterSpec(\"SHA3-512\", \"MGF1\", new MGF1ParameterSpec(\"SHA3-512\"), PSource.PSpecified.DEFAULT));\n        }\n        else\n        {\n            throw new NoSuchPaddingException(padding + \" unavailable with RSA.\");\n        }\n    }\n\n    protected void engineInit(\n        int                     opmode,\n        Key key,\n        AlgorithmParameterSpec params,\n        SecureRandom random)\n    throws InvalidKeyException, InvalidAlgorithmParameterException\n    {\n        CipherParameters param;\n\n        if (params == null || params instanceof OAEPParameterSpec)\n        {\n            if (key instanceof RSAPublicKey)\n            {\n                if (privateKeyOnly && opmode == Cipher.ENCRYPT_MODE)\n                {\n                    throw new InvalidKeyException(\n                                \"mode 1 requires RSAPrivateKey\");\n                }\n\n                param = RSAUtil.generatePublicKeyParameter((RSAPublicKey)key);\n            }\n            else if (key instanceof RSAPrivateKey)\n            {\n                if (publicKeyOnly && opmode == Cipher.ENCRYPT_MODE)\n                {\n                    throw new InvalidKeyException(\n                                \"mode 2 requires RSAPublicKey\");\n                }\n\n                param = RSAUtil.generatePrivateKeyParameter((RSAPrivateKey)key);\n            }\n            else\n            {\n                throw new InvalidKeyException(\"unknown key type passed to RSA\");\n            }\n            \n            if (params != null)\n            {\n                OAEPParameterSpec spec = (OAEPParameterSpec)params;\n                \n                paramSpec = params;\n                \n                if (!spec.getMGFAlgorithm().equalsIgnoreCase(\"MGF1\") && !spec.getMGFAlgorithm().equals(PKCSObjectIdentifiers.id_mgf1.getId()))\n                {\n                    throw new InvalidAlgorithmParameterException(\"unknown mask generation function specified\");\n                }\n                \n                if (!(spec.getMGFParameters() instanceof MGF1ParameterSpec))\n                {\n                    throw new InvalidAlgorithmParameterException(\"unkown MGF parameters\");\n                }\n    \n                Digest digest = DigestFactory.getDigest(spec.getDigestAlgorithm());\n\n                if (digest == null)\n                {\n                    throw new InvalidAlgorithmParameterException(\"no match on digest algorithm: \"+ spec.getDigestAlgorithm());\n                }\n\n                MGF1ParameterSpec mgfParams = (MGF1ParameterSpec)spec.getMGFParameters();\n                Digest mgfDigest = DigestFactory.getDigest(mgfParams.getDigestAlgorithm());\n                \n                if (mgfDigest == null)\n                {\n                    throw new InvalidAlgorithmParameterException(\"no match on MGF digest algorithm: \"+ mgfParams.getDigestAlgorithm());\n                }\n\n                cipher = new OAEPEncoding(new RSABlindedEngine(), digest, mgfDigest, ((PSource.PSpecified)spec.getPSource()).getValue());\n            }\n        }\n        else\n        {\n            throw new InvalidAlgorithmParameterException(\"unknown parameter type: \" + params.getClass().getName());\n        }\n\n        if (!(cipher instanceof RSABlindedEngine))\n        {\n            if (random != null)\n            {\n                param = new ParametersWithRandom(param, random);\n            }\n            else\n            {\n                param = new ParametersWithRandom(param, new SecureRandom());\n            }\n        }\n\n        bOut.reset();\n\n        switch (opmode)\n        {\n        case Cipher.ENCRYPT_MODE:\n        case Cipher.WRAP_MODE:\n            cipher.init(true, param);\n            break;\n        case Cipher.DECRYPT_MODE:\n        case Cipher.UNWRAP_MODE:\n            cipher.init(false, param);\n            break;\n        default:\n            throw new InvalidParameterException(\"unknown opmode \" + opmode + \" passed to RSA\");\n        }\n    }\n\n    protected void engineInit(\n        int                 opmode,\n        Key key,\n        AlgorithmParameters params,\n        SecureRandom random)\n    throws InvalidKeyException, InvalidAlgorithmParameterException\n    {\n        AlgorithmParameterSpec paramSpec = null;\n\n        if (params != null)\n        {\n            try\n            {\n                paramSpec = params.getParameterSpec(OAEPParameterSpec.class);\n            }\n            catch (InvalidParameterSpecException e)\n            {\n                throw new InvalidAlgorithmParameterException(\"cannot recognise parameters: \" + e.toString(), e);\n            }\n        }\n\n        engineParams = params;\n        engineInit(opmode, key, paramSpec, random);\n    }\n\n    protected void engineInit(\n        int                 opmode,\n        Key key,\n        SecureRandom random)\n    throws InvalidKeyException\n    {\n        try\n        {\n            engineInit(opmode, key, (AlgorithmParameterSpec)null, random);\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            // this shouldn't happen\n            throw new InvalidKeyException(\"Eeeek! \" + e.toString(), e);\n        }\n    }\n\n    protected byte[] engineUpdate(\n        byte[]  input,\n        int     inputOffset,\n        int     inputLen) \n    {\n        bOut.write(input, inputOffset, inputLen);\n\n        if (cipher instanceof RSABlindedEngine)\n        {\n            if (bOut.size() > cipher.getInputBlockSize() + 1)\n            {\n                throw new ArrayIndexOutOfBoundsException(\"too much data for RSA block\");\n            }\n        }\n        else\n        {\n            if (bOut.size() > cipher.getInputBlockSize())\n            {\n                throw new ArrayIndexOutOfBoundsException(\"too much data for RSA block\");\n            }\n        }\n\n        return null;\n    }\n\n    protected int engineUpdate(\n        byte[]  input,\n        int     inputOffset,\n        int     inputLen,\n        byte[]  output,\n        int     outputOffset) \n    {\n        bOut.write(input, inputOffset, inputLen);\n\n        if (cipher instanceof RSABlindedEngine)\n        {\n            if (bOut.size() > cipher.getInputBlockSize() + 1)\n            {\n                throw new ArrayIndexOutOfBoundsException(\"too much data for RSA block\");\n            }\n        }\n        else\n        {\n            if (bOut.size() > cipher.getInputBlockSize())\n            {\n                throw new ArrayIndexOutOfBoundsException(\"too much data for RSA block\");\n            }\n        }\n\n        return 0;\n    }\n\n    protected byte[] engineDoFinal(\n        byte[]  input,\n        int     inputOffset,\n        int     inputLen) \n        throws IllegalBlockSizeException, BadPaddingException\n    {\n        if (input != null)\n        {\n            bOut.write(input, inputOffset, inputLen);\n        }\n\n        if (cipher instanceof RSABlindedEngine)\n        {\n            if (bOut.size() > cipher.getInputBlockSize() + 1)\n            {\n                throw new ArrayIndexOutOfBoundsException(\"too much data for RSA block\");\n            }\n        }\n        else\n        {\n            if (bOut.size() > cipher.getInputBlockSize())\n            {\n                throw new ArrayIndexOutOfBoundsException(\"too much data for RSA block\");\n            }\n        }\n\n        return getOutput();\n    }\n\n    protected int engineDoFinal(\n        byte[]  input,\n        int     inputOffset,\n        int     inputLen,\n        byte[]  output,\n        int     outputOffset) \n        throws IllegalBlockSizeException, BadPaddingException\n    {\n        if (input != null)\n        {\n            bOut.write(input, inputOffset, inputLen);\n        }\n\n        if (cipher instanceof RSABlindedEngine)\n        {\n            if (bOut.size() > cipher.getInputBlockSize() + 1)\n            {\n                throw new ArrayIndexOutOfBoundsException(\"too much data for RSA block\");\n            }\n        }\n        else\n        {\n            if (bOut.size() > cipher.getInputBlockSize())\n            {\n                throw new ArrayIndexOutOfBoundsException(\"too much data for RSA block\");\n            }\n        }\n\n        byte[]  out = getOutput();\n\n        for (int i = 0; i != out.length; i++)\n        {\n            output[outputOffset + i] = out[i];\n        }\n\n        return out.length;\n    }\n\n    private byte[] getOutput()\n        throws BadPaddingException\n    {\n        try\n        {\n            byte[]  bytes = bOut.toByteArray();\n\n            return cipher.processBlock(bytes, 0, bytes.length);\n        }\n        catch (InvalidCipherTextException e)\n        {\n            throw new BadBlockException(\"unable to decrypt block\", e);\n        }\n        finally\n        {\n            bOut.reset();\n        }\n    }\n\n    /**\n     * classes that inherit from us.\n     */\n\n    static public class NoPadding\n        extends CipherSpi\n    {\n        public NoPadding()\n        {\n            super(new RSABlindedEngine());\n        }\n    }\n\n    static public class PKCS1v1_5Padding\n        extends CipherSpi\n    {\n        public PKCS1v1_5Padding()\n        {\n            super(new PKCS1Encoding(new RSABlindedEngine()));\n        }\n    }\n\n    static public class PKCS1v1_5Padding_PrivateOnly\n        extends CipherSpi\n    {\n        public PKCS1v1_5Padding_PrivateOnly()\n        {\n            super(false, true, new PKCS1Encoding(new RSABlindedEngine()));\n        }\n    }\n\n    static public class PKCS1v1_5Padding_PublicOnly\n        extends CipherSpi\n    {\n        public PKCS1v1_5Padding_PublicOnly()\n        {\n            super(true, false, new PKCS1Encoding(new RSABlindedEngine()));\n        }\n    }\n\n    static public class OAEPPadding\n        extends CipherSpi\n    {\n        public OAEPPadding()\n        {\n            super(OAEPParameterSpec.DEFAULT);\n        }\n    }\n    \n    static public class ISO9796d1Padding\n        extends CipherSpi\n    {\n        public ISO9796d1Padding()\n        {\n            super(new ISO9796d1Encoding(new RSABlindedEngine()));\n        }\n    }\n}\n", "target": 0}
{"idx": 925, "func": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage io.milton.http.webdav;\n\nimport io.milton.common.ReadingException;\nimport io.milton.common.StreamUtils;\nimport io.milton.common.WritingException;\nimport java.io.ByteArrayInputStream;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport javax.xml.namespace.QName;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n *\n * @author brad\n */\npublic class DefaultPropPatchParser implements PropPatchRequestParser {\n\n    private final static Logger log = LoggerFactory.getLogger( DefaultPropPatchParser.class );\n\n\t@Override\n    public PropPatchParseResult getRequestedFields( InputStream in ) {\n        log.debug( \"getRequestedFields\" );\n        try {\n            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n            StreamUtils.readTo( in, bout, false, true );\n            byte[] arr = bout.toByteArray();\n            return parseContent( arr );\n        } catch( SAXException ex ) {\n            throw new RuntimeException( ex );\n        } catch( ReadingException ex ) {\n            throw new RuntimeException( ex );\n        } catch( WritingException ex ) {\n            throw new RuntimeException( ex );\n        } catch( IOException ex ) {\n            throw new RuntimeException( ex );\n        }\n    }\n\n    private PropPatchParseResult parseContent( byte[] arr ) throws IOException, SAXException {\n        if( arr.length > 0 ) {\n            log.debug( \"processing content\" );\n            ByteArrayInputStream bin = new ByteArrayInputStream( arr );\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\t// https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n            PropPatchSaxHandler handler = new PropPatchSaxHandler();\n            reader.setContentHandler( handler );\n            reader.parse( new InputSource( bin ) );\n            log.debug( \"toset: \" + handler.getAttributesToSet().size());\n            return new PropPatchParseResult( handler.getAttributesToSet(), handler.getAttributesToRemove().keySet() );\n        } else {\n            log.debug( \"empty content\" );\n            return new PropPatchParseResult( new HashMap<QName, String>(), new HashSet<QName>() );\n        }\n\n    }\n}\n", "target": 0}
{"idx": 926, "func": "/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.impl.protocol.jabber;\n\nimport java.util.*;\n\nimport net.java.sip.communicator.impl.protocol.jabber.extensions.carbon.*;\nimport net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.*;\nimport net.java.sip.communicator.impl.protocol.jabber.extensions.messagecorrection.*;\nimport net.java.sip.communicator.service.protocol.*;\nimport net.java.sip.communicator.service.protocol.Message;\nimport net.java.sip.communicator.service.protocol.event.*;\nimport net.java.sip.communicator.service.protocol.jabberconstants.*;\nimport net.java.sip.communicator.util.*;\n\nimport org.jivesoftware.smack.*;\nimport org.jivesoftware.smack.filter.*;\nimport org.jivesoftware.smack.packet.*;\nimport org.jivesoftware.smack.provider.*;\nimport org.jivesoftware.smack.util.*;\nimport org.jivesoftware.smackx.*;\nimport org.jivesoftware.smackx.packet.*;\n\n/**\n * A straightforward implementation of the basic instant messaging operation\n * set.\n *\n * @author Damian Minkov\n * @author Matthieu Helleringer\n * @author Alain Knaebel\n * @author Emil Ivov\n * @author Hristo Terezov\n */\npublic class OperationSetBasicInstantMessagingJabberImpl\n    extends AbstractOperationSetBasicInstantMessaging\n    implements OperationSetMessageCorrection\n{\n    /**\n     * Our class logger\n     */\n    private static final Logger logger =\n        Logger.getLogger(OperationSetBasicInstantMessagingJabberImpl.class);\n\n    /**\n     * The maximum number of unread threads that we'd be notifying the user of.\n     */\n    private static final String PNAME_MAX_GMAIL_THREADS_PER_NOTIFICATION\n        = \"net.java.sip.communicator.impl.protocol.jabber.\"\n            +\"MAX_GMAIL_THREADS_PER_NOTIFICATION\";\n\n    /**\n     * A table mapping contact addresses to full jids that can be used to\n     * target a specific resource (rather than sending a message to all logged\n     * instances of a user).\n     */\n    private Map<String, StoredThreadID> jids\n        = new Hashtable<String, StoredThreadID>();\n\n    /**\n     * The most recent full JID used for the contact address.\n     */\n    private Map<String, String> recentJIDForAddress\n        = new Hashtable<String, String>();\n    /**\n     * The smackMessageListener instance listens for incoming messages.\n     * Keep a reference of it so if anything goes wrong we don't add\n     * two different instances.\n     */\n    private SmackMessageListener smackMessageListener = null;\n\n    /**\n     * Contains the complete jid of a specific user and the time that it was\n     * last used so that we could remove it after a certain point.\n     */\n    public static class StoredThreadID\n    {\n        /** The time that we last sent or received a message from this jid */\n        long lastUpdatedTime;\n\n        /** The last chat used, this way we will reuse the thread-id */\n        String threadID;\n    }\n\n    /**\n     * A prefix helps to make sure that thread ID's are unique across mutliple\n     * instances.\n     */\n    private static String prefix = StringUtils.randomString(5);\n\n    /**\n     * Keeps track of the current increment, which is appended to the prefix to\n     * forum a unique thread ID.\n     */\n    private static long id = 0;\n\n    /**\n     * The number of milliseconds that we preserve threads with no traffic\n     * before considering them dead.\n     */\n    private static final long JID_INACTIVITY_TIMEOUT = 10*60*1000;//10 min.\n\n    /**\n     * Indicates the time of the last Mailbox report that we received from\n     * Google (if this is a Google server we are talking to). Should be included\n     * in all following mailbox queries\n     */\n    private long lastReceivedMailboxResultTime = -1;\n\n    /**\n     * The provider that created us.\n     */\n    private final ProtocolProviderServiceJabberImpl jabberProvider;\n\n    /**\n     * A reference to the persistent presence operation set that we use\n     * to match incoming messages to <tt>Contact</tt>s and vice versa.\n     */\n    private OperationSetPersistentPresenceJabberImpl opSetPersPresence = null;\n\n    /**\n     * The opening BODY HTML TAG: &ltbody&gt\n     */\n    private static final String OPEN_BODY_TAG = \"<body>\";\n\n    /**\n     * The closing BODY HTML TAG: &ltbody&gt\n     */\n    private static final String CLOSE_BODY_TAG = \"</body>\";\n\n    /**\n     * The html namespace used as feature\n     * XHTMLManager.namespace\n     */\n    private final static String HTML_NAMESPACE =\n        \"http://jabber.org/protocol/xhtml-im\";\n\n    /**\n     * List of filters to be used to filter which messages to handle\n     * current Operation Set.\n     */\n    private List<PacketFilter> packetFilters = new ArrayList<PacketFilter>();\n\n    /**\n     * Whether carbon is enabled or not.\n     */\n    private boolean isCarbonEnabled = false;\n\n    /**\n     * Creates an instance of this operation set.\n     * @param provider a reference to the <tt>ProtocolProviderServiceImpl</tt>\n     * that created us and that we'll use for retrieving the underlying aim\n     * connection.\n     */\n    OperationSetBasicInstantMessagingJabberImpl(\n        ProtocolProviderServiceJabberImpl provider)\n    {\n        this.jabberProvider = provider;\n\n        packetFilters.add(new GroupMessagePacketFilter());\n        packetFilters.add(\n            new PacketTypeFilter(org.jivesoftware.smack.packet.Message.class));\n\n        provider.addRegistrationStateChangeListener(\n                        new RegistrationStateListener());\n\n        ProviderManager man = ProviderManager.getInstance();\n        MessageCorrectionExtensionProvider extProvider =\n                new MessageCorrectionExtensionProvider();\n        man.addExtensionProvider(MessageCorrectionExtension.ELEMENT_NAME,\n                MessageCorrectionExtension.NAMESPACE,\n                extProvider);\n    }\n\n    /**\n     * Create a Message instance with the specified UID, content type\n     * and a default encoding.\n     * This method can be useful when message correction is required. One can\n     * construct the corrected message to have the same UID as the message\n     * before correction.\n     *\n     * @param messageText the string content of the message.\n     * @param contentType the MIME-type for <tt>content</tt>\n     * @param messageUID the unique identifier of this message.\n     * @return Message the newly created message\n     */\n    public Message createMessageWithUID(\n        String messageText, String contentType, String messageUID)\n    {\n        return new MessageJabberImpl(messageText, contentType,\n            DEFAULT_MIME_ENCODING, null, messageUID);\n    }\n\n    /**\n     * Create a Message instance for sending arbitrary MIME-encoding content.\n     *\n     * @param content content value\n     * @param contentType the MIME-type for <tt>content</tt>\n     * @return the newly created message.\n     */\n    public Message createMessage(String content, String contentType)\n    {\n        return createMessage(content, contentType, DEFAULT_MIME_ENCODING, null);\n    }\n\n    /**\n     * Create a Message instance for sending arbitrary MIME-encoding content.\n     *\n     * @param content content value\n     * @param contentType the MIME-type for <tt>content</tt>\n     * @param subject the Subject of the message that we'd like to create.\n     * @param encoding the enconding of the message that we will be sending.\n     *\n     * @return the newly created message.\n     */\n    @Override\n    public Message createMessage(String content, String contentType,\n        String encoding, String subject)\n    {\n        return new MessageJabberImpl(content, contentType, encoding, subject);\n    }\n\n    Message createMessage(String content, String contentType,\n            String messageUID)\n    {\n        return new MessageJabberImpl(content, contentType,\n                DEFAULT_MIME_ENCODING, null, messageUID);\n    }\n\n    /**\n     * Determines wheter the protocol provider (or the protocol itself) support\n     * sending and receiving offline messages. Most often this method would\n     * return true for protocols that support offline messages and false for\n     * those that don't. It is however possible for a protocol to support these\n     * messages and yet have a particular account that does not (i.e. feature\n     * not enabled on the protocol server). In cases like this it is possible\n     * for this method to return true even when offline messaging is not\n     * supported, and then have the sendMessage method throw an\n     * OperationFailedException with code - OFFLINE_MESSAGES_NOT_SUPPORTED.\n     *\n     * @return <tt>true</tt> if the protocol supports offline messages and\n     * <tt>false</tt> otherwise.\n     */\n    public boolean isOfflineMessagingSupported()\n    {\n        return true;\n    }\n\n    /**\n     * Determines wheter the protocol supports the supplied content type\n     *\n     * @param contentType the type we want to check\n     * @return <tt>true</tt> if the protocol supports it and\n     * <tt>false</tt> otherwise.\n     */\n    public boolean isContentTypeSupported(String contentType)\n    {\n        return\n            (contentType.equals(DEFAULT_MIME_TYPE)\n                || contentType.equals(HTML_MIME_TYPE));\n    }\n\n    /**\n     * Determines whether the protocol supports the supplied content type\n     * for the given contact.\n     *\n     * @param contentType the type we want to check\n     * @param contact contact which is checked for supported contentType\n     * @return <tt>true</tt> if the contact supports it and\n     * <tt>false</tt> otherwise.\n     */\n    @Override\n    public boolean isContentTypeSupported(String contentType, Contact contact)\n    {\n        // by default we support default mime type, for other mimetypes\n        // method must be overriden\n        if(contentType.equals(DEFAULT_MIME_TYPE))\n            return true;\n        else if(contentType.equals(HTML_MIME_TYPE))\n        {\n            String toJID = recentJIDForAddress.get(contact.getAddress());\n\n            if (toJID == null)\n                toJID = contact.getAddress();\n\n            return jabberProvider.isFeatureListSupported(\n                        toJID,\n                        HTML_NAMESPACE);\n        }\n\n        return false;\n    }\n\n    /**\n     * Remove from our <tt>jids</tt> map all entries that have not seen any\n     * activity (i.e. neither outgoing nor incoming messags) for more than\n     * JID_INACTIVITY_TIMEOUT. Note that this method is not synchronous and that\n     * it is only meant for use by the {@link #getThreadIDForAddress(String)} and\n     * {@link #putJidForAddress(String, String)}\n     */\n    private void purgeOldJids()\n    {\n        long currentTime = System.currentTimeMillis();\n\n        Iterator<Map.Entry<String, StoredThreadID>> entries\n            = jids.entrySet().iterator();\n\n\n        while( entries.hasNext() )\n        {\n            Map.Entry<String, StoredThreadID> entry = entries.next();\n            StoredThreadID target = entry.getValue();\n\n            if (currentTime - target.lastUpdatedTime\n                            > JID_INACTIVITY_TIMEOUT)\n                entries.remove();\n        }\n    }\n\n    /**\n     * Returns the last jid that the party with the specified <tt>address</tt>\n     * contacted us from or <tt>null</tt>(or bare jid) if we don't have a jid\n     * for the specified <tt>address</tt> yet. The method would also purge all\n     * entries that haven't seen any activity (i.e. no one has tried to get or\n     * remap it) for a delay longer than <tt>JID_INACTIVITY_TIMEOUT</tt>.\n     *\n     * @param jid the <tt>jid</tt> that we'd like to obtain a threadID for.\n     *\n     * @return the last jid that the party with the specified <tt>address</tt>\n     * contacted us from or <tt>null</tt> if we don't have a jid for the\n     * specified <tt>address</tt> yet.\n     */\n    String getThreadIDForAddress(String jid)\n    {\n        synchronized(jids)\n        {\n            purgeOldJids();\n            StoredThreadID ta = jids.get(jid);\n\n            if (ta == null)\n                return null;\n\n            ta.lastUpdatedTime = System.currentTimeMillis();\n\n            return ta.threadID;\n        }\n    }\n\n    /**\n     * Maps the specified <tt>address</tt> to <tt>jid</tt>. The point of this\n     * method is to allow us to send all messages destined to the contact with\n     * the specified <tt>address</tt> to the <tt>jid</tt> that they last\n     * contacted us from.\n     *\n     * @param threadID the threadID of conversation.\n     * @param jid the jid (i.e. address/resource) that the contact with the\n     * specified <tt>address</tt> last contacted us from.\n     */\n    private void putJidForAddress(String jid, String threadID)\n    {\n        synchronized(jids)\n        {\n            purgeOldJids();\n\n            StoredThreadID ta = jids.get(jid);\n\n            if (ta == null)\n            {\n                ta = new StoredThreadID();\n                jids.put(jid, ta);\n            }\n\n            recentJIDForAddress.put(StringUtils.parseBareAddress(jid), jid);\n\n            ta.lastUpdatedTime = System.currentTimeMillis();\n            ta.threadID = threadID;\n        }\n    }\n\n    /**\n     * Helper function used to send a message to a contact, with the given\n     * extensions attached.\n     *\n     * @param to The contact to send the message to.\n     * @param toResource The resource to send the message to or null if no\n     * resource has been specified\n     * @param message The message to send.\n     * @param extensions The XMPP extensions that should be attached to the\n     * message before sending.\n     * @return The MessageDeliveryEvent that resulted after attempting to\n     * send this message, so the calling function can modify it if needed.\n     */\n    private MessageDeliveredEvent sendMessage(  Contact to,\n                                                ContactResource toResource,\n                                                Message message,\n                                                PacketExtension[] extensions)\n    {\n        if( !(to instanceof ContactJabberImpl) )\n           throw new IllegalArgumentException(\n               \"The specified contact is not a Jabber contact.\"\n               + to);\n\n        assertConnected();\n\n        org.jivesoftware.smack.packet.Message msg =\n            new org.jivesoftware.smack.packet.Message();\n\n        String toJID = null;\n\n        if (toResource != null)\n        {\n            if(toResource.equals(ContactResource.BASE_RESOURCE))\n            {\n                toJID = to.getAddress();\n            }\n            else\n                toJID =\n                    ((ContactResourceJabberImpl) toResource).getFullJid();\n        }\n\n        if (toJID == null)\n        {\n            toJID = to.getAddress();\n        }\n\n        msg.setPacketID(message.getMessageUID());\n        msg.setTo(toJID);\n\n        for (PacketExtension ext : extensions)\n        {\n            msg.addExtension(ext);\n        }\n\n        if (logger.isTraceEnabled())\n            logger.trace(\"Will send a message to:\" + toJID\n                        + \" chat.jid=\" + toJID);\n\n        MessageDeliveredEvent msgDeliveryPendingEvt\n            = new MessageDeliveredEvent(message, to, toResource);\n\n        MessageDeliveredEvent[] transformedEvents = messageDeliveryPendingTransform(msgDeliveryPendingEvt);\n\n        if (transformedEvents == null || transformedEvents.length == 0)\n            return null;\n\n        for (MessageDeliveredEvent event : transformedEvents)\n        {\n            String content = event.getSourceMessage().getContent();\n\n            if (message.getContentType().equals(HTML_MIME_TYPE))\n            {\n                msg.setBody(Html2Text.extractText(content));\n\n                // Check if the other user supports XHTML messages\n                // make sure we use our discovery manager as it caches calls\n                if (jabberProvider\n                    .isFeatureListSupported(toJID, HTML_NAMESPACE))\n                {\n                    // Add the XHTML text to the message\n                    XHTMLManager.addBody(msg, OPEN_BODY_TAG + content\n                        + CLOSE_BODY_TAG);\n                }\n            }\n            else\n            {\n                // this is plain text so keep it as it is.\n                msg.setBody(content);\n            }\n\n            // msg.addExtension(new Version());\n\n            if (event.isMessageEncrypted() && isCarbonEnabled)\n            {\n                msg.addExtension(new CarbonPacketExtension.PrivateExtension());\n            }\n\n            MessageEventManager.addNotificationsRequests(msg, true, false,\n                false, true);\n\n            String threadID = getThreadIDForAddress(toJID);\n            if (threadID == null)\n                threadID = nextThreadID();\n\n            msg.setThread(threadID);\n            msg.setType(org.jivesoftware.smack.packet.Message.Type.chat);\n            msg.setFrom(jabberProvider.getConnection().getUser());\n\n            jabberProvider.getConnection().sendPacket(msg);\n\n            putJidForAddress(toJID, threadID);\n        }\n\n        return new MessageDeliveredEvent(message, to, toResource);\n    }\n\n    /**\n     * Sends the <tt>message</tt> to the destination indicated by the\n     * <tt>to</tt> contact.\n     *\n     * @param to the <tt>Contact</tt> to send <tt>message</tt> to\n     * @param message the <tt>Message</tt> to send.\n     * @throws java.lang.IllegalStateException if the underlying stack is\n     * not registered and initialized.\n     * @throws java.lang.IllegalArgumentException if <tt>to</tt> is not an\n     * instance of ContactImpl.\n     */\n    public void sendInstantMessage(Contact to, Message message)\n        throws IllegalStateException, IllegalArgumentException\n    {\n        sendInstantMessage(to, null, message);\n    }\n\n    /**\n     * Sends the <tt>message</tt> to the destination indicated by the\n     * <tt>to</tt>. Provides a default implementation of this method.\n     *\n     * @param to the <tt>Contact</tt> to send <tt>message</tt> to\n     * @param toResource the resource to which the message should be send\n     * @param message the <tt>Message</tt> to send.\n     * @throws java.lang.IllegalStateException if the underlying ICQ stack is\n     * not registered and initialized.\n     * @throws java.lang.IllegalArgumentException if <tt>to</tt> is not an\n     * instance belonging to the underlying implementation.\n     */\n    @Override\n    public void sendInstantMessage( Contact to,\n                                    ContactResource toResource,\n                                    Message message)\n        throws  IllegalStateException,\n                IllegalArgumentException\n    {\n        MessageDeliveredEvent msgDelivered =\n            sendMessage(to, toResource, message, new PacketExtension[0]);\n\n        fireMessageEvent(msgDelivered);\n    }\n\n    /**\n     * Replaces the message with ID <tt>correctedMessageUID</tt> sent to\n     * the contact <tt>to</tt> with the message <tt>message</tt>\n     *\n     * @param to The contact to send the message to.\n     * @param message The new message.\n     * @param correctedMessageUID The ID of the message being replaced.\n     */\n    public void correctMessage(\n        Contact to, ContactResource resource,\n        Message message, String correctedMessageUID)\n    {\n        PacketExtension[] exts = new PacketExtension[1];\n        exts[0] = new MessageCorrectionExtension(correctedMessageUID);\n        MessageDeliveredEvent msgDelivered\n            = sendMessage(to, resource, message, exts);\n        msgDelivered.setCorrectedMessageUID(correctedMessageUID);\n        fireMessageEvent(msgDelivered);\n    }\n\n    /**\n     * Utility method throwing an exception if the stack is not properly\n     * initialized.\n     *\n     * @throws java.lang.IllegalStateException if the underlying stack is\n     * not registered and initialized.\n     */\n    private void assertConnected()\n        throws IllegalStateException\n    {\n        if (opSetPersPresence == null)\n        {\n            throw\n                new IllegalStateException(\n                        \"The provider must be signed on the service before\"\n                            + \" being able to communicate.\");\n        }\n        else\n            opSetPersPresence.assertConnected();\n    }\n\n    /**\n     * Our listener that will tell us when we're registered to\n     */\n    private class RegistrationStateListener\n        implements RegistrationStateChangeListener\n    {\n        /**\n         * The method is called by a ProtocolProvider implementation whenever\n         * a change in the registration state of the corresponding provider had\n         * occurred.\n         * @param evt ProviderStatusChangeEvent the event describing the status\n         * change.\n         */\n        public void registrationStateChanged(RegistrationStateChangeEvent evt)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(\"The provider changed state from: \"\n                         + evt.getOldState()\n                         + \" to: \" + evt.getNewState());\n\n            if (evt.getNewState() == RegistrationState.REGISTERING)\n            {\n                opSetPersPresence\n                    = (OperationSetPersistentPresenceJabberImpl)\n                        jabberProvider.getOperationSet(\n                                OperationSetPersistentPresence.class);\n\n                if(smackMessageListener == null)\n                {\n                    smackMessageListener = new SmackMessageListener();\n                }\n                else\n                {\n                    // make sure this listener is not already installed in this\n                    // connection\n                    jabberProvider.getConnection()\n                        .removePacketListener(smackMessageListener);\n                }\n\n                jabberProvider.getConnection().addPacketListener(\n                        smackMessageListener,\n                        new AndFilter(\n                            packetFilters.toArray(\n                                new PacketFilter[packetFilters.size()])));\n            }\n            else if (evt.getNewState() == RegistrationState.REGISTERED)\n            {\n                new Thread(new Runnable()\n                {\n                    @Override\n                    public void run()\n                    {\n                        initAdditionalServices();\n                    }\n                }).start();\n            }\n            else if(evt.getNewState() == RegistrationState.UNREGISTERED\n                || evt.getNewState() == RegistrationState.CONNECTION_FAILED\n                || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED)\n            {\n                if(jabberProvider.getConnection() != null)\n                {\n                    if(smackMessageListener != null)\n                        jabberProvider.getConnection().removePacketListener(\n                            smackMessageListener);\n                }\n\n                smackMessageListener = null;\n            }\n        }\n    }\n\n    /**\n     * Initialize additional services, like gmail notifications and message\n     * carbons.\n     */\n    private void initAdditionalServices()\n    {\n        //subscribe for Google (Gmail or Google Apps) notifications\n        //for new mail messages.\n        boolean enableGmailNotifications\n            = jabberProvider\n            .getAccountID()\n            .getAccountPropertyBoolean(\n                \"GMAIL_NOTIFICATIONS_ENABLED\",\n                false);\n\n        if (enableGmailNotifications)\n            subscribeForGmailNotifications();\n\n        boolean enableCarbon\n            = isCarbonSupported() && !jabberProvider.getAccountID()\n            .getAccountPropertyBoolean(\n                ProtocolProviderFactory.IS_CARBON_DISABLED,\n                false);\n        if(enableCarbon)\n        {\n            enableDisableCarbon(true);\n        }\n        else\n        {\n            isCarbonEnabled = false;\n        }\n    }\n\n    /**\n     * Sends enable or disable carbon packet to the server.\n     * @param enable if <tt>true</tt> sends enable packet otherwise sends\n     * disable packet.\n     */\n    private void enableDisableCarbon(final boolean enable)\n    {\n        IQ iq = new IQ(){\n\n            @Override\n            public String getChildElementXML()\n            {\n                return \"<\" + (enable? \"enable\" : \"disable\") + \" xmlns='urn:xmpp:carbons:2' />\";\n            }\n\n        };\n\n        Packet response = null;\n        try\n        {\n            PacketCollector packetCollector\n                = jabberProvider.getConnection().createPacketCollector(\n                        new PacketIDFilter(iq.getPacketID()));\n            iq.setFrom(jabberProvider.getOurJID());\n            iq.setType(IQ.Type.SET);\n            jabberProvider.getConnection().sendPacket(iq);\n            response\n                = packetCollector.nextResult(\n                        SmackConfiguration.getPacketReplyTimeout());\n\n            packetCollector.cancel();\n        }\n        catch(Exception e)\n        {\n            logger.error(\"Failed to enable carbon.\", e);\n        }\n\n        isCarbonEnabled = false;\n\n        if (response == null)\n        {\n            logger.error(\n                    \"Failed to enable carbon. No response is received.\");\n        }\n        else if (response.getError() != null)\n        {\n            logger.error(\n                    \"Failed to enable carbon: \"\n                        + response.getError());\n        }\n        else if (!(response instanceof IQ)\n            || !((IQ) response).getType().equals(IQ.Type.RESULT))\n        {\n            logger.error(\n                    \"Failed to enable carbon. The response is not correct.\");\n        }\n        else\n        {\n            isCarbonEnabled = true;\n        }\n    }\n\n    /**\n     * Checks whether the carbon is supported by the server or not.\n     * @return <tt>true</tt> if carbon is supported by the server and\n     * <tt>false</tt> if not.\n     */\n    private boolean isCarbonSupported()\n    {\n        try\n        {\n            return jabberProvider.getDiscoveryManager().discoverInfo(\n                jabberProvider.getAccountID().getService())\n                .containsFeature(CarbonPacketExtension.NAMESPACE);\n        }\n        catch (XMPPException e)\n        {\n           logger.warn(\"Failed to retrieve carbon support.\" + e.getMessage());\n        }\n        return false;\n    }\n\n    /**\n     * The listener that we use in order to handle incoming messages.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private class SmackMessageListener\n        implements PacketListener\n    {\n        /**\n         * Handles incoming messages and dispatches whatever events are\n         * necessary.\n         * @param packet the packet that we need to handle (if it is a message).\n         */\n        public void processPacket(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return;\n\n            org.jivesoftware.smack.packet.Message msg =\n                (org.jivesoftware.smack.packet.Message)packet;\n\n            boolean isForwardedSentMessage = false;\n            if(msg.getBody() == null)\n            {\n\n                CarbonPacketExtension carbonExt\n                    = (CarbonPacketExtension) msg.getExtension(\n                        CarbonPacketExtension.NAMESPACE);\n                if(carbonExt == null)\n                    return;\n\n                isForwardedSentMessage\n                    = (carbonExt.getElementName()\n                        == CarbonPacketExtension.SENT_ELEMENT_NAME);\n                List<ForwardedPacketExtension> extensions\n                    = carbonExt.getChildExtensionsOfType(\n                        ForwardedPacketExtension.class);\n                if(extensions.isEmpty())\n                    return;\n\n                // according to xep-0280 all carbons should come from\n                // our bare jid\n                if (!msg.getFrom().equals(\n                        StringUtils.parseBareAddress(\n                            jabberProvider.getOurJID())))\n                {\n                    logger.info(\"Received a carbon copy with wrong from!\");\n                    return;\n                }\n\n                ForwardedPacketExtension forwardedExt = extensions.get(0);\n                msg = forwardedExt.getMessage();\n                if(msg == null || msg.getBody() == null)\n                    return;\n\n            }\n\n            Object multiChatExtension =\n                msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\n            // its not for us\n            if(multiChatExtension != null)\n                return;\n\n            String userFullId\n                = isForwardedSentMessage? msg.getTo() : msg.getFrom();\n\n            String userBareID = StringUtils.parseBareAddress(userFullId);\n\n            boolean isPrivateMessaging = false;\n            ChatRoom privateContactRoom = null;\n            OperationSetMultiUserChatJabberImpl mucOpSet =\n                (OperationSetMultiUserChatJabberImpl)jabberProvider\n                    .getOperationSet(OperationSetMultiUserChat.class);\n            if(mucOpSet != null)\n                privateContactRoom = mucOpSet.getChatRoom(userBareID);\n\n            if(privateContactRoom != null)\n            {\n                isPrivateMessaging = true;\n            }\n\n            if(logger.isDebugEnabled())\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Received from \"\n                             + userBareID\n                             + \" the message \"\n                             + msg.toXML());\n            }\n\n            Message newMessage = createMessage(msg.getBody(),\n                    DEFAULT_MIME_TYPE, msg.getPacketID());\n\n            //check if the message is available in xhtml\n            PacketExtension ext = msg.getExtension(\n                            \"http://jabber.org/protocol/xhtml-im\");\n\n            if(ext != null)\n            {\n                XHTMLExtension xhtmlExt\n                    = (XHTMLExtension)ext;\n\n                //parse all bodies\n                Iterator<String> bodies = xhtmlExt.getBodies();\n                StringBuffer messageBuff = new StringBuffer();\n                while (bodies.hasNext())\n                {\n                    String body = bodies.next();\n                    messageBuff.append(body);\n                }\n\n                if (messageBuff.length() > 0)\n                {\n                    // we remove body tags around message cause their\n                    // end body tag is breaking\n                    // the visualization as html in the UI\n                    String receivedMessage =\n                        messageBuff.toString()\n                        // removes body start tag\n                        .replaceAll(\"\\\\<[bB][oO][dD][yY].*?>\",\"\")\n                        // removes body end tag\n                        .replaceAll(\"\\\\</[bB][oO][dD][yY].*?>\",\"\");\n\n                    // for some reason &apos; is not rendered correctly\n                    // from our ui, lets use its equivalent. Other\n                    // similar chars(< > & \") seem ok.\n                    receivedMessage =\n                            receivedMessage.replaceAll(\"&apos;\", \"&#39;\");\n\n                    newMessage = createMessage(receivedMessage,\n                            HTML_MIME_TYPE, msg.getPacketID());\n                }\n            }\n\n            PacketExtension correctionExtension =\n                    msg.getExtension(MessageCorrectionExtension.NAMESPACE);\n            String correctedMessageUID = null;\n            if (correctionExtension != null)\n            {\n                correctedMessageUID = ((MessageCorrectionExtension)\n                        correctionExtension).getCorrectedMessageUID();\n            }\n\n            Contact sourceContact\n                = opSetPersPresence.findContactByID(\n                    (isPrivateMessaging? userFullId : userBareID));\n            if(msg.getType()\n                            == org.jivesoftware.smack.packet.Message.Type.error)\n            {\n                // error which is multichat and we don't know about the contact\n                // is a muc message error which is missing muc extension\n                // and is coming from the room, when we try to send message to\n                // room which was deleted or offline on the server\n                if(isPrivateMessaging && sourceContact == null)\n                {\n                    if(privateContactRoom != null)\n                    {\n                        XMPPError error = packet.getError();\n                        int errorResultCode\n                            = ChatRoomMessageDeliveryFailedEvent.UNKNOWN_ERROR;\n\n                        if(error != null && error.getCode() == 403)\n                        {\n                            errorResultCode\n                                = ChatRoomMessageDeliveryFailedEvent.FORBIDDEN;\n                        }\n\n                        String errorReason = error.getMessage();\n\n                        ChatRoomMessageDeliveryFailedEvent evt =\n                            new ChatRoomMessageDeliveryFailedEvent(\n                                privateContactRoom,\n                                null,\n                                errorResultCode,\n                                errorReason,\n                                new Date(),\n                                newMessage);\n                        ((ChatRoomJabberImpl)privateContactRoom)\n                            .fireMessageEvent(evt);\n                    }\n\n                    return;\n                }\n\n                if (logger.isInfoEnabled())\n                    logger.info(\"Message error received from \" + userBareID);\n\n                int errorResultCode = MessageDeliveryFailedEvent.UNKNOWN_ERROR;\n                if (packet.getError() != null)\n                {\n                    int errorCode = packet.getError().getCode();\n    \n                    if(errorCode == 503)\n                    {\n                        org.jivesoftware.smackx.packet.MessageEvent msgEvent =\n                            (org.jivesoftware.smackx.packet.MessageEvent)\n                                packet.getExtension(\"x\", \"jabber:x:event\");\n                        if(msgEvent != null && msgEvent.isOffline())\n                        {\n                            errorResultCode =\n                                MessageDeliveryFailedEvent\n                                    .OFFLINE_MESSAGES_NOT_SUPPORTED;\n                        }\n                    }\n                }\n\n                if (sourceContact == null)\n                {\n                    sourceContact = opSetPersPresence.createVolatileContact(\n                        userFullId, isPrivateMessaging);\n                }\n\n                MessageDeliveryFailedEvent ev\n                    = new MessageDeliveryFailedEvent(newMessage,\n                                                     sourceContact,\n                                                     correctedMessageUID,\n                                                     errorResultCode);\n\n                // ev = messageDeliveryFailedTransform(ev);\n\n                if (ev != null)\n                    fireMessageEvent(ev);\n                return;\n            }\n            putJidForAddress(userFullId, msg.getThread());\n\n            // In the second condition we filter all group chat messages,\n            // because they are managed by the multi user chat operation set.\n            if(sourceContact == null)\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"received a message from an unknown contact: \"\n                                   + userBareID);\n                //create the volatile contact\n                sourceContact = opSetPersPresence\n                    .createVolatileContact(\n                        userFullId,\n                        isPrivateMessaging);\n            }\n\n            Date timestamp = new Date();\n            //Check for XEP-0091 timestamp (deprecated)\n            PacketExtension delay = msg.getExtension(\"x\", \"jabber:x:delay\");\n            if(delay != null && delay instanceof DelayInformation)\n            {\n                timestamp = ((DelayInformation)delay).getStamp();\n            }\n            //check for XEP-0203 timestamp\n            delay = msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n            if(delay != null && delay instanceof DelayInfo)\n            {\n                timestamp = ((DelayInfo)delay).getStamp();\n            }\n\n            ContactResource resource = ((ContactJabberImpl) sourceContact)\n                    .getResourceFromJid(userFullId);\n\n            EventObject msgEvt = null;\n            if(!isForwardedSentMessage)\n                msgEvt\n                    = new MessageReceivedEvent( newMessage,\n                                                sourceContact,\n                                                resource,\n                                                timestamp,\n                                                correctedMessageUID,\n                                                isPrivateMessaging,\n                                                privateContactRoom);\n            else\n                msgEvt = new MessageDeliveredEvent(newMessage, sourceContact, timestamp);\n            // msgReceivedEvt = messageReceivedTransform(msgReceivedEvt);\n            if (msgEvt != null)\n                fireMessageEvent(msgEvt);\n        }\n    }\n\n\n    /**\n     * A filter that prevents this operation set from handling multi user chat\n     * messages.\n     */\n    private static class GroupMessagePacketFilter implements PacketFilter\n    {\n        /**\n         * Returns <tt>true</tt> if <tt>packet</tt> is a <tt>Message</tt> and\n         * false otherwise.\n         *\n         * @param packet the packet that we need to check.\n         *\n         * @return  <tt>true</tt> if <tt>packet</tt> is a <tt>Message</tt> and\n         * false otherwise.\n         */\n        public boolean accept(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return false;\n\n            org.jivesoftware.smack.packet.Message msg\n                = (org.jivesoftware.smack.packet.Message) packet;\n\n            return\n                !msg.getType().equals(\n                        org.jivesoftware.smack.packet.Message.Type.groupchat);\n        }\n    }\n\n    /**\n     * Subscribes this provider as interested in receiving notifications for\n     * new mail messages from Google mail services such as Gmail or Google Apps.\n     */\n    private void subscribeForGmailNotifications()\n    {\n        // first check support for the notification service\n        String accountIDService = jabberProvider.getAccountID().getService();\n        boolean notificationsAreSupported\n            = jabberProvider.isFeatureSupported(\n                    accountIDService,\n                    NewMailNotificationIQ.NAMESPACE);\n\n        if (!notificationsAreSupported)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(accountIDService\n                        +\" does not seem to provide a Gmail notification \"\n                        +\" service so we won't be trying to subscribe for it\");\n            return;\n        }\n\n        if (logger.isDebugEnabled())\n            logger.debug(accountIDService\n                        +\" seems to provide a Gmail notification \"\n                        +\" service so we will try to subscribe for it\");\n\n        ProviderManager providerManager = ProviderManager.getInstance();\n\n        providerManager.addIQProvider(\n                MailboxIQ.ELEMENT_NAME,\n                MailboxIQ.NAMESPACE,\n                new MailboxIQProvider());\n        providerManager.addIQProvider(\n                NewMailNotificationIQ.ELEMENT_NAME,\n                NewMailNotificationIQ.NAMESPACE,\n                new NewMailNotificationProvider());\n\n        Connection connection = jabberProvider.getConnection();\n\n        connection.addPacketListener(\n                new MailboxIQListener(), new PacketTypeFilter(MailboxIQ.class));\n        connection.addPacketListener(\n                new NewMailNotificationListener(),\n                new PacketTypeFilter(NewMailNotificationIQ.class));\n\n        if(opSetPersPresence.getCurrentStatusMessage().equals(\n                JabberStatusEnum.OFFLINE))\n           return;\n\n        //create a query with -1 values for newer-than-tid and\n        //newer-than-time attributes\n        MailboxQueryIQ mailboxQuery = new MailboxQueryIQ();\n\n        if (logger.isTraceEnabled())\n            logger.trace(\"sending mailNotification for acc: \"\n                    + jabberProvider.getAccountID().getAccountUniqueID());\n        jabberProvider.getConnection().sendPacket(mailboxQuery);\n    }\n\n    /**\n     * Creates an html description of the specified mailbox.\n     *\n     * @param mailboxIQ the mailboxIQ that we are to describe.\n     *\n     * @return an html description of <tt>mailboxIQ</tt>\n     */\n    private String createMailboxDescription(MailboxIQ mailboxIQ)\n    {\n        int threadCount = mailboxIQ.getThreadCount();\n\n        String resourceHeaderKey = threadCount > 1\n            ? \"service.gui.NEW_GMAIL_MANY_HEADER\"\n            : \"service.gui.NEW_GMAIL_HEADER\";\n\n        String resourceFooterKey = threadCount > 1\n            ? \"service.gui.NEW_GMAIL_MANY_FOOTER\"\n            : \"service.gui.NEW_GMAIL_FOOTER\";\n\n        // FIXME Escape HTML!\n        String newMailHeader = JabberActivator.getResources().getI18NString(\n            resourceHeaderKey,\n            new String[]\n                {\n                    jabberProvider.getAccountID()\n                                .getService(),     //{0} - service name\n                    mailboxIQ.getUrl(),            //{1} - inbox URI\n                    Integer.toString( threadCount )//{2} - thread count\n                });\n\n        StringBuilder message = new StringBuilder(newMailHeader);\n\n        //we now start an html table for the threads.\n        message.append(\"<table width=100% cellpadding=2 cellspacing=0 \");\n        message.append(\"border=0 bgcolor=#e8eef7>\");\n\n        Iterator<MailThreadInfo> threads = mailboxIQ.threads();\n\n        String maxThreadsStr = (String)JabberActivator.getConfigurationService()\n            .getProperty(PNAME_MAX_GMAIL_THREADS_PER_NOTIFICATION);\n\n        int maxThreads = 5;\n\n        try\n        {\n            if(maxThreadsStr != null)\n                maxThreads = Integer.parseInt(maxThreadsStr);\n        }\n        catch (NumberFormatException e)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(\"Failed to parse max threads count: \"+maxThreads\n                            +\". Going for default.\");\n        }\n\n        //print a maximum of MAX_THREADS\n        for (int i = 0; i < maxThreads && threads.hasNext(); i++)\n        {\n            message.append(threads.next().createHtmlDescription());\n        }\n        message.append(\"</table><br/>\");\n\n        if(threadCount > maxThreads)\n        {\n            String messageFooter = JabberActivator.getResources().getI18NString(\n                resourceFooterKey,\n                new String[]\n                {\n                    mailboxIQ.getUrl(),            //{0} - inbox URI\n                    Integer.toString(\n                        threadCount - maxThreads )//{1} - thread count\n                });\n            message.append(messageFooter);\n        }\n\n        return message.toString();\n    }\n\n    public String getRecentJIDForAddress(String address)\n    {\n        return recentJIDForAddress.get(address);\n    }\n\n    /**\n     * Receives incoming MailNotification Packets\n     */\n    private class MailboxIQListener\n        implements PacketListener\n    {\n        /**\n         * Handles incoming <tt>MailboxIQ</tt> packets.\n         *\n         * @param packet the IQ that we need to handle in case it is a\n         * <tt>MailboxIQ</tt>.\n         */\n        public void processPacket(Packet packet)\n        {\n            if(packet != null && !(packet instanceof MailboxIQ))\n                return;\n\n            MailboxIQ mailboxIQ = (MailboxIQ) packet;\n\n            if(mailboxIQ.getTotalMatched() < 1)\n                return;\n\n            //Get a reference to a dummy volatile contact\n            Contact sourceContact = opSetPersPresence\n                .findContactByID(jabberProvider.getAccountID().getService());\n\n            if(sourceContact == null)\n                sourceContact = opSetPersPresence.createVolatileContact(\n                                jabberProvider.getAccountID().getService());\n\n            lastReceivedMailboxResultTime = mailboxIQ.getResultTime();\n\n            String newMail = createMailboxDescription(mailboxIQ);\n\n            Message newMailMessage = new MessageJabberImpl(\n                newMail, HTML_MIME_TYPE, DEFAULT_MIME_ENCODING, null);\n\n            MessageReceivedEvent msgReceivedEvt = new MessageReceivedEvent(\n                newMailMessage, sourceContact, new Date(),\n                MessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);\n\n            fireMessageEvent(msgReceivedEvt);\n        }\n    }\n\n    /**\n     * Receives incoming NewMailNotification Packets.\n     */\n    private class NewMailNotificationListener\n        implements PacketListener\n    {\n        /**\n         * Handles incoming <tt>NewMailNotificationIQ</tt> packets.\n         *\n         * @param packet the IQ that we need to handle in case it is a\n         * <tt>NewMailNotificationIQ</tt>.\n         */\n        public void processPacket(Packet packet)\n        {\n            if(packet != null &&  !(packet instanceof NewMailNotificationIQ))\n                return;\n\n            //check whether we are still enabled.\n            boolean enableGmailNotifications\n                = jabberProvider\n                    .getAccountID()\n                        .getAccountPropertyBoolean(\n                            \"GMAIL_NOTIFICATIONS_ENABLED\",\n                            false);\n\n            if (!enableGmailNotifications)\n                return;\n\n            if(opSetPersPresence.getCurrentStatusMessage()\n                    .equals(JabberStatusEnum.OFFLINE))\n                return;\n\n            MailboxQueryIQ mailboxQueryIQ = new MailboxQueryIQ();\n\n            if(lastReceivedMailboxResultTime != -1)\n                mailboxQueryIQ.setNewerThanTime(\n                                lastReceivedMailboxResultTime);\n\n            if (logger.isTraceEnabled())\n                logger.trace(\n                \"send mailNotification for acc: \"\n                + jabberProvider.getAccountID().getAccountUniqueID());\n\n            jabberProvider.getConnection().sendPacket(mailboxQueryIQ);\n        }\n    }\n\n    /**\n     * Returns the inactivity timeout in milliseconds.\n     *\n     * @return The inactivity timeout in milliseconds. Or -1 if undefined\n     */\n    public long getInactivityTimeout()\n    {\n        return JID_INACTIVITY_TIMEOUT;\n    }\n\n    /**\n     * Adds additional filters for incoming messages. To be able to skip some\n     * messages.\n     * @param filter to add\n     */\n    public void addMessageFilters(PacketFilter filter)\n    {\n        this.packetFilters.add(filter);\n    }\n\n    /**\n     * Returns the next unique thread id. Each thread id made up of a short\n     * alphanumeric prefix along with a unique numeric value.\n     *\n     * @return the next thread id.\n     */\n    public static synchronized String nextThreadID() {\n        return prefix + Long.toString(id++);\n    }\n\n\n}\n", "target": 0}
{"idx": 927, "func": "package org.bouncycastle.jce.provider.test;\n\nimport java.math.BigInteger;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.SecureRandom;\nimport java.security.Security;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DHParameterSpec;\n\nimport org.bouncycastle.crypto.agreement.DHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.DESEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.jcajce.provider.asymmetric.dh.IESCipher;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.SimpleTest;\n\n/**\n * Test for DHIES - Diffie-Hellman Integrated Encryption Scheme\n */\npublic class DHIESTest\n    extends SimpleTest\n{\n    // Oakley group 2 - RFC 5996\n    BigInteger p1024 = new BigInteger(\n                    \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\" +\n                    \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\" +\n                    \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\" +\n                    \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\" +\n                    \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381\" +\n                    \"FFFFFFFFFFFFFFFF\",16);\n\n    BigInteger g1024 = new BigInteger(\"2\",16);\n\n    DHParameterSpec param = new DHParameterSpec(p1024, g1024);\n\n    DHIESTest()\n    {\n    }\n\n    public String getName()\n    {\n        return \"DHIES\";\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        byte[] derivation = Hex.decode(\"202122232425262728292a2b2c2d2e2f\");\n        byte[] encoding   = Hex.decode(\"303132333435363738393a3b3c3d3e3f\");\n\n        \n        IESCipher c1 = new org.bouncycastle.jcajce.provider.asymmetric.dh.IESCipher.IES();\n        IESCipher c2 = new org.bouncycastle.jcajce.provider.asymmetric.dh.IESCipher.IES();\n        IESParameterSpec params = new IESParameterSpec(derivation,encoding,128);\n\n        // Testing DHIES with default prime in streaming mode\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n        KeyPairGenerator    g512 = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n\n        g.initialize(param);\n\n        doTest(\"DHIES with default\", g, \"DHIES\", params);\n        \n        // Testing DHIES with 512-bit prime in streaming mode\n        g512.initialize(512, new SecureRandom());\n        doTest(\"DHIES with 512-bit\", g512, \"DHIES\", params);\n\n        // Testing ECIES with 1024-bit prime in streaming mode \n        g.initialize(param, new SecureRandom());\n        doTest(\"DHIES with 1024-bit\", g, \"DHIES\", params);\n\n        c1 = new IESCipher(new IESEngine(new DHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));\n        \n        c2 = new IESCipher(new IESEngine(new DHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));  \n    \n        params = new IESParameterSpec(derivation, encoding, 128, 192, Hex.decode(\"0001020304050607\"));\n      \n        // Testing DHIES with default prime using DESEDE\n        g = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n        doTest(\"DHIESwithDES default\", g, \"DHIESwithDESEDE-CBC\", params);\n        \n        // Testing DHIES with 512-bit prime using DESEDE\n        doTest(\"DHIESwithDES 512-bit\", g512, \"DHIESwithDESEDE-CBC\", params);\n        \n        // Testing DHIES with 1024-bit prime using DESEDE\n        g.initialize(param, new SecureRandom());\n        doTest(\"DHIESwithDES 1024-bit\", g, \"DHIESwithDESEDE-CBC\", params);\n\n        g = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n        g.initialize(param);\n\n        c1 = new IESCipher.IESwithAESCBC();\n        c2 = new IESCipher.IESwithAESCBC();\n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"00010203040506070001020304050607\"));\n        \n        // Testing DHIES with default prime using AES\n        doTest(\"DHIESwithAES default\", g, \"DHIESwithAES-CBC\", params);\n        \n        // Testing DHIES with 512-bit prime using AES\n        doTest(\"DHIESwithAES 512-bit\", g512, \"DHIESwithAES-CBC\", params);\n        \n        // Testing DHIES with 1024-bit prime using AES\n        g.initialize(param, new SecureRandom());\n        doTest(\"DHIESwithAES 1024-bit\", g, \"DHIESwithAES-CBC\", params);\n\n        KeyPair       keyPair = g.generateKeyPair();\n        DHPublicKey   pub = (DHPublicKey)keyPair.getPublic();\n        DHPrivateKey  priv = (DHPrivateKey)keyPair.getPrivate();\n\n        Cipher c = Cipher.getInstance(\"DHIESwithAES-CBC\", \"BC\");\n\n        try\n        {\n            c.init(Cipher.ENCRYPT_MODE, pub, new IESParameterSpec(derivation, encoding, 128, 128, null));\n\n            fail(\"no exception\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            isTrue(\"message \", \"NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n\n        try\n        {\n            c.init(Cipher.DECRYPT_MODE, priv);\n\n            fail(\"no exception\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            isTrue(\"message \", \"cannot handle supplied parameter spec: NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n\n        try\n        {\n            c.init(Cipher.DECRYPT_MODE, priv, new IESParameterSpec(derivation, encoding, 128, 128, null));\n\n            fail(\"no exception\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            isTrue(\"message \", \"NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n    }\n\n    public void doTest(\n        String              testname,\n        KeyPairGenerator    g,\n        String              cipher,\n        IESParameterSpec    p)\n        throws Exception\n    {\n        \n        byte[] message = Hex.decode(\"0102030405060708090a0b0c0d0e0f10111213141516\");\n        byte[] out1, out2;\n  \n        Cipher        c1 = Cipher.getInstance(cipher, \"BC\");\n        Cipher        c2 = Cipher.getInstance(cipher, \"BC\");\n        // Generate static key pair\n        KeyPair       keyPair = g.generateKeyPair();\n        DHPublicKey   pub = (DHPublicKey)keyPair.getPublic();\n        DHPrivateKey  priv = (DHPrivateKey)keyPair.getPrivate();\n\n        // Testing with default parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, pub, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, c1.getParameters());\n\n        isTrue(\"nonce mismatch\", Arrays.areEqual(c1.getIV(), c2.getIV()));\n\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n        {\n            fail(testname + \" test failed with default parameters, DHAES mode false.\");\n        }\n        \n        // Testing with given parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, pub, p, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, p);\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with non-null parameters, DHAES mode false.\");\n        \n        // Testing with null parameters and DHAES mode on\n        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n        c1.init(Cipher.ENCRYPT_MODE, pub, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, c1.getParameters(), new SecureRandom());\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with null parameters, DHAES mode true.\");\n     \n        \n        // Testing with given parameters and DHAES mode on\n        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n\n        c1.init(Cipher.ENCRYPT_MODE, pub, p, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, priv, p, new SecureRandom());\n\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with non-null parameters, DHAES mode true.\");\n\n        //\n        // corrupted data test\n        //\n        byte[] tmp = new byte[out1.length];\n        for (int i = 0; i != out1.length; i++)\n        {\n            System.arraycopy(out1, 0, tmp, 0, tmp.length);\n            tmp[i] = (byte)~tmp[i];\n\n            try\n            {\n                c2.doFinal(tmp, 0, tmp.length);\n\n                fail(\"decrypted corrupted data\");\n            }\n            catch (BadPaddingException e)\n            {\n                isTrue(\"wrong message: \" + e.getMessage(), \"unable to process block\".equals(e.getMessage()));\n            }\n        }\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new DHIESTest());\n    }\n}\n", "target": 0}
{"idx": 928, "func": "package io.onedev.server.web;\n\nimport org.apache.wicket.core.request.mapper.ResourceMapper;\nimport org.apache.wicket.markup.html.pages.BrowserInfoPage;\nimport org.apache.wicket.protocol.http.WebApplication;\nimport org.apache.wicket.request.IRequestMapper;\nimport org.apache.wicket.request.mapper.CompoundRequestMapper;\n\nimport io.onedev.server.GeneralException;\nimport io.onedev.server.web.asset.icon.IconScope;\nimport io.onedev.server.web.mapper.BaseResourceMapper;\nimport io.onedev.server.web.mapper.DynamicPathPageMapper;\nimport io.onedev.server.web.mapper.DynamicPathResourceMapper;\nimport io.onedev.server.web.page.admin.authenticator.AuthenticatorPage;\nimport io.onedev.server.web.page.admin.databasebackup.DatabaseBackupPage;\nimport io.onedev.server.web.page.admin.generalsecuritysetting.GeneralSecuritySettingPage;\nimport io.onedev.server.web.page.admin.groovyscript.GroovyScriptListPage;\nimport io.onedev.server.web.page.admin.group.GroupListPage;\nimport io.onedev.server.web.page.admin.group.authorization.GroupAuthorizationsPage;\nimport io.onedev.server.web.page.admin.group.create.NewGroupPage;\nimport io.onedev.server.web.page.admin.group.membership.GroupMembershipsPage;\nimport io.onedev.server.web.page.admin.group.profile.GroupProfilePage;\nimport io.onedev.server.web.page.admin.issuesetting.defaultboard.DefaultBoardListPage;\nimport io.onedev.server.web.page.admin.issuesetting.fieldspec.IssueFieldListPage;\nimport io.onedev.server.web.page.admin.issuesetting.issuetemplate.IssueTemplateListPage;\nimport io.onedev.server.web.page.admin.issuesetting.statespec.IssueStateListPage;\nimport io.onedev.server.web.page.admin.issuesetting.transitionspec.StateTransitionListPage;\nimport io.onedev.server.web.page.admin.jobexecutor.JobExecutorsPage;\nimport io.onedev.server.web.page.admin.mailsetting.MailSettingPage;\nimport io.onedev.server.web.page.admin.role.NewRolePage;\nimport io.onedev.server.web.page.admin.role.RoleDetailPage;\nimport io.onedev.server.web.page.admin.role.RoleListPage;\nimport io.onedev.server.web.page.admin.serverinformation.ServerInformationPage;\nimport io.onedev.server.web.page.admin.serverlog.ServerLogPage;\nimport io.onedev.server.web.page.admin.ssh.SshSettingPage;\nimport io.onedev.server.web.page.admin.sso.SsoConnectorListPage;\nimport io.onedev.server.web.page.admin.sso.SsoProcessPage;\nimport io.onedev.server.web.page.admin.systemsetting.SystemSettingPage;\nimport io.onedev.server.web.page.admin.user.UserListPage;\nimport io.onedev.server.web.page.admin.user.accesstoken.UserAccessTokenPage;\nimport io.onedev.server.web.page.admin.user.authorization.UserAuthorizationsPage;\nimport io.onedev.server.web.page.admin.user.avatar.UserAvatarPage;\nimport io.onedev.server.web.page.admin.user.create.NewUserPage;\nimport io.onedev.server.web.page.admin.user.membership.UserMembershipsPage;\nimport io.onedev.server.web.page.admin.user.password.UserPasswordPage;\nimport io.onedev.server.web.page.admin.user.profile.UserProfilePage;\nimport io.onedev.server.web.page.admin.user.ssh.UserSshKeysPage;\nimport io.onedev.server.web.page.builds.BuildListPage;\nimport io.onedev.server.web.page.issues.IssueListPage;\nimport io.onedev.server.web.page.my.accesstoken.MyAccessTokenPage;\nimport io.onedev.server.web.page.my.avatar.MyAvatarPage;\nimport io.onedev.server.web.page.my.password.MyPasswordPage;\nimport io.onedev.server.web.page.my.profile.MyProfilePage;\nimport io.onedev.server.web.page.my.sshkeys.MySshKeysPage;\nimport io.onedev.server.web.page.project.NewProjectPage;\nimport io.onedev.server.web.page.project.ProjectListPage;\nimport io.onedev.server.web.page.project.blob.ProjectBlobPage;\nimport io.onedev.server.web.page.project.branches.ProjectBranchesPage;\nimport io.onedev.server.web.page.project.builds.ProjectBuildsPage;\nimport io.onedev.server.web.page.project.builds.detail.InvalidBuildPage;\nimport io.onedev.server.web.page.project.builds.detail.artifacts.BuildArtifactsPage;\nimport io.onedev.server.web.page.project.builds.detail.changes.BuildChangesPage;\nimport io.onedev.server.web.page.project.builds.detail.dashboard.BuildDashboardPage;\nimport io.onedev.server.web.page.project.builds.detail.issues.FixedIssuesPage;\nimport io.onedev.server.web.page.project.builds.detail.log.BuildLogPage;\nimport io.onedev.server.web.page.project.codecomments.InvalidCodeCommentPage;\nimport io.onedev.server.web.page.project.codecomments.ProjectCodeCommentsPage;\nimport io.onedev.server.web.page.project.commits.CommitDetailPage;\nimport io.onedev.server.web.page.project.commits.ProjectCommitsPage;\nimport io.onedev.server.web.page.project.compare.RevisionComparePage;\nimport io.onedev.server.web.page.project.dashboard.ProjectDashboardPage;\nimport io.onedev.server.web.page.project.issues.boards.IssueBoardsPage;\nimport io.onedev.server.web.page.project.issues.create.NewIssuePage;\nimport io.onedev.server.web.page.project.issues.detail.IssueActivitiesPage;\nimport io.onedev.server.web.page.project.issues.detail.IssueBuildsPage;\nimport io.onedev.server.web.page.project.issues.detail.IssueCommitsPage;\nimport io.onedev.server.web.page.project.issues.detail.IssuePullRequestsPage;\nimport io.onedev.server.web.page.project.issues.list.ProjectIssueListPage;\nimport io.onedev.server.web.page.project.issues.milestones.MilestoneDetailPage;\nimport io.onedev.server.web.page.project.issues.milestones.MilestoneEditPage;\nimport io.onedev.server.web.page.project.issues.milestones.MilestoneListPage;\nimport io.onedev.server.web.page.project.issues.milestones.NewMilestonePage;\nimport io.onedev.server.web.page.project.pullrequests.InvalidPullRequestPage;\nimport io.onedev.server.web.page.project.pullrequests.ProjectPullRequestsPage;\nimport io.onedev.server.web.page.project.pullrequests.create.NewPullRequestPage;\nimport io.onedev.server.web.page.project.pullrequests.detail.activities.PullRequestActivitiesPage;\nimport io.onedev.server.web.page.project.pullrequests.detail.changes.PullRequestChangesPage;\nimport io.onedev.server.web.page.project.pullrequests.detail.codecomments.PullRequestCodeCommentsPage;\nimport io.onedev.server.web.page.project.pullrequests.detail.mergepreview.MergePreviewPage;\nimport io.onedev.server.web.page.project.setting.authorization.ProjectAuthorizationsPage;\nimport io.onedev.server.web.page.project.setting.avatar.AvatarEditPage;\nimport io.onedev.server.web.page.project.setting.branchprotection.BranchProtectionsPage;\nimport io.onedev.server.web.page.project.setting.build.ActionAuthorizationsPage;\nimport io.onedev.server.web.page.project.setting.build.BuildPreservationsPage;\nimport io.onedev.server.web.page.project.setting.build.JobSecretsPage;\nimport io.onedev.server.web.page.project.setting.general.GeneralProjectSettingPage;\nimport io.onedev.server.web.page.project.setting.tagprotection.TagProtectionsPage;\nimport io.onedev.server.web.page.project.setting.webhook.WebHooksPage;\nimport io.onedev.server.web.page.project.stats.ProjectContribsPage;\nimport io.onedev.server.web.page.project.stats.SourceLinesPage;\nimport io.onedev.server.web.page.project.tags.ProjectTagsPage;\nimport io.onedev.server.web.page.pullrequests.PullRequestListPage;\nimport io.onedev.server.web.page.simple.error.PageNotFoundErrorPage;\nimport io.onedev.server.web.page.simple.security.LoginPage;\nimport io.onedev.server.web.page.simple.security.LogoutPage;\nimport io.onedev.server.web.page.simple.security.PasswordResetPage;\nimport io.onedev.server.web.page.simple.security.SignUpPage;\nimport io.onedev.server.web.page.simple.serverinit.ServerInitPage;\nimport io.onedev.server.web.resource.ArchiveResourceReference;\nimport io.onedev.server.web.resource.ArtifactResourceReference;\nimport io.onedev.server.web.resource.AttachmentResourceReference;\nimport io.onedev.server.web.resource.BuildLogResourceReference;\nimport io.onedev.server.web.resource.RawBlobResourceReference;\nimport io.onedev.server.web.resource.ServerLogResourceReference;\nimport io.onedev.server.web.resource.SvgSpriteResourceReference;\n\npublic class BaseUrlMapper extends CompoundRequestMapper {\n\n\t@Override\n\tpublic CompoundRequestMapper add(IRequestMapper mapper) {\n\t\tif (mapper instanceof ResourceMapper && !(mapper instanceof BaseResourceMapper))\n\t\t\tthrow new GeneralException(\"Base resource mapper should be used\");\n\t\treturn super.add(mapper);\n\t}\n\n\tpublic BaseUrlMapper(WebApplication app) {\n\t\tadd(new DynamicPathPageMapper(\"init\", ServerInitPage.class));\n\t\tadd(new DynamicPathPageMapper(\"loading\", BrowserInfoPage.class));\n\t\tadd(new DynamicPathPageMapper(\"issues\", IssueListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"pull-requests\", PullRequestListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"builds\", BuildListPage.class));\n\t\taddProjectPages();\n\t\taddMyPages();\n\t\taddAdministrationPages();\n\t\taddSecurityPages();\n\t\t\t\t\n\t\taddResources();\n\t\t\n\t\taddErrorPages();\n\t}\n\n\tprivate void addMyPages() {\n\t\tadd(new DynamicPathPageMapper(\"my/profile\", MyProfilePage.class));\n\t\tadd(new DynamicPathPageMapper(\"my/avatar\", MyAvatarPage.class));\n\t\tadd(new DynamicPathPageMapper(\"my/password\", MyPasswordPage.class));\n\t\tadd(new DynamicPathPageMapper(\"my/ssh-keys\", MySshKeysPage.class));\n\t\tadd(new DynamicPathPageMapper(\"my/access-token\", MyAccessTokenPage.class));\n\t}\n\n\tprivate void addResources() {\n\t\tadd(new BaseResourceMapper(\"downloads/server-log\", new ServerLogResourceReference()));\n\t\tadd(new BaseResourceMapper(\"downloads/projects/${project}/builds/${build}/log\", new BuildLogResourceReference()));\n\t\tadd(new BaseResourceMapper(\"projects/${project}/archive/${revision}\", new ArchiveResourceReference()));\n\t\tadd(new DynamicPathResourceMapper(\"projects/${project}/raw/${revision}/${path}\", new RawBlobResourceReference()));\n\t\tadd(new BaseResourceMapper(\"projects/${project}/attachment/${uuid}/${attachment}\", new AttachmentResourceReference()));\n\t\tadd(new DynamicPathResourceMapper(\"downloads/projects/${project}/builds/${build}/artifacts/${path}\", \n\t\t\t\tnew ArtifactResourceReference()));\n\t\tadd(new BaseResourceMapper(SvgSpriteResourceReference.DEFAULT_MOUNT_PATH, new SvgSpriteResourceReference(IconScope.class)));\n\t}\n\t\n\tprivate void addErrorPages() {\n\t\tadd(new DynamicPathPageMapper(\"/errors/404\", PageNotFoundErrorPage.class));\n\t}\n\t\n\tprivate void addSecurityPages() {\n\t\tadd(new DynamicPathPageMapper(\"login\", LoginPage.class));\n\t\tadd(new DynamicPathPageMapper(\"logout\", LogoutPage.class));\n\t\tadd(new DynamicPathPageMapper(\"signup\", SignUpPage.class));\n\t\tadd(new DynamicPathPageMapper(\"reset-password\", PasswordResetPage.class));\n\t\tadd(new DynamicPathPageMapper(SsoProcessPage.MOUNT_PATH + \"/${stage}/${connector}\", SsoProcessPage.class));\n\t}\n \t\n\tprivate void addAdministrationPages() {\n\t\tadd(new DynamicPathPageMapper(\"administration\", UserListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/users\", UserListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/users/new\", NewUserPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/users/${user}/profile\", UserProfilePage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/users/${user}/groups\", UserMembershipsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/users/${user}/authorizations\", UserAuthorizationsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/users/${user}/avatar\", UserAvatarPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/users/${user}/password\", UserPasswordPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/users/${user}/ssh-keys\", UserSshKeysPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/users/${user}/access-token\", UserAccessTokenPage.class));\n\t\t\n\t\tadd(new DynamicPathPageMapper(\"administration/roles\", RoleListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/roles/new\", NewRolePage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/roles/${role}\", RoleDetailPage.class));\n\t\t\n\t\tadd(new DynamicPathPageMapper(\"administration/groups\", GroupListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/groups/new\", NewGroupPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/groups/${group}/profile\", GroupProfilePage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/groups/${group}/members\", GroupMembershipsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/groups/${group}/authorizations\", GroupAuthorizationsPage.class));\n\t\t\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/system\", SystemSettingPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/mail\", MailSettingPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/backup\", DatabaseBackupPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/security\", GeneralSecuritySettingPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/authenticator\", AuthenticatorPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/sso-connectors\", SsoConnectorListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/ssh\", SshSettingPage.class));\n\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/job-executors\", JobExecutorsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/groovy-scripts\", GroovyScriptListPage.class));\n\t\t\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/issue-fields\", IssueFieldListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/issue-states\", IssueStateListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/state-transitions\", StateTransitionListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/issue-boards\", DefaultBoardListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/settings/issue-templates\", IssueTemplateListPage.class));\n\t\t\n\t\tadd(new DynamicPathPageMapper(\"administration/server-log\", ServerLogPage.class));\n\t\tadd(new DynamicPathPageMapper(\"administration/server-information\", ServerInformationPage.class));\n\t}\n\t\n\tprivate void addProjectPages() {\n\t\tadd(new DynamicPathPageMapper(\"projects\", ProjectListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/new\", NewProjectPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}\", ProjectDashboardPage.class));\n\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/blob/#{revision}/#{path}\", ProjectBlobPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/commits\", ProjectCommitsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/commits/${revision}\", CommitDetailPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/compare\", RevisionComparePage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/stats/contribs\", ProjectContribsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/stats/lines\", SourceLinesPage.class));\n\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/branches\", ProjectBranchesPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/tags\", ProjectTagsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/code-comments\", ProjectCodeCommentsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/code-comments/${code-comment}/invalid\", InvalidCodeCommentPage.class));\n\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/pulls\", ProjectPullRequestsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/pulls/new\", NewPullRequestPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}\", PullRequestActivitiesPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/activities\", PullRequestActivitiesPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/code-comments\", PullRequestCodeCommentsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/changes\", PullRequestChangesPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/merge-preview\", MergePreviewPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/invalid\", InvalidPullRequestPage.class));\n\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/issues/boards\", IssueBoardsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/issues/boards/${board}\", IssueBoardsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/issues/list\", ProjectIssueListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}\", IssueActivitiesPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/activities\", IssueActivitiesPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/commits\", IssueCommitsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/pull-requests\", IssuePullRequestsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/builds\", IssueBuildsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/issues/new\", NewIssuePage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/milestones\", MilestoneListPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/milestones/${milestone}\", MilestoneDetailPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/milestones/${milestone}/edit\", MilestoneEditPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/milestones/new\", NewMilestonePage.class));\n\t\t\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/builds\", ProjectBuildsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/builds/${build}\", BuildDashboardPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/log\", BuildLogPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/changes\", BuildChangesPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/fixed-issues\", FixedIssuesPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/artifacts\", BuildArtifactsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/invalid\", InvalidBuildPage.class));\n\t\t\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/settings/general\", GeneralProjectSettingPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/settings/authorizations\", ProjectAuthorizationsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/settings/avatar-edit\", AvatarEditPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/settings/branch-protection\", BranchProtectionsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/settings/tag-protection\", TagProtectionsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/settings/build/job-secrets\", JobSecretsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/settings/build/action-authorizations\", ActionAuthorizationsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/settings/build/build-preserve-rules\", BuildPreservationsPage.class));\n\t\tadd(new DynamicPathPageMapper(\"projects/${project}/settings/web-hooks\", WebHooksPage.class));\n\t}\n\n}\n", "target": 0}
{"idx": 929, "func": "package org.jbpm.designer.bpmn2.resource;\n\n\nimport bpsim.impl.BpsimPackageImpl;\nimport org.eclipse.bpmn2.*;\nimport org.eclipse.bpmn2.util.Bpmn2ResourceImpl;\nimport org.eclipse.emf.common.util.URI;\nimport org.eclipse.emf.common.util.WrappedException;\nimport org.eclipse.emf.ecore.EObject;\nimport org.eclipse.emf.ecore.EStructuralFeature;\nimport org.eclipse.emf.ecore.xmi.XMLLoad;\nimport org.eclipse.emf.ecore.xmi.XMLResource;\nimport org.eclipse.emf.ecore.xmi.XMLSave;\nimport org.eclipse.emf.ecore.xmi.impl.XMLLoadImpl;\nimport org.eclipse.emf.ecore.resource.Resource;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class JBPMBpmn2ResourceImpl extends Bpmn2ResourceImpl {\n\n    public HashMap xmlNameToFeatureMap = new HashMap();\n\n\tpublic JBPMBpmn2ResourceImpl(URI uri) {\n\t\tsuper(uri);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DEFER_IDREF_RESOLUTION, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DISABLE_NOTIFY, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_USE_XML_NAME_TO_FEATURE_MAP, xmlNameToFeatureMap);\n\n        // Switch off DTD external entity processing\n        Map parserFeatures = new HashMap();\n        parserFeatures.put(\"http://xml.org/sax/features/external-general-entities\", false);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_PARSER_FEATURES, parserFeatures);\n\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_ENCODING, \"UTF-8\");\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_PROCESS_DANGLING_HREF, XMLResource.OPTION_PROCESS_DANGLING_HREF_DISCARD);\n\t}\n\t\n\t@Override\n    protected XMLSave createXMLSave() {\n        prepareSave();\n        return new JBPMXMLSaveImpl(createXMLHelper()) {\n            @Override\n            protected boolean shouldSaveFeature(EObject o, EStructuralFeature f) {\n                if (Bpmn2Package.eINSTANCE.getDocumentation_Text().equals(f))\n                    return false;\n                if (Bpmn2Package.eINSTANCE.getFormalExpression_Body().equals(f))\n                    return false;\n                return super.shouldSaveFeature(o, f);\n            }\n        };\n    }\n\n    @Override\n    protected XMLLoad createXMLLoad() {\n//        DroolsPackageImpl.init();\n//        BpsimPackageImpl.init();\n        return new XMLLoadImpl(createXMLHelper()) {\n\n            @Override\n            public void load(XMLResource resource, InputStream inputStream, Map<?, ?> options) throws IOException {\n                try {\n                    super.load(resource, inputStream, options);\n                }\n                catch (Exception e) {\n                    DiagnosticWrappedException error = new DiagnosticWrappedException(e);\n                    resource.getErrors().add(error);\n                }\n            }\n        };\n    }\n\n    class DiagnosticWrappedException extends WrappedException implements Resource.Diagnostic {\n        private static final long serialVersionUID = 1L;\n        private String location;\n        private int column;\n        private int line;\n\n        public DiagnosticWrappedException(Exception exception) {\n            super(exception);\n        }\n\n        public void setLocation(String location) {\n            this.location = location;\n        }\n\n        public String getLocation() {\n            return location;\n        }\n\n        public void setColumn(int column) {\n            this.column = column;;\n        }\n\n        public int getColumn() {\n            return column;\n        }\n\n        public void setLine(int line) {\n            this.line = line;\n        }\n\n        public int getLine() {\n            return line;\n        }\n    }\n}", "target": 0}
{"idx": 930, "func": "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.util.internal;\n\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.net.URL;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Helper class to load JNI resources.\n *\n */\npublic final class NativeLibraryLoader {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(NativeLibraryLoader.class);\n\n    private static final String NATIVE_RESOURCE_HOME = \"META-INF/native/\";\n    private static final File WORKDIR;\n    private static final boolean DELETE_NATIVE_LIB_AFTER_LOADING;\n    private static final boolean TRY_TO_PATCH_SHADED_ID;\n\n    // Just use a-Z and numbers as valid ID bytes.\n    private static final byte[] UNIQUE_ID_BYTES =\n            \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".getBytes(CharsetUtil.US_ASCII);\n\n    static {\n        String workdir = SystemPropertyUtil.get(\"io.netty.native.workdir\");\n        if (workdir != null) {\n            File f = new File(workdir);\n            f.mkdirs();\n\n            try {\n                f = f.getAbsoluteFile();\n            } catch (Exception ignored) {\n                // Good to have an absolute path, but it's OK.\n            }\n\n            WORKDIR = f;\n            logger.debug(\"-Dio.netty.native.workdir: \" + WORKDIR);\n        } else {\n            WORKDIR = PlatformDependent.tmpdir();\n            logger.debug(\"-Dio.netty.native.workdir: \" + WORKDIR + \" (io.netty.tmpdir)\");\n        }\n\n        DELETE_NATIVE_LIB_AFTER_LOADING = SystemPropertyUtil.getBoolean(\n                \"io.netty.native.deleteLibAfterLoading\", true);\n        logger.debug(\"-Dio.netty.native.deleteLibAfterLoading: {}\", DELETE_NATIVE_LIB_AFTER_LOADING);\n\n        TRY_TO_PATCH_SHADED_ID = SystemPropertyUtil.getBoolean(\n                \"io.netty.native.tryPatchShadedId\", true);\n        logger.debug(\"-Dio.netty.native.tryPatchShadedId: {}\", TRY_TO_PATCH_SHADED_ID);\n    }\n\n    /**\n     * Loads the first available library in the collection with the specified\n     * {@link ClassLoader}.\n     *\n     * @throws IllegalArgumentException\n     *         if none of the given libraries load successfully.\n     */\n    public static void loadFirstAvailable(ClassLoader loader, String... names) {\n        List<Throwable> suppressed = new ArrayList<Throwable>();\n        for (String name : names) {\n            try {\n                load(name, loader);\n                return;\n            } catch (Throwable t) {\n                suppressed.add(t);\n            }\n        }\n\n        IllegalArgumentException iae =\n                new IllegalArgumentException(\"Failed to load any of the given libraries: \" + Arrays.toString(names));\n        ThrowableUtil.addSuppressedAndClear(iae, suppressed);\n        throw iae;\n    }\n\n    /**\n     * The shading prefix added to this class's full name.\n     *\n     * @throws UnsatisfiedLinkError if the shader used something other than a prefix\n     */\n    private static String calculatePackagePrefix() {\n        String maybeShaded = NativeLibraryLoader.class.getName();\n        // Use ! instead of . to avoid shading utilities from modifying the string\n        String expected = \"io!netty!util!internal!NativeLibraryLoader\".replace('!', '.');\n        if (!maybeShaded.endsWith(expected)) {\n            throw new UnsatisfiedLinkError(String.format(\n                    \"Could not find prefix added to %s to get %s. When shading, only adding a \"\n                    + \"package prefix is supported\", expected, maybeShaded));\n        }\n        return maybeShaded.substring(0, maybeShaded.length() - expected.length());\n    }\n\n    /**\n     * Load the given library with the specified {@link ClassLoader}\n     */\n    public static void load(String originalName, ClassLoader loader) {\n        // Adjust expected name to support shading of native libraries.\n        String packagePrefix = calculatePackagePrefix().replace('.', '_');\n        String name = packagePrefix + originalName;\n        List<Throwable> suppressed = new ArrayList<Throwable>();\n        try {\n            // first try to load from java.library.path\n            loadLibrary(loader, name, false);\n            return;\n        } catch (Throwable ex) {\n            suppressed.add(ex);\n        }\n\n        String libname = System.mapLibraryName(name);\n        String path = NATIVE_RESOURCE_HOME + libname;\n\n        InputStream in = null;\n        OutputStream out = null;\n        File tmpFile = null;\n        URL url;\n        if (loader == null) {\n            url = ClassLoader.getSystemResource(path);\n        } else {\n            url = loader.getResource(path);\n        }\n        try {\n            if (url == null) {\n                if (PlatformDependent.isOsx()) {\n                    String fileName = path.endsWith(\".jnilib\") ? NATIVE_RESOURCE_HOME + \"lib\" + name + \".dynlib\" :\n                            NATIVE_RESOURCE_HOME + \"lib\" + name + \".jnilib\";\n                    if (loader == null) {\n                        url = ClassLoader.getSystemResource(fileName);\n                    } else {\n                        url = loader.getResource(fileName);\n                    }\n                    if (url == null) {\n                        FileNotFoundException fnf = new FileNotFoundException(fileName);\n                        ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                        throw fnf;\n                    }\n                } else {\n                    FileNotFoundException fnf = new FileNotFoundException(path);\n                    ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                    throw fnf;\n                }\n            }\n\n            int index = libname.lastIndexOf('.');\n            String prefix = libname.substring(0, index);\n            String suffix = libname.substring(index);\n\n            tmpFile = PlatformDependent.createTempFile(prefix, suffix, WORKDIR);\n            in = url.openStream();\n            out = new FileOutputStream(tmpFile);\n\n            if (shouldShadedLibraryIdBePatched(packagePrefix)) {\n                patchShadedLibraryId(in, out, originalName, name);\n            } else {\n                byte[] buffer = new byte[8192];\n                int length;\n                while ((length = in.read(buffer)) > 0) {\n                    out.write(buffer, 0, length);\n                }\n            }\n\n            out.flush();\n\n            // Close the output stream before loading the unpacked library,\n            // because otherwise Windows will refuse to load it when it's in use by other process.\n            closeQuietly(out);\n            out = null;\n            loadLibrary(loader, tmpFile.getPath(), true);\n        } catch (UnsatisfiedLinkError e) {\n            try {\n                if (tmpFile != null && tmpFile.isFile() && tmpFile.canRead() &&\n                    !NoexecVolumeDetector.canExecuteExecutable(tmpFile)) {\n                    // Pass \"io.netty.native.workdir\" as an argument to allow shading tools to see\n                    // the string. Since this is printed out to users to tell them what to do next,\n                    // we want the value to be correct even when shading.\n                    logger.info(\"{} exists but cannot be executed even when execute permissions set; \" +\n                                \"check volume for \\\"noexec\\\" flag; use -D{}=[path] \" +\n                                \"to set native working directory separately.\",\n                                tmpFile.getPath(), \"io.netty.native.workdir\");\n                }\n            } catch (Throwable t) {\n                suppressed.add(t);\n                logger.debug(\"Error checking if {} is on a file store mounted with noexec\", tmpFile, t);\n            }\n            // Re-throw to fail the load\n            ThrowableUtil.addSuppressedAndClear(e, suppressed);\n            throw e;\n        } catch (Exception e) {\n            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(\"could not load a native library: \" + name);\n            ule.initCause(e);\n            ThrowableUtil.addSuppressedAndClear(ule, suppressed);\n            throw ule;\n        } finally {\n            closeQuietly(in);\n            closeQuietly(out);\n            // After we load the library it is safe to delete the file.\n            // We delete the file immediately to free up resources as soon as possible,\n            // and if this fails fallback to deleting on JVM exit.\n            if (tmpFile != null && (!DELETE_NATIVE_LIB_AFTER_LOADING || !tmpFile.delete())) {\n                tmpFile.deleteOnExit();\n            }\n        }\n    }\n\n    // Package-private for testing.\n    static boolean patchShadedLibraryId(InputStream in, OutputStream out, String originalName, String name)\n            throws IOException {\n        byte[] buffer = new byte[8192];\n        int length;\n        // We read the whole native lib into memory to make it easier to monkey-patch the id.\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(in.available());\n\n        while ((length = in.read(buffer)) > 0) {\n            byteArrayOutputStream.write(buffer, 0, length);\n        }\n        byteArrayOutputStream.flush();\n        byte[] bytes = byteArrayOutputStream.toByteArray();\n        byteArrayOutputStream.close();\n\n        final boolean patched;\n        // Try to patch the library id.\n        if (!patchShadedLibraryId(bytes, originalName, name)) {\n            // We did not find the Id, check if we used a originalName that has the os and arch as suffix.\n            // If this is the case we should also try to patch with the os and arch suffix removed.\n            String os = PlatformDependent.normalizedOs();\n            String arch = PlatformDependent.normalizedArch();\n            String osArch = \"_\" + os + \"_\" + arch;\n            if (originalName.endsWith(osArch)) {\n                patched = patchShadedLibraryId(bytes,\n                        originalName.substring(0, originalName.length() - osArch.length()), name);\n            } else {\n                patched = false;\n            }\n        } else {\n            patched = true;\n        }\n        out.write(bytes, 0, bytes.length);\n        return patched;\n    }\n\n    private static boolean shouldShadedLibraryIdBePatched(String packagePrefix) {\n        return TRY_TO_PATCH_SHADED_ID && PlatformDependent.isOsx() && !packagePrefix.isEmpty();\n    }\n\n    /**\n     * Try to patch shaded library to ensure it uses a unique ID.\n     */\n    private static boolean patchShadedLibraryId(byte[] bytes, String originalName, String name) {\n        // Our native libs always have the name as part of their id so we can search for it and replace it\n        // to make the ID unique if shading is used.\n        byte[] nameBytes = originalName.getBytes(CharsetUtil.UTF_8);\n        int idIdx = -1;\n\n        // Be aware this is a really raw way of patching a dylib but it does all we need without implementing\n        // a full mach-o parser and writer. Basically we just replace the the original bytes with some\n        // random bytes as part of the ID regeneration. The important thing here is that we need to use the same\n        // length to not corrupt the mach-o header.\n        outerLoop: for (int i = 0; i < bytes.length && bytes.length - i >= nameBytes.length; i++) {\n            int idx = i;\n            for (int j = 0; j < nameBytes.length;) {\n                if (bytes[idx++] != nameBytes[j++]) {\n                    // Did not match the name, increase the index and try again.\n                    break;\n                } else if (j == nameBytes.length) {\n                    // We found the index within the id.\n                    idIdx = i;\n                    break outerLoop;\n                }\n            }\n        }\n\n        if (idIdx == -1) {\n            logger.debug(\"Was not able to find the ID of the shaded native library {}, can't adjust it.\", name);\n            return false;\n        } else {\n            // We found our ID... now monkey-patch it!\n            for (int i = 0; i < nameBytes.length; i++) {\n                // We should only use bytes as replacement that are in our UNIQUE_ID_BYTES array.\n                bytes[idIdx + i] = UNIQUE_ID_BYTES[PlatformDependent.threadLocalRandom()\n                                                                    .nextInt(UNIQUE_ID_BYTES.length)];\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\n                        \"Found the ID of the shaded native library {}. Replacing ID part {} with {}\",\n                        name, originalName, new String(bytes, idIdx, nameBytes.length, CharsetUtil.UTF_8));\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Loading the native library into the specified {@link ClassLoader}.\n     * @param loader - The {@link ClassLoader} where the native library will be loaded into\n     * @param name - The native library path or name\n     * @param absolute - Whether the native library will be loaded by path or by name\n     */\n    private static void loadLibrary(final ClassLoader loader, final String name, final boolean absolute) {\n        Throwable suppressed = null;\n        try {\n            try {\n                // Make sure the helper is belong to the target ClassLoader.\n                final Class<?> newHelper = tryToLoadClass(loader, NativeLibraryUtil.class);\n                loadLibraryByHelper(newHelper, name, absolute);\n                logger.debug(\"Successfully loaded the library {}\", name);\n                return;\n            } catch (UnsatisfiedLinkError e) { // Should by pass the UnsatisfiedLinkError here!\n                suppressed = e;\n            } catch (Exception e) {\n                suppressed = e;\n            }\n            NativeLibraryUtil.loadLibrary(name, absolute);  // Fallback to local helper class.\n            logger.debug(\"Successfully loaded the library {}\", name);\n        } catch (NoSuchMethodError nsme) {\n            if (suppressed != null) {\n                ThrowableUtil.addSuppressed(nsme, suppressed);\n            }\n            rethrowWithMoreDetailsIfPossible(name, nsme);\n        } catch (UnsatisfiedLinkError ule) {\n            if (suppressed != null) {\n                ThrowableUtil.addSuppressed(ule, suppressed);\n            }\n            throw ule;\n        }\n    }\n\n    @SuppressJava6Requirement(reason = \"Guarded by version check\")\n    private static void rethrowWithMoreDetailsIfPossible(String name, NoSuchMethodError error) {\n        if (PlatformDependent.javaVersion() >= 7) {\n            throw new LinkageError(\n                    \"Possible multiple incompatible native libraries on the classpath for '\" + name + \"'?\", error);\n        }\n        throw error;\n    }\n\n    private static void loadLibraryByHelper(final Class<?> helper, final String name, final boolean absolute)\n            throws UnsatisfiedLinkError {\n        Object ret = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n                try {\n                    // Invoke the helper to load the native library, if succeed, then the native\n                    // library belong to the specified ClassLoader.\n                    Method method = helper.getMethod(\"loadLibrary\", String.class, boolean.class);\n                    method.setAccessible(true);\n                    return method.invoke(null, name, absolute);\n                } catch (Exception e) {\n                    return e;\n                }\n            }\n        });\n        if (ret instanceof Throwable) {\n            Throwable t = (Throwable) ret;\n            assert !(t instanceof UnsatisfiedLinkError) : t + \" should be a wrapper throwable\";\n            Throwable cause = t.getCause();\n            if (cause instanceof UnsatisfiedLinkError) {\n                throw (UnsatisfiedLinkError) cause;\n            }\n            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(t.getMessage());\n            ule.initCause(t);\n            throw ule;\n        }\n    }\n\n    /**\n     * Try to load the helper {@link Class} into specified {@link ClassLoader}.\n     * @param loader - The {@link ClassLoader} where to load the helper {@link Class}\n     * @param helper - The helper {@link Class}\n     * @return A new helper Class defined in the specified ClassLoader.\n     * @throws ClassNotFoundException Helper class not found or loading failed\n     */\n    private static Class<?> tryToLoadClass(final ClassLoader loader, final Class<?> helper)\n            throws ClassNotFoundException {\n        try {\n            return Class.forName(helper.getName(), false, loader);\n        } catch (ClassNotFoundException e1) {\n            if (loader == null) {\n                // cannot defineClass inside bootstrap class loader\n                throw e1;\n            }\n            try {\n                // The helper class is NOT found in target ClassLoader, we have to define the helper class.\n                final byte[] classBinary = classToByteArray(helper);\n                return AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {\n                    @Override\n                    public Class<?> run() {\n                        try {\n                            // Define the helper class in the target ClassLoader,\n                            //  then we can call the helper to load the native library.\n                            Method defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class,\n                                    byte[].class, int.class, int.class);\n                            defineClass.setAccessible(true);\n                            return (Class<?>) defineClass.invoke(loader, helper.getName(), classBinary, 0,\n                                    classBinary.length);\n                        } catch (Exception e) {\n                            throw new IllegalStateException(\"Define class failed!\", e);\n                        }\n                    }\n                });\n            } catch (ClassNotFoundException e2) {\n                ThrowableUtil.addSuppressed(e2, e1);\n                throw e2;\n            } catch (RuntimeException e2) {\n                ThrowableUtil.addSuppressed(e2, e1);\n                throw e2;\n            } catch (Error e2) {\n                ThrowableUtil.addSuppressed(e2, e1);\n                throw e2;\n            }\n        }\n    }\n\n    /**\n     * Load the helper {@link Class} as a byte array, to be redefined in specified {@link ClassLoader}.\n     * @param clazz - The helper {@link Class} provided by this bundle\n     * @return The binary content of helper {@link Class}.\n     * @throws ClassNotFoundException Helper class not found or loading failed\n     */\n    private static byte[] classToByteArray(Class<?> clazz) throws ClassNotFoundException {\n        String fileName = clazz.getName();\n        int lastDot = fileName.lastIndexOf('.');\n        if (lastDot > 0) {\n            fileName = fileName.substring(lastDot + 1);\n        }\n        URL classUrl = clazz.getResource(fileName + \".class\");\n        if (classUrl == null) {\n            throw new ClassNotFoundException(clazz.getName());\n        }\n        byte[] buf = new byte[1024];\n        ByteArrayOutputStream out = new ByteArrayOutputStream(4096);\n        InputStream in = null;\n        try {\n            in = classUrl.openStream();\n            for (int r; (r = in.read(buf)) != -1;) {\n                out.write(buf, 0, r);\n            }\n            return out.toByteArray();\n        } catch (IOException ex) {\n            throw new ClassNotFoundException(clazz.getName(), ex);\n        } finally {\n            closeQuietly(in);\n            closeQuietly(out);\n        }\n    }\n\n    private static void closeQuietly(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException ignore) {\n                // ignore\n            }\n        }\n    }\n\n    private NativeLibraryLoader() {\n        // Utility\n    }\n\n    private static final class NoexecVolumeDetector {\n\n        @SuppressJava6Requirement(reason = \"Usage guarded by java version check\")\n        private static boolean canExecuteExecutable(File file) throws IOException {\n            if (PlatformDependent.javaVersion() < 7) {\n                // Pre-JDK7, the Java API did not directly support POSIX permissions; instead of implementing a custom\n                // work-around, assume true, which disables the check.\n                return true;\n            }\n\n            // If we can already execute, there is nothing to do.\n            if (file.canExecute()) {\n                return true;\n            }\n\n            // On volumes, with noexec set, even files with the executable POSIX permissions will fail to execute.\n            // The File#canExecute() method honors this behavior, probaby via parsing the noexec flag when initializing\n            // the UnixFileStore, though the flag is not exposed via a public API.  To find out if library is being\n            // loaded off a volume with noexec, confirm or add executalbe permissions, then check File#canExecute().\n\n            // Note: We use FQCN to not break when netty is used in java6\n            Set<java.nio.file.attribute.PosixFilePermission> existingFilePermissions =\n                    java.nio.file.Files.getPosixFilePermissions(file.toPath());\n            Set<java.nio.file.attribute.PosixFilePermission> executePermissions =\n                    EnumSet.of(java.nio.file.attribute.PosixFilePermission.OWNER_EXECUTE,\n                            java.nio.file.attribute.PosixFilePermission.GROUP_EXECUTE,\n                            java.nio.file.attribute.PosixFilePermission.OTHERS_EXECUTE);\n            if (existingFilePermissions.containsAll(executePermissions)) {\n                return false;\n            }\n\n            Set<java.nio.file.attribute.PosixFilePermission> newPermissions = EnumSet.copyOf(existingFilePermissions);\n            newPermissions.addAll(executePermissions);\n            java.nio.file.Files.setPosixFilePermissions(file.toPath(), newPermissions);\n            return file.canExecute();\n        }\n\n        private NoexecVolumeDetector() {\n            // Utility\n        }\n    }\n}\n", "target": 0}
{"idx": 931, "func": "package org.jooby.handlers;\n\nimport static org.easymock.EasyMock.expect;\nimport static org.junit.Assert.assertNotNull;\n\nimport java.io.File;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport org.jooby.test.MockUnit;\nimport org.jooby.test.MockUnit.Block;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.powermock.core.classloader.annotations.PrepareForTest;\nimport org.powermock.modules.junit4.PowerMockRunner;\n\n@RunWith(PowerMockRunner.class)\n@PrepareForTest({AssetHandler.class, File.class, Paths.class, Files.class })\npublic class AssetHandlerTest {\n\n  @Test\n  public void customClassloader() throws Exception {\n    URI uri = Paths.get(\"src\", \"test\", \"resources\", \"org\", \"jooby\").toUri();\n    new MockUnit(ClassLoader.class)\n        .expect(publicDir(uri, \"JoobyTest.js\"))\n        .run(unit -> {\n          URL value = new AssetHandler(\"/\", unit.get(ClassLoader.class))\n              .resolve(\"JoobyTest.js\");\n          assertNotNull(value);\n        });\n  }\n\n  @Test\n  public void shouldCallParentOnMissing() throws Exception {\n    URI uri = Paths.get(\"src\", \"test\", \"resources\", \"org\", \"jooby\").toUri();\n    new MockUnit(ClassLoader.class)\n        .expect(publicDir(uri, \"index.js\", false))\n        .expect(unit -> {\n          ClassLoader loader = unit.get(ClassLoader.class);\n          expect(loader.getResource(\"index.js\")).andReturn(uri.toURL());\n        })\n        .run(unit -> {\n          URL value = new AssetHandler(\"/\", unit.get(ClassLoader.class))\n              .resolve(\"index.js\");\n          assertNotNull(value);\n        });\n  }\n\n  @Test\n  public void ignoreMalformedURL() throws Exception {\n    Path path = Paths.get(\"src\", \"test\", \"resources\", \"org\", \"jooby\");\n    new MockUnit(ClassLoader.class, URI.class)\n        .expect(publicDir(null, \"index.js\"))\n        .expect(unit -> {\n          URI uri = unit.get(URI.class);\n          expect(uri.toURL()).andThrow(new MalformedURLException());\n        })\n        .expect(unit -> {\n          ClassLoader loader = unit.get(ClassLoader.class);\n          expect(loader.getResource(\"index.js\")).andReturn(path.toUri().toURL());\n        })\n        .run(unit -> {\n          URL value = new AssetHandler(\"/\", unit.get(ClassLoader.class))\n              .resolve(\"index.js\");\n          assertNotNull(value);\n        });\n  }\n\n  private Block publicDir(final URI uri, final String name) {\n    return publicDir(uri, name, true);\n  }\n\n  private Block publicDir(final URI uri, final String name, final boolean exists) {\n    return unit -> {\n      unit.mockStatic(Paths.class);\n\n      Path basedir = unit.mock(Path.class);\n\n      expect(Paths.get(\"public\")).andReturn(basedir);\n\n      Path path = unit.mock(Path.class);\n      expect(basedir.resolve(name)).andReturn(path);\n      expect(path.normalize()).andReturn(path);\n\n      if (exists) {\n        expect(path.startsWith(basedir)).andReturn(true);\n      }\n\n      unit.mockStatic(Files.class);\n      expect(Files.exists(basedir)).andReturn(true);\n      expect(Files.exists(path)).andReturn(exists);\n\n      if (exists) {\n        if (uri != null) {\n          expect(path.toUri()).andReturn(uri);\n        } else {\n          expect(path.toUri()).andReturn(unit.get(URI.class));\n        }\n      }\n    };\n  }\n\n}\n", "target": 1}
{"idx": 932, "func": "package org.bouncycastle.asn1;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\n\nimport org.bouncycastle.util.Arrays;\n\n/**\n * Class representing the ASN.1 INTEGER type.\n */\npublic class ASN1Integer\n    extends ASN1Primitive\n{\n    private final byte[] bytes;\n\n    /**\n     * return an integer from the passed in object\n     *\n     * @param obj an ASN1Integer or an object that can be converted into one.\n     * @throws IllegalArgumentException if the object cannot be converted.\n     * @return an ASN1Integer instance.\n     */\n    public static ASN1Integer getInstance(\n        Object obj)\n    {\n        if (obj == null || obj instanceof ASN1Integer)\n        {\n            return (ASN1Integer)obj;\n        }\n\n        if (obj instanceof byte[])\n        {\n            try\n            {\n                return (ASN1Integer)fromByteArray((byte[])obj);\n            }\n            catch (Exception e)\n            {\n                throw new IllegalArgumentException(\"encoding error in getInstance: \" + e.toString());\n            }\n        }\n\n        throw new IllegalArgumentException(\"illegal object in getInstance: \" + obj.getClass().getName());\n    }\n\n    /**\n     * return an Integer from a tagged object.\n     *\n     * @param obj      the tagged object holding the object we want\n     * @param explicit true if the object is meant to be explicitly\n     *                 tagged false otherwise.\n     * @throws IllegalArgumentException if the tagged object cannot\n     * be converted.\n     * @return an ASN1Integer instance.\n     */\n    public static ASN1Integer getInstance(\n        ASN1TaggedObject obj,\n        boolean explicit)\n    {\n        ASN1Primitive o = obj.getObject();\n\n        if (explicit || o instanceof ASN1Integer)\n        {\n            return getInstance(o);\n        }\n        else\n        {\n            return new ASN1Integer(ASN1OctetString.getInstance(obj.getObject()).getOctets());\n        }\n    }\n\n    public ASN1Integer(\n        long value)\n    {\n        bytes = BigInteger.valueOf(value).toByteArray();\n    }\n\n    public ASN1Integer(\n        BigInteger value)\n    {\n        bytes = value.toByteArray();\n    }\n\n    public ASN1Integer(\n        byte[] bytes)\n    {\n        this(bytes, true);\n    }\n\n    ASN1Integer(byte[] bytes, boolean clone)\n    {\n        if (bytes.length > 1)\n        {\n            if (bytes[0] == 0 && (bytes[1] & 0x80) == 0)\n            {\n                throw new IllegalArgumentException(\"malformed integer\");\n            }\n            if (bytes[0] == (byte)0xff && (bytes[1] & 0x80) != 0)\n            {\n                throw new IllegalArgumentException(\"malformed integer\");\n            }\n        }\n        this.bytes = (clone) ? Arrays.clone(bytes) : bytes;\n    }\n\n    public BigInteger getValue()\n    {\n        return new BigInteger(bytes);\n    }\n\n    /**\n     * in some cases positive values get crammed into a space,\n     * that's not quite big enough...\n     * @return the BigInteger that results from treating this ASN.1 INTEGER as unsigned.\n     */\n    public BigInteger getPositiveValue()\n    {\n        return new BigInteger(1, bytes);\n    }\n\n    boolean isConstructed()\n    {\n        return false;\n    }\n\n    int encodedLength()\n    {\n        return 1 + StreamUtil.calculateBodyLength(bytes.length) + bytes.length;\n    }\n\n    void encode(\n        ASN1OutputStream out)\n        throws IOException\n    {\n        out.writeEncoded(BERTags.INTEGER, bytes);\n    }\n\n    public int hashCode()\n    {\n        int value = 0;\n\n        for (int i = 0; i != bytes.length; i++)\n        {\n            value ^= (bytes[i] & 0xff) << (i % 4);\n        }\n\n        return value;\n    }\n\n    boolean asn1Equals(\n        ASN1Primitive o)\n    {\n        if (!(o instanceof ASN1Integer))\n        {\n            return false;\n        }\n\n        ASN1Integer other = (ASN1Integer)o;\n\n        return Arrays.areEqual(bytes, other.bytes);\n    }\n\n    public String toString()\n    {\n        return getValue().toString();\n    }\n\n}\n", "target": 0}
{"idx": 933, "func": "package io.dropwizard.validation.selfvalidating;\n\nimport com.fasterxml.classmate.AnnotationConfiguration;\nimport com.fasterxml.classmate.AnnotationInclusion;\nimport com.fasterxml.classmate.MemberResolver;\nimport com.fasterxml.classmate.ResolvedTypeWithMembers;\nimport com.fasterxml.classmate.TypeResolver;\nimport com.fasterxml.classmate.members.ResolvedMethod;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.stream.Collectors;\n\n/**\n * This class is the base validator for the <code>@SelfValidating</code> annotation. It\n * initiates the self validation process on an object, generating wrapping methods to call\n * the validation methods efficiently and then calls them.\n */\npublic class SelfValidatingValidator implements ConstraintValidator<SelfValidating, Object> {\n    private static final Logger log = LoggerFactory.getLogger(SelfValidatingValidator.class);\n\n    @SuppressWarnings(\"rawtypes\")\n    private final ConcurrentMap<Class<?>, List<ValidationCaller>> methodMap = new ConcurrentHashMap<>();\n    private final AnnotationConfiguration annotationConfiguration = new AnnotationConfiguration.StdConfiguration(AnnotationInclusion.INCLUDE_AND_INHERIT_IF_INHERITED);\n    private final TypeResolver typeResolver = new TypeResolver();\n    private final MemberResolver memberResolver = new MemberResolver(typeResolver);\n    private boolean escapeExpressions = true;\n\n    @Override\n    public void initialize(SelfValidating constraintAnnotation) {\n        escapeExpressions = constraintAnnotation.escapeExpressions();\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public boolean isValid(Object value, ConstraintValidatorContext context) {\n        final ViolationCollector collector = new ViolationCollector(context, escapeExpressions);\n        context.disableDefaultConstraintViolation();\n        for (ValidationCaller caller : methodMap.computeIfAbsent(value.getClass(), this::findMethods)) {\n            caller.setValidationObject(value);\n            caller.call(collector);\n        }\n        return !collector.hasViolationOccurred();\n    }\n\n    /**\n     * This method generates <code>ValidationCaller</code>s for each method annotated\n     * with <code>@SelfValidation</code> that adheres to required signature.\n     */\n    @SuppressWarnings({ \"rawtypes\" })\n    private <T> List<ValidationCaller> findMethods(Class<T> annotated) {\n        ResolvedTypeWithMembers annotatedType = memberResolver.resolve(typeResolver.resolve(annotated), annotationConfiguration, null);\n        final List<ValidationCaller> callers = Arrays.stream(annotatedType.getMemberMethods())\n            .filter(this::isValidationMethod)\n            .filter(this::isMethodCorrect)\n            .map(m -> new ProxyValidationCaller<>(annotated, m))\n            .collect(Collectors.toList());\n        if (callers.isEmpty()) {\n            log.warn(\"The class {} is annotated with @SelfValidating but contains no valid methods that are annotated \" +\n                \"with @SelfValidation\", annotated);\n        }\n        return callers;\n    }\n\n    private boolean isValidationMethod(ResolvedMethod m) {\n        return m.get(SelfValidation.class) != null;\n    }\n\n    boolean isMethodCorrect(ResolvedMethod m) {\n        if (m.getReturnType()!=null) {\n            log.error(\"The method {} is annotated with @SelfValidation but does not return void. It is ignored\", m.getRawMember());\n            return false;\n        } else if (m.getArgumentCount() != 1 || !m.getArgumentType(0).getErasedType().equals(ViolationCollector.class)) {\n            log.error(\"The method {} is annotated with @SelfValidation but does not have a single parameter of type {}\",\n                m.getRawMember(), ViolationCollector.class);\n            return false;\n        } else if (!m.isPublic()) {\n            log.error(\"The method {} is annotated with @SelfValidation but is not public\", m.getRawMember());\n            return false;\n        }\n        return true;\n    }\n\n    final static class ProxyValidationCaller<T> extends ValidationCaller<T> {\n        private final Class<T> cls;\n        private final ResolvedMethod resolvedMethod;\n\n        ProxyValidationCaller(Class<T> cls, ResolvedMethod resolvedMethod) {\n            this.cls = cls;\n            this.resolvedMethod = resolvedMethod;\n        }\n\n        @Override\n        public void call(ViolationCollector vc) {\n            final Method method = resolvedMethod.getRawMember();\n            final T obj = cls.cast(getValidationObject());\n            try {\n                method.invoke(obj, vc);\n            } catch (ReflectiveOperationException e) {\n                throw new IllegalStateException(\"Couldn't call \" + resolvedMethod + \" on \" + getValidationObject(), e);\n            }\n        }\n    }\n}\n", "target": 0}
{"idx": 934, "func": "package jenkins.security;\n\nimport hudson.Extension;\nimport hudson.console.AnnotatedLargeText;\nimport hudson.init.InitMilestone;\nimport hudson.init.Initializer;\nimport hudson.model.AdministrativeMonitor;\nimport hudson.util.HttpResponses;\nimport hudson.util.SecretRewriter;\nimport hudson.util.StreamTaskListener;\nimport hudson.util.VersionNumber;\nimport jenkins.model.Jenkins;\nimport jenkins.util.io.FileBoolean;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.StaplerProxy;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.nio.charset.Charset;\nimport java.security.GeneralSecurityException;\nimport java.util.Date;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Warns the administrator to run {@link SecretRewriter}\n *\n * @author Kohsuke Kawaguchi\n */\n@Extension\npublic class RekeySecretAdminMonitor extends AdministrativeMonitor implements StaplerProxy {\n\n    /**\n     * Whether we detected a need to run the rewrite program.\n     * Once we set it to true, we'll never turn it off.\n     *\n     * If the admin decides to dismiss this warning, we use {@link #isEnabled()} for that.\n     *\n     * In this way we can correctly differentiate all the different states.\n     */\n    private final FileBoolean needed = state(\"needed\");\n\n    /**\n     * If the scanning process has run to the completion, we set to this true.\n     */\n    private final FileBoolean done = state(\"done\");\n\n    /**\n     * If the rewrite process is scheduled upon the next boot.\n     */\n    private final FileBoolean scanOnBoot = state(\"scanOnBoot\");\n\n    /**\n     * Set to non-null once the rewriting activities starts running.\n     */\n    private volatile RekeyThread rekeyThread;\n\n\n    public RekeySecretAdminMonitor() throws IOException {\n        // if JENKINS_HOME existed <1.497, we need to offer rewrite\n        // this computation needs to be done and the value be captured,\n        // since $JENKINS_HOME/config.xml can be saved later before the user has\n        // actually rewritten XML files.\n        Jenkins j = Jenkins.getInstance();\n        if (j.isUpgradedFromBefore(new VersionNumber(\"1.496.*\"))\n        &&  new FileBoolean(new File(j.getRootDir(),\"secret.key.not-so-secret\")).isOff())\n            needed.on();\n    }\n\n    /**\n     * Requires ADMINISTER permission for any operation in here.\n     */\n    public Object getTarget() {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n        return this;\n    }\n\n    @Override\n    public boolean isActivated() {\n        return needed.isOn();\n    }\n\n    /**\n     * Indicates that the re-keying has run to the completion.\n     */\n    public boolean isDone() {\n        return done.isOn();\n    }\n\n    public void setNeeded() {\n        needed.on();\n    }\n\n    public boolean isScanOnBoot() {\n        return scanOnBoot.isOn();\n    }\n\n    @RequirePOST\n    public HttpResponse doScan(StaplerRequest req) throws IOException, GeneralSecurityException {\n        if(req.hasParameter(\"background\")) {\n            synchronized (this) {\n                if (!isRewriterActive()) {\n                    rekeyThread = new RekeyThread();\n                    rekeyThread.start();\n                }\n            }\n        } else\n        if(req.hasParameter(\"schedule\")) {\n            scanOnBoot.on();\n        } else\n        if(req.hasParameter(\"dismiss\")) {\n            disable(true);\n        } else\n            throw HttpResponses.error(400,\"Invalid request submission\");\n\n        return HttpResponses.redirectViaContextPath(\"/manage\");\n    }\n\n    /**\n     * Is there an active rewriting process going on?\n     */\n    public boolean isRewriterActive() {\n        return rekeyThread !=null && rekeyThread.isAlive();\n    }\n\n    /**\n     * Used to URL-bind {@link AnnotatedLargeText}.\n     */\n    public AnnotatedLargeText getLogText() {\n        return new AnnotatedLargeText<RekeySecretAdminMonitor>(getLogFile(), Charset.defaultCharset(),\n                !isRewriterActive(),this);\n    }\n\n    private static FileBoolean state(String name) {\n        return new FileBoolean(new File(getBaseDir(),name));\n    }\n\n    @Initializer(fatal=false,after=InitMilestone.PLUGINS_STARTED,before=InitMilestone.EXTENSIONS_AUGMENTED)\n    // as early as possible, but this needs to be late enough that the ConfidentialStore is available\n    public static void scanOnReboot() throws InterruptedException, IOException, GeneralSecurityException {\n        FileBoolean flag = new RekeySecretAdminMonitor().scanOnBoot;\n        if (flag.isOn()) {\n            flag.off();\n            RekeyThread t = new RekeyThread();\n            t.start();\n            t.join();\n            // block the boot until the rewrite process is complete\n            // don't let the failure in RekeyThread block Jenkins boot.\n        }\n    }\n\n    /**\n     * Rewrite log file.\n     */\n    public static File getLogFile() {\n        return new File(getBaseDir(),\"rekey.log\");\n    }\n\n    private static File getBaseDir() {\n        return new File(Jenkins.getInstance().getRootDir(),RekeySecretAdminMonitor.class.getName());\n    }\n\n    private static class RekeyThread extends Thread {\n        private final SecretRewriter rewriter;\n\n        RekeyThread() throws GeneralSecurityException {\n            super(\"Rekey secret thread\");\n            rewriter = new SecretRewriter(new File(getBaseDir(),\"backups\"));\n        }\n\n        @Override\n        public void run() {\n            try {\n                LOGGER.info(\"Initiating a re-keying of secrets. See \"+getLogFile());\n                StreamTaskListener listener = new StreamTaskListener(getLogFile());\n                try {\n                    PrintStream log = listener.getLogger();\n                    log.println(\"Started re-keying \" + new Date());\n                    int count = rewriter.rewriteRecursive(Jenkins.getInstance().getRootDir(), listener);\n                    log.printf(\"Completed re-keying %d files on %s\\n\",count,new Date());\n                    new RekeySecretAdminMonitor().done.on();\n                    LOGGER.info(\"Secret re-keying completed\");\n                } catch (Exception e) {\n                    LOGGER.log(Level.SEVERE, \"Fatal failure in re-keying secrets\",e);\n                    e.printStackTrace(listener.error(\"Fatal failure in rewriting secrets\"));\n                }\n            } catch (IOException e) {\n                LOGGER.log(Level.SEVERE, \"Catastrophic failure to rewrite secrets\",e);\n            }\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(RekeySecretAdminMonitor.class.getName());\n\n}\n", "target": 0}
{"idx": 935, "func": "package org.mapfish.print.map.style;\n\nimport org.geotools.factory.CommonFactoryFinder;\nimport org.geotools.styling.DefaultResourceLocator;\nimport org.geotools.styling.Style;\nimport org.geotools.xml.styling.SLDParser;\nimport org.locationtech.jts.util.Assert;\nimport org.mapfish.print.Constants;\nimport org.mapfish.print.config.Configuration;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.client.ClientHttpRequest;\nimport org.springframework.http.client.ClientHttpRequestFactory;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\n/**\n * Basic implementation for loading and parsing an SLD style.\n */\npublic class SLDParserPlugin implements StyleParserPlugin {\n    /**\n     * The separator between the path or url segment for loading the sld and an index of the style to obtain.\n     * <p>\n     * SLDs can contains multiple styles.  Because of this there needs to be a way to indicate which style is\n     * referred to.  That is the purpose of the style index.\n     */\n    public static final String STYLE_INDEX_REF_SEPARATOR = \"##\";\n\n\n    @Override\n    public final Optional<Style> parseStyle(\n            @Nullable final Configuration configuration,\n            @Nonnull final ClientHttpRequestFactory clientHttpRequestFactory,\n            @Nonnull final String styleString) {\n\n        // try to load xml\n        final Optional<Style> styleOptional = tryLoadSLD(\n                styleString.getBytes(Constants.DEFAULT_CHARSET), null, clientHttpRequestFactory);\n\n        if (styleOptional.isPresent()) {\n            return styleOptional;\n        }\n\n        final Integer styleIndex = lookupStyleIndex(styleString).orElse(null);\n        final String styleStringWithoutIndexReference = removeIndexReference(styleString);\n        Function<byte[], Optional<Style>> loadFunction =\n                input -> tryLoadSLD(input, styleIndex, clientHttpRequestFactory);\n\n        return ParserPluginUtils.loadStyleAsURI(clientHttpRequestFactory, styleStringWithoutIndexReference,\n                                                loadFunction);\n    }\n\n    private String removeIndexReference(final String styleString) {\n        int styleIdentifier = styleString.lastIndexOf(STYLE_INDEX_REF_SEPARATOR);\n        if (styleIdentifier > 0) {\n            return styleString.substring(0, styleIdentifier);\n        }\n        return styleString;\n    }\n\n    private Optional<Integer> lookupStyleIndex(final String ref) {\n        int styleIdentifier = ref.lastIndexOf(STYLE_INDEX_REF_SEPARATOR);\n        if (styleIdentifier > 0) {\n            return Optional.of(Integer.parseInt(ref.substring(styleIdentifier + 2)) - 1);\n        }\n        return Optional.empty();\n    }\n\n    private Optional<Style> tryLoadSLD(\n            final byte[] bytes, final Integer styleIndex,\n            final ClientHttpRequestFactory clientHttpRequestFactory) {\n        Assert.isTrue(styleIndex == null || styleIndex > -1,\n                      \"styleIndex must be > -1 but was: \" + styleIndex);\n\n        final Style[] styles;\n        try {\n\n            // check if the XML is valid\n            // this is only done in a separate step to avoid that fatal errors show up in the logs\n            // by setting a custom error handler.\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setNamespaceAware(true);\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            db.setErrorHandler(new ErrorHandler());\n            db.parse(new ByteArrayInputStream(bytes));\n\n            // then read the styles\n            final SLDParser sldParser = new SLDParser(CommonFactoryFinder.getStyleFactory());\n            sldParser.setOnLineResourceLocator(new DefaultResourceLocator() {\n                @Override\n                public URL locateResource(final String uri) {\n                    try {\n                        final URL theUrl = super.locateResource(uri);\n                        final URI theUri;\n                        if (theUrl != null) {\n                            theUri = theUrl.toURI();\n                        } else {\n                            theUri = URI.create(uri);\n                        }\n                        if (theUri.getScheme().startsWith(\"http\")) {\n                            final ClientHttpRequest request = clientHttpRequestFactory.createRequest(\n                                    theUri, HttpMethod.GET);\n                            return request.getURI().toURL();\n                        }\n                        return null;\n                    } catch (IOException | URISyntaxException e) {\n                        return null;\n                    }\n                }\n            });\n            sldParser.setInput(new ByteArrayInputStream(bytes));\n            styles = sldParser.readXML();\n\n        } catch (Throwable e) {\n            return Optional.empty();\n        }\n\n        if (styleIndex != null) {\n            Assert.isTrue(styleIndex < styles.length, String.format(\"There where %s styles in file but \" +\n                                                                            \"requested index was: %s\",\n                                                                    styles.length, styleIndex + 1));\n        } else {\n            Assert.isTrue(styles.length < 2, String.format(\"There are %s therefore the styleRef must \" +\n                                                                   \"contain an index identifying the style.\" +\n                                                                   \"  The index starts at 1 for the first \" +\n                                                                   \"style.\\n\" +\n                                                                   \"\\tExample: thinline.sld##1\",\n                                                           styles.length));\n        }\n\n        if (styleIndex == null) {\n            return Optional.of(styles[0]);\n        } else {\n            return Optional.of(styles[styleIndex]);\n        }\n    }\n\n    /**\n     * A default error handler to avoid that error messages like \"[Fatal Error] :1:1: Content is not allowed\n     * in prolog.\" are directly printed to STDERR.\n     */\n    public static class ErrorHandler extends DefaultHandler {\n\n        private static final Logger LOGGER = LoggerFactory.getLogger(ErrorHandler.class);\n\n        /**\n         * @param e Exception\n         */\n        public final void error(final SAXParseException e) throws SAXException {\n            LOGGER.debug(\"XML error: {}\", e.getLocalizedMessage());\n            super.error(e);\n        }\n\n        /**\n         * @param e Exception\n         */\n        public final void fatalError(final SAXParseException e) throws SAXException {\n            LOGGER.debug(\"XML fatal error: {}\", e.getLocalizedMessage());\n            super.fatalError(e);\n        }\n\n        /**\n         * @param e Exception\n         */\n        public final void warning(final SAXParseException e) {\n            //ignore\n        }\n    }\n}\n", "target": 0}
{"idx": 936, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.services.common.ExampleServiceHost;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UserService;\nimport com.vmware.xenon.services.common.authn.AuthenticationRequest;\nimport com.vmware.xenon.services.common.authn.BasicAuthenticationUtils;\n\npublic class TestExampleServiceHost extends BasicReusableHostTestCase {\n\n    private static final String adminUser = \"admin@localhost\";\n    private static final String exampleUser = \"example@localhost\";\n\n    /**\n     * Verify that the example service host creates users as expected.\n     *\n     * In theory we could test that authentication and authorization works correctly\n     * for these users. It's not critical to do here since we already test it in\n     * TestAuthSetupHelper.\n     */\n    @Test\n    public void createUsers() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        TemporaryFolder tmpFolder = new TemporaryFolder();\n        tmpFolder.create();\n        try {\n            String bindAddress = \"127.0.0.1\";\n\n            String[] args = {\n                    \"--sandbox=\"\n                            + tmpFolder.getRoot().getAbsolutePath(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--isAuthorizationEnabled=\" + Boolean.TRUE.toString(),\n                    \"--adminUser=\" + adminUser,\n                    \"--adminUserPassword=\" + adminUser,\n                    \"--exampleUser=\" + exampleUser,\n                    \"--exampleUserPassword=\" + exampleUser,\n            };\n\n            h.initialize(args);\n            h.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n            h.start();\n\n            URI hostUri = h.getUri();\n            String authToken = loginUser(hostUri);\n            waitForUsers(hostUri, authToken);\n\n        } finally {\n            h.stop();\n            tmpFolder.delete();\n        }\n    }\n\n    /**\n     * Supports createUsers() by logging in as the admin. The admin user\n     * isn't created immediately, so this polls.\n     */\n    private String loginUser(URI hostUri) throws Throwable {\n        URI usersLink = UriUtils.buildUri(hostUri, UserService.FACTORY_LINK);\n        // wait for factory availability\n        this.host.waitForReplicatedFactoryServiceAvailable(usersLink);\n\n        String basicAuth = BasicAuthenticationUtils.constructBasicAuth(adminUser, adminUser);\n        URI loginUri = UriUtils.buildUri(hostUri, ServiceUriPaths.CORE_AUTHN_BASIC);\n        AuthenticationRequest login = new AuthenticationRequest();\n        login.requestType = AuthenticationRequest.AuthenticationRequestType.LOGIN;\n\n        String[] authToken = new String[1];\n        authToken[0] = null;\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            Operation loginPost = Operation.createPost(loginUri)\n                    .setBody(login)\n                    .addRequestHeader(Operation.AUTHORIZATION_HEADER, basicAuth)\n                    .forceRemote()\n                    .setCompletion((op, ex) -> {\n                        if (ex != null) {\n                            this.host.completeIteration();\n                            return;\n                        }\n                        authToken[0] = op.getResponseHeader(Operation.REQUEST_AUTH_TOKEN_HEADER);\n                        this.host.completeIteration();\n                    });\n\n            this.host.testStart(1);\n            this.host.send(loginPost);\n            this.host.testWait();\n\n            if (authToken[0] != null) {\n                break;\n            }\n            Thread.sleep(250);\n        }\n\n        if (new Date().after(exp)) {\n            throw new TimeoutException();\n        }\n\n        assertNotNull(authToken[0]);\n\n        return authToken[0];\n    }\n\n    /**\n     * Supports createUsers() by waiting for two users to be created. They aren't created immediately,\n     * so this polls.\n     */\n    private void waitForUsers(URI hostUri, String authToken) throws Throwable {\n        URI usersLink = UriUtils.buildUri(hostUri, UserService.FACTORY_LINK);\n        Integer[] numberUsers = new Integer[1];\n        for (int i = 0; i < 20; i++) {\n            Operation get = Operation.createGet(usersLink)\n                    .forceRemote()\n                    .addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken)\n                    .setCompletion((op, ex) -> {\n                        if (ex != null) {\n                            if (op.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                this.host.failIteration(ex);\n                                return;\n                            } else {\n                                numberUsers[0] = 0;\n                                this.host.completeIteration();\n                                return;\n                            }\n                        }\n                        ServiceDocumentQueryResult response = op\n                                .getBody(ServiceDocumentQueryResult.class);\n                        assertTrue(response != null && response.documentLinks != null);\n                        numberUsers[0] = response.documentLinks.size();\n                        this.host.completeIteration();\n                    });\n\n            this.host.testStart(1);\n            this.host.send(get);\n            this.host.testWait();\n\n            if (numberUsers[0] == 2) {\n                break;\n            }\n            Thread.sleep(250);\n        }\n        assertTrue(numberUsers[0] == 2);\n    }\n\n}\n", "target": 1}
{"idx": 937, "func": "package io.hawt.web.plugin.karaf.terminal;\n\nimport org.apache.felix.service.command.CommandProcessor;\nimport org.apache.felix.service.command.CommandSession;\nimport org.apache.felix.service.threadio.ThreadIO;\nimport org.apache.karaf.shell.console.jline.Console;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.lang.reflect.Constructor;\nimport java.util.zip.GZIPOutputStream;\n\n/**\n *\n */\npublic class TerminalServlet extends HttpServlet {\n\n    public static final int TERM_WIDTH = 120;\n    public static final int TERM_HEIGHT = 39;\n    private final static Logger LOG = LoggerFactory.getLogger(TerminalServlet.class);\n    /**\n     * Pseudo class version ID to keep the IDE quite.\n     */\n    private static final long serialVersionUID = 1L;\n\n    public CommandProcessor getCommandProcessor() {\n        return CommandProcessorHolder.getCommandProcessor();\n    }\n\n    public ThreadIO getThreadIO() {\n        return ThreadIOHolder.getThreadIO();\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String encoding = request.getHeader(\"Accept-Encoding\");\n        boolean supportsGzip = (encoding != null && encoding.toLowerCase().indexOf(\"gzip\") > -1);\n        SessionTerminal st = (SessionTerminal) request.getSession(true).getAttribute(\"terminal\");\n        if (st == null || st.isClosed()) {\n            st = new SessionTerminal(getCommandProcessor(), getThreadIO());\n            request.getSession().setAttribute(\"terminal\", st);\n        }\n        String str = request.getParameter(\"k\");\n        String f = request.getParameter(\"f\");\n        String dump = st.handle(str, f != null && f.length() > 0);\n        if (dump != null) {\n            if (supportsGzip) {\n                response.setHeader(\"Content-Encoding\", \"gzip\");\n                response.setHeader(\"Content-Type\", \"text/html\");\n                try {\n                    GZIPOutputStream gzos = new GZIPOutputStream(response.getOutputStream());\n                    gzos.write(dump.getBytes());\n                    gzos.close();\n                } catch (IOException ie) {\n                    LOG.info(\"Exception writing response: \", ie);\n                }\n            } else {\n                response.getOutputStream().write(dump.getBytes());\n            }\n        }\n    }\n\n    public class SessionTerminal implements Runnable {\n\n        private Terminal terminal;\n        private Console console;\n        private PipedOutputStream in;\n        private PipedInputStream out;\n        private boolean closed;\n\n        public SessionTerminal(CommandProcessor commandProcessor, ThreadIO threadIO) throws IOException {\n            try {\n                this.terminal = new Terminal(TERM_WIDTH, TERM_HEIGHT);\n                terminal.write(\"\\u001b\\u005B20\\u0068\"); // set newline mode on\n\n                in = new PipedOutputStream();\n                out = new PipedInputStream();\n                PrintStream pipedOut = new PrintStream(new PipedOutputStream(out), true);\n\n                Constructor ctr = Console.class.getConstructors()[0];\n                if (ctr.getParameterTypes().length <= 7) {\n                    LOG.debug(\"Using old Karaf Console API\");\n                    // the old API does not have the threadIO parameter, so its only 7 parameters\n                    console = (Console) ctr.newInstance(commandProcessor,\n                            new PipedInputStream(in),\n                            pipedOut,\n                            pipedOut,\n                            new WebTerminal(TERM_WIDTH, TERM_HEIGHT),\n                            null,\n                            null);\n                } else {\n                    LOG.debug(\"Using new Karaf Console API\");\n                    // use the new api directly which we compile against\n                    console = new Console(commandProcessor,\n                            threadIO,\n                            new PipedInputStream(in),\n                            pipedOut,\n                            pipedOut,\n                            new WebTerminal(TERM_WIDTH, TERM_HEIGHT),\n                            null,\n                            null);\n                }\n\n                CommandSession session = console.getSession();\n                session.put(\"APPLICATION\", System.getProperty(\"karaf.name\", \"root\"));\n                session.put(\"USER\", \"karaf\");\n                session.put(\"COLUMNS\", Integer.toString(TERM_WIDTH));\n                session.put(\"LINES\", Integer.toString(TERM_HEIGHT));\n            } catch (IOException e) {\n                LOG.info(\"Exception attaching to console\", e);\n                throw e;\n            } catch (Exception e) {\n                LOG.info(\"Exception attaching to console\", e);\n                throw (IOException) new IOException().initCause(e);\n            }\n            new Thread(console).start();\n            new Thread(this).start();\n        }\n\n        public boolean isClosed() {\n            return closed;\n        }\n\n        public String handle(String str, boolean forceDump) throws IOException {\n            try {\n                if (str != null && str.length() > 0) {\n                    String d = terminal.pipe(str);\n                    for (byte b : d.getBytes()) {\n                        in.write(b);\n                    }\n                    in.flush();\n                }\n            } catch (IOException e) {\n                closed = true;\n                throw e;\n            }\n            try {\n                return terminal.dump(10, forceDump);\n            } catch (InterruptedException e) {\n                throw new InterruptedIOException(e.toString());\n            }\n        }\n\n        public void run() {\n            try {\n                for (; ; ) {\n                    byte[] buf = new byte[8192];\n                    int l = out.read(buf);\n                    InputStreamReader r = new InputStreamReader(new ByteArrayInputStream(buf, 0, l));\n                    StringBuilder sb = new StringBuilder();\n                    for (; ; ) {\n                        int c = r.read();\n                        if (c == -1) {\n                            break;\n                        }\n                        sb.append((char) c);\n                    }\n                    if (sb.length() > 0) {\n                        terminal.write(sb.toString());\n                    }\n                    String s = terminal.read();\n                    if (s != null && s.length() > 0) {\n                        for (byte b : s.getBytes()) {\n                            in.write(b);\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                closed = true;\n            }\n        }\n\n    }\n}\n", "target": 1}
{"idx": 938, "func": "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.onkyo.internal.handler;\n\nimport static org.openhab.binding.onkyo.internal.OnkyoBindingConstants.*;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.smarthome.core.audio.AudioHTTPServer;\nimport org.eclipse.smarthome.core.library.types.DecimalType;\nimport org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\nimport org.eclipse.smarthome.core.library.types.NextPreviousType;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.PercentType;\nimport org.eclipse.smarthome.core.library.types.PlayPauseType;\nimport org.eclipse.smarthome.core.library.types.RawType;\nimport org.eclipse.smarthome.core.library.types.RewindFastforwardType;\nimport org.eclipse.smarthome.core.library.types.StringType;\nimport org.eclipse.smarthome.core.thing.Channel;\nimport org.eclipse.smarthome.core.thing.ChannelUID;\nimport org.eclipse.smarthome.core.thing.Thing;\nimport org.eclipse.smarthome.core.thing.ThingStatus;\nimport org.eclipse.smarthome.core.thing.ThingStatusDetail;\nimport org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.RefreshType;\nimport org.eclipse.smarthome.core.types.State;\nimport org.eclipse.smarthome.core.types.StateOption;\nimport org.eclipse.smarthome.core.types.UnDefType;\nimport org.eclipse.smarthome.io.net.http.HttpUtil;\nimport org.eclipse.smarthome.io.transport.upnp.UpnpIOService;\nimport org.openhab.binding.onkyo.internal.OnkyoAlbumArt;\nimport org.openhab.binding.onkyo.internal.OnkyoConnection;\nimport org.openhab.binding.onkyo.internal.OnkyoEventListener;\nimport org.openhab.binding.onkyo.internal.OnkyoStateDescriptionProvider;\nimport org.openhab.binding.onkyo.internal.ServiceType;\nimport org.openhab.binding.onkyo.internal.automation.modules.OnkyoThingActionsService;\nimport org.openhab.binding.onkyo.internal.config.OnkyoDeviceConfiguration;\nimport org.openhab.binding.onkyo.internal.eiscp.EiscpCommand;\nimport org.openhab.binding.onkyo.internal.eiscp.EiscpMessage;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link OnkyoHandler} is responsible for handling commands, which are\n * sent to one of the channels.\n *\n * @author Paul Frank - Initial contribution\n * @author Marcel Verpaalen - parsing additional commands\n * @author Pauli Anttila - lot of refactoring\n * @author Stewart Cossey - add dynamic state description provider\n */\npublic class OnkyoHandler extends UpnpAudioSinkHandler implements OnkyoEventListener {\n\n    private final Logger logger = LoggerFactory.getLogger(OnkyoHandler.class);\n\n    private OnkyoDeviceConfiguration configuration;\n\n    private OnkyoConnection connection;\n    private ScheduledFuture<?> resourceUpdaterFuture;\n    @SuppressWarnings(\"unused\")\n    private int currentInput = -1;\n    private State volumeLevelZone1 = UnDefType.UNDEF;\n    private State volumeLevelZone2 = UnDefType.UNDEF;\n    private State volumeLevelZone3 = UnDefType.UNDEF;\n    private State lastPowerState = OnOffType.OFF;\n\n    private final OnkyoStateDescriptionProvider stateDescriptionProvider;\n\n    private final OnkyoAlbumArt onkyoAlbumArt = new OnkyoAlbumArt();\n\n    private static final int NET_USB_ID = 43;\n\n    public OnkyoHandler(Thing thing, UpnpIOService upnpIOService, AudioHTTPServer audioHTTPServer, String callbackUrl,\n            OnkyoStateDescriptionProvider stateDescriptionProvider) {\n        super(thing, upnpIOService, audioHTTPServer, callbackUrl);\n        this.stateDescriptionProvider = stateDescriptionProvider;\n    }\n\n    /**\n     * Initialize the state of the receiver.\n     */\n    @Override\n    public void initialize() {\n        logger.debug(\"Initializing handler for Onkyo Receiver\");\n        configuration = getConfigAs(OnkyoDeviceConfiguration.class);\n        logger.info(\"Using configuration: {}\", configuration.toString());\n\n        connection = new OnkyoConnection(configuration.ipAddress, configuration.port);\n        connection.addEventListener(this);\n\n        scheduler.execute(() -> {\n            logger.debug(\"Open connection to Onkyo Receiver @{}\", connection.getConnectionName());\n            connection.openConnection();\n            if (connection.isConnected()) {\n                updateStatus(ThingStatus.ONLINE);\n\n                sendCommand(EiscpCommand.INFO_QUERY);\n            }\n        });\n\n        if (configuration.refreshInterval > 0) {\n            // Start resource refresh updater\n            resourceUpdaterFuture = scheduler.scheduleWithFixedDelay(() -> {\n                try {\n                    logger.debug(\"Send resource update requests to Onkyo Receiver @{}\", connection.getConnectionName());\n                    checkStatus();\n                } catch (LinkageError e) {\n                    logger.warn(\"Failed to send resource update requests to Onkyo Receiver @{}. Cause: {}\",\n                            connection.getConnectionName(), e.getMessage());\n                } catch (Exception ex) {\n                    logger.warn(\"Exception in resource refresh Thread Onkyo Receiver @{}. Cause: {}\",\n                            connection.getConnectionName(), ex.getMessage());\n                }\n            }, configuration.refreshInterval, configuration.refreshInterval, TimeUnit.SECONDS);\n        }\n    }\n\n    @Override\n    public void dispose() {\n        super.dispose();\n        if (resourceUpdaterFuture != null) {\n            resourceUpdaterFuture.cancel(true);\n        }\n        if (connection != null) {\n            connection.removeEventListener(this);\n            connection.closeConnection();\n        }\n    }\n\n    @Override\n    public void handleCommand(ChannelUID channelUID, Command command) {\n        logger.debug(\"handleCommand for channel {}: {}\", channelUID.getId(), command.toString());\n        switch (channelUID.getId()) {\n            /*\n             * ZONE 1\n             */\n\n            case CHANNEL_POWER:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.POWER_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.POWER_QUERY);\n                }\n                break;\n            case CHANNEL_MUTE:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.MUTE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.MUTE_QUERY);\n                }\n                break;\n            case CHANNEL_VOLUME:\n                handleVolumeSet(EiscpCommand.Zone.ZONE1, volumeLevelZone1, command);\n                break;\n            case CHANNEL_INPUT:\n                if (command instanceof DecimalType) {\n                    selectInput(((DecimalType) command).intValue());\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.SOURCE_QUERY);\n                }\n                break;\n            case CHANNEL_LISTENMODE:\n                if (command instanceof DecimalType) {\n                    sendCommand(EiscpCommand.LISTEN_MODE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.LISTEN_MODE_QUERY);\n                }\n                break;\n\n            /*\n             * ZONE 2\n             */\n\n            case CHANNEL_POWERZONE2:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE2_POWER_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE2_POWER_QUERY);\n                }\n                break;\n            case CHANNEL_MUTEZONE2:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE2_MUTE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE2_MUTE_QUERY);\n                }\n                break;\n            case CHANNEL_VOLUMEZONE2:\n                handleVolumeSet(EiscpCommand.Zone.ZONE2, volumeLevelZone2, command);\n                break;\n            case CHANNEL_INPUTZONE2:\n                if (command instanceof DecimalType) {\n                    sendCommand(EiscpCommand.ZONE2_SOURCE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE2_SOURCE_QUERY);\n                }\n                break;\n\n            /*\n             * ZONE 3\n             */\n\n            case CHANNEL_POWERZONE3:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE3_POWER_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE3_POWER_QUERY);\n                }\n                break;\n            case CHANNEL_MUTEZONE3:\n                if (command instanceof OnOffType) {\n                    sendCommand(EiscpCommand.ZONE3_MUTE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE3_MUTE_QUERY);\n                }\n                break;\n            case CHANNEL_VOLUMEZONE3:\n                handleVolumeSet(EiscpCommand.Zone.ZONE3, volumeLevelZone3, command);\n                break;\n            case CHANNEL_INPUTZONE3:\n                if (command instanceof DecimalType) {\n                    sendCommand(EiscpCommand.ZONE3_SOURCE_SET, command);\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.ZONE3_SOURCE_QUERY);\n                }\n                break;\n\n            /*\n             * NET PLAYER\n             */\n\n            case CHANNEL_CONTROL:\n                if (command instanceof PlayPauseType) {\n                    if (command.equals(PlayPauseType.PLAY)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_PLAY);\n                    } else if (command.equals(PlayPauseType.PAUSE)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_PAUSE);\n                    }\n                } else if (command instanceof NextPreviousType) {\n                    if (command.equals(NextPreviousType.NEXT)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_TRACKUP);\n                    } else if (command.equals(NextPreviousType.PREVIOUS)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_TRACKDWN);\n                    }\n                } else if (command instanceof RewindFastforwardType) {\n                    if (command.equals(RewindFastforwardType.REWIND)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_REW);\n                    } else if (command.equals(RewindFastforwardType.FASTFORWARD)) {\n                        sendCommand(EiscpCommand.NETUSB_OP_FF);\n                    }\n                } else if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_PLAY_STATUS_QUERY);\n                }\n                break;\n            case CHANNEL_PLAY_URI:\n                handlePlayUri(command);\n                break;\n            case CHANNEL_ALBUM_ART:\n            case CHANNEL_ALBUM_ART_URL:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_ALBUM_ART_QUERY);\n                }\n                break;\n            case CHANNEL_ARTIST:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_ARTIST_QUERY);\n                }\n                break;\n            case CHANNEL_ALBUM:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_ALBUM_QUERY);\n                }\n                break;\n            case CHANNEL_TITLE:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_TITLE_QUERY);\n                }\n                break;\n            case CHANNEL_CURRENTPLAYINGTIME:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_SONG_ELAPSEDTIME_QUERY);\n                }\n                break;\n\n            /*\n             * NET MENU\n             */\n\n            case CHANNEL_NET_MENU_CONTROL:\n                if (command instanceof StringType) {\n                    final String cmdName = command.toString();\n                    handleNetMenuCommand(cmdName);\n                }\n                break;\n            case CHANNEL_NET_MENU_TITLE:\n                if (command.equals(RefreshType.REFRESH)) {\n                    sendCommand(EiscpCommand.NETUSB_TITLE_QUERY);\n                }\n                break;\n\n            /*\n             * MISC\n             */\n\n            default:\n                logger.debug(\"Command received for an unknown channel: {}\", channelUID.getId());\n                break;\n        }\n    }\n\n    private void populateInputs(NodeList selectorlist) {\n        List<StateOption> options = new ArrayList<>();\n\n        for (int i = 0; i < selectorlist.getLength(); i++) {\n            Element selectorItem = (Element) selectorlist.item(i);\n\n            options.add(new StateOption(String.valueOf(Integer.parseInt(selectorItem.getAttribute(\"id\"), 16)),\n                    selectorItem.getAttribute(\"name\")));\n        }\n        logger.debug(\"Got Input List from Receiver {}\", options);\n\n        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_INPUT), options);\n        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_INPUTZONE2), options);\n        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_INPUTZONE3), options);\n    }\n\n    private void doPowerOnCheck(State state) {\n        if (configuration.refreshInterval == 0 && lastPowerState == OnOffType.OFF && state == OnOffType.ON) {\n            sendCommand(EiscpCommand.INFO_QUERY);\n        }\n        lastPowerState = state;\n    }\n\n    @Override\n    public void statusUpdateReceived(String ip, EiscpMessage data) {\n        logger.debug(\"Received status update from Onkyo Receiver @{}: data={}\", connection.getConnectionName(), data);\n\n        updateStatus(ThingStatus.ONLINE);\n\n        try {\n            EiscpCommand receivedCommand = null;\n\n            try {\n                receivedCommand = EiscpCommand.getCommandByCommandAndValueStr(data.getCommand(), \"\");\n            } catch (IllegalArgumentException ex) {\n                logger.debug(\"Received unknown status update from Onkyo Receiver @{}: data={}\",\n                        connection.getConnectionName(), data);\n                return;\n            }\n\n            logger.debug(\"Received command {}\", receivedCommand);\n\n            switch (receivedCommand) {\n                /*\n                 * ZONE 1\n                 */\n                case POWER:\n                    State powerState = convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class);\n                    updateState(CHANNEL_POWER, powerState);\n                    doPowerOnCheck(powerState);\n                    break;\n                case MUTE:\n                    updateState(CHANNEL_MUTE, convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class));\n                    break;\n                case VOLUME:\n                    volumeLevelZone1 = handleReceivedVolume(\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    updateState(CHANNEL_VOLUME, volumeLevelZone1);\n                    break;\n                case SOURCE:\n                    updateState(CHANNEL_INPUT, convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n                case LISTEN_MODE:\n                    updateState(CHANNEL_LISTENMODE,\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n\n                /*\n                 * ZONE 2\n                 */\n                case ZONE2_POWER:\n                    State powerZone2State = convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class);\n                    updateState(CHANNEL_POWERZONE2, powerZone2State);\n                    doPowerOnCheck(powerZone2State);\n                    break;\n                case ZONE2_MUTE:\n                    updateState(CHANNEL_MUTEZONE2, convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class));\n                    break;\n                case ZONE2_VOLUME:\n                    volumeLevelZone2 = handleReceivedVolume(\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    updateState(CHANNEL_VOLUMEZONE2, volumeLevelZone2);\n                    break;\n                case ZONE2_SOURCE:\n                    updateState(CHANNEL_INPUTZONE2,\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n\n                /*\n                 * ZONE 3\n                 */\n                case ZONE3_POWER:\n                    State powerZone3State = convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class);\n                    updateState(CHANNEL_POWERZONE3, powerZone3State);\n                    doPowerOnCheck(powerZone3State);\n                    break;\n                case ZONE3_MUTE:\n                    updateState(CHANNEL_MUTEZONE3, convertDeviceValueToOpenHabState(data.getValue(), OnOffType.class));\n                    break;\n                case ZONE3_VOLUME:\n                    volumeLevelZone3 = handleReceivedVolume(\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    updateState(CHANNEL_VOLUMEZONE3, volumeLevelZone3);\n                    break;\n                case ZONE3_SOURCE:\n                    updateState(CHANNEL_INPUTZONE3,\n                            convertDeviceValueToOpenHabState(data.getValue(), DecimalType.class));\n                    break;\n\n                /*\n                 * NET PLAYER\n                 */\n\n                case NETUSB_SONG_ARTIST:\n                    updateState(CHANNEL_ARTIST, convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_SONG_ALBUM:\n                    updateState(CHANNEL_ALBUM, convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_SONG_TITLE:\n                    updateState(CHANNEL_TITLE, convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_SONG_ELAPSEDTIME:\n                    updateState(CHANNEL_CURRENTPLAYINGTIME,\n                            convertDeviceValueToOpenHabState(data.getValue(), StringType.class));\n                    break;\n                case NETUSB_PLAY_STATUS:\n                    updateState(CHANNEL_CONTROL, convertNetUsbPlayStatus(data.getValue()));\n                    break;\n                case NETUSB_ALBUM_ART:\n                    updateAlbumArt(data.getValue());\n                    break;\n                case NETUSB_TITLE:\n                    updateNetTitle(data.getValue());\n                    break;\n                case NETUSB_MENU:\n                    updateNetMenu(data.getValue());\n                    break;\n\n                /*\n                 * MISC\n                 */\n\n                case INFO:\n                    processInfo(data.getValue());\n                    logger.debug(\"Info message: '{}'\", data.getValue());\n                    break;\n\n                default:\n                    logger.debug(\"Received unhandled status update from Onkyo Receiver @{}: data={}\",\n                            connection.getConnectionName(), data);\n\n            }\n\n        } catch (Exception ex) {\n            logger.warn(\"Exception in statusUpdateReceived for Onkyo Receiver @{}. Cause: {}, data received: {}\",\n                    connection.getConnectionName(), ex.getMessage(), data);\n        }\n    }\n\n    private void processInfo(String infoXML) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            try (StringReader sr = new StringReader(infoXML)) {\n                InputSource is = new InputSource(sr);\n                Document doc = builder.parse(is);\n\n                NodeList selectableInputs = doc.getDocumentElement().getElementsByTagName(\"selector\");\n                populateInputs(selectableInputs);\n            }\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            logger.debug(\"Error occured during Info XML parsing.\", e);\n        }\n    }\n\n    @Override\n    public void connectionError(String ip, String errorMsg) {\n        logger.debug(\"Connection error occurred to Onkyo Receiver @{}\", ip);\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\n    }\n\n    private State convertDeviceValueToOpenHabState(String data, Class<?> classToConvert) {\n        State state = UnDefType.UNDEF;\n\n        try {\n            int index;\n\n            if (data.contentEquals(\"N/A\")) {\n                state = UnDefType.UNDEF;\n\n            } else if (classToConvert == OnOffType.class) {\n                index = Integer.parseInt(data, 16);\n                state = index == 0 ? OnOffType.OFF : OnOffType.ON;\n\n            } else if (classToConvert == DecimalType.class) {\n                index = Integer.parseInt(data, 16);\n                state = new DecimalType(index);\n\n            } else if (classToConvert == PercentType.class) {\n                index = Integer.parseInt(data, 16);\n                state = new PercentType(index);\n\n            } else if (classToConvert == StringType.class) {\n                state = new StringType(data);\n\n            }\n        } catch (Exception e) {\n            logger.debug(\"Cannot convert value '{}' to data type {}\", data, classToConvert);\n        }\n\n        logger.debug(\"Converted data '{}' to openHAB state '{}' ({})\", data, state, classToConvert);\n        return state;\n    }\n\n    private void handleNetMenuCommand(String cmdName) {\n        if (\"Up\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_UP);\n        } else if (\"Down\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_DOWN);\n        } else if (\"Select\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_SELECT);\n        } else if (\"PageUp\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_LEFT);\n        } else if (\"PageDown\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_RIGHT);\n        } else if (\"Back\".equals(cmdName)) {\n            sendCommand(EiscpCommand.NETUSB_OP_RETURN);\n        } else if (cmdName.matches(\"Select[0-9]\")) {\n            int pos = Integer.parseInt(cmdName.substring(6));\n            sendCommand(EiscpCommand.NETUSB_MENU_SELECT, new DecimalType(pos));\n        } else {\n            logger.debug(\"Received unknown menucommand {}\", cmdName);\n        }\n    }\n\n    private void selectInput(int inputId) {\n        sendCommand(EiscpCommand.SOURCE_SET, new DecimalType(inputId));\n        currentInput = inputId;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private void onInputChanged(int newInput) {\n        currentInput = newInput;\n\n        if (newInput != NET_USB_ID) {\n            resetNetMenu();\n\n            updateState(CHANNEL_ARTIST, UnDefType.UNDEF);\n            updateState(CHANNEL_ALBUM, UnDefType.UNDEF);\n            updateState(CHANNEL_TITLE, UnDefType.UNDEF);\n            updateState(CHANNEL_CURRENTPLAYINGTIME, UnDefType.UNDEF);\n        }\n    }\n\n    private void updateAlbumArt(String data) {\n        onkyoAlbumArt.addFrame(data);\n\n        if (onkyoAlbumArt.isAlbumCoverReady()) {\n            try {\n                byte[] imgData = onkyoAlbumArt.getAlbumArt();\n                if (imgData != null && imgData.length > 0) {\n                    String mimeType = onkyoAlbumArt.getAlbumArtMimeType();\n                    if (mimeType.isEmpty()) {\n                        mimeType = guessMimeTypeFromData(imgData);\n                    }\n                    updateState(CHANNEL_ALBUM_ART, new RawType(imgData, mimeType));\n                } else {\n                    updateState(CHANNEL_ALBUM_ART, UnDefType.UNDEF);\n                }\n            } catch (IllegalArgumentException e) {\n                updateState(CHANNEL_ALBUM_ART, UnDefType.UNDEF);\n            }\n            onkyoAlbumArt.clearAlbumArt();\n        }\n\n        if (data.startsWith(\"2-\")) {\n            updateState(CHANNEL_ALBUM_ART_URL, new StringType(data.substring(2, data.length())));\n        } else if (data.startsWith(\"n-\")) {\n            updateState(CHANNEL_ALBUM_ART_URL, UnDefType.UNDEF);\n        } else {\n            logger.debug(\"Not supported album art URL type: {}\", data.substring(0, 2));\n            updateState(CHANNEL_ALBUM_ART_URL, UnDefType.UNDEF);\n        }\n    }\n\n    private void updateNetTitle(String data) {\n        // first 2 characters is service type\n        int type = Integer.parseInt(data.substring(0, 2), 16);\n        ServiceType service = ServiceType.getType(type);\n\n        String title = \"\";\n        if (data.length() > 21) {\n            title = data.substring(22, data.length());\n        }\n\n        updateState(CHANNEL_NET_MENU_TITLE,\n                new StringType(service.toString() + ((title.length() > 0) ? \": \" + title : \"\")));\n    }\n\n    private void updateNetMenu(String data) {\n        switch (data.charAt(0)) {\n            case 'U':\n                String itemData = data.substring(3, data.length());\n                switch (data.charAt(1)) {\n                    case '0':\n                        updateState(CHANNEL_NET_MENU0, new StringType(itemData));\n                        break;\n                    case '1':\n                        updateState(CHANNEL_NET_MENU1, new StringType(itemData));\n                        break;\n                    case '2':\n                        updateState(CHANNEL_NET_MENU2, new StringType(itemData));\n                        break;\n                    case '3':\n                        updateState(CHANNEL_NET_MENU3, new StringType(itemData));\n                        break;\n                    case '4':\n                        updateState(CHANNEL_NET_MENU4, new StringType(itemData));\n                        break;\n                    case '5':\n                        updateState(CHANNEL_NET_MENU5, new StringType(itemData));\n                        break;\n                    case '6':\n                        updateState(CHANNEL_NET_MENU6, new StringType(itemData));\n                        break;\n                    case '7':\n                        updateState(CHANNEL_NET_MENU7, new StringType(itemData));\n                        break;\n                    case '8':\n                        updateState(CHANNEL_NET_MENU8, new StringType(itemData));\n                        break;\n                    case '9':\n                        updateState(CHANNEL_NET_MENU9, new StringType(itemData));\n                        break;\n                }\n                break;\n\n            case 'C':\n                updateMenuPosition(data);\n                break;\n        }\n    }\n\n    private void updateMenuPosition(String data) {\n        char position = data.charAt(1);\n        int pos = Character.getNumericValue(position);\n\n        logger.debug(\"Updating menu position to {}\", pos);\n\n        if (pos == -1) {\n            updateState(CHANNEL_NET_MENU_SELECTION, UnDefType.UNDEF);\n        } else {\n            updateState(CHANNEL_NET_MENU_SELECTION, new DecimalType(pos));\n        }\n\n        if (data.endsWith(\"P\")) {\n            resetNetMenu();\n        }\n    }\n\n    private void resetNetMenu() {\n        logger.debug(\"Reset net menu\");\n        updateState(CHANNEL_NET_MENU0, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU1, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU2, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU3, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU4, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU5, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU6, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU7, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU8, new StringType(\"-\"));\n        updateState(CHANNEL_NET_MENU9, new StringType(\"-\"));\n    }\n\n    private State convertNetUsbPlayStatus(String data) {\n        State state = UnDefType.UNDEF;\n        switch (data.charAt(0)) {\n            case 'P':\n                state = PlayPauseType.PLAY;\n                break;\n            case 'p':\n            case 'S':\n                state = PlayPauseType.PAUSE;\n                break;\n            case 'F':\n                state = RewindFastforwardType.FASTFORWARD;\n                break;\n            case 'R':\n                state = RewindFastforwardType.REWIND;\n                break;\n\n        }\n        return state;\n    }\n\n    public void sendRawCommand(String command, String value) {\n        if (connection != null) {\n            connection.send(command, value);\n        } else {\n            logger.debug(\"Cannot send command to onkyo receiver since the onkyo binding is not initialized\");\n        }\n    }\n\n    private void sendCommand(EiscpCommand deviceCommand) {\n        if (connection != null) {\n            connection.send(deviceCommand.getCommand(), deviceCommand.getValue());\n        } else {\n            logger.debug(\"Connect send command to onkyo receiver since the onkyo binding is not initialized\");\n        }\n    }\n\n    private void sendCommand(EiscpCommand deviceCommand, Command command) {\n        if (connection != null) {\n            final String cmd = deviceCommand.getCommand();\n            String valTemplate = deviceCommand.getValue();\n            String val;\n\n            if (command instanceof OnOffType) {\n                val = String.format(valTemplate, command == OnOffType.ON ? 1 : 0);\n\n            } else if (command instanceof StringType) {\n                val = String.format(valTemplate, command);\n\n            } else if (command instanceof DecimalType) {\n                val = String.format(valTemplate, ((DecimalType) command).intValue());\n\n            } else if (command instanceof PercentType) {\n                val = String.format(valTemplate, ((DecimalType) command).intValue());\n            } else {\n                val = valTemplate;\n            }\n\n            logger.debug(\"Sending command '{}' with value '{}' to Onkyo Receiver @{}\", cmd, val,\n                    connection.getConnectionName());\n            connection.send(cmd, val);\n        } else {\n            logger.debug(\"Connect send command to onkyo receiver since the onkyo binding is not initialized\");\n        }\n    }\n\n    /**\n     * Check the status of the AVR.\n     *\n     * @return\n     */\n    private void checkStatus() {\n        sendCommand(EiscpCommand.POWER_QUERY);\n\n        if (connection != null && connection.isConnected()) {\n            sendCommand(EiscpCommand.VOLUME_QUERY);\n            sendCommand(EiscpCommand.SOURCE_QUERY);\n            sendCommand(EiscpCommand.MUTE_QUERY);\n            sendCommand(EiscpCommand.NETUSB_TITLE_QUERY);\n            sendCommand(EiscpCommand.LISTEN_MODE_QUERY);\n            sendCommand(EiscpCommand.INFO_QUERY);\n\n            if (isChannelAvailable(CHANNEL_POWERZONE2)) {\n                sendCommand(EiscpCommand.ZONE2_POWER_QUERY);\n                sendCommand(EiscpCommand.ZONE2_VOLUME_QUERY);\n                sendCommand(EiscpCommand.ZONE2_SOURCE_QUERY);\n                sendCommand(EiscpCommand.ZONE2_MUTE_QUERY);\n            }\n\n            if (isChannelAvailable(CHANNEL_POWERZONE3)) {\n                sendCommand(EiscpCommand.ZONE3_POWER_QUERY);\n                sendCommand(EiscpCommand.ZONE3_VOLUME_QUERY);\n                sendCommand(EiscpCommand.ZONE3_SOURCE_QUERY);\n                sendCommand(EiscpCommand.ZONE3_MUTE_QUERY);\n            }\n        } else {\n            updateStatus(ThingStatus.OFFLINE);\n        }\n    }\n\n    private boolean isChannelAvailable(String channel) {\n        List<Channel> channels = getThing().getChannels();\n        for (Channel c : channels) {\n            if (c.getUID().getId().equals(channel)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void handleVolumeSet(EiscpCommand.Zone zone, final State currentValue, final Command command) {\n        if (command instanceof PercentType) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_SET),\n                    downScaleVolume((PercentType) command));\n        } else if (command.equals(IncreaseDecreaseType.INCREASE)) {\n            if (currentValue instanceof PercentType) {\n                if (((DecimalType) currentValue).intValue() < configuration.volumeLimit) {\n                    sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_UP));\n                } else {\n                    logger.info(\"Volume level is limited to {}, ignore volume up command.\", configuration.volumeLimit);\n                }\n            }\n        } else if (command.equals(IncreaseDecreaseType.DECREASE)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_DOWN));\n        } else if (command.equals(OnOffType.OFF)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.MUTE_SET), command);\n        } else if (command.equals(OnOffType.ON)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.MUTE_SET), command);\n        } else if (command.equals(RefreshType.REFRESH)) {\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.VOLUME_QUERY));\n            sendCommand(EiscpCommand.getCommandForZone(zone, EiscpCommand.MUTE_QUERY));\n        }\n    }\n\n    private State handleReceivedVolume(State volume) {\n        if (volume instanceof DecimalType) {\n            return upScaleVolume(((DecimalType) volume));\n        }\n        return volume;\n    }\n\n    private PercentType upScaleVolume(DecimalType volume) {\n        PercentType newVolume = scaleVolumeFromReceiver(volume);\n\n        if (configuration.volumeLimit < 100) {\n            double scaleCoefficient = 100d / configuration.volumeLimit;\n            PercentType unLimitedVolume = newVolume;\n            newVolume = new PercentType(((Double) (newVolume.doubleValue() * scaleCoefficient)).intValue());\n            logger.debug(\"Up scaled volume level '{}' to '{}'\", unLimitedVolume, newVolume);\n        }\n\n        return newVolume;\n    }\n\n    private DecimalType downScaleVolume(PercentType volume) {\n        PercentType limitedVolume = volume;\n\n        if (configuration.volumeLimit < 100) {\n            double scaleCoefficient = configuration.volumeLimit / 100d;\n            limitedVolume = new PercentType(((Double) (volume.doubleValue() * scaleCoefficient)).intValue());\n            logger.debug(\"Limited volume level '{}' to '{}'\", volume, limitedVolume);\n        }\n\n        return scaleVolumeForReceiver(limitedVolume);\n    }\n\n    private DecimalType scaleVolumeForReceiver(PercentType volume) {\n        return new DecimalType(((Double) (volume.doubleValue() * configuration.volumeScale)).intValue());\n    }\n\n    private PercentType scaleVolumeFromReceiver(DecimalType volume) {\n        return new PercentType(((Double) (volume.intValue() / configuration.volumeScale)).intValue());\n    }\n\n    @Override\n    public PercentType getVolume() throws IOException {\n        if (volumeLevelZone1 instanceof PercentType) {\n            return (PercentType) volumeLevelZone1;\n        }\n\n        throw new IOException();\n    }\n\n    @Override\n    public void setVolume(PercentType volume) throws IOException {\n        handleVolumeSet(EiscpCommand.Zone.ZONE1, volumeLevelZone1, downScaleVolume(volume));\n    }\n\n    private String guessMimeTypeFromData(byte[] data) {\n        String mimeType = HttpUtil.guessContentTypeFromData(data);\n        logger.debug(\"Mime type guess from content: {}\", mimeType);\n        if (mimeType == null) {\n            mimeType = RawType.DEFAULT_MIME_TYPE;\n        }\n        logger.debug(\"Mime type: {}\", mimeType);\n        return mimeType;\n    }\n\n    @Override\n    public Collection<Class<? extends ThingHandlerService>> getServices() {\n        return Collections.singletonList(OnkyoThingActionsService.class);\n    }\n}\n", "target": 0}
{"idx": 939, "func": "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.stream;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOutboundHandlerAdapter;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.FileChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static java.util.concurrent.TimeUnit.*;\nimport static org.junit.Assert.*;\n\npublic class ChunkedWriteHandlerTest {\n    private static final byte[] BYTES = new byte[1024 * 64];\n    private static final File TMP;\n\n    static {\n        for (int i = 0; i < BYTES.length; i++) {\n            BYTES[i] = (byte) i;\n        }\n\n        FileOutputStream out = null;\n        try {\n            TMP = File.createTempFile(\"netty-chunk-\", \".tmp\");\n            TMP.deleteOnExit();\n            out = new FileOutputStream(TMP);\n            out.write(BYTES);\n            out.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n    }\n\n    // See #310\n    @Test\n    public void testChunkedStream() {\n        check(new ChunkedStream(new ByteArrayInputStream(BYTES)));\n\n        check(new ChunkedStream(new ByteArrayInputStream(BYTES)),\n                new ChunkedStream(new ByteArrayInputStream(BYTES)),\n                new ChunkedStream(new ByteArrayInputStream(BYTES)));\n    }\n\n    @Test\n    public void testChunkedNioStream() {\n        check(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n\n        check(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),\n                new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),\n                new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n    }\n\n    @Test\n    public void testChunkedFile() throws IOException {\n        check(new ChunkedFile(TMP));\n\n        check(new ChunkedFile(TMP), new ChunkedFile(TMP), new ChunkedFile(TMP));\n    }\n\n    @Test\n    public void testChunkedNioFile() throws IOException {\n        check(new ChunkedNioFile(TMP));\n\n        check(new ChunkedNioFile(TMP), new ChunkedNioFile(TMP), new ChunkedNioFile(TMP));\n    }\n\n    @Test\n    public void testChunkedNioFileLeftPositionUnchanged() throws IOException {\n        FileChannel in = null;\n        final long expectedPosition = 10;\n        try {\n            in = new RandomAccessFile(TMP, \"r\").getChannel();\n            in.position(expectedPosition);\n            check(new ChunkedNioFile(in) {\n                @Override\n                public void close() throws Exception {\n                    //no op\n                }\n            });\n            Assert.assertTrue(in.isOpen());\n            Assert.assertEquals(expectedPosition, in.position());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n\n    @Test(expected = ClosedChannelException.class)\n    public void testChunkedNioFileFailOnClosedFileChannel() throws IOException {\n        final FileChannel in = new RandomAccessFile(TMP, \"r\").getChannel();\n        in.close();\n        check(new ChunkedNioFile(in) {\n            @Override\n            public void close() throws Exception {\n                //no op\n            }\n        });\n        Assert.fail();\n    }\n\n    @Test\n    public void testUnchunkedData() throws IOException {\n        check(Unpooled.wrappedBuffer(BYTES));\n\n        check(Unpooled.wrappedBuffer(BYTES), Unpooled.wrappedBuffer(BYTES), Unpooled.wrappedBuffer(BYTES));\n    }\n\n    // Test case which shows that there is not a bug like stated here:\n    // https://stackoverflow.com/a/10426305\n    @Test\n    public void testListenerNotifiedWhenIsEnd() {\n        ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n\n        ChunkedInput<ByteBuf> input = new ChunkedInput<ByteBuf>() {\n            private boolean done;\n            private final ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return done;\n            }\n\n            @Override\n            public void close() throws Exception {\n                buffer.release();\n            }\n\n            @Deprecated\n            @Override\n            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n                if (done) {\n                    return null;\n                }\n                done = true;\n                return buffer.retainedDuplicate();\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        final AtomicBoolean listenerNotified = new AtomicBoolean(false);\n        final ChannelFutureListener listener = new ChannelFutureListener() {\n\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                listenerNotified.set(true);\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n        ch.writeAndFlush(input).addListener(listener).syncUninterruptibly();\n        assertTrue(ch.finish());\n\n        // the listener should have been notified\n        assertTrue(listenerNotified.get());\n\n        ByteBuf buffer2 = ch.readOutbound();\n        assertEquals(buffer, buffer2);\n        assertNull(ch.readOutbound());\n\n        buffer.release();\n        buffer2.release();\n    }\n\n    @Test\n    public void testChunkedMessageInput() {\n\n        ChunkedInput<Object> input = new ChunkedInput<Object>() {\n            private boolean done;\n\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return done;\n            }\n\n            @Override\n            public void close() throws Exception {\n                // NOOP\n            }\n\n            @Deprecated\n            @Override\n            public Object readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public Object readChunk(ByteBufAllocator ctx) throws Exception {\n                if (done) {\n                    return false;\n                }\n                done = true;\n                return 0;\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n        ch.writeAndFlush(input).syncUninterruptibly();\n        assertTrue(ch.finish());\n\n        assertEquals(0, ch.readOutbound());\n        assertNull(ch.readOutbound());\n    }\n\n    @Test\n    public void testWriteFailureChunkedStream() throws IOException {\n        checkFirstFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)));\n    }\n\n    @Test\n    public void testWriteFailureChunkedNioStream() throws IOException {\n        checkFirstFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n    }\n\n    @Test\n    public void testWriteFailureChunkedFile() throws IOException {\n        checkFirstFailed(new ChunkedFile(TMP));\n    }\n\n    @Test\n    public void testWriteFailureChunkedNioFile() throws IOException {\n        checkFirstFailed(new ChunkedNioFile(TMP));\n    }\n\n    @Test\n    public void testWriteFailureUnchunkedData() throws IOException {\n        checkFirstFailed(Unpooled.wrappedBuffer(BYTES));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedStream() throws IOException {\n        checkSkipFailed(new ChunkedStream(new ByteArrayInputStream(BYTES)),\n                        new ChunkedStream(new ByteArrayInputStream(BYTES)));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedNioStream() throws IOException {\n        checkSkipFailed(new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))),\n                        new ChunkedNioStream(Channels.newChannel(new ByteArrayInputStream(BYTES))));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedFile() throws IOException {\n        checkSkipFailed(new ChunkedFile(TMP), new ChunkedFile(TMP));\n    }\n\n    @Test\n    public void testSkipAfterFailedChunkedNioFile() throws IOException {\n        checkSkipFailed(new ChunkedNioFile(TMP), new ChunkedFile(TMP));\n    }\n\n    // See https://github.com/netty/netty/issues/8700.\n    @Test\n    public void testFailureWhenLastChunkFailed() throws IOException {\n        ChannelOutboundHandlerAdapter failLast = new ChannelOutboundHandlerAdapter() {\n            private int passedWrites;\n\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                if (++this.passedWrites < 4) {\n                    ctx.write(msg, promise);\n                } else {\n                    ReferenceCountUtil.release(msg);\n                    promise.tryFailure(new RuntimeException());\n                }\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(failLast, new ChunkedWriteHandler());\n        ChannelFuture r = ch.writeAndFlush(new ChunkedFile(TMP, 1024 * 16)); // 4 chunks\n        assertTrue(ch.finish());\n\n        assertFalse(r.isSuccess());\n        assertTrue(r.cause() instanceof RuntimeException);\n\n        // 3 out of 4 chunks were already written\n        int read = 0;\n        for (;;) {\n            ByteBuf buffer = ch.readOutbound();\n            if (buffer == null) {\n                break;\n            }\n            read += buffer.readableBytes();\n            buffer.release();\n        }\n\n        assertEquals(1024 * 16 * 3, read);\n    }\n\n    @Test\n    public void testDiscardPendingWritesOnInactive() throws IOException {\n\n        final AtomicBoolean closeWasCalled = new AtomicBoolean(false);\n\n        ChunkedInput<ByteBuf> notifiableInput = new ChunkedInput<ByteBuf>() {\n            private boolean done;\n            private final ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return done;\n            }\n\n            @Override\n            public void close() throws Exception {\n                buffer.release();\n                closeWasCalled.set(true);\n            }\n\n            @Deprecated\n            @Override\n            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n                if (done) {\n                    return null;\n                }\n                done = true;\n                return buffer.retainedDuplicate();\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        // Write 3 messages and close channel before flushing\n        ChannelFuture r1 = ch.write(new ChunkedFile(TMP));\n        ChannelFuture r2 = ch.write(new ChunkedNioFile(TMP));\n        ch.write(notifiableInput);\n\n        // Should be `false` as we do not expect any messages to be written\n        assertFalse(ch.finish());\n\n        assertFalse(r1.isSuccess());\n        assertFalse(r2.isSuccess());\n        assertTrue(closeWasCalled.get());\n    }\n\n    // See https://github.com/netty/netty/issues/8700.\n    @Test\n    public void testStopConsumingChunksWhenFailed() {\n        final ByteBuf buffer = Unpooled.copiedBuffer(\"Test\", CharsetUtil.ISO_8859_1);\n        final AtomicInteger chunks = new AtomicInteger(0);\n\n        ChunkedInput<ByteBuf> nonClosableInput = new ChunkedInput<ByteBuf>() {\n            @Override\n            public boolean isEndOfInput() throws Exception {\n                return chunks.get() >= 5;\n            }\n\n            @Override\n            public void close() throws Exception {\n                // no-op\n            }\n\n            @Deprecated\n            @Override\n            public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n                return readChunk(ctx.alloc());\n            }\n\n            @Override\n            public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n                chunks.incrementAndGet();\n                return buffer.retainedDuplicate();\n            }\n\n            @Override\n            public long length() {\n                return -1;\n            }\n\n            @Override\n            public long progress() {\n                return 1;\n            }\n        };\n\n        ChannelOutboundHandlerAdapter noOpWrites = new ChannelOutboundHandlerAdapter() {\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                ReferenceCountUtil.release(msg);\n                promise.tryFailure(new RuntimeException());\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(noOpWrites, new ChunkedWriteHandler());\n        ch.writeAndFlush(nonClosableInput).awaitUninterruptibly();\n        // Should be `false` as we do not expect any messages to be written\n        assertFalse(ch.finish());\n        buffer.release();\n\n        // We should expect only single chunked being read from the input.\n        // It's possible to get a race condition here between resolving a promise and\n        // allocating a new chunk, but should be fine when working with embedded channels.\n        assertEquals(1, chunks.get());\n    }\n\n    @Test\n    public void testCloseSuccessfulChunkedInput() {\n        int chunks = 10;\n        TestChunkedInput input = new TestChunkedInput(chunks);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        assertTrue(ch.writeOutbound(input));\n\n        for (int i = 0; i < chunks; i++) {\n            ByteBuf buf = ch.readOutbound();\n            assertEquals(i, buf.readInt());\n            buf.release();\n        }\n\n        assertTrue(input.isClosed());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testCloseFailedChunkedInput() {\n        Exception error = new Exception(\"Unable to produce a chunk\");\n        ThrowingChunkedInput input = new ThrowingChunkedInput(error);\n\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        try {\n            ch.writeOutbound(input);\n            fail(\"Exception expected\");\n        } catch (Exception e) {\n            assertEquals(error, e);\n        }\n\n        assertTrue(input.isClosed());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterSuccessfulChunkedInputClosed() throws Exception {\n        final TestChunkedInput input = new TestChunkedInput(2);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertTrue(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertTrue(ch.finishAndReleaseAll());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterFailedChunkedInputClosed() throws Exception {\n        final ThrowingChunkedInput input = new ThrowingChunkedInput(new RuntimeException());\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertFalse(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterChannelClosedAndInputFullyConsumed() throws Exception {\n        // use empty input which has endOfInput = true\n        final TestChunkedInput input = new TestChunkedInput(0);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.close(); // close channel to make handler discard the input on subsequent flush\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertTrue(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertFalse(ch.finish());\n    }\n\n    @Test\n    public void testWriteListenerInvokedAfterChannelClosedAndInputNotFullyConsumed() throws Exception {\n        // use non-empty input which has endOfInput = false\n        final TestChunkedInput input = new TestChunkedInput(42);\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        final AtomicBoolean inputClosedWhenListenerInvoked = new AtomicBoolean();\n        final CountDownLatch listenerInvoked = new CountDownLatch(1);\n\n        ChannelFuture writeFuture = ch.write(input);\n        writeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                inputClosedWhenListenerInvoked.set(input.isClosed());\n                listenerInvoked.countDown();\n            }\n        });\n        ch.close(); // close channel to make handler discard the input on subsequent flush\n        ch.flush();\n\n        assertTrue(listenerInvoked.await(10, SECONDS));\n        assertFalse(writeFuture.isSuccess());\n        assertTrue(inputClosedWhenListenerInvoked.get());\n        assertFalse(ch.finish());\n    }\n\n    private static void check(Object... inputs) {\n        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());\n\n        for (Object input: inputs) {\n            ch.writeOutbound(input);\n        }\n\n        assertTrue(ch.finish());\n\n        int i = 0;\n        int read = 0;\n        for (;;) {\n            ByteBuf buffer = ch.readOutbound();\n            if (buffer == null) {\n                break;\n            }\n            while (buffer.isReadable()) {\n                assertEquals(BYTES[i++], buffer.readByte());\n                read++;\n                if (i == BYTES.length) {\n                    i = 0;\n                }\n            }\n            buffer.release();\n        }\n\n        assertEquals(BYTES.length * inputs.length, read);\n    }\n\n    private static void checkFirstFailed(Object input) {\n        ChannelOutboundHandlerAdapter noOpWrites = new ChannelOutboundHandlerAdapter() {\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                ReferenceCountUtil.release(msg);\n                promise.tryFailure(new RuntimeException());\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(noOpWrites, new ChunkedWriteHandler());\n        ChannelFuture r = ch.writeAndFlush(input);\n\n        // Should be `false` as we do not expect any messages to be written\n        assertFalse(ch.finish());\n        assertTrue(r.cause() instanceof RuntimeException);\n    }\n\n    private static void checkSkipFailed(Object input1, Object input2) {\n        ChannelOutboundHandlerAdapter failFirst = new ChannelOutboundHandlerAdapter() {\n            private boolean alreadyFailed;\n\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n                if (alreadyFailed) {\n                    ctx.write(msg, promise);\n                } else {\n                    this.alreadyFailed = true;\n                    ReferenceCountUtil.release(msg);\n                    promise.tryFailure(new RuntimeException());\n                }\n            }\n        };\n\n        EmbeddedChannel ch = new EmbeddedChannel(failFirst, new ChunkedWriteHandler());\n        ChannelFuture r1 = ch.write(input1);\n        ChannelFuture r2 = ch.writeAndFlush(input2).awaitUninterruptibly();\n        assertTrue(ch.finish());\n\n        assertTrue(r1.cause() instanceof RuntimeException);\n        assertTrue(r2.isSuccess());\n\n        // note, that after we've \"skipped\" the first write,\n        // we expect to see the second message, chunk by chunk\n        int i = 0;\n        int read = 0;\n        for (;;) {\n            ByteBuf buffer = ch.readOutbound();\n            if (buffer == null) {\n                break;\n            }\n            while (buffer.isReadable()) {\n                assertEquals(BYTES[i++], buffer.readByte());\n                read++;\n                if (i == BYTES.length) {\n                    i = 0;\n                }\n            }\n            buffer.release();\n        }\n\n        assertEquals(BYTES.length, read);\n    }\n\n    private static final class TestChunkedInput implements ChunkedInput<ByteBuf> {\n        private final int chunksToProduce;\n\n        private int chunksProduced;\n        private volatile boolean closed;\n\n        TestChunkedInput(int chunksToProduce) {\n            this.chunksToProduce = chunksToProduce;\n        }\n\n        @Override\n        public boolean isEndOfInput() {\n            return chunksProduced >= chunksToProduce;\n        }\n\n        @Override\n        public void close() {\n            closed = true;\n        }\n\n        @Override\n        public ByteBuf readChunk(ChannelHandlerContext ctx) {\n            return readChunk(ctx.alloc());\n        }\n\n        @Override\n        public ByteBuf readChunk(ByteBufAllocator allocator) {\n            ByteBuf buf = allocator.buffer();\n            buf.writeInt(chunksProduced);\n            chunksProduced++;\n            return buf;\n        }\n\n        @Override\n        public long length() {\n            return chunksToProduce;\n        }\n\n        @Override\n        public long progress() {\n            return chunksProduced;\n        }\n\n        boolean isClosed() {\n            return closed;\n        }\n    }\n\n    private static final class ThrowingChunkedInput implements ChunkedInput<ByteBuf> {\n        private final Exception error;\n\n        private volatile boolean closed;\n\n        ThrowingChunkedInput(Exception error) {\n            this.error = error;\n        }\n\n        @Override\n        public boolean isEndOfInput() {\n            return false;\n        }\n\n        @Override\n        public void close() {\n            closed = true;\n        }\n\n        @Override\n        public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {\n            return readChunk(ctx.alloc());\n        }\n\n        @Override\n        public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {\n            throw error;\n        }\n\n        @Override\n        public long length() {\n            return -1;\n        }\n\n        @Override\n        public long progress() {\n            return -1;\n        }\n\n        boolean isClosed() {\n            return closed;\n        }\n    }\n}\n", "target": 1}
{"idx": 940, "func": "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\n\npackage org.opencastproject.mediapackage.identifier;\n\nimport java.util.regex.Pattern;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlType;\nimport javax.xml.bind.annotation.XmlValue;\n\n/**\n * Simple and straightforward implementation of the {@link Id} interface.\n */\n@XmlType\n@XmlAccessorType(XmlAccessType.NONE)\npublic class IdImpl implements Id {\n\n  private static final Pattern pattern = Pattern.compile(\"[\\\\w-_.:;()]+\");\n\n  /** The identifier */\n  @XmlValue\n  protected String id = null;\n\n  /**\n   * Needed for JAXB serialization\n   */\n  public IdImpl() {\n  }\n\n  /**\n   * Creates a new identifier.\n   *\n   * @param id\n   *          the identifier\n   */\n  public IdImpl(final String id) {\n    if (!pattern.matcher(id).matches()) {\n      throw new IllegalArgumentException(\"Id must match \" + pattern);\n    }\n    this.id = id;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.mediapackage.identifier.Id#compact()\n   */\n  public String compact() {\n    return toString();\n  }\n\n  @Override\n  public String toString() {\n    return id;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see java.lang.Object#equals(java.lang.Object)\n   */\n  @Override\n  public boolean equals(Object o) {\n    if (o instanceof IdImpl) {\n      IdImpl other = (IdImpl) o;\n      return id != null && other.id != null && id.equals(other.id);\n    }\n    return false;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see java.lang.Object#hashCode()\n   */\n  @Override\n  public int hashCode() {\n    return id.hashCode();\n  }\n}\n", "target": 0}
{"idx": 941, "func": "package com.softwaremill.session.javadsl;\n\nimport akka.http.javadsl.model.FormData;\nimport akka.http.javadsl.model.HttpRequest;\nimport akka.http.javadsl.model.HttpResponse;\nimport akka.http.javadsl.model.StatusCodes;\nimport akka.http.javadsl.model.headers.Cookie;\nimport akka.http.javadsl.model.headers.HttpCookie;\nimport akka.http.javadsl.model.headers.RawHeader;\nimport akka.http.javadsl.server.Route;\nimport akka.http.javadsl.testkit.TestRouteResult;\nimport akka.japi.Pair;\nimport com.softwaremill.session.CsrfCheckMode;\nimport com.softwaremill.session.SessionContinuity;\nimport com.softwaremill.session.SetSessionTransport;\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class CsrfDirectivesTest extends HttpSessionAwareDirectivesTest {\n\n    protected Route buildRoute(HttpSessionAwareDirectives<String> testDirectives, SessionContinuity<String> oneOff, SessionContinuity<String> refreshable, SetSessionTransport sessionTransport, CsrfCheckMode<String> csrfCheckMode) {\n        return route(\n            testDirectives.randomTokenCsrfProtection(csrfCheckMode, () ->\n                route(\n                    get(() ->\n                        path(\"site\", () ->\n                            complete(\"ok\")\n                        )\n                    ),\n                    post(() ->\n                        route(\n                            path(\"login\", () ->\n                                testDirectives.setNewCsrfToken(csrfCheckMode, () ->\n                                    complete(\"ok\"))),\n                            path(\"transfer_money\", () ->\n                                complete(\"ok\")\n                            )\n                        )\n                    )\n                )\n            )\n        );\n\n    }\n\n    @Test\n    public void shouldSetTheCsrfCookieOnTheFirstGetRequestOnly() {\n        // given\n        final Route route = createCsrfRouteWithCheckHeaderMode();\n\n        // when\n        TestRouteResult testRouteResult = testRoute(route)\n            .run(HttpRequest.GET(\"/site\"));\n\n        // then\n        testRouteResult\n            .assertStatusCode(StatusCodes.OK)\n            .assertEntity(\"ok\");\n\n        // and\n        HttpResponse response = testRouteResult.response();\n        HttpCookie csrfCookie = getCsrfTokenCookieValues(response);\n        Assert.assertNotNull(csrfCookie.value());\n\n        /* second request */\n        // when\n        TestRouteResult testRouteResult2 = testRoute(route)\n            .run(HttpRequest.GET(\"/site\")\n                .addHeader(Cookie.create(csrfCookieName, csrfCookie.value()))\n            );\n\n        // then\n        testRouteResult2\n            .assertStatusCode(StatusCodes.OK)\n            .assertEntity(\"ok\");\n\n        // and\n        HttpResponse response2 = testRouteResult2.response();\n        HttpCookie cookieValues2 = getCsrfTokenCookieValues(response2);\n        Assert.assertNull(cookieValues2);\n\n    }\n\n    @Test\n    public void shouldRejectRequestsIfTheCsrfCookieDoesNotMatchTheHeaderValue() {\n        // given\n        final Route route = createCsrfRouteWithCheckHeaderMode();\n\n        // when\n        TestRouteResult testRouteResult = testRoute(route)\n            .run(HttpRequest.GET(\"/site\"));\n\n        // then\n        testRouteResult\n            .assertStatusCode(StatusCodes.OK);\n\n        // and\n        HttpCookie csrfCookie = getCsrfTokenCookieValues(testRouteResult.response());\n\n        /* second request */\n        // when\n        TestRouteResult testRouteResult2 = testRoute(route)\n            .run(HttpRequest.POST(\"/transfer_money\")\n                .addHeader(Cookie.create(csrfCookieName, csrfCookie.value()))\n                .addHeader(RawHeader.create(csrfSubmittedName, \"something else\"))\n            );\n\n        // then\n        testRouteResult2\n            .assertStatusCode(StatusCodes.FORBIDDEN);\n    }\n\n    @Test\n    public void shouldRejectRequestsIfTheCsrfCookieIsNotSet() {\n        // given\n        final Route route = createCsrfRouteWithCheckHeaderMode();\n\n        // when\n        TestRouteResult testRouteResult = testRoute(route)\n            .run(HttpRequest.GET(\"/site\"));\n\n        // then\n        testRouteResult\n            .assertStatusCode(StatusCodes.OK);\n\n        /* second request */\n        // when\n        TestRouteResult testRouteResult2 = testRoute(route)\n            .run(HttpRequest.POST(\"/transfer_money\"));\n\n        // then\n        testRouteResult2\n            .assertStatusCode(StatusCodes.FORBIDDEN);\n\n\n    }\n\n    @Test\n    public void shouldAcceptRequestsIfTheCsrfCookieMatchesTheHeaderValue() {\n        // given\n        final Route route = createCsrfRouteWithCheckHeaderMode();\n\n        // when\n        TestRouteResult testRouteResult = testRoute(route)\n            .run(HttpRequest.GET(\"/site\"));\n\n        // then\n        testRouteResult\n            .assertStatusCode(StatusCodes.OK);\n\n        // and\n        HttpCookie csrfCookie = getCsrfTokenCookieValues(testRouteResult.response());\n\n        /* second request */\n        // when\n        TestRouteResult testRouteResult2 = testRoute(route)\n            .run(HttpRequest.POST(\"/transfer_money\")\n                .addHeader(Cookie.create(csrfCookieName, csrfCookie.value()))\n                .addHeader(RawHeader.create(csrfSubmittedName, csrfCookie.value()))\n            );\n\n        // then\n        testRouteResult2\n            .assertStatusCode(StatusCodes.OK)\n            .assertEntity(\"ok\");\n\n    }\n\n    @Test\n    public void shouldAcceptRequestsIfTheCsrfCookieMatchesTheFormFieldValue() {\n        // given\n        final Route route = createCsrfRouteWithCheckHeaderAndFormMode();\n\n        // when\n        TestRouteResult testRouteResult = testRoute(route)\n            .run(HttpRequest.GET(\"/site\"));\n\n        // then\n        testRouteResult\n            .assertStatusCode(StatusCodes.OK);\n\n        // and\n        HttpCookie csrfCookie = getCsrfTokenCookieValues(testRouteResult.response());\n\n        /* second request */\n        // when\n        final FormData formData = FormData.create(\n            Pair.create(csrfSubmittedName, csrfCookie.value())\n        );\n        TestRouteResult testRouteResult2 = testRoute(route)\n            .run(HttpRequest.POST(\"/transfer_money\").withEntity(formData.toEntity())\n                .addHeader(Cookie.create(csrfCookieName, csrfCookie.value()))\n            );\n\n        // then\n        testRouteResult2\n            .assertStatusCode(StatusCodes.OK)\n            .assertEntity(\"ok\");\n    }\n\n    @Test\n    public void shouldSetANewCsrfCookieWhenRequested() {\n        // given\n        final Route route = createCsrfRouteWithCheckHeaderMode();\n\n        // when\n        TestRouteResult testRouteResult = testRoute(route)\n            .run(HttpRequest.GET(\"/site\"));\n\n        // then\n        testRouteResult\n            .assertStatusCode(StatusCodes.OK);\n\n        // and\n        HttpCookie csrfCookie = getCsrfTokenCookieValues(testRouteResult.response());\n\n        /* second request */\n        // when\n        TestRouteResult testRouteResult2 = testRoute(route)\n            .run(HttpRequest.POST(\"/login\")\n                .addHeader(Cookie.create(csrfCookieName, csrfCookie.value()))\n                .addHeader(RawHeader.create(csrfSubmittedName, csrfCookie.value()))\n            );\n\n        // then\n        testRouteResult2\n            .assertStatusCode(StatusCodes.OK)\n            .assertEntity(\"ok\");\n\n        // and\n        HttpCookie csrfCookie2 = getCsrfTokenCookieValues(testRouteResult2.response());\n        Assert.assertNotEquals(csrfCookie.value(), csrfCookie2.value());\n\n    }\n\n}\n", "target": 1}
{"idx": 942, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.util;\n\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.MarshallingContext;\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.trilead.ssh2.crypto.Base64;\nimport jenkins.model.Jenkins;\nimport hudson.Util;\nimport jenkins.security.CryptoConfidentialKey;\nimport org.kohsuke.stapler.Stapler;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.Cipher;\nimport java.io.Serializable;\nimport java.io.UnsupportedEncodingException;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\n\n/**\n * Glorified {@link String} that uses encryption in the persisted form, to avoid accidental exposure of a secret.\n *\n * <p>\n * This is not meant as a protection against code running in the same VM, nor against an attacker\n * who has local file system access on Jenkins master.\n *\n * <p>\n * {@link Secret}s can correctly read-in plain text password, so this allows the existing\n * String field to be updated to {@link Secret}.\n *\n * @author Kohsuke Kawaguchi\n */\npublic final class Secret implements Serializable {\n    /**\n     * Unencrypted secret text.\n     */\n    private final String value;\n\n    private Secret(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Obtains the secret in a plain text.\n     *\n     * @see #getEncryptedValue()\n     * @deprecated as of 1.356\n     *      Use {@link #toString(Secret)} to avoid NPE in case Secret is null.\n     *      Or if you really know what you are doing, use the {@link #getPlainText()} method.\n     */\n    @Override\n    public String toString() {\n        return value;\n    }\n\n    /**\n     * Obtains the plain text password.\n     * Before using this method, ask yourself if you'd be better off using {@link Secret#toString(Secret)}\n     * to avoid NPE.\n     */\n    public String getPlainText() {\n        return value;\n    }\n\n    @Override\n    public boolean equals(Object that) {\n        return that instanceof Secret && value.equals(((Secret)that).value);\n    }\n\n    @Override\n    public int hashCode() {\n        return value.hashCode();\n    }\n\n    /**\n     * Turns {@link Jenkins#getSecretKey()} into an AES key.\n     *\n     * @deprecated\n     * This is no longer the key we use to encrypt new information, but we still need this\n     * to be able to decrypt what's already persisted.\n     */\n    /*package*/ static SecretKey getLegacyKey() throws UnsupportedEncodingException, GeneralSecurityException {\n        String secret = SECRET;\n        if(secret==null)    return Jenkins.getInstance().getSecretKeyAsAES128();\n        return Util.toAes128Key(secret);\n    }\n\n    /**\n     * Encrypts {@link #value} and returns it in an encoded printable form.\n     *\n     * @see #toString() \n     */\n    public String getEncryptedValue() {\n        try {\n            Cipher cipher = KEY.encrypt();\n            // add the magic suffix which works like a check sum.\n            return new String(Base64.encode(cipher.doFinal((value+MAGIC).getBytes(\"UTF-8\"))));\n        } catch (GeneralSecurityException e) {\n            throw new Error(e); // impossible\n        } catch (UnsupportedEncodingException e) {\n            throw new Error(e); // impossible\n        }\n    }\n\n    /**\n     * Reverse operation of {@link #getEncryptedValue()}. Returns null\n     * if the given cipher text was invalid.\n     */\n    public static Secret decrypt(String data) {\n        if(data==null)      return null;\n        try {\n            byte[] in = Base64.decode(data.toCharArray());\n            Secret s = tryDecrypt(KEY.decrypt(), in);\n            if (s!=null)    return s;\n\n            // try our historical key for backward compatibility\n            Cipher cipher = getCipher(\"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, getLegacyKey());\n            return tryDecrypt(cipher, in);\n        } catch (GeneralSecurityException e) {\n            return null;\n        } catch (UnsupportedEncodingException e) {\n            throw new Error(e); // impossible\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    private static Secret tryDecrypt(Cipher cipher, byte[] in) throws UnsupportedEncodingException {\n        try {\n            String plainText = new String(cipher.doFinal(in), \"UTF-8\");\n            if(plainText.endsWith(MAGIC))\n                return new Secret(plainText.substring(0,plainText.length()-MAGIC.length()));\n            return null;\n        } catch (GeneralSecurityException e) {\n            return null;\n        }\n    }\n\n    /**\n     * Workaround for JENKINS-6459 / http://java.net/jira/browse/GLASSFISH-11862\n     * This method uses specific provider selected via hudson.util.Secret.provider system property\n     * to provide a workaround for the above bug where default provide gives an unusable instance.\n     * (Glassfish Enterprise users should set value of this property to \"SunJCE\")\n     */\n    public static Cipher getCipher(String algorithm) throws GeneralSecurityException {\n        return PROVIDER != null ? Cipher.getInstance(algorithm, PROVIDER)\n                                : Cipher.getInstance(algorithm);\n    }\n\n    /**\n     * Attempts to treat the given string first as a cipher text, and if it doesn't work,\n     * treat the given string as the unencrypted secret value.\n     *\n     * <p>\n     * Useful for recovering a value from a form field.\n     *\n     * @return never null\n     */\n    public static Secret fromString(String data) {\n        data = Util.fixNull(data);\n        Secret s = decrypt(data);\n        if(s==null) s=new Secret(data);\n        return s;\n    }\n\n    /**\n     * Works just like {@link Secret#toString()} but avoids NPE when the secret is null.\n     * To be consistent with {@link #fromString(String)}, this method doesn't distinguish\n     * empty password and null password.\n     */\n    public static String toString(Secret s) {\n        return s==null ? \"\" : s.value;\n    }\n\n    public static final class ConverterImpl implements Converter {\n        public ConverterImpl() {\n        }\n\n        public boolean canConvert(Class type) {\n            return type==Secret.class;\n        }\n\n        public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {\n            Secret src = (Secret) source;\n            writer.setValue(src.getEncryptedValue());\n        }\n\n        public Object unmarshal(HierarchicalStreamReader reader, final UnmarshallingContext context) {\n            return fromString(reader.getValue());\n        }\n    }\n\n    private static final String MAGIC = \"::::MAGIC::::\";\n\n    /**\n     * Workaround for JENKINS-6459 / http://java.net/jira/browse/GLASSFISH-11862\n     * @see #getCipher(String)\n     */\n    private static final String PROVIDER = System.getProperty(Secret.class.getName()+\".provider\");\n\n    /**\n     * For testing only. Override the secret key so that we can test this class without {@link Jenkins}.\n     */\n    /*package*/ static String SECRET = null;\n\n    /**\n     * The key that encrypts the data on disk.\n     */\n    private static final CryptoConfidentialKey KEY = new CryptoConfidentialKey(Secret.class.getName());\n\n    private static final long serialVersionUID = 1L;\n\n    static {\n        Stapler.CONVERT_UTILS.register(new org.apache.commons.beanutils.Converter() {\n            public Secret convert(Class type, Object value) {\n                return Secret.fromString(value.toString());\n            }\n        }, Secret.class);\n    }\n}\n", "target": 1}
{"idx": 943, "func": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.activemq.broker;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.net.SocketException;\nimport java.net.URI;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nimport javax.transaction.xa.XAResource;\n\nimport org.apache.activemq.advisory.AdvisorySupport;\nimport org.apache.activemq.broker.region.ConnectionStatistics;\nimport org.apache.activemq.broker.region.RegionBroker;\nimport org.apache.activemq.command.ActiveMQDestination;\nimport org.apache.activemq.command.BrokerInfo;\nimport org.apache.activemq.command.Command;\nimport org.apache.activemq.command.CommandTypes;\nimport org.apache.activemq.command.ConnectionControl;\nimport org.apache.activemq.command.ConnectionError;\nimport org.apache.activemq.command.ConnectionId;\nimport org.apache.activemq.command.ConnectionInfo;\nimport org.apache.activemq.command.ConsumerControl;\nimport org.apache.activemq.command.ConsumerId;\nimport org.apache.activemq.command.ConsumerInfo;\nimport org.apache.activemq.command.ControlCommand;\nimport org.apache.activemq.command.DataArrayResponse;\nimport org.apache.activemq.command.DestinationInfo;\nimport org.apache.activemq.command.ExceptionResponse;\nimport org.apache.activemq.command.FlushCommand;\nimport org.apache.activemq.command.IntegerResponse;\nimport org.apache.activemq.command.KeepAliveInfo;\nimport org.apache.activemq.command.Message;\nimport org.apache.activemq.command.MessageAck;\nimport org.apache.activemq.command.MessageDispatch;\nimport org.apache.activemq.command.MessageDispatchNotification;\nimport org.apache.activemq.command.MessagePull;\nimport org.apache.activemq.command.ProducerAck;\nimport org.apache.activemq.command.ProducerId;\nimport org.apache.activemq.command.ProducerInfo;\nimport org.apache.activemq.command.RemoveSubscriptionInfo;\nimport org.apache.activemq.command.Response;\nimport org.apache.activemq.command.SessionId;\nimport org.apache.activemq.command.SessionInfo;\nimport org.apache.activemq.command.ShutdownInfo;\nimport org.apache.activemq.command.TransactionId;\nimport org.apache.activemq.command.TransactionInfo;\nimport org.apache.activemq.command.WireFormatInfo;\nimport org.apache.activemq.network.DemandForwardingBridge;\nimport org.apache.activemq.network.MBeanNetworkListener;\nimport org.apache.activemq.network.NetworkBridgeConfiguration;\nimport org.apache.activemq.network.NetworkBridgeFactory;\nimport org.apache.activemq.security.MessageAuthorizationPolicy;\nimport org.apache.activemq.state.CommandVisitor;\nimport org.apache.activemq.state.ConnectionState;\nimport org.apache.activemq.state.ConsumerState;\nimport org.apache.activemq.state.ProducerState;\nimport org.apache.activemq.state.SessionState;\nimport org.apache.activemq.state.TransactionState;\nimport org.apache.activemq.thread.Task;\nimport org.apache.activemq.thread.TaskRunner;\nimport org.apache.activemq.thread.TaskRunnerFactory;\nimport org.apache.activemq.transaction.Transaction;\nimport org.apache.activemq.transport.DefaultTransportListener;\nimport org.apache.activemq.transport.ResponseCorrelator;\nimport org.apache.activemq.transport.TransmitCallback;\nimport org.apache.activemq.transport.Transport;\nimport org.apache.activemq.transport.TransportDisposedIOException;\nimport org.apache.activemq.util.IntrospectionSupport;\nimport org.apache.activemq.util.MarshallingSupport;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.MDC;\n\npublic class TransportConnection implements Connection, Task, CommandVisitor {\n    private static final Logger LOG = LoggerFactory.getLogger(TransportConnection.class);\n    private static final Logger TRANSPORTLOG = LoggerFactory.getLogger(TransportConnection.class.getName() + \".Transport\");\n    private static final Logger SERVICELOG = LoggerFactory.getLogger(TransportConnection.class.getName() + \".Service\");\n    // Keeps track of the broker and connector that created this connection.\n    protected final Broker broker;\n    protected final TransportConnector connector;\n    // Keeps track of the state of the connections.\n    // protected final ConcurrentHashMap localConnectionStates=new\n    // ConcurrentHashMap();\n    protected final Map<ConnectionId, ConnectionState> brokerConnectionStates;\n    // The broker and wireformat info that was exchanged.\n    protected BrokerInfo brokerInfo;\n    protected final List<Command> dispatchQueue = new LinkedList<Command>();\n    protected TaskRunner taskRunner;\n    protected final AtomicReference<IOException> transportException = new AtomicReference<IOException>();\n    protected AtomicBoolean dispatchStopped = new AtomicBoolean(false);\n    private final Transport transport;\n    private MessageAuthorizationPolicy messageAuthorizationPolicy;\n    private WireFormatInfo wireFormatInfo;\n    // Used to do async dispatch.. this should perhaps be pushed down into the\n    // transport layer..\n    private boolean inServiceException;\n    private final ConnectionStatistics statistics = new ConnectionStatistics();\n    private boolean manageable;\n    private boolean slow;\n    private boolean markedCandidate;\n    private boolean blockedCandidate;\n    private boolean blocked;\n    private boolean connected;\n    private boolean active;\n    private boolean starting;\n    private boolean pendingStop;\n    private long timeStamp;\n    private final AtomicBoolean stopping = new AtomicBoolean(false);\n    private final CountDownLatch stopped = new CountDownLatch(1);\n    private final AtomicBoolean asyncException = new AtomicBoolean(false);\n    private final Map<ProducerId, ProducerBrokerExchange> producerExchanges = new HashMap<ProducerId, ProducerBrokerExchange>();\n    private final Map<ConsumerId, ConsumerBrokerExchange> consumerExchanges = new HashMap<ConsumerId, ConsumerBrokerExchange>();\n    private final CountDownLatch dispatchStoppedLatch = new CountDownLatch(1);\n    private ConnectionContext context;\n    private boolean networkConnection;\n    private boolean faultTolerantConnection;\n    private final AtomicInteger protocolVersion = new AtomicInteger(CommandTypes.PROTOCOL_VERSION);\n    private DemandForwardingBridge duplexBridge;\n    private final TaskRunnerFactory taskRunnerFactory;\n    private final TaskRunnerFactory stopTaskRunnerFactory;\n    private TransportConnectionStateRegister connectionStateRegister = new SingleTransportConnectionStateRegister();\n    private final ReentrantReadWriteLock serviceLock = new ReentrantReadWriteLock();\n    private String duplexNetworkConnectorId;\n    private Throwable stopError = null;\n\n    /**\n     * @param taskRunnerFactory - can be null if you want direct dispatch to the transport\n     *                          else commands are sent async.\n     * @param stopTaskRunnerFactory - can <b>not</b> be null, used for stopping this connection.\n     */\n    public TransportConnection(TransportConnector connector, final Transport transport, Broker broker,\n                               TaskRunnerFactory taskRunnerFactory, TaskRunnerFactory stopTaskRunnerFactory) {\n        this.connector = connector;\n        this.broker = broker;\n        RegionBroker rb = (RegionBroker) broker.getAdaptor(RegionBroker.class);\n        brokerConnectionStates = rb.getConnectionStates();\n        if (connector != null) {\n            this.statistics.setParent(connector.getStatistics());\n            this.messageAuthorizationPolicy = connector.getMessageAuthorizationPolicy();\n        }\n        this.taskRunnerFactory = taskRunnerFactory;\n        this.stopTaskRunnerFactory = stopTaskRunnerFactory;\n        this.transport = transport;\n        final BrokerService brokerService = this.broker.getBrokerService();\n        if( this.transport instanceof BrokerServiceAware ) {\n            ((BrokerServiceAware)this.transport).setBrokerService(brokerService);\n        }\n        this.transport.setTransportListener(new DefaultTransportListener() {\n            @Override\n            public void onCommand(Object o) {\n                serviceLock.readLock().lock();\n                try {\n                    if (!(o instanceof Command)) {\n                        throw new RuntimeException(\"Protocol violation - Command corrupted: \" + o.toString());\n                    }\n                    Command command = (Command) o;\n                    if (!brokerService.isStopping()) {\n                        Response response = service(command);\n                        if (response != null && !brokerService.isStopping()) {\n                            dispatchSync(response);\n                        }\n                    } else {\n                        throw new BrokerStoppedException(\"Broker \" + brokerService + \" is being stopped\");\n                    }\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }\n\n            @Override\n            public void onException(IOException exception) {\n                serviceLock.readLock().lock();\n                try {\n                    serviceTransportException(exception);\n                } finally {\n                    serviceLock.readLock().unlock();\n                }\n            }\n        });\n        connected = true;\n    }\n\n    /**\n     * Returns the number of messages to be dispatched to this connection\n     *\n     * @return size of dispatch queue\n     */\n    @Override\n    public int getDispatchQueueSize() {\n        synchronized (dispatchQueue) {\n            return dispatchQueue.size();\n        }\n    }\n\n    public void serviceTransportException(IOException e) {\n        BrokerService bService = connector.getBrokerService();\n        if (bService.isShutdownOnSlaveFailure()) {\n            if (brokerInfo != null) {\n                if (brokerInfo.isSlaveBroker()) {\n                    LOG.error(\"Slave has exception: {} shutting down master now.\", e.getMessage(), e);\n                    try {\n                        doStop();\n                        bService.stop();\n                    } catch (Exception ex) {\n                        LOG.warn(\"Failed to stop the master\", ex);\n                    }\n                }\n            }\n        }\n        if (!stopping.get() && !pendingStop) {\n            transportException.set(e);\n            if (TRANSPORTLOG.isDebugEnabled()) {\n                TRANSPORTLOG.debug(this + \" failed: \" + e, e);\n            } else if (TRANSPORTLOG.isWarnEnabled() && !expected(e)) {\n                TRANSPORTLOG.warn(this + \" failed: \" + e);\n            }\n            stopAsync();\n        }\n    }\n\n    private boolean expected(IOException e) {\n        return isStomp() && ((e instanceof SocketException && e.getMessage().indexOf(\"reset\") != -1) || e instanceof EOFException);\n    }\n\n    private boolean isStomp() {\n        URI uri = connector.getUri();\n        return uri != null && uri.getScheme() != null && uri.getScheme().indexOf(\"stomp\") != -1;\n    }\n\n    /**\n     * Calls the serviceException method in an async thread. Since handling a\n     * service exception closes a socket, we should not tie up broker threads\n     * since client sockets may hang or cause deadlocks.\n     */\n    @Override\n    public void serviceExceptionAsync(final IOException e) {\n        if (asyncException.compareAndSet(false, true)) {\n            new Thread(\"Async Exception Handler\") {\n                @Override\n                public void run() {\n                    serviceException(e);\n                }\n            }.start();\n        }\n    }\n\n    /**\n     * Closes a clients connection due to a detected error. Errors are ignored\n     * if: the client is closing or broker is closing. Otherwise, the connection\n     * error transmitted to the client before stopping it's transport.\n     */\n    @Override\n    public void serviceException(Throwable e) {\n        // are we a transport exception such as not being able to dispatch\n        // synchronously to a transport\n        if (e instanceof IOException) {\n            serviceTransportException((IOException) e);\n        } else if (e.getClass() == BrokerStoppedException.class) {\n            // Handle the case where the broker is stopped\n            // But the client is still connected.\n            if (!stopping.get()) {\n                SERVICELOG.debug(\"Broker has been stopped.  Notifying client and closing his connection.\");\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                dispatchSync(ce);\n                // Record the error that caused the transport to stop\n                this.stopError = e;\n                // Wait a little bit to try to get the output buffer to flush\n                // the exception notification to the client.\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n                // Worst case is we just kill the connection before the\n                // notification gets to him.\n                stopAsync();\n            }\n        } else if (!stopping.get() && !inServiceException) {\n            inServiceException = true;\n            try {\n                SERVICELOG.warn(\"Async error occurred: \", e);\n                ConnectionError ce = new ConnectionError();\n                ce.setException(e);\n                if (pendingStop) {\n                    dispatchSync(ce);\n                } else {\n                    dispatchAsync(ce);\n                }\n            } finally {\n                inServiceException = false;\n            }\n        }\n    }\n\n    @Override\n    public Response service(Command command) {\n        MDC.put(\"activemq.connector\", connector.getUri().toString());\n        Response response = null;\n        boolean responseRequired = command.isResponseRequired();\n        int commandId = command.getCommandId();\n        try {\n            if (!pendingStop) {\n                response = command.visit(this);\n            } else {\n                response = new ExceptionResponse(this.stopError);\n            }\n        } catch (Throwable e) {\n            if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {\n                SERVICELOG.debug(\"Error occured while processing \" + (responseRequired ? \"sync\" : \"async\")\n                        + \" command: \" + command + \", exception: \" + e, e);\n            }\n\n            if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {\n                LOG.info(\"Suppressing reply to: \" + command + \" on: \" + e + \", cause: \" + e.getCause());\n                responseRequired = false;\n            }\n\n            if (responseRequired) {\n                if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {\n                    SERVICELOG.warn(\"Security Error occurred: {}\", e.getMessage());\n                }\n                response = new ExceptionResponse(e);\n            } else {\n                serviceException(e);\n            }\n        }\n        if (responseRequired) {\n            if (response == null) {\n                response = new Response();\n            }\n            response.setCorrelationId(commandId);\n        }\n        // The context may have been flagged so that the response is not\n        // sent.\n        if (context != null) {\n            if (context.isDontSendReponse()) {\n                context.setDontSendReponse(false);\n                response = null;\n            }\n            context = null;\n        }\n        MDC.remove(\"activemq.connector\");\n        return response;\n    }\n\n    @Override\n    public Response processKeepAlive(KeepAliveInfo info) throws Exception {\n        return null;\n    }\n\n    @Override\n    public Response processRemoveSubscription(RemoveSubscriptionInfo info) throws Exception {\n        broker.removeSubscription(lookupConnectionState(info.getConnectionId()).getContext(), info);\n        return null;\n    }\n\n    @Override\n    public Response processWireFormat(WireFormatInfo info) throws Exception {\n        wireFormatInfo = info;\n        protocolVersion.set(info.getVersion());\n        return null;\n    }\n\n    @Override\n    public Response processShutdown(ShutdownInfo info) throws Exception {\n        stopAsync();\n        return null;\n    }\n\n    @Override\n    public Response processFlush(FlushCommand command) throws Exception {\n        return null;\n    }\n\n    @Override\n    public Response processBeginTransaction(TransactionInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        context = null;\n        if (cs != null) {\n            context = cs.getContext();\n        }\n        if (cs == null) {\n            throw new NullPointerException(\"Context is null\");\n        }\n        // Avoid replaying dup commands\n        if (cs.getTransactionState(info.getTransactionId()) == null) {\n            cs.addTransactionState(info.getTransactionId());\n            broker.beginTransaction(context, info.getTransactionId());\n        }\n        return null;\n    }\n\n    @Override\n    public int getActiveTransactionCount() {\n        int rc = 0;\n        for (TransportConnectionState cs : connectionStateRegister.listConnectionStates()) {\n            Collection<TransactionState> transactions = cs.getTransactionStates();\n            for (TransactionState transaction : transactions) {\n                rc++;\n            }\n        }\n        return rc;\n    }\n\n    @Override\n    public Long getOldestActiveTransactionDuration() {\n        TransactionState oldestTX = null;\n        for (TransportConnectionState cs : connectionStateRegister.listConnectionStates()) {\n            Collection<TransactionState> transactions = cs.getTransactionStates();\n            for (TransactionState transaction : transactions) {\n                if( oldestTX ==null || oldestTX.getCreatedAt() < transaction.getCreatedAt() ) {\n                    oldestTX = transaction;\n                }\n            }\n        }\n        if( oldestTX == null ) {\n            return null;\n        }\n        return System.currentTimeMillis() - oldestTX.getCreatedAt();\n    }\n\n    @Override\n    public Response processEndTransaction(TransactionInfo info) throws Exception {\n        // No need to do anything. This packet is just sent by the client\n        // make sure he is synced with the server as commit command could\n        // come from a different connection.\n        return null;\n    }\n\n    @Override\n    public Response processPrepareTransaction(TransactionInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        context = null;\n        if (cs != null) {\n            context = cs.getContext();\n        }\n        if (cs == null) {\n            throw new NullPointerException(\"Context is null\");\n        }\n        TransactionState transactionState = cs.getTransactionState(info.getTransactionId());\n        if (transactionState == null) {\n            throw new IllegalStateException(\"Cannot prepare a transaction that had not been started or previously returned XA_RDONLY: \"\n                    + info.getTransactionId());\n        }\n        // Avoid dups.\n        if (!transactionState.isPrepared()) {\n            transactionState.setPrepared(true);\n            int result = broker.prepareTransaction(context, info.getTransactionId());\n            transactionState.setPreparedResult(result);\n            if (result == XAResource.XA_RDONLY) {\n                // we are done, no further rollback or commit from TM\n                cs.removeTransactionState(info.getTransactionId());\n            }\n            IntegerResponse response = new IntegerResponse(result);\n            return response;\n        } else {\n            IntegerResponse response = new IntegerResponse(transactionState.getPreparedResult());\n            return response;\n        }\n    }\n\n    @Override\n    public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        context = cs.getContext();\n        cs.removeTransactionState(info.getTransactionId());\n        broker.commitTransaction(context, info.getTransactionId(), true);\n        return null;\n    }\n\n    @Override\n    public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        context = cs.getContext();\n        cs.removeTransactionState(info.getTransactionId());\n        broker.commitTransaction(context, info.getTransactionId(), false);\n        return null;\n    }\n\n    @Override\n    public Response processRollbackTransaction(TransactionInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        context = cs.getContext();\n        cs.removeTransactionState(info.getTransactionId());\n        broker.rollbackTransaction(context, info.getTransactionId());\n        return null;\n    }\n\n    @Override\n    public Response processForgetTransaction(TransactionInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        context = cs.getContext();\n        broker.forgetTransaction(context, info.getTransactionId());\n        return null;\n    }\n\n    @Override\n    public Response processRecoverTransactions(TransactionInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        context = cs.getContext();\n        TransactionId[] preparedTransactions = broker.getPreparedTransactions(context);\n        return new DataArrayResponse(preparedTransactions);\n    }\n\n    @Override\n    public Response processMessage(Message messageSend) throws Exception {\n        ProducerId producerId = messageSend.getProducerId();\n        ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);\n        if (producerExchange.canDispatch(messageSend)) {\n            broker.send(producerExchange, messageSend);\n        }\n        return null;\n    }\n\n    @Override\n    public Response processMessageAck(MessageAck ack) throws Exception {\n        ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(ack.getConsumerId());\n        if (consumerExchange != null) {\n            broker.acknowledge(consumerExchange, ack);\n        } else if (ack.isInTransaction()) {\n            LOG.warn(\"no matching consumer, ignoring ack {}\", consumerExchange, ack);\n        }\n        return null;\n    }\n\n    @Override\n    public Response processMessagePull(MessagePull pull) throws Exception {\n        return broker.messagePull(lookupConnectionState(pull.getConsumerId()).getContext(), pull);\n    }\n\n    @Override\n    public Response processMessageDispatchNotification(MessageDispatchNotification notification) throws Exception {\n        broker.processDispatchNotification(notification);\n        return null;\n    }\n\n    @Override\n    public Response processAddDestination(DestinationInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        broker.addDestinationInfo(cs.getContext(), info);\n        if (info.getDestination().isTemporary()) {\n            cs.addTempDestination(info);\n        }\n        return null;\n    }\n\n    @Override\n    public Response processRemoveDestination(DestinationInfo info) throws Exception {\n        TransportConnectionState cs = lookupConnectionState(info.getConnectionId());\n        broker.removeDestinationInfo(cs.getContext(), info);\n        if (info.getDestination().isTemporary()) {\n            cs.removeTempDestination(info.getDestination());\n        }\n        return null;\n    }\n\n    @Override\n    public Response processAddProducer(ProducerInfo info) throws Exception {\n        SessionId sessionId = info.getProducerId().getParentId();\n        ConnectionId connectionId = sessionId.getParentId();\n        TransportConnectionState cs = lookupConnectionState(connectionId);\n        if (cs == null) {\n            throw new IllegalStateException(\"Cannot add a producer to a connection that had not been registered: \"\n                    + connectionId);\n        }\n        SessionState ss = cs.getSessionState(sessionId);\n        if (ss == null) {\n            throw new IllegalStateException(\"Cannot add a producer to a session that had not been registered: \"\n                    + sessionId);\n        }\n        // Avoid replaying dup commands\n        if (!ss.getProducerIds().contains(info.getProducerId())) {\n            ActiveMQDestination destination = info.getDestination();\n            if (destination != null && !AdvisorySupport.isAdvisoryTopic(destination)) {\n                if (getProducerCount(connectionId) >= connector.getMaximumProducersAllowedPerConnection()){\n                    throw new IllegalStateException(\"Can't add producer on connection \" + connectionId + \": at maximum limit: \" + connector.getMaximumProducersAllowedPerConnection());\n                }\n            }\n            broker.addProducer(cs.getContext(), info);\n            try {\n                ss.addProducer(info);\n            } catch (IllegalStateException e) {\n                broker.removeProducer(cs.getContext(), info);\n            }\n\n        }\n        return null;\n    }\n\n    @Override\n    public Response processRemoveProducer(ProducerId id) throws Exception {\n        SessionId sessionId = id.getParentId();\n        ConnectionId connectionId = sessionId.getParentId();\n        TransportConnectionState cs = lookupConnectionState(connectionId);\n        SessionState ss = cs.getSessionState(sessionId);\n        if (ss == null) {\n            throw new IllegalStateException(\"Cannot remove a producer from a session that had not been registered: \"\n                    + sessionId);\n        }\n        ProducerState ps = ss.removeProducer(id);\n        if (ps == null) {\n            throw new IllegalStateException(\"Cannot remove a producer that had not been registered: \" + id);\n        }\n        removeProducerBrokerExchange(id);\n        broker.removeProducer(cs.getContext(), ps.getInfo());\n        return null;\n    }\n\n    @Override\n    public Response processAddConsumer(ConsumerInfo info) throws Exception {\n        SessionId sessionId = info.getConsumerId().getParentId();\n        ConnectionId connectionId = sessionId.getParentId();\n        TransportConnectionState cs = lookupConnectionState(connectionId);\n        if (cs == null) {\n            throw new IllegalStateException(\"Cannot add a consumer to a connection that had not been registered: \"\n                    + connectionId);\n        }\n        SessionState ss = cs.getSessionState(sessionId);\n        if (ss == null) {\n            throw new IllegalStateException(broker.getBrokerName()\n                    + \" Cannot add a consumer to a session that had not been registered: \" + sessionId);\n        }\n        // Avoid replaying dup commands\n        if (!ss.getConsumerIds().contains(info.getConsumerId())) {\n            ActiveMQDestination destination = info.getDestination();\n            if (destination != null && !AdvisorySupport.isAdvisoryTopic(destination)) {\n                if (getConsumerCount(connectionId) >= connector.getMaximumConsumersAllowedPerConnection()){\n                    throw new IllegalStateException(\"Can't add consumer on connection \" + connectionId + \": at maximum limit: \" + connector.getMaximumConsumersAllowedPerConnection());\n                }\n            }\n\n            broker.addConsumer(cs.getContext(), info);\n            try {\n                ss.addConsumer(info);\n                addConsumerBrokerExchange(info.getConsumerId());\n            } catch (IllegalStateException e) {\n                broker.removeConsumer(cs.getContext(), info);\n            }\n\n        }\n        return null;\n    }\n\n    @Override\n    public Response processRemoveConsumer(ConsumerId id, long lastDeliveredSequenceId) throws Exception {\n        SessionId sessionId = id.getParentId();\n        ConnectionId connectionId = sessionId.getParentId();\n        TransportConnectionState cs = lookupConnectionState(connectionId);\n        if (cs == null) {\n            throw new IllegalStateException(\"Cannot remove a consumer from a connection that had not been registered: \"\n                    + connectionId);\n        }\n        SessionState ss = cs.getSessionState(sessionId);\n        if (ss == null) {\n            throw new IllegalStateException(\"Cannot remove a consumer from a session that had not been registered: \"\n                    + sessionId);\n        }\n        ConsumerState consumerState = ss.removeConsumer(id);\n        if (consumerState == null) {\n            throw new IllegalStateException(\"Cannot remove a consumer that had not been registered: \" + id);\n        }\n        ConsumerInfo info = consumerState.getInfo();\n        info.setLastDeliveredSequenceId(lastDeliveredSequenceId);\n        broker.removeConsumer(cs.getContext(), consumerState.getInfo());\n        removeConsumerBrokerExchange(id);\n        return null;\n    }\n\n    @Override\n    public Response processAddSession(SessionInfo info) throws Exception {\n        ConnectionId connectionId = info.getSessionId().getParentId();\n        TransportConnectionState cs = lookupConnectionState(connectionId);\n        // Avoid replaying dup commands\n        if (cs != null && !cs.getSessionIds().contains(info.getSessionId())) {\n            broker.addSession(cs.getContext(), info);\n            try {\n                cs.addSession(info);\n            } catch (IllegalStateException e) {\n                e.printStackTrace();\n                broker.removeSession(cs.getContext(), info);\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Response processRemoveSession(SessionId id, long lastDeliveredSequenceId) throws Exception {\n        ConnectionId connectionId = id.getParentId();\n        TransportConnectionState cs = lookupConnectionState(connectionId);\n        if (cs == null) {\n            throw new IllegalStateException(\"Cannot remove session from connection that had not been registered: \" + connectionId);\n        }\n        SessionState session = cs.getSessionState(id);\n        if (session == null) {\n            throw new IllegalStateException(\"Cannot remove session that had not been registered: \" + id);\n        }\n        // Don't let new consumers or producers get added while we are closing\n        // this down.\n        session.shutdown();\n        // Cascade the connection stop to the consumers and producers.\n        for (ConsumerId consumerId : session.getConsumerIds()) {\n            try {\n                processRemoveConsumer(consumerId, lastDeliveredSequenceId);\n            } catch (Throwable e) {\n                LOG.warn(\"Failed to remove consumer: {}\", consumerId, e);\n            }\n        }\n        for (ProducerId producerId : session.getProducerIds()) {\n            try {\n                processRemoveProducer(producerId);\n            } catch (Throwable e) {\n                LOG.warn(\"Failed to remove producer: {}\", producerId, e);\n            }\n        }\n        cs.removeSession(id);\n        broker.removeSession(cs.getContext(), session.getInfo());\n        return null;\n    }\n\n    @Override\n    public Response processAddConnection(ConnectionInfo info) throws Exception {\n        // Older clients should have been defaulting this field to true.. but\n        // they were not.\n        if (wireFormatInfo != null && wireFormatInfo.getVersion() <= 2) {\n            info.setClientMaster(true);\n        }\n        TransportConnectionState state;\n        // Make sure 2 concurrent connections by the same ID only generate 1\n        // TransportConnectionState object.\n        synchronized (brokerConnectionStates) {\n            state = (TransportConnectionState) brokerConnectionStates.get(info.getConnectionId());\n            if (state == null) {\n                state = new TransportConnectionState(info, this);\n                brokerConnectionStates.put(info.getConnectionId(), state);\n            }\n            state.incrementReference();\n        }\n        // If there are 2 concurrent connections for the same connection id,\n        // then last one in wins, we need to sync here\n        // to figure out the winner.\n        synchronized (state.getConnectionMutex()) {\n            if (state.getConnection() != this) {\n                LOG.debug(\"Killing previous stale connection: {}\", state.getConnection().getRemoteAddress());\n                state.getConnection().stop();\n                LOG.debug(\"Connection {} taking over previous connection: {}\", getRemoteAddress(), state.getConnection().getRemoteAddress());\n                state.setConnection(this);\n                state.reset(info);\n            }\n        }\n        registerConnectionState(info.getConnectionId(), state);\n        LOG.debug(\"Setting up new connection id: {}, address: {}, info: {}\", new Object[]{ info.getConnectionId(), getRemoteAddress(), info });\n        this.faultTolerantConnection = info.isFaultTolerant();\n        // Setup the context.\n        String clientId = info.getClientId();\n        context = new ConnectionContext();\n        context.setBroker(broker);\n        context.setClientId(clientId);\n        context.setClientMaster(info.isClientMaster());\n        context.setConnection(this);\n        context.setConnectionId(info.getConnectionId());\n        context.setConnector(connector);\n        context.setMessageAuthorizationPolicy(getMessageAuthorizationPolicy());\n        context.setNetworkConnection(networkConnection);\n        context.setFaultTolerant(faultTolerantConnection);\n        context.setTransactions(new ConcurrentHashMap<TransactionId, Transaction>());\n        context.setUserName(info.getUserName());\n        context.setWireFormatInfo(wireFormatInfo);\n        context.setReconnect(info.isFailoverReconnect());\n        this.manageable = info.isManageable();\n        context.setConnectionState(state);\n        state.setContext(context);\n        state.setConnection(this);\n        if (info.getClientIp() == null) {\n            info.setClientIp(getRemoteAddress());\n        }\n\n        try {\n            broker.addConnection(context, info);\n        } catch (Exception e) {\n            synchronized (brokerConnectionStates) {\n                brokerConnectionStates.remove(info.getConnectionId());\n            }\n            unregisterConnectionState(info.getConnectionId());\n            LOG.warn(\"Failed to add Connection {}\", info.getConnectionId(), e);\n            if (e instanceof SecurityException) {\n                // close this down - in case the peer of this transport doesn't play nice\n                delayedStop(2000, \"Failed with SecurityException: \" + e.getLocalizedMessage(), e);\n            }\n            throw e;\n        }\n        if (info.isManageable()) {\n            // send ConnectionCommand\n            ConnectionControl command = this.connector.getConnectionControl();\n            command.setFaultTolerant(broker.isFaultTolerantConfiguration());\n            if (info.isFailoverReconnect()) {\n                command.setRebalanceConnection(false);\n            }\n            dispatchAsync(command);\n        }\n        return null;\n    }\n\n    @Override\n    public synchronized Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId)\n            throws InterruptedException {\n        LOG.debug(\"remove connection id: {}\", id);\n        TransportConnectionState cs = lookupConnectionState(id);\n        if (cs != null) {\n            // Don't allow things to be added to the connection state while we\n            // are shutting down.\n            cs.shutdown();\n            // Cascade the connection stop to the sessions.\n            for (SessionId sessionId : cs.getSessionIds()) {\n                try {\n                    processRemoveSession(sessionId, lastDeliveredSequenceId);\n                } catch (Throwable e) {\n                    SERVICELOG.warn(\"Failed to remove session {}\", sessionId, e);\n                }\n            }\n            // Cascade the connection stop to temp destinations.\n            for (Iterator<DestinationInfo> iter = cs.getTempDestinations().iterator(); iter.hasNext(); ) {\n                DestinationInfo di = iter.next();\n                try {\n                    broker.removeDestination(cs.getContext(), di.getDestination(), 0);\n                } catch (Throwable e) {\n                    SERVICELOG.warn(\"Failed to remove tmp destination {}\", di.getDestination(), e);\n                }\n                iter.remove();\n            }\n            try {\n                broker.removeConnection(cs.getContext(), cs.getInfo(), null);\n            } catch (Throwable e) {\n                SERVICELOG.warn(\"Failed to remove connection {}\", cs.getInfo(), e);\n            }\n            TransportConnectionState state = unregisterConnectionState(id);\n            if (state != null) {\n                synchronized (brokerConnectionStates) {\n                    // If we are the last reference, we should remove the state\n                    // from the broker.\n                    if (state.decrementReference() == 0) {\n                        brokerConnectionStates.remove(id);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public Response processProducerAck(ProducerAck ack) throws Exception {\n        // A broker should not get ProducerAck messages.\n        return null;\n    }\n\n    @Override\n    public Connector getConnector() {\n        return connector;\n    }\n\n    @Override\n    public void dispatchSync(Command message) {\n        try {\n            processDispatch(message);\n        } catch (IOException e) {\n            serviceExceptionAsync(e);\n        }\n    }\n\n    @Override\n    public void dispatchAsync(Command message) {\n        if (!stopping.get()) {\n            if (taskRunner == null) {\n                dispatchSync(message);\n            } else {\n                synchronized (dispatchQueue) {\n                    dispatchQueue.add(message);\n                }\n                try {\n                    taskRunner.wakeup();\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        } else {\n            if (message.isMessageDispatch()) {\n                MessageDispatch md = (MessageDispatch) message;\n                TransmitCallback sub = md.getTransmitCallback();\n                broker.postProcessDispatch(md);\n                if (sub != null) {\n                    sub.onFailure();\n                }\n            }\n        }\n    }\n\n    protected void processDispatch(Command command) throws IOException {\n        MessageDispatch messageDispatch = (MessageDispatch) (command.isMessageDispatch() ? command : null);\n        try {\n            if (!stopping.get()) {\n                if (messageDispatch != null) {\n                    broker.preProcessDispatch(messageDispatch);\n                }\n                dispatch(command);\n            }\n        } catch (IOException e) {\n            if (messageDispatch != null) {\n                TransmitCallback sub = messageDispatch.getTransmitCallback();\n                broker.postProcessDispatch(messageDispatch);\n                if (sub != null) {\n                    sub.onFailure();\n                }\n                messageDispatch = null;\n                throw e;\n            }\n        } finally {\n            if (messageDispatch != null) {\n                TransmitCallback sub = messageDispatch.getTransmitCallback();\n                broker.postProcessDispatch(messageDispatch);\n                if (sub != null) {\n                    sub.onSuccess();\n                }\n            }\n        }\n    }\n\n    @Override\n    public boolean iterate() {\n        try {\n            if (pendingStop || stopping.get()) {\n                if (dispatchStopped.compareAndSet(false, true)) {\n                    if (transportException.get() == null) {\n                        try {\n                            dispatch(new ShutdownInfo());\n                        } catch (Throwable ignore) {\n                        }\n                    }\n                    dispatchStoppedLatch.countDown();\n                }\n                return false;\n            }\n            if (!dispatchStopped.get()) {\n                Command command = null;\n                synchronized (dispatchQueue) {\n                    if (dispatchQueue.isEmpty()) {\n                        return false;\n                    }\n                    command = dispatchQueue.remove(0);\n                }\n                processDispatch(command);\n                return true;\n            }\n            return false;\n        } catch (IOException e) {\n            if (dispatchStopped.compareAndSet(false, true)) {\n                dispatchStoppedLatch.countDown();\n            }\n            serviceExceptionAsync(e);\n            return false;\n        }\n    }\n\n    /**\n     * Returns the statistics for this connection\n     */\n    @Override\n    public ConnectionStatistics getStatistics() {\n        return statistics;\n    }\n\n    public MessageAuthorizationPolicy getMessageAuthorizationPolicy() {\n        return messageAuthorizationPolicy;\n    }\n\n    public void setMessageAuthorizationPolicy(MessageAuthorizationPolicy messageAuthorizationPolicy) {\n        this.messageAuthorizationPolicy = messageAuthorizationPolicy;\n    }\n\n    @Override\n    public boolean isManageable() {\n        return manageable;\n    }\n\n    @Override\n    public void start() throws Exception {\n        try {\n            synchronized (this) {\n                starting = true;\n                if (taskRunnerFactory != null) {\n                    taskRunner = taskRunnerFactory.createTaskRunner(this, \"ActiveMQ Connection Dispatcher: \"\n                            + getRemoteAddress());\n                } else {\n                    taskRunner = null;\n                }\n                transport.start();\n                active = true;\n                BrokerInfo info = connector.getBrokerInfo().copy();\n                if (connector.isUpdateClusterClients()) {\n                    info.setPeerBrokerInfos(this.broker.getPeerBrokerInfos());\n                } else {\n                    info.setPeerBrokerInfos(null);\n                }\n                dispatchAsync(info);\n\n                connector.onStarted(this);\n            }\n        } catch (Exception e) {\n            // Force clean up on an error starting up.\n            pendingStop = true;\n            throw e;\n        } finally {\n            // stop() can be called from within the above block,\n            // but we want to be sure start() completes before\n            // stop() runs, so queue the stop until right now:\n            setStarting(false);\n            if (isPendingStop()) {\n                LOG.debug(\"Calling the delayed stop() after start() {}\", this);\n                stop();\n            }\n        }\n    }\n\n    @Override\n    public void stop() throws Exception {\n        // do not stop task the task runner factories (taskRunnerFactory, stopTaskRunnerFactory)\n        // as their lifecycle is handled elsewhere\n\n        stopAsync();\n        while (!stopped.await(5, TimeUnit.SECONDS)) {\n            LOG.info(\"The connection to '{}' is taking a long time to shutdown.\", transport.getRemoteAddress());\n        }\n    }\n\n    public void delayedStop(final int waitTime, final String reason, Throwable cause) {\n        if (waitTime > 0) {\n            synchronized (this) {\n                pendingStop = true;\n                stopError = cause;\n            }\n            try {\n                stopTaskRunnerFactory.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        try {\n                            Thread.sleep(waitTime);\n                            stopAsync();\n                            LOG.info(\"Stopping {} because {}\", transport.getRemoteAddress(), reason);\n                        } catch (InterruptedException e) {\n                        }\n                    }\n                });\n            } catch (Throwable t) {\n                LOG.warn(\"Cannot create stopAsync. This exception will be ignored.\", t);\n            }\n        }\n    }\n\n    public void stopAsync() {\n        // If we're in the middle of starting then go no further... for now.\n        synchronized (this) {\n            pendingStop = true;\n            if (starting) {\n                LOG.debug(\"stopAsync() called in the middle of start(). Delaying till start completes..\");\n                return;\n            }\n        }\n        if (stopping.compareAndSet(false, true)) {\n            // Let all the connection contexts know we are shutting down\n            // so that in progress operations can notice and unblock.\n            List<TransportConnectionState> connectionStates = listConnectionStates();\n            for (TransportConnectionState cs : connectionStates) {\n                ConnectionContext connectionContext = cs.getContext();\n                if (connectionContext != null) {\n                    connectionContext.getStopping().set(true);\n                }\n            }\n            try {\n                stopTaskRunnerFactory.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        serviceLock.writeLock().lock();\n                        try {\n                            doStop();\n                        } catch (Throwable e) {\n                            LOG.debug(\"Error occurred while shutting down a connection {}\", this, e);\n                        } finally {\n                            stopped.countDown();\n                            serviceLock.writeLock().unlock();\n                        }\n                    }\n                });\n            } catch (Throwable t) {\n                LOG.warn(\"Cannot create async transport stopper thread. This exception is ignored. Not waiting for stop to complete\", t);\n                stopped.countDown();\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"Transport Connection to: \" + transport.getRemoteAddress();\n    }\n\n    protected void doStop() throws Exception {\n        LOG.debug(\"Stopping connection: {}\", transport.getRemoteAddress());\n        connector.onStopped(this);\n        try {\n            synchronized (this) {\n                if (duplexBridge != null) {\n                    duplexBridge.stop();\n                }\n            }\n        } catch (Exception ignore) {\n            LOG.trace(\"Exception caught stopping. This exception is ignored.\", ignore);\n        }\n        try {\n            transport.stop();\n            LOG.debug(\"Stopped transport: {}\", transport.getRemoteAddress());\n        } catch (Exception e) {\n            LOG.debug(\"Could not stop transport to {}. This exception is ignored.\", transport.getRemoteAddress(), e);\n        }\n        if (taskRunner != null) {\n            taskRunner.shutdown(1);\n            taskRunner = null;\n        }\n        active = false;\n        // Run the MessageDispatch callbacks so that message references get\n        // cleaned up.\n        synchronized (dispatchQueue) {\n            for (Iterator<Command> iter = dispatchQueue.iterator(); iter.hasNext(); ) {\n                Command command = iter.next();\n                if (command.isMessageDispatch()) {\n                    MessageDispatch md = (MessageDispatch) command;\n                    TransmitCallback sub = md.getTransmitCallback();\n                    broker.postProcessDispatch(md);\n                    if (sub != null) {\n                        sub.onFailure();\n                    }\n                }\n            }\n            dispatchQueue.clear();\n        }\n        //\n        // Remove all logical connection associated with this connection\n        // from the broker.\n        if (!broker.isStopped()) {\n            List<TransportConnectionState> connectionStates = listConnectionStates();\n            connectionStates = listConnectionStates();\n            for (TransportConnectionState cs : connectionStates) {\n                cs.getContext().getStopping().set(true);\n                try {\n                    LOG.debug(\"Cleaning up connection resources: {}\", getRemoteAddress());\n                    processRemoveConnection(cs.getInfo().getConnectionId(), 0l);\n                } catch (Throwable ignore) {\n                    ignore.printStackTrace();\n                }\n            }\n        }\n        LOG.debug(\"Connection Stopped: {}\", getRemoteAddress());\n    }\n\n    /**\n     * @return Returns the blockedCandidate.\n     */\n    public boolean isBlockedCandidate() {\n        return blockedCandidate;\n    }\n\n    /**\n     * @param blockedCandidate The blockedCandidate to set.\n     */\n    public void setBlockedCandidate(boolean blockedCandidate) {\n        this.blockedCandidate = blockedCandidate;\n    }\n\n    /**\n     * @return Returns the markedCandidate.\n     */\n    public boolean isMarkedCandidate() {\n        return markedCandidate;\n    }\n\n    /**\n     * @param markedCandidate The markedCandidate to set.\n     */\n    public void setMarkedCandidate(boolean markedCandidate) {\n        this.markedCandidate = markedCandidate;\n        if (!markedCandidate) {\n            timeStamp = 0;\n            blockedCandidate = false;\n        }\n    }\n\n    /**\n     * @param slow The slow to set.\n     */\n    public void setSlow(boolean slow) {\n        this.slow = slow;\n    }\n\n    /**\n     * @return true if the Connection is slow\n     */\n    @Override\n    public boolean isSlow() {\n        return slow;\n    }\n\n    /**\n     * @return true if the Connection is potentially blocked\n     */\n    public boolean isMarkedBlockedCandidate() {\n        return markedCandidate;\n    }\n\n    /**\n     * Mark the Connection, so we can deem if it's collectable on the next sweep\n     */\n    public void doMark() {\n        if (timeStamp == 0) {\n            timeStamp = System.currentTimeMillis();\n        }\n    }\n\n    /**\n     * @return if after being marked, the Connection is still writing\n     */\n    @Override\n    public boolean isBlocked() {\n        return blocked;\n    }\n\n    /**\n     * @return true if the Connection is connected\n     */\n    @Override\n    public boolean isConnected() {\n        return connected;\n    }\n\n    /**\n     * @param blocked The blocked to set.\n     */\n    public void setBlocked(boolean blocked) {\n        this.blocked = blocked;\n    }\n\n    /**\n     * @param connected The connected to set.\n     */\n    public void setConnected(boolean connected) {\n        this.connected = connected;\n    }\n\n    /**\n     * @return true if the Connection is active\n     */\n    @Override\n    public boolean isActive() {\n        return active;\n    }\n\n    /**\n     * @param active The active to set.\n     */\n    public void setActive(boolean active) {\n        this.active = active;\n    }\n\n    /**\n     * @return true if the Connection is starting\n     */\n    public synchronized boolean isStarting() {\n        return starting;\n    }\n\n    @Override\n    public synchronized boolean isNetworkConnection() {\n        return networkConnection;\n    }\n\n    @Override\n    public boolean isFaultTolerantConnection() {\n        return this.faultTolerantConnection;\n    }\n\n    protected synchronized void setStarting(boolean starting) {\n        this.starting = starting;\n    }\n\n    /**\n     * @return true if the Connection needs to stop\n     */\n    public synchronized boolean isPendingStop() {\n        return pendingStop;\n    }\n\n    protected synchronized void setPendingStop(boolean pendingStop) {\n        this.pendingStop = pendingStop;\n    }\n\n    @Override\n    public Response processBrokerInfo(BrokerInfo info) {\n        if (info.isSlaveBroker()) {\n            LOG.error(\" Slave Brokers are no longer supported - slave trying to attach is: {}\", info.getBrokerName());\n        } else if (info.isNetworkConnection() && info.isDuplexConnection()) {\n            // so this TransportConnection is the rear end of a network bridge\n            // We have been requested to create a two way pipe ...\n            try {\n                Properties properties = MarshallingSupport.stringToProperties(info.getNetworkProperties());\n                Map<String, String> props = createMap(properties);\n                NetworkBridgeConfiguration config = new NetworkBridgeConfiguration();\n                IntrospectionSupport.setProperties(config, props, \"\");\n                config.setBrokerName(broker.getBrokerName());\n\n                // check for existing duplex connection hanging about\n\n                // We first look if existing network connection already exists for the same broker Id and network connector name\n                // It's possible in case of brief network fault to have this transport connector side of the connection always active\n                // and the duplex network connector side wanting to open a new one\n                // In this case, the old connection must be broken\n                String duplexNetworkConnectorId = config.getName() + \"@\" + info.getBrokerId();\n                CopyOnWriteArrayList<TransportConnection> connections = this.connector.getConnections();\n                synchronized (connections) {\n                    for (Iterator<TransportConnection> iter = connections.iterator(); iter.hasNext(); ) {\n                        TransportConnection c = iter.next();\n                        if ((c != this) && (duplexNetworkConnectorId.equals(c.getDuplexNetworkConnectorId()))) {\n                            LOG.warn(\"Stopping an existing active duplex connection [{}] for network connector ({}).\", c, duplexNetworkConnectorId);\n                            c.stopAsync();\n                            // better to wait for a bit rather than get connection id already in use and failure to start new bridge\n                            c.getStopped().await(1, TimeUnit.SECONDS);\n                        }\n                    }\n                    setDuplexNetworkConnectorId(duplexNetworkConnectorId);\n                }\n                Transport localTransport = NetworkBridgeFactory.createLocalTransport(broker);\n                Transport remoteBridgeTransport = transport;\n                if (! (remoteBridgeTransport instanceof ResponseCorrelator)) {\n                    // the vm transport case is already wrapped\n                    remoteBridgeTransport = new ResponseCorrelator(remoteBridgeTransport);\n                }\n                String duplexName = localTransport.toString();\n                if (duplexName.contains(\"#\")) {\n                    duplexName = duplexName.substring(duplexName.lastIndexOf(\"#\"));\n                }\n                MBeanNetworkListener listener = new MBeanNetworkListener(broker.getBrokerService(), config, broker.getBrokerService().createDuplexNetworkConnectorObjectName(duplexName));\n                listener.setCreatedByDuplex(true);\n                duplexBridge = NetworkBridgeFactory.createBridge(config, localTransport, remoteBridgeTransport, listener);\n                duplexBridge.setBrokerService(broker.getBrokerService());\n                // now turn duplex off this side\n                info.setDuplexConnection(false);\n                duplexBridge.setCreatedByDuplex(true);\n                duplexBridge.duplexStart(this, brokerInfo, info);\n                LOG.info(\"Started responder end of duplex bridge {}\", duplexNetworkConnectorId);\n                return null;\n            } catch (TransportDisposedIOException e) {\n                LOG.warn(\"Duplex bridge {} was stopped before it was correctly started.\", duplexNetworkConnectorId);\n                return null;\n            } catch (Exception e) {\n                LOG.error(\"Failed to create responder end of duplex network bridge {}\", duplexNetworkConnectorId, e);\n                return null;\n            }\n        }\n        // We only expect to get one broker info command per connection\n        if (this.brokerInfo != null) {\n            LOG.warn(\"Unexpected extra broker info command received: {}\", info);\n        }\n        this.brokerInfo = info;\n        networkConnection = true;\n        List<TransportConnectionState> connectionStates = listConnectionStates();\n        for (TransportConnectionState cs : connectionStates) {\n            cs.getContext().setNetworkConnection(true);\n        }\n        return null;\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private HashMap<String, String> createMap(Properties properties) {\n        return new HashMap(properties);\n    }\n\n    protected void dispatch(Command command) throws IOException {\n        try {\n            setMarkedCandidate(true);\n            transport.oneway(command);\n        } finally {\n            setMarkedCandidate(false);\n        }\n    }\n\n    @Override\n    public String getRemoteAddress() {\n        return transport.getRemoteAddress();\n    }\n\n    public Transport getTransport() {\n        return transport;\n    }\n\n    @Override\n    public String getConnectionId() {\n        List<TransportConnectionState> connectionStates = listConnectionStates();\n        for (TransportConnectionState cs : connectionStates) {\n            if (cs.getInfo().getClientId() != null) {\n                return cs.getInfo().getClientId();\n            }\n            return cs.getInfo().getConnectionId().toString();\n        }\n        return null;\n    }\n\n    @Override\n    public void updateClient(ConnectionControl control) {\n        if (isActive() && isBlocked() == false && isFaultTolerantConnection() && this.wireFormatInfo != null\n                && this.wireFormatInfo.getVersion() >= 6) {\n            dispatchAsync(control);\n        }\n    }\n\n    public ProducerBrokerExchange getProducerBrokerExchangeIfExists(ProducerInfo producerInfo){\n        ProducerBrokerExchange result = null;\n        if (producerInfo != null && producerInfo.getProducerId() != null){\n            synchronized (producerExchanges){\n                result = producerExchanges.get(producerInfo.getProducerId());\n            }\n        }\n        return result;\n    }\n\n    private ProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {\n        ProducerBrokerExchange result = producerExchanges.get(id);\n        if (result == null) {\n            synchronized (producerExchanges) {\n                result = new ProducerBrokerExchange();\n                TransportConnectionState state = lookupConnectionState(id);\n                context = state.getContext();\n                result.setConnectionContext(context);\n                if (context.isReconnect() || (context.isNetworkConnection() && connector.isAuditNetworkProducers())) {\n                    result.setLastStoredSequenceId(broker.getBrokerService().getPersistenceAdapter().getLastProducerSequenceId(id));\n                }\n                SessionState ss = state.getSessionState(id.getParentId());\n                if (ss != null) {\n                    result.setProducerState(ss.getProducerState(id));\n                    ProducerState producerState = ss.getProducerState(id);\n                    if (producerState != null && producerState.getInfo() != null) {\n                        ProducerInfo info = producerState.getInfo();\n                        result.setMutable(info.getDestination() == null || info.getDestination().isComposite());\n                    }\n                }\n                producerExchanges.put(id, result);\n            }\n        } else {\n            context = result.getConnectionContext();\n        }\n        return result;\n    }\n\n    private void removeProducerBrokerExchange(ProducerId id) {\n        synchronized (producerExchanges) {\n            producerExchanges.remove(id);\n        }\n    }\n\n    private ConsumerBrokerExchange getConsumerBrokerExchange(ConsumerId id) {\n        ConsumerBrokerExchange result = consumerExchanges.get(id);\n        return result;\n    }\n\n    private ConsumerBrokerExchange addConsumerBrokerExchange(ConsumerId id) {\n        ConsumerBrokerExchange result = consumerExchanges.get(id);\n        if (result == null) {\n            synchronized (consumerExchanges) {\n                result = new ConsumerBrokerExchange();\n                TransportConnectionState state = lookupConnectionState(id);\n                context = state.getContext();\n                result.setConnectionContext(context);\n                SessionState ss = state.getSessionState(id.getParentId());\n                if (ss != null) {\n                    ConsumerState cs = ss.getConsumerState(id);\n                    if (cs != null) {\n                        ConsumerInfo info = cs.getInfo();\n                        if (info != null) {\n                            if (info.getDestination() != null && info.getDestination().isPattern()) {\n                                result.setWildcard(true);\n                            }\n                        }\n                    }\n                }\n                consumerExchanges.put(id, result);\n            }\n        }\n        return result;\n    }\n\n    private void removeConsumerBrokerExchange(ConsumerId id) {\n        synchronized (consumerExchanges) {\n            consumerExchanges.remove(id);\n        }\n    }\n\n    public int getProtocolVersion() {\n        return protocolVersion.get();\n    }\n\n    @Override\n    public Response processControlCommand(ControlCommand command) throws Exception {\n        return null;\n    }\n\n    @Override\n    public Response processMessageDispatch(MessageDispatch dispatch) throws Exception {\n        return null;\n    }\n\n    @Override\n    public Response processConnectionControl(ConnectionControl control) throws Exception {\n        if (control != null) {\n            faultTolerantConnection = control.isFaultTolerant();\n        }\n        return null;\n    }\n\n    @Override\n    public Response processConnectionError(ConnectionError error) throws Exception {\n        return null;\n    }\n\n    @Override\n    public Response processConsumerControl(ConsumerControl control) throws Exception {\n        ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(control.getConsumerId());\n        broker.processConsumerControl(consumerExchange, control);\n        return null;\n    }\n\n    protected synchronized TransportConnectionState registerConnectionState(ConnectionId connectionId,\n                                                                            TransportConnectionState state) {\n        TransportConnectionState cs = null;\n        if (!connectionStateRegister.isEmpty() && !connectionStateRegister.doesHandleMultipleConnectionStates()) {\n            // swap implementations\n            TransportConnectionStateRegister newRegister = new MapTransportConnectionStateRegister();\n            newRegister.intialize(connectionStateRegister);\n            connectionStateRegister = newRegister;\n        }\n        cs = connectionStateRegister.registerConnectionState(connectionId, state);\n        return cs;\n    }\n\n    protected synchronized TransportConnectionState unregisterConnectionState(ConnectionId connectionId) {\n        return connectionStateRegister.unregisterConnectionState(connectionId);\n    }\n\n    protected synchronized List<TransportConnectionState> listConnectionStates() {\n        return connectionStateRegister.listConnectionStates();\n    }\n\n    protected synchronized TransportConnectionState lookupConnectionState(String connectionId) {\n        return connectionStateRegister.lookupConnectionState(connectionId);\n    }\n\n    protected synchronized TransportConnectionState lookupConnectionState(ConsumerId id) {\n        return connectionStateRegister.lookupConnectionState(id);\n    }\n\n    protected synchronized TransportConnectionState lookupConnectionState(ProducerId id) {\n        return connectionStateRegister.lookupConnectionState(id);\n    }\n\n    protected synchronized TransportConnectionState lookupConnectionState(SessionId id) {\n        return connectionStateRegister.lookupConnectionState(id);\n    }\n\n    // public only for testing\n    public synchronized TransportConnectionState lookupConnectionState(ConnectionId connectionId) {\n        return connectionStateRegister.lookupConnectionState(connectionId);\n    }\n\n    protected synchronized void setDuplexNetworkConnectorId(String duplexNetworkConnectorId) {\n        this.duplexNetworkConnectorId = duplexNetworkConnectorId;\n    }\n\n    protected synchronized String getDuplexNetworkConnectorId() {\n        return this.duplexNetworkConnectorId;\n    }\n\n    public boolean isStopping() {\n        return stopping.get();\n    }\n\n    protected CountDownLatch getStopped() {\n        return stopped;\n    }\n\n    private int getProducerCount(ConnectionId connectionId) {\n        int result = 0;\n        TransportConnectionState cs = lookupConnectionState(connectionId);\n        if (cs != null) {\n            for (SessionId sessionId : cs.getSessionIds()) {\n                SessionState sessionState = cs.getSessionState(sessionId);\n                if (sessionState != null) {\n                    result += sessionState.getProducerIds().size();\n                }\n            }\n        }\n        return result;\n    }\n\n    private int getConsumerCount(ConnectionId connectionId) {\n        int result = 0;\n        TransportConnectionState cs = lookupConnectionState(connectionId);\n        if (cs != null) {\n            for (SessionId sessionId : cs.getSessionIds()) {\n                SessionState sessionState = cs.getSessionState(sessionId);\n                if (sessionState != null) {\n                    result += sessionState.getConsumerIds().size();\n                }\n            }\n        }\n        return result;\n    }\n\n    public WireFormatInfo getRemoteWireFormatInfo() {\n        return wireFormatInfo;\n    }\n}\n", "target": 0}
{"idx": 944, "func": "/*\n * JBoss, Home of Professional Open Source\n * Copyright 2014, Red Hat, Inc., and individual contributors\n * by the @authors tag. See the copyright.txt in the distribution for a\n * full listing of individual contributors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jboss.weld.tests.contexts.cache;\n\nimport java.io.IOException;\n\nimport javax.inject.Inject;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.jboss.weld.context.beanstore.ConversationNamingScheme;\n\n@WebServlet(value = \"/servlet\", asyncSupported = true)\npublic class SimpleServlet extends HttpServlet {\n\n    @Inject\n    private ConversationScopedBean bean;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String action = req.getParameter(\"action\");\n        String sequence = req.getParameter(\"sequence\");\n        String poison = req.getParameter(\"poison\");\n        if (\"getAndSet\".equals(action)) {\n            // the value should always be foo\n            String value = bean.getAndSet(\"bar\" + sequence);\n            resp.getWriter().println(value);\n            if (poison != null) {\n                // this is a poisoning request\n                // normal applications should never do something like this\n                // we just do this to cause an exception to be thrown out of ConversationContext.deactivate\n                req.removeAttribute(ConversationNamingScheme.PARAMETER_NAME);\n            }\n        } else {\n            throw new IllegalArgumentException(action);\n        }\n    }\n}\n", "target": 0}
{"idx": 945, "func": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/*\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n */\n\npackage org.apache.cxf.transport.https.httpclient;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateParsingException;\nimport java.security.cert.X509Certificate;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.NoSuchElementException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.naming.InvalidNameException;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.ldap.LdapName;\nimport javax.naming.ldap.Rdn;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLSession;\nimport javax.security.auth.x500.X500Principal;\n\nimport org.apache.cxf.common.logging.LogUtils;\n\n/**\n * Default {@link javax.net.ssl.HostnameVerifier} implementation.\n * Copied from httpclient.\n */\npublic final class DefaultHostnameVerifier implements HostnameVerifier {\n\n    enum TYPE { IPv4, IPv6, DNS };\n\n    static final int DNS_NAME_TYPE = 2;\n    static final int IP_ADDRESS_TYPE = 7;\n\n    private static final Logger LOG = LogUtils.getL7dLogger(DefaultHostnameVerifier.class);\n\n    private final PublicSuffixMatcher publicSuffixMatcher;\n\n    public DefaultHostnameVerifier(final PublicSuffixMatcher publicSuffixMatcher) {\n        this.publicSuffixMatcher = publicSuffixMatcher;\n    }\n\n    public DefaultHostnameVerifier() {\n        this(null);\n    }\n\n    @Override\n    public boolean verify(final String host, final SSLSession session) {\n        try {\n            final Certificate[] certs = session.getPeerCertificates();\n            final X509Certificate x509 = (X509Certificate) certs[0];\n            verify(host, x509);\n            return true;\n        } catch (final SSLException ex) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, ex.getMessage(), ex);\n            }\n            return false;\n        }\n    }\n\n    public void verify(\n            final String host, final X509Certificate cert) throws SSLException {\n        TYPE hostFormat = TYPE.DNS;\n        if (InetAddressUtils.isIPv4Address(host)) {\n            hostFormat = TYPE.IPv4;\n        } else {\n            String s = host;\n            if (s.startsWith(\"[\") && s.endsWith(\"]\")) {\n                s = host.substring(1, host.length() - 1);\n            }\n            if (InetAddressUtils.isIPv6Address(s)) {\n                hostFormat = TYPE.IPv6;\n            }\n        }\n        final int subjectType = hostFormat == TYPE.IPv4 || hostFormat == TYPE.IPv6 ? IP_ADDRESS_TYPE : DNS_NAME_TYPE;\n        final List<String> subjectAlts = extractSubjectAlts(cert, subjectType);\n        if (subjectAlts != null && !subjectAlts.isEmpty()) {\n            switch (hostFormat) {\n            case IPv4:\n                matchIPAddress(host, subjectAlts);\n                break;\n            case IPv6:\n                matchIPv6Address(host, subjectAlts);\n                break;\n            default:\n                matchDNSName(host, subjectAlts, this.publicSuffixMatcher);\n            }\n        } else {\n            // CN matching has been deprecated by rfc2818 and can be used\n            // as fallback only when no subjectAlts are available\n            final X500Principal subjectPrincipal = cert.getSubjectX500Principal();\n            final String cn = extractCN(subjectPrincipal.getName(X500Principal.RFC2253));\n            if (cn == null) {\n                throw new SSLException(\"Certificate subject for <\" + host + \"> doesn't contain \"\n                    + \"a common name and does not have alternative names\");\n            }\n            matchCN(host, cn, this.publicSuffixMatcher);\n        }\n    }\n\n    static void matchIPAddress(final String host, final List<String> subjectAlts) throws SSLException {\n        for (int i = 0; i < subjectAlts.size(); i++) {\n            final String subjectAlt = subjectAlts.get(i);\n            if (host.equals(subjectAlt)) {\n                return;\n            }\n        }\n        throw new SSLException(\"Certificate for <\" + host + \"> doesn't match any \"\n            + \"of the subject alternative names: \" + subjectAlts);\n    }\n\n    static void matchIPv6Address(final String host, final List<String> subjectAlts) throws SSLException {\n        final String normalisedHost = normaliseAddress(host);\n        for (int i = 0; i < subjectAlts.size(); i++) {\n            final String subjectAlt = subjectAlts.get(i);\n            final String normalizedSubjectAlt = normaliseAddress(subjectAlt);\n            if (normalisedHost.equals(normalizedSubjectAlt)) {\n                return;\n            }\n        }\n        throw new SSLException(\"Certificate for <\" + host + \"> doesn't match any \"\n            + \"of the subject alternative names: \" + subjectAlts);\n    }\n\n    static void matchDNSName(final String host, final List<String> subjectAlts,\n                             final PublicSuffixMatcher publicSuffixMatcher) throws SSLException {\n        final String normalizedHost = host.toLowerCase(Locale.ROOT);\n        for (int i = 0; i < subjectAlts.size(); i++) {\n            final String subjectAlt = subjectAlts.get(i);\n            final String normalizedSubjectAlt = subjectAlt.toLowerCase(Locale.ROOT);\n            if (matchIdentityStrict(normalizedHost, normalizedSubjectAlt, publicSuffixMatcher)) {\n                return;\n            }\n        }\n        throw new SSLException(\"Certificate for <\" + host + \"> doesn't match any \"\n            + \"of the subject alternative names: \" + subjectAlts);\n    }\n\n    static void matchCN(final String host, final String cn,\n                 final PublicSuffixMatcher publicSuffixMatcher) throws SSLException {\n        if (!matchIdentityStrict(host, cn, publicSuffixMatcher)) {\n            throw new SSLException(\"Certificate for <\" + host + \"> doesn't match \"\n                + \"common name of the certificate subject: \" + cn);\n        }\n    }\n\n    static boolean matchDomainRoot(final String host, final String domainRoot) {\n        if (domainRoot == null) {\n            return false;\n        }\n        return host.endsWith(domainRoot) && (host.length() == domainRoot.length()\n                || host.charAt(host.length() - domainRoot.length() - 1) == '.');\n    }\n\n    private static boolean matchIdentity(final String host, final String identity,\n                                         final PublicSuffixMatcher publicSuffixMatcher,\n                                         final boolean strict) {\n        if (publicSuffixMatcher != null && host.contains(\".\")\n            && !matchDomainRoot(host, publicSuffixMatcher.getDomainRoot(identity, DomainType.ICANN))) {\n            return false;\n        }\n\n        // RFC 2818, 3.1. Server Identity\n        // \"...Names may contain the wildcard\n        // character * which is considered to match any single domain name\n        // component or component fragment...\"\n        // Based on this statement presuming only singular wildcard is legal\n        final int asteriskIdx = identity.indexOf('*');\n        if (asteriskIdx != -1) {\n            final String prefix = identity.substring(0, asteriskIdx);\n            final String suffix = identity.substring(asteriskIdx + 1);\n            if (!prefix.isEmpty() && !host.startsWith(prefix)) {\n                return false;\n            }\n            if (!suffix.isEmpty() && !host.endsWith(suffix)) {\n                return false;\n            }\n            // Additional sanity checks on content selected by wildcard can be done here\n            if (strict) {\n                final String remainder = host.substring(\n                        prefix.length(), host.length() - suffix.length());\n                if (remainder.contains(\".\")) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return host.equalsIgnoreCase(identity);\n    }\n\n    static boolean matchIdentity(final String host, final String identity,\n                                 final PublicSuffixMatcher publicSuffixMatcher) {\n        return matchIdentity(host, identity, publicSuffixMatcher, false);\n    }\n\n    static boolean matchIdentity(final String host, final String identity) {\n        return matchIdentity(host, identity, null, false);\n    }\n\n    static boolean matchIdentityStrict(final String host, final String identity,\n                                       final PublicSuffixMatcher publicSuffixMatcher) {\n        return matchIdentity(host, identity, publicSuffixMatcher, true);\n    }\n\n    static boolean matchIdentityStrict(final String host, final String identity) {\n        return matchIdentity(host, identity, null, true);\n    }\n\n    static String extractCN(final String subjectPrincipal) throws SSLException {\n        if (subjectPrincipal == null) {\n            return null;\n        }\n        try {\n            final LdapName subjectDN = new LdapName(subjectPrincipal);\n            final List<Rdn> rdns = subjectDN.getRdns();\n            for (int i = rdns.size() - 1; i >= 0; i--) {\n                final Rdn rds = rdns.get(i);\n                final Attributes attributes = rds.toAttributes();\n                final Attribute cn = attributes.get(\"cn\");\n                if (cn != null) {\n                    try {\n                        final Object value = cn.get();\n                        if (value != null) {\n                            return value.toString();\n                        }\n                    } catch (NoSuchElementException ignore) {\n                        //\n                    } catch (NamingException ignore) {\n                        //\n                    }\n                }\n            }\n            return null;\n        } catch (InvalidNameException e) {\n            throw new SSLException(subjectPrincipal + \" is not a valid X500 distinguished name\");\n        }\n    }\n\n    static List<String> extractSubjectAlts(final X509Certificate cert, final int subjectType) {\n        Collection<List<?>> c = null;\n        try {\n            c = cert.getSubjectAlternativeNames();\n        } catch (final CertificateParsingException ignore) {\n            //\n        }\n        List<String> subjectAltList = null;\n        if (c != null) {\n            for (final List<?> aC : c) {\n                final List<?> list = aC;\n                final int type = ((Integer) list.get(0)).intValue();\n                if (type == subjectType) {\n                    final String s = (String) list.get(1);\n                    if (subjectAltList == null) {\n                        subjectAltList = new ArrayList<>();\n                    }\n                    subjectAltList.add(s);\n                }\n            }\n        }\n        return subjectAltList;\n    }\n\n    /*\n     * Normalize IPv6 or DNS name.\n     */\n    static String normaliseAddress(final String hostname) {\n        if (hostname == null) {\n            return hostname;\n        }\n        try {\n            final InetAddress inetAddress = InetAddress.getByName(hostname);\n            return inetAddress.getHostAddress();\n        } catch (final UnknownHostException unexpected) { // Should not happen, because we check for IPv6 address above\n            return hostname;\n        }\n    }\n}\n", "target": 1}
{"idx": 946, "func": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.facebook.thrift.protocol;\n\nimport com.facebook.thrift.ShortStack;\nimport com.facebook.thrift.TException;\nimport com.facebook.thrift.transport.TTransport;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\n/**\n * TCompactProtocol2 is the Java implementation of the compact protocol specified in THRIFT-110. The\n * fundamental approach to reducing the overhead of structures is a) use variable-length integers\n * all over the place and b) make use of unused bits wherever possible. Your savings will obviously\n * vary based on the specific makeup of your structs, but in general, the more fields, nested\n * structures, short strings and collections, and low-value i32 and i64 fields you have, the more\n * benefit you'll see.\n */\npublic class TCompactProtocol extends TProtocol {\n\n  private static final TStruct ANONYMOUS_STRUCT = new TStruct(\"\");\n  private static final TField TSTOP = new TField(\"\", TType.STOP, (short) 0);\n\n  private static final byte[] ttypeToCompactType = new byte[20];\n\n  static {\n    ttypeToCompactType[TType.STOP] = TType.STOP;\n    ttypeToCompactType[TType.BOOL] = Types.BOOLEAN_TRUE;\n    ttypeToCompactType[TType.BYTE] = Types.BYTE;\n    ttypeToCompactType[TType.I16] = Types.I16;\n    ttypeToCompactType[TType.I32] = Types.I32;\n    ttypeToCompactType[TType.I64] = Types.I64;\n    ttypeToCompactType[TType.DOUBLE] = Types.DOUBLE;\n    ttypeToCompactType[TType.STRING] = Types.BINARY;\n    ttypeToCompactType[TType.LIST] = Types.LIST;\n    ttypeToCompactType[TType.SET] = Types.SET;\n    ttypeToCompactType[TType.MAP] = Types.MAP;\n    ttypeToCompactType[TType.STRUCT] = Types.STRUCT;\n    ttypeToCompactType[TType.FLOAT] = Types.FLOAT;\n  }\n\n  /** TProtocolFactory that produces TCompactProtocols. */\n  @SuppressWarnings(\"serial\")\n  public static class Factory implements TProtocolFactory {\n    private final long maxNetworkBytes_;\n\n    public Factory() {\n      maxNetworkBytes_ = -1;\n    }\n\n    public Factory(int maxNetworkBytes) {\n      maxNetworkBytes_ = maxNetworkBytes;\n    }\n\n    public TProtocol getProtocol(TTransport trans) {\n      return new TCompactProtocol(trans, maxNetworkBytes_);\n    }\n  }\n\n  public static final byte PROTOCOL_ID = (byte) 0x82;\n  public static final byte VERSION = 2;\n  public static final byte VERSION_LOW = 1;\n  public static final byte VERSION_DOUBLE_BE = 2;\n  public static final byte VERSION_MASK = 0x1f; // 0001 1111\n  public static final byte TYPE_MASK = (byte) 0xE0; // 1110 0000\n  public static final int TYPE_SHIFT_AMOUNT = 5;\n\n  /** All of the on-wire type codes. */\n  private static class Types {\n    public static final byte BOOLEAN_TRUE = 0x01;\n    public static final byte BOOLEAN_FALSE = 0x02;\n    public static final byte BYTE = 0x03;\n    public static final byte I16 = 0x04;\n    public static final byte I32 = 0x05;\n    public static final byte I64 = 0x06;\n    public static final byte DOUBLE = 0x07;\n    public static final byte BINARY = 0x08;\n    public static final byte LIST = 0x09;\n    public static final byte SET = 0x0A;\n    public static final byte MAP = 0x0B;\n    public static final byte STRUCT = 0x0C;\n    public static final byte FLOAT = 0x0D;\n  }\n\n  /**\n   * Used to keep track of the last field for the current and previous structs, so we can do the\n   * delta stuff.\n   */\n  private ShortStack lastField_ = new ShortStack(15);\n\n  private short lastFieldId_ = 0;\n\n  private byte version_ = VERSION;\n\n  /**\n   * If we encounter a boolean field begin, save the TField here so it can have the value\n   * incorporated.\n   */\n  private TField booleanField_ = null;\n\n  /**\n   * If we read a field header, and it's a boolean field, save the boolean value here so that\n   * readBool can use it.\n   */\n  private Boolean boolValue_ = null;\n\n  /**\n   * The maximum number of bytes to read from the network for variable-length fields (such as\n   * strings or binary) or -1 for unlimited.\n   */\n  private final long maxNetworkBytes_;\n\n  /** Temporary buffer to avoid allocations */\n  private final byte[] buffer = new byte[10];\n\n  /**\n   * Create a TCompactProtocol.\n   *\n   * @param transport the TTransport object to read from or write to.\n   * @param maxNetworkBytes the maximum number of bytes to read for variable-length fields.\n   */\n  public TCompactProtocol(TTransport transport, long maxNetworkBytes) {\n    super(transport);\n    maxNetworkBytes_ = maxNetworkBytes;\n  }\n\n  /**\n   * Create a TCompactProtocol.\n   *\n   * @param transport the TTransport object to read from or write to.\n   */\n  public TCompactProtocol(TTransport transport) {\n    this(transport, -1);\n  }\n\n  public void reset() {\n    lastField_.clear();\n    lastFieldId_ = 0;\n  }\n\n  //\n  // Public Writing methods.\n  //\n\n  /**\n   * Write a message header to the wire. Compact Protocol messages contain the protocol version so\n   * we can migrate forwards in the future if need be.\n   */\n  public void writeMessageBegin(TMessage message) throws TException {\n    writeByteDirect(PROTOCOL_ID);\n    writeByteDirect((VERSION & VERSION_MASK) | ((message.type << TYPE_SHIFT_AMOUNT) & TYPE_MASK));\n    writeVarint32(message.seqid);\n    writeString(message.name);\n  }\n\n  /**\n   * Write a struct begin. This doesn't actually put anything on the wire. We use it as an\n   * opportunity to put special placeholder markers on the field stack so we can get the field id\n   * deltas correct.\n   */\n  public void writeStructBegin(TStruct struct) throws TException {\n    lastField_.push(lastFieldId_);\n    lastFieldId_ = 0;\n  }\n\n  /**\n   * Write a struct end. This doesn't actually put anything on the wire. We use this as an\n   * opportunity to pop the last field from the current struct off of the field stack.\n   */\n  public void writeStructEnd() throws TException {\n    lastFieldId_ = lastField_.pop();\n  }\n\n  /**\n   * Write a field header containing the field id and field type. If the difference between the\n   * current field id and the last one is small (< 15), then the field id will be encoded in the 4\n   * MSB as a delta. Otherwise, the field id will follow the type header as a zigzag varint.\n   */\n  public void writeFieldBegin(TField field) throws TException {\n    if (field.type == TType.BOOL) {\n      // we want to possibly include the value, so we'll wait.\n      booleanField_ = field;\n    } else {\n      writeFieldBeginInternal(field, (byte) -1);\n    }\n  }\n\n  /**\n   * The workhorse of writeFieldBegin. It has the option of doing a 'type override' of the type\n   * header. This is used specifically in the boolean field case.\n   */\n  private void writeFieldBeginInternal(TField field, byte typeOverride) throws TException {\n    // short lastField = lastField_.pop();\n\n    // if there's a type override, use that.\n    byte typeToWrite = typeOverride == -1 ? getCompactType(field.type) : typeOverride;\n\n    // check if we can use delta encoding for the field id\n    if (field.id > lastFieldId_ && field.id - lastFieldId_ <= 15) {\n      // write them together\n      writeByteDirect((field.id - lastFieldId_) << 4 | typeToWrite);\n    } else {\n      // write them separate\n      writeByteDirect(typeToWrite);\n      writeI16(field.id);\n    }\n\n    lastFieldId_ = field.id;\n    // lastField_.push(field.id);\n  }\n\n  /** Write the STOP symbol so we know there are no more fields in this struct. */\n  public void writeFieldStop() throws TException {\n    writeByteDirect(TType.STOP);\n  }\n\n  /**\n   * Write a map header. If the map is empty, omit the key and value type headers, as we don't need\n   * any additional information to skip it.\n   */\n  public void writeMapBegin(TMap map) throws TException {\n    if (map.size == 0) {\n      writeByteDirect(0);\n    } else {\n      writeVarint32(map.size);\n      writeByteDirect(getCompactType(map.keyType) << 4 | getCompactType(map.valueType));\n    }\n  }\n\n  /** Write a list header. */\n  public void writeListBegin(TList list) throws TException {\n    writeCollectionBegin(list.elemType, list.size);\n  }\n\n  /** Write a set header. */\n  public void writeSetBegin(TSet set) throws TException {\n    writeCollectionBegin(set.elemType, set.size);\n  }\n\n  /**\n   * Write a boolean value. Potentially, this could be a boolean field, in which case the field\n   * header info isn't written yet. If so, decide what the right type header is for the value and\n   * then write the field header. Otherwise, write a single byte.\n   */\n  public void writeBool(boolean b) throws TException {\n    if (booleanField_ != null) {\n      // we haven't written the field header yet\n      writeFieldBeginInternal(booleanField_, b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);\n      booleanField_ = null;\n    } else {\n      // we're not part of a field, so just write the value.\n      writeByteDirect(b ? Types.BOOLEAN_TRUE : Types.BOOLEAN_FALSE);\n    }\n  }\n\n  /** Write a byte. Nothing to see here! */\n  public void writeByte(byte b) throws TException {\n    writeByteDirect(b);\n  }\n\n  /** Write an I16 as a zigzag varint. */\n  public void writeI16(short i16) throws TException {\n    writeVarint32(intToZigZag(i16));\n  }\n\n  /** Write an i32 as a zigzag varint. */\n  public void writeI32(int i32) throws TException {\n    writeVarint32(intToZigZag(i32));\n  }\n\n  /** Write an i64 as a zigzag varint. */\n  public void writeI64(long i64) throws TException {\n    writeVarint64(longToZigzag(i64));\n  }\n\n  /** Write a double to the wire as 8 bytes. */\n  public void writeDouble(double dub) throws TException {\n    fixedLongToBytes(Double.doubleToLongBits(dub), buffer, 0);\n    trans_.write(buffer, 0, 8);\n  }\n\n  /** Write a float to the wire as 4 bytes. */\n  public void writeFloat(float flt) throws TException {\n    fixedIntToBytes(Float.floatToIntBits(flt), buffer, 0);\n    trans_.write(buffer, 0, 4);\n  }\n\n  /** Write a string to the wire with a varint size preceding. */\n  public void writeString(String str) throws TException {\n    byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n    writeBinary(bytes, 0, bytes.length);\n  }\n\n  /** Write a byte array, using a varint for the size. */\n  public void writeBinary(byte[] buf) throws TException {\n    writeBinary(buf, 0, buf.length);\n  }\n\n  private void writeBinary(byte[] buf, int offset, int length) throws TException {\n    writeVarint32(length);\n    trans_.write(buf, offset, length);\n  }\n\n  //\n  // These methods are called by structs, but don't actually have any wire\n  // output or purpose.\n  //\n\n  public void writeMessageEnd() throws TException {}\n\n  public void writeMapEnd() throws TException {}\n\n  public void writeListEnd() throws TException {}\n\n  public void writeSetEnd() throws TException {}\n\n  public void writeFieldEnd() throws TException {}\n\n  //\n  // Internal writing methods\n  //\n\n  /**\n   * Abstract method for writing the start of lists and sets. List and sets on the wire differ only\n   * by the type indicator.\n   */\n  protected void writeCollectionBegin(byte elemType, int size) throws TException {\n    if (size <= 14) {\n      writeByteDirect(size << 4 | getCompactType(elemType));\n    } else {\n      writeByteDirect(0xf0 | getCompactType(elemType));\n      writeVarint32(size);\n    }\n  }\n\n  /** Write an i32 as a varint. Results in 1-5 bytes on the wire. */\n  private void writeVarint32(int n) throws TException {\n    int idx = 0;\n    while (true) {\n      if ((n & ~0x7F) == 0) {\n        buffer[idx++] = (byte) n;\n        break;\n      } else {\n        buffer[idx++] = (byte) ((n & 0x7F) | 0x80);\n        n >>>= 7;\n      }\n    }\n    trans_.write(buffer, 0, idx);\n  }\n\n  /** Write an i64 as a varint. Results in 1-10 bytes on the wire. */\n  private void writeVarint64(long n) throws TException {\n    int idx = 0;\n    while (true) {\n      if ((n & ~0x7FL) == 0) {\n        buffer[idx++] = (byte) n;\n        break;\n      } else {\n        buffer[idx++] = ((byte) ((n & 0x7F) | 0x80));\n        n >>>= 7;\n      }\n    }\n    trans_.write(buffer, 0, idx);\n  }\n\n  /**\n   * Convert l into a zigzag long. This allows negative numbers to be represented compactly as a\n   * varint.\n   */\n  private long longToZigzag(long l) {\n    return (l << 1) ^ (l >> 63);\n  }\n\n  /**\n   * Convert n into a zigzag int. This allows negative numbers to be represented compactly as a\n   * varint.\n   */\n  private int intToZigZag(int n) {\n    return (n << 1) ^ (n >> 31);\n  }\n\n  /** Convert a long into little-endian bytes in buf starting at off and going until off+7. */\n  private void fixedLongToBytes(long n, byte[] buf, int off) {\n    buf[off + 0] = (byte) ((n >> 56) & 0xff);\n    buf[off + 1] = (byte) ((n >> 48) & 0xff);\n    buf[off + 2] = (byte) ((n >> 40) & 0xff);\n    buf[off + 3] = (byte) ((n >> 32) & 0xff);\n    buf[off + 4] = (byte) ((n >> 24) & 0xff);\n    buf[off + 5] = (byte) ((n >> 16) & 0xff);\n    buf[off + 6] = (byte) ((n >> 8) & 0xff);\n    buf[off + 7] = (byte) (n & 0xff);\n  }\n\n  /** Convert a long into little-endian bytes in buf starting at off and going until off+7. */\n  private void fixedIntToBytes(int n, byte[] buf, int off) {\n    buf[off + 0] = (byte) ((n >> 24) & 0xff);\n    buf[off + 1] = (byte) ((n >> 16) & 0xff);\n    buf[off + 2] = (byte) ((n >> 8) & 0xff);\n    buf[off + 3] = (byte) (n & 0xff);\n  }\n\n  /**\n   * Writes a byte without any possiblity of all that field header nonsense. Used internally by\n   * other writing methods that know they need to write a byte.\n   */\n  private void writeByteDirect(byte b) throws TException {\n    buffer[0] = b;\n    trans_.write(buffer, 0, 1);\n  }\n\n  /** Writes a byte without any possiblity of all that field header nonsense. */\n  private void writeByteDirect(int n) throws TException {\n    writeByteDirect((byte) n);\n  }\n\n  //\n  // Reading methods.\n  //\n\n  /** Read a message header. */\n  public TMessage readMessageBegin() throws TException {\n    byte protocolId = readByte();\n    if (protocolId != PROTOCOL_ID) {\n      throw new TProtocolException(\n          \"Expected protocol id \"\n              + Integer.toHexString(PROTOCOL_ID)\n              + \" but got \"\n              + Integer.toHexString(protocolId));\n    }\n    byte versionAndType = readByte();\n    version_ = (byte) (versionAndType & VERSION_MASK);\n    if (!(version_ <= VERSION && version_ >= VERSION_LOW)) {\n      throw new TProtocolException(\"Expected version \" + VERSION + \" but got \" + version_);\n    }\n    byte type = (byte) ((versionAndType >> TYPE_SHIFT_AMOUNT) & 0x03);\n    int seqid = readVarint32();\n    String messageName = readString();\n    return new TMessage(messageName, type, seqid);\n  }\n\n  /**\n   * Read a struct begin. There's nothing on the wire for this, but it is our opportunity to push a\n   * new struct begin marker onto the field stack.\n   */\n  public TStruct readStructBegin(\n      Map<Integer, com.facebook.thrift.meta_data.FieldMetaData> metaDataMap) throws TException {\n    lastField_.push(lastFieldId_);\n    lastFieldId_ = 0;\n    return ANONYMOUS_STRUCT;\n  }\n\n  /**\n   * Doesn't actually consume any wire data, just removes the last field for this struct from the\n   * field stack.\n   */\n  public void readStructEnd() throws TException {\n    // consume the last field we read off the wire.\n    lastFieldId_ = lastField_.pop();\n  }\n\n  /** Read a field header off the wire. */\n  public TField readFieldBegin() throws TException {\n    byte type = readByte();\n\n    // if it's a stop, then we can return immediately, as the struct is over.\n    if (type == TType.STOP) {\n      return TSTOP;\n    }\n\n    short fieldId;\n\n    // mask off the 4 MSB of the type header. it could contain a field id delta.\n    short modifier = (short) ((type & 0xf0) >> 4);\n    if (modifier == 0) {\n      // not a delta. look ahead for the zigzag varint field id.\n      fieldId = readI16();\n    } else {\n      // has a delta. add the delta to the last read field id.\n      fieldId = (short) (lastFieldId_ + modifier);\n    }\n\n    TField field = new TField(\"\", getTType((byte) (type & 0x0f)), fieldId);\n\n    // if this happens to be a boolean field, the value is encoded in the type\n    if (isBoolType(type)) {\n      // save the boolean value in a special instance variable.\n      boolValue_ = (byte) (type & 0x0f) == Types.BOOLEAN_TRUE ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    // push the new field onto the field stack so we can keep the deltas going.\n    lastFieldId_ = field.id;\n    return field;\n  }\n\n  /**\n   * Read a map header off the wire. If the size is zero, skip reading the key and value type. This\n   * means that 0-length maps will yield TMaps without the \"correct\" types.\n   */\n  public TMap readMapBegin() throws TException {\n    int size = readVarint32();\n    byte keyAndValueType = size == 0 ? 0 : readByte();\n    byte keyType = getTType((byte) (keyAndValueType >> 4));\n    byte valueType = getTType((byte) (keyAndValueType & 0xf));\n    if (size > 0) {\n      ensureMapHasEnough(size, keyType, valueType);\n    }\n    return new TMap(keyType, valueType, size);\n  }\n\n  /**\n   * Read a list header off the wire. If the list size is 0-14, the size will be packed into the\n   * element type header. If it's a longer list, the 4 MSB of the element type header will be 0xF,\n   * and a varint will follow with the true size.\n   */\n  public TList readListBegin() throws TException {\n    byte size_and_type = readByte();\n    int size = (size_and_type >> 4) & 0x0f;\n    if (size == 15) {\n      size = readVarint32();\n    }\n    byte type = getTType(size_and_type);\n    ensureContainerHasEnough(size, type);\n    return new TList(type, size);\n  }\n\n  /**\n   * Read a set header off the wire. If the set size is 0-14, the size will be packed into the\n   * element type header. If it's a longer set, the 4 MSB of the element type header will be 0xF,\n   * and a varint will follow with the true size.\n   */\n  public TSet readSetBegin() throws TException {\n    return new TSet(readListBegin());\n  }\n\n  /**\n   * Read a boolean off the wire. If this is a boolean field, the value should already have been\n   * read during readFieldBegin, so we'll just consume the pre-stored value. Otherwise, read a byte.\n   */\n  public boolean readBool() throws TException {\n    if (boolValue_ != null) {\n      boolean result = boolValue_.booleanValue();\n      boolValue_ = null;\n      return result;\n    }\n    return readByte() == Types.BOOLEAN_TRUE;\n  }\n\n  /** Read a single byte off the wire. Nothing interesting here. */\n  public byte readByte() throws TException {\n    byte b;\n    if (trans_.getBytesRemainingInBuffer() > 0) {\n      b = trans_.getBuffer()[trans_.getBufferPosition()];\n      trans_.consumeBuffer(1);\n    } else {\n      trans_.readAll(buffer, 0, 1);\n      b = buffer[0];\n    }\n    return b;\n  }\n\n  /** Read an i16 from the wire as a zigzag varint. */\n  public short readI16() throws TException {\n    return (short) zigzagToInt(readVarint32());\n  }\n\n  /** Read an i32 from the wire as a zigzag varint. */\n  public int readI32() throws TException {\n    return zigzagToInt(readVarint32());\n  }\n\n  /** Read an i64 from the wire as a zigzag varint. */\n  public long readI64() throws TException {\n    return zigzagToLong(readVarint64());\n  }\n\n  /** No magic here - just read a double off the wire. */\n  public double readDouble() throws TException {\n    trans_.readAll(buffer, 0, 8);\n    long value;\n    if (version_ >= VERSION_DOUBLE_BE) {\n      value = bytesToLong(buffer);\n    } else {\n      value = bytesToLongLE(buffer);\n    }\n    return Double.longBitsToDouble(value);\n  }\n\n  /** No magic here - just read a float off the wire. */\n  public float readFloat() throws TException {\n    trans_.readAll(buffer, 0, 4);\n    int value = bytesToInt(buffer);\n    return Float.intBitsToFloat(value);\n  }\n\n  /** Reads a byte[] (via readBinary), and then UTF-8 decodes it. */\n  public String readString() throws TException {\n    int length = readVarint32();\n    checkReadLength(length);\n\n    if (length == 0) {\n      return \"\";\n    }\n\n    if (trans_.getBytesRemainingInBuffer() >= length) {\n      String str =\n          new String(\n              trans_.getBuffer(), trans_.getBufferPosition(), length, StandardCharsets.UTF_8);\n      trans_.consumeBuffer(length);\n      return str;\n    } else {\n      return new String(readBinary(length), StandardCharsets.UTF_8);\n    }\n  }\n\n  /** Read a byte[] from the wire. */\n  public byte[] readBinary() throws TException {\n    int length = readVarint32();\n    checkReadLength(length);\n    return readBinary(length);\n  }\n\n  private byte[] readBinary(int length) throws TException {\n    if (length == 0) {\n      return new byte[0];\n    }\n\n    byte[] buf = new byte[length];\n    trans_.readAll(buf, 0, length);\n    return buf;\n  }\n\n  private void checkReadLength(int length) throws TProtocolException {\n    if (length < 0) {\n      throw new TProtocolException(\"Negative length: \" + length);\n    }\n    if (maxNetworkBytes_ != -1 && length > maxNetworkBytes_) {\n      throw new TProtocolException(\"Length exceeded max allowed: \" + length);\n    }\n  }\n\n  //\n  // These methods are here for the struct to call, but don't have any wire\n  // encoding.\n  //\n  public void readMessageEnd() throws TException {}\n\n  public void readFieldEnd() throws TException {}\n\n  public void readMapEnd() throws TException {}\n\n  public void readListEnd() throws TException {}\n\n  public void readSetEnd() throws TException {}\n\n  //\n  // Internal reading methods\n  //\n\n  /**\n   * Read an i32 from the wire as a varint. The MSB of each byte is set if there is another byte to\n   * follow. This can read up to 5 bytes.\n   */\n  private int readVarint32() throws TException {\n    int result = 0;\n    int shift = 0;\n    if (trans_.getBytesRemainingInBuffer() >= 5) {\n      byte[] buf = trans_.getBuffer();\n      int pos = trans_.getBufferPosition();\n      int off = 0;\n      while (true) {\n        byte b = buf[pos + off];\n        result |= (int) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n        off++;\n      }\n      trans_.consumeBuffer(off + 1);\n    } else {\n      while (true) {\n        byte b = readByte();\n        result |= (int) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Read an i64 from the wire as a proper varint. The MSB of each byte is set if there is another\n   * byte to follow. This can read up to 10 bytes.\n   */\n  private long readVarint64() throws TException {\n    int shift = 0;\n    long result = 0;\n    if (trans_.getBytesRemainingInBuffer() >= 10) {\n      byte[] buf = trans_.getBuffer();\n      int pos = trans_.getBufferPosition();\n      int off = 0;\n      while (true) {\n        byte b = buf[pos + off];\n        result |= (long) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n        off++;\n      }\n      trans_.consumeBuffer(off + 1);\n    } else {\n      while (true) {\n        byte b = readByte();\n        result |= (long) (b & 0x7f) << shift;\n        if ((b & 0x80) != 0x80) {\n          break;\n        }\n        shift += 7;\n      }\n    }\n    return result;\n  }\n\n  //\n  // encoding helpers\n  //\n\n  /** Convert from zigzag int to int. */\n  private int zigzagToInt(int n) {\n    return (n >>> 1) ^ -(n & 1);\n  }\n\n  /** Convert from zigzag long to long. */\n  private long zigzagToLong(long n) {\n    return (n >>> 1) ^ -(n & 1);\n  }\n\n  /**\n   * Note that it's important that the mask bytes are long literals, otherwise they'll default to\n   * ints, and when you shift an int left 56 bits, you just get a messed up int.\n   */\n  private long bytesToLong(byte[] bytes) {\n    return ((bytes[0] & 0xffL) << 56)\n        | ((bytes[1] & 0xffL) << 48)\n        | ((bytes[2] & 0xffL) << 40)\n        | ((bytes[3] & 0xffL) << 32)\n        | ((bytes[4] & 0xffL) << 24)\n        | ((bytes[5] & 0xffL) << 16)\n        | ((bytes[6] & 0xffL) << 8)\n        | ((bytes[7] & 0xffL));\n  }\n\n  /* Little endian version of the above */\n  private long bytesToLongLE(byte[] bytes) {\n    return ((bytes[7] & 0xffL) << 56)\n        | ((bytes[6] & 0xffL) << 48)\n        | ((bytes[5] & 0xffL) << 40)\n        | ((bytes[4] & 0xffL) << 32)\n        | ((bytes[3] & 0xffL) << 24)\n        | ((bytes[2] & 0xffL) << 16)\n        | ((bytes[1] & 0xffL) << 8)\n        | ((bytes[0] & 0xffL));\n  }\n\n  private int bytesToInt(byte[] bytes) {\n    return ((bytes[0] & 0xff) << 24)\n        | ((bytes[1] & 0xff) << 16)\n        | ((bytes[2] & 0xff) << 8)\n        | ((bytes[3] & 0xff));\n  }\n\n  //\n  // type testing and converting\n  //\n\n  private boolean isBoolType(byte b) {\n    int lowerNibble = b & 0x0f;\n    return lowerNibble == Types.BOOLEAN_TRUE || lowerNibble == Types.BOOLEAN_FALSE;\n  }\n\n  /** Given a TCompactProtocol.Types constant, convert it to its corresponding TType value. */\n  private byte getTType(byte type) throws TProtocolException {\n    switch ((byte) (type & 0x0f)) {\n      case TType.STOP:\n        return TType.STOP;\n      case Types.BOOLEAN_FALSE:\n      case Types.BOOLEAN_TRUE:\n        return TType.BOOL;\n      case Types.BYTE:\n        return TType.BYTE;\n      case Types.I16:\n        return TType.I16;\n      case Types.I32:\n        return TType.I32;\n      case Types.I64:\n        return TType.I64;\n      case Types.DOUBLE:\n        return TType.DOUBLE;\n      case Types.FLOAT:\n        return TType.FLOAT;\n      case Types.BINARY:\n        return TType.STRING;\n      case Types.LIST:\n        return TType.LIST;\n      case Types.SET:\n        return TType.SET;\n      case Types.MAP:\n        return TType.MAP;\n      case Types.STRUCT:\n        return TType.STRUCT;\n      default:\n        throw new TProtocolException(\"don't know what type: \" + (byte) (type & 0x0f));\n    }\n  }\n\n  /** Given a TType value, find the appropriate TCompactProtocol.Types constant. */\n  private byte getCompactType(byte ttype) {\n    return ttypeToCompactType[ttype];\n  }\n\n  @Override\n  protected int typeMinimumSize(byte type) {\n    switch (type & 0x0f) {\n      case TType.BOOL:\n      case TType.BYTE:\n      case TType.I16: // because of variable length encoding\n      case TType.I32: // because of variable length encoding\n      case TType.I64: // because of variable length encoding\n        return 1;\n      case TType.FLOAT:\n        return 4;\n      case TType.DOUBLE:\n        return 8;\n      case TType.STRING:\n      case TType.STRUCT:\n      case TType.MAP:\n      case TType.SET:\n      case TType.LIST:\n      case TType.ENUM:\n        return 1;\n      default:\n        throw new TProtocolException(\n            TProtocolException.INVALID_DATA, \"Unexpected data type \" + (byte) (type & 0x0f));\n    }\n  }\n}\n", "target": 0}
{"idx": 947, "func": "/*\n * Copyright 2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.gradle.plugins.signing.signatory.pgp;\n\nimport org.bouncycastle.bcpg.BCPGOutputStream;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPException;\nimport org.bouncycastle.openpgp.PGPPrivateKey;\nimport org.bouncycastle.openpgp.PGPSecretKey;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.operator.PBESecretKeyDecryptor;\nimport org.bouncycastle.openpgp.operator.bc.BcPBESecretKeyDecryptorBuilder;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder;\nimport org.bouncycastle.openpgp.operator.bc.BcPGPDigestCalculatorProvider;\nimport org.gradle.api.UncheckedIOException;\nimport org.gradle.internal.UncheckedException;\nimport org.gradle.plugins.signing.signatory.SignatorySupport;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.Security;\n\n/**\n * PGP signatory from PGP key and password.\n */\npublic class PgpSignatory extends SignatorySupport {\n\n    {\n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    private final String name;\n    private final PGPSecretKey secretKey;\n    private final PGPPrivateKey privateKey;\n\n    public PgpSignatory(String name, PGPSecretKey secretKey, String password) {\n        this.name = name;\n        this.secretKey = secretKey;\n        this.privateKey = createPrivateKey(secretKey, password);\n    }\n\n    @Override\n    public final String getName() {\n        return name;\n    }\n\n    /**\n     * Exhausts {@code toSign}, and writes the signature to {@code signatureDestination}.\n     *\n     * The caller is responsible for closing the streams, though the output WILL be flushed.\n     */\n    @Override\n    public void sign(InputStream toSign, OutputStream signatureDestination) {\n        PGPSignatureGenerator generator = createSignatureGenerator();\n        try {\n            feedGeneratorWith(toSign, generator);\n\n            PGPSignature signature = generator.generate();\n            writeSignatureTo(signatureDestination, signature);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    @Override\n    public String getKeyId() {\n        PgpKeyId id = new PgpKeyId(secretKey.getKeyID());\n        return id == null ? null : id.getAsHex();\n    }\n\n    private void feedGeneratorWith(InputStream toSign, PGPSignatureGenerator generator) throws IOException {\n        byte[] buffer = new byte[1024];\n        int read = toSign.read(buffer);\n        while (read > 0) {\n            generator.update(buffer, 0, read);\n            read = toSign.read(buffer);\n        }\n    }\n\n    private void writeSignatureTo(OutputStream signatureDestination, PGPSignature pgpSignature) throws PGPException, IOException {\n        // BCPGOutputStream seems to do some internal buffering, it's unclear whether it's strictly required here though\n        BCPGOutputStream bufferedOutput = new BCPGOutputStream(signatureDestination);\n        pgpSignature.encode(bufferedOutput);\n        bufferedOutput.flush();\n    }\n\n    public PGPSignatureGenerator createSignatureGenerator() {\n        try {\n            PGPSignatureGenerator generator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(secretKey.getPublicKey().getAlgorithm(), PGPUtil.SHA1));\n            generator.init(PGPSignature.BINARY_DOCUMENT, privateKey);\n            return generator;\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n\n    private PGPPrivateKey createPrivateKey(PGPSecretKey secretKey, String password) {\n        try {\n            PBESecretKeyDecryptor decryptor = new BcPBESecretKeyDecryptorBuilder(new BcPGPDigestCalculatorProvider()).build(password.toCharArray());\n            return secretKey.extractPrivateKey(decryptor);\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }\n}\n", "target": 1}
{"idx": 948, "func": "package cc.mrbird.common.handler;\n\nimport cc.mrbird.common.domain.ResponseBo;\nimport cc.mrbird.common.exception.FileDownloadException;\nimport cc.mrbird.common.exception.LimitAccessException;\nimport org.apache.shiro.authz.AuthorizationException;\nimport org.apache.shiro.session.ExpiredSessionException;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\n\n@RestControllerAdvice\n@Order(value = Ordered.HIGHEST_PRECEDENCE)\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(value = AuthorizationException.class)\n    public Object handleAuthorizationException(HttpServletRequest request) {\n        if (isAjaxRequest(request)) {\n            return ResponseBo.error(\"\");\n        } else {\n            ModelAndView mav = new ModelAndView();\n            mav.setViewName(\"error/403\");\n            return mav;\n        }\n    }\n\n    @ExceptionHandler(value = ExpiredSessionException.class)\n    public String handleExpiredSessionException() {\n        return \"login\";\n    }\n\n    @ExceptionHandler(value = LimitAccessException.class)\n    public ResponseBo handleLimitAccessException(LimitAccessException e) {\n        return ResponseBo.error(e.getMessage());\n    }\n\n    @ExceptionHandler(value = FileDownloadException.class)\n    public ResponseBo handleFileDownloadException(FileDownloadException e) {\n        return ResponseBo.error(e.getMessage());\n    }\n\n    private static boolean isAjaxRequest(HttpServletRequest request) {\n        return (request.getHeader(\"X-Requested-With\") != null\n                && \"XMLHttpRequest\".equals(request.getHeader(\"X-Requested-With\")));\n    }\n\n}\n", "target": 0}
{"idx": 949, "func": "/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage org.jboss.netty.handler.ssl;\n\nimport org.jboss.netty.buffer.ChannelBuffer;\nimport org.jboss.netty.buffer.ChannelBufferFactory;\nimport org.jboss.netty.buffer.ChannelBuffers;\nimport org.jboss.netty.channel.Channel;\nimport org.jboss.netty.channel.ChannelDownstreamHandler;\nimport org.jboss.netty.channel.ChannelEvent;\nimport org.jboss.netty.channel.ChannelFuture;\nimport org.jboss.netty.channel.ChannelFutureListener;\nimport org.jboss.netty.channel.ChannelHandlerContext;\nimport org.jboss.netty.channel.ChannelPipeline;\nimport org.jboss.netty.channel.ChannelStateEvent;\nimport org.jboss.netty.channel.Channels;\nimport org.jboss.netty.channel.DefaultChannelFuture;\nimport org.jboss.netty.channel.DownstreamMessageEvent;\nimport org.jboss.netty.channel.ExceptionEvent;\nimport org.jboss.netty.channel.MessageEvent;\nimport org.jboss.netty.handler.codec.frame.FrameDecoder;\nimport org.jboss.netty.logging.InternalLogger;\nimport org.jboss.netty.logging.InternalLoggerFactory;\nimport org.jboss.netty.util.Timeout;\nimport org.jboss.netty.util.Timer;\nimport org.jboss.netty.util.TimerTask;\nimport org.jboss.netty.util.internal.DetectionUtil;\nimport org.jboss.netty.util.internal.NonReentrantLock;\n\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLEngineResult.HandshakeStatus;\nimport javax.net.ssl.SSLEngineResult.Status;\nimport javax.net.ssl.SSLException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.DatagramChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\nimport java.util.regex.Pattern;\n\nimport static org.jboss.netty.channel.Channels.*;\n\n/**\n * Adds <a href=\"http://en.wikipedia.org/wiki/Transport_Layer_Security\">SSL\n * &middot; TLS</a> and StartTLS support to a {@link Channel}.  Please refer\n * to the <strong>\"SecureChat\"</strong> example in the distribution or the web\n * site for the detailed usage.\n *\n * <h3>Beginning the handshake</h3>\n * <p>\n * You must make sure not to write a message while the\n * {@linkplain #handshake() handshake} is in progress unless you are\n * renegotiating.  You will be notified by the {@link ChannelFuture} which is\n * returned by the {@link #handshake()} method when the handshake\n * process succeeds or fails.\n *\n * <h3>Handshake</h3>\n * <p>\n * If {@link #isIssueHandshake()} is {@code false}\n * (default) you will need to take care of calling {@link #handshake()} by your own. In most\n * situations were {@link SslHandler} is used in 'client mode' you want to issue a handshake once\n * the connection was established. if {@link #setIssueHandshake(boolean)} is set to {@code true}\n * you don't need to worry about this as the {@link SslHandler} will take care of it.\n * <p>\n *\n * <h3>Renegotiation</h3>\n * <p>\n * If {@link #isEnableRenegotiation() enableRenegotiation} is {@code true}\n * (default) and the initial handshake has been done successfully, you can call\n * {@link #handshake()} to trigger the renegotiation.\n * <p>\n * If {@link #isEnableRenegotiation() enableRenegotiation} is {@code false},\n * an attempt to trigger renegotiation will result in the connection closure.\n * <p>\n * Please note that TLS renegotiation had a security issue before.  If your\n * runtime environment did not fix it, please make sure to disable TLS\n * renegotiation by calling {@link #setEnableRenegotiation(boolean)} with\n * {@code false}.  For more information, please refer to the following documents:\n * <ul>\n *   <li><a href=\"http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3555\">CVE-2009-3555</a></li>\n *   <li><a href=\"http://www.ietf.org/rfc/rfc5746.txt\">RFC5746</a></li>\n *   <li><a href=\"http://www.oracle.com/technetwork/java/javase/documentation/tlsreadme2-176330.html\">Phased\n *       Approach to Fixing the TLS Renegotiation Issue</a></li>\n * </ul>\n *\n * <h3>Closing the session</h3>\n * <p>\n * To close the SSL session, the {@link #close()} method should be\n * called to send the {@code close_notify} message to the remote peer.  One\n * exception is when you close the {@link Channel} - {@link SslHandler}\n * intercepts the close request and send the {@code close_notify} message\n * before the channel closure automatically.  Once the SSL session is closed,\n * it is not reusable, and consequently you should create a new\n * {@link SslHandler} with a new {@link SSLEngine} as explained in the\n * following section.\n *\n * <h3>Restarting the session</h3>\n * <p>\n * To restart the SSL session, you must remove the existing closed\n * {@link SslHandler} from the {@link ChannelPipeline}, insert a new\n * {@link SslHandler} with a new {@link SSLEngine} into the pipeline,\n * and start the handshake process as described in the first section.\n *\n * <h3>Implementing StartTLS</h3>\n * <p>\n * <a href=\"http://en.wikipedia.org/wiki/STARTTLS\">StartTLS</a> is the\n * communication pattern that secures the wire in the middle of the plaintext\n * connection.  Please note that it is different from SSL &middot; TLS, that\n * secures the wire from the beginning of the connection.  Typically, StartTLS\n * is composed of three steps:\n * <ol>\n * <li>Client sends a StartTLS request to server.</li>\n * <li>Server sends a StartTLS response to client.</li>\n * <li>Client begins SSL handshake.</li>\n * </ol>\n * If you implement a server, you need to:\n * <ol>\n * <li>create a new {@link SslHandler} instance with {@code startTls} flag set\n *     to {@code true},</li>\n * <li>insert the {@link SslHandler} to the {@link ChannelPipeline}, and</li>\n * <li>write a StartTLS response.</li>\n * </ol>\n * Please note that you must insert {@link SslHandler} <em>before</em> sending\n * the StartTLS response.  Otherwise the client can send begin SSL handshake\n * before {@link SslHandler} is inserted to the {@link ChannelPipeline}, causing\n * data corruption.\n * <p>\n * The client-side implementation is much simpler.\n * <ol>\n * <li>Write a StartTLS request,</li>\n * <li>wait for the StartTLS response,</li>\n * <li>create a new {@link SslHandler} instance with {@code startTls} flag set\n *     to {@code false},</li>\n * <li>insert the {@link SslHandler} to the {@link ChannelPipeline}, and</li>\n * <li>Initiate SSL handshake by calling {@link SslHandler#handshake()}.</li>\n * </ol>\n *\n * <h3>Known issues</h3>\n * <p>\n * Because of a known issue with the current implementation of the SslEngine that comes\n * with Java it may be possible that you see blocked IO-Threads while a full GC is done.\n * <p>\n * So if you are affected you can workaround this problem by adjust the cache settings\n * like shown below:\n *\n * <pre>\n *     SslContext context = ...;\n *     context.getServerSessionContext().setSessionCacheSize(someSaneSize);\n *     context.getServerSessionContext().setSessionTime(someSameTimeout);\n * </pre>\n * <p>\n * What values to use here depends on the nature of your application and should be set\n * based on monitoring and debugging of it.\n * For more details see\n * <a href=\"https://github.com/netty/netty/issues/832\">#832</a> in our issue tracker.\n * @apiviz.landmark\n * @apiviz.uses org.jboss.netty.handler.ssl.SslBufferPool\n */\npublic class SslHandler extends FrameDecoder\n                        implements ChannelDownstreamHandler {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(SslHandler.class);\n\n    private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);\n\n    private static final Pattern IGNORABLE_CLASS_IN_STACK = Pattern.compile(\n            \"^.*(?:Socket|Datagram|Sctp|Udt)Channel.*$\");\n    private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(\n            \"^.*(?:connection.*(?:reset|closed|abort|broken)|broken.*pipe).*$\", Pattern.CASE_INSENSITIVE);\n\n    private static SslBufferPool defaultBufferPool;\n\n    /**\n     * Returns the default {@link SslBufferPool} used when no pool is\n     * specified in the constructor.\n     */\n    public static synchronized SslBufferPool getDefaultBufferPool() {\n        if (defaultBufferPool == null) {\n            defaultBufferPool = new SslBufferPool();\n        }\n        return defaultBufferPool;\n    }\n\n    private volatile ChannelHandlerContext ctx;\n    private final SSLEngine engine;\n    private final SslBufferPool bufferPool;\n    private final Executor delegatedTaskExecutor;\n    private final boolean startTls;\n\n    private volatile boolean enableRenegotiation = true;\n\n    final Object handshakeLock = new Object();\n    private boolean handshaking;\n    private volatile boolean handshaken;\n    private volatile ChannelFuture handshakeFuture;\n\n    @SuppressWarnings(\"UnusedDeclaration\")\n    private volatile int sentFirstMessage;\n    @SuppressWarnings(\"UnusedDeclaration\")\n    private volatile int sentCloseNotify;\n    @SuppressWarnings(\"UnusedDeclaration\")\n    private volatile int closedOutboundAndChannel;\n\n    private static final AtomicIntegerFieldUpdater<SslHandler> SENT_FIRST_MESSAGE_UPDATER =\n            AtomicIntegerFieldUpdater.newUpdater(SslHandler.class, \"sentFirstMessage\");\n    private static final AtomicIntegerFieldUpdater<SslHandler> SENT_CLOSE_NOTIFY_UPDATER =\n            AtomicIntegerFieldUpdater.newUpdater(SslHandler.class, \"sentCloseNotify\");\n    private static final AtomicIntegerFieldUpdater<SslHandler> CLOSED_OUTBOUND_AND_CHANNEL_UPDATER =\n            AtomicIntegerFieldUpdater.newUpdater(SslHandler.class, \"closedOutboundAndChannel\");\n\n    int ignoreClosedChannelException;\n    final Object ignoreClosedChannelExceptionLock = new Object();\n    private final Queue<PendingWrite> pendingUnencryptedWrites = new LinkedList<PendingWrite>();\n    private final NonReentrantLock pendingUnencryptedWritesLock = new NonReentrantLock();\n    private final Queue<MessageEvent> pendingEncryptedWrites = new ConcurrentLinkedQueue<MessageEvent>();\n    private final NonReentrantLock pendingEncryptedWritesLock = new NonReentrantLock();\n\n    private volatile boolean issueHandshake;\n    private volatile boolean writeBeforeHandshakeDone;\n    private final SSLEngineInboundCloseFuture sslEngineCloseFuture = new SSLEngineInboundCloseFuture();\n\n    private boolean closeOnSslException;\n\n    private int packetLength;\n\n    private final Timer timer;\n    private final long handshakeTimeoutInMillis;\n    private Timeout handshakeTimeout;\n\n    /**\n     * Creates a new instance.\n     *\n     * @param engine  the {@link SSLEngine} this handler will use\n     */\n    public SslHandler(SSLEngine engine) {\n        this(engine, getDefaultBufferPool(), false, null, 0);\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param engine      the {@link SSLEngine} this handler will use\n     * @param bufferPool  the {@link SslBufferPool} where this handler will\n     *                    acquire the buffers required by the {@link SSLEngine}\n     */\n    public SslHandler(SSLEngine engine, SslBufferPool bufferPool) {\n        this(engine, bufferPool, false, null, 0);\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param engine    the {@link SSLEngine} this handler will use\n     * @param startTls  {@code true} if the first write request shouldn't be\n     *                  encrypted by the {@link SSLEngine}\n     */\n    public SslHandler(SSLEngine engine, boolean startTls) {\n        this(engine, getDefaultBufferPool(), startTls);\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param engine      the {@link SSLEngine} this handler will use\n     * @param bufferPool  the {@link SslBufferPool} where this handler will\n     *                    acquire the buffers required by the {@link SSLEngine}\n     * @param startTls    {@code true} if the first write request shouldn't be\n     *                    encrypted by the {@link SSLEngine}\n     */\n    public SslHandler(SSLEngine engine, SslBufferPool bufferPool, boolean startTls) {\n        this(engine, bufferPool, startTls, null, 0);\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param engine\n     *        the {@link SSLEngine} this handler will use\n     * @param bufferPool\n     *        the {@link SslBufferPool} where this handler will acquire\n     *        the buffers required by the {@link SSLEngine}\n     * @param startTls\n     *        {@code true} if the first write request shouldn't be encrypted\n     *        by the {@link SSLEngine}\n     * @param timer\n     *        the {@link Timer} which will be used to process the timeout of the {@link #handshake()}.\n     *        Be aware that the given {@link Timer} will not get stopped automaticly, so it is up to you to cleanup\n     *        once you not need it anymore\n     * @param handshakeTimeoutInMillis\n     *        the time in milliseconds after whic the {@link #handshake()}  will be failed, and so the future notified\n     */\n    @SuppressWarnings(\"deprecation\")\n    public SslHandler(SSLEngine engine, SslBufferPool bufferPool, boolean startTls,\n                      Timer timer, long handshakeTimeoutInMillis) {\n        this(engine, bufferPool, startTls, ImmediateExecutor.INSTANCE, timer, handshakeTimeoutInMillis);\n    }\n\n    /**\n     * @deprecated Use {@link #SslHandler(SSLEngine)} instead.\n     */\n    @Deprecated\n    public SslHandler(SSLEngine engine, Executor delegatedTaskExecutor) {\n        this(engine, getDefaultBufferPool(), delegatedTaskExecutor);\n    }\n\n    /**\n     * @deprecated Use {@link #SslHandler(SSLEngine, boolean)} instead.\n     */\n    @Deprecated\n    public SslHandler(SSLEngine engine, SslBufferPool bufferPool, Executor delegatedTaskExecutor) {\n        this(engine, bufferPool, false, delegatedTaskExecutor);\n    }\n\n    /**\n     * @deprecated  Use {@link #SslHandler(SSLEngine, boolean)} instead.\n     */\n    @Deprecated\n    public SslHandler(SSLEngine engine, boolean startTls, Executor delegatedTaskExecutor) {\n        this(engine, getDefaultBufferPool(), startTls, delegatedTaskExecutor);\n    }\n\n    /**\n     * @deprecated Use {@link #SslHandler(SSLEngine, SslBufferPool, boolean)} instead.\n     */\n    @Deprecated\n    public SslHandler(SSLEngine engine, SslBufferPool bufferPool, boolean startTls, Executor delegatedTaskExecutor) {\n        this(engine, bufferPool, startTls, delegatedTaskExecutor, null, 0);\n    }\n\n    /**\n     * @deprecated Use {@link #SslHandler(SSLEngine engine, SslBufferPool bufferPool, boolean startTls, Timer timer,\n     *             long handshakeTimeoutInMillis)} instead.\n     */\n    @Deprecated\n    public SslHandler(SSLEngine engine, SslBufferPool bufferPool, boolean startTls, Executor delegatedTaskExecutor,\n                      Timer timer, long handshakeTimeoutInMillis) {\n        if (engine == null) {\n            throw new NullPointerException(\"engine\");\n        }\n        if (bufferPool == null) {\n            throw new NullPointerException(\"bufferPool\");\n        }\n        if (delegatedTaskExecutor == null) {\n            throw new NullPointerException(\"delegatedTaskExecutor\");\n        }\n        if (timer == null && handshakeTimeoutInMillis > 0) {\n            throw new IllegalArgumentException(\"No Timer was given but a handshakeTimeoutInMillis, need both or none\");\n        }\n\n        this.engine = engine;\n        this.bufferPool = bufferPool;\n        this.delegatedTaskExecutor = delegatedTaskExecutor;\n        this.startTls = startTls;\n        this.timer = timer;\n        this.handshakeTimeoutInMillis = handshakeTimeoutInMillis;\n    }\n\n    /**\n     * Returns the {@link SSLEngine} which is used by this handler.\n     */\n    public SSLEngine getEngine() {\n        return engine;\n    }\n\n    /**\n     * Starts an SSL / TLS handshake for the specified channel.\n     *\n     * @return a {@link ChannelFuture} which is notified when the handshake\n     *         succeeds or fails.\n     */\n    public ChannelFuture handshake() {\n        synchronized (handshakeLock) {\n            if (handshaken && !isEnableRenegotiation()) {\n                throw new IllegalStateException(\"renegotiation disabled\");\n            }\n\n            final ChannelHandlerContext ctx = this.ctx;\n            final Channel channel = ctx.getChannel();\n            ChannelFuture handshakeFuture;\n            Exception exception = null;\n\n            if (handshaking) {\n                return this.handshakeFuture;\n            }\n\n            handshaking = true;\n            try {\n                engine.beginHandshake();\n                runDelegatedTasks();\n                handshakeFuture = this.handshakeFuture = future(channel);\n                if (handshakeTimeoutInMillis > 0) {\n                    handshakeTimeout = timer.newTimeout(new TimerTask() {\n                            public void run(Timeout timeout) throws Exception {\n                            ChannelFuture future = SslHandler.this.handshakeFuture;\n                            if (future != null && future.isDone()) {\n                                return;\n                            }\n\n                            setHandshakeFailure(channel, new SSLException(\"Handshake did not complete within \" +\n                                            handshakeTimeoutInMillis + \"ms\"));\n                        }\n                        }, handshakeTimeoutInMillis, TimeUnit.MILLISECONDS);\n                }\n            } catch (Exception e) {\n                handshakeFuture = this.handshakeFuture = failedFuture(channel, e);\n                exception = e;\n            }\n\n            if (exception == null) { // Began handshake successfully.\n                try {\n                    final ChannelFuture hsFuture = handshakeFuture;\n                    wrapNonAppData(ctx, channel).addListener(new ChannelFutureListener() {\n                        public void operationComplete(ChannelFuture future) throws Exception {\n                            if (!future.isSuccess()) {\n                                Throwable cause = future.getCause();\n                                hsFuture.setFailure(cause);\n\n                                fireExceptionCaught(ctx, cause);\n                                if (closeOnSslException) {\n                                    Channels.close(ctx, future(channel));\n                                }\n                            }\n                        }\n                    });\n                } catch (SSLException e) {\n                    handshakeFuture.setFailure(e);\n\n                    fireExceptionCaught(ctx, e);\n                    if (closeOnSslException) {\n                        Channels.close(ctx, future(channel));\n                    }\n                }\n            } else { // Failed to initiate handshake.\n                fireExceptionCaught(ctx, exception);\n                if (closeOnSslException) {\n                    Channels.close(ctx, future(channel));\n                }\n            }\n            return handshakeFuture;\n        }\n    }\n\n    /**\n     * @deprecated Use {@link #handshake()} instead.\n     */\n    @Deprecated\n    public ChannelFuture handshake(@SuppressWarnings(\"unused\") Channel channel) {\n        return handshake();\n    }\n\n    /**\n     * Sends an SSL {@code close_notify} message to the specified channel and\n     * destroys the underlying {@link SSLEngine}.\n     */\n    public ChannelFuture close() {\n        ChannelHandlerContext ctx = this.ctx;\n        Channel channel = ctx.getChannel();\n        try {\n            engine.closeOutbound();\n            return wrapNonAppData(ctx, channel);\n        } catch (SSLException e) {\n            fireExceptionCaught(ctx, e);\n            if (closeOnSslException) {\n                Channels.close(ctx, future(channel));\n            }\n            return failedFuture(channel, e);\n        }\n    }\n\n    /**\n     * @deprecated Use {@link #close()} instead.\n     */\n    @Deprecated\n    public ChannelFuture close(@SuppressWarnings(\"unused\") Channel channel) {\n        return close();\n    }\n\n    /**\n     * Returns {@code true} if and only if TLS renegotiation is enabled.\n     */\n    public boolean isEnableRenegotiation() {\n        return enableRenegotiation;\n    }\n\n    /**\n     * Enables or disables TLS renegotiation.\n     */\n    public void setEnableRenegotiation(boolean enableRenegotiation) {\n        this.enableRenegotiation = enableRenegotiation;\n    }\n\n    /**\n     * Enables or disables the automatic handshake once the {@link Channel} is\n     * connected. The value will only have affect if its set before the\n     * {@link Channel} is connected.\n     */\n    public void setIssueHandshake(boolean issueHandshake) {\n        this.issueHandshake = issueHandshake;\n    }\n\n    /**\n     * Returns {@code true} if the automatic handshake is enabled\n     */\n    public boolean isIssueHandshake() {\n        return issueHandshake;\n    }\n\n    /**\n     * Return the {@link ChannelFuture} that will get notified if the inbound of the {@link SSLEngine} will get closed.\n     *\n     * This method will return the same {@link ChannelFuture} all the time.\n     *\n     * For more informations see the apidocs of {@link SSLEngine}\n     *\n     */\n    public ChannelFuture getSSLEngineInboundCloseFuture() {\n        return sslEngineCloseFuture;\n    }\n\n    /**\n     * Return the timeout (in ms) after which the {@link ChannelFuture} of {@link #handshake()} will be failed, while\n     * a handshake is in progress\n     */\n    public long getHandshakeTimeout() {\n        return handshakeTimeoutInMillis;\n    }\n\n    /**\n     * If set to {@code true}, the {@link Channel} will automatically get closed\n     * one a {@link SSLException} was caught. This is most times what you want, as after this\n     * its almost impossible to recover.\n     *\n     * Anyway the default is {@code false} to not break compatibility with older releases. This\n     * will be changed to {@code true} in the next major release.\n     *\n     */\n    public void setCloseOnSSLException(boolean closeOnSslException) {\n        if (ctx != null) {\n            throw new IllegalStateException(\"Can only get changed before attached to ChannelPipeline\");\n        }\n        this.closeOnSslException = closeOnSslException;\n    }\n\n    public boolean getCloseOnSSLException() {\n        return closeOnSslException;\n    }\n\n    public void handleDownstream(\n            final ChannelHandlerContext context, final ChannelEvent evt) throws Exception {\n        if (evt instanceof ChannelStateEvent) {\n            ChannelStateEvent e = (ChannelStateEvent) evt;\n            switch (e.getState()) {\n            case OPEN:\n            case CONNECTED:\n            case BOUND:\n                if (Boolean.FALSE.equals(e.getValue()) || e.getValue() == null) {\n                    closeOutboundAndChannel(context, e);\n                    return;\n                }\n            }\n        }\n        if (!(evt instanceof MessageEvent)) {\n            context.sendDownstream(evt);\n            return;\n        }\n\n        MessageEvent e = (MessageEvent) evt;\n        if (!(e.getMessage() instanceof ChannelBuffer)) {\n            context.sendDownstream(evt);\n            return;\n        }\n\n        // Do not encrypt the first write request if this handler is\n        // created with startTLS flag turned on.\n        if (startTls && SENT_FIRST_MESSAGE_UPDATER.compareAndSet(this, 0, 1)) {\n            context.sendDownstream(evt);\n            return;\n        }\n\n        // Otherwise, all messages are encrypted.\n        ChannelBuffer msg = (ChannelBuffer) e.getMessage();\n        PendingWrite pendingWrite;\n\n        if (msg.readable()) {\n            pendingWrite = new PendingWrite(evt.getFuture(), msg.toByteBuffer(msg.readerIndex(), msg.readableBytes()));\n        } else {\n            pendingWrite = new PendingWrite(evt.getFuture(), null);\n        }\n\n        pendingUnencryptedWritesLock.lock();\n        try {\n            pendingUnencryptedWrites.add(pendingWrite);\n        } finally {\n            pendingUnencryptedWritesLock.unlock();\n        }\n\n        if (handshakeFuture == null || !handshakeFuture.isDone()) {\n            writeBeforeHandshakeDone = true;\n        }\n        wrap(context, evt.getChannel());\n    }\n\n    private void cancelHandshakeTimeout() {\n        if (handshakeTimeout != null) {\n            // cancel the task as we will fail the handshake future now\n            handshakeTimeout.cancel();\n        }\n    }\n\n    @Override\n    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n\n        // Make sure the handshake future is notified when a connection has\n        // been closed during handshake.\n        synchronized (handshakeLock) {\n            if (handshaking) {\n                cancelHandshakeTimeout();\n                handshakeFuture.setFailure(new ClosedChannelException());\n            }\n        }\n\n        try {\n            super.channelDisconnected(ctx, e);\n        } finally {\n            unwrapNonAppData(ctx, e.getChannel());\n            closeEngine();\n        }\n    }\n\n    private void closeEngine() {\n        engine.closeOutbound();\n        if (sentCloseNotify == 0 && handshaken) {\n            try {\n                engine.closeInbound();\n            } catch (SSLException ex) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Failed to clean up SSLEngine.\", ex);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)\n            throws Exception {\n\n        Throwable cause = e.getCause();\n        if (cause instanceof IOException) {\n            if (cause instanceof ClosedChannelException) {\n                synchronized (ignoreClosedChannelExceptionLock) {\n                    if (ignoreClosedChannelException > 0) {\n                        ignoreClosedChannelException --;\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\n                                    \"Swallowing an exception raised while \" +\n                                    \"writing non-app data\", cause);\n                        }\n\n                        return;\n                    }\n                }\n            } else {\n                if (ignoreException(cause)) {\n                    return;\n                }\n            }\n        }\n\n        ctx.sendUpstream(e);\n    }\n\n    /**\n     * Checks if the given {@link Throwable} can be ignore and just \"swallowed\"\n     *\n     * When an ssl connection is closed a close_notify message is sent.\n     * After that the peer also sends close_notify however, it's not mandatory to receive\n     * the close_notify. The party who sent the initial close_notify can close the connection immediately\n     * then the peer will get connection reset error.\n     *\n     */\n    private boolean ignoreException(Throwable t) {\n        if (!(t instanceof SSLException) && t instanceof IOException && engine.isOutboundDone()) {\n            String message = String.valueOf(t.getMessage()).toLowerCase();\n\n            // first try to match connection reset / broke peer based on the regex. This is the fastest way\n            // but may fail on different jdk impls or OS's\n            if (IGNORABLE_ERROR_MESSAGE.matcher(message).matches()) {\n                return true;\n            }\n\n            // Inspect the StackTraceElements to see if it was a connection reset / broken pipe or not\n            StackTraceElement[] elements = t.getStackTrace();\n            for (StackTraceElement element: elements) {\n                String classname = element.getClassName();\n                String methodname = element.getMethodName();\n\n                // skip all classes that belong to the io.netty package\n                if (classname.startsWith(\"org.jboss.netty.\")) {\n                    continue;\n                }\n\n                // check if the method name is read if not skip it\n                if (!\"read\".equals(methodname)) {\n                    continue;\n                }\n\n                // This will also match against SocketInputStream which is used by openjdk 7 and maybe\n                // also others\n                if (IGNORABLE_CLASS_IN_STACK.matcher(classname).matches()) {\n                    return true;\n                }\n\n                try {\n                    // No match by now.. Try to load the class via classloader and inspect it.\n                    // This is mainly done as other JDK implementations may differ in name of\n                    // the impl.\n                    Class<?> clazz = getClass().getClassLoader().loadClass(classname);\n\n                    if (SocketChannel.class.isAssignableFrom(clazz)\n                            || DatagramChannel.class.isAssignableFrom(clazz)) {\n                        return true;\n                    }\n\n                    // also match against SctpChannel via String matching as it may not present.\n                    if (DetectionUtil.javaVersion() >= 7\n                            && \"com.sun.nio.sctp.SctpChannel\".equals(clazz.getSuperclass().getName())) {\n                        return true;\n                    }\n                } catch (ClassNotFoundException e) {\n                    // This should not happen just ignore\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns {@code true} if the given {@link ChannelBuffer} is encrypted. Be aware that this method\n     * will not increase the readerIndex of the given {@link ChannelBuffer}.\n     *\n     * @param   buffer\n     *                  The {@link ChannelBuffer} to read from. Be aware that it must have at least 5 bytes to read,\n     *                  otherwise it will throw an {@link IllegalArgumentException}.\n     * @return encrypted\n     *                  {@code true} if the {@link ChannelBuffer} is encrypted, {@code false} otherwise.\n     * @throws IllegalArgumentException\n     *                  Is thrown if the given {@link ChannelBuffer} has not at least 5 bytes to read.\n     */\n    public static boolean isEncrypted(ChannelBuffer buffer) {\n        return getEncryptedPacketLength(buffer, buffer.readerIndex()) != -1;\n    }\n\n    /**\n     * Return how much bytes can be read out of the encrypted data. Be aware that this method will not increase\n     * the readerIndex of the given {@link ChannelBuffer}.\n     *\n     * @param   buffer\n     *                  The {@link ChannelBuffer} to read from. Be aware that it must have at least 5 bytes to read,\n     *                  otherwise it will throw an {@link IllegalArgumentException}.\n     * @return length\n     *                  The length of the encrypted packet that is included in the buffer. This will\n     *                  return {@code -1} if the given {@link ChannelBuffer} is not encrypted at all.\n     * @throws IllegalArgumentException\n     *                  Is thrown if the given {@link ChannelBuffer} has not at least 5 bytes to read.\n     */\n    private static int getEncryptedPacketLength(ChannelBuffer buffer, int offset) {\n        int packetLength = 0;\n\n        // SSLv3 or TLS - Check ContentType\n        boolean tls;\n        switch (buffer.getUnsignedByte(offset)) {\n            case 20:  // change_cipher_spec\n            case 21:  // alert\n            case 22:  // handshake\n            case 23:  // application_data\n                tls = true;\n                break;\n            default:\n                // SSLv2 or bad data\n                tls = false;\n        }\n\n        if (tls) {\n            // SSLv3 or TLS - Check ProtocolVersion\n            int majorVersion = buffer.getUnsignedByte(offset + 1);\n            if (majorVersion == 3) {\n                // SSLv3 or TLS\n                packetLength = (getShort(buffer, offset + 3) & 0xFFFF) + 5;\n                if (packetLength <= 5) {\n                    // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                    tls = false;\n                }\n            } else {\n                // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                tls = false;\n            }\n        }\n\n        if (!tls) {\n            // SSLv2 or bad data - Check the version\n            boolean sslv2 = true;\n            int headerLength = (buffer.getUnsignedByte(offset) & 0x80) != 0 ? 2 : 3;\n            int majorVersion = buffer.getUnsignedByte(offset + headerLength + 1);\n            if (majorVersion == 2 || majorVersion == 3) {\n                // SSLv2\n                if (headerLength == 2) {\n                    packetLength = (getShort(buffer, offset) & 0x7FFF) + 2;\n                } else {\n                    packetLength = (getShort(buffer, offset) & 0x3FFF) + 3;\n                }\n                if (packetLength <= headerLength) {\n                    sslv2 = false;\n                }\n            } else {\n                sslv2 = false;\n            }\n\n            if (!sslv2) {\n                return -1;\n            }\n        }\n        return packetLength;\n    }\n\n    @Override\n    protected Object decode(\n            final ChannelHandlerContext ctx, Channel channel, ChannelBuffer in) throws Exception {\n\n        final int startOffset = in.readerIndex();\n        final int endOffset = in.writerIndex();\n        int offset = startOffset;\n        int totalLength = 0;\n\n        // If we calculated the length of the current SSL record before, use that information.\n        if (packetLength > 0) {\n            if (endOffset - startOffset < packetLength) {\n                return null;\n            } else {\n                offset += packetLength;\n                totalLength = packetLength;\n                packetLength = 0;\n            }\n        }\n\n        boolean nonSslRecord = false;\n\n        while (totalLength < OpenSslEngine.MAX_ENCRYPTED_PACKET_LENGTH) {\n            final int readableBytes = endOffset - offset;\n            if (readableBytes < 5) {\n                break;\n            }\n\n            final int packetLength = getEncryptedPacketLength(in, offset);\n            if (packetLength == -1) {\n                nonSslRecord = true;\n                break;\n            }\n\n            assert packetLength > 0;\n\n            if (packetLength > readableBytes) {\n                // wait until the whole packet can be read\n                this.packetLength = packetLength;\n                break;\n            }\n\n            int newTotalLength = totalLength + packetLength;\n            if (newTotalLength > OpenSslEngine.MAX_ENCRYPTED_PACKET_LENGTH) {\n                // Don't read too much.\n                break;\n            }\n\n            // We have a whole packet.\n            // Increment the offset to handle the next packet.\n            offset += packetLength;\n            totalLength = newTotalLength;\n        }\n\n        ChannelBuffer unwrapped = null;\n        if (totalLength > 0) {\n            // The buffer contains one or more full SSL records.\n            // Slice out the whole packet so unwrap will only be called with complete packets.\n            // Also directly reset the packetLength. This is needed as unwrap(..) may trigger\n            // decode(...) again via:\n            // 1) unwrap(..) is called\n            // 2) wrap(...) is called from within unwrap(...)\n            // 3) wrap(...) calls unwrapLater(...)\n            // 4) unwrapLater(...) calls decode(...)\n            //\n            // See https://github.com/netty/netty/issues/1534\n\n            final ByteBuffer inNetBuf = in.toByteBuffer(in.readerIndex(), totalLength);\n            unwrapped = unwrap(ctx, channel, in, inNetBuf, totalLength);\n            assert !inNetBuf.hasRemaining() || engine.isInboundDone();\n        }\n\n        if (nonSslRecord) {\n            // Not an SSL/TLS packet\n            NotSslRecordException e = new NotSslRecordException(\n                    \"not an SSL/TLS record: \" + ChannelBuffers.hexDump(in));\n            in.skipBytes(in.readableBytes());\n            if (closeOnSslException) {\n                // first trigger the exception and then close the channel\n                fireExceptionCaught(ctx, e);\n                Channels.close(ctx, future(channel));\n\n                // just return null as we closed the channel before, that\n                // will take care of cleanup etc\n                return null;\n            } else {\n                throw e;\n            }\n        }\n\n        return unwrapped;\n    }\n\n    /**\n     * Reads a big-endian short integer from the buffer.  Please note that we do not use\n     * {@link ChannelBuffer#getShort(int)} because it might be a little-endian buffer.\n     */\n    private static short getShort(ChannelBuffer buf, int offset) {\n        return (short) (buf.getByte(offset) << 8 | buf.getByte(offset + 1) & 0xFF);\n    }\n\n    private void wrap(ChannelHandlerContext context, Channel channel) throws SSLException {\n        ChannelBuffer msg;\n        ByteBuffer outNetBuf = bufferPool.acquireBuffer();\n        boolean success = true;\n        boolean offered = false;\n        boolean needsUnwrap = false;\n        PendingWrite pendingWrite = null;\n\n        try {\n            loop:\n            for (;;) {\n                // Acquire a lock to make sure unencrypted data is polled\n                // in order and their encrypted counterpart is offered in\n                // order.\n                pendingUnencryptedWritesLock.lock();\n                try {\n                    pendingWrite = pendingUnencryptedWrites.peek();\n                    if (pendingWrite == null) {\n                        break;\n                    }\n\n                    ByteBuffer outAppBuf = pendingWrite.outAppBuf;\n                    if (outAppBuf == null) {\n                        // A write request with an empty buffer\n                        pendingUnencryptedWrites.remove();\n                        offerEncryptedWriteRequest(\n                                new DownstreamMessageEvent(\n                                        channel, pendingWrite.future,\n                                        ChannelBuffers.EMPTY_BUFFER,\n                                        channel.getRemoteAddress()));\n                        offered = true;\n                    } else {\n                        synchronized (handshakeLock) {\n                            SSLEngineResult result = null;\n                            try {\n                                result = engine.wrap(outAppBuf, outNetBuf);\n                            } finally {\n                                if (!outAppBuf.hasRemaining()) {\n                                    pendingUnencryptedWrites.remove();\n                                }\n                            }\n\n                            if (result.bytesProduced() > 0) {\n                                outNetBuf.flip();\n                                int remaining = outNetBuf.remaining();\n                                msg = ctx.getChannel().getConfig().getBufferFactory().getBuffer(remaining);\n\n                                // Transfer the bytes to the new ChannelBuffer using some safe method that will also\n                                // work with \"non\" heap buffers\n                                //\n                                // See https://github.com/netty/netty/issues/329\n                                msg.writeBytes(outNetBuf);\n                                outNetBuf.clear();\n\n                                ChannelFuture future;\n                                if (pendingWrite.outAppBuf.hasRemaining()) {\n                                    // pendingWrite's future shouldn't be notified if\n                                    // only partial data is written.\n                                    future = succeededFuture(channel);\n                                } else {\n                                    future = pendingWrite.future;\n                                }\n\n                                MessageEvent encryptedWrite = new DownstreamMessageEvent(\n                                        channel, future, msg, channel.getRemoteAddress());\n                                offerEncryptedWriteRequest(encryptedWrite);\n                                offered = true;\n                            } else if (result.getStatus() == Status.CLOSED) {\n                                // SSLEngine has been closed already.\n                                // Any further write attempts should be denied.\n                                success = false;\n                                break;\n                            } else {\n                                final HandshakeStatus handshakeStatus = result.getHandshakeStatus();\n                                handleRenegotiation(handshakeStatus);\n                                switch (handshakeStatus) {\n                                case NEED_WRAP:\n                                    if (outAppBuf.hasRemaining()) {\n                                        break;\n                                    } else {\n                                        break loop;\n                                    }\n                                case NEED_UNWRAP:\n                                    needsUnwrap = true;\n                                    break loop;\n                                case NEED_TASK:\n                                    runDelegatedTasks();\n                                    break;\n                                case FINISHED:\n                                    setHandshakeSuccess(channel);\n                                    if (result.getStatus() == Status.CLOSED) {\n                                        success = false;\n                                    }\n                                    break loop;\n                                case NOT_HANDSHAKING:\n                                    setHandshakeSuccessIfStillHandshaking(channel);\n                                    if (result.getStatus() == Status.CLOSED) {\n                                        success = false;\n                                    }\n                                    break loop;\n                                default:\n                                    throw new IllegalStateException(\n                                            \"Unknown handshake status: \" +\n                                            handshakeStatus);\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    pendingUnencryptedWritesLock.unlock();\n                }\n            }\n        } catch (SSLException e) {\n            success = false;\n            setHandshakeFailure(channel, e);\n            throw e;\n        } finally {\n            bufferPool.releaseBuffer(outNetBuf);\n\n            if (offered) {\n                flushPendingEncryptedWrites(context);\n            }\n\n            if (!success) {\n                IllegalStateException cause =\n                    new IllegalStateException(\"SSLEngine already closed\");\n\n                // Check if we had a pendingWrite in process, if so we need to also notify as otherwise\n                // the ChannelFuture will never get notified\n                if (pendingWrite != null) {\n                    pendingWrite.future.setFailure(cause);\n                }\n\n                // Mark all remaining pending writes as failure if anything\n                // wrong happened before the write requests are wrapped.\n                // Please note that we do not call setFailure while a lock is\n                // acquired, to avoid a potential dead lock.\n                for (;;) {\n                    pendingUnencryptedWritesLock.lock();\n                    try {\n                        pendingWrite = pendingUnencryptedWrites.poll();\n                        if (pendingWrite == null) {\n                            break;\n                        }\n                    } finally {\n                        pendingUnencryptedWritesLock.unlock();\n                    }\n\n                    pendingWrite.future.setFailure(cause);\n                }\n            }\n        }\n\n        if (needsUnwrap) {\n            unwrapNonAppData(ctx, channel);\n        }\n    }\n\n    private void offerEncryptedWriteRequest(MessageEvent encryptedWrite) {\n        final boolean locked = pendingEncryptedWritesLock.tryLock();\n        try {\n            pendingEncryptedWrites.add(encryptedWrite);\n        } finally {\n            if (locked) {\n                pendingEncryptedWritesLock.unlock();\n            }\n        }\n    }\n\n    private void flushPendingEncryptedWrites(ChannelHandlerContext ctx) {\n        while (!pendingEncryptedWrites.isEmpty()) {\n            // Avoid possible dead lock and data integrity issue\n            // which is caused by cross communication between more than one channel\n            // in the same VM.\n            if (!pendingEncryptedWritesLock.tryLock()) {\n                return;\n            }\n\n            try {\n                MessageEvent e;\n                while ((e = pendingEncryptedWrites.poll()) != null) {\n                    ctx.sendDownstream(e);\n                }\n            } finally {\n                pendingEncryptedWritesLock.unlock();\n            }\n\n            // Other thread might have added more elements at this point, so we loop again if the queue got unempty.\n        }\n    }\n\n    private ChannelFuture wrapNonAppData(ChannelHandlerContext ctx, Channel channel) throws SSLException {\n        ChannelFuture future = null;\n        ByteBuffer outNetBuf = bufferPool.acquireBuffer();\n\n        SSLEngineResult result;\n        try {\n            for (;;) {\n                synchronized (handshakeLock) {\n                    result = engine.wrap(EMPTY_BUFFER, outNetBuf);\n                }\n\n                if (result.bytesProduced() > 0) {\n                    outNetBuf.flip();\n                    ChannelBuffer msg =\n                            ctx.getChannel().getConfig().getBufferFactory().getBuffer(outNetBuf.remaining());\n\n                    // Transfer the bytes to the new ChannelBuffer using some safe method that will also\n                    // work with \"non\" heap buffers\n                    //\n                    // See https://github.com/netty/netty/issues/329\n                    msg.writeBytes(outNetBuf);\n                    outNetBuf.clear();\n\n                    future = future(channel);\n                    future.addListener(new ChannelFutureListener() {\n                        public void operationComplete(ChannelFuture future)\n                                throws Exception {\n                            if (future.getCause() instanceof ClosedChannelException) {\n                                synchronized (ignoreClosedChannelExceptionLock) {\n                                    ignoreClosedChannelException ++;\n                                }\n                            }\n                        }\n                    });\n\n                    write(ctx, future, msg);\n                }\n\n                final HandshakeStatus handshakeStatus = result.getHandshakeStatus();\n                handleRenegotiation(handshakeStatus);\n                switch (handshakeStatus) {\n                case FINISHED:\n                    setHandshakeSuccess(channel);\n                    runDelegatedTasks();\n                    break;\n                case NEED_TASK:\n                    runDelegatedTasks();\n                    break;\n                case NEED_UNWRAP:\n                    if (!Thread.holdsLock(handshakeLock)) {\n                        // unwrap shouldn't be called when this method was\n                        // called by unwrap - unwrap will keep running after\n                        // this method returns.\n                        unwrapNonAppData(ctx, channel);\n                    }\n                    break;\n                case NOT_HANDSHAKING:\n                    if (setHandshakeSuccessIfStillHandshaking(channel)) {\n                        runDelegatedTasks();\n                    }\n                    break;\n                case NEED_WRAP:\n                    break;\n                default:\n                    throw new IllegalStateException(\n                            \"Unexpected handshake status: \" + handshakeStatus);\n                }\n\n                if (result.bytesProduced() == 0) {\n                    break;\n                }\n            }\n        } catch (SSLException e) {\n            setHandshakeFailure(channel, e);\n            throw e;\n        } finally {\n            bufferPool.releaseBuffer(outNetBuf);\n        }\n\n        if (future == null) {\n            future = succeededFuture(channel);\n        }\n\n        return future;\n    }\n\n    /**\n     * Calls {@link SSLEngine#unwrap(ByteBuffer, ByteBuffer)} with an empty buffer to handle handshakes, etc.\n     */\n    private void unwrapNonAppData(ChannelHandlerContext ctx, Channel channel) throws SSLException {\n        unwrap(ctx, channel, ChannelBuffers.EMPTY_BUFFER, EMPTY_BUFFER, -1);\n    }\n\n    /**\n     * Unwraps inbound SSL records.\n     */\n    private ChannelBuffer unwrap(\n            ChannelHandlerContext ctx, Channel channel,\n            ChannelBuffer nettyInNetBuf, ByteBuffer nioInNetBuf,\n            int initialNettyOutAppBufCapacity) throws SSLException {\n\n        final int nettyInNetBufStartOffset = nettyInNetBuf.readerIndex();\n        final int nioInNetBufStartOffset = nioInNetBuf.position();\n        final ByteBuffer nioOutAppBuf = bufferPool.acquireBuffer();\n\n        ChannelBuffer nettyOutAppBuf = null;\n\n        try {\n            boolean needsWrap = false;\n            for (;;) {\n                SSLEngineResult result;\n                boolean needsHandshake = false;\n                synchronized (handshakeLock) {\n                    if (!handshaken && !handshaking &&\n                        !engine.getUseClientMode() &&\n                        !engine.isInboundDone() && !engine.isOutboundDone()) {\n                        needsHandshake = true;\n                    }\n                }\n\n                if (needsHandshake) {\n                    handshake();\n                }\n\n                synchronized (handshakeLock) {\n                    // Decrypt at least one record in the inbound network buffer.\n                    // It is impossible to consume no record here because we made sure the inbound network buffer\n                    // always contain at least one record in decode().  Therefore, if SSLEngine.unwrap() returns\n                    // BUFFER_OVERFLOW, it is always resolved by retrying after emptying the application buffer.\n                    for (;;) {\n                        try {\n                            result = engine.unwrap(nioInNetBuf, nioOutAppBuf);\n                            switch (result.getStatus()) {\n                                case CLOSED:\n                                    // notify about the CLOSED state of the SSLEngine. See #137\n                                    sslEngineCloseFuture.setClosed();\n                                    break;\n                                case BUFFER_OVERFLOW:\n                                    // Flush the unwrapped data in the outAppBuf into frame and try again.\n                                    // See the finally block.\n                                    continue;\n                            }\n\n                            break;\n                        } finally {\n                            nioOutAppBuf.flip();\n\n                            // Sync the offset of the inbound buffer.\n                            nettyInNetBuf.readerIndex(\n                                    nettyInNetBufStartOffset + nioInNetBuf.position() - nioInNetBufStartOffset);\n\n                            // Copy the unwrapped data into a smaller buffer.\n                            if (nioOutAppBuf.hasRemaining()) {\n                                if (nettyOutAppBuf == null) {\n                                    ChannelBufferFactory factory = ctx.getChannel().getConfig().getBufferFactory();\n                                    nettyOutAppBuf = factory.getBuffer(initialNettyOutAppBufCapacity);\n                                }\n                                nettyOutAppBuf.writeBytes(nioOutAppBuf);\n                            }\n                            nioOutAppBuf.clear();\n                        }\n                    }\n\n                    final HandshakeStatus handshakeStatus = result.getHandshakeStatus();\n                    handleRenegotiation(handshakeStatus);\n                    switch (handshakeStatus) {\n                    case NEED_UNWRAP:\n                        break;\n                    case NEED_WRAP:\n                        wrapNonAppData(ctx, channel);\n                        break;\n                    case NEED_TASK:\n                        runDelegatedTasks();\n                        break;\n                    case FINISHED:\n                        setHandshakeSuccess(channel);\n                        needsWrap = true;\n                        continue;\n                    case NOT_HANDSHAKING:\n                        if (setHandshakeSuccessIfStillHandshaking(channel)) {\n                            needsWrap = true;\n                            continue;\n                        }\n                        if (writeBeforeHandshakeDone) {\n                            // We need to call wrap(...) in case there was a flush done before the handshake completed.\n                            //\n                            // See https://github.com/netty/netty/pull/2437\n                            writeBeforeHandshakeDone = false;\n                            needsWrap = true;\n                        }\n                        break;\n                    default:\n                        throw new IllegalStateException(\n                                \"Unknown handshake status: \" + handshakeStatus);\n                    }\n\n                    if (result.getStatus() == Status.BUFFER_UNDERFLOW ||\n                        result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n                        break;\n                    }\n                }\n            }\n\n            if (needsWrap) {\n                // wrap() acquires pendingUnencryptedWrites first and then\n                // handshakeLock.  If handshakeLock is already hold by the\n                // current thread, calling wrap() will lead to a dead lock\n                // i.e. pendingUnencryptedWrites -> handshakeLock vs.\n                //      handshakeLock -> pendingUnencryptedLock -> handshakeLock\n                //\n                // There is also the same issue between pendingEncryptedWrites\n                // and pendingUnencryptedWrites.\n                if (!Thread.holdsLock(handshakeLock) && !pendingEncryptedWritesLock.isHeldByCurrentThread()) {\n                    wrap(ctx, channel);\n                }\n            }\n        } catch (SSLException e) {\n            setHandshakeFailure(channel, e);\n            throw e;\n        } finally {\n            bufferPool.releaseBuffer(nioOutAppBuf);\n        }\n\n        if (nettyOutAppBuf != null && nettyOutAppBuf.readable()) {\n            return nettyOutAppBuf;\n        } else {\n            return null;\n        }\n    }\n\n    private void handleRenegotiation(HandshakeStatus handshakeStatus) {\n        synchronized (handshakeLock) {\n            if (handshakeStatus == HandshakeStatus.NOT_HANDSHAKING ||\n                handshakeStatus == HandshakeStatus.FINISHED) {\n                // Not handshaking\n                return;\n            }\n\n            if (!handshaken) {\n                // Not renegotiation\n                return;\n            }\n\n            final boolean renegotiate;\n            if (handshaking) {\n                // Renegotiation in progress or failed already.\n                // i.e. Renegotiation check has been done already below.\n                return;\n            }\n\n            if (engine.isInboundDone() || engine.isOutboundDone()) {\n                // Not handshaking but closing.\n                return;\n            }\n\n            if (isEnableRenegotiation()) {\n                // Continue renegotiation.\n                renegotiate = true;\n            } else {\n                // Do not renegotiate.\n                renegotiate = false;\n                // Prevent reentrance of this method.\n                handshaking = true;\n            }\n\n            if (renegotiate) {\n                // Renegotiate.\n                handshake();\n            } else {\n                // Raise an exception.\n                fireExceptionCaught(\n                        ctx, new SSLException(\n                                \"renegotiation attempted by peer; \" +\n                                \"closing the connection\"));\n\n                // Close the connection to stop renegotiation.\n                Channels.close(ctx, succeededFuture(ctx.getChannel()));\n            }\n        }\n    }\n\n    /**\n     * Fetches all delegated tasks from the {@link SSLEngine} and runs them via the {@link #delegatedTaskExecutor}.\n     * If the {@link #delegatedTaskExecutor} is {@link ImmediateExecutor}, just call {@link Runnable#run()} directly\n     * instead of using {@link Executor#execute(Runnable)}.  Otherwise, run the tasks via\n     * the {@link #delegatedTaskExecutor} and wait until the tasks are finished.\n     */\n    private void runDelegatedTasks() {\n        if (delegatedTaskExecutor == ImmediateExecutor.INSTANCE) {\n            for (;;) {\n                final Runnable task;\n                synchronized (handshakeLock) {\n                    task = engine.getDelegatedTask();\n                }\n\n                if (task == null) {\n                    break;\n                }\n\n                delegatedTaskExecutor.execute(task);\n            }\n        } else {\n            final List<Runnable> tasks = new ArrayList<Runnable>(2);\n            for (;;) {\n                final Runnable task;\n                synchronized (handshakeLock) {\n                    task = engine.getDelegatedTask();\n                }\n\n                if (task == null) {\n                    break;\n                }\n\n                tasks.add(task);\n            }\n\n            if (tasks.isEmpty()) {\n                return;\n            }\n\n            final CountDownLatch latch = new CountDownLatch(1);\n            delegatedTaskExecutor.execute(new Runnable() {\n                public void run() {\n                    try {\n                        for (Runnable task: tasks) {\n                            task.run();\n                        }\n                    } catch (Exception e) {\n                        fireExceptionCaught(ctx, e);\n                    } finally {\n                        latch.countDown();\n                    }\n                }\n            });\n\n            boolean interrupted = false;\n            while (latch.getCount() != 0) {\n                try {\n                    latch.await();\n                } catch (InterruptedException e) {\n                    // Interrupt later.\n                    interrupted = true;\n                }\n            }\n\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    /**\n     * Works around some Android {@link SSLEngine} implementations that skip {@link HandshakeStatus#FINISHED} and\n     * go straight into {@link HandshakeStatus#NOT_HANDSHAKING} when handshake is finished.\n     *\n     * @return {@code true} if and only if the workaround has been applied and thus {@link #handshakeFuture} has been\n     *         marked as success by this method\n     */\n    private boolean setHandshakeSuccessIfStillHandshaking(Channel channel) {\n        if (handshaking && !handshakeFuture.isDone()) {\n            setHandshakeSuccess(channel);\n            return true;\n        }\n        return false;\n    }\n\n    private void setHandshakeSuccess(Channel channel) {\n        synchronized (handshakeLock) {\n            handshaking = false;\n            handshaken = true;\n\n            if (handshakeFuture == null) {\n                handshakeFuture = future(channel);\n            }\n            cancelHandshakeTimeout();\n        }\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(channel + \" HANDSHAKEN: \" + engine.getSession().getCipherSuite());\n        }\n\n        handshakeFuture.setSuccess();\n    }\n\n    private void setHandshakeFailure(Channel channel, SSLException cause) {\n        synchronized (handshakeLock) {\n            if (!handshaking) {\n                return;\n            }\n            handshaking = false;\n            handshaken = false;\n\n            if (handshakeFuture == null) {\n                handshakeFuture = future(channel);\n            }\n\n            // cancel the timeout now\n            cancelHandshakeTimeout();\n\n            // Release all resources such as internal buffers that SSLEngine\n            // is managing.\n\n            engine.closeOutbound();\n\n            try {\n                engine.closeInbound();\n            } catch (SSLException e) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\n                            \"SSLEngine.closeInbound() raised an exception after \" +\n                            \"a handshake failure.\", e);\n                }\n            }\n        }\n\n        handshakeFuture.setFailure(cause);\n        if (closeOnSslException) {\n            Channels.close(ctx, future(channel));\n        }\n    }\n\n    private void closeOutboundAndChannel(\n            final ChannelHandlerContext context, final ChannelStateEvent e) {\n        if (!e.getChannel().isConnected()) {\n            context.sendDownstream(e);\n            return;\n        }\n\n        // Ensure that the tear-down logic beyond this point is never invoked concurrently nor multiple times.\n        if (!CLOSED_OUTBOUND_AND_CHANNEL_UPDATER.compareAndSet(this, 0, 1)) {\n            // The other thread called this method already, and thus the connection will be closed eventually.\n            // So, just wait until the connection is closed, and then forward the event so that the sink handles\n            // the duplicate close attempt.\n            e.getChannel().getCloseFuture().addListener(new ChannelFutureListener() {\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    context.sendDownstream(e);\n                }\n            });\n            return;\n        }\n\n        boolean passthrough = true;\n        try {\n            try {\n                unwrapNonAppData(ctx, e.getChannel());\n            } catch (SSLException ex) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Failed to unwrap before sending a close_notify message\", ex);\n                }\n            }\n\n            if (!engine.isOutboundDone()) {\n                if (SENT_CLOSE_NOTIFY_UPDATER.compareAndSet(this, 0, 1)) {\n                    engine.closeOutbound();\n                    try {\n                        ChannelFuture closeNotifyFuture = wrapNonAppData(context, e.getChannel());\n                        closeNotifyFuture.addListener(\n                                new ClosingChannelFutureListener(context, e));\n                        passthrough = false;\n                    } catch (SSLException ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Failed to encode a close_notify message\", ex);\n                        }\n                    }\n                }\n            }\n        } finally {\n            if (passthrough) {\n                context.sendDownstream(e);\n            }\n        }\n    }\n\n    private static final class PendingWrite {\n        final ChannelFuture future;\n        final ByteBuffer outAppBuf;\n\n        PendingWrite(ChannelFuture future, ByteBuffer outAppBuf) {\n            this.future = future;\n            this.outAppBuf = outAppBuf;\n        }\n    }\n\n    private static final class ClosingChannelFutureListener implements ChannelFutureListener {\n\n        private final ChannelHandlerContext context;\n        private final ChannelStateEvent e;\n\n        ClosingChannelFutureListener(\n                ChannelHandlerContext context, ChannelStateEvent e) {\n            this.context = context;\n            this.e = e;\n        }\n\n        public void operationComplete(ChannelFuture closeNotifyFuture) throws Exception {\n            if (!(closeNotifyFuture.getCause() instanceof ClosedChannelException)) {\n                Channels.close(context, e.getFuture());\n            } else {\n                e.getFuture().setSuccess();\n            }\n        }\n    }\n\n    @Override\n    public void beforeAdd(ChannelHandlerContext ctx) throws Exception {\n        super.beforeAdd(ctx);\n        this.ctx = ctx;\n    }\n\n    /**\n     * Fail all pending writes which we were not able to flush out\n     */\n    @Override\n    public void afterRemove(ChannelHandlerContext ctx) throws Exception {\n        closeEngine();\n\n        // there is no need for synchronization here as we do not receive downstream events anymore\n        Throwable cause = null;\n        for (;;) {\n            PendingWrite pw = pendingUnencryptedWrites.poll();\n            if (pw == null) {\n                break;\n            }\n            if (cause == null) {\n                cause = new IOException(\"Unable to write data\");\n            }\n            pw.future.setFailure(cause);\n        }\n\n        for (;;) {\n            MessageEvent ev = pendingEncryptedWrites.poll();\n            if (ev == null) {\n                break;\n            }\n            if (cause == null) {\n                cause = new IOException(\"Unable to write data\");\n            }\n            ev.getFuture().setFailure(cause);\n        }\n\n        if (cause != null) {\n            fireExceptionCaughtLater(ctx, cause);\n        }\n    }\n\n    /**\n     * Calls {@link #handshake()} once the {@link Channel} is connected\n     */\n    @Override\n    public void channelConnected(final ChannelHandlerContext ctx, final ChannelStateEvent e) throws Exception {\n        if (issueHandshake) {\n            // issue and handshake and add a listener to it which will fire an exception event if\n            // an exception was thrown while doing the handshake\n            handshake().addListener(new ChannelFutureListener() {\n\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    if (future.isSuccess()) {\n                        // Send the event upstream after the handshake was completed without an error.\n                        //\n                        // See https://github.com/netty/netty/issues/358\n                        ctx.sendUpstream(e);\n                    }\n                }\n            });\n        } else {\n            super.channelConnected(ctx, e);\n        }\n    }\n\n    /**\n     * Loop over all the pending writes and fail them.\n     *\n     * See <a href=\"https://github.com/netty/netty/issues/305\">#305</a> for more details.\n     */\n    @Override\n    public void channelClosed(final ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {\n        // Move the fail of the writes to the IO-Thread to prevent possible deadlock\n        // See https://github.com/netty/netty/issues/989\n        ctx.getPipeline().execute(new Runnable() {\n            public void run() {\n                if (!pendingUnencryptedWritesLock.tryLock()) {\n                    return;\n                }\n\n                Throwable cause = null;\n                try {\n                    for (;;) {\n                        PendingWrite pw = pendingUnencryptedWrites.poll();\n                        if (pw == null) {\n                            break;\n                        }\n                        if (cause == null) {\n                            cause = new ClosedChannelException();\n                        }\n                        pw.future.setFailure(cause);\n                    }\n\n                    for (;;) {\n                        MessageEvent ev = pendingEncryptedWrites.poll();\n                        if (ev == null) {\n                            break;\n                        }\n                        if (cause == null) {\n                            cause = new ClosedChannelException();\n                        }\n                        ev.getFuture().setFailure(cause);\n                    }\n                } finally {\n                    pendingUnencryptedWritesLock.unlock();\n                }\n\n                if (cause != null) {\n                    fireExceptionCaught(ctx, cause);\n                }\n            }\n        });\n\n        super.channelClosed(ctx, e);\n    }\n\n    private final class SSLEngineInboundCloseFuture extends DefaultChannelFuture {\n        SSLEngineInboundCloseFuture() {\n            super(null, true);\n        }\n\n        void setClosed() {\n            super.setSuccess();\n        }\n\n        @Override\n        public Channel getChannel() {\n            if (ctx == null) {\n                // Maybe we should better throw an IllegalStateException() ?\n                return null;\n            } else {\n                return ctx.getChannel();\n            }\n        }\n\n        @Override\n        public boolean setSuccess() {\n            return false;\n        }\n\n        @Override\n        public boolean setFailure(Throwable cause) {\n            return false;\n        }\n    }\n}\n", "target": 1}
{"idx": 950, "func": "package org.bouncycastle.pqc.crypto.rainbow;\n\nimport org.bouncycastle.crypto.CipherParameters;\n\npublic class RainbowParameters\n    implements CipherParameters\n{\n\n    /**\n     * DEFAULT PARAMS\n     */\n    /*\n      * Vi = vinegars per layer whereas n is vu (vu = 33 = n) such that\n      *\n      * v1 = 6; o1 = 12-6 = 6\n      *\n      * v2 = 12; o2 = 17-12 = 5\n      *\n      * v3 = 17; o3 = 22-17 = 5\n      *\n      * v4 = 22; o4 = 33-22 = 11\n      *\n      * v5 = 33; (o5 = 0)\n      */\n    private final int[] DEFAULT_VI = {6, 12, 17, 22, 33};\n\n    private int[] vi;// set of vinegar vars per layer.\n\n    /**\n     * Default Constructor The elements of the array containing the number of\n     * Vinegar variables in each layer are set to the default values here.\n     */\n    public RainbowParameters()\n    {\n        this.vi = this.DEFAULT_VI;\n    }\n\n    /**\n     * Constructor with parameters\n     *\n     * @param vi The elements of the array containing the number of Vinegar\n     *           variables per layer are set to the values of the input array.\n     */\n    public RainbowParameters(int[] vi)\n    {\n        this.vi = vi;\n        try\n        {\n            checkParams();\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n\n    private void checkParams()\n        throws Exception\n    {\n        if (vi == null)\n        {\n            throw new Exception(\"no layers defined.\");\n        }\n        if (vi.length > 1)\n        {\n            for (int i = 0; i < vi.length - 1; i++)\n            {\n                if (vi[i] >= vi[i + 1])\n                {\n                    throw new Exception(\n                        \"v[i] has to be smaller than v[i+1]\");\n                }\n            }\n        }\n        else\n        {\n            throw new Exception(\n                \"Rainbow needs at least 1 layer, such that v1 < v2.\");\n        }\n    }\n\n    /**\n     * Getter for the number of layers\n     *\n     * @return the number of layers\n     */\n    public int getNumOfLayers()\n    {\n        return this.vi.length - 1;\n    }\n\n    /**\n     * Getter for the number of all the polynomials in Rainbow\n     *\n     * @return the number of the polynomials\n     */\n    public int getDocLength()\n    {\n        return vi[vi.length - 1] - vi[0];\n    }\n\n    /**\n     * Getter for the array containing the number of Vinegar-variables per layer\n     *\n     * @return the numbers of vinegars per layer\n     */\n    public int[] getVi()\n    {\n        return this.vi;\n    }\n}\n", "target": 1}
{"idx": 951, "func": "package hudson.model;\n\nimport static org.junit.Assert.*;\n\nimport com.gargoylesoftware.htmlunit.html.DomNodeUtil;\nimport com.gargoylesoftware.htmlunit.html.HtmlFormUtil;\nimport org.junit.Rule;\nimport org.junit.Test;\n\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\nimport com.gargoylesoftware.htmlunit.html.HtmlForm;\nimport com.gargoylesoftware.htmlunit.html.HtmlElement;\nimport com.gargoylesoftware.htmlunit.html.HtmlTextInput;\nimport com.gargoylesoftware.htmlunit.html.HtmlCheckBoxInput;\nimport com.gargoylesoftware.htmlunit.html.HtmlOption;\nimport org.jvnet.hudson.test.CaptureEnvironmentBuilder;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.JenkinsRule.WebClient;\n\nimport java.util.Set;\n\n/**\n * @author huybrechts\n */\npublic class ParametersTest {\n\n    @Rule\n    public JenkinsRule j = new JenkinsRule();\n\n    @Test\n    public void parameterTypes() throws Exception {\n        FreeStyleProject otherProject = j.createFreeStyleProject();\n        otherProject.scheduleBuild2(0).get();\n\n        FreeStyleProject project = j.createFreeStyleProject();\n        ParametersDefinitionProperty pdp = new ParametersDefinitionProperty(\n                new StringParameterDefinition(\"string\", \"defaultValue\", \"string description\"),\n                new BooleanParameterDefinition(\"boolean\", true, \"boolean description\"),\n                new ChoiceParameterDefinition(\"choice\", \"Choice 1\\nChoice 2\", \"choice description\"),\n                new RunParameterDefinition(\"run\", otherProject.getName(), \"run description\", null));\n        project.addProperty(pdp);\n        CaptureEnvironmentBuilder builder = new CaptureEnvironmentBuilder();\n        project.getBuildersList().add(builder);\n\n        WebClient wc = j.createWebClient();\n        wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n        HtmlPage page = wc.goTo(\"job/\" + project.getName() + \"/build?delay=0sec\");\n\n        HtmlForm form = page.getFormByName(\"parameters\");\n\n        HtmlElement element = (HtmlElement) DomNodeUtil.selectSingleNode(form, \"//tr[td/div/input/@value='string']\");\n        assertNotNull(element);\n        assertEquals(\"string description\", ((HtmlElement) DomNodeUtil.selectSingleNode(element.getNextSibling().getNextSibling(), \"td[@class='setting-description']\")).getTextContent());\n\n        HtmlTextInput stringParameterInput = (HtmlTextInput) DomNodeUtil.selectSingleNode(element, \".//input[@name='value']\");\n        assertEquals(\"defaultValue\", stringParameterInput.getAttribute(\"value\"));\n        assertEquals(\"string\", ((HtmlElement) DomNodeUtil.selectSingleNode(element, \"td[@class='setting-name']\")).getTextContent());\n        stringParameterInput.setAttribute(\"value\", \"newValue\");\n\n        element = (HtmlElement) DomNodeUtil.selectSingleNode(form, \"//tr[td/div/input/@value='boolean']\");\n        assertNotNull(element);\n        assertEquals(\"boolean description\", ((HtmlElement) DomNodeUtil.selectSingleNode(element.getNextSibling().getNextSibling(), \"td[@class='setting-description']\")).getTextContent());\n        Object o = DomNodeUtil.selectSingleNode(element, \".//input[@name='value']\");\n        System.out.println(o);\n        HtmlCheckBoxInput booleanParameterInput = (HtmlCheckBoxInput) o;\n        assertEquals(true, booleanParameterInput.isChecked());\n        assertEquals(\"boolean\", ((HtmlElement) DomNodeUtil.selectSingleNode(element, \"td[@class='setting-name']\")).getTextContent());\n\n        element = (HtmlElement) DomNodeUtil.selectSingleNode(form, \".//tr[td/div/input/@value='choice']\");\n        assertNotNull(element);\n        assertEquals(\"choice description\", ((HtmlElement) DomNodeUtil.selectSingleNode(element.getNextSibling().getNextSibling(), \"td[@class='setting-description']\")).getTextContent());\n        assertEquals(\"choice\", ((HtmlElement) DomNodeUtil.selectSingleNode(element, \"td[@class='setting-name']\")).getTextContent());\n\n        element = (HtmlElement) DomNodeUtil.selectSingleNode(form, \".//tr[td/div/input/@value='run']\");\n        assertNotNull(element);\n        assertEquals(\"run description\", ((HtmlElement) DomNodeUtil.selectSingleNode(element.getNextSibling().getNextSibling(), \"td[@class='setting-description']\")).getTextContent());\n        assertEquals(\"run\", ((HtmlElement) DomNodeUtil.selectSingleNode(element, \"td[@class='setting-name']\")).getTextContent());\n\n        j.submit(form);\n        Queue.Item q = j.jenkins.getQueue().getItem(project);\n        if (q != null) q.getFuture().get();\n        else Thread.sleep(1000);\n\n        assertEquals(\"newValue\", builder.getEnvVars().get(\"STRING\"));\n        assertEquals(\"true\", builder.getEnvVars().get(\"BOOLEAN\"));\n        assertEquals(\"Choice 1\", builder.getEnvVars().get(\"CHOICE\"));\n        assertEquals(j.jenkins.getRootUrl() + otherProject.getLastBuild().getUrl(), builder.getEnvVars().get(\"RUN\"));\n    }\n\n    @Test\n    public void choiceWithLTGT() throws Exception {\n        FreeStyleProject project = j.createFreeStyleProject();\n        ParametersDefinitionProperty pdp = new ParametersDefinitionProperty(\n                new ChoiceParameterDefinition(\"choice\", \"Choice 1\\nChoice <2>\", \"choice description\"));\n        project.addProperty(pdp);\n        CaptureEnvironmentBuilder builder = new CaptureEnvironmentBuilder();\n        project.getBuildersList().add(builder);\n\n        WebClient wc = j.createWebClient();\n        wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n        HtmlPage page = wc.goTo(\"job/\" + project.getName() + \"/build?delay=0sec\");\n        HtmlForm form = page.getFormByName(\"parameters\");\n\n        HtmlElement element = (HtmlElement) DomNodeUtil.selectSingleNode(form, \".//tr[td/div/input/@value='choice']\");\n        assertNotNull(element);\n        assertEquals(\"choice description\", ((HtmlElement) DomNodeUtil.selectSingleNode(element.getNextSibling().getNextSibling(), \"td[@class='setting-description']\")).getTextContent());\n        assertEquals(\"choice\", ((HtmlElement) DomNodeUtil.selectSingleNode(element, \"td[@class='setting-name']\")).getTextContent());\n        HtmlOption opt = (HtmlOption)DomNodeUtil.selectSingleNode(element, \"td/div/select/option[@value='Choice <2>']\");\n        assertNotNull(opt);\n        assertEquals(\"Choice <2>\", opt.asText());\n        opt.setSelected(true);\n\n        j.submit(form);\n        Queue.Item q = j.jenkins.getQueue().getItem(project);\n        if (q != null) q.getFuture().get();\n        else Thread.sleep(1000);\n\n        assertNotNull(builder.getEnvVars());\n        assertEquals(\"Choice <2>\", builder.getEnvVars().get(\"CHOICE\"));\n    }\n\n    @Test\n    public void sensitiveParameters() throws Exception {\n        FreeStyleProject project = j.createFreeStyleProject();\n        ParametersDefinitionProperty pdb = new ParametersDefinitionProperty(\n                new PasswordParameterDefinition(\"password\", \"12345\", \"password description\"));\n        project.addProperty(pdb);\n\n        CaptureEnvironmentBuilder builder = new CaptureEnvironmentBuilder();\n        project.getBuildersList().add(builder);\n\n        FreeStyleBuild build = project.scheduleBuild2(0).get();\n        Set<String> sensitiveVars = build.getSensitiveBuildVariables();\n\n        assertNotNull(sensitiveVars);\n        assertTrue(sensitiveVars.contains(\"password\"));\n    }\n\n    @Test\n    public void nonSensitiveParameters() throws Exception {\n        FreeStyleProject project = j.createFreeStyleProject();\n        ParametersDefinitionProperty pdb = new ParametersDefinitionProperty(\n                new StringParameterDefinition(\"string\", \"defaultValue\", \"string description\"));\n        project.addProperty(pdb);\n\n        CaptureEnvironmentBuilder builder = new CaptureEnvironmentBuilder();\n        project.getBuildersList().add(builder);\n\n        FreeStyleBuild build = project.scheduleBuild2(0).get();\n        Set<String> sensitiveVars = build.getSensitiveBuildVariables();\n\n        assertNotNull(sensitiveVars);\n        assertFalse(sensitiveVars.contains(\"string\"));\n    }\n\n    @Test\n    public void mixedSensitivity() throws Exception {\n        FreeStyleProject project = j.createFreeStyleProject();\n        ParametersDefinitionProperty pdb = new ParametersDefinitionProperty(\n                new StringParameterDefinition(\"string\", \"defaultValue\", \"string description\"),\n                new PasswordParameterDefinition(\"password\", \"12345\", \"password description\"),\n                new StringParameterDefinition(\"string2\", \"Value2\", \"string description\")\n        );\n        project.addProperty(pdb);\n\n        CaptureEnvironmentBuilder builder = new CaptureEnvironmentBuilder();\n        project.getBuildersList().add(builder);\n\n        FreeStyleBuild build = project.scheduleBuild2(0).get();\n        Set<String> sensitiveVars = build.getSensitiveBuildVariables();\n\n        assertNotNull(sensitiveVars);\n        assertFalse(sensitiveVars.contains(\"string\"));\n        assertTrue(sensitiveVars.contains(\"password\"));\n        assertFalse(sensitiveVars.contains(\"string2\"));\n    }\n\n    @Test\n    @Issue(\"JENKINS-3539\")\n    public void fileParameterNotSet() throws Exception {\n        FreeStyleProject project = j.createFreeStyleProject();\n        ParametersDefinitionProperty pdp = new ParametersDefinitionProperty(\n                new FileParameterDefinition(\"filename\", \"description\"));\n        project.addProperty(pdp);\n\n        WebClient wc = j.createWebClient();\n        wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n        HtmlPage page = wc.goTo(\"job/\" + project.getName() + \"/build?delay=0sec\");\n        HtmlForm form = page.getFormByName(\"parameters\");\n\n        j.submit(form);\n        Queue.Item q = j.jenkins.getQueue().getItem(project);\n        if (q != null) q.getFuture().get();\n        else Thread.sleep(1000);\n\n        assertFalse(\"file must not exist\", project.getSomeWorkspace().child(\"filename\").exists());\n    }\n\n    @Test\n    @Issue(\"JENKINS-11543\")\n    public void unicodeParametersArePresetCorrectly() throws Exception {\n        final FreeStyleProject p = j.createFreeStyleProject();\n        ParametersDefinitionProperty pdb = new ParametersDefinitionProperty(\n                new StringParameterDefinition(\"sname:a\", \"svalue:a\", \"sdesc:a\"),\n                new FileParameterDefinition(\"fname:a\", \"fdesc:a\")\n        );\n        p.addProperty(pdb);\n\n        WebClient wc = j.createWebClient();\n        wc.getOptions().setThrowExceptionOnFailingStatusCode(false); // Ignore 405\n        HtmlPage page = wc.getPage(p, \"build\");\n\n        // java.lang.IllegalArgumentException: No such parameter definition: <gibberish>.\n        wc.getOptions().setThrowExceptionOnFailingStatusCode(true);\n        final HtmlForm form = page.getFormByName(\"parameters\");\n        HtmlFormUtil.submit(form, HtmlFormUtil.getButtonByCaption(form, \"Build\"));\n    }\n}\n", "target": 1}
{"idx": 952, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.services.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.concurrent.ConcurrentSkipListSet;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiPredicate;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.stream.Collectors;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.common.AuthorizationSetupHelper;\nimport com.vmware.xenon.common.CommandLineArgumentParser;\nimport com.vmware.xenon.common.FactoryService;\nimport com.vmware.xenon.common.NodeSelectorService.SelectAndForwardRequest;\nimport com.vmware.xenon.common.NodeSelectorService.SelectOwnerResponse;\nimport com.vmware.xenon.common.NodeSelectorState;\nimport com.vmware.xenon.common.Operation;\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.OperationJoin;\nimport com.vmware.xenon.common.Service;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.Service.ProcessingStage;\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceConfigUpdateRequest;\nimport com.vmware.xenon.common.ServiceConfiguration;\nimport com.vmware.xenon.common.ServiceDocument;\nimport com.vmware.xenon.common.ServiceDocumentDescription;\nimport com.vmware.xenon.common.ServiceDocumentQueryResult;\nimport com.vmware.xenon.common.ServiceHost;\nimport com.vmware.xenon.common.ServiceHost.HttpScheme;\nimport com.vmware.xenon.common.ServiceHost.ServiceHostState;\nimport com.vmware.xenon.common.ServiceStats;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.StatefulService;\nimport com.vmware.xenon.common.SynchronizationTaskService;\nimport com.vmware.xenon.common.TaskState;\nimport com.vmware.xenon.common.UriUtils;\nimport com.vmware.xenon.common.Utils;\nimport com.vmware.xenon.common.serialization.KryoSerializers;\nimport com.vmware.xenon.common.test.AuthorizationHelper;\nimport com.vmware.xenon.common.test.MinimalTestServiceState;\nimport com.vmware.xenon.common.test.RoundRobinIterator;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestProperty;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.common.test.VerificationHost.WaitHandler;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.ExampleTaskService.ExampleTaskServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService.MinimalTestServiceErrorResponse;\nimport com.vmware.xenon.services.common.NodeGroupBroadcastResult.PeerNodeResult;\nimport com.vmware.xenon.services.common.NodeGroupService.JoinPeerRequest;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupConfig;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupState;\nimport com.vmware.xenon.services.common.NodeState.NodeOption;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Builder;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.ReplicationTestService.ReplicationTestServiceErrorResponse;\nimport com.vmware.xenon.services.common.ReplicationTestService.ReplicationTestServiceState;\nimport com.vmware.xenon.services.common.ResourceGroupService.PatchQueryRequest;\nimport com.vmware.xenon.services.common.ResourceGroupService.ResourceGroupState;\nimport com.vmware.xenon.services.common.RoleService.RoleState;\nimport com.vmware.xenon.services.common.UserService.UserState;\n\npublic class TestNodeGroupService {\n\n    public static class PeriodicExampleFactoryService extends FactoryService {\n        public static final String SELF_LINK = \"test/examples-periodic\";\n\n        public PeriodicExampleFactoryService() {\n            super(ExampleServiceState.class);\n        }\n\n        @Override\n        public Service createServiceInstance() throws Throwable {\n            ExampleService s = new ExampleService();\n            s.toggleOption(ServiceOption.PERIODIC_MAINTENANCE, true);\n            return s;\n        }\n    }\n\n    public static class ExampleServiceWithCustomSelector extends StatefulService {\n\n        public ExampleServiceWithCustomSelector() {\n            super(ExampleServiceState.class);\n            super.toggleOption(ServiceOption.REPLICATION, true);\n            super.toggleOption(ServiceOption.OWNER_SELECTION, true);\n            super.toggleOption(ServiceOption.PERSISTENCE, true);\n        }\n\n    }\n\n    public static class ExampleFactoryServiceWithCustomSelector extends FactoryService {\n\n        public ExampleFactoryServiceWithCustomSelector() {\n            super(ExampleServiceState.class);\n            super.setPeerNodeSelectorPath(CUSTOM_GROUP_NODE_SELECTOR);\n        }\n\n        @Override\n        public Service createServiceInstance() throws Throwable {\n            return new ExampleServiceWithCustomSelector();\n        }\n\n    }\n\n    private static final String CUSTOM_EXAMPLE_SERVICE_KIND = \"xenon:examplestate\";\n    private static final String CUSTOM_NODE_GROUP_NAME = \"custom\";\n    private static final String CUSTOM_NODE_GROUP = UriUtils.buildUriPath(\n            ServiceUriPaths.NODE_GROUP_FACTORY,\n            CUSTOM_NODE_GROUP_NAME);\n    private static final String CUSTOM_GROUP_NODE_SELECTOR = UriUtils.buildUriPath(\n            ServiceUriPaths.NODE_SELECTOR_PREFIX,\n            CUSTOM_NODE_GROUP_NAME);\n\n    public static final long DEFAULT_MAINT_INTERVAL_MICROS = TimeUnit.MILLISECONDS\n            .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS);\n    private VerificationHost host;\n\n    /**\n     * Command line argument specifying number of times to run the same test method.\n     */\n    public int testIterationCount = 1;\n\n    /**\n     * Command line argument specifying default number of in process service hosts\n     */\n    public int nodeCount = 3;\n\n    /**\n     * Command line argument specifying request count\n     */\n    public int updateCount = 10;\n\n    /**\n     * Command line argument specifying service instance count\n     */\n    public int serviceCount = 10;\n\n    /**\n     * Command line argument specifying test duration\n     */\n    public long testDurationSeconds;\n\n    /**\n     * Command line argument specifying iterations per test method\n     */\n    public long iterationCount = 1;\n\n    /**\n     * Command line argument used by replication long running tests\n     */\n    public long totalOperationLimit = Long.MAX_VALUE;\n\n    private NodeGroupConfig nodeGroupConfig = new NodeGroupConfig();\n    private EnumSet<ServiceOption> postCreationServiceOptions = EnumSet.noneOf(ServiceOption.class);\n    private boolean expectFailure;\n    private long expectedFailureStartTimeMicros;\n    private List<URI> expectedFailedHosts = new ArrayList<>();\n    private String replicationTargetFactoryLink = ExampleService.FACTORY_LINK;\n    private String replicationNodeSelector = ServiceUriPaths.DEFAULT_NODE_SELECTOR;\n    private long replicationFactor;\n\n    private BiPredicate<ExampleServiceState, ExampleServiceState> exampleStateConvergenceChecker = (\n            initial, current) -> {\n        if (current.name == null) {\n            return false;\n        }\n        if (!this.host.isRemotePeerTest() &&\n                !CUSTOM_EXAMPLE_SERVICE_KIND.equals(current.documentKind)) {\n            return false;\n        }\n        return current.name.equals(initial.name);\n    };\n\n    private Function<ExampleServiceState, Void> exampleStateUpdateBodySetter = (\n            ExampleServiceState state) -> {\n        state.name = Utils.getNowMicrosUtc() + \"\";\n        return null;\n    };\n\n    private boolean isPeerSynchronizationEnabled = true;\n    private boolean isAuthorizationEnabled = false;\n    private HttpScheme replicationUriScheme;\n    private boolean skipAvailabilityChecks = false;\n    private boolean isMultiLocationTest = false;\n\n    private void setUp(int localHostCount) throws Throwable {\n        if (this.host != null) {\n            return;\n        }\n        CommandLineArgumentParser.parseFromProperties(this);\n        this.host = VerificationHost.create(0);\n        this.host.setAuthorizationEnabled(this.isAuthorizationEnabled);\n\n        VerificationHost.createAndAttachSSLClient(this.host);\n\n        if (this.replicationUriScheme == HttpScheme.HTTPS_ONLY) {\n            // disable HTTP, forcing host.getPublicUri() to return a HTTPS schemed URI. This in\n            // turn forces the node group to use HTTPS for join, replication, etc\n            this.host.setPort(ServiceHost.PORT_VALUE_LISTENER_DISABLED);\n            // the default is disable (-1) so we must set port to 0, to enable SSL and make the\n            // runtime pick a random HTTPS port\n            this.host.setSecurePort(0);\n        }\n\n        if (this.testDurationSeconds > 0) {\n            // for long running tests use the default interval to match production code\n            this.host.maintenanceIntervalMillis = TimeUnit.MICROSECONDS.toMillis(\n                    ServiceHostState.DEFAULT_MAINTENANCE_INTERVAL_MICROS);\n        }\n\n        this.host.start();\n\n        if (this.host.isAuthorizationEnabled()) {\n            this.host.setSystemAuthorizationContext();\n        }\n\n        CommandLineArgumentParser.parseFromProperties(this.host);\n        this.host.setStressTest(this.host.isStressTest);\n        this.host.setPeerSynchronizationEnabled(this.isPeerSynchronizationEnabled);\n        this.host.setMultiLocationTest(this.isMultiLocationTest);\n        this.host.setUpPeerHosts(localHostCount);\n\n        for (VerificationHost h1 : this.host.getInProcessHostMap().values()) {\n            setUpPeerHostWithAdditionalServices(h1);\n        }\n\n        // If the peer hosts are remote, then we undo CUSTOM_EXAMPLE_SERVICE_KIND\n        // from the KINDS cache and use the real documentKind of ExampleService.\n        if (this.host.isRemotePeerTest()) {\n            Utils.registerKind(ExampleServiceState.class,\n                    Utils.toDocumentKind(ExampleServiceState.class));\n        }\n    }\n\n    private void setUpPeerHostWithAdditionalServices(VerificationHost h1) throws Throwable {\n        h1.setStressTest(this.host.isStressTest);\n\n        h1.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n\n        Replication1xExampleFactoryService exampleFactory1x = new Replication1xExampleFactoryService();\n        h1.startServiceAndWait(exampleFactory1x,\n                Replication1xExampleFactoryService.SELF_LINK,\n                null);\n\n        Replication3xExampleFactoryService exampleFactory3x = new Replication3xExampleFactoryService();\n        h1.startServiceAndWait(exampleFactory3x,\n                Replication3xExampleFactoryService.SELF_LINK,\n                null);\n\n        // start the replication test factory service with OWNER_SELECTION\n        ReplicationFactoryTestService ownerSelRplFactory = new ReplicationFactoryTestService();\n        h1.startServiceAndWait(ownerSelRplFactory,\n                ReplicationFactoryTestService.OWNER_SELECTION_SELF_LINK,\n                null);\n\n        // start the replication test factory service with STRICT update checking\n        ReplicationFactoryTestService strictReplFactory = new ReplicationFactoryTestService();\n        h1.startServiceAndWait(strictReplFactory,\n                ReplicationFactoryTestService.STRICT_SELF_LINK, null);\n\n        // start the replication test factory service with simple replication, no owner selection\n        ReplicationFactoryTestService replFactory = new ReplicationFactoryTestService();\n        h1.startServiceAndWait(replFactory,\n                ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK, null);\n    }\n\n    private Map<URI, URI> getFactoriesPerNodeGroup(String factoryLink) {\n        Map<URI, URI> map = this.host.getNodeGroupToFactoryMap(factoryLink);\n        for (URI h : this.expectedFailedHosts) {\n            URI e = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n            // do not send messages through hosts that will be stopped: this allows all messages to\n            // end the node group and the succeed or fail based on the test goals. If we let messages\n            // route through a host that we will abruptly stop, the message might timeout, which is\n            // OK for the expected failure case when quorum is not met, but will prevent is from confirming\n            // in the non eager consistency case, that all updates were written to at least one host\n            map.remove(e);\n        }\n\n        return map;\n    }\n\n    @Before\n    public void setUp() {\n        CommandLineArgumentParser.parseFromProperties(this);\n        Utils.registerKind(ExampleServiceState.class, CUSTOM_EXAMPLE_SERVICE_KIND);\n    }\n\n    private void setUpOnDemandLoad() throws Throwable {\n        setUp();\n        // we need at least 5 nodes, because we're going to stop 2\n        // nodes and we need majority quorum\n        this.nodeCount = Math.max(5, this.nodeCount);\n\n        this.isPeerSynchronizationEnabled = true;\n        this.skipAvailabilityChecks = true;\n        // create node group, join nodes and set majority quorum\n        setUp(this.nodeCount);\n        toggleOnDemandLoad();\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.host.getPeerCount() / 2 + 1);\n    }\n\n    private void toggleOnDemandLoad() {\n        for (URI nodeUri : this.host.getNodeGroupMap().keySet()) {\n            URI factoryUri = UriUtils.buildUri(nodeUri, ExampleService.FACTORY_LINK);\n            this.host.toggleServiceOptions(factoryUri, EnumSet.of(ServiceOption.ON_DEMAND_LOAD),\n                    null);\n        }\n    }\n\n    @After\n    public void tearDown() throws InterruptedException {\n        Utils.registerKind(ExampleServiceState.class,\n                Utils.toDocumentKind(ExampleServiceState.class));\n        if (this.host == null) {\n            return;\n        }\n\n        if (this.host.isRemotePeerTest()) {\n            try {\n                this.host.logNodeProcessLogs(this.host.getNodeGroupMap().keySet(),\n                        ServiceUriPaths.PROCESS_LOG);\n            } catch (Throwable e) {\n                this.host.log(\"Failure retrieving process logs: %s\", Utils.toString(e));\n            }\n\n            try {\n                this.host.logNodeManagementState(this.host.getNodeGroupMap().keySet());\n            } catch (Throwable e) {\n                this.host.log(\"Failure retrieving management state: %s\", Utils.toString(e));\n            }\n        }\n\n        this.host.tearDownInProcessPeers();\n        this.host.toggleNegativeTestMode(false);\n        this.host.tearDown();\n        this.host = null;\n\n        System.clearProperty(\n                NodeSelectorReplicationService.PROPERTY_NAME_REPLICA_NOT_FOUND_TIMEOUT_MICROS);\n    }\n\n    @Test\n    public void synchronizationCollisionWithPosts() throws Throwable {\n        // POST requests go through the FactoryService\n        // and do not get queued with Synchronization\n        // requests, so if synchronization was running\n        // while POSTs were happening for the same factory\n        // service, we could run into collisions. This test\n        // verifies that xenon handles such collisions and\n        // POST requests are always successful.\n\n        // Join the nodes with full quorum and wait for nodes to\n        // converge and synchronization to complete.\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.nodeCount);\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n\n        // Find the owner node for /core/examples. We will\n        // use it to start on-demand synchronization for\n        // this factory\n        URI factoryUri = UriUtils.buildUri(this.host.getPeerHost(), ExampleService.FACTORY_LINK);\n        waitForReplicatedFactoryServiceAvailable(factoryUri, this.replicationNodeSelector);\n\n        String taskPath = UriUtils.buildUriPath(\n                SynchronizationTaskService.FACTORY_LINK,\n                UriUtils.convertPathCharsFromLink(ExampleService.FACTORY_LINK));\n\n        VerificationHost owner = null;\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            if (peer.isOwner(ExampleService.FACTORY_LINK, ServiceUriPaths.DEFAULT_NODE_SELECTOR)) {\n                owner = peer;\n                break;\n            }\n        }\n        this.host.log(Level.INFO, \"Owner of synch-task is %s\", owner.getId());\n\n        // Get the membershipUpdateTimeMicros so that we can\n        // kick-off the synch-task on-demand.\n        URI taskUri = UriUtils.buildUri(owner, taskPath);\n        SynchronizationTaskService.State taskState = this.host.getServiceState(\n                null, SynchronizationTaskService.State.class, taskUri);\n        long membershipUpdateTimeMicros = taskState.membershipUpdateTimeMicros;\n\n        // Start posting and in the middle also start\n        // synchronization. All POSTs should succeed!\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = \"testing\";\n        TestContext ctx = this.host.testCreate((this.serviceCount * 10) + 1);\n        for (int i = 0; i < this.serviceCount * 10; i++) {\n            if (i == 5) {\n                SynchronizationTaskService.State task = new SynchronizationTaskService.State();\n                task.documentSelfLink = UriUtils.convertPathCharsFromLink(ExampleService.FACTORY_LINK);\n                task.factorySelfLink = ExampleService.FACTORY_LINK;\n                task.factoryStateKind = Utils.buildKind(ExampleService.ExampleServiceState.class);\n                task.membershipUpdateTimeMicros = membershipUpdateTimeMicros + 1;\n                task.nodeSelectorLink = ServiceUriPaths.DEFAULT_NODE_SELECTOR;\n                task.queryResultLimit = 1000;\n                task.taskInfo = TaskState.create();\n                task.taskInfo.isDirect = true;\n\n                Operation post = Operation\n                        .createPost(owner, SynchronizationTaskService.FACTORY_LINK)\n                        .setBody(task)\n                        .setReferer(this.host.getUri())\n                        .setCompletion(ctx.getCompletion());\n                this.host.sendRequest(post);\n            }\n            Operation post = Operation\n                    .createPost(factoryUri)\n                    .setBody(state)\n                    .setReferer(this.host.getUri())\n                    .setCompletion(ctx.getCompletion());\n            this.host.sendRequest(post);\n        }\n        ctx.await();\n    }\n\n    @Test\n    public void commandLineJoinRetries() throws Throwable {\n        this.host = VerificationHost.create(0);\n        this.host.start();\n\n        ExampleServiceHost nodeA = null;\n        TemporaryFolder tmpFolderA = new TemporaryFolder();\n        tmpFolderA.create();\n        this.setUp(1);\n        try {\n            // start a node, supplying a bogus peer. Verify we retry, up to expiration which is\n            // the operation timeout\n            nodeA = new ExampleServiceHost();\n\n            String id = \"nodeA-\" + VerificationHost.hostNumber.incrementAndGet();\n            int bogusPort = 1;\n            String[] args = {\n                    \"--port=0\",\n                    \"--id=\" + id,\n                    \"--bindAddress=127.0.0.1\",\n                    \"--sandbox=\"\n                            + tmpFolderA.getRoot().getAbsolutePath(),\n                    \"--peerNodes=\" + \"http://127.0.0.1:\" + bogusPort\n            };\n\n            nodeA.initialize(args);\n            nodeA.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                    .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n            nodeA.start();\n\n            // verify we see a specific retry stat\n            URI nodeGroupUri = UriUtils.buildUri(nodeA, ServiceUriPaths.DEFAULT_NODE_GROUP);\n            URI statsUri = UriUtils.buildStatsUri(nodeGroupUri);\n            this.host.waitFor(\"expected stat did not converge\", () -> {\n                ServiceStats stats = this.host.getServiceState(null, ServiceStats.class, statsUri);\n                ServiceStat st = stats.entries.get(NodeGroupService.STAT_NAME_JOIN_RETRY_COUNT);\n                if (st == null || st.latestValue < 1) {\n                    return false;\n                }\n                return true;\n            });\n\n        } finally {\n            if (nodeA != null) {\n                nodeA.stop();\n                tmpFolderA.delete();\n            }\n        }\n    }\n\n    @Test\n    public void synchronizationOnDemandLoad() throws Throwable {\n        // Setup peer nodes\n        setUp(this.nodeCount);\n\n        long intervalMicros = TimeUnit.MILLISECONDS.toMicros(200);\n\n        // Start the ODL Factory service on all the peers.\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            // Reduce cache clear delay to short duration\n            // to cause ODL service stops.\n            h.setServiceCacheClearDelayMicros(h.getMaintenanceIntervalMicros());\n\n            // create an on demand load factory and services\n            OnDemandLoadFactoryService.create(h);\n        }\n\n        // join the nodes and set full quorum.\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.nodeCount);\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(OnDemandLoadFactoryService.SELF_LINK),\n                this.replicationNodeSelector);\n\n        // Create a few child-services.\n        VerificationHost h = this.host.getPeerHost();\n        Map<URI, ExampleServiceState> childServices = this.host.doFactoryChildServiceStart(\n                null,\n                this.serviceCount,\n                ExampleServiceState.class,\n                (o) -> {\n                    ExampleServiceState initialState = new ExampleServiceState();\n                    initialState.name = UUID.randomUUID().toString();\n                    o.setBody(initialState);\n                },\n                UriUtils.buildFactoryUri(h, OnDemandLoadFactoryService.class));\n\n        // Verify that each peer host reports the correct value for ODL stop count.\n        for (VerificationHost vh : this.host.getInProcessHostMap().values()) {\n            this.host.waitFor(\"ODL services did not stop as expected\",\n                    () -> checkOdlServiceStopCount(vh, this.serviceCount));\n        }\n\n        // Add a new host to the cluster.\n        VerificationHost newHost = this.host.setUpLocalPeerHost(0, h.getMaintenanceIntervalMicros(),\n                null);\n        newHost.setServiceCacheClearDelayMicros(intervalMicros);\n        OnDemandLoadFactoryService.create(newHost);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount + 1);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(OnDemandLoadFactoryService.SELF_LINK),\n                this.replicationNodeSelector);\n\n        // Do GETs on each previously created child services by calling the newly added host.\n        // This will trigger synchronization for the child services.\n        this.host.log(Level.INFO, \"Verifying synchronization for ODL services\");\n        for (Entry<URI, ExampleServiceState> childService : childServices.entrySet()) {\n            String childServicePath = childService.getKey().getPath();\n            ExampleServiceState state = this.host.getServiceState(null,\n                    ExampleServiceState.class, UriUtils.buildUri(newHost, childServicePath));\n            assertNotNull(state);\n        }\n\n        // Verify that the new peer host reports the correct value for ODL stop count.\n        this.host.waitFor(\"ODL services did not stop as expected\",\n                () -> checkOdlServiceStopCount(newHost, this.serviceCount));\n    }\n\n    private boolean checkOdlServiceStopCount(VerificationHost host, int serviceCount)\n            throws Throwable {\n        ServiceStat stopCount = host\n                .getServiceStats(host.getManagementServiceUri())\n                .get(ServiceHostManagementService.STAT_NAME_ODL_STOP_COUNT);\n        if (stopCount == null || stopCount.latestValue < serviceCount) {\n            this.host.log(Level.INFO,\n                    \"Current stopCount is %s\",\n                    (stopCount != null) ? String.valueOf(stopCount.latestValue) : \"null\");\n            return false;\n        }\n        return true;\n    }\n\n    @Test\n    public void customNodeGroupWithObservers() throws Throwable {\n        for (int i = 0; i < this.iterationCount; i++) {\n            Logger.getAnonymousLogger().info(\"Iteration: \" + i);\n            verifyCustomNodeGroupWithObservers();\n            tearDown();\n        }\n    }\n\n    private void verifyCustomNodeGroupWithObservers() throws Throwable {\n        setUp(this.nodeCount);\n        // on one of the hosts create the custom group but with self as an observer. That peer should\n        // never receive replicated or broadcast requests\n        URI observerHostUri = this.host.getPeerHostUri();\n        ServiceHostState observerHostState = this.host.getServiceState(null,\n                ServiceHostState.class,\n                UriUtils.buildUri(observerHostUri, ServiceUriPaths.CORE_MANAGEMENT));\n        Map<URI, NodeState> selfStatePerNode = new HashMap<>();\n        NodeState observerSelfState = new NodeState();\n        observerSelfState.id = observerHostState.id;\n        observerSelfState.options = EnumSet.of(NodeOption.OBSERVER);\n\n        selfStatePerNode.put(observerHostUri, observerSelfState);\n        this.host.createCustomNodeGroupOnPeers(CUSTOM_NODE_GROUP_NAME, selfStatePerNode);\n\n        final String customFactoryLink = \"custom-factory\";\n        // start a node selector attached to the custom group\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            NodeSelectorState initialState = new NodeSelectorState();\n            initialState.nodeGroupLink = CUSTOM_NODE_GROUP;\n            h.startServiceAndWait(new ConsistentHashingNodeSelectorService(),\n                    CUSTOM_GROUP_NODE_SELECTOR, initialState);\n            // start the factory that is attached to the custom group selector\n            h.startServiceAndWait(ExampleFactoryServiceWithCustomSelector.class, customFactoryLink);\n        }\n\n        URI customNodeGroupServiceOnObserver = UriUtils\n                .buildUri(observerHostUri, CUSTOM_NODE_GROUP);\n        Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode = new HashMap<>();\n        expectedOptionsPerNode.put(customNodeGroupServiceOnObserver,\n                observerSelfState.options);\n\n        this.host.joinNodesAndVerifyConvergence(CUSTOM_NODE_GROUP, this.nodeCount,\n                this.nodeCount, expectedOptionsPerNode);\n        // one of the nodes is observer, so we must set quorum to 2 explicitly\n        this.host.setNodeGroupQuorum(2, customNodeGroupServiceOnObserver);\n        this.host.waitForNodeSelectorQuorumConvergence(CUSTOM_GROUP_NODE_SELECTOR, 2);\n        this.host.waitForNodeGroupIsAvailableConvergence(CUSTOM_NODE_GROUP);\n\n        int restartCount = 0;\n        // verify that the observer node shows up as OBSERVER on all peers, including self\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            URI customNodeGroupUri = UriUtils.buildUri(hostUri, CUSTOM_NODE_GROUP);\n            NodeGroupState ngs = this.host.getServiceState(null, NodeGroupState.class,\n                    customNodeGroupUri);\n\n            for (NodeState ns : ngs.nodes.values()) {\n                if (ns.id.equals(observerHostState.id)) {\n                    assertTrue(ns.options.contains(NodeOption.OBSERVER));\n                } else {\n                    assertTrue(ns.options.contains(NodeOption.PEER));\n                }\n            }\n\n            ServiceStats nodeGroupStats = this.host.getServiceState(null, ServiceStats.class,\n                    UriUtils.buildStatsUri(customNodeGroupUri));\n            ServiceStat restartStat = nodeGroupStats.entries\n                    .get(NodeGroupService.STAT_NAME_RESTARTING_SERVICES_COUNT);\n            if (restartStat != null) {\n                restartCount += restartStat.latestValue;\n            }\n        }\n\n        assertEquals(\"expected different number of service restarts\", restartCount, 0);\n\n        // join all the nodes through the default group, making sure another group still works\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount, true);\n\n        URI observerFactoryUri = UriUtils.buildUri(observerHostUri, customFactoryLink);\n\n        waitForReplicatedFactoryServiceAvailable(observerFactoryUri, CUSTOM_GROUP_NODE_SELECTOR);\n\n        // create N services on the custom group, verify none of them got created on the observer.\n        // We actually post directly to the observer node, which should forward to the other nodes\n        Map<URI, ExampleServiceState> serviceStatesOnPost = this.host.doFactoryChildServiceStart(\n                null, this.serviceCount,\n                ExampleServiceState.class,\n                (o) -> {\n                    ExampleServiceState body = new ExampleServiceState();\n                    body.name = Utils.getNowMicrosUtc() + \"\";\n                    o.setBody(body);\n                },\n                observerFactoryUri);\n\n        ServiceDocumentQueryResult r = this.host.getFactoryState(observerFactoryUri);\n        assertEquals(0, r.documentLinks.size());\n\n        // do a GET on each service and confirm the owner id is never that of the observer node\n        Map<URI, ExampleServiceState> serviceStatesFromGet = this.host.getServiceState(\n                null, ExampleServiceState.class, serviceStatesOnPost.keySet());\n\n        for (ExampleServiceState s : serviceStatesFromGet.values()) {\n            if (observerHostState.id.equals(s.documentOwner)) {\n                throw new IllegalStateException(\"Observer node reported state for service\");\n            }\n        }\n\n        // create additional example services which are not associated with the custom node group\n        // and verify that they are always included in queries which target the custom node group\n        // (e.g. that the query is never executed on the OBSERVER node).\n        createExampleServices(observerHostUri);\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND).setTermMatchValue(\n                Utils.buildKind(ExampleServiceState.class));\n        QueryTask task = QueryTask.create(q).setDirect(true);\n\n        for (Entry<URI, URI> node : this.host.getNodeGroupMap().entrySet()) {\n            URI nodeUri = node.getKey();\n            URI serviceUri = UriUtils.buildUri(nodeUri, ServiceUriPaths.CORE_LOCAL_QUERY_TASKS);\n            URI forwardQueryUri = UriUtils.buildForwardRequestUri(serviceUri, null,\n                    CUSTOM_GROUP_NODE_SELECTOR);\n            TestContext ctx = this.host.testCreate(1);\n            Operation post = Operation\n                    .createPost(forwardQueryUri)\n                    .setBody(task)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            ctx.fail(e);\n                            return;\n                        }\n\n                        QueryTask rsp = o.getBody(QueryTask.class);\n                        int resultCount = rsp.results.documentLinks.size();\n                        if (resultCount != 2 * this.serviceCount) {\n                            ctx.fail(new IllegalStateException(\n                                    \"Forwarded query returned unexpected document count \" +\n                                            resultCount));\n                            return;\n                        }\n\n                        ctx.complete();\n                    });\n            this.host.send(post);\n            ctx.await();\n        }\n\n        task.querySpec.options = EnumSet.of(QueryTask.QuerySpecification.QueryOption.BROADCAST);\n        task.nodeSelectorLink = CUSTOM_GROUP_NODE_SELECTOR;\n        URI queryPostUri = UriUtils.buildUri(observerHostUri, ServiceUriPaths.CORE_QUERY_TASKS);\n        TestContext ctx = this.host.testCreate(1);\n        Operation post = Operation\n                .createPost(queryPostUri)\n                .setBody(task)\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx.fail(e);\n                        return;\n                    }\n\n                    QueryTask rsp = o.getBody(QueryTask.class);\n                    int resultCount = rsp.results.documentLinks.size();\n                    if (resultCount != 2 * this.serviceCount) {\n                        ctx.fail(new IllegalStateException(\n                                \"Broadcast query returned unexpected document count \" +\n                                        resultCount));\n                        return;\n                    }\n\n                    ctx.complete();\n                });\n        this.host.send(post);\n        ctx.await();\n\n        URI existingNodeGroup = this.host.getPeerNodeGroupUri();\n\n        // start more nodes, insert them to existing group, but with no synchronization required\n        // start some additional nodes\n        Collection<VerificationHost> existingHosts = this.host.getInProcessHostMap().values();\n        int additionalHostCount = this.nodeCount;\n        this.host.setUpPeerHosts(additionalHostCount);\n\n        List<ServiceHost> newHosts = Collections.synchronizedList(new ArrayList<>());\n        newHosts.addAll(this.host.getInProcessHostMap().values());\n        newHosts.removeAll(existingHosts);\n\n        expectedOptionsPerNode.clear();\n        // join new nodes with existing node group.\n\n        TestContext testContext = this.host.testCreate(newHosts.size());\n        for (ServiceHost h : newHosts) {\n            URI newCustomNodeGroupUri = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n\n            JoinPeerRequest joinBody = JoinPeerRequest.create(existingNodeGroup, null);\n            joinBody.localNodeOptions = EnumSet.of(NodeOption.PEER);\n            this.host.send(Operation.createPost(newCustomNodeGroupUri)\n                    .setBody(joinBody)\n                    .setCompletion(testContext.getCompletion()));\n            expectedOptionsPerNode.put(newCustomNodeGroupUri, joinBody.localNodeOptions);\n        }\n\n        testContext.await();\n        this.host.waitForNodeGroupConvergence(this.host.getNodeGroupMap().values(),\n                this.host.getNodeGroupMap().size(),\n                this.host.getNodeGroupMap().size(),\n                expectedOptionsPerNode, false);\n\n        restartCount = 0;\n        // do another restart check. None of the new nodes should have reported restarts\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            URI nodeGroupUri = UriUtils.buildUri(hostUri, ServiceUriPaths.DEFAULT_NODE_GROUP);\n            ServiceStats nodeGroupStats = this.host.getServiceState(null, ServiceStats.class,\n                    UriUtils.buildStatsUri(nodeGroupUri));\n            ServiceStat restartStat = nodeGroupStats.entries\n                    .get(NodeGroupService.STAT_NAME_RESTARTING_SERVICES_COUNT);\n            if (restartStat != null) {\n                restartCount += restartStat.latestValue;\n            }\n        }\n\n        assertEquals(\"expected different number of service restarts\", 0,\n                restartCount);\n    }\n\n    @Test\n    public void verifyGossipForObservers() throws Throwable {\n        setUp(this.nodeCount);\n\n        Iterator<Entry<URI, URI>> nodeGroupIterator = this.host.getNodeGroupMap().entrySet()\n                .iterator();\n        URI observerUri = nodeGroupIterator.next().getKey();\n        String observerId = this.host.getServiceState(null,\n                ServiceHostState.class,\n                UriUtils.buildUri(observerUri, ServiceUriPaths.CORE_MANAGEMENT)).id;\n\n        // Create a custom node group. Mark one node as OBSERVER and rest as PEER\n        Map<URI, NodeState> selfStatePerNode = new HashMap<>();\n        NodeState observerSelfState = new NodeState();\n        observerSelfState.id = observerId;\n        observerSelfState.options = EnumSet.of(NodeOption.OBSERVER);\n        selfStatePerNode.put(observerUri, observerSelfState);\n        this.host.createCustomNodeGroupOnPeers(CUSTOM_NODE_GROUP_NAME, selfStatePerNode);\n\n        // Pick a PEER and join it to each node in the node-group\n        URI peerUri = nodeGroupIterator.next().getKey();\n        URI peerCustomUri = UriUtils.buildUri(peerUri, CUSTOM_NODE_GROUP);\n\n        Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode = new HashMap<>();\n        Set<URI> customNodeUris = new HashSet<>();\n\n        for (Entry<URI, URI> node : this.host.getNodeGroupMap().entrySet()) {\n            URI nodeUri = node.getKey();\n            URI nodeCustomUri = UriUtils.buildUri(nodeUri, CUSTOM_NODE_GROUP);\n\n            JoinPeerRequest request = new JoinPeerRequest();\n            request.memberGroupReference = nodeCustomUri;\n            TestContext ctx = this.host.testCreate(1);\n            Operation post = Operation\n                    .createPost(peerCustomUri)\n                    .setBody(request)\n                    .setReferer(this.host.getReferer())\n                    .setCompletion(ctx.getCompletion());\n            this.host.sendRequest(post);\n            ctx.await();\n\n            expectedOptionsPerNode.put(nodeCustomUri,\n                    EnumSet.of((nodeUri == observerUri)\n                            ? NodeOption.OBSERVER : NodeOption.PEER));\n            customNodeUris.add(nodeCustomUri);\n        }\n\n        // Verify that gossip will propagate the single OBSERVER and the PEER nodes\n        // to every node in the custom node-group.\n        this.host.waitForNodeGroupConvergence(\n                customNodeUris, this.nodeCount, this.nodeCount, expectedOptionsPerNode, false);\n    }\n\n    @Test\n    public void synchronizationOneByOneWithAbruptNodeShutdown() throws Throwable {\n        setUp(this.nodeCount);\n\n        this.replicationTargetFactoryLink = PeriodicExampleFactoryService.SELF_LINK;\n        // start the periodic example service factory on each node\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.startServiceAndWait(PeriodicExampleFactoryService.class,\n                    PeriodicExampleFactoryService.SELF_LINK);\n        }\n\n        // On one host, add some services. They exist only on this host and we expect them to synchronize\n        // across all hosts once this one joins with the group\n        VerificationHost initialHost = this.host.getPeerHost();\n        URI hostUriWithInitialState = initialHost.getUri();\n        Map<String, ExampleServiceState> exampleStatesPerSelfLink = createExampleServices(\n                hostUriWithInitialState);\n\n        URI hostWithStateNodeGroup = UriUtils.buildUri(hostUriWithInitialState,\n                ServiceUriPaths.DEFAULT_NODE_GROUP);\n\n        // before start joins, verify isolated factory synchronization is done\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            waitForReplicatedFactoryServiceAvailable(\n                    UriUtils.buildUri(hostUri, this.replicationTargetFactoryLink),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        }\n\n        // join a node, with no state, one by one, to the host with state.\n        // The steps are:\n        // 1) set quorum to node group size + 1\n        // 2) Join new empty node with existing node group\n        // 3) verify convergence of factory state\n        // 4) repeat\n\n        List<URI> joinedHosts = new ArrayList<>();\n        Map<URI, URI> factories = new HashMap<>();\n        factories.put(hostWithStateNodeGroup, UriUtils.buildUri(hostWithStateNodeGroup,\n                this.replicationTargetFactoryLink));\n        joinedHosts.add(hostWithStateNodeGroup);\n        int fullQuorum = 1;\n\n        for (URI nodeGroupUri : this.host.getNodeGroupMap().values()) {\n            // skip host with state\n            if (hostWithStateNodeGroup.equals(nodeGroupUri)) {\n                continue;\n            }\n\n            this.host.log(\"Setting quorum to %d, already joined: %d\",\n                    fullQuorum + 1, joinedHosts.size());\n            // set quorum to expected full node group size, for the setup hosts\n            this.host.setNodeGroupQuorum(++fullQuorum);\n\n            this.host.testStart(1);\n            // join empty node, with node with state\n            this.host.joinNodeGroup(hostWithStateNodeGroup, nodeGroupUri, fullQuorum);\n            this.host.testWait();\n            joinedHosts.add(nodeGroupUri);\n            factories.put(nodeGroupUri, UriUtils.buildUri(nodeGroupUri,\n                    this.replicationTargetFactoryLink));\n            this.host.waitForNodeGroupConvergence(joinedHosts, fullQuorum, fullQuorum, true);\n            this.host.waitForNodeGroupIsAvailableConvergence(nodeGroupUri.getPath(), joinedHosts);\n\n            this.waitForReplicatedFactoryChildServiceConvergence(\n                    factories,\n                    exampleStatesPerSelfLink,\n                    this.exampleStateConvergenceChecker, exampleStatesPerSelfLink.size(),\n                    0);\n\n            // Do updates, which will verify that the services are converged in terms of ownership.\n            // Since we also synchronize on demand, if there was any discrepancy, after updates, the\n            // services will converge\n            doExampleServicePatch(exampleStatesPerSelfLink,\n                    joinedHosts.get(0));\n\n            Set<String> ownerIds = this.host.getNodeStateMap().keySet();\n            verifyDocumentOwnerAndEpoch(exampleStatesPerSelfLink, initialHost, joinedHosts, 0, 1,\n                    ownerIds.size() - 1);\n        }\n\n        doNodeStopWithUpdates(exampleStatesPerSelfLink);\n    }\n\n    private void doExampleServicePatch(Map<String, ExampleServiceState> states,\n            URI nodeGroupOnSomeHost) throws Throwable {\n        this.host.log(\"Starting PATCH to %d example services\", states.size());\n        TestContext ctx = this.host\n                .testCreate(this.updateCount * states.size());\n\n        this.setOperationTimeoutMicros(TimeUnit.SECONDS.toMicros(this.host.getTimeoutSeconds()));\n\n        for (int i = 0; i < this.updateCount; i++) {\n            for (Entry<String, ExampleServiceState> e : states.entrySet()) {\n                ExampleServiceState st = Utils.clone(e.getValue());\n                st.counter = (long) i;\n                Operation patch = Operation\n                        .createPatch(UriUtils.buildUri(nodeGroupOnSomeHost, e.getKey()))\n                        .setCompletion(ctx.getCompletion())\n                        .setBody(st);\n                this.host.send(patch);\n            }\n        }\n        this.host.testWait(ctx);\n        this.host.log(\"Done with PATCH to %d example services\", states.size());\n    }\n\n    public void doNodeStopWithUpdates(Map<String, ExampleServiceState> exampleStatesPerSelfLink)\n            throws Throwable {\n        this.host.log(\"Starting to stop nodes and send updates\");\n        VerificationHost remainingHost = this.host.getPeerHost();\n        Collection<VerificationHost> hostsToStop = new ArrayList<>(this.host.getInProcessHostMap()\n                .values());\n        hostsToStop.remove(remainingHost);\n        List<URI> targetServices = new ArrayList<>();\n        for (String link : exampleStatesPerSelfLink.keySet()) {\n            // build the URIs using the host we plan to keep, so the maps we use below to lookup\n            // stats from URIs, work before and after node stop\n            targetServices.add(UriUtils.buildUri(remainingHost, link));\n        }\n\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.setPeerSynchronizationTimeLimitSeconds(this.host.getTimeoutSeconds() / 3);\n        }\n\n        // capture current stats from each service\n        Map<URI, ServiceStats> prevStats = verifyMaintStatsAfterSynchronization(targetServices,\n                null);\n\n        stopHostsAndVerifyQueuing(hostsToStop, remainingHost, targetServices);\n\n        // its important to verify document ownership before we do any updates on the services.\n        // This is because we verify, that even without any on demand synchronization,\n        // the factory driven synchronization set the services in the proper state\n        Set<String> ownerIds = this.host.getNodeStateMap().keySet();\n        List<URI> remainingHosts = new ArrayList<>(this.host.getNodeGroupMap().keySet());\n        verifyDocumentOwnerAndEpoch(exampleStatesPerSelfLink,\n                this.host.getInProcessHostMap().values().iterator().next(),\n                remainingHosts, 0, 1,\n                ownerIds.size() - 1);\n\n        // confirm maintenance is back up and running on all services\n        verifyMaintStatsAfterSynchronization(targetServices, prevStats);\n\n        // nodes are stopped, do updates again, quorum is relaxed, they should work\n        doExampleServicePatch(exampleStatesPerSelfLink, remainingHost.getUri());\n\n        this.host.log(\"Done with stop nodes and send updates\");\n    }\n\n    private void verifyDynamicMaintOptionToggle(Map<String, ExampleServiceState> childStates) {\n\n        List<URI> targetServices = new ArrayList<>();\n        childStates.keySet().forEach((l) -> targetServices.add(this.host.getPeerServiceUri(l)));\n\n        List<URI> targetServiceStats = new ArrayList<>();\n        List<URI> targetServiceConfig = new ArrayList<>();\n        for (URI child : targetServices) {\n            targetServiceStats.add(UriUtils.buildStatsUri(child));\n            targetServiceConfig.add(UriUtils.buildConfigUri(child));\n        }\n\n        Map<URI, ServiceConfiguration> configPerService = this.host.getServiceState(\n                null, ServiceConfiguration.class, targetServiceConfig);\n        for (ServiceConfiguration cfg : configPerService.values()) {\n            assertTrue(!cfg.options.contains(ServiceOption.PERIODIC_MAINTENANCE));\n        }\n\n        for (URI child : targetServices) {\n            this.host.toggleServiceOptions(child,\n                    EnumSet.of(ServiceOption.PERIODIC_MAINTENANCE),\n                    null);\n        }\n\n        verifyMaintStatsAfterSynchronization(targetServices, null);\n    }\n\n    private Map<URI, ServiceStats> verifyMaintStatsAfterSynchronization(List<URI> targetServices,\n            Map<URI, ServiceStats> statsPerService) {\n\n        List<URI> targetServiceStats = new ArrayList<>();\n        List<URI> targetServiceConfig = new ArrayList<>();\n        for (URI child : targetServices) {\n            targetServiceStats.add(UriUtils.buildStatsUri(child));\n            targetServiceConfig.add(UriUtils.buildConfigUri(child));\n        }\n\n        if (statsPerService == null) {\n            statsPerService = new HashMap<>();\n        }\n        final Map<URI, ServiceStats> previousStatsPerService = statsPerService;\n        this.host.waitFor(\n                \"maintenance not enabled\",\n                () -> {\n                    Map<URI, ServiceStats> stats = this.host.getServiceState(null,\n                            ServiceStats.class, targetServiceStats);\n                    for (Entry<URI, ServiceStats> currentEntry : stats.entrySet()) {\n                        ServiceStats previousStats = previousStatsPerService.get(currentEntry\n                                .getKey());\n                        ServiceStats currentStats = currentEntry.getValue();\n                        ServiceStat previousMaintStat = previousStats == null ? new ServiceStat()\n                                : previousStats.entries\n                                .get(Service.STAT_NAME_MAINTENANCE_COUNT);\n                        double previousValue = previousMaintStat == null ? 0L\n                                : previousMaintStat.latestValue;\n                        ServiceStat maintStat = currentStats.entries\n                                .get(Service.STAT_NAME_MAINTENANCE_COUNT);\n                        if (maintStat == null || maintStat.latestValue <= previousValue) {\n                            return false;\n                        }\n                    }\n                    previousStatsPerService.putAll(stats);\n                    return true;\n                });\n        return statsPerService;\n    }\n\n    private Map<String, ExampleServiceState> createExampleServices(URI hostUri) throws Throwable {\n        URI factoryUri = UriUtils.buildUri(hostUri, this.replicationTargetFactoryLink);\n        this.host.log(\"POSTing children to %s\", hostUri);\n\n        // add some services on one of the peers, so we can verify the get synchronized after they all join\n        Map<URI, ExampleServiceState> exampleStates = this.host.doFactoryChildServiceStart(\n                null,\n                this.serviceCount,\n                ExampleServiceState.class,\n                (o) -> {\n                    ExampleServiceState s = new ExampleServiceState();\n                    s.name = UUID.randomUUID().toString();\n                    o.setBody(s);\n                }, factoryUri);\n\n        Map<String, ExampleServiceState> exampleStatesPerSelfLink = new HashMap<>();\n\n        for (ExampleServiceState s : exampleStates.values()) {\n            exampleStatesPerSelfLink.put(s.documentSelfLink, s);\n        }\n        return exampleStatesPerSelfLink;\n    }\n\n    @Test\n    public void synchronizationWithPeerNodeListAndDuplicates()\n            throws Throwable {\n\n        ExampleServiceHost h = null;\n\n        TemporaryFolder tmpFolder = new TemporaryFolder();\n        tmpFolder.create();\n\n        try {\n            setUp(this.nodeCount);\n\n            // the hosts are started, but not joined. We need to relax the quorum for any updates\n            // to go through\n            this.host.setNodeGroupQuorum(1);\n\n            Map<String, ExampleServiceState> exampleStatesPerSelfLink = new HashMap<>();\n\n            // add the *same* service instance, all *all* peers, so we force synchronization and epoch\n            // change on an instance that exists everywhere\n\n            int dupServiceCount = this.serviceCount;\n            AtomicInteger counter = new AtomicInteger();\n            Map<URI, ExampleServiceState> dupStates = new HashMap<>();\n            for (VerificationHost v : this.host.getInProcessHostMap().values()) {\n                counter.set(0);\n                URI factoryUri = UriUtils.buildFactoryUri(v,\n                        ExampleService.class);\n                dupStates = this.host.doFactoryChildServiceStart(\n                        null,\n                        dupServiceCount,\n                        ExampleServiceState.class,\n                        (o) -> {\n                            ExampleServiceState s = new ExampleServiceState();\n                            s.documentSelfLink = \"duplicateExampleInstance-\"\n                                    + counter.incrementAndGet();\n                            s.name = s.documentSelfLink;\n                            o.setBody(s);\n                        }, factoryUri);\n            }\n\n            for (ExampleServiceState s : dupStates.values()) {\n                exampleStatesPerSelfLink.put(s.documentSelfLink, s);\n            }\n\n            // increment to account for link found on all nodes\n            this.serviceCount = exampleStatesPerSelfLink.size();\n\n            // create peer argument list, all the nodes join.\n            Collection<URI> peerNodeGroupUris = new ArrayList<>();\n            StringBuilder peerNodes = new StringBuilder();\n            for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n                peerNodeGroupUris.add(UriUtils.buildUri(peer, ServiceUriPaths.DEFAULT_NODE_GROUP));\n                peerNodes.append(peer.getUri().toString()).append(\",\");\n            }\n\n            CountDownLatch notifications = new CountDownLatch(this.nodeCount);\n            for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n                this.host.subscribeForNodeGroupConvergence(nodeGroup, this.nodeCount + 1,\n                        (o, e) -> {\n                            if (e != null) {\n                                this.host.log(\"Error in notificaiton: %s\", Utils.toString(e));\n                                return;\n                            }\n                            notifications.countDown();\n                        });\n            }\n\n            // now start a new Host and supply the already created peer, then observe the automatic\n            // join\n            h = new ExampleServiceHost();\n            int quorum = this.host.getPeerCount() + 1;\n\n            String mainHostId = \"main-\" + VerificationHost.hostNumber.incrementAndGet();\n            String[] args = {\n                    \"--port=0\",\n                    \"--id=\" + mainHostId,\n                    \"--bindAddress=127.0.0.1\",\n                    \"--sandbox=\"\n                            + tmpFolder.getRoot().getAbsolutePath(),\n                    \"--peerNodes=\" + peerNodes.toString()\n            };\n\n            h.initialize(args);\n\n            h.setPeerSynchronizationEnabled(this.isPeerSynchronizationEnabled);\n            h.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                    .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n\n            h.start();\n            URI mainHostNodeGroupUri = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n\n            int totalCount = this.nodeCount + 1;\n            peerNodeGroupUris.add(mainHostNodeGroupUri);\n            this.host.waitForNodeGroupIsAvailableConvergence();\n            this.host.waitForNodeGroupConvergence(peerNodeGroupUris, totalCount,\n                    totalCount, true);\n\n            this.host.setNodeGroupQuorum(quorum, mainHostNodeGroupUri);\n            this.host.setNodeGroupQuorum(quorum);\n\n            this.host.scheduleSynchronizationIfAutoSyncDisabled(this.replicationNodeSelector);\n\n            int peerNodeCount = h.getInitialPeerHosts().size();\n            // include self in peers\n            assertTrue(totalCount >= peerNodeCount + 1);\n\n            // Before factory synch is complete, make sure POSTs to existing services fail,\n            // since they are not marked idempotent.\n            verifyReplicatedInConflictPost(dupStates);\n\n            // now verify all nodes synchronize and see the example service instances that existed on the single\n            // host\n            waitForReplicatedFactoryChildServiceConvergence(\n                    exampleStatesPerSelfLink,\n                    this.exampleStateConvergenceChecker,\n                    this.serviceCount, 0);\n\n            // Send some updates after the full group has formed  and verify the updates are seen by services on all nodes\n\n            doStateUpdateReplicationTest(Action.PATCH, this.serviceCount, this.updateCount, 0,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    exampleStatesPerSelfLink);\n\n            URI exampleFactoryUri = this.host.getPeerServiceUri(ExampleService.FACTORY_LINK);\n            waitForReplicatedFactoryServiceAvailable(\n                    UriUtils.buildUri(exampleFactoryUri, ExampleService.FACTORY_LINK),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        } finally {\n            this.host.log(\"test finished\");\n            if (h != null) {\n                h.stop();\n                tmpFolder.delete();\n            }\n        }\n    }\n\n    private void verifyReplicatedInConflictPost(Map<URI, ExampleServiceState> dupStates)\n            throws Throwable {\n        // Its impossible to guarantee that this runs during factory synch. It might run before,\n        // it might run during, it might run after. Since we runs 1000s of tests per day, CI\n        // will let us know if the production code works. Here, we add a small sleep so we increase\n        // chance we overlap with factory synchronization.\n        Thread.sleep(TimeUnit.MICROSECONDS.toMillis(\n                this.host.getPeerHost().getMaintenanceIntervalMicros()));\n        // Issue a POST for a service we know exists and expect failure, since the example service\n        // is not marked IDEMPOTENT. We expect CONFLICT error code, but if synchronization is active\n        // we want to confirm we dont get 500, but the 409 is preserved\n        TestContext ctx = this.host.testCreate(dupStates.size());\n        for (ExampleServiceState st : dupStates.values()) {\n            URI factoryUri = this.host.getPeerServiceUri(ExampleService.FACTORY_LINK);\n            Operation post = Operation.createPost(factoryUri).setBody(st)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_CONFLICT) {\n                                ctx.failIteration(new IllegalStateException(\n                                        \"Expected conflict status, got \" + o.getStatusCode()));\n                                return;\n                            }\n                            ctx.completeIteration();\n                            return;\n                        }\n                        ctx.failIteration(new IllegalStateException(\n                                \"Expected failure on duplicate POST\"));\n                    });\n            this.host.send(post);\n        }\n        this.host.testWait(ctx);\n    }\n\n    @Test\n    public void replicationWithQuorumAfterAbruptNodeStopOnDemandLoad() throws Throwable {\n        tearDown();\n        for (int i = 0; i < this.testIterationCount; i++) {\n\n            setUpOnDemandLoad();\n\n            int hostStopCount = 2;\n            doReplicationWithQuorumAfterAbruptNodeStop(hostStopCount);\n            this.host.log(\"Done with iteration %d\", i);\n            tearDown();\n            this.host = null;\n        }\n    }\n\n    private void doReplicationWithQuorumAfterAbruptNodeStop(int hostStopCount)\n            throws Throwable {\n        // create some documents\n        Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                this.serviceCount, null, null);\n        updateExampleServiceOptions(childStates);\n\n        // stop minority number of hosts - quorum is still intact\n        int i = 0;\n        for (Entry<URI, VerificationHost> e : this.host.getInProcessHostMap().entrySet()) {\n            this.expectedFailedHosts.add(e.getKey());\n            this.host.stopHost(e.getValue());\n            if (++i >= hostStopCount) {\n                break;\n            }\n        }\n\n        // do some updates with strong quorum enabled\n        int expectedVersion = this.updateCount;\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                expectedVersion,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n    }\n\n    @Test\n    public void replicationWithQuorumAfterAbruptNodeStopMultiLocation()\n            throws Throwable {\n        // we need 6 nodes, 3 in each location\n        this.nodeCount = 6;\n\n        this.isPeerSynchronizationEnabled = true;\n        this.skipAvailabilityChecks = true;\n        this.isMultiLocationTest = true;\n\n        if (this.host == null) {\n            // create node group, join nodes and set local majority quorum\n            setUp(this.nodeCount);\n            this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n            this.host.setNodeGroupQuorum(2);\n        }\n\n        // create some documents\n        Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                this.serviceCount, null, null);\n        updateExampleServiceOptions(childStates);\n\n        // stop hosts in location \"L2\"\n        for (Entry<URI, VerificationHost> e : this.host.getInProcessHostMap().entrySet()) {\n            VerificationHost h = e.getValue();\n            if (h.getLocation().equals(VerificationHost.LOCATION2)) {\n                this.expectedFailedHosts.add(e.getKey());\n                this.host.stopHost(h);\n            }\n        }\n\n        // do some updates\n        int expectedVersion = this.updateCount;\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                expectedVersion,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n    }\n\n    /**\n     * This test validates that if a host, joined in a peer node group, stops/fails and another\n     * host, listening on the same address:port, rejoins, the existing peer members will mark the\n     * OLD host instance as FAILED, and mark the new instance, with the new ID as HEALTHY\n     *\n     * @throws Throwable\n     */\n    @Test\n    public void nodeRestartWithSameAddressDifferentId() throws Throwable {\n        int failedNodeCount = 1;\n        int afterFailureQuorum = this.nodeCount - failedNodeCount;\n\n        setUp(this.nodeCount);\n        setOperationTimeoutMicros(TimeUnit.SECONDS.toMicros(5));\n\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        this.host.log(\"Stopping node\");\n\n        // relax quorum for convergence check\n        this.host.setNodeGroupQuorum(afterFailureQuorum);\n\n        // we should now have N nodes, that see each other. Stop one of the\n        // nodes, and verify the other host's node group deletes the entry\n        List<ServiceHostState> hostStates = stopHostsToSimulateFailure(failedNodeCount);\n        URI remainingPeerNodeGroup = this.host.getPeerNodeGroupUri();\n\n        // wait for convergence of the remaining peers, before restarting. The failed host\n        // should be marked FAILED, otherwise we will not converge\n        this.host.waitForNodeGroupConvergence(this.nodeCount - failedNodeCount);\n\n        ServiceHostState stoppedHostState = hostStates.get(0);\n\n        // start a new HOST, with a new ID, but with the same address:port as the one we stopped\n        this.host.testStart(1);\n        VerificationHost newHost = this.host.setUpLocalPeerHost(stoppedHostState.httpPort,\n                VerificationHost.FAST_MAINT_INTERVAL_MILLIS, null);\n        this.host.testWait();\n\n        // re-join the remaining peers\n        URI newHostNodeGroupService = UriUtils\n                .buildUri(newHost.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP);\n        this.host.testStart(1);\n        this.host.joinNodeGroup(newHostNodeGroupService, remainingPeerNodeGroup);\n        this.host.testWait();\n\n        // now wait for convergence. If the logic is correct, the old HOST, that listened on the\n        // same port as the new host, should stay in the FAILED state, but the new host should\n        // be marked as HEALTHY\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n    }\n\n    public void setMaintenanceIntervalMillis(long defaultMaintIntervalMillis) {\n        for (VerificationHost h1 : this.host.getInProcessHostMap().values()) {\n            // set short interval so failure detection and convergence happens quickly\n            h1.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                    .toMicros(defaultMaintIntervalMillis));\n        }\n    }\n\n    @Test\n    public void synchronizationRequestQueuing() throws Throwable {\n        setUp(this.nodeCount);\n\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        waitForReplicationFactoryConvergence();\n\n        VerificationHost peerHost = this.host.getPeerHost();\n\n        List<URI> exampleUris = new ArrayList<>();\n        this.host.createExampleServices(peerHost, 1, exampleUris, null);\n\n        URI instanceUri = exampleUris.get(0);\n\n        ExampleServiceState synchState = new ExampleServiceState();\n        synchState.documentSelfLink = UriUtils.getLastPathSegment(instanceUri);\n\n        TestContext ctx = this.host.testCreate(this.updateCount);\n        for (int i = 0; i < this.updateCount; i++) {\n            Operation op = Operation.createPost(peerHost, ExampleService.FACTORY_LINK)\n                    .setBody(synchState)\n                    .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_SYNCH_OWNER)\n                    .setReferer(this.host.getUri())\n                    .setCompletion(ctx.getCompletion());\n            this.host.sendRequest(op);\n        }\n        ctx.await();\n    }\n\n    @Test\n    public void enforceHighQuorumWithNodeConcurrentStop()\n            throws Throwable {\n        int hostRestartCount = 2;\n\n        Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                this.serviceCount, null, null);\n\n        updateExampleServiceOptions(childStates);\n\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.setPeerSynchronizationTimeLimitSeconds(1);\n        }\n\n        this.host.setNodeGroupConfig(this.nodeGroupConfig);\n        this.host.setNodeGroupQuorum((this.nodeCount + 1) / 2);\n\n        // do some replication with strong quorum enabled\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                0,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n\n        long now = Utils.getNowMicrosUtc();\n\n        validatePerOperationReplicationQuorum(childStates, now);\n\n        // expect failure, since we will stop some hosts, break quorum\n        this.expectFailure = true;\n\n        // when quorum is not met the runtime will just queue requests until expiration, so\n        // we set expiration to something quick. Some requests will make it past queuing\n        // and will fail because replication quorum is not met\n        long opTimeoutMicros = TimeUnit.MILLISECONDS.toMicros(500);\n        setOperationTimeoutMicros(opTimeoutMicros);\n\n        int i = 0;\n        for (URI h : this.host.getInProcessHostMap().keySet()) {\n            this.expectedFailedHosts.add(h);\n            if (++i >= hostRestartCount) {\n                break;\n            }\n        }\n\n        // stop one host right away\n        stopHostsToSimulateFailure(1);\n\n        // concurrently with the PATCH requests below, stop another host\n        Runnable r = () -> {\n            stopHostsToSimulateFailure(hostRestartCount - 1);\n            // add a small bit of time slop since its feasible a host completed a operation *after* we stopped it,\n            // the netty handlers are stopped in async (not forced) mode\n            this.expectedFailureStartTimeMicros = Utils.getNowMicrosUtc()\n                    + TimeUnit.MILLISECONDS.toMicros(250);\n\n        };\n        this.host.schedule(r, 1, TimeUnit.MILLISECONDS);\n\n        childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                this.updateCount,\n                this.updateCount,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n\n        doStateUpdateReplicationTest(Action.PATCH, childStates.size(), this.updateCount,\n                this.updateCount * 2,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n\n        doStateUpdateReplicationTest(Action.PATCH, childStates.size(), 1,\n                this.updateCount * 2,\n                this.exampleStateUpdateBodySetter,\n                this.exampleStateConvergenceChecker,\n                childStates);\n    }\n\n    private void validatePerOperationReplicationQuorum(Map<String, ExampleServiceState> childStates,\n            long now) throws Throwable {\n        Random r = new Random();\n        // issue a patch, with per operation quorum set, verify it applied\n        for (Entry<String, ExampleServiceState> e : childStates.entrySet()) {\n            TestContext ctx = this.host.testCreate(1);\n            ExampleServiceState body = e.getValue();\n            body.counter = now;\n            Operation patch = Operation.createPatch(this.host.getPeerServiceUri(e.getKey()))\n                    .setCompletion(ctx.getCompletion())\n                    .setBody(body);\n\n            // add an explicit replication count header, using either the \"all\" value, or an\n            // explicit node count\n            if (r.nextBoolean()) {\n                patch.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                        Operation.REPLICATION_QUORUM_HEADER_VALUE_ALL);\n            } else {\n                patch.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                        this.nodeCount + \"\");\n            }\n\n            this.host.send(patch);\n            this.host.testWait(ctx);\n            // Go to each peer, directly to their index, and verify update is present. This is not\n            // proof the per operation quorum was applied \"synchronously\", before the response\n            // was sent, but over many runs, if there is a race or its applied asynchronously,\n            // we will see failures\n            for (URI hostBaseUri : this.host.getNodeGroupMap().keySet()) {\n                URI indexUri = UriUtils.buildUri(hostBaseUri, ServiceUriPaths.CORE_DOCUMENT_INDEX);\n                indexUri = UriUtils.buildIndexQueryUri(indexUri,\n                        e.getKey(), true, false, ServiceOption.PERSISTENCE);\n\n                ExampleServiceState afterState = this.host.getServiceState(null,\n                        ExampleServiceState.class, indexUri);\n                assertEquals(body.counter, afterState.counter);\n            }\n        }\n\n        this.host.toggleNegativeTestMode(true);\n        // verify that if we try to set per operation quorum too high, request will fail\n        for (Entry<String, ExampleServiceState> e : childStates.entrySet()) {\n            TestContext ctx = this.host.testCreate(1);\n            ExampleServiceState body = e.getValue();\n            body.counter = now;\n            Operation patch = Operation.createPatch(this.host.getPeerServiceUri(e.getKey()))\n                    .addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                            (this.nodeCount * 2) + \"\")\n                    .setCompletion(ctx.getExpectedFailureCompletion())\n                    .setBody(body);\n            this.host.send(patch);\n            this.host.testWait(ctx);\n            break;\n        }\n        this.host.toggleNegativeTestMode(false);\n    }\n\n    private void setOperationTimeoutMicros(long opTimeoutMicros) {\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.setOperationTimeOutMicros(opTimeoutMicros);\n        }\n        this.host.setOperationTimeOutMicros(opTimeoutMicros);\n    }\n\n    /**\n     * This test creates N local service hosts, each with K instances of a replicated service. The\n     * service will create a query task, also replicated, and self patch itself. The test makes sure\n     * all K instances, on all N hosts see the self PATCHs AND that the query tasks exist on all\n     * hosts\n     *\n     * @throws Throwable\n     */\n    @Test\n    public void replicationWithCrossServiceDependencies() throws Throwable {\n        this.isPeerSynchronizationEnabled = false;\n        setUp(this.nodeCount);\n\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n\n        Consumer<Operation> setBodyCallback = (o) -> {\n            ReplicationTestServiceState s = new ReplicationTestServiceState();\n            s.stringField = UUID.randomUUID().toString();\n            o.setBody(s);\n        };\n\n        URI hostUri = this.host.getPeerServiceUri(null);\n\n        URI factoryUri = UriUtils.buildUri(hostUri,\n                ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK);\n        doReplicatedServiceFactoryPost(this.serviceCount, setBodyCallback, factoryUri);\n\n        factoryUri = UriUtils.buildUri(hostUri,\n                ReplicationFactoryTestService.OWNER_SELECTION_SELF_LINK);\n        Map<URI, ReplicationTestServiceState> ownerSelectedServices = doReplicatedServiceFactoryPost(\n                this.serviceCount, setBodyCallback, factoryUri);\n\n        factoryUri = UriUtils.buildUri(hostUri, ReplicationFactoryTestService.STRICT_SELF_LINK);\n        doReplicatedServiceFactoryPost(this.serviceCount, setBodyCallback, factoryUri);\n\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        Query kindClause = new Query();\n        kindClause.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND)\n                .setTermMatchValue(Utils.buildKind(ReplicationTestServiceState.class));\n        q.query.addBooleanClause(kindClause);\n\n        Query nameClause = new Query();\n        nameClause.setTermPropertyName(\"stringField\")\n                .setTermMatchValue(\"*\")\n                .setTermMatchType(MatchType.WILDCARD);\n        q.query.addBooleanClause(nameClause);\n\n        // expect results for strict and regular service instances\n        int expectedServiceCount = this.serviceCount * 3;\n\n        Date exp = this.host.getTestExpiration();\n        while (exp.after(new Date())) {\n            // create N direct query tasks. Direct tasks complete in the context of the POST to the\n            // query task factory\n            int count = 10;\n            URI queryFactoryUri = UriUtils.extendUri(hostUri,\n                    ServiceUriPaths.CORE_QUERY_TASKS);\n            TestContext testContext = this.host.testCreate(count);\n\n            Map<String, QueryTask> taskResults = new ConcurrentSkipListMap<>();\n            for (int i = 0; i < count; i++) {\n                QueryTask qt = QueryTask.create(q);\n                qt.taskInfo.isDirect = true;\n                qt.documentSelfLink = UUID.randomUUID().toString();\n                Operation startPost = Operation\n                        .createPost(queryFactoryUri)\n                        .setBody(qt)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        testContext.fail(e);\n                                        return;\n                                    }\n\n                                    QueryTask rsp = o.getBody(QueryTask.class);\n                                    qt.results = rsp.results;\n                                    qt.documentOwner = rsp.documentOwner;\n                                    taskResults.put(rsp.documentSelfLink, qt);\n                                    testContext.complete();\n                                });\n\n                this.host.send(startPost);\n            }\n            testContext.await();\n            this.host.logThroughput();\n\n            boolean converged = true;\n            for (QueryTask qt : taskResults.values()) {\n                if (qt.results == null || qt.results.documentLinks == null) {\n                    throw new IllegalStateException(\"Missing results\");\n                }\n                if (qt.results.documentLinks.size() != expectedServiceCount) {\n                    this.host.log(\"%s\", Utils.toJsonHtml(qt));\n                    converged = false;\n                    break;\n                }\n            }\n\n            if (!converged) {\n                Thread.sleep(250);\n                continue;\n            }\n            break;\n        }\n\n        if (exp.before(new Date())) {\n            throw new TimeoutException();\n        }\n\n        // Negative tests: Make sure custom error response body is preserved\n        URI childUri = ownerSelectedServices.keySet().iterator().next();\n        TestContext testContext = this.host.testCreate(1);\n        ReplicationTestServiceState badRequestBody = new ReplicationTestServiceState();\n        this.host\n                .send(Operation\n                        .createPatch(childUri)\n                        .setBody(badRequestBody)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e == null) {\n                                        testContext.fail(new IllegalStateException(\n                                                \"Expected failure\"));\n                                        return;\n                                    }\n\n                                    ReplicationTestServiceErrorResponse rsp = o\n                                            .getBody(ReplicationTestServiceErrorResponse.class);\n                                    if (!ReplicationTestServiceErrorResponse.KIND\n                                            .equals(rsp.documentKind)) {\n                                        testContext.fail(new IllegalStateException(\n                                                \"Expected custom response body\"));\n                                        return;\n                                    }\n\n                                    testContext.complete();\n                                }));\n        testContext.await();\n\n        // verify that each owner selected service reports stats from the same node that reports state\n        Map<URI, ReplicationTestServiceState> latestState = this.host.getServiceState(null,\n                ReplicationTestServiceState.class, ownerSelectedServices.keySet());\n        Map<String, String> ownerIdPerLink = new HashMap<>();\n        List<URI> statsUris = new ArrayList<>();\n        for (ReplicationTestServiceState state : latestState.values()) {\n            URI statsUri = this.host.getPeerServiceUri(UriUtils.buildUriPath(\n                    state.documentSelfLink, ServiceHost.SERVICE_URI_SUFFIX_STATS));\n            ownerIdPerLink.put(state.documentSelfLink, state.documentOwner);\n            statsUris.add(statsUri);\n        }\n\n        Map<URI, ServiceStats> latestStats = this.host.getServiceState(null, ServiceStats.class,\n                statsUris);\n        for (ServiceStats perServiceStats : latestStats.values()) {\n\n            String serviceLink = UriUtils.getParentPath(perServiceStats.documentSelfLink);\n            String expectedOwnerId = ownerIdPerLink.get(serviceLink);\n            if (expectedOwnerId.equals(perServiceStats.documentOwner)) {\n                continue;\n            }\n            throw new IllegalStateException(\"owner routing issue with stats: \"\n                    + Utils.toJsonHtml(perServiceStats));\n\n        }\n\n        exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            boolean isConverged = true;\n            // verify all factories report same number of children\n            for (VerificationHost peerHost : this.host.getInProcessHostMap().values()) {\n                factoryUri = UriUtils.buildUri(peerHost,\n                        ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK);\n                ServiceDocumentQueryResult rsp = this.host.getFactoryState(factoryUri);\n                if (rsp.documentLinks.size() != latestState.size()) {\n                    this.host.log(\"Factory %s reporting %d children, expected %d\", factoryUri,\n                            rsp.documentLinks.size(), latestState.size());\n                    isConverged = false;\n                    break;\n                }\n            }\n            if (!isConverged) {\n                Thread.sleep(250);\n                continue;\n            }\n            break;\n        }\n\n        if (new Date().after(exp)) {\n            throw new TimeoutException(\"factories did not converge\");\n        }\n\n        this.host.log(\"Inducing synchronization\");\n        // Induce synchronization on stable node group. No changes should be observed since\n        // all nodes should have identical state\n        this.host.scheduleSynchronizationIfAutoSyncDisabled(this.replicationNodeSelector);\n        // give synchronization a chance to run, its 100% asynchronous so we can't really tell when each\n        // child is done, but a small delay should be sufficient for 99.9% of test environments, even under\n        // load\n        Thread.sleep(2000);\n\n        // verify that example states did not change due to the induced synchronization\n        Map<URI, ReplicationTestServiceState> latestStateAfter = this.host.getServiceState(null,\n                ReplicationTestServiceState.class, ownerSelectedServices.keySet());\n        for (Entry<URI, ReplicationTestServiceState> afterEntry : latestStateAfter.entrySet()) {\n            ReplicationTestServiceState beforeState = latestState.get(afterEntry.getKey());\n            ReplicationTestServiceState afterState = afterEntry.getValue();\n            assertEquals(beforeState.documentVersion, afterState.documentVersion);\n        }\n\n        verifyOperationJoinAcrossPeers(latestStateAfter);\n    }\n\n    private Map<URI, ReplicationTestServiceState> doReplicatedServiceFactoryPost(int serviceCount,\n            Consumer<Operation> setBodyCallback, URI factoryUri) throws Throwable,\n            InterruptedException, TimeoutException {\n\n        ServiceDocumentDescription sdd = this.host\n                .buildDescription(ReplicationTestServiceState.class);\n        Map<URI, ReplicationTestServiceState> serviceMap = this.host.doFactoryChildServiceStart(\n                null, serviceCount, ReplicationTestServiceState.class, setBodyCallback, factoryUri);\n\n        Date expiration = this.host.getTestExpiration();\n        boolean isConverged = true;\n        Map<URI, String> uriToSignature = new HashMap<>();\n        while (new Date().before(expiration)) {\n            isConverged = true;\n            uriToSignature.clear();\n            for (Entry<URI, VerificationHost> e : this.host.getInProcessHostMap().entrySet()) {\n                URI baseUri = e.getKey();\n                VerificationHost h = e.getValue();\n                URI u = UriUtils.buildUri(baseUri, factoryUri.getPath());\n                u = UriUtils.buildExpandLinksQueryUri(u);\n                ServiceDocumentQueryResult r = this.host.getFactoryState(u);\n                if (r.documents.size() != serviceCount) {\n                    this.host.log(\"instance count mismatch, expected %d, got %d, from %s\",\n                            serviceCount, r.documents.size(), u);\n                    isConverged = false;\n                    break;\n                }\n\n                for (URI instanceUri : serviceMap.keySet()) {\n                    ReplicationTestServiceState initialState = serviceMap.get(instanceUri);\n                    ReplicationTestServiceState newState = Utils.fromJson(\n                            r.documents.get(instanceUri.getPath()),\n                            ReplicationTestServiceState.class);\n                    if (newState.documentVersion == 0) {\n                        this.host.log(\"version mismatch, expected %d, got %d, from %s\", 0,\n                                newState.documentVersion, instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n\n                    if (initialState.stringField.equals(newState.stringField)) {\n                        this.host.log(\"field mismatch, expected %s, got %s, from %s\",\n                                initialState.stringField, newState.stringField, instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n\n                    if (newState.queryTaskLink == null) {\n                        this.host.log(\"missing query task link from %s\", instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n\n                    // Only instances with OWNER_SELECTION patch string field with self link so bypass this check\n                    if (!newState.documentSelfLink\n                            .contains(ReplicationFactoryTestService.STRICT_SELF_LINK)\n                            && !newState.documentSelfLink\n                            .contains(ReplicationFactoryTestService.SIMPLE_REPL_SELF_LINK)\n                            && !newState.stringField.equals(newState.documentSelfLink)) {\n                        this.host.log(\"State not in final state\");\n                        isConverged = false;\n                        break;\n                    }\n\n                    String sig = uriToSignature.get(instanceUri);\n                    if (sig == null) {\n                        sig = Utils.computeSignature(newState, sdd);\n                        uriToSignature.put(instanceUri, sig);\n                    } else {\n                        String newSig = Utils.computeSignature(newState, sdd);\n                        if (!sig.equals(newSig)) {\n                            isConverged = false;\n                            this.host.log(\"signature mismatch, expected %s, got %s, from %s\",\n                                    sig, newSig, instanceUri);\n                        }\n                    }\n\n                    ProcessingStage ps = h.getServiceStage(newState.queryTaskLink);\n                    if (ps == null || ps != ProcessingStage.AVAILABLE) {\n                        this.host.log(\"missing query task service from %s\", newState.queryTaskLink,\n                                instanceUri);\n                        isConverged = false;\n                        break;\n                    }\n                }\n\n                if (isConverged == false) {\n                    break;\n                }\n            }\n            if (isConverged == true) {\n                break;\n            }\n\n            Thread.sleep(100);\n        }\n\n        if (!isConverged) {\n            throw new TimeoutException(\"States did not converge\");\n        }\n\n        return serviceMap;\n    }\n\n    @Test\n    public void replicationWithOutOfOrderPostAndUpdates() throws Throwable {\n        // This test verifies that if a replica receives\n        // replication requests of POST and PATCH/PUT\n        // out-of-order, xenon can still handle it\n        // by doing retries for failed out-of-order\n        // updates. To verify this, we setup a node\n        // group and set quorum to just 1, so that the post\n        // returns as soon as the owner commits the post,\n        // so that we increase the chance of out-of-order\n        // update replication requests.\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        this.host.setNodeGroupQuorum(1);\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        waitForReplicationFactoryConvergence();\n\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = \"testing\";\n        state.counter = 1L;\n\n        VerificationHost peer = this.host.getPeerHost();\n\n        TestContext ctx = this.host.testCreate(this.serviceCount * this.updateCount);\n        for (int i = 0; i < this.serviceCount; i++) {\n            Operation post = Operation\n                    .createPost(peer, ExampleService.FACTORY_LINK)\n                    .setBody(state)\n                    .setReferer(this.host.getUri())\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            ctx.failIteration(e);\n                            return;\n                        }\n\n                        ExampleServiceState rsp = o.getBody(ExampleServiceState.class);\n                        for (int k = 0; k < this.updateCount; k++) {\n                            ExampleServiceState update = new ExampleServiceState();\n                            state.counter = (long) k;\n                            Operation patch = Operation\n                                    .createPatch(peer, rsp.documentSelfLink)\n                                    .setBody(update)\n                                    .setReferer(this.host.getUri())\n                                    .setCompletion(ctx.getCompletion());\n                            this.host.sendRequest(patch);\n                        }\n\n                    });\n            this.host.sendRequest(post);\n        }\n        ctx.await();\n    }\n\n    @Test\n    public void replication() throws Throwable {\n        this.replicationTargetFactoryLink = ExampleService.FACTORY_LINK;\n        doReplication();\n    }\n\n    @Test\n    public void replicationSsl() throws Throwable {\n        this.replicationUriScheme = ServiceHost.HttpScheme.HTTPS_ONLY;\n        this.replicationTargetFactoryLink = ExampleService.FACTORY_LINK;\n        doReplication();\n    }\n\n    @Test\n    public void replication1x() throws Throwable {\n        this.replicationFactor = 1L;\n        this.replicationNodeSelector = ServiceUriPaths.DEFAULT_1X_NODE_SELECTOR;\n        this.replicationTargetFactoryLink = Replication1xExampleFactoryService.SELF_LINK;\n        doReplication();\n    }\n\n    @Test\n    public void replication3x() throws Throwable {\n        this.replicationFactor = 3L;\n        this.replicationNodeSelector = ServiceUriPaths.DEFAULT_3X_NODE_SELECTOR;\n        this.replicationTargetFactoryLink = Replication3xExampleFactoryService.SELF_LINK;\n        this.nodeCount = Math.max(5, this.nodeCount);\n        doReplication();\n    }\n\n    private void doReplication() throws Throwable {\n        this.isPeerSynchronizationEnabled = false;\n        CommandLineArgumentParser.parseFromProperties(this);\n        Date expiration = new Date();\n        if (this.testDurationSeconds > 0) {\n            expiration = new Date(expiration.getTime()\n                    + TimeUnit.SECONDS.toMillis(this.testDurationSeconds));\n        }\n\n        Map<Action, Long> elapsedTimePerAction = new HashMap<>();\n        Map<Action, Long> countPerAction = new HashMap<>();\n\n        long totalOperations = 0;\n        int iterationCount = 0;\n        do {\n            if (this.host == null) {\n                setUp(this.nodeCount);\n                this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n                // for limited replication factor, we will still set the quorum high, and expect\n                // the limited replication selector to use the minimum between majority of replication\n                // factor, versus node group membership quorum\n                this.host.setNodeGroupQuorum(this.nodeCount);\n                // since we have disabled peer synch, trigger it explicitly so factories become available\n                this.host.scheduleSynchronizationIfAutoSyncDisabled(this.replicationNodeSelector);\n\n                waitForReplicatedFactoryServiceAvailable(\n                        this.host.getPeerServiceUri(this.replicationTargetFactoryLink),\n                        this.replicationNodeSelector);\n\n                waitForReplicationFactoryConvergence();\n                if (this.replicationUriScheme == ServiceHost.HttpScheme.HTTPS_ONLY) {\n                    // confirm nodes are joined using HTTPS group references\n                    for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n                        assertTrue(UriUtils.HTTPS_SCHEME.equals(nodeGroup.getScheme()));\n                    }\n                }\n\n            }\n\n            Map<String, ExampleServiceState> childStates = doExampleFactoryPostReplicationTest(\n                    this.serviceCount, countPerAction, elapsedTimePerAction);\n            totalOperations += this.serviceCount;\n\n            if (this.testDurationSeconds == 0) {\n                // various validation tests, executed just once, ignored in long running test\n                this.host.doExampleServiceUpdateAndQueryByVersion(this.host.getPeerHostUri(),\n                        this.serviceCount);\n                verifyReplicatedForcedPostAfterDelete(childStates);\n                verifyInstantNotFoundFailureOnBadLinks();\n                verifyReplicatedIdempotentPost(childStates);\n                verifyDynamicMaintOptionToggle(childStates);\n            }\n\n            totalOperations += this.serviceCount;\n\n            if (expiration == null) {\n                expiration = this.host.getTestExpiration();\n            }\n            int expectedVersion = this.updateCount;\n\n            if (!this.host.isStressTest()\n                    && (this.host.getPeerCount() > 16\n                    || this.serviceCount * this.updateCount > 100)) {\n                this.host.setStressTest(true);\n            }\n\n            long opCount = this.serviceCount * this.updateCount;\n            childStates = doStateUpdateReplicationTest(Action.PATCH, this.serviceCount,\n                    this.updateCount,\n                    expectedVersion,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    childStates,\n                    countPerAction,\n                    elapsedTimePerAction);\n            expectedVersion += this.updateCount;\n\n            totalOperations += opCount;\n\n            childStates = doStateUpdateReplicationTest(Action.PUT, this.serviceCount,\n                    this.updateCount,\n                    expectedVersion,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    childStates,\n                    countPerAction,\n                    elapsedTimePerAction);\n\n            totalOperations += opCount;\n\n            Date queryExp = this.host.getTestExpiration();\n            if (expiration.after(queryExp)) {\n                queryExp = expiration;\n            }\n            while (new Date().before(queryExp)) {\n                Set<String> links = verifyReplicatedServiceCountWithBroadcastQueries();\n                if (links.size() < this.serviceCount) {\n                    this.host.log(\"Found only %d links across nodes, retrying\", links.size());\n                    Thread.sleep(500);\n                    continue;\n                }\n                break;\n            }\n\n            totalOperations += this.serviceCount;\n\n            if (queryExp.before(new Date())) {\n                throw new TimeoutException();\n            }\n\n            expectedVersion += 1;\n            doStateUpdateReplicationTest(Action.DELETE, this.serviceCount, 1,\n                    expectedVersion,\n                    this.exampleStateUpdateBodySetter,\n                    this.exampleStateConvergenceChecker,\n                    childStates,\n                    countPerAction,\n                    elapsedTimePerAction);\n\n            totalOperations += this.serviceCount;\n\n            // compute the binary serialized payload, and the JSON payload size\n            ExampleServiceState st = childStates.values().iterator().next();\n            String json = Utils.toJson(st);\n            int byteCount = KryoSerializers.serializeDocument(st, 4096).position();\n            int jsonByteCount = json.getBytes(Utils.CHARSET).length;\n            // estimate total bytes transferred between nodes. The owner receives JSON from the client\n            // but then uses binary serialization to the N-1 replicas\n            long totalBytes = jsonByteCount * totalOperations\n                    + (this.nodeCount - 1) * byteCount * totalOperations;\n\n            this.host.log(\n                    \"Bytes per json:%d, per binary: %d, Total operations: %d, Total bytes:%d\",\n                    jsonByteCount,\n                    byteCount,\n                    totalOperations,\n                    totalBytes);\n\n            if (iterationCount++ < 2 && this.testDurationSeconds > 0) {\n                // ignore data during JVM warm-up, first two iterations\n                countPerAction.clear();\n                elapsedTimePerAction.clear();\n            }\n\n        } while (new Date().before(expiration) && this.totalOperationLimit > totalOperations);\n\n        logHostStats();\n        logPerActionThroughput(elapsedTimePerAction, countPerAction);\n\n        this.host.doNodeGroupStatsVerification(this.host.getNodeGroupMap());\n    }\n\n    private void logHostStats() {\n        for (URI u : this.host.getNodeGroupMap().keySet()) {\n            URI mgmtUri = UriUtils.buildUri(u, ServiceHostManagementService.SELF_LINK);\n            mgmtUri = UriUtils.buildStatsUri(mgmtUri);\n            ServiceStats stats = this.host.getServiceState(null, ServiceStats.class, mgmtUri);\n            this.host.log(\"%s: %s\", u, Utils.toJsonHtml(stats));\n        }\n    }\n\n    private void logPerActionThroughput(Map<Action, Long> elapsedTimePerAction,\n            Map<Action, Long> countPerAction) {\n        for (Action a : EnumSet.allOf(Action.class)) {\n            Long count = countPerAction.get(a);\n            if (count == null) {\n                continue;\n            }\n            Long elapsedMicros = elapsedTimePerAction.get(a);\n\n            double thpt = (count * 1.0) / (1.0 * elapsedMicros);\n            thpt *= 1000000;\n            this.host.log(\"Total ops for %s: %d, Throughput (ops/sec): %f\", a, count, thpt);\n        }\n    }\n\n    private void updatePerfDataPerAction(Action a, Long startTime, Long opCount,\n            Map<Action, Long> countPerAction, Map<Action, Long> elapsedTime) {\n        if (opCount == null || countPerAction != null) {\n            countPerAction.merge(a, opCount, (e, n) -> {\n                if (e == null) {\n                    return n;\n                }\n                return e + n;\n            });\n        }\n\n        if (startTime == null || elapsedTime == null) {\n            return;\n        }\n\n        long delta = Utils.getNowMicrosUtc() - startTime;\n        elapsedTime.merge(a, delta, (e, n) -> {\n            if (e == null) {\n                return n;\n            }\n            return e + n;\n        });\n    }\n\n    private void verifyReplicatedIdempotentPost(Map<String, ExampleServiceState> childStates)\n            throws Throwable {\n        // verify IDEMPOTENT POST conversion to PUT, with replication\n        // Since the factory is not idempotent by default, enable the option dynamically\n        Map<URI, URI> exampleFactoryUris = this.host\n                .getNodeGroupToFactoryMap(ExampleService.FACTORY_LINK);\n        for (URI factoryUri : exampleFactoryUris.values()) {\n            this.host.toggleServiceOptions(factoryUri,\n                    EnumSet.of(ServiceOption.IDEMPOTENT_POST), null);\n        }\n        TestContext ctx = this.host.testCreate(childStates.size());\n        for (Entry<String, ExampleServiceState> entry : childStates.entrySet()) {\n            Operation post = Operation\n                    .createPost(this.host.getPeerServiceUri(ExampleService.FACTORY_LINK))\n                    .setBody(entry.getValue())\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(post);\n        }\n        ctx.await();\n    }\n\n    /**\n     * Verifies that DELETE actions propagate and commit, and, that forced POST actions succeed\n     */\n    private void verifyReplicatedForcedPostAfterDelete(Map<String, ExampleServiceState> childStates)\n            throws Throwable {\n        // delete one of the children, then re-create but with a zero version, using a special\n        // directive that forces creation\n        Entry<String, ExampleServiceState> childEntry = childStates.entrySet().iterator().next();\n        TestContext ctx = this.host.testCreate(1);\n        Operation delete = Operation\n                .createDelete(this.host.getPeerServiceUri(childEntry.getKey()))\n                .setCompletion(ctx.getCompletion());\n        this.host.send(delete);\n        ctx.await();\n\n        if (!this.host.isRemotePeerTest()) {\n            this.host.waitFor(\"services not deleted\", () -> {\n                for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n                    ProcessingStage stg = h.getServiceStage(childEntry.getKey());\n                    if (stg != null) {\n                        this.host.log(\"Service exists %s on host %s, stage %s\",\n                                childEntry.getKey(), h.toString(), stg);\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n\n        TestContext postCtx = this.host.testCreate(1);\n        Operation opPost = Operation\n                .createPost(this.host.getPeerServiceUri(this.replicationTargetFactoryLink))\n                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_FORCE_INDEX_UPDATE)\n                .setBody(childEntry.getValue())\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        postCtx.failIteration(e);\n                    } else {\n                        postCtx.completeIteration();\n                    }\n                });\n        this.host.send(opPost);\n        this.host.testWait(postCtx);\n    }\n\n    private void waitForReplicationFactoryConvergence() throws Throwable {\n\n        // for code coverage, verify the convenience method on the host also reports available\n        WaitHandler wh = () -> {\n            TestContext ctx = this.host.testCreate(1);\n            boolean[] isReady = new boolean[1];\n            CompletionHandler ch = (o, e) -> {\n                if (e != null) {\n                    isReady[0] = false;\n                } else {\n                    isReady[0] = true;\n                }\n                ctx.completeIteration();\n            };\n\n            VerificationHost peerHost = this.host.getPeerHost();\n            if (peerHost == null) {\n                NodeGroupUtils.checkServiceAvailability(ch, this.host,\n                        this.host.getPeerServiceUri(this.replicationTargetFactoryLink),\n                        this.replicationNodeSelector);\n            } else {\n                peerHost.checkReplicatedServiceAvailable(ch, this.replicationTargetFactoryLink);\n            }\n            ctx.await();\n            return isReady[0];\n        };\n\n        this.host.waitFor(\"available check timeout for \" + this.replicationTargetFactoryLink, wh);\n    }\n\n    private Set<String> verifyReplicatedServiceCountWithBroadcastQueries()\n            throws Throwable {\n        // create a query task, which will execute on a randomly selected node. Since there is no guarantee the node\n        // selected to execute the query task is the one with all the replicated services, broadcast to all nodes, then\n        // join the results\n\n        URI nodeUri = this.host.getPeerHostUri();\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND).setTermMatchValue(\n                Utils.buildKind(ExampleServiceState.class));\n        QueryTask task = QueryTask.create(q).setDirect(true);\n        URI queryTaskFactoryUri = UriUtils\n                .buildUri(nodeUri, ServiceUriPaths.CORE_LOCAL_QUERY_TASKS);\n\n        // send the POST to the forwarding service on one of the nodes, with the broadcast query parameter set\n        URI forwardingService = UriUtils.buildBroadcastRequestUri(queryTaskFactoryUri,\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n        Set<String> links = new HashSet<>();\n\n        TestContext testContext = this.host.testCreate(1);\n        Operation postQuery = Operation\n                .createPost(forwardingService)\n                .setBody(task)\n                .setCompletion(\n                        (o, e) -> {\n                            if (e != null) {\n                                this.host.failIteration(e);\n                                return;\n                            }\n\n                            NodeGroupBroadcastResponse rsp = o\n                                    .getBody(NodeGroupBroadcastResponse.class);\n\n                            NodeGroupBroadcastResult broadcastResponse = NodeGroupUtils.toBroadcastResult(rsp);\n                            if (broadcastResponse.hasFailure()) {\n                                testContext.fail(new IllegalStateException(\n                                        \"Failure from query tasks: \" + Utils.toJsonHtml(rsp)));\n                                return;\n                            }\n\n                            // verify broadcast requests should come from all discrete nodes\n                            Set<String> ownerIds = new HashSet<>();\n\n                            for (PeerNodeResult successResponse : broadcastResponse.successResponses) {\n                                QueryTask qt = successResponse.castBodyTo(QueryTask.class);\n                                this.host.log(\"Broadcast response from %s %s\", qt.documentSelfLink,\n                                        qt.documentOwner);\n                                ownerIds.add(qt.documentOwner);\n                                if (qt.results == null) {\n                                    this.host.log(\"Node %s had no results\", successResponse.requestUri);\n                                    continue;\n                                }\n                                for (String l : qt.results.documentLinks) {\n                                    links.add(l);\n                                }\n                            }\n\n                            testContext.completeIteration();\n                        });\n\n        this.host.send(postQuery);\n        testContext.await();\n\n        return links;\n    }\n\n    private void verifyInstantNotFoundFailureOnBadLinks() throws Throwable {\n        this.host.toggleNegativeTestMode(true);\n\n        TestContext testContext = this.host.testCreate(this.serviceCount);\n\n        CompletionHandler c = (o, e) -> {\n            if (e != null) {\n                testContext.complete();\n                return;\n            }\n            // strange, service exists, lets verify\n            for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n                ProcessingStage stg = h.getServiceStage(o.getUri().getPath());\n                if (stg != null) {\n                    this.host.log(\"Service exists %s on host %s, stage %s\",\n                            o.getUri().getPath(), h.toString(), stg);\n                }\n            }\n            testContext.fail(new Throwable(\"Expected service to not exist:\"\n                    + o.toString()));\n        };\n\n        // do a negative test: send request to a example child we know does not exist, but disable queuing\n        // so we get 404 right away\n        for (int i = 0; i < this.serviceCount; i++) {\n            URI factoryURI = this.host.getNodeGroupToFactoryMap(ExampleService.FACTORY_LINK)\n                    .values().iterator().next();\n            URI bogusChild = UriUtils.extendUri(factoryURI,\n                    Utils.getNowMicrosUtc() + UUID.randomUUID().toString());\n            Operation patch = Operation.createPatch(bogusChild)\n                    .setCompletion(c)\n                    .setBody(new ExampleServiceState());\n\n            this.host.send(patch);\n        }\n        testContext.await();\n        this.host.toggleNegativeTestMode(false);\n    }\n\n    @Test\n    public void factorySynchronization() throws Throwable {\n\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n\n        factorySynchronizationNoChildren();\n\n        factoryDuplicatePost();\n    }\n\n    @Test\n    public void replicationWithAuthzCacheClear() throws Throwable {\n        this.isAuthorizationEnabled = true;\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        VerificationHost groupHost = this.host.getPeerHost();\n\n        groupHost.setSystemAuthorizationContext();\n        // wait for auth related services to be stabilized\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, UserService.FACTORY_LINK));\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, UserGroupService.FACTORY_LINK));\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, ResourceGroupService.FACTORY_LINK));\n        groupHost.waitForReplicatedFactoryServiceAvailable(\n                UriUtils.buildUri(groupHost, RoleService.FACTORY_LINK));\n\n        String fooUserLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS,\n                \"foo@vmware.com\");\n        String barUserLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS,\n                \"bar@vmware.com\");\n        String bazUserLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS,\n                \"baz@vmware.com\");\n\n\n\n        // create user, user-group, resource-group, role for foo@vmware.com\n        //   user: /core/authz/users/foo@vmware.com\n        //   user-group: /core/authz/user-groups/foo-user-group\n        //   resource-group:  /core/authz/resource-groups/foo-resource-group\n        //   role: /core/authz/roles/foo-role-1\n        TestContext testContext = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(\"foo@vmware.com\")\n                .setUserEmail(\"foo@vmware.com\")\n                .setUserPassword(\"password\")\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setUserGroupName(\"foo-user-group\")\n                .setResourceGroupName(\"foo-resource-group\")\n                .setRoleName(\"foo-role-1\")\n                .setCompletion(testContext.getCompletion())\n                .start();\n        testContext.await();\n\n        // create another user-group, resource-group, and role for foo@vmware.com\n        //   user-group: (not important)\n        //   resource-group:  (not important)\n        //   role: /core/authz/role/foo-role-2\n        TestContext ctxToCreateAnotherRole = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(fooUserLink)\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setRoleName(\"foo-role-2\")\n                .setCompletion(ctxToCreateAnotherRole.getCompletion())\n                .setupRole();\n        ctxToCreateAnotherRole.await();\n\n        // create user, user-group, resource-group, role for bar@vmware.com\n        //   user: /core/authz/users/bar@vmware.com\n        //   user-group: (not important)\n        //   resource-group:  (not important)\n        //   role: (not important)\n        TestContext ctxToCreateBar = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(\"bar@vmware.com\")\n                .setUserEmail(\"bar@vmware.com\")\n                .setUserPassword(\"password\")\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setCompletion(ctxToCreateBar.getCompletion())\n                .start();\n        ctxToCreateBar.await();\n\n        // create user, user-group, resource-group, role for baz@vmware.com\n        //   user: /core/authz/users/baz@vmware.com\n        //   user-group: (not important)\n        //   resource-group:  (not important)\n        //   role: (not important)\n        TestContext ctxToCreateBaz = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(\"baz@vmware.com\")\n                .setUserEmail(\"baz@vmware.com\")\n                .setUserPassword(\"password\")\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setCompletion(ctxToCreateBaz.getCompletion())\n                .start();\n        ctxToCreateBaz.await();\n\n        AuthorizationContext fooAuthContext = groupHost.assumeIdentity(fooUserLink);\n        AuthorizationContext barAuthContext = groupHost.assumeIdentity(barUserLink);\n        AuthorizationContext bazAuthContext = groupHost.assumeIdentity(bazUserLink);\n        String fooToken = fooAuthContext.getToken();\n        String barToken = barAuthContext.getToken();\n        String bazToken = bazAuthContext.getToken();\n\n        groupHost.resetSystemAuthorizationContext();\n\n        // verify GET will NOT clear cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/users/foo@vmware.com\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/user-groups/foo-user-group\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/resource-groups/foo-resource-group\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(\n                        UriUtils.buildUri(groupHost, \"/core/authz/roles/foo-role-1\")));\n        groupHost.resetSystemAuthorizationContext();\n        checkCacheInAllPeers(fooToken, true);\n\n        // verify deleting role should clear the auth cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createDelete(\n                        UriUtils.buildUri(groupHost, \"/core/authz/roles/foo-role-1\")));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(fooToken);\n\n        // verify deleting user-group should clear the auth cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        // delete the user group associated with the user\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createDelete(\n                        UriUtils.buildUri(groupHost, \"/core/authz/user-groups/foo-user-group\")));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(fooToken);\n\n        // verify creating new role should clear the auth cache (using bar@vmware.com)\n        populateAuthCacheInAllPeers(barAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        Query q = Builder.create()\n                .addFieldClause(\n                        ExampleServiceState.FIELD_NAME_KIND,\n                        Utils.buildKind(ExampleServiceState.class))\n                .build();\n        TestContext ctxToCreateAnotherRoleForBar = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(groupHost)\n                .setUserSelfLink(barUserLink)\n                .setResourceGroupName(\"/core/authz/resource-groups/new-rg\")\n                .setResourceQuery(q)\n                .setRoleName(\"bar-role-2\")\n                .setCompletion(ctxToCreateAnotherRoleForBar.getCompletion())\n                .setupRole();\n        ctxToCreateAnotherRoleForBar.await();\n        groupHost.resetSystemAuthorizationContext();\n\n        verifyAuthCacheHasClearedInAllPeers(barToken);\n\n        //\n        populateAuthCacheInAllPeers(barAuthContext);\n        groupHost.setSystemAuthorizationContext();\n\n        // Updating the resource group should be able to handle the fact that the user group does not exist\n        String newResourceGroupLink = \"/core/authz/resource-groups/new-rg\";\n        Query updateResourceGroupQuery = Builder.create()\n                .addFieldClause(ExampleServiceState.FIELD_NAME_NAME, \"bar\")\n                .build();\n        ResourceGroupState resourceGroupState = new ResourceGroupState();\n        resourceGroupState.query = updateResourceGroupQuery;\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPut(UriUtils.buildUri(groupHost, newResourceGroupLink))\n                        .setBody(resourceGroupState));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(barToken);\n\n        // verify patching user should clear the auth cache\n        populateAuthCacheInAllPeers(fooAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        UserState userState = new UserState();\n        userState.userGroupLinks = new HashSet<>();\n        userState.userGroupLinks.add(\"foo\");\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPatch(UriUtils.buildUri(groupHost, fooUserLink))\n                        .setBody(userState));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(fooToken);\n\n        // verify deleting user should clear the auth cache\n        populateAuthCacheInAllPeers(bazAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createDelete(UriUtils.buildUri(groupHost, bazUserLink)));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(bazToken);\n\n        // verify patching ResourceGroup should clear the auth cache\n        // uses \"new-rg\" resource group that has associated to user bar\n        TestRequestSender sender = new TestRequestSender(this.host.getPeerHost());\n        groupHost.setSystemAuthorizationContext();\n        Operation newResourceGroupGetOp = Operation.createGet(groupHost, newResourceGroupLink);\n        ResourceGroupState newResourceGroupState = sender.sendAndWait(newResourceGroupGetOp, ResourceGroupState.class);\n        groupHost.resetSystemAuthorizationContext();\n\n        PatchQueryRequest patchBody = PatchQueryRequest.create(newResourceGroupState.query, false);\n\n        populateAuthCacheInAllPeers(barAuthContext);\n        groupHost.setSystemAuthorizationContext();\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPatch(UriUtils.buildUri(groupHost, newResourceGroupLink))\n                        .setBody(patchBody));\n        groupHost.resetSystemAuthorizationContext();\n        verifyAuthCacheHasClearedInAllPeers(barToken);\n\n    }\n\n    private void populateAuthCacheInAllPeers(AuthorizationContext authContext) throws Throwable {\n\n        // send a GET request to the ExampleService factory to populate auth cache on each peer.\n        // since factory is not OWNER_SELECTION service, request goes to the specified node.\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            peer.setAuthorizationContext(authContext);\n\n            // based on the role created in test, all users have access to ExampleService\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createGet(UriUtils.buildUri(peer, ExampleService.FACTORY_LINK)));\n        }\n\n        this.host.waitFor(\"Timeout waiting for correct auth cache state\",\n                () -> checkCacheInAllPeers(authContext.getToken(), true));\n    }\n\n    private void verifyAuthCacheHasClearedInAllPeers(String userToken) {\n        this.host.waitFor(\"Timeout waiting for correct auth cache state\",\n                () -> checkCacheInAllPeers(userToken, false));\n    }\n\n    private boolean checkCacheInAllPeers(String token, boolean expectEntries) throws Throwable {\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            peer.setSystemAuthorizationContext();\n            MinimalTestService s = new MinimalTestService();\n            peer.addPrivilegedService(MinimalTestService.class);\n            peer.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n            peer.resetSystemAuthorizationContext();\n\n            boolean contextFound = peer.getAuthorizationContext(s, token) != null;\n            if ((expectEntries && !contextFound) || (!expectEntries && contextFound)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void factoryDuplicatePost() throws Throwable, InterruptedException, TimeoutException {\n        // pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n        Consumer<Operation> setBodyCallback = (o) -> {\n            ReplicationTestServiceState s = new ReplicationTestServiceState();\n            s.stringField = UUID.randomUUID().toString();\n            o.setBody(s);\n        };\n\n        URI factoryUri = this.host\n                .getPeerServiceUri(ReplicationFactoryTestService.OWNER_SELECTION_SELF_LINK);\n        Map<URI, ReplicationTestServiceState> states = doReplicatedServiceFactoryPost(\n                this.serviceCount, setBodyCallback, factoryUri);\n\n        TestContext testContext = serviceHost.testCreate(states.size());\n        ReplicationTestServiceState initialState = new ReplicationTestServiceState();\n\n        for (URI uri : states.keySet()) {\n            initialState.documentSelfLink = uri.toString().substring(uri.toString()\n                    .lastIndexOf(UriUtils.URI_PATH_CHAR) + 1);\n            Operation createPost = Operation\n                    .createPost(factoryUri)\n                    .setBody(initialState)\n                    .setCompletion(\n                            (o, e) -> {\n                                if (o.getStatusCode() != Operation.STATUS_CODE_CONFLICT) {\n                                    testContext.fail(\n                                            new IllegalStateException(\n                                                    \"Incorrect response code received\"));\n                                    return;\n                                }\n                                testContext.complete();\n                            });\n            serviceHost.send(createPost);\n        }\n        testContext.await();\n    }\n\n    private void factorySynchronizationNoChildren() throws Throwable {\n        int factoryCount = Math.max(this.serviceCount, 25);\n        setUp(this.nodeCount);\n\n        // start many factories, in each host, so when the nodes join there will be a storm\n        // of synchronization requests between the nodes + factory instances\n        TestContext testContext = this.host.testCreate(this.nodeCount * factoryCount);\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            for (int i = 0; i < factoryCount; i++) {\n                Operation startPost = Operation.createPost(\n                        UriUtils.buildUri(h,\n                                UriUtils.buildUriPath(ExampleService.FACTORY_LINK, UUID\n                                        .randomUUID().toString())))\n                        .setCompletion(testContext.getCompletion());\n                h.startService(startPost, ExampleService.createFactory());\n            }\n        }\n        testContext.await();\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n    }\n\n    @Test\n    public void forwardingAndSelection() throws Throwable {\n        this.isPeerSynchronizationEnabled = false;\n        setUp(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        for (int i = 0; i < this.iterationCount; i++) {\n            directOwnerSelection();\n            forwardingToPeerId();\n            forwardingToKeyHashNode();\n            broadcast();\n        }\n    }\n\n    public void broadcast() throws Throwable {\n        // Do a broadcast on a local, non replicated service. Replicated services can not\n        // be used with broadcast since they will duplicate the update and potentially route\n        // to a single node\n        URI nodeGroup = this.host.getPeerNodeGroupUri();\n\n        long c = this.updateCount * this.nodeCount;\n        List<ServiceDocument> initialStates = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            ServiceDocument s = this.host.buildMinimalTestState();\n            s.documentSelfLink = UUID.randomUUID().toString();\n            initialStates.add(s);\n        }\n\n        TestContext testContext = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                Operation post = Operation.createPost(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(testContext.getCompletion())\n                        .setBody(s);\n                peer.startService(post, new MinimalTestService());\n            }\n        }\n        testContext.await();\n\n        // we broadcast one update, per service, through one peer. We expect to see\n        // the same update across all peers, just like with replicated services\n        nodeGroup = this.host.getPeerNodeGroupUri();\n        testContext = this.host.testCreate(initialStates.size());\n        for (ServiceDocument s : initialStates) {\n            URI serviceUri = UriUtils.buildUri(nodeGroup, s.documentSelfLink);\n            URI u = UriUtils.buildBroadcastRequestUri(serviceUri,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                    .buildMinimalTestState();\n            body.id = serviceUri.getPath();\n            this.host.send(Operation.createPut(u)\n                    .setCompletion(testContext.getCompletion())\n                    .setBody(body));\n        }\n        testContext.await();\n\n        for (URI baseHostUri : this.host.getNodeGroupMap().keySet()) {\n            List<URI> uris = new ArrayList<>();\n            for (ServiceDocument s : initialStates) {\n                URI serviceUri = UriUtils.buildUri(baseHostUri, s.documentSelfLink);\n                uris.add(serviceUri);\n            }\n            Map<URI, MinimalTestServiceState> states = this.host.getServiceState(null,\n                    MinimalTestServiceState.class, uris);\n            for (MinimalTestServiceState s : states.values()) {\n                // the PUT we issued, should have been forwarded to this service and modified its\n                // initial ID to be the same as the self link\n                if (!s.id.equals(s.documentSelfLink)) {\n                    throw new IllegalStateException(\"Service broadcast failure\");\n                }\n\n            }\n        }\n    }\n\n    public void forwardingToKeyHashNode() throws Throwable {\n        long c = this.updateCount * this.nodeCount;\n        Map<String, List<String>> ownersPerServiceLink = new HashMap<>();\n\n        // 0) Create N service instances, in each peer host. Services are NOT replicated\n        // 1) issue a forward request to owner, per service link\n        // 2) verify the request ended up on the owner the partitioning service predicted\n        List<ServiceDocument> initialStates = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            ServiceDocument s = this.host.buildMinimalTestState();\n            s.documentSelfLink = UUID.randomUUID().toString();\n            initialStates.add(s);\n        }\n\n        TestContext testContext = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                Operation post = Operation.createPost(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(testContext.getCompletion())\n                        .setBody(s);\n                peer.startService(post, new MinimalTestService());\n            }\n        }\n        testContext.await();\n\n        URI nodeGroup = this.host.getPeerNodeGroupUri();\n        testContext = this.host.testCreate(initialStates.size());\n        for (ServiceDocument s : initialStates) {\n            URI serviceUri = UriUtils.buildUri(nodeGroup, s.documentSelfLink);\n            URI u = UriUtils.buildForwardRequestUri(serviceUri,\n                    null,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                    .buildMinimalTestState();\n            body.id = serviceUri.getPath();\n            this.host.send(Operation.createPut(u)\n                    .setCompletion(testContext.getCompletion())\n                    .setBody(body));\n        }\n        testContext.await();\n        this.host.logThroughput();\n\n        AtomicInteger assignedLinks = new AtomicInteger();\n        TestContext testContextForPost = this.host.testCreate(initialStates.size());\n        for (ServiceDocument s : initialStates) {\n            // make sure the key is the path to the service. The initial state self link is not a\n            // path ...\n            String key = UriUtils.normalizeUriPath(s.documentSelfLink);\n            s.documentSelfLink = key;\n            SelectAndForwardRequest body = new SelectAndForwardRequest();\n            body.key = key;\n            Operation post = Operation.createPost(UriUtils.buildUri(nodeGroup,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR))\n                    .setBody(body)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            testContextForPost.fail(e);\n                            return;\n                        }\n                        synchronized (ownersPerServiceLink) {\n                            SelectOwnerResponse rsp = o.getBody(SelectOwnerResponse.class);\n                            List<String> links = ownersPerServiceLink.get(rsp.ownerNodeId);\n                            if (links == null) {\n                                links = new ArrayList<>();\n                                ownersPerServiceLink.put(rsp.ownerNodeId, links);\n                            }\n                            links.add(key);\n                            ownersPerServiceLink.put(rsp.ownerNodeId, links);\n                        }\n                        assignedLinks.incrementAndGet();\n                        testContextForPost.complete();\n                    });\n            this.host.send(post);\n        }\n        testContextForPost.await();\n\n        assertTrue(assignedLinks.get() == initialStates.size());\n\n        // verify the services on the node that should be owner, has modified state\n        for (Entry<String, List<String>> e : ownersPerServiceLink.entrySet()) {\n            String nodeId = e.getKey();\n            List<String> links = e.getValue();\n            NodeState ns = this.host.getNodeStateMap().get(nodeId);\n            List<URI> uris = new ArrayList<>();\n            // make a list of URIs to the services assigned to this peer node\n            for (String l : links) {\n                uris.add(UriUtils.buildUri(ns.groupReference, l));\n            }\n\n            Map<URI, MinimalTestServiceState> states = this.host.getServiceState(null,\n                    MinimalTestServiceState.class, uris);\n            for (MinimalTestServiceState s : states.values()) {\n                // the PUT we issued, should have been forwarded to this service and modified its\n                // initial ID to be the same as the self link\n                if (!s.id.equals(s.documentSelfLink)) {\n                    throw new IllegalStateException(\"Service forwarding failure\");\n                } else {\n                }\n            }\n        }\n    }\n\n    public void forwardingToPeerId() throws Throwable {\n        long c = this.updateCount * this.nodeCount;\n        // 0) Create N service instances, in each peer host. Services are NOT replicated\n        // 1) issue a forward request to a specific peer id, per service link\n        // 2) verify the request ended up on the peer we targeted\n        List<ServiceDocument> initialStates = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            ServiceDocument s = this.host.buildMinimalTestState();\n            s.documentSelfLink = UUID.randomUUID().toString();\n            initialStates.add(s);\n        }\n\n        TestContext testContext = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                s = Utils.clone(s);\n                // set the owner to be the target node. we will use this to verify it matches\n                // the id in the state, which is set through a forwarded PATCH\n                s.documentOwner = peer.getId();\n                Operation post = Operation.createPost(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(testContext.getCompletion())\n                        .setBody(s);\n                peer.startService(post, new MinimalTestService());\n            }\n        }\n        testContext.await();\n\n        VerificationHost peerEntryPoint = this.host.getPeerHost();\n\n        // add a custom header and make sure the service sees it in its handler, in the request\n        // headers, and we see a service response header in our response\n        String headerName = MinimalTestService.TEST_HEADER_NAME.toLowerCase();\n        UUID id = UUID.randomUUID();\n        String headerRequestValue = \"request-\" + id;\n        String headerResponseValue = \"response-\" + id;\n        TestContext testContextForPut = this.host.testCreate(initialStates.size() * this.nodeCount);\n\n        for (ServiceDocument s : initialStates) {\n            // send a PATCH the id for each document, to each peer. If it routes to the proper peer\n            // the initial state.documentOwner, will match the state.id\n\n            for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n                // For testing coverage, force the use of the same forwarding service instance.\n                // We make all request flow from one peer to others, testing both loopback p2p\n                // and true forwarding. Otherwise, the forwarding happens by directly contacting\n                // peer we want to land on!\n                URI localForwardingUri = UriUtils.buildUri(peerEntryPoint.getUri(),\n                        s.documentSelfLink);\n                // add a query to make sure it does not affect forwarding\n                localForwardingUri = UriUtils.extendUriWithQuery(localForwardingUri, \"k\", \"v\",\n                        \"k1\", \"v1\", \"k2\", \"v2\");\n                URI u = UriUtils.buildForwardToPeerUri(localForwardingUri, peer.getId(),\n                        ServiceUriPaths.DEFAULT_NODE_SELECTOR, EnumSet.noneOf(ServiceOption.class));\n                MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                        .buildMinimalTestState();\n                body.id = peer.getId();\n\n                this.host.send(Operation.createPut(u)\n                        .addRequestHeader(headerName, headerRequestValue)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        testContextForPut.fail(e);\n                                        return;\n                                    }\n                                    String value = o.getResponseHeader(headerName);\n                                    if (value == null || !value.equals(headerResponseValue)) {\n                                        testContextForPut.fail(new IllegalArgumentException(\n                                                \"response header not found\"));\n                                        return;\n                                    }\n                                    testContextForPut.complete();\n                                })\n                        .setBody(body));\n            }\n        }\n        testContextForPut.await();\n        this.host.logThroughput();\n\n        TestContext ctx = this.host.testCreate(c * this.host.getPeerCount());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            for (ServiceDocument s : initialStates) {\n                Operation get = Operation.createGet(UriUtils.buildUri(peer, s.documentSelfLink))\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        ctx.fail(e);\n                                        return;\n                                    }\n                                    MinimalTestServiceState rsp = o\n                                            .getBody(MinimalTestServiceState.class);\n                                    if (!rsp.id.equals(rsp.documentOwner)) {\n                                        ctx.fail(\n                                                new IllegalStateException(\"Expected: \"\n                                                        + rsp.documentOwner + \" was: \" + rsp.id));\n                                    } else {\n                                        ctx.complete();\n                                    }\n                                });\n                this.host.send(get);\n            }\n        }\n        ctx.await();\n\n        // Do a negative test: Send a request that will induce failure in the service handler and\n        // make sure we receive back failure, with a ServiceErrorResponse body\n\n        this.host.toggleDebuggingMode(true);\n        TestContext testCxtForPut = this.host.testCreate(this.host.getInProcessHostMap().size());\n        for (VerificationHost peer : this.host.getInProcessHostMap().values()) {\n            ServiceDocument s = initialStates.get(0);\n            URI serviceUri = UriUtils.buildUri(peerEntryPoint.getUri(), s.documentSelfLink);\n            URI u = UriUtils.buildForwardToPeerUri(serviceUri, peer.getId(),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR,\n                    null);\n            MinimalTestServiceState body = (MinimalTestServiceState) this.host\n                    .buildMinimalTestState();\n            // setting id to null will cause validation failure.\n            body.id = null;\n            this.host.send(Operation.createPut(u)\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e == null) {\n                                    testCxtForPut.fail(new IllegalStateException(\n                                            \"expected failure\"));\n                                    return;\n                                }\n                                MinimalTestServiceErrorResponse rsp = o\n                                        .getBody(MinimalTestServiceErrorResponse.class);\n                                if (rsp.message == null || rsp.message.isEmpty()) {\n                                    testCxtForPut.fail(new IllegalStateException(\n                                            \"expected error response message\"));\n                                    return;\n                                }\n\n                                if (!MinimalTestServiceErrorResponse.KIND.equals(rsp.documentKind)\n                                        || 0 != Double.compare(Math.PI, rsp.customErrorField)) {\n                                    testCxtForPut.fail(new IllegalStateException(\n                                            \"expected custom error fields\"));\n                                    return;\n                                }\n                                testCxtForPut.complete();\n                            })\n                    .setBody(body));\n        }\n        testCxtForPut.await();\n        this.host.toggleDebuggingMode(false);\n    }\n\n    private void directOwnerSelection() throws Throwable {\n        Map<URI, Map<String, Long>> keyToNodeAssignmentsPerNode = new HashMap<>();\n        List<String> keys = new ArrayList<>();\n\n        long c = this.updateCount * this.nodeCount;\n        // generate N keys once, then ask each node to assign to its peers. Each node should come up\n        // with the same distribution\n\n        for (int i = 0; i < c; i++) {\n            keys.add(Utils.getNowMicrosUtc() + \"\");\n        }\n\n        for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n            keyToNodeAssignmentsPerNode.put(nodeGroup, new HashMap<>());\n        }\n\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n\n        TestContext testContext = this.host.testCreate(c * this.nodeCount);\n        for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n            for (String key : keys) {\n                SelectAndForwardRequest body = new SelectAndForwardRequest();\n                body.key = key;\n                Operation post = Operation\n                        .createPost(UriUtils.buildUri(nodeGroup,\n                                ServiceUriPaths.DEFAULT_NODE_SELECTOR))\n                        .setBody(body)\n                        .setCompletion(\n                                (o, e) -> {\n                                    try {\n                                        synchronized (keyToNodeAssignmentsPerNode) {\n                                            SelectOwnerResponse rsp = o\n                                                    .getBody(SelectOwnerResponse.class);\n                                            Map<String, Long> assignmentsPerNode = keyToNodeAssignmentsPerNode\n                                                    .get(nodeGroup);\n                                            Long l = assignmentsPerNode.get(rsp.ownerNodeId);\n                                            if (l == null) {\n                                                l = 0L;\n                                            }\n                                            assignmentsPerNode.put(rsp.ownerNodeId, l + 1);\n                                            testContext.complete();\n                                        }\n                                    } catch (Throwable ex) {\n                                        testContext.fail(ex);\n                                    }\n                                });\n                this.host.send(post);\n            }\n        }\n        testContext.await();\n        this.host.logThroughput();\n\n        Map<String, Long> countPerNode = null;\n\n        for (URI nodeGroup : this.host.getNodeGroupMap().values()) {\n            Map<String, Long> assignmentsPerNode = keyToNodeAssignmentsPerNode.get(nodeGroup);\n            if (countPerNode == null) {\n                countPerNode = assignmentsPerNode;\n            }\n\n            this.host.log(\"Node group %s assignments: %s\", nodeGroup, assignmentsPerNode);\n\n            for (Entry<String, Long> e : assignmentsPerNode.entrySet()) {\n                // we assume that with random keys, and random node ids, each node will get at least\n                // one key.\n                assertTrue(e.getValue() > 0);\n                Long count = countPerNode.get(e.getKey());\n                if (count == null) {\n                    continue;\n                }\n                if (!count.equals(e.getValue())) {\n                    this.host.logNodeGroupState();\n                    throw new IllegalStateException(\n                            \"Node id got assigned the same key different number of times, on one of the nodes\");\n                }\n            }\n\n        }\n    }\n\n    @Test\n    public void replicationFullQuorumMissingServiceOnPeer() throws Throwable {\n        // This test verifies the following scenario:\n        // A new node joins an existing node-group with\n        // services already created. Synchronization is\n        // still in-progress and a write request arrives.\n        // If the quorum is configured to FULL, the write\n        // request will fail on the new node with not-found\n        // error, since synchronization hasn't completed.\n        // The test verifies that when this happens, the\n        // owner node will try to synchronize on-demand\n        // and retry the original update reqeust.\n\n        // Artificially setting the replica not found timeout to\n        // a lower-value, to reduce the wait time before owner\n        // retries\n        System.setProperty(\n                NodeSelectorReplicationService.PROPERTY_NAME_REPLICA_NOT_FOUND_TIMEOUT_MICROS,\n                Long.toString(TimeUnit.MILLISECONDS.toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS)));\n\n        this.host = VerificationHost.create(0);\n        this.host.setPeerSynchronizationEnabled(false);\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(\n                VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n        this.host.start();\n\n        // Setup one host and create some example\n        // services on it.\n        List<URI> exampleUris = new ArrayList<>();\n        this.host.createExampleServices(this.host, this.serviceCount, exampleUris, null);\n\n        // Add a second host with synchronization disabled,\n        // Join it to the existing host.\n        VerificationHost host2 = new VerificationHost();\n\n        try {\n            TemporaryFolder tmpFolder = new TemporaryFolder();\n            tmpFolder.create();\n\n            String mainHostId = \"main-\" + VerificationHost.hostNumber.incrementAndGet();\n            String[] args = {\n                    \"--id=\" + mainHostId,\n                    \"--port=0\",\n                    \"--bindAddress=127.0.0.1\",\n                    \"--sandbox=\"\n                            + tmpFolder.getRoot().getAbsolutePath(),\n                    \"--peerNodes=\" + this.host.getUri()\n            };\n\n            host2.initialize(args);\n            host2.setPeerSynchronizationEnabled(false);\n            host2.setMaintenanceIntervalMicros(\n                    TimeUnit.MILLISECONDS.toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n            host2.start();\n\n            this.host.addPeerNode(host2);\n\n            // Wait for node-group to converge\n            List<URI> nodeGroupUris = new ArrayList<>();\n            nodeGroupUris.add(UriUtils.buildUri(this.host, ServiceUriPaths.DEFAULT_NODE_GROUP));\n            nodeGroupUris.add(UriUtils.buildUri(host2, ServiceUriPaths.DEFAULT_NODE_GROUP));\n            this.host.waitForNodeGroupConvergence(nodeGroupUris, 2, 2, true);\n\n            // Set the quorum to full.\n            this.host.setNodeGroupQuorum(2, nodeGroupUris.get(0));\n            host2.setNodeGroupQuorum(2);\n\n            // Filter the created examples to only those\n            // that are owned by host-1.\n            List<URI> host1Examples = exampleUris.stream()\n                    .filter(e -> this.host.isOwner(e.getPath(), ServiceUriPaths.DEFAULT_NODE_SELECTOR))\n                    .collect(Collectors.toList());\n\n            // Start patching all filtered examples. Because\n            // synchronization is disabled each of these\n            // example services will not exist on the new\n            // node that we added resulting in a non_found\n            // error. However, the owner will retry this\n            // after on-demand synchronization and hence\n            // patches should succeed.\n            ExampleServiceState state = new ExampleServiceState();\n            state.counter = 1L;\n\n            if (host1Examples.size() > 0) {\n                this.host.log(Level.INFO, \"Starting patches\");\n                TestContext ctx = this.host.testCreate(host1Examples.size());\n                for (URI exampleUri : host1Examples) {\n                    Operation patch = Operation\n                            .createPatch(exampleUri)\n                            .setBody(state)\n                            .setReferer(\"localhost\")\n                            .setCompletion(ctx.getCompletion());\n                    this.host.sendRequest(patch);\n                }\n                ctx.await();\n            }\n        } finally {\n            host2.tearDown();\n        }\n    }\n\n    @Test\n    public void replicationWithAuthAndNodeRestart() throws Throwable {\n        AuthorizationHelper authHelper;\n\n        this.isAuthorizationEnabled = true;\n        setUp(this.nodeCount);\n\n        authHelper = new AuthorizationHelper(this.host);\n\n        // relax quorum to allow for divergent writes, on independent nodes (not yet joined)\n\n        this.host.setSystemAuthorizationContext();\n\n        // Create the same users and roles on every peer independently\n        Map<ServiceHost, Collection<String>> roleLinksByHost = new HashMap<>();\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            String email = \"jane@doe.com\";\n            authHelper.createUserService(h, email);\n            authHelper.createRoles(h, email);\n        }\n\n        // Get roles from all nodes\n        Map<ServiceHost, Map<URI, RoleState>> roleStateByHost = getRolesByHost(roleLinksByHost);\n\n        // Join nodes to force synchronization and convergence\n        this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n\n        // Get roles from all nodes\n        Map<ServiceHost, Map<URI, RoleState>> newRoleStateByHost = getRolesByHost(roleLinksByHost);\n\n        // Verify that every host independently advances their version & epoch\n        for (ServiceHost h : roleStateByHost.keySet()) {\n            Map<URI, RoleState> roleState = roleStateByHost.get(h);\n            for (URI u : roleState.keySet()) {\n                RoleState oldRole = roleState.get(u);\n                RoleState newRole = newRoleStateByHost.get(h).get(u);\n                assertTrue(\"version should have advanced\",\n                        newRole.documentVersion > oldRole.documentVersion);\n                assertTrue(\"epoch should have advanced\",\n                        newRole.documentEpoch > oldRole.documentEpoch);\n            }\n        }\n\n        // Verify that every host converged to the same version, epoch, and owner\n        Map<String, Long> versions = new HashMap<>();\n        Map<String, Long> epochs = new HashMap<>();\n        Map<String, String> owners = new HashMap<>();\n        for (ServiceHost h : newRoleStateByHost.keySet()) {\n            Map<URI, RoleState> roleState = newRoleStateByHost.get(h);\n            for (URI u : roleState.keySet()) {\n                RoleState newRole = roleState.get(u);\n\n                if (versions.containsKey(newRole.documentSelfLink)) {\n                    assertTrue(versions.get(newRole.documentSelfLink) == newRole.documentVersion);\n                } else {\n                    versions.put(newRole.documentSelfLink, newRole.documentVersion);\n                }\n\n                if (epochs.containsKey(newRole.documentSelfLink)) {\n                    assertTrue(Objects.equals(epochs.get(newRole.documentSelfLink),\n                            newRole.documentEpoch));\n                } else {\n                    epochs.put(newRole.documentSelfLink, newRole.documentEpoch);\n                }\n\n                if (owners.containsKey(newRole.documentSelfLink)) {\n                    assertEquals(owners.get(newRole.documentSelfLink), newRole.documentOwner);\n                } else {\n                    owners.put(newRole.documentSelfLink, newRole.documentOwner);\n                }\n            }\n        }\n\n        // create some example tasks, which delete example services. We dont have any\n        // examples services created, which is good, since we just want these tasks to\n        // go to finished state, then verify, after node restart, they all start\n        Set<String> exampleTaskLinks = new ConcurrentSkipListSet<>();\n        createReplicatedExampleTasks(exampleTaskLinks, null);\n\n        Set<String> exampleLinks = new ConcurrentSkipListSet<>();\n        verifyReplicatedAuthorizedPost(exampleLinks);\n\n        // verify restart, with authorization.\n        // stop one host\n        VerificationHost hostToStop = this.host.getInProcessHostMap().values().iterator().next();\n        stopAndRestartHost(exampleLinks, exampleTaskLinks, hostToStop);\n    }\n\n    private void createReplicatedExampleTasks(Set<String> exampleTaskLinks, String name)\n            throws Throwable {\n        URI factoryUri = UriUtils.buildFactoryUri(this.host.getPeerHost(),\n                ExampleTaskService.class);\n        this.host.setSystemAuthorizationContext();\n        // Sample body that this user is authorized to create\n        ExampleTaskServiceState exampleServiceState = new ExampleTaskServiceState();\n        if (name != null) {\n            exampleServiceState.customQueryClause = Query.Builder.create()\n                    .addFieldClause(ExampleServiceState.FIELD_NAME_NAME, name).build();\n        }\n        this.host.log(\"creating example *task* instances\");\n        TestContext testContext = this.host.testCreate(this.serviceCount);\n        for (int i = 0; i < this.serviceCount; i++) {\n            CompletionHandler c = (o, e) -> {\n                if (e != null) {\n                    testContext.fail(e);\n                    return;\n                }\n                ExampleTaskServiceState rsp = o.getBody(ExampleTaskServiceState.class);\n                synchronized (exampleTaskLinks) {\n                    exampleTaskLinks.add(rsp.documentSelfLink);\n                }\n                testContext.complete();\n            };\n            this.host.send(Operation\n                    .createPost(factoryUri)\n                    .setBody(exampleServiceState)\n                    .setCompletion(c));\n        }\n        testContext.await();\n\n        // ensure all tasks are in finished state\n        this.host.waitFor(\"Example tasks did not finish\", () -> {\n            ServiceDocumentQueryResult rsp = this.host.getExpandedFactoryState(factoryUri);\n            for (Object o : rsp.documents.values()) {\n                ExampleTaskServiceState doc = Utils.fromJson(o, ExampleTaskServiceState.class);\n                if (TaskState.isFailed(doc.taskInfo)) {\n                    this.host.log(\"task %s failed: %s\", doc.documentSelfLink, doc.failureMessage);\n                    throw new IllegalStateException(\"task failed\");\n                }\n                if (!TaskState.isFinished(doc.taskInfo)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    private void verifyReplicatedAuthorizedPost(Set<String> exampleLinks)\n            throws Throwable {\n        Collection<VerificationHost> hosts = this.host.getInProcessHostMap().values();\n        RoundRobinIterator<VerificationHost> it = new RoundRobinIterator<>(hosts);\n        int exampleServiceCount = this.serviceCount;\n\n        String userLink = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, \"jane@doe.com\");\n        // Verify we can assert identity and make a request to every host\n        this.host.assumeIdentity(userLink);\n\n        // Sample body that this user is authorized to create\n        ExampleServiceState exampleServiceState = new ExampleServiceState();\n        exampleServiceState.name = \"jane\";\n\n        this.host.log(\"creating example instances\");\n        TestContext testContext = this.host.testCreate(exampleServiceCount);\n        for (int i = 0; i < exampleServiceCount; i++) {\n            CompletionHandler c = (o, e) -> {\n                if (e != null) {\n                    testContext.fail(e);\n                    return;\n                }\n\n                try {\n                    // Verify the user is set as principal\n                    ExampleServiceState state = o.getBody(ExampleServiceState.class);\n                    assertEquals(state.documentAuthPrincipalLink,\n                            userLink);\n                    exampleLinks.add(state.documentSelfLink);\n                    testContext.complete();\n                } catch (Throwable e2) {\n                    testContext.fail(e2);\n                }\n            };\n            this.host.send(Operation\n                    .createPost(UriUtils.buildFactoryUri(it.next(), ExampleService.class))\n                    .setBody(exampleServiceState)\n                    .setCompletion(c));\n        }\n        testContext.await();\n\n        this.host.toggleNegativeTestMode(true);\n        // Sample body that this user is NOT authorized to create\n        ExampleServiceState invalidExampleServiceState = new ExampleServiceState();\n        invalidExampleServiceState.name = \"somebody other than jane\";\n\n        this.host.log(\"issuing non authorized request\");\n        TestContext testCtx = this.host.testCreate(exampleServiceCount);\n        for (int i = 0; i < exampleServiceCount; i++) {\n            this.host.send(Operation\n                    .createPost(UriUtils.buildFactoryUri(it.next(), ExampleService.class))\n                    .setBody(invalidExampleServiceState)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            assertEquals(Operation.STATUS_CODE_FORBIDDEN, o.getStatusCode());\n                            testCtx.complete();\n                            return;\n                        }\n\n                        testCtx.fail(new IllegalStateException(\"expected failure\"));\n                    }));\n        }\n        testCtx.await();\n        this.host.toggleNegativeTestMode(false);\n    }\n\n    private void stopAndRestartHost(Set<String> exampleLinks, Set<String> exampleTaskLinks,\n            VerificationHost hostToStop)\n            throws Throwable, InterruptedException {\n        // relax quorum\n        this.host.setNodeGroupQuorum(this.nodeCount - 1);\n        // expire node that went away quickly to avoid alot of log spam from gossip failures\n        NodeGroupConfig cfg = new NodeGroupConfig();\n        cfg.nodeRemovalDelayMicros = TimeUnit.SECONDS.toMicros(1);\n        this.host.setNodeGroupConfig(cfg);\n\n        this.host.stopHostAndPreserveState(hostToStop);\n        this.host.waitForNodeGroupConvergence(2, 2);\n        VerificationHost existingHost = this.host.getInProcessHostMap().values().iterator().next();\n\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleTaskService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n        waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK),\n                ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n        // create some additional tasks on the remaining two hosts, but make sure they don't delete\n        // any example service instances, by specifying a name value we know will not match anything\n        createReplicatedExampleTasks(exampleTaskLinks, UUID.randomUUID().toString());\n\n        // delete some of the task links, to test synchronization of deleted entries on the restarted\n        // host\n        Set<String> deletedExampleLinks = deleteSomeServices(exampleLinks);\n\n        // increase quorum on existing nodes, so they wait for new node\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        hostToStop.setPort(0);\n        hostToStop.setSecurePort(0);\n        if (!VerificationHost.restartStatefulHost(hostToStop)) {\n            this.host.log(\"Failed restart of host, aborting\");\n            return;\n        }\n\n        // restart host, rejoin it\n        URI nodeGroupU = UriUtils.buildUri(hostToStop, ServiceUriPaths.DEFAULT_NODE_GROUP);\n        URI eNodeGroupU = UriUtils.buildUri(existingHost, ServiceUriPaths.DEFAULT_NODE_GROUP);\n        this.host.testStart(1);\n        this.host.setSystemAuthorizationContext();\n        this.host.joinNodeGroup(nodeGroupU, eNodeGroupU, this.nodeCount);\n        this.host.testWait();\n        this.host.addPeerNode(hostToStop);\n        this.host.waitForNodeGroupConvergence(this.nodeCount);\n        // set quorum on new node as well\n        this.host.setNodeGroupQuorum(this.nodeCount);\n\n        this.host.resetAuthorizationContext();\n\n        this.host.waitFor(\"Task services not started in restarted host:\" + exampleTaskLinks, () -> {\n            return checkChildServicesIfStarted(exampleTaskLinks, hostToStop) == 0;\n        });\n\n        // verify all services, not previously deleted, are restarted\n        this.host.waitFor(\"Services not started in restarted host:\" + exampleLinks, () -> {\n            return checkChildServicesIfStarted(exampleLinks, hostToStop) == 0;\n        });\n\n        int deletedCount = deletedExampleLinks.size();\n        this.host.waitFor(\"Deleted services still present in restarted host\", () -> {\n            return checkChildServicesIfStarted(deletedExampleLinks, hostToStop) == deletedCount;\n        });\n    }\n\n    private Set<String> deleteSomeServices(Set<String> exampleLinks)\n            throws Throwable {\n        int deleteCount = exampleLinks.size() / 3;\n        Iterator<String> itLinks = exampleLinks.iterator();\n        Set<String> deletedExampleLinks = new HashSet<>();\n        TestContext testContext = this.host.testCreate(deleteCount);\n        for (int i = 0; i < deleteCount; i++) {\n            String link = itLinks.next();\n            deletedExampleLinks.add(link);\n            exampleLinks.remove(link);\n            Operation delete = Operation.createDelete(this.host.getPeerServiceUri(link))\n                    .setCompletion(testContext.getCompletion());\n            this.host.send(delete);\n        }\n        testContext.await();\n        this.host.log(\"Deleted links: %s\", deletedExampleLinks);\n        return deletedExampleLinks;\n    }\n\n    private int checkChildServicesIfStarted(Set<String> exampleTaskLinks,\n            VerificationHost host) {\n        this.host.setSystemAuthorizationContext();\n        int notStartedCount = 0;\n        for (String s : exampleTaskLinks) {\n            ProcessingStage st = host.getServiceStage(s);\n            if (st == null) {\n                notStartedCount++;\n            }\n        }\n        this.host.resetAuthorizationContext();\n        if (notStartedCount > 0) {\n            this.host.log(\"%d services not started on %s (%s)\", notStartedCount,\n                    host.getPublicUri(), host.getId());\n        }\n        return notStartedCount;\n    }\n\n    private Map<ServiceHost, Map<URI, RoleState>> getRolesByHost(\n            Map<ServiceHost, Collection<String>> roleLinksByHost) throws Throwable {\n        Map<ServiceHost, Map<URI, RoleState>> roleStateByHost = new HashMap<>();\n        for (ServiceHost h : roleLinksByHost.keySet()) {\n            Collection<String> roleLinks = roleLinksByHost.get(h);\n            Collection<URI> roleURIs = new ArrayList<>();\n            for (String link : roleLinks) {\n                roleURIs.add(UriUtils.buildUri(h, link));\n            }\n\n            Map<URI, RoleState> serviceState = this.host.getServiceState(null, RoleState.class,\n                    roleURIs);\n            roleStateByHost.put(h, serviceState);\n        }\n        return roleStateByHost;\n    }\n\n    private void verifyOperationJoinAcrossPeers(Map<URI, ReplicationTestServiceState> childStates)\n            throws Throwable {\n        // do a OperationJoin across N nodes, making sure join works when forwarding is involved\n        List<Operation> joinedOps = new ArrayList<>();\n        for (ReplicationTestServiceState st : childStates.values()) {\n            Operation get = Operation.createGet(\n                    this.host.getPeerServiceUri(st.documentSelfLink)).setReferer(\n                    this.host.getReferer());\n            joinedOps.add(get);\n        }\n\n        TestContext testContext = this.host.testCreate(1);\n        OperationJoin\n                .create(joinedOps)\n                .setCompletion(\n                        (ops, exc) -> {\n                            if (exc != null) {\n                                testContext.fail(exc.values().iterator().next());\n                                return;\n                            }\n\n                            for (Operation o : ops.values()) {\n                                ReplicationTestServiceState state = o.getBody(\n                                        ReplicationTestServiceState.class);\n                                if (state.stringField == null) {\n                                    testContext.fail(new IllegalStateException());\n                                    return;\n                                }\n                            }\n                            testContext.complete();\n                        })\n                .sendWith(this.host.getPeerHost());\n        testContext.await();\n    }\n\n    public Map<String, Set<String>> computeOwnerIdsPerLink(VerificationHost joinedHost,\n            Collection<String> links)\n            throws Throwable {\n\n        TestContext testContext = this.host.testCreate(links.size());\n\n        Map<String, Set<String>> expectedOwnersPerLink = new ConcurrentSkipListMap<>();\n        CompletionHandler c = (o, e) -> {\n            if (e != null) {\n                testContext.fail(e);\n                return;\n            }\n\n            SelectOwnerResponse rsp = o.getBody(SelectOwnerResponse.class);\n            Set<String> eligibleNodeIds = new HashSet<>();\n            for (NodeState ns : rsp.selectedNodes) {\n                eligibleNodeIds.add(ns.id);\n            }\n            expectedOwnersPerLink.put(rsp.key, eligibleNodeIds);\n            testContext.complete();\n        };\n\n        for (String link : links) {\n            Operation selectOp = Operation.createGet(null)\n                    .setCompletion(c)\n                    .setExpiration(this.host.getOperationTimeoutMicros() + Utils.getNowMicrosUtc());\n\n            joinedHost.selectOwner(this.replicationNodeSelector, link, selectOp);\n        }\n        testContext.await();\n        return expectedOwnersPerLink;\n    }\n\n    public <T extends ServiceDocument> void verifyDocumentOwnerAndEpoch(Map<String, T> childStates,\n            VerificationHost joinedHost,\n            List<URI> joinedHostUris,\n            int minExpectedEpochRetries,\n            int maxExpectedEpochRetries, int expectedOwnerChanges)\n            throws Throwable, InterruptedException, TimeoutException {\n\n        Map<URI, NodeGroupState> joinedHostNodeGroupStates = this.host.getServiceState(null,\n                NodeGroupState.class, joinedHostUris);\n        Set<String> joinedHostOwnerIds = new HashSet<>();\n        for (NodeGroupState st : joinedHostNodeGroupStates.values()) {\n            joinedHostOwnerIds.add(st.documentOwner);\n        }\n\n        this.host.waitFor(\"ownership did not converge\", () -> {\n            Map<String, Set<String>> ownerIdsPerLink = computeOwnerIdsPerLink(joinedHost,\n                    childStates.keySet());\n            boolean isConverged = true;\n            Map<String, Set<Long>> epochsPerLink = new HashMap<>();\n            List<URI> nodeSelectorStatsUris = new ArrayList<>();\n\n            for (URI baseNodeUri : joinedHostUris) {\n                nodeSelectorStatsUris.add(UriUtils.buildUri(baseNodeUri,\n                        ServiceUriPaths.DEFAULT_NODE_SELECTOR,\n                        ServiceHost.SERVICE_URI_SUFFIX_STATS));\n\n                URI factoryUri = UriUtils.buildUri(\n                        baseNodeUri, this.replicationTargetFactoryLink);\n                ServiceDocumentQueryResult factoryRsp = this.host\n                        .getFactoryState(factoryUri);\n                if (factoryRsp.documentLinks == null\n                        || factoryRsp.documentLinks.size() != childStates.size()) {\n                    isConverged = false;\n                    // services not all started in new nodes yet;\n                    this.host.log(\"Node %s does not have all services: %s\", baseNodeUri,\n                            Utils.toJsonHtml(factoryRsp));\n                    break;\n                }\n\n                List<URI> childUris = new ArrayList<>();\n                for (String link : childStates.keySet()) {\n                    childUris.add(UriUtils.buildUri(baseNodeUri, link));\n                }\n\n                // retrieve the document state directly from each service\n                Map<URI, ServiceDocument> childDocs = this.host.getServiceState(null,\n                        ServiceDocument.class, childUris);\n\n                List<URI> childStatUris = new ArrayList<>();\n                for (ServiceDocument state : childDocs.values()) {\n\n                    if (state.documentOwner == null) {\n                        this.host.log(\"Owner not set in service on new node: %s\",\n                                Utils.toJsonHtml(state));\n                        isConverged = false;\n                        break;\n                    }\n\n                    URI statUri = UriUtils.buildUri(baseNodeUri, state.documentSelfLink,\n                            ServiceHost.SERVICE_URI_SUFFIX_STATS);\n                    childStatUris.add(statUri);\n\n                    Set<Long> epochs = epochsPerLink.get(state.documentEpoch);\n                    if (epochs == null) {\n                        epochs = new HashSet<>();\n                        epochsPerLink.put(state.documentSelfLink, epochs);\n                    }\n\n                    epochs.add(state.documentEpoch);\n                    Set<String> eligibleNodeIds = ownerIdsPerLink.get(state.documentSelfLink);\n\n                    if (!joinedHostOwnerIds.contains(state.documentOwner)) {\n                        this.host.log(\"Owner id for %s not expected: %s, valid ids: %s\",\n                                state.documentSelfLink, state.documentOwner, joinedHostOwnerIds);\n                        isConverged = false;\n                        break;\n                    }\n\n                    if (eligibleNodeIds != null && !eligibleNodeIds.contains(state.documentOwner)) {\n                        this.host.log(\"Owner id for %s not eligible: %s, eligible ids: %s\",\n                                state.documentSelfLink, state.documentOwner, joinedHostOwnerIds);\n                        isConverged = false;\n                        break;\n                    }\n                }\n\n                int nodeGroupMaintCount = 0;\n                int docOwnerToggleOffCount = 0;\n                int docOwnerToggleCount = 0;\n                // verify stats were reported by owner node, not a random peer\n                Map<URI, ServiceStats> allChildStats = this.host.getServiceState(null,\n                        ServiceStats.class, childStatUris);\n                for (ServiceStats childStats : allChildStats.values()) {\n                    String parentLink = UriUtils.getParentPath(childStats.documentSelfLink);\n                    Set<String> eligibleNodes = ownerIdsPerLink.get(parentLink);\n                    if (!eligibleNodes.contains(childStats.documentOwner)) {\n                        this.host.log(\"Stats for %s owner not expected. Is %s, should be %s\",\n                                parentLink, childStats.documentOwner,\n                                ownerIdsPerLink.get(parentLink));\n                        isConverged = false;\n                        break;\n                    }\n                    ServiceStat maintStat = childStats.entries\n                            .get(Service.STAT_NAME_NODE_GROUP_CHANGE_MAINTENANCE_COUNT);\n                    if (maintStat != null) {\n                        nodeGroupMaintCount++;\n                    }\n                    ServiceStat docOwnerToggleOffStat = childStats.entries\n                            .get(Service.STAT_NAME_DOCUMENT_OWNER_TOGGLE_OFF_MAINT_COUNT);\n                    if (docOwnerToggleOffStat != null) {\n                        docOwnerToggleOffCount++;\n                    }\n                    ServiceStat docOwnerToggleStat = childStats.entries\n                            .get(Service.STAT_NAME_DOCUMENT_OWNER_TOGGLE_ON_MAINT_COUNT);\n                    if (docOwnerToggleStat != null) {\n                        docOwnerToggleCount++;\n                    }\n                }\n\n                this.host.log(\"Node group change maintenance observed: %d\", nodeGroupMaintCount);\n                if (nodeGroupMaintCount < expectedOwnerChanges) {\n                    isConverged = false;\n                }\n\n                this.host.log(\"Toggled off doc owner count: %d, toggle on count: %d\",\n                        docOwnerToggleOffCount, docOwnerToggleCount);\n                if (docOwnerToggleCount < childStates.size()) {\n                    isConverged = false;\n                }\n\n                // verify epochs\n                for (Set<Long> epochs : epochsPerLink.values()) {\n                    if (epochs.size() > 1) {\n                        this.host.log(\"Documents have different epochs:%s\", epochs.toString());\n                        isConverged = false;\n                    }\n                }\n\n                if (!isConverged) {\n                    break;\n                }\n            }\n\n            return isConverged;\n        });\n    }\n\n    private <T extends ServiceDocument> Map<String, T> doStateUpdateReplicationTest(Action action,\n            int childCount, int updateCount,\n            long expectedVersion,\n            Function<T, Void> updateBodySetter,\n            BiPredicate<T, T> convergenceChecker,\n            Map<String, T> initialStatesPerChild) throws Throwable {\n        return doStateUpdateReplicationTest(action, childCount, updateCount, expectedVersion,\n                updateBodySetter, convergenceChecker, initialStatesPerChild, null, null);\n    }\n\n    private <T extends ServiceDocument> Map<String, T> doStateUpdateReplicationTest(Action action,\n            int childCount, int updateCount,\n            long expectedVersion,\n            Function<T, Void> updateBodySetter,\n            BiPredicate<T, T> convergenceChecker,\n            Map<String, T> initialStatesPerChild,\n            Map<Action, Long> countsPerAction,\n            Map<Action, Long> elapsedTimePerAction) throws Throwable {\n\n        int testCount = childCount * updateCount;\n        String testName = \"Replication with \" + action;\n        TestContext testContext = this.host.testCreate(testCount);\n        testContext.setTestName(testName).logBefore();\n\n        if (!this.expectFailure) {\n            // Before we do the replication test, wait for factory availability.\n            for (URI fu : this.host.getNodeGroupToFactoryMap(this.replicationTargetFactoryLink)\n                    .values()) {\n                // confirm that /factory/available returns 200 across all nodes\n                waitForReplicatedFactoryServiceAvailable(fu, ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            }\n        }\n\n        long before = Utils.getNowMicrosUtc();\n        AtomicInteger failedCount = new AtomicInteger();\n        // issue an update to each child service and verify it was reflected\n        // among\n        // peers\n        for (T initState : initialStatesPerChild.values()) {\n            // change a field in the initial state of each service but keep it\n            // the same across all updates so potential re ordering of the\n            // updates does not cause spurious test breaks\n            updateBodySetter.apply(initState);\n\n            for (int i = 0; i < updateCount; i++) {\n\n                long sentTime = 0;\n                if (this.expectFailure) {\n                    sentTime = Utils.getNowMicrosUtc();\n                }\n                URI factoryOnRandomPeerUri = this.host\n                        .getPeerServiceUri(this.replicationTargetFactoryLink);\n\n                long finalSentTime = sentTime;\n                this.host\n                        .send(Operation\n                                .createPatch(UriUtils.buildUri(factoryOnRandomPeerUri,\n                                        initState.documentSelfLink))\n                                .setAction(action)\n                                .forceRemote()\n                                .setBodyNoCloning(initState)\n                                .setCompletion(\n                                        (o, e) -> {\n                                            if (e != null) {\n                                                if (this.expectFailure) {\n                                                    failedCount.incrementAndGet();\n                                                    testContext.complete();\n                                                    return;\n                                                }\n                                                testContext.fail(e);\n                                                return;\n                                            }\n\n                                            if (this.expectFailure\n                                                    && this.expectedFailureStartTimeMicros > 0\n                                                    && finalSentTime > this.expectedFailureStartTimeMicros) {\n                                                testContext.fail(new IllegalStateException(\n                                                        \"Request should have failed: %s\"\n                                                                + o.toString()\n                                                                + \" sent at \" + finalSentTime));\n                                                return;\n                                            }\n                                            testContext.complete();\n                                        }));\n            }\n        }\n\n        testContext.await();\n        testContext.logAfter();\n\n        updatePerfDataPerAction(action, before, (long) (childCount * updateCount), countsPerAction,\n                elapsedTimePerAction);\n\n        if (this.expectFailure) {\n            this.host.log(\"Failed count: %d\", failedCount.get());\n            if (failedCount.get() == 0) {\n                throw new IllegalStateException(\n                        \"Possible false negative but expected at least one failure\");\n            }\n            return initialStatesPerChild;\n        }\n\n        // All updates sent to all children within one host, now wait for\n        // convergence\n        if (action != Action.DELETE) {\n            return waitForReplicatedFactoryChildServiceConvergence(initialStatesPerChild,\n                    convergenceChecker,\n                    childCount,\n                    expectedVersion);\n        }\n\n        // for DELETE replication, we expect the child services to be stopped\n        // across hosts and their state marked \"deleted\". So confirm no children\n        // are available\n        return waitForReplicatedFactoryChildServiceConvergence(initialStatesPerChild,\n                convergenceChecker,\n                0,\n                expectedVersion);\n    }\n\n    private Map<String, ExampleServiceState> doExampleFactoryPostReplicationTest(int childCount,\n            Map<Action, Long> countPerAction,\n            Map<Action, Long> elapsedTimePerAction)\n            throws Throwable {\n        return doExampleFactoryPostReplicationTest(childCount, null,\n                countPerAction, elapsedTimePerAction);\n    }\n\n    private Map<String, ExampleServiceState> doExampleFactoryPostReplicationTest(int childCount,\n            EnumSet<TestProperty> props,\n            Map<Action, Long> countPerAction,\n            Map<Action, Long> elapsedTimePerAction) throws Throwable {\n\n        if (props == null) {\n            props = EnumSet.noneOf(TestProperty.class);\n        }\n\n        if (this.host == null) {\n            setUp(this.nodeCount);\n            this.host.joinNodesAndVerifyConvergence(this.host.getPeerCount());\n        }\n\n        if (props.contains(TestProperty.FORCE_FAILURE)) {\n            this.host.toggleNegativeTestMode(true);\n        }\n\n        String factoryPath = this.replicationTargetFactoryLink;\n        Map<String, ExampleServiceState> serviceStates = new HashMap<>();\n        long before = Utils.getNowMicrosUtc();\n        TestContext testContext = this.host.testCreate(childCount);\n        testContext.setTestName(\"POST replication\");\n        testContext.logBefore();\n        for (int i = 0; i < childCount; i++) {\n            URI factoryOnRandomPeerUri = this.host.getPeerServiceUri(factoryPath);\n            Operation post = Operation\n                    .createPost(factoryOnRandomPeerUri)\n                    .setCompletion(testContext.getCompletion());\n\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.name = \"\" + post.getId();\n            initialState.counter = Long.MIN_VALUE;\n\n            // set the self link as a hint so the child service URI is\n            // predefined instead of random\n            initialState.documentSelfLink = \"\" + post.getId();\n\n            // factory service is started on all hosts. Now issue a POST to one,\n            // to create a child service with some initial state.\n            post.setReferer(this.host.getReferer());\n            this.host.sendRequest(post.setBody(initialState));\n\n            // initial state is cloned and sent, now we can change self link per\n            // child to reflect its runtime URI, which will\n            // contain the factory service path\n            initialState.documentSelfLink = UriUtils.buildUriPath(factoryPath,\n                    initialState.documentSelfLink);\n            serviceStates.put(initialState.documentSelfLink, initialState);\n        }\n\n        if (props.contains(TestProperty.FORCE_FAILURE)) {\n            // do not wait for convergence of the child services. Instead\n            // proceed to the next test which is probably stopping hosts\n            // abruptly\n            return serviceStates;\n        }\n\n        testContext.await();\n        updatePerfDataPerAction(Action.POST, before, (long) this.serviceCount, countPerAction,\n                elapsedTimePerAction);\n\n        testContext.logAfter();\n\n        return waitForReplicatedFactoryChildServiceConvergence(serviceStates,\n                this.exampleStateConvergenceChecker,\n                childCount,\n                0L);\n    }\n\n    private void updateExampleServiceOptions(\n            Map<String, ExampleServiceState> statesPerSelfLink) throws Throwable {\n        if (this.postCreationServiceOptions == null || this.postCreationServiceOptions.isEmpty()) {\n            return;\n        }\n        TestContext testContext = this.host.testCreate(statesPerSelfLink.size());\n        URI nodeGroup = this.host.getNodeGroupMap().values().iterator().next();\n        for (String link : statesPerSelfLink.keySet()) {\n            URI bUri = UriUtils.buildBroadcastRequestUri(\n                    UriUtils.buildUri(nodeGroup, link, ServiceHost.SERVICE_URI_SUFFIX_CONFIG),\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n            ServiceConfigUpdateRequest cfgBody = ServiceConfigUpdateRequest.create();\n            cfgBody.addOptions = this.postCreationServiceOptions;\n            this.host.send(Operation.createPatch(bUri)\n                    .setBody(cfgBody)\n                    .setCompletion(testContext.getCompletion()));\n\n        }\n        testContext.await();\n    }\n\n    private <T extends ServiceDocument> Map<String, T> waitForReplicatedFactoryChildServiceConvergence(\n            Map<String, T> serviceStates,\n            BiPredicate<T, T> stateChecker,\n            int expectedChildCount, long expectedVersion)\n            throws Throwable, TimeoutException {\n        return waitForReplicatedFactoryChildServiceConvergence(\n                getFactoriesPerNodeGroup(this.replicationTargetFactoryLink),\n                serviceStates,\n                stateChecker,\n                expectedChildCount,\n                expectedVersion);\n    }\n\n    private <T extends ServiceDocument> Map<String, T> waitForReplicatedFactoryChildServiceConvergence(\n            Map<URI, URI> factories,\n            Map<String, T> serviceStates,\n            BiPredicate<T, T> stateChecker,\n            int expectedChildCount, long expectedVersion)\n            throws Throwable, TimeoutException {\n        // now poll all hosts until they converge: They all have a child service\n        // with the expected URI and it has the same state\n\n        Map<String, T> updatedStatesPerSelfLink = new HashMap<>();\n        Date expiration = new Date(new Date().getTime()\n                + TimeUnit.SECONDS.toMillis(this.host.getTimeoutSeconds()));\n        do {\n\n            URI node = factories.keySet().iterator().next();\n            AtomicInteger getFailureCount = new AtomicInteger();\n            if (expectedChildCount != 0) {\n                // issue direct GETs to the services, we do not trust the factory\n\n                for (String link : serviceStates.keySet()) {\n                    TestContext ctx = this.host.testCreate(1);\n                    Operation get = Operation.createGet(UriUtils.buildUri(node, link))\n                            .setReferer(this.host.getReferer())\n                            .setExpiration(Utils.getNowMicrosUtc() + TimeUnit.SECONDS.toMicros(5))\n                            .setCompletion(\n                                    (o, e) -> {\n                                        if (e != null) {\n                                            getFailureCount.incrementAndGet();\n                                        }\n                                        ctx.completeIteration();\n                                    });\n                    this.host.sendRequest(get);\n                    this.host.testWait(ctx);\n                }\n\n            }\n\n            if (getFailureCount.get() > 0) {\n                this.host.log(\"Child services not propagated yet. Failure count: %d\",\n                        getFailureCount.get());\n                Thread.sleep(500);\n                continue;\n            }\n\n            TestContext testContext = this.host.testCreate(factories.size());\n            Map<URI, ServiceDocumentQueryResult> childServicesPerNode = new HashMap<>();\n            for (URI remoteFactory : factories.values()) {\n                URI factoryUriWithExpand = UriUtils.buildExpandLinksQueryUri(remoteFactory);\n                Operation get = Operation.createGet(factoryUriWithExpand)\n                        .setCompletion(\n                                (o, e) -> {\n                                    if (e != null) {\n                                        testContext.complete();\n                                        return;\n                                    }\n                                    if (!o.hasBody()) {\n                                        testContext.complete();\n                                        return;\n                                    }\n                                    ServiceDocumentQueryResult r = o\n                                            .getBody(ServiceDocumentQueryResult.class);\n                                    synchronized (childServicesPerNode) {\n                                        childServicesPerNode.put(o.getUri(), r);\n                                    }\n                                    testContext.complete();\n                                });\n                this.host.send(get);\n            }\n            testContext.await();\n\n            long expectedNodeCountPerLinkMax = factories.size();\n            long expectedNodeCountPerLinkMin = expectedNodeCountPerLinkMax;\n            if (this.replicationFactor != 0) {\n                // We expect services to end up either on K nodes, or K + 1 nodes,\n                // if limited replication is enabled. The reason we might end up with services on\n                // an additional node, is because we elect an owner to synchronize an entire factory,\n                // using the factory's link, and that might end up on a node not used for any child.\n                // This will produce children on that node, giving us K+1 replication, which is acceptable\n                // given K (replication factor) << N (total nodes in group)\n                expectedNodeCountPerLinkMax = this.replicationFactor + 1;\n                expectedNodeCountPerLinkMin = this.replicationFactor;\n            }\n\n            if (expectedChildCount == 0) {\n                expectedNodeCountPerLinkMax = 0;\n                expectedNodeCountPerLinkMin = 0;\n            }\n\n            // build a service link to node map so we can tell on which node each service instance landed\n            Map<String, Set<URI>> linkToNodeMap = new HashMap<>();\n\n            boolean isConverged = true;\n            for (Entry<URI, ServiceDocumentQueryResult> entry : childServicesPerNode.entrySet()) {\n                for (String link : entry.getValue().documentLinks) {\n                    if (!serviceStates.containsKey(link)) {\n                        this.host.log(\"service %s not expected, node: %s\", link, entry.getKey());\n                        isConverged = false;\n                        continue;\n                    }\n\n                    Set<URI> hostsPerLink = linkToNodeMap.get(link);\n                    if (hostsPerLink == null) {\n                        hostsPerLink = new HashSet<>();\n                    }\n                    hostsPerLink.add(entry.getKey());\n                    linkToNodeMap.put(link, hostsPerLink);\n                }\n            }\n\n            if (!isConverged) {\n                Thread.sleep(500);\n                continue;\n            }\n\n            // each link must exist on N hosts, where N is either the replication factor, or, if not used, all nodes\n            for (Entry<String, Set<URI>> e : linkToNodeMap.entrySet()) {\n                if (e.getValue() == null && this.replicationFactor == 0) {\n                    this.host.log(\"Service %s not found on any nodes\", e.getKey());\n                    isConverged = false;\n                    continue;\n                }\n\n                if (e.getValue().size() < expectedNodeCountPerLinkMin\n                        || e.getValue().size() > expectedNodeCountPerLinkMax) {\n                    this.host.log(\"Service %s found on %d nodes, expected %d -> %d\", e.getKey(), e\n                                    .getValue().size(), expectedNodeCountPerLinkMin,\n                            expectedNodeCountPerLinkMax);\n                    isConverged = false;\n                }\n            }\n\n            if (!isConverged) {\n                Thread.sleep(500);\n                continue;\n            }\n\n            if (expectedChildCount == 0) {\n                // DELETE test, all children removed from all hosts, we are done\n                return updatedStatesPerSelfLink;\n            }\n\n            // verify /available reports correct results on the factory.\n            URI factoryUri = factories.values().iterator().next();\n            Class<?> stateType = serviceStates.values().iterator().next().getClass();\n            waitForReplicatedFactoryServiceAvailable(factoryUri,\n                    ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n            // we have the correct number of services on all hosts. Now verify\n            // the state of each service matches what we expect\n\n            isConverged = true;\n\n            for (Entry<String, Set<URI>> entry : linkToNodeMap.entrySet()) {\n                String selfLink = entry.getKey();\n                int convergedNodeCount = 0;\n                for (URI nodeUri : entry.getValue()) {\n                    ServiceDocumentQueryResult childLinksAndDocsPerHost = childServicesPerNode\n                            .get(nodeUri);\n                    Object jsonState = childLinksAndDocsPerHost.documents.get(selfLink);\n                    if (jsonState == null && this.replicationFactor == 0) {\n                        this.host\n                                .log(\"Service %s not present on host %s\", selfLink, entry.getKey());\n                        continue;\n                    }\n\n                    if (jsonState == null) {\n                        continue;\n                    }\n\n                    T initialState = serviceStates.get(selfLink);\n\n                    if (initialState == null) {\n                        continue;\n                    }\n\n                    @SuppressWarnings(\"unchecked\")\n                    T stateOnNode = (T) Utils.fromJson(jsonState, stateType);\n                    if (!stateChecker.test(initialState, stateOnNode)) {\n                        this.host\n                                .log(\"State for %s not converged on node %s. Current state: %s, Initial: %s\",\n                                        selfLink, nodeUri, Utils.toJsonHtml(stateOnNode),\n                                        Utils.toJsonHtml(initialState));\n                        break;\n                    }\n\n                    if (stateOnNode.documentVersion < expectedVersion) {\n                        this.host\n                                .log(\"Version (%d, expected %d) not converged, state: %s\",\n                                        stateOnNode.documentVersion,\n                                        expectedVersion,\n                                        Utils.toJsonHtml(stateOnNode));\n                        break;\n                    }\n\n                    if (stateOnNode.documentEpoch == null) {\n                        this.host.log(\"Epoch is missing, state: %s\",\n                                Utils.toJsonHtml(stateOnNode));\n                        break;\n                    }\n\n                    // Do not check exampleState.counter, in this validation loop.\n                    // We can not compare the counter since the replication test sends the updates\n                    // in parallel, meaning some of them will get re-ordered and ignored due to\n                    // version being out of date.\n\n                    updatedStatesPerSelfLink.put(selfLink, stateOnNode);\n                    convergedNodeCount++;\n                }\n\n                if (convergedNodeCount < expectedNodeCountPerLinkMin\n                        || convergedNodeCount > expectedNodeCountPerLinkMax) {\n                    isConverged = false;\n                    break;\n                }\n            }\n\n            if (isConverged) {\n                return updatedStatesPerSelfLink;\n            }\n\n            Thread.sleep(500);\n        } while (new Date().before(expiration));\n\n        throw new TimeoutException();\n    }\n\n    private List<ServiceHostState> stopHostsToSimulateFailure(int failedNodeCount) {\n        int k = 0;\n        List<ServiceHostState> stoppedHosts = new ArrayList<>();\n        for (VerificationHost hostToStop : this.host.getInProcessHostMap().values()) {\n            this.host.log(\"Stopping host %s\", hostToStop);\n            stoppedHosts.add(hostToStop.getState());\n            this.host.stopHost(hostToStop);\n\n            k++;\n            if (k >= failedNodeCount) {\n                break;\n            }\n        }\n        return stoppedHosts;\n    }\n\n    public static class StopVerificationTestService extends StatefulService {\n\n        public Collection<URI> serviceTargets;\n\n        public AtomicInteger outboundRequestCompletion = new AtomicInteger();\n        public AtomicInteger outboundRequestFailureCompletion = new AtomicInteger();\n\n        public StopVerificationTestService() {\n            super(MinimalTestServiceState.class);\n        }\n\n        @Override\n        public void handleStop(Operation deleteForStop) {\n            // send requests to replicated services, during stop to verify that the\n            // runtime prevents any outbound requests from making it out\n            for (URI uri : this.serviceTargets) {\n                ReplicationTestServiceState body = new ReplicationTestServiceState();\n                body.stringField = ReplicationTestServiceState.CLIENT_PATCH_HINT;\n                for (int i = 0; i < 10; i++) {\n                    // send patch to self, so the select owner logic gets invoked and in theory\n                    // queues or cancels the request\n                    Operation op = Operation.createPatch(this, uri.getPath()).setBody(body)\n                            .setTargetReplicated(true)\n                            .setCompletion((o, e) -> {\n                                if (e != null) {\n                                    this.outboundRequestFailureCompletion.incrementAndGet();\n                                } else {\n                                    this.outboundRequestCompletion.incrementAndGet();\n                                }\n                            });\n                    sendRequest(op);\n                }\n            }\n        }\n\n    }\n\n    private void stopHostsAndVerifyQueuing(Collection<VerificationHost> hostsToStop,\n            VerificationHost remainingHost,\n            Collection<URI> serviceTargets) throws Throwable {\n        this.host.log(\"Starting to stop hosts and verify queuing\");\n\n        // reduce node expiration for unavailable hosts so gossip warning\n        // messages do not flood the logs\n        this.nodeGroupConfig.nodeRemovalDelayMicros = remainingHost.getMaintenanceIntervalMicros();\n        this.host.setNodeGroupConfig(this.nodeGroupConfig);\n        this.setOperationTimeoutMicros(TimeUnit.SECONDS.toMicros(10));\n\n        // relax quorum to single remaining host\n        this.host.setNodeGroupQuorum(1);\n\n        // start a special test service that will attempt to send messages when it sees\n        // handleStop(). This is not expected of production code, since service authors\n        // should never have to worry about handleStop(). We rely on the fact that handleStop\n        // will be called due to node shutdown, and issue requests to replicated targets,\n        // then check if anyone of them actually made it out (they should not have)\n\n        List<StopVerificationTestService> verificationServices = new ArrayList<>();\n\n        // Do the inverse test. Remove all of the original hosts and this time, expect all the\n        // documents have owners assigned to the new hosts\n        for (VerificationHost h : hostsToStop) {\n            StopVerificationTestService s = new StopVerificationTestService();\n            verificationServices.add(s);\n            s.serviceTargets = serviceTargets;\n            h.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n            this.host.stopHost(h);\n        }\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            boolean isConverged = true;\n            for (StopVerificationTestService s : verificationServices) {\n                if (s.outboundRequestCompletion.get() > 0) {\n                    throw new IllegalStateException(\"Replicated request succeeded\");\n                }\n                if (s.outboundRequestFailureCompletion.get() < serviceTargets.size()) {\n                    // We expect at least one failure per service target, if we have less\n                    // keep polling.\n                    this.host.log(\n                            \"Not converged yet: service %s on host %s has %d outbound request failures, which is lower than %d\",\n                            s.getSelfLink(), s.getHost().getId(),\n                            s.outboundRequestFailureCompletion.get(), serviceTargets.size());\n                    isConverged = false;\n                    break;\n                }\n            }\n\n            if (isConverged) {\n                this.host.log(\"Done with stop hosts and verify queuing\");\n                return;\n            }\n\n            Thread.sleep(250);\n        }\n\n        throw new TimeoutException();\n    }\n\n    private void waitForReplicatedFactoryServiceAvailable(URI uri, String nodeSelectorPath)\n            throws Throwable {\n        if (this.skipAvailabilityChecks) {\n            return;\n        }\n        if (UriUtils.isHostEqual(this.host, uri)) {\n\n            VerificationHost host = this.host;\n\n            // if uri is for in-process peers, then use the one\n            URI peerUri = UriUtils.buildUri(uri.toString().replace(uri.getPath(), \"\"));\n            VerificationHost peer = this.host.getInProcessHostMap().get(peerUri);\n            if (peer != null) {\n                host = peer;\n            }\n\n            TestContext ctx = host.testCreate(1);\n            CompletionHandler ch = (o, e) -> {\n                if (e != null) {\n                    String msg = \"Failed to check replicated factory service availability\";\n                    ctx.failIteration(new RuntimeException(msg, e));\n                    return;\n                }\n                ctx.completeIteration();\n            };\n\n            host.registerForServiceAvailability(ch, nodeSelectorPath, true, uri.getPath());\n            ctx.await();\n\n        } else {\n            // for remote host\n            this.host.waitForReplicatedFactoryServiceAvailable(uri, nodeSelectorPath);\n        }\n\n    }\n}\n", "target": 0}
{"idx": 953, "func": "package jenkins.security;\n\nimport hudson.FilePath;\nimport hudson.Util;\nimport hudson.util.IOException2;\nimport hudson.util.IOUtils;\nimport hudson.util.Secret;\nimport hudson.util.TextFile;\nimport jenkins.model.Jenkins;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.SecretKey;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.security.SecureRandom;\n\n/**\n * Default portable implementation of {@link ConfidentialStore} that uses\n * a directory inside $JENKINS_HOME.\n *\n * The master key is also stored in this same directory.\n *\n * @author Kohsuke Kawaguchi\n */\n// @MetaInfServices --- not annotated because this is the fallback implementation\npublic class DefaultConfidentialStore extends ConfidentialStore {\n    private final SecureRandom sr = new SecureRandom();\n\n    /**\n     * Directory that stores individual keys.\n     */\n    private final File rootDir;\n\n    /**\n     * The master key.\n     *\n     * The sole purpose of the master key is to encrypt individual keys on the disk.\n     * Because leaking this master key compromises all the individual keys, we must not let\n     * this master key used for any other purpose, hence the protected access.\n     */\n    private final SecretKey masterKey;\n\n    public DefaultConfidentialStore() throws IOException, InterruptedException {\n        this(new File(Jenkins.getInstance().getRootDir(),\"secrets\"));\n    }\n\n    public DefaultConfidentialStore(File rootDir) throws IOException, InterruptedException {\n        this.rootDir = rootDir;\n        if (rootDir.mkdirs()) {\n            // protect this directory. but don't change the permission of the existing directory\n            // in case the administrator changed this.\n            new FilePath(rootDir).chmod(0700);\n        }\n\n        TextFile masterSecret = new TextFile(new File(rootDir,\"master.key\"));\n        if (!masterSecret.exists()) {\n            // we are only going to use small number of bits (since export control limits AES key length)\n            // but let's generate a long enough key anyway\n            masterSecret.write(Util.toHexString(randomBytes(128)));\n        }\n        this.masterKey = Util.toAes128Key(masterSecret.readTrim());\n    }\n\n    /**\n     * Persists the payload of {@link ConfidentialKey} to the disk.\n     */\n    @Override\n    protected void store(ConfidentialKey key, byte[] payload) throws IOException {\n        CipherOutputStream cos=null;\n        FileOutputStream fos=null;\n        try {\n            Cipher sym = Secret.getCipher(\"AES\");\n            sym.init(Cipher.ENCRYPT_MODE, masterKey);\n            cos = new CipherOutputStream(fos=new FileOutputStream(getFileFor(key)), sym);\n            cos.write(payload);\n            cos.write(MAGIC);\n        } catch (GeneralSecurityException e) {\n            throw new IOException2(\"Failed to persist the key: \"+key.getId(),e);\n        } finally {\n            IOUtils.closeQuietly(cos);\n            IOUtils.closeQuietly(fos);\n        }\n    }\n\n    /**\n     * Reverse operation of {@link #store(ConfidentialKey, byte[])}\n     *\n     * @return\n     *      null the data has not been previously persisted.\n     */\n    @Override\n    protected byte[] load(ConfidentialKey key) throws IOException {\n        CipherInputStream cis=null;\n        FileInputStream fis=null;\n        try {\n            File f = getFileFor(key);\n            if (!f.exists())    return null;\n\n            Cipher sym = Secret.getCipher(\"AES\");\n            sym.init(Cipher.DECRYPT_MODE, masterKey);\n            cis = new CipherInputStream(fis=new FileInputStream(f), sym);\n            byte[] bytes = IOUtils.toByteArray(cis);\n            return verifyMagic(bytes);\n        } catch (GeneralSecurityException e) {\n            throw new IOException2(\"Failed to persist the key: \"+key.getId(),e);\n        } finally {\n            IOUtils.closeQuietly(cis);\n            IOUtils.closeQuietly(fis);\n        }\n    }\n\n    /**\n     * Verifies that the given byte[] has the MAGIC trailer, to verify the integrity of the decryption process.\n     */\n    private byte[] verifyMagic(byte[] payload) {\n        int payloadLen = payload.length-MAGIC.length;\n        if (payloadLen<0)   return null;    // obviously broken\n\n        for (int i=0; i<MAGIC.length; i++) {\n            if (payload[payloadLen+i]!=MAGIC[i])\n                return null;    // broken\n        }\n        byte[] truncated = new byte[payloadLen];\n        System.arraycopy(payload,0,truncated,0,truncated.length);\n        return truncated;\n    }\n\n    private File getFileFor(ConfidentialKey key) {\n        return new File(rootDir, key.getId());\n    }\n\n    public byte[] randomBytes(int size) {\n        byte[] random = new byte[size];\n        sr.nextBytes(random);\n        return random;\n    }\n\n    private static final byte[] MAGIC = \"::::MAGIC::::\".getBytes();\n}\n", "target": 0}
{"idx": 954, "func": "package org.bouncycastle.pqc.crypto.xmss;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Hex;\n\n/**\n * Utils for XMSS implementation.\n */\npublic class XMSSUtil\n{\n\n    /**\n     * Calculates the logarithm base 2 for a given Integer.\n     *\n     * @param n Number.\n     * @return Logarithm to base 2 of {@code n}.\n     */\n    public static int log2(int n)\n    {\n        int log = 0;\n        while ((n >>= 1) != 0)\n        {\n            log++;\n        }\n        return log;\n    }\n\n    /**\n     * Convert int/long to n-byte array.\n     *\n     * @param value      int/long value.\n     * @param sizeInByte Size of byte array in byte.\n     * @return int/long as big-endian byte array of size {@code sizeInByte}.\n     */\n    public static byte[] toBytesBigEndian(long value, int sizeInByte)\n    {\n        byte[] out = new byte[sizeInByte];\n        for (int i = (sizeInByte - 1); i >= 0; i--)\n        {\n            out[i] = (byte)value;\n            value >>>= 8;\n        }\n        return out;\n    }\n\n    /*\n     * Copy long to byte array in big-endian at specific offset.\n     */\n    public static void longToBigEndian(long value, byte[] in, int offset)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        if ((in.length - offset) < 8)\n        {\n            throw new IllegalArgumentException(\"not enough space in array\");\n        }\n        in[offset] = (byte)((value >> 56) & 0xff);\n        in[offset + 1] = (byte)((value >> 48) & 0xff);\n        in[offset + 2] = (byte)((value >> 40) & 0xff);\n        in[offset + 3] = (byte)((value >> 32) & 0xff);\n        in[offset + 4] = (byte)((value >> 24) & 0xff);\n        in[offset + 5] = (byte)((value >> 16) & 0xff);\n        in[offset + 6] = (byte)((value >> 8) & 0xff);\n        in[offset + 7] = (byte)((value) & 0xff);\n    }\n\n    /*\n     * Generic convert from big endian byte array to long.\n     */\n    public static long bytesToXBigEndian(byte[] in, int offset, int size)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        long res = 0;\n        for (int i = offset; i < (offset + size); i++)\n        {\n            res = (res << 8) | (in[i] & 0xff);\n        }\n        return res;\n    }\n\n    /**\n     * Clone a byte array.\n     *\n     * @param in byte array.\n     * @return Copy of byte array.\n     */\n    public static byte[] cloneArray(byte[] in)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        byte[] out = new byte[in.length];\n        for (int i = 0; i < in.length; i++)\n        {\n            out[i] = in[i];\n        }\n        return out;\n    }\n\n    /**\n     * Clone a 2d byte array.\n     *\n     * @param in 2d byte array.\n     * @return Copy of 2d byte array.\n     */\n    public static byte[][] cloneArray(byte[][] in)\n    {\n        if (hasNullPointer(in))\n        {\n            throw new NullPointerException(\"in has null pointers\");\n        }\n        byte[][] out = new byte[in.length][];\n        for (int i = 0; i < in.length; i++)\n        {\n            out[i] = new byte[in[i].length];\n            for (int j = 0; j < in[i].length; j++)\n            {\n                out[i][j] = in[i][j];\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Compares two 2d-byte arrays.\n     *\n     * @param a 2d-byte array 1.\n     * @param b 2d-byte array 2.\n     * @return true if all values in 2d-byte array are equal false else.\n     */\n    public static boolean areEqual(byte[][] a, byte[][] b)\n    {\n        if (hasNullPointer(a) || hasNullPointer(b))\n        {\n            throw new NullPointerException(\"a or b == null\");\n        }\n        for (int i = 0; i < a.length; i++)\n        {\n            if (!Arrays.areEqual(a[i], b[i]))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Dump content of 2d byte array.\n     *\n     * @param x byte array.\n     */\n    public static void dumpByteArray(byte[][] x)\n    {\n        if (hasNullPointer(x))\n        {\n            throw new NullPointerException(\"x has null pointers\");\n        }\n        for (int i = 0; i < x.length; i++)\n        {\n            System.out.println(Hex.toHexString(x[i]));\n        }\n    }\n\n    /**\n     * Checks whether 2d byte array has null pointers.\n     *\n     * @param in 2d byte array.\n     * @return true if at least one null pointer is found false else.\n     */\n    public static boolean hasNullPointer(byte[][] in)\n    {\n        if (in == null)\n        {\n            return true;\n        }\n        for (int i = 0; i < in.length; i++)\n        {\n            if (in[i] == null)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Copy src byte array to dst byte array at offset.\n     *\n     * @param dst    Destination.\n     * @param src    Source.\n     * @param offset Destination offset.\n     */\n    public static void copyBytesAtOffset(byte[] dst, byte[] src, int offset)\n    {\n        if (dst == null)\n        {\n            throw new NullPointerException(\"dst == null\");\n        }\n        if (src == null)\n        {\n            throw new NullPointerException(\"src == null\");\n        }\n        if (offset < 0)\n        {\n            throw new IllegalArgumentException(\"offset hast to be >= 0\");\n        }\n        if ((src.length + offset) > dst.length)\n        {\n            throw new IllegalArgumentException(\"src length + offset must not be greater than size of destination\");\n        }\n        for (int i = 0; i < src.length; i++)\n        {\n            dst[offset + i] = src[i];\n        }\n    }\n\n    /**\n     * Copy length bytes at position offset from src.\n     *\n     * @param src    Source byte array.\n     * @param offset Offset in source byte array.\n     * @param length Length of bytes to copy.\n     * @return New byte array.\n     */\n    public static byte[] extractBytesAtOffset(byte[] src, int offset, int length)\n    {\n        if (src == null)\n        {\n            throw new NullPointerException(\"src == null\");\n        }\n        if (offset < 0)\n        {\n            throw new IllegalArgumentException(\"offset hast to be >= 0\");\n        }\n        if (length < 0)\n        {\n            throw new IllegalArgumentException(\"length hast to be >= 0\");\n        }\n        if ((offset + length) > src.length)\n        {\n            throw new IllegalArgumentException(\"offset + length must not be greater then size of source array\");\n        }\n        byte[] out = new byte[length];\n        for (int i = 0; i < out.length; i++)\n        {\n            out[i] = src[offset + i];\n        }\n        return out;\n    }\n\n    /**\n     * Check whether an index is valid or not.\n     *\n     * @param height Height of binary tree.\n     * @param index  Index to validate.\n     * @return true if index is valid false else.\n     */\n    public static boolean isIndexValid(int height, long index)\n    {\n        if (index < 0)\n        {\n            throw new IllegalStateException(\"index must not be negative\");\n        }\n        return index < (1L << height);\n    }\n\n    /**\n     * Determine digest size of digest.\n     *\n     * @param digest Digest.\n     * @return Digest size.\n     */\n    public static int getDigestSize(Digest digest)\n    {\n        if (digest == null)\n        {\n            throw new NullPointerException(\"digest == null\");\n        }\n        String algorithmName = digest.getAlgorithmName();\n        if (algorithmName.equals(\"SHAKE128\"))\n        {\n            return 32;\n        }\n        if (algorithmName.equals(\"SHAKE256\"))\n        {\n            return 64;\n        }\n        return digest.getDigestSize();\n    }\n\n    public static long getTreeIndex(long index, int xmssTreeHeight)\n    {\n        return index >> xmssTreeHeight;\n    }\n\n    public static int getLeafIndex(long index, int xmssTreeHeight)\n    {\n        return (int)(index & ((1L << xmssTreeHeight) - 1L));\n    }\n\n    public static byte[] serialize(Object obj)\n        throws IOException\n    {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(out);\n        oos.writeObject(obj);\n        oos.flush();\n        return out.toByteArray();\n    }\n\n    public static Object deserialize(byte[] data, Class clazz)\n        throws IOException, ClassNotFoundException\n    {\n        ByteArrayInputStream in = new ByteArrayInputStream(data);\n        ObjectInputStream is = new ObjectInputStream(in);\n        Object obj = is.readObject();\n\n        if (is.available() != 0)\n        {\n            throw new IOException(\"unexpected data found at end of ObjectInputStream\");\n        }\n        if (clazz.isInstance(obj))\n        {\n            return obj;\n        }\n        else\n        {\n            throw new IOException(\"unexpected class found in ObjectInputStream\");\n        }\n    }\n\n    public static int calculateTau(int index, int height)\n    {\n        int tau = 0;\n        for (int i = 0; i < height; i++)\n        {\n            if (((index >> i) & 1) == 0)\n            {\n                tau = i;\n                break;\n            }\n        }\n        return tau;\n    }\n\n    public static boolean isNewBDSInitNeeded(long globalIndex, int xmssHeight, int layer)\n    {\n        if (globalIndex == 0)\n        {\n            return false;\n        }\n        return (globalIndex % (long)Math.pow((1 << xmssHeight), layer + 1) == 0) ? true : false;\n    }\n\n    public static boolean isNewAuthenticationPathNeeded(long globalIndex, int xmssHeight, int layer)\n    {\n        if (globalIndex == 0)\n        {\n            return false;\n        }\n        return ((globalIndex + 1) % (long)Math.pow((1 << xmssHeight), layer) == 0) ? true : false;\n    }\n}\n", "target": 0}
{"idx": 955, "func": "package org.jboss.resteasy.resteasy1073;\n\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.core.MediaType;\n\n/**\n * RESTEASY-1073\n * \n * @author <a href=\"ron.sigal@jboss.com\">Ron Sigal</a>\n * @version $Revision: 1.1 $\n *\n * Copyright July 19, 2014\n */\n@Path(\"\")\npublic class TestResource\n{\n   @POST\n   @Path(\"test\")\n   @Consumes(MediaType.APPLICATION_XML)\n   public String post(TestWrapper wrapper)\n   {\n      return wrapper.getName();\n   }\n}\n", "target": 0}
{"idx": 956, "func": "package jenkins.security;\n\nimport hudson.Extension;\nimport hudson.init.InitMilestone;\nimport hudson.init.Initializer;\nimport hudson.model.TaskListener;\nimport hudson.util.HttpResponses;\nimport hudson.util.SecretRewriter;\nimport hudson.util.VersionNumber;\nimport jenkins.management.AsynchronousAdministrativeMonitor;\nimport jenkins.model.Jenkins;\nimport jenkins.util.io.FileBoolean;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.security.GeneralSecurityException;\nimport java.util.Date;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Warns the administrator to run {@link SecretRewriter}\n *\n * @author Kohsuke Kawaguchi\n */\n@Extension\npublic class RekeySecretAdminMonitor extends AsynchronousAdministrativeMonitor {\n\n    /**\n     * Whether we detected a need to run the rewrite program.\n     * Once we set it to true, we'll never turn it off.\n     *\n     * If the admin decides to dismiss this warning, we use {@link #isEnabled()} for that.\n     *\n     * In this way we can correctly differentiate all the different states.\n     */\n    private final FileBoolean needed = state(\"needed\");\n\n    /**\n     * If the scanning process has run to the completion, we set to this true.\n     */\n    private final FileBoolean done = state(\"done\");\n\n    /**\n     * If the rewrite process is scheduled upon the next boot.\n     */\n    private final FileBoolean scanOnBoot = state(\"scanOnBoot\");\n\n    public RekeySecretAdminMonitor() throws IOException {\n        // if JENKINS_HOME existed <1.497, we need to offer rewrite\n        // this computation needs to be done and the value be captured,\n        // since $JENKINS_HOME/config.xml can be saved later before the user has\n        // actually rewritten XML files.\n        Jenkins j = Jenkins.getInstance();\n        if (j.isUpgradedFromBefore(new VersionNumber(\"1.496.*\"))\n        &&  new FileBoolean(new File(j.getRootDir(),\"secret.key.not-so-secret\")).isOff())\n            needed.on();\n    }\n\n    @Override\n    public boolean isActivated() {\n        return needed.isOn();\n    }\n\n    /**\n     * Indicates that the re-keying has run to the completion.\n     */\n    public boolean isDone() {\n        return done.isOn();\n    }\n\n    public void setNeeded() {\n        needed.on();\n    }\n\n    public boolean isScanOnBoot() {\n        return scanOnBoot.isOn();\n    }\n\n    @RequirePOST\n    public HttpResponse doScan(StaplerRequest req) throws IOException, GeneralSecurityException {\n        if(req.hasParameter(\"background\")) {\n            start(false);\n        } else\n        if(req.hasParameter(\"schedule\")) {\n            scanOnBoot.on();\n        } else\n        if(req.hasParameter(\"dismiss\")) {\n            disable(true);\n        } else\n            throw HttpResponses.error(400,\"Invalid request submission: \" + req.getParameterMap());\n\n        return HttpResponses.redirectViaContextPath(\"/manage\");\n    }\n\n\n    private FileBoolean state(String name) {\n        return new FileBoolean(new File(getBaseDir(),name));\n    }\n\n    @Initializer(fatal=false,after=InitMilestone.PLUGINS_STARTED,before=InitMilestone.EXTENSIONS_AUGMENTED)\n    // as early as possible, but this needs to be late enough that the ConfidentialStore is available\n    public static void scanOnReboot() throws InterruptedException, IOException, GeneralSecurityException {\n        RekeySecretAdminMonitor m = new RekeySecretAdminMonitor();  // throw-away instance\n\n        FileBoolean flag = m.scanOnBoot;\n        if (flag.isOn()) {\n            flag.off();\n            m.start(false).join();\n            // block the boot until the rewrite process is complete\n            // don't let the failure in RekeyThread block Jenkins boot.\n        }\n    }\n\n    @Override\n    public String getDisplayName() {\n        return Messages.RekeySecretAdminMonitor_DisplayName();\n    }\n\n    /**\n     * Rewrite log file.\n     */\n    @Override\n    protected File getLogFile() {\n        return new File(getBaseDir(),\"rekey.log\");\n    }\n\n    @Override\n    protected void fix(TaskListener listener) throws Exception {\n        LOGGER.info(\"Initiating a re-keying of secrets. See \"+getLogFile());\n\n        SecretRewriter rewriter = new SecretRewriter(new File(getBaseDir(),\"backups\"));\n\n        try {\n            PrintStream log = listener.getLogger();\n            log.println(\"Started re-keying \" + new Date());\n            int count = rewriter.rewriteRecursive(Jenkins.getInstance().getRootDir(), listener);\n            log.printf(\"Completed re-keying %d files on %s\\n\",count,new Date());\n            new RekeySecretAdminMonitor().done.on();\n            LOGGER.info(\"Secret re-keying completed\");\n        } catch (Exception e) {\n            LOGGER.log(Level.SEVERE, \"Fatal failure in re-keying secrets\",e);\n            e.printStackTrace(listener.error(\"Fatal failure in rewriting secrets\"));\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(RekeySecretAdminMonitor.class.getName());\n\n}\n", "target": 0}
{"idx": 957, "func": "/*\n * Copyright (C) 2012 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage retrofit2;\n\nimport java.io.IOException;\nimport javax.annotation.Nullable;\nimport okhttp3.FormBody;\nimport okhttp3.Headers;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.MultipartBody;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okio.Buffer;\nimport okio.BufferedSink;\n\nfinal class RequestBuilder {\n  private static final char[] HEX_DIGITS =\n      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = \" \\\"<>^`{}|\\\\?#\";\n\n  private final String method;\n\n  private final HttpUrl baseUrl;\n  private @Nullable String relativeUrl;\n  private @Nullable HttpUrl.Builder urlBuilder;\n\n  private final Request.Builder requestBuilder;\n  private @Nullable MediaType contentType;\n\n  private final boolean hasBody;\n  private @Nullable MultipartBody.Builder multipartBuilder;\n  private @Nullable FormBody.Builder formBuilder;\n  private @Nullable RequestBody body;\n\n  RequestBuilder(String method, HttpUrl baseUrl,\n      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,\n      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {\n    this.method = method;\n    this.baseUrl = baseUrl;\n    this.relativeUrl = relativeUrl;\n    this.requestBuilder = new Request.Builder();\n    this.contentType = contentType;\n    this.hasBody = hasBody;\n\n    if (headers != null) {\n      requestBuilder.headers(headers);\n    }\n\n    if (isFormEncoded) {\n      // Will be set to 'body' in 'build'.\n      formBuilder = new FormBody.Builder();\n    } else if (isMultipart) {\n      // Will be set to 'body' in 'build'.\n      multipartBuilder = new MultipartBody.Builder();\n      multipartBuilder.setType(MultipartBody.FORM);\n    }\n  }\n\n  void setRelativeUrl(Object relativeUrl) {\n    this.relativeUrl = relativeUrl.toString();\n  }\n\n  void addHeader(String name, String value) {\n    if (\"Content-Type\".equalsIgnoreCase(name)) {\n      try {\n        contentType = MediaType.get(value);\n      } catch (IllegalArgumentException e) {\n        throw new IllegalArgumentException(\"Malformed content type: \" + value, e);\n      }\n    } else {\n      requestBuilder.addHeader(name, value);\n    }\n  }\n\n  void addPathParam(String name, String value, boolean encoded) {\n    if (relativeUrl == null) {\n      // The relative URL is cleared when the first query parameter is set.\n      throw new AssertionError();\n    }\n    relativeUrl = relativeUrl.replace(\"{\" + name + \"}\", canonicalizeForPath(value, encoded));\n  }\n\n  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {\n    int codePoint;\n    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Slow path: the character at i requires encoding!\n        Buffer out = new Buffer();\n        out.writeUtf8(input, 0, i);\n        canonicalizeForPath(out, input, i, limit, alreadyEncoded);\n        return out.readUtf8();\n      }\n    }\n\n    // Fast path: no characters required encoding.\n    return input;\n  }\n\n  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,\n      boolean alreadyEncoded) {\n    Buffer utf8Buffer = null; // Lazily allocated.\n    int codePoint;\n    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (alreadyEncoded\n          && (codePoint == '\\t' || codePoint == '\\n' || codePoint == '\\f' || codePoint == '\\r')) {\n        // Skip this character.\n      } else if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        // Percent encode this character.\n        if (utf8Buffer == null) {\n          utf8Buffer = new Buffer();\n        }\n        utf8Buffer.writeUtf8CodePoint(codePoint);\n        while (!utf8Buffer.exhausted()) {\n          int b = utf8Buffer.readByte() & 0xff;\n          out.writeByte('%');\n          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);\n          out.writeByte(HEX_DIGITS[b & 0xf]);\n        }\n      } else {\n        // This character doesn't need encoding. Just copy it over.\n        out.writeUtf8CodePoint(codePoint);\n      }\n    }\n  }\n\n  void addQueryParam(String name, @Nullable String value, boolean encoded) {\n    if (relativeUrl != null) {\n      // Do a one-time combination of the built relative URL and the base URL.\n      urlBuilder = baseUrl.newBuilder(relativeUrl);\n      if (urlBuilder == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n      relativeUrl = null;\n    }\n\n    if (encoded) {\n      //noinspection ConstantConditions Checked to be non-null by above 'if' block.\n      urlBuilder.addEncodedQueryParameter(name, value);\n    } else {\n      //noinspection ConstantConditions Checked to be non-null by above 'if' block.\n      urlBuilder.addQueryParameter(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isFormEncoded was true.\n  void addFormField(String name, String value, boolean encoded) {\n    if (encoded) {\n      formBuilder.addEncoded(name, value);\n    } else {\n      formBuilder.add(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isMultipart was true.\n  void addPart(Headers headers, RequestBody body) {\n    multipartBuilder.addPart(headers, body);\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") // Only called when isMultipart was true.\n  void addPart(MultipartBody.Part part) {\n    multipartBuilder.addPart(part);\n  }\n\n  void setBody(RequestBody body) {\n    this.body = body;\n  }\n\n  Request.Builder get() {\n    HttpUrl url;\n    HttpUrl.Builder urlBuilder = this.urlBuilder;\n    if (urlBuilder != null) {\n      url = urlBuilder.build();\n    } else {\n      // No query parameters triggered builder creation, just combine the relative URL and base URL.\n      //noinspection ConstantConditions Non-null if urlBuilder is null.\n      url = baseUrl.resolve(relativeUrl);\n      if (url == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n    }\n\n    RequestBody body = this.body;\n    if (body == null) {\n      // Try to pull from one of the builders.\n      if (formBuilder != null) {\n        body = formBuilder.build();\n      } else if (multipartBuilder != null) {\n        body = multipartBuilder.build();\n      } else if (hasBody) {\n        // Body is absent, make an empty body.\n        body = RequestBody.create(null, new byte[0]);\n      }\n    }\n\n    MediaType contentType = this.contentType;\n    if (contentType != null) {\n      if (body != null) {\n        body = new ContentTypeOverridingRequestBody(body, contentType);\n      } else {\n        requestBuilder.addHeader(\"Content-Type\", contentType.toString());\n      }\n    }\n\n    return requestBuilder\n        .url(url)\n        .method(method, body);\n  }\n\n  private static class ContentTypeOverridingRequestBody extends RequestBody {\n    private final RequestBody delegate;\n    private final MediaType contentType;\n\n    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {\n      this.delegate = delegate;\n      this.contentType = contentType;\n    }\n\n    @Override public MediaType contentType() {\n      return contentType;\n    }\n\n    @Override public long contentLength() throws IOException {\n      return delegate.contentLength();\n    }\n\n    @Override public void writeTo(BufferedSink sink) throws IOException {\n      delegate.writeTo(sink);\n    }\n  }\n}\n", "target": 1}
{"idx": 958, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static com.vmware.xenon.common.Service.Action.DELETE;\nimport static com.vmware.xenon.common.Service.Action.POST;\n\nimport java.io.NotActiveException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.logging.Level;\n\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Operation.OperationOption;\nimport com.vmware.xenon.common.ServiceDocumentDescription.TypeName;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceSubscriptionState.ServiceSubscriber;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.NumericRange;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Occurance;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UiContentService;\n\n/**\n * Utility service managing the various URI control REST APIs for each service instance. A single\n * utility service instance manages operations on multiple URI suffixes (/stats, /subscriptions,\n * etc) in order to reduce runtime overhead per service instance\n */\npublic class UtilityService implements Service {\n    private transient Service parent;\n    private ServiceStats stats;\n    private ServiceSubscriptionState subscriptions;\n    private UiContentService uiService;\n\n    public UtilityService() {\n    }\n\n    public UtilityService setParent(Service parent) {\n        this.parent = parent;\n        return this;\n    }\n\n    @Override\n    public void authorizeRequest(Operation op) {\n\n        String suffix = UriUtils.buildUriPath(UriUtils.URI_PATH_CHAR, UriUtils.getLastPathSegment(op.getUri()));\n\n        // allow access to ui endpoint\n        if (ServiceHost.SERVICE_URI_SUFFIX_UI.equals(suffix)) {\n            op.complete();\n            return;\n        }\n\n        ServiceDocument doc = new ServiceDocument();\n        if (this.parent.getOptions().contains(ServiceOption.FACTORY_ITEM)) {\n            doc.documentSelfLink = UriUtils.buildUriPath(UriUtils.getParentPath(this.parent.getSelfLink()), suffix);\n        } else {\n            doc.documentSelfLink = UriUtils.buildUriPath(this.parent.getSelfLink(), suffix);\n        }\n\n        doc.documentKind = Utils.buildKind(this.parent.getStateType());\n        if (getHost().isAuthorized(this.parent, doc, op)) {\n            op.complete();\n            return;\n        }\n\n        op.fail(Operation.STATUS_CODE_FORBIDDEN);\n    }\n\n    @Override\n    public void handleRequest(Operation op) {\n        String uriPrefix = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n\n        if (op.getUri().getPath().startsWith(uriPrefix)) {\n            // startsWith catches all /factory/instance/ui/some-script.js\n            handleUiRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_STATS)) {\n            handleStatsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS)) {\n            handleSubscriptionsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_TEMPLATE)) {\n            handleDocumentTemplateRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_CONFIG)) {\n            this.parent.handleConfigurationRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_AVAILABLE)) {\n            handleAvailableRequest(op);\n        } else {\n            op.fail(new UnknownHostException());\n        }\n    }\n\n    @Override\n    public void handleCreate(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void handleStart(Operation startPost) {\n        startPost.complete();\n    }\n\n    @Override\n    public void handleStop(Operation op) {\n        op.complete();\n    }\n\n    @Override\n    public void handleRequest(Operation op, OperationProcessingStage opProcessingStage) {\n        handleRequest(op);\n    }\n\n    private void handleAvailableRequest(Operation op) {\n        if (op.getAction() == Action.GET) {\n            if (this.parent.getProcessingStage() != ProcessingStage.PAUSED\n                    && this.parent.getProcessingStage() != ProcessingStage.AVAILABLE) {\n                // processing stage takes precedence over isAvailable statistic\n                op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n                return;\n            }\n            if (this.stats == null) {\n                op.complete();\n                return;\n            }\n            ServiceStat st = this.getStat(STAT_NAME_AVAILABLE, false);\n            if (st == null || st.latestValue == 1.0) {\n                op.complete();\n                return;\n            }\n            op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n        } else if (op.getAction() == Action.PATCH || op.getAction() == Action.PUT) {\n            if (!op.hasBody()) {\n                op.fail(new IllegalArgumentException(\"body is required\"));\n                return;\n            }\n            ServiceStat st = op.getBody(ServiceStat.class);\n            if (!STAT_NAME_AVAILABLE.equals(st.name)) {\n                op.fail(new IllegalArgumentException(\n                        \"body must be of type ServiceStat and name must be \"\n                                + STAT_NAME_AVAILABLE));\n                return;\n            }\n            handleStatsRequest(op);\n        } else {\n            Operation.failActionNotSupported(op);\n        }\n    }\n\n    private void handleSubscriptionsRequest(Operation op) {\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                this.subscriptions = new ServiceSubscriptionState();\n                this.subscriptions.subscribers = new ConcurrentSkipListMap<>();\n            }\n        }\n\n        ServiceSubscriber body = null;\n\n        // validate and populate body for POST & DELETE\n        Action action = op.getAction();\n        if (action == POST || action == DELETE) {\n            if (!op.hasBody()) {\n                op.fail(new IllegalStateException(\"body is required\"));\n                return;\n            }\n            body = op.getBody(ServiceSubscriber.class);\n            if (body.reference == null) {\n                op.fail(new IllegalArgumentException(\"reference is required\"));\n                return;\n            }\n        }\n\n        switch (action) {\n        case POST:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.put(body.reference, body);\n            }\n            if (!body.replayState) {\n                break;\n            }\n            // if replayState is set, replay the current state to the subscriber\n            URI notificationURI = body.reference;\n            this.parent.sendRequest(Operation.createGet(this, this.parent.getSelfLink())\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e != null) {\n                                    op.fail(new IllegalStateException(\n                                            \"Unable to get current state\"));\n                                    return;\n                                }\n                                Operation putOp = Operation\n                                        .createPut(notificationURI)\n                                        .setBodyNoCloning(o.getBody(this.parent.getStateType()))\n                                        .addPragmaDirective(\n                                                Operation.PRAGMA_DIRECTIVE_NOTIFICATION)\n                                        .setReferer(getUri());\n                                this.parent.sendRequest(putOp);\n                            }));\n\n            break;\n        case DELETE:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.remove(body.reference);\n            }\n            break;\n        case GET:\n            ServiceDocument rsp;\n            synchronized (this.subscriptions) {\n                rsp = Utils.clone(this.subscriptions);\n            }\n            op.setBody(rsp);\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n\n        op.complete();\n    }\n\n    public boolean hasSubscribers() {\n        ServiceSubscriptionState subscriptions = this.subscriptions;\n        return subscriptions != null\n                && subscriptions.subscribers != null\n                && !subscriptions.subscribers.isEmpty();\n    }\n\n    public boolean hasStats() {\n        ServiceStats stats = this.stats;\n        return stats != null && stats.entries != null && !stats.entries.isEmpty();\n    }\n\n    public void notifySubscribers(Operation op) {\n        try {\n            if (op.getAction() == Action.GET) {\n                return;\n            }\n\n            if (!this.hasSubscribers()) {\n                return;\n            }\n\n            long now = Utils.getNowMicrosUtc();\n\n            Operation clone = op.clone();\n            clone.toggleOption(OperationOption.REMOTE, false);\n            clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NOTIFICATION);\n            for (Entry<URI, ServiceSubscriber> e : this.subscriptions.subscribers.entrySet()) {\n                ServiceSubscriber s = e.getValue();\n                notifySubscriber(now, clone, s);\n            }\n\n            if (!performSubscriptionsMaintenance(now)) {\n                return;\n            }\n        } catch (Throwable e) {\n            this.parent.getHost().log(Level.WARNING,\n                    \"Uncaught exception notifying subscribers for %s: %s\",\n                    this.parent.getSelfLink(), Utils.toString(e));\n        }\n    }\n\n    private void notifySubscriber(long now, Operation clone, ServiceSubscriber s) {\n        synchronized (s) {\n            if (s.failedNotificationCount != null) {\n                // indicate to the subscriber that they missed notifications and should retrieve latest state\n                clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_SKIPPED_NOTIFICATIONS);\n            }\n        }\n\n        CompletionHandler c = (o, ex) -> {\n            s.documentUpdateTimeMicros = Utils.getNowMicrosUtc();\n            synchronized (s) {\n                if (ex != null) {\n                    if (s.failedNotificationCount == null) {\n                        s.failedNotificationCount = 0L;\n                        s.initialFailedNotificationTimeMicros = now;\n                    }\n                    s.failedNotificationCount++;\n                    return;\n                }\n\n                if (s.failedNotificationCount != null) {\n                    // the subscriber is available again.\n                    s.failedNotificationCount = null;\n                    s.initialFailedNotificationTimeMicros = null;\n                }\n            }\n        };\n\n        this.parent.sendRequest(clone.setUri(s.reference).setCompletion(c));\n    }\n\n    private boolean performSubscriptionsMaintenance(long now) {\n        List<URI> subscribersToDelete = null;\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                return false;\n            }\n\n            Iterator<Entry<URI, ServiceSubscriber>> it = this.subscriptions.subscribers.entrySet()\n                    .iterator();\n            while (it.hasNext()) {\n                Entry<URI, ServiceSubscriber> e = it.next();\n                ServiceSubscriber s = e.getValue();\n                boolean remove = false;\n                synchronized (s) {\n                    if (s.documentExpirationTimeMicros != 0 && s.documentExpirationTimeMicros < now) {\n                        remove = true;\n                    } else if (s.notificationLimit != null) {\n                        if (s.notificationCount == null) {\n                            s.notificationCount = 0L;\n                        }\n                        if (++s.notificationCount >= s.notificationLimit) {\n                            remove = true;\n                        }\n                    } else if (s.failedNotificationCount != null\n                            && s.failedNotificationCount > ServiceSubscriber.NOTIFICATION_FAILURE_LIMIT) {\n                        if (now - s.initialFailedNotificationTimeMicros > getHost()\n                                .getMaintenanceIntervalMicros()) {\n                            getHost().log(Level.INFO,\n                                    \"removing subscriber, failed notifications: %d\",\n                                    s.failedNotificationCount);\n                            remove = true;\n                        }\n                    }\n                }\n\n                if (!remove) {\n                    continue;\n                }\n\n                it.remove();\n                if (subscribersToDelete == null) {\n                    subscribersToDelete = new ArrayList<>();\n                }\n                subscribersToDelete.add(s.reference);\n                continue;\n            }\n        }\n\n        if (subscribersToDelete != null) {\n            for (URI subscriber : subscribersToDelete) {\n                this.parent.sendRequest(Operation.createDelete(subscriber));\n            }\n        }\n\n        return true;\n    }\n\n    private void handleUiRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new IllegalArgumentException(\"Action not supported\"));\n            return;\n        }\n\n        if (!this.parent.hasOption(ServiceOption.HTML_USER_INTERFACE)) {\n            String servicePath = UriUtils.buildUriPath(ServiceUriPaths.UI_SERVICE_BASE_URL, op\n                    .getUri().getPath());\n            String defaultHtmlPath = UriUtils.buildUriPath(servicePath.substring(0,\n                    servicePath.length() - ServiceUriPaths.UI_PATH_SUFFIX.length()),\n                    ServiceUriPaths.UI_SERVICE_HOME);\n\n            redirectGetToHtmlUiResource(op, defaultHtmlPath);\n            return;\n        }\n\n        if (this.uiService == null) {\n            this.uiService = new UiContentService() {\n            };\n            this.uiService.setHost(this.parent.getHost());\n        }\n\n        // simulate a full service deployed at the utility endpoint /service/ui\n        String selfLink = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n        this.uiService.handleUiGet(selfLink, this.parent, op);\n    }\n\n    public void redirectGetToHtmlUiResource(Operation op, String htmlResourcePath) {\n        // redirect using relative url without host:port\n        // not so much optimization as handling the case of port forwarding/containers\n        try {\n            op.addResponseHeader(Operation.LOCATION_HEADER,\n                    URLDecoder.decode(htmlResourcePath, Utils.CHARSET));\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e);\n        }\n\n        op.setStatusCode(Operation.STATUS_CODE_MOVED_TEMP);\n        op.complete();\n    }\n\n    private void handleStatsRequest(Operation op) {\n        switch (op.getAction()) {\n        case PUT:\n            ServiceStats.ServiceStat stat = op\n                    .getBody(ServiceStats.ServiceStat.class);\n            if (stat.kind == null) {\n                op.fail(new IllegalArgumentException(\"kind is required\"));\n                return;\n            }\n            if (stat.kind.equals(ServiceStats.ServiceStat.KIND)) {\n                if (stat.name == null) {\n                    op.fail(new IllegalArgumentException(\"stat name is required\"));\n                    return;\n                }\n                replaceSingleStat(stat);\n            } else if (stat.kind.equals(ServiceStats.KIND)) {\n                ServiceStats stats = op.getBody(ServiceStats.class);\n                if (stats.entries == null || stats.entries.isEmpty()) {\n                    op.fail(new IllegalArgumentException(\"stats entries need to be defined\"));\n                    return;\n                }\n                replaceAllStats(stats);\n            } else {\n                op.fail(new IllegalArgumentException(\"operation not supported for kind\"));\n                return;\n            }\n            op.complete();\n            break;\n        case POST:\n            ServiceStats.ServiceStat newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // create a stat object if one does not exist\n            ServiceStats.ServiceStat existingStat = this.getStat(newStat.name);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat does not exist\"));\n                return;\n            }\n            initializeOrSetStat(existingStat, newStat);\n            op.complete();\n            break;\n        case DELETE:\n            // TODO support removing stats externally - do we need this?\n            op.fail(new NotActiveException());\n            break;\n        case PATCH:\n            newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // if an existing stat by this name exists, adjust the stat value, else this is a no-op\n            existingStat = this.getStat(newStat.name, false);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat to patch does not exist\"));\n                return;\n            }\n            adjustStat(existingStat, newStat.latestValue);\n            op.complete();\n            break;\n        case GET:\n            if (this.stats == null) {\n                ServiceStats s = new ServiceStats();\n                populateDocumentProperties(s);\n                op.setBody(s).complete();\n            } else {\n                ServiceStats rsp;\n                synchronized (this.stats) {\n                    rsp = populateDocumentProperties(this.stats);\n                    rsp = Utils.clone(rsp);\n                }\n\n                if (handleStatsGetWithODataRequest(op, rsp)) {\n                    return;\n                }\n\n                op.setBodyNoCloning(rsp);\n                op.complete();\n            }\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n    }\n\n    /**\n     * Selects statistics entries that satisfy a simple sub set of ODATA filter expressions\n     */\n    private boolean handleStatsGetWithODataRequest(Operation op, ServiceStats rsp) {\n        if (UriUtils.getODataCountParamValue(op.getUri())) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_COUNT + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataOrderByParamValue(op.getUri()) != null) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_ORDER_BY + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataSkipToParamValue(op.getUri()) != null) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_SKIP_TO + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataTopParamValue(op.getUri()) != null) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_TOP + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataFilterParamValue(op.getUri()) == null) {\n            return false;\n        }\n\n        QueryTask task = ODataUtils.toQuery(op, false, null);\n        if (task == null || task.querySpec.query == null) {\n            return false;\n        }\n\n        List<Query> clauses = task.querySpec.query.booleanClauses;\n        if (clauses == null || clauses.size() == 0) {\n            clauses = new ArrayList<Query>();\n            if (task.querySpec.query.term == null) {\n                return false;\n            }\n            clauses.add(task.querySpec.query);\n        }\n\n        return processStatsODataQueryClauses(op, rsp, clauses);\n    }\n\n    private boolean processStatsODataQueryClauses(Operation op, ServiceStats rsp,\n            List<Query> clauses) {\n        for (Query q : clauses) {\n            if (!Occurance.MUST_OCCUR.equals(q.occurance)) {\n                op.fail(new IllegalArgumentException(\"only AND expressions are supported\"));\n                return true;\n            }\n\n            QueryTerm term = q.term;\n\n            if (term == null) {\n                return processStatsODataQueryClauses(op, rsp, q.booleanClauses);\n            }\n\n            // prune entries using the filter match value and property\n            Iterator<Entry<String, ServiceStat>> statIt = rsp.entries.entrySet().iterator();\n            while (statIt.hasNext()) {\n                Entry<String, ServiceStat> e = statIt.next();\n                if (ServiceStat.FIELD_NAME_NAME.equals(term.propertyName)) {\n                    // match against the name property which is the also the key for the\n                    // entry table\n                    if (term.matchType.equals(MatchType.TERM)\n                            && e.getKey().equals(term.matchValue)) {\n                        continue;\n                    }\n                    if (term.matchType.equals(MatchType.PREFIX)\n                            && e.getKey().startsWith(term.matchValue)) {\n                        continue;\n                    }\n                    if (term.matchType.equals(MatchType.WILDCARD)) {\n                        // we only support two types of wild card queries:\n                        // *something or something*\n                        if (term.matchValue.endsWith(UriUtils.URI_WILDCARD_CHAR)) {\n                            // prefix match\n                            String mv = term.matchValue.replace(UriUtils.URI_WILDCARD_CHAR, \"\");\n                            if (e.getKey().startsWith(mv)) {\n                                continue;\n                            }\n                        } else if (term.matchValue.startsWith(UriUtils.URI_WILDCARD_CHAR)) {\n                            // suffix match\n                            String mv = term.matchValue.replace(UriUtils.URI_WILDCARD_CHAR, \"\");\n\n                            if (e.getKey().endsWith(mv)) {\n                                continue;\n                            }\n                        }\n                    }\n                } else if (ServiceStat.FIELD_NAME_LATEST_VALUE.equals(term.propertyName)) {\n                    // support numeric range queries on latest value\n                    if (term.range == null || term.range.type != TypeName.DOUBLE) {\n                        op.fail(new IllegalArgumentException(\n                                ServiceStat.FIELD_NAME_LATEST_VALUE\n                                        + \"requires double numeric range\"));\n                        return true;\n                    }\n                    @SuppressWarnings(\"unchecked\")\n                    NumericRange<Double> nr = (NumericRange<Double>) term.range;\n                    ServiceStat st = e.getValue();\n                    boolean withinMax = nr.isMaxInclusive && st.latestValue <= nr.max ||\n                            st.latestValue < nr.max;\n                    boolean withinMin = nr.isMinInclusive && st.latestValue >= nr.min ||\n                            st.latestValue > nr.min;\n                    if (withinMin && withinMax) {\n                        continue;\n                    }\n                }\n                statIt.remove();\n            }\n        }\n        return false;\n    }\n\n    private ServiceStats populateDocumentProperties(ServiceStats stats) {\n        ServiceStats clone = new ServiceStats();\n        // sort entries by key (natural ordering)\n        clone.entries = new TreeMap<>(stats.entries);\n        clone.documentUpdateTimeMicros = stats.documentUpdateTimeMicros;\n        clone.documentSelfLink = UriUtils.buildUriPath(this.parent.getSelfLink(),\n                ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        clone.documentOwner = getHost().getId();\n        clone.documentKind = Utils.buildKind(ServiceStats.class);\n        return clone;\n    }\n\n    private void handleDocumentTemplateRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new NotActiveException());\n            return;\n        }\n        ServiceDocument template = this.parent.getDocumentTemplate();\n        String serializedTemplate = Utils.toJsonHtml(template);\n        op.setBody(serializedTemplate).complete();\n    }\n\n    @Override\n    public void handleConfigurationRequest(Operation op) {\n        this.parent.handleConfigurationRequest(op);\n    }\n\n    public void handlePatchConfiguration(Operation op, ServiceConfigUpdateRequest updateBody) {\n        if (updateBody == null) {\n            updateBody = op.getBody(ServiceConfigUpdateRequest.class);\n        }\n\n        if (!ServiceConfigUpdateRequest.KIND.equals(updateBody.kind)) {\n            op.fail(new IllegalArgumentException(\"Unrecognized kind: \" + updateBody.kind));\n            return;\n        }\n\n        if (updateBody.maintenanceIntervalMicros == null\n                && updateBody.peerNodeSelectorPath == null\n                && updateBody.operationQueueLimit == null\n                && updateBody.epoch == null\n                && (updateBody.addOptions == null || updateBody.addOptions.isEmpty())\n                && (updateBody.removeOptions == null || updateBody.removeOptions\n                .isEmpty())\n                && updateBody.versionRetentionLimit == null) {\n            op.fail(new IllegalArgumentException(\n                    \"At least one configuraton field must be specified\"));\n            return;\n        }\n\n        if (updateBody.versionRetentionLimit != null) {\n            // Fail the request for immutable service as it is not allowed to change the version\n            // retention.\n            if (this.parent.getOptions().contains(ServiceOption.IMMUTABLE)) {\n                op.fail(new IllegalArgumentException(String.format(\n                        \"Service %s has option %s, retention limit cannot be modified\",\n                        this.parent.getSelfLink(), ServiceOption.IMMUTABLE)));\n                return;\n            }\n            ServiceDocumentDescription serviceDocumentDescription = this.parent\n                    .getDocumentTemplate().documentDescription;\n            serviceDocumentDescription.versionRetentionLimit = updateBody.versionRetentionLimit;\n            if (updateBody.versionRetentionFloor != null) {\n                serviceDocumentDescription.versionRetentionFloor = updateBody.versionRetentionFloor;\n            } else {\n                serviceDocumentDescription.versionRetentionFloor =\n                        updateBody.versionRetentionLimit / 2;\n            }\n        }\n\n        // service might fail a capability toggle if the capability can not be changed after start\n        if (updateBody.addOptions != null) {\n            for (ServiceOption c : updateBody.addOptions) {\n                this.parent.toggleOption(c, true);\n            }\n        }\n\n        if (updateBody.removeOptions != null) {\n            for (ServiceOption c : updateBody.removeOptions) {\n                this.parent.toggleOption(c, false);\n            }\n        }\n\n        if (updateBody.maintenanceIntervalMicros != null) {\n            this.parent.setMaintenanceIntervalMicros(updateBody.maintenanceIntervalMicros);\n        }\n\n        if (updateBody.peerNodeSelectorPath != null) {\n            this.parent.setPeerNodeSelectorPath(updateBody.peerNodeSelectorPath);\n        }\n\n        op.complete();\n    }\n\n    private void initializeOrSetStat(ServiceStat stat, ServiceStat newValue) {\n        synchronized (stat) {\n            if (stat.timeSeriesStats == null && newValue.timeSeriesStats != null) {\n                stat.timeSeriesStats = new TimeSeriesStats(newValue.timeSeriesStats.numBins,\n                        newValue.timeSeriesStats.binDurationMillis, newValue.timeSeriesStats.aggregationType);\n            }\n            stat.unit = newValue.unit;\n            stat.sourceTimeMicrosUtc = newValue.sourceTimeMicrosUtc;\n            setStat(stat, newValue.latestValue);\n        }\n    }\n\n    @Override\n    public void setStat(ServiceStat stat, double newValue) {\n        allocateStats();\n        findStat(stat.name, true, stat);\n        synchronized (stat) {\n            stat.version++;\n            stat.accumulatedValue += newValue;\n            stat.latestValue = newValue;\n            if (stat.logHistogram != null) {\n                int binIndex = 0;\n                if (newValue > 0.0) {\n                    binIndex = (int) Math.log10(newValue);\n                }\n                if (binIndex >= 0 && binIndex < stat.logHistogram.bins.length) {\n                    stat.logHistogram.bins[binIndex]++;\n                }\n            }\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, newValue, newValue);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, newValue, newValue);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void adjustStat(ServiceStat stat, double delta) {\n        allocateStats();\n        synchronized (stat) {\n            stat.latestValue += delta;\n            stat.version++;\n            if (stat.logHistogram != null) {\n                int binIndex = 0;\n                if (delta > 0.0) {\n                    binIndex = (int) Math.log10(delta);\n                }\n                if (binIndex >= 0 && binIndex < stat.logHistogram.bins.length) {\n                    stat.logHistogram.bins[binIndex]++;\n                }\n            }\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, stat.latestValue, delta);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, stat.latestValue, delta);\n                }\n            }\n        }\n    }\n\n    @Override\n    public ServiceStat getStat(String name) {\n        return getStat(name, true);\n    }\n\n    private ServiceStat getStat(String name, boolean create) {\n        if (!allocateStats(true)) {\n            return null;\n        }\n        return findStat(name, create, null);\n    }\n\n    private void replaceSingleStat(ServiceStat stat) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // create a new stat with the default values\n            ServiceStat newStat = new ServiceStat();\n            newStat.name = stat.name;\n            initializeOrSetStat(newStat, stat);\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            // add it to the list of stats for this service\n            this.stats.entries.put(stat.name, newStat);\n        }\n    }\n\n    private void replaceAllStats(ServiceStats newStats) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // reset the current set of stats\n            this.stats.entries.clear();\n            for (ServiceStats.ServiceStat currentStat : newStats.entries.values()) {\n                replaceSingleStat(currentStat);\n            }\n\n        }\n    }\n\n    private ServiceStat findStat(String name, boolean create, ServiceStat initialStat) {\n        synchronized (this.stats) {\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            ServiceStat st = this.stats.entries.get(name);\n            if (st == null && create) {\n                st = initialStat != null ? initialStat : new ServiceStat();\n                name = name.intern();\n                st.name = name;\n                this.stats.entries.put(name, st);\n            }\n\n            if (create && st != null && initialStat != null) {\n                // if the statistic already exists make sure it has the same features\n                // as the statistic we are trying to create\n                if (st.timeSeriesStats == null && initialStat.timeSeriesStats != null) {\n                    st.timeSeriesStats = initialStat.timeSeriesStats;\n                }\n                if (st.logHistogram == null && initialStat.logHistogram != null) {\n                    st.logHistogram = initialStat.logHistogram;\n                }\n            }\n            return st;\n        }\n    }\n\n    private void allocateStats() {\n        allocateStats(true);\n    }\n\n    private synchronized boolean allocateStats(boolean mustAllocate) {\n        if (!mustAllocate && this.stats == null) {\n            return false;\n        }\n        if (this.stats != null) {\n            return true;\n        }\n        this.stats = new ServiceStats();\n        return true;\n    }\n\n    @Override\n    public ServiceHost getHost() {\n        return this.parent.getHost();\n    }\n\n    @Override\n    public String getSelfLink() {\n        return null;\n    }\n\n    @Override\n    public URI getUri() {\n        return null;\n    }\n\n    @Override\n    public OperationProcessingChain getOperationProcessingChain() {\n        return null;\n    }\n\n    @Override\n    public ProcessingStage getProcessingStage() {\n        return ProcessingStage.AVAILABLE;\n    }\n\n    @Override\n    public EnumSet<ServiceOption> getOptions() {\n        return EnumSet.of(ServiceOption.UTILITY);\n    }\n\n    @Override\n    public boolean hasOption(ServiceOption cap) {\n        return false;\n    }\n\n    @Override\n    public void toggleOption(ServiceOption cap, boolean enable) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public void adjustStat(String name, double delta) {\n        return;\n    }\n\n    @Override\n    public void setStat(String name, double newValue) {\n        return;\n    }\n\n    @Override\n    public void handleMaintenance(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void setHost(ServiceHost serviceHost) {\n\n    }\n\n    @Override\n    public void setSelfLink(String path) {\n\n    }\n\n    @Override\n    public void setOperationProcessingChain(OperationProcessingChain opProcessingChain) {\n\n    }\n\n    @Override\n    public ServiceRuntimeContext setProcessingStage(ProcessingStage initialized) {\n        return null;\n    }\n\n    @Override\n    public ServiceDocument setInitialState(Object state, Long initialVersion) {\n        return null;\n    }\n\n    @Override\n    public Service getUtilityService(String uriPath) {\n        return null;\n    }\n\n    @Override\n    public boolean queueRequest(Operation op) {\n        return false;\n    }\n\n    @Override\n    public void sendRequest(Operation op) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public ServiceDocument getDocumentTemplate() {\n        return null;\n    }\n\n    @Override\n    public void setPeerNodeSelectorPath(String uriPath) {\n\n    }\n\n    @Override\n    public String getPeerNodeSelectorPath() {\n        return null;\n    }\n\n    @Override\n    public void setDocumentIndexPath(String uriPath) {\n\n    }\n\n    @Override\n    public String getDocumentIndexPath() {\n        return null;\n    }\n\n    @Override\n    public void setState(Operation op, ServiceDocument newState) {\n        op.linkState(newState);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends ServiceDocument> T getState(Operation op) {\n        return (T) op.getLinkedState();\n    }\n\n    @Override\n    public void setMaintenanceIntervalMicros(long micros) {\n        throw new RuntimeException(\"not implemented\");\n    }\n\n    @Override\n    public long getMaintenanceIntervalMicros() {\n        return 0;\n    }\n\n    @Override\n    public Operation dequeueRequest() {\n        return null;\n    }\n\n    @Override\n    public Class<? extends ServiceDocument> getStateType() {\n        return null;\n    }\n\n    @Override\n    public final void setAuthorizationContext(Operation op, AuthorizationContext ctx) {\n        throw new RuntimeException(\"Service not allowed to set authorization context\");\n    }\n\n    @Override\n    public final AuthorizationContext getSystemAuthorizationContext() {\n        throw new RuntimeException(\"Service not allowed to get system authorization context\");\n    }\n}\n", "target": 0}
{"idx": 959, "func": "\n/**\n * Copyright (C) 2011 Xavier Jodoin (xavier@jodoin.me)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author xjodoin\n * @version $Id: $Id\n */\npackage org.torpedoquery.jpa.internal.conditions;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.torpedoquery.core.QueryBuilder;\nimport org.torpedoquery.jpa.ComparableFunction;\nimport org.torpedoquery.jpa.Function;\nimport org.torpedoquery.jpa.OnGoingCollectionCondition;\nimport org.torpedoquery.jpa.OnGoingComparableCondition;\nimport org.torpedoquery.jpa.OnGoingLikeCondition;\nimport org.torpedoquery.jpa.OnGoingLogicalCondition;\nimport org.torpedoquery.jpa.OnGoingStringCondition;\nimport org.torpedoquery.jpa.Query;\nimport org.torpedoquery.jpa.internal.Condition;\nimport org.torpedoquery.jpa.internal.Parameter;\nimport org.torpedoquery.jpa.internal.Selector;\nimport org.torpedoquery.jpa.internal.conditions.LikeCondition.Type;\nimport org.torpedoquery.jpa.internal.selectors.NotSelector;\nimport org.torpedoquery.jpa.internal.selectors.SizeSelector;\npublic class ConditionBuilder<T> implements OnGoingComparableCondition<T>, OnGoingStringCondition<T>,\n\t\tOnGoingLikeCondition, OnGoingCollectionCondition<T>, Condition, Serializable {\n\tprivate Selector selector;\n\tprivate final LogicalCondition logicalCondition;\n\tprivate Condition condition;\n\tprivate boolean notLike;\n\n\t/**\n\t * <p>\n\t * Constructor for ConditionBuilder.\n\t * </p>\n\t *\n\t * @param builder\n\t *            a {@link org.torpedoquery.core.QueryBuilder} object.\n\t * @param selector\n\t *            a {@link org.torpedoquery.jpa.internal.Selector} object.\n\t */\n\tpublic ConditionBuilder(QueryBuilder<T> builder, Selector<?> selector) {\n\t\tthis.logicalCondition = new LogicalCondition(builder, this);\n\t\tthis.selector = selector;\n\t}\n\n\t/**\n\t * <p>\n\t * Constructor for ConditionBuilder.\n\t * </p>\n\t *\n\t * @param logicalCondition\n\t *            a\n\t *            {@link org.torpedoquery.jpa.internal.conditions.LogicalCondition}\n\t *            object.\n\t * @param selector\n\t *            a {@link org.torpedoquery.jpa.internal.Selector} object.\n\t */\n\tpublic ConditionBuilder(LogicalCondition logicalCondition, Selector<?> selector) {\n\t\tthis.logicalCondition = logicalCondition;\n\t\tthis.selector = selector;\n\t}\n\n\t/**\n\t * <p>\n\t * Getter for the field <code>logicalCondition</code>.\n\t * </p>\n\t *\n\t * @return a\n\t *         {@link org.torpedoquery.jpa.internal.conditions.LogicalCondition}\n\t *         object.\n\t */\n\tpublic LogicalCondition getLogicalCondition() {\n\t\treturn logicalCondition;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition eq(T value) {\n\t\tCondition conditionLocal = new EqualCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition eq(Class<? extends T> value) {\n\t\tCondition conditionLocal = new EqualPolymorphicCondition<T>(selector, value);\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition neq(T value) {\n\t\tCondition conditionLocal = new NotEqualCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition neq(Class<? extends T> value) {\n\t\tCondition conditionLocal = new NotEqualPolymorphicCondition<T>(selector, value);\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition lt(T value) {\n\t\tCondition conditionLocal = new LtCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition lte(T value) {\n\t\tCondition conditionLocal = new LteCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition gt(T value) {\n\t\tCondition conditionLocal = new GtCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition gte(T value) {\n\t\tCondition conditionLocal = new GteCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition isNull() {\n\t\tCondition conditionLocal = new IsNullCondition(selector);\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition isNotNull() {\n\t\tCondition conditionLocal = new IsNotNullCondition(selector);\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition in(T... values) {\n\t\treturn in(Arrays.asList(values));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition in(Collection<T> values) {\n\t\tCondition conditionLocal = new InCondition<T>(selector, selector.generateParameter(values));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition in(Query<T> query) {\n\t\tCondition conditionLocal = new InSubQueryCondition<T>(selector, (QueryBuilder) query);\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition notIn(T... values) {\n\t\treturn notIn(Arrays.asList(values));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition notIn(Collection<T> values) {\n\t\treturn getOnGoingLogicalCondition(new NotInCondition<T>(selector, selector.generateParameter(values)));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition notIn(Query<T> subQuery) {\n\t\treturn getOnGoingLogicalCondition(new NotInSubQueryCondition<T>(selector, (QueryBuilder) subQuery));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic String createQueryFragment(AtomicInteger incrementor) {\n\t\tif (condition != null) {\n\t\t\treturn condition.createQueryFragment(incrementor);\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\n\t}\n\n\tprivate OnGoingLogicalCondition getOnGoingLogicalCondition(Condition condition) {\n\t\tthis.condition = condition;\n\t\treturn logicalCondition;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic List<Parameter> getParameters() {\n\t\tif (condition != null) {\n\t\t\treturn condition.getParameters();\n\t\t} else {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLikeCondition like() {\n\t\treturn this;\n\t}\n\t\n\t@Override\n\tpublic OnGoingLogicalCondition like(String likeValue) {\n\t\treturn getOnGoingLogicalCondition(createLike(LikeCondition.Type.UNKNOW, likeValue));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLikeCondition notLike() {\n\t\tnotLike = true;\n\t\treturn this;\n\t}\n\t\n\t@Override\n\tpublic OnGoingLogicalCondition notLike(String notLikeValue) {\n\t\tnotLike = true;\n\t\treturn getOnGoingLogicalCondition(createLike(LikeCondition.Type.UNKNOW, notLikeValue));\n\t}\n\n\tprivate LikeCondition createLike(Type type, String toMatch) {\n\t\tif (notLike) {\n\t\t\treturn new NotLikeCondition(selector, selector.generateParameter(type.wrap(toMatch)));\n\t\t} else {\n\t\t\treturn new LikeCondition(selector, selector.generateParameter(type.wrap(toMatch)));\n\t\t}\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition any(String toMatch) {\n\t\treturn getOnGoingLogicalCondition(createLike(LikeCondition.Type.ANY, toMatch));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition startsWith(String toMatch) {\n\t\treturn getOnGoingLogicalCondition(createLike(LikeCondition.Type.STARTSWITH, toMatch));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition endsWith(String toMatch) {\n\t\treturn getOnGoingLogicalCondition(createLike(LikeCondition.Type.ENDSWITH, toMatch));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition isEmpty() {\n\t\treturn getOnGoingLogicalCondition(new IsEmptyCondition(selector));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition isNotEmpty() {\n\t\treturn getOnGoingLogicalCondition(new IsNotEmptyCondition(selector));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition memberOf(T member) {\n\t\treturn getOnGoingLogicalCondition(new MemberOfCondition<>(selector, selector.generateParameter(member)));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingComparableCondition<Integer> size() {\n\t\tselector = new SizeSelector(selector);\n\t\treturn (OnGoingComparableCondition<Integer>) this;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition lt(ComparableFunction<T> value) {\n\t\tCondition conditionLocal = new LtCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition lte(ComparableFunction<T> value) {\n\t\tCondition conditionLocal = new LteCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition gt(ComparableFunction<T> value) {\n\t\tCondition conditionLocal = new GtCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition gte(ComparableFunction<T> value) {\n\t\tCondition conditionLocal = new GteCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition eq(Function<T> value) {\n\t\tCondition conditionLocal = new EqualCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition neq(Function<T> value) {\n\t\tCondition conditionLocal = new NotEqualCondition<T>(selector, selector.generateParameter(value));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition between(T from, T to) {\n\t\tCondition conditionLocal = new BetweenCondition<T>(selector,\n\t\t\t\tArrays.asList(selector.generateParameter(from), selector.generateParameter(to)));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition notBetween(T from, T to) {\n\t\tCondition conditionLocal = new BetweenCondition<T>(new NotSelector(selector),\n\t\t\t\tArrays.asList(selector.generateParameter(from), selector.generateParameter(to)));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition between(ComparableFunction<T> from, ComparableFunction<T> to) {\n\t\tCondition conditionLocal = new BetweenCondition<T>(selector,\n\t\t\t\tArrays.asList(selector.generateParameter(from), selector.generateParameter(to)));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic OnGoingLogicalCondition notBetween(ComparableFunction<T> from, ComparableFunction<T> to) {\n\t\tCondition conditionLocal = new BetweenCondition<T>(new NotSelector(selector),\n\t\t\t\tArrays.asList(selector.generateParameter(from), selector.generateParameter(to)));\n\t\treturn getOnGoingLogicalCondition(conditionLocal);\n\t}\n\t\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic <T> QueryBuilder<T> getBuilder() {\n\t\treturn logicalCondition.getBuilder();\n\t}\n\t\n}\n", "target": 0}
{"idx": 960, "func": "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.facebook.thrift;\n\nimport com.facebook.thrift.java.test.MyListStruct;\nimport com.facebook.thrift.java.test.MyMapStruct;\nimport com.facebook.thrift.java.test.MySetStruct;\nimport com.facebook.thrift.java.test.MyStringStruct;\nimport com.facebook.thrift.protocol.TBinaryProtocol;\nimport com.facebook.thrift.protocol.TCompactProtocol;\nimport com.facebook.thrift.protocol.TProtocol;\nimport com.facebook.thrift.protocol.TProtocolException;\nimport com.facebook.thrift.protocol.TType;\nimport com.facebook.thrift.transport.TMemoryInputTransport;\nimport org.junit.Test;\n\npublic class TruncatedFrameTest extends junit.framework.TestCase {\n  private static final byte[] kBinaryListEncoding = {\n    TType.LIST, // Field Type = List\n    (byte) 0x00,\n    (byte) 0x01, // Field id = 1\n    TType.I64, // List type = i64\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0xFF, // List length (255 > 3!)\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // value = 1L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x02, // value = 2L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x03, // value = 3L\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactListEncoding = {\n    (byte) 0b00011001, // field id delta (0001) + type (1001) = List\n    (byte) 0b11100110, // list size (0111) and 7>3 + list type (0110) = i64\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactListEncoding2 = {\n    (byte) 0b00011001, // field id delta (0001) + type (1001) = List\n    (byte) 0b11110110, // list size magic marker (1111) + list type (0110) = i64\n    (byte) 0x64, // list actual size (varint of 1 byte here) = 100\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  public static void testTruncated(TBase struct, TProtocol iprot) throws Exception {\n    try {\n      struct.read(iprot);\n      assertTrue(\"Not reachable\", false);\n    } catch (TProtocolException ex) {\n      assertEquals(\n          \"Not enough bytes to read the entire message, the data appears to be truncated\",\n          ex.getMessage());\n    }\n  }\n\n  @Test\n  public static void testListBinary() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kBinaryListEncoding);\n    TProtocol iprot = new TBinaryProtocol(buf);\n    testTruncated(new MyListStruct(), iprot);\n  }\n\n  @Test\n  public static void testListCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactListEncoding);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MyListStruct(), iprot);\n  }\n\n  @Test\n  public static void testLongListCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactListEncoding2);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MyListStruct(), iprot);\n  }\n\n  private static final byte[] kBinarySetEncoding = {\n    TType.SET, // Field Type = Set\n    (byte) 0x00,\n    (byte) 0x01, // Field id = 1\n    TType.I64, // Set type = i64\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0xFF, // Set length (255 > 3!)\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // value = 1L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x02, // value = 2L\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x03, // value = 3L\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactSetEncoding = {\n    (byte) 0b00011010, // field id delta (0001) + type (1010) = Set\n    (byte) 0b01110110, // set size (0111) and 7>3 + set type (0110) = i64\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactSetEncoding2 = {\n    (byte) 0b00011010, // field id delta (0001) + type (1010) = Set\n    (byte) 0b11110110, // set size magic marker (1111) + set type (0110) = i64\n    (byte) 0x64, // set actual size (varint of 1 byte here) = 100\n    (byte) 0x02, // value = 1 (zigzag encoded)\n    (byte) 0x04, // value = 2 (zigzag encoded)\n    (byte) 0x06, // value = 3 (zigzag encoded)\n    (byte) 0x00, // Stop\n  };\n\n  @Test\n  public static void testSetBinary() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kBinarySetEncoding);\n    TProtocol iprot = new TBinaryProtocol(buf);\n    testTruncated(new MySetStruct(), iprot);\n  }\n\n  @Test\n  public static void testSetCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactSetEncoding);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MySetStruct(), iprot);\n  }\n\n  @Test\n  public static void testLongSetCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactSetEncoding2);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MySetStruct(), iprot);\n  }\n\n  private static final byte[] kBinaryMapEncoding = {\n    TType.MAP, // field type = Map\n    (byte) 0x00,\n    (byte) 0x01, // field id = 1\n    TType.I64, // key type = i64\n    TType.STRING, // value type = string\n    (byte) 0x00,\n    (byte) 0xFF,\n    (byte) 0xFF,\n    (byte) 0xFF, // size = 0x00FFFFFF\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00, // key = 0\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // string size = 1\n    (byte) 0x30, // string value = \"0\"\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // key = 1\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // string size = 1\n    (byte) 0x31, // string value = \"1\"\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x02, // key = 2\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x01, // string size = 1\n    (byte) 0x32, // string value = \"2\"\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactMapEncoding = {\n    (byte) 0b00011011, // field id delta (0001) + type (1011) = Map\n    (byte) 0x64, // map size (varint = 100)\n    (byte) 0b01101000, // key type (0110) i64, value type (1000) string\n    (byte) 0x00, // key value = 0\n    (byte) 0x01, // value: string size = 1\n    (byte) 0x30, // string content = \"0\"\n    (byte) 0x02, // key value = 1 (zigzag encoded)\n    (byte) 0x01, // value: string size = 1\n    (byte) 0x31, // string content = \"1\"\n    (byte) 0x04, // key value = 2 (zigzag encoded)\n    (byte) 0x01, // value: string size = 1\n    (byte) 0x32, // string content = \"2\"\n    (byte) 0x00, // Stop\n  };\n\n  @Test\n  public static void testMapBinary() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kBinaryMapEncoding);\n    TProtocol iprot = new TBinaryProtocol(buf);\n    testTruncated(new MyMapStruct(), iprot);\n  }\n\n  @Test\n  public static void testMapCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactMapEncoding);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MyMapStruct(), iprot);\n  }\n\n  private static final byte[] kBinaryStringEncoding = {\n    TType.STRING, // Field Type = string\n    (byte) 0x00,\n    (byte) 0x01, // Field id = 1\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0x00,\n    (byte) 0xFF, // string length (255!)\n    (byte) 0x48,\n    (byte) 0x65,\n    (byte) 0x6C,\n    (byte) 0x6C,\n    (byte) 0x6F,\n    (byte) 0x2C,\n    (byte) 0x20,\n    (byte) 0x57,\n    (byte) 0x6F,\n    (byte) 0x72,\n    (byte) 0x6C,\n    (byte) 0x64,\n    (byte) 0x21, // string chars: \"Hello, World!\"\n    (byte) 0x00, // Stop\n  };\n\n  private static final byte[] kCompactStringEncoding = {\n    (byte) 0b00011000, // field id delta (0001) + type (1000) = Binary\n    (byte) 0xFF,\n    (byte) 0x0F, // string size (varint) = 0x0FFF (4095)\n    (byte) 0x48,\n    (byte) 0x65,\n    (byte) 0x6C,\n    (byte) 0x6C,\n    (byte) 0x6F,\n    (byte) 0x2C,\n    (byte) 0x20,\n    (byte) 0x57,\n    (byte) 0x6F,\n    (byte) 0x72,\n    (byte) 0x6C,\n    (byte) 0x64,\n    (byte) 0x21, // string chars: \"Hello, World!\"\n    (byte) 0x00, // Stop\n  };\n\n  @Test\n  public void testStringBinary() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kBinaryStringEncoding);\n    TProtocol iprot = new TBinaryProtocol(buf);\n    testTruncated(new MyStringStruct(), iprot);\n  }\n\n  @Test\n  public void testStringCompact() throws Exception {\n    TMemoryInputTransport buf = new TMemoryInputTransport(kCompactStringEncoding);\n    TProtocol iprot = new TCompactProtocol(buf);\n    testTruncated(new MyStringStruct(), iprot);\n  }\n}\n", "target": 0}
{"idx": 961, "func": "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.sonos.internal;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n * The {@link SonosXMLParser} is a class of helper functions\n * to parse XML data returned by the Zone Players\n *\n * @author Karel Goderis - Initial contribution\n */\n@NonNullByDefault\npublic class SonosXMLParser {\n\n    static final Logger LOGGER = LoggerFactory.getLogger(SonosXMLParser.class);\n\n    private static final MessageFormat METADATA_FORMAT = new MessageFormat(\n            \"<DIDL-Lite xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\" \"\n                    + \"xmlns:upnp=\\\"urn:schemas-upnp-org:metadata-1-0/upnp/\\\" \"\n                    + \"xmlns:r=\\\"urn:schemas-rinconnetworks-com:metadata-1-0/\\\" \"\n                    + \"xmlns=\\\"urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/\\\">\"\n                    + \"<item id=\\\"{0}\\\" parentID=\\\"{1}\\\" restricted=\\\"true\\\">\" + \"<dc:title>{2}</dc:title>\"\n                    + \"<upnp:class>{3}</upnp:class>\"\n                    + \"<desc id=\\\"cdudn\\\" nameSpace=\\\"urn:schemas-rinconnetworks-com:metadata-1-0/\\\">\" + \"{4}</desc>\"\n                    + \"</item></DIDL-Lite>\");\n\n    private enum Element {\n        TITLE,\n        CLASS,\n        ALBUM,\n        ALBUM_ART_URI,\n        CREATOR,\n        RES,\n        TRACK_NUMBER,\n        RESMD,\n        DESC\n    }\n\n    private enum CurrentElement {\n        item,\n        res,\n        streamContent,\n        albumArtURI,\n        title,\n        upnpClass,\n        creator,\n        album,\n        albumArtist,\n        desc\n    }\n\n    /**\n     * @param xml\n     * @return a list of alarms from the given xml string.\n     * @throws IOException\n     * @throws SAXException\n     */\n    public static List<SonosAlarm> getAlarmsFromStringResult(String xml) {\n        AlarmHandler handler = new AlarmHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            LOGGER.error(\"Could not parse Alarms from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Alarms from string '{}'\", xml);\n        }\n        return handler.getAlarms();\n    }\n\n    /**\n     * @param xml\n     * @return a list of Entries from the given xml string.\n     * @throws IOException\n     * @throws SAXException\n     */\n    public static List<SonosEntry> getEntriesFromString(String xml) {\n        EntryHandler handler = new EntryHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            LOGGER.error(\"Could not parse Entries from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Entries from string '{}'\", xml);\n        }\n\n        return handler.getArtists();\n    }\n\n    /**\n     * Returns the meta data which is needed to play Pandora\n     * (and others?) favorites\n     *\n     * @param xml\n     * @return The value of the desc xml tag\n     * @throws SAXException\n     */\n    public static @Nullable SonosResourceMetaData getResourceMetaData(String xml) throws SAXException {\n        XMLReader reader = XMLReaderFactory.createXMLReader();\n        reader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        ResourceMetaDataHandler handler = new ResourceMetaDataHandler();\n        reader.setContentHandler(handler);\n        try {\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            LOGGER.error(\"Could not parse Resource MetaData from String '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Resource MetaData from string '{}'\", xml);\n        }\n        return handler.getMetaData();\n    }\n\n    /**\n     * @param controller\n     * @param xml\n     * @return zone group from the given xml\n     * @throws IOException\n     * @throws SAXException\n     */\n    public static List<SonosZoneGroup> getZoneGroupFromXML(String xml) {\n        ZoneGroupHandler handler = new ZoneGroupHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse ZoneGroup from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse ZoneGroup from string '{}'\", xml);\n        }\n\n        return handler.getGroups();\n    }\n\n    public static List<String> getRadioTimeFromXML(String xml) {\n        OpmlHandler handler = new OpmlHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse RadioTime from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse RadioTime from string '{}'\", xml);\n        }\n\n        return handler.getTextFields();\n    }\n\n    public static Map<String, @Nullable String> getRenderingControlFromXML(String xml) {\n        RenderingControlEventHandler handler = new RenderingControlEventHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse Rendering Control from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse Rendering Control from string '{}'\", xml);\n        }\n        return handler.getChanges();\n    }\n\n    public static Map<String, @Nullable String> getAVTransportFromXML(String xml) {\n        AVTransportEventHandler handler = new AVTransportEventHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse AV Transport from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse AV Transport from string '{}'\", xml);\n        }\n        return handler.getChanges();\n    }\n\n    public static SonosMetaData getMetaDataFromXML(String xml) {\n        MetaDataHandler handler = new MetaDataHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse MetaData from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse MetaData from string '{}'\", xml);\n        }\n\n        return handler.getMetaData();\n    }\n\n    public static List<SonosMusicService> getMusicServicesFromXML(String xml) {\n        MusicServiceHandler handler = new MusicServiceHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(handler);\n            reader.parse(new InputSource(new StringReader(xml)));\n        } catch (IOException e) {\n            // This should never happen - we're not performing I/O!\n            LOGGER.error(\"Could not parse music services from string '{}'\", xml);\n        } catch (SAXException s) {\n            LOGGER.error(\"Could not parse music services from string '{}'\", xml);\n        }\n        return handler.getServices();\n    }\n\n    private static class EntryHandler extends DefaultHandler {\n\n        // Maintain a set of elements about which it is unuseful to complain about.\n        // This list will be initialized on the first failure case\n        private static @Nullable List<String> ignore;\n\n        private String id = \"\";\n        private String parentId = \"\";\n        private StringBuilder upnpClass = new StringBuilder();\n        private StringBuilder res = new StringBuilder();\n        private StringBuilder title = new StringBuilder();\n        private StringBuilder album = new StringBuilder();\n        private StringBuilder albumArtUri = new StringBuilder();\n        private StringBuilder creator = new StringBuilder();\n        private StringBuilder trackNumber = new StringBuilder();\n        private StringBuilder desc = new StringBuilder();\n        private @Nullable Element element;\n\n        private List<SonosEntry> artists = new ArrayList<>();\n\n        EntryHandler() {\n            // shouldn't be used outside of this package.\n        }\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            String name = qName == null ? \"\" : qName;\n            switch (name) {\n                case \"container\":\n                case \"item\":\n                    if (attributes != null) {\n                        id = attributes.getValue(\"id\");\n                        parentId = attributes.getValue(\"parentID\");\n                    }\n                    break;\n                case \"res\":\n                    element = Element.RES;\n                    break;\n                case \"dc:title\":\n                    element = Element.TITLE;\n                    break;\n                case \"upnp:class\":\n                    element = Element.CLASS;\n                    break;\n                case \"dc:creator\":\n                    element = Element.CREATOR;\n                    break;\n                case \"upnp:album\":\n                    element = Element.ALBUM;\n                    break;\n                case \"upnp:albumArtURI\":\n                    element = Element.ALBUM_ART_URI;\n                    break;\n                case \"upnp:originalTrackNumber\":\n                    element = Element.TRACK_NUMBER;\n                    break;\n                case \"r:resMD\":\n                    element = Element.RESMD;\n                    break;\n                default:\n                    List<String> curIgnore = ignore;\n                    if (curIgnore == null) {\n                        curIgnore = new ArrayList<>();\n                        curIgnore.add(\"DIDL-Lite\");\n                        curIgnore.add(\"type\");\n                        curIgnore.add(\"ordinal\");\n                        curIgnore.add(\"description\");\n                        ignore = curIgnore;\n                    }\n\n                    if (!curIgnore.contains(localName)) {\n                        LOGGER.debug(\"Did not recognise element named {}\", localName);\n                    }\n                    element = null;\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            Element elt = element;\n            if (elt == null) {\n                return;\n            }\n            switch (elt) {\n                case TITLE:\n                    title.append(ch, start, length);\n                    break;\n                case CLASS:\n                    upnpClass.append(ch, start, length);\n                    break;\n                case RES:\n                    res.append(ch, start, length);\n                    break;\n                case ALBUM:\n                    album.append(ch, start, length);\n                    break;\n                case ALBUM_ART_URI:\n                    albumArtUri.append(ch, start, length);\n                    break;\n                case CREATOR:\n                    creator.append(ch, start, length);\n                    break;\n                case TRACK_NUMBER:\n                    trackNumber.append(ch, start, length);\n                    break;\n                case RESMD:\n                    desc.append(ch, start, length);\n                    break;\n                case DESC:\n                    break;\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if ((\"container\".equals(qName) || \"item\".equals(qName))) {\n                element = null;\n\n                int trackNumberVal = 0;\n                try {\n                    trackNumberVal = Integer.parseInt(trackNumber.toString());\n                } catch (Exception e) {\n                }\n\n                SonosResourceMetaData md = null;\n\n                // The resource description is needed for playing favorites on pandora\n                if (!desc.toString().isEmpty()) {\n                    try {\n                        md = getResourceMetaData(desc.toString());\n                    } catch (SAXException ignore) {\n                        LOGGER.debug(\"Failed to parse embeded\", ignore);\n                    }\n                }\n\n                artists.add(new SonosEntry(id, title.toString(), parentId, album.toString(), albumArtUri.toString(),\n                        creator.toString(), upnpClass.toString(), res.toString(), trackNumberVal, md));\n                title = new StringBuilder();\n                upnpClass = new StringBuilder();\n                res = new StringBuilder();\n                album = new StringBuilder();\n                albumArtUri = new StringBuilder();\n                creator = new StringBuilder();\n                trackNumber = new StringBuilder();\n                desc = new StringBuilder();\n            }\n        }\n\n        public List<SonosEntry> getArtists() {\n            return artists;\n        }\n    }\n\n    private static class ResourceMetaDataHandler extends DefaultHandler {\n\n        private String id = \"\";\n        private String parentId = \"\";\n        private StringBuilder title = new StringBuilder();\n        private StringBuilder upnpClass = new StringBuilder();\n        private StringBuilder desc = new StringBuilder();\n        private @Nullable Element element;\n        private @Nullable SonosResourceMetaData metaData;\n\n        ResourceMetaDataHandler() {\n            // shouldn't be used outside of this package.\n        }\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            String name = qName == null ? \"\" : qName;\n            switch (name) {\n                case \"container\":\n                case \"item\":\n                    if (attributes != null) {\n                        id = attributes.getValue(\"id\");\n                        parentId = attributes.getValue(\"parentID\");\n                    }\n                    break;\n                case \"desc\":\n                    element = Element.DESC;\n                    break;\n                case \"upnp:class\":\n                    element = Element.CLASS;\n                    break;\n                case \"dc:title\":\n                    element = Element.TITLE;\n                    break;\n                default:\n                    element = null;\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            Element elt = element;\n            if (elt == null) {\n                return;\n            }\n            switch (elt) {\n                case TITLE:\n                    title.append(ch, start, length);\n                    break;\n                case CLASS:\n                    upnpClass.append(ch, start, length);\n                    break;\n                case DESC:\n                    desc.append(ch, start, length);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"DIDL-Lite\".equals(qName)) {\n                metaData = new SonosResourceMetaData(id, parentId, title.toString(), upnpClass.toString(),\n                        desc.toString());\n                element = null;\n                desc = new StringBuilder();\n                upnpClass = new StringBuilder();\n                title = new StringBuilder();\n            }\n        }\n\n        public @Nullable SonosResourceMetaData getMetaData() {\n            return metaData;\n        }\n    }\n\n    private static class AlarmHandler extends DefaultHandler {\n\n        private @Nullable String id;\n        private String startTime = \"\";\n        private String duration = \"\";\n        private String recurrence = \"\";\n        private @Nullable String enabled;\n        private String roomUUID = \"\";\n        private String programURI = \"\";\n        private String programMetaData = \"\";\n        private String playMode = \"\";\n        private @Nullable String volume;\n        private @Nullable String includeLinkedZones;\n\n        private List<SonosAlarm> alarms = new ArrayList<>();\n\n        AlarmHandler() {\n            // shouldn't be used outside of this package.\n        }\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"Alarm\".equals(qName) && attributes != null) {\n                id = attributes.getValue(\"ID\");\n                duration = attributes.getValue(\"Duration\");\n                recurrence = attributes.getValue(\"Recurrence\");\n                startTime = attributes.getValue(\"StartTime\");\n                enabled = attributes.getValue(\"Enabled\");\n                roomUUID = attributes.getValue(\"RoomUUID\");\n                programURI = attributes.getValue(\"ProgramURI\");\n                programMetaData = attributes.getValue(\"ProgramMetaData\");\n                playMode = attributes.getValue(\"PlayMode\");\n                volume = attributes.getValue(\"Volume\");\n                includeLinkedZones = attributes.getValue(\"IncludeLinkedZones\");\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"Alarm\".equals(qName)) {\n                int finalID = 0;\n                int finalVolume = 0;\n                boolean finalEnabled = !\"0\".equals(enabled);\n                boolean finalIncludeLinkedZones = !\"0\".equals(includeLinkedZones);\n\n                try {\n                    finalID = Integer.parseInt(id);\n                    finalVolume = Integer.parseInt(volume);\n                } catch (Exception e) {\n                    LOGGER.debug(\"Error parsing Integer\");\n                }\n\n                alarms.add(new SonosAlarm(finalID, startTime, duration, recurrence, finalEnabled, roomUUID, programURI,\n                        programMetaData, playMode, finalVolume, finalIncludeLinkedZones));\n            }\n        }\n\n        public List<SonosAlarm> getAlarms() {\n            return alarms;\n        }\n    }\n\n    private static class ZoneGroupHandler extends DefaultHandler {\n\n        private final List<SonosZoneGroup> groups = new ArrayList<>();\n        private final List<String> currentGroupPlayers = new ArrayList<>();\n        private final List<String> currentGroupPlayerZones = new ArrayList<>();\n        private String coordinator = \"\";\n        private String groupId = \"\";\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"ZoneGroup\".equals(qName) && attributes != null) {\n                groupId = attributes.getValue(\"ID\");\n                coordinator = attributes.getValue(\"Coordinator\");\n            } else if (\"ZoneGroupMember\".equals(qName) && attributes != null) {\n                currentGroupPlayers.add(attributes.getValue(\"UUID\"));\n                String zoneName = attributes.getValue(\"ZoneName\");\n                if (zoneName != null) {\n                    currentGroupPlayerZones.add(zoneName);\n                }\n                String htInfoSet = attributes.getValue(\"HTSatChanMapSet\");\n                if (htInfoSet != null) {\n                    currentGroupPlayers.addAll(getAllHomeTheaterMembers(htInfoSet));\n                }\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"ZoneGroup\".equals(qName)) {\n                groups.add(new SonosZoneGroup(groupId, coordinator, currentGroupPlayers, currentGroupPlayerZones));\n                currentGroupPlayers.clear();\n                currentGroupPlayerZones.clear();\n            }\n        }\n\n        public List<SonosZoneGroup> getGroups() {\n            return groups;\n        }\n\n        private Set<String> getAllHomeTheaterMembers(String homeTheaterDescription) {\n            Set<String> homeTheaterMembers = new HashSet<>();\n            Matcher matcher = Pattern.compile(\"(RINCON_\\\\w+)\").matcher(homeTheaterDescription);\n            while (matcher.find()) {\n                String member = matcher.group();\n                homeTheaterMembers.add(member);\n            }\n            return homeTheaterMembers;\n        }\n    }\n\n    private static class OpmlHandler extends DefaultHandler {\n\n        // <opml version=\"1\">\n        // <head>\n        // <status>200</status>\n        //\n        // </head>\n        // <body>\n        // <outline type=\"text\" text=\"Q-Music 103.3\" guide_id=\"s2398\" key=\"station\"\n        // image=\"http://radiotime-logos.s3.amazonaws.com/s87683q.png\" preset_id=\"s2398\"/>\n        // <outline type=\"text\" text=\"Bjorn Verhoeven\" guide_id=\"p257265\" seconds_remaining=\"2230\" duration=\"7200\"\n        // key=\"show\"/>\n        // <outline type=\"text\" text=\"Top 40-Pop\"/>\n        // <outline type=\"text\" text=\"37m remaining\"/>\n        // <outline type=\"object\" text=\"NowPlaying\">\n        // <nowplaying>\n        // <logo>http://radiotime-logos.s3.amazonaws.com/s87683.png</logo>\n        // <twitter_id />\n        // </nowplaying>\n        // </outline>\n        // </body>\n        // </opml>\n\n        private final List<String> textFields = new ArrayList<>();\n        private @Nullable String textField;\n        private @Nullable String type;\n        // private String logo;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"outline\".equals(qName)) {\n                type = attributes == null ? null : attributes.getValue(\"type\");\n                if (\"text\".equals(type)) {\n                    textField = attributes == null ? null : attributes.getValue(\"text\");\n                } else {\n                    textField = null;\n                }\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (\"outline\".equals(qName)) {\n                String field = textField;\n                if (field != null) {\n                    textFields.add(field);\n                }\n            }\n        }\n\n        public List<String> getTextFields() {\n            return textFields;\n        }\n    }\n\n    private static class AVTransportEventHandler extends DefaultHandler {\n\n        /*\n         * <Event xmlns=\"urn:schemas-upnp-org:metadata-1-0/AVT/\" xmlns:r=\"urn:schemas-rinconnetworks-com:metadata-1-0/\">\n         * <InstanceID val=\"0\">\n         * <TransportState val=\"PLAYING\"/>\n         * <CurrentPlayMode val=\"NORMAL\"/>\n         * <CurrentPlayMode val=\"0\"/>\n         * <NumberOfTracks val=\"29\"/>\n         * <CurrentTrack val=\"12\"/>\n         * <CurrentSection val=\"0\"/>\n         * <CurrentTrackURI val=\n         * \"x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2012%20-%20Broken%20Box.wma\"\n         * />\n         * <CurrentTrackDuration val=\"0:03:02\"/>\n         * <CurrentTrackMetaData val=\n         * \"&lt;DIDL-Lite xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot; xmlns:r=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot; xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot;&gt;&lt;item id=&quot;-1&quot; parentID=&quot;-1&quot; restricted=&quot;true&quot;&gt;&lt;res protocolInfo=&quot;x-file-cifs:*:audio/x-ms-wma:*&quot; duration=&quot;0:03:02&quot;&gt;x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2012%20-%20Broken%20Box.wma&lt;/res&gt;&lt;r:streamContent&gt;&lt;/r:streamContent&gt;&lt;dc:title&gt;Broken Box&lt;/dc:title&gt;&lt;upnp:class&gt;object.item.audioItem.musicTrack&lt;/upnp:class&gt;&lt;dc:creator&gt;Queens Of The Stone Age&lt;/dc:creator&gt;&lt;upnp:album&gt;Lullabies To Paralyze&lt;/upnp:album&gt;&lt;r:albumArtist&gt;Queens Of The Stone Age&lt;/r:albumArtist&gt;&lt;/item&gt;&lt;/DIDL-Lite&gt;\"\n         * /><r:NextTrackURI val=\n         * \"x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2013%20-%20&apos;&apos;You%20Got%20A%20Killer%20Scene%20There,%20Man...&apos;&apos;.wma\"\n         * /><r:NextTrackMetaData val=\n         * \"&lt;DIDL-Lite xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot; xmlns:r=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot; xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot;&gt;&lt;item id=&quot;-1&quot; parentID=&quot;-1&quot; restricted=&quot;true&quot;&gt;&lt;res protocolInfo=&quot;x-file-cifs:*:audio/x-ms-wma:*&quot; duration=&quot;0:04:56&quot;&gt;x-file-cifs://192.168.1.1/Storage4/Sonos%20Music/Queens%20Of%20The%20Stone%20Age/Lullabies%20To%20Paralyze/Queens%20Of%20The%20Stone%20Age%20-%20Lullabies%20To%20Paralyze%20-%2013%20-%20&amp;apos;&amp;apos;You%20Got%20A%20Killer%20Scene%20There,%20Man...&amp;apos;&amp;apos;.wma&lt;/res&gt;&lt;dc:title&gt;&amp;apos;&amp;apos;You Got A Killer Scene There, Man...&amp;apos;&amp;apos;&lt;/dc:title&gt;&lt;upnp:class&gt;object.item.audioItem.musicTrack&lt;/upnp:class&gt;&lt;dc:creator&gt;Queens Of The Stone Age&lt;/dc:creator&gt;&lt;upnp:album&gt;Lullabies To Paralyze&lt;/upnp:album&gt;&lt;r:albumArtist&gt;Queens Of The Stone Age&lt;/r:albumArtist&gt;&lt;/item&gt;&lt;/DIDL-Lite&gt;\"\n         * /><r:EnqueuedTransportURI\n         * val=\"x-rincon-playlist:RINCON_000E582126EE01400#A:ALBUMARTIST/Queens%20Of%20The%20Stone%20Age\"/><r:\n         * EnqueuedTransportURIMetaData val=\n         * \"&lt;DIDL-Lite xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot; xmlns:r=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot; xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot;&gt;&lt;item id=&quot;A:ALBUMARTIST/Queens%20Of%20The%20Stone%20Age&quot; parentID=&quot;A:ALBUMARTIST&quot; restricted=&quot;true&quot;&gt;&lt;dc:title&gt;Queens Of The Stone Age&lt;/dc:title&gt;&lt;upnp:class&gt;object.container&lt;/upnp:class&gt;&lt;desc id=&quot;cdudn&quot; nameSpace=&quot;urn:schemas-rinconnetworks-com:metadata-1-0/&quot;&gt;RINCON_AssociatedZPUDN&lt;/desc&gt;&lt;/item&gt;&lt;/DIDL-Lite&gt;\"\n         * />\n         * <PlaybackStorageMedium val=\"NETWORK\"/>\n         * <AVTransportURI val=\"x-rincon-queue:RINCON_000E5812BC1801400#0\"/>\n         * <AVTransportURIMetaData val=\"\"/>\n         * <CurrentTransportActions val=\"Play, Stop, Pause, Seek, Next, Previous\"/>\n         * <TransportStatus val=\"OK\"/>\n         * <r:SleepTimerGeneration val=\"0\"/>\n         * <r:AlarmRunning val=\"0\"/>\n         * <r:SnoozeRunning val=\"0\"/>\n         * <r:RestartPending val=\"0\"/>\n         * <TransportPlaySpeed val=\"NOT_IMPLEMENTED\"/>\n         * <CurrentMediaDuration val=\"NOT_IMPLEMENTED\"/>\n         * <RecordStorageMedium val=\"NOT_IMPLEMENTED\"/>\n         * <PossiblePlaybackStorageMedia val=\"NONE, NETWORK\"/>\n         * <PossibleRecordStorageMedia val=\"NOT_IMPLEMENTED\"/>\n         * <RecordMediumWriteStatus val=\"NOT_IMPLEMENTED\"/>\n         * <CurrentRecordQualityMode val=\"NOT_IMPLEMENTED\"/>\n         * <PossibleRecordQualityModes val=\"NOT_IMPLEMENTED\"/>\n         * <NextAVTransportURI val=\"NOT_IMPLEMENTED\"/>\n         * <NextAVTransportURIMetaData val=\"NOT_IMPLEMENTED\"/>\n         * </InstanceID>\n         * </Event>\n         */\n\n        private final Map<String, @Nullable String> changes = new HashMap<>();\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            /*\n             * The events are all of the form <qName val=\"value\"/> so we can get all\n             * the info we need from here.\n             */\n            if (localName == null) {\n                // this means that localName isn't defined in EventType, which is expected for some elements\n                LOGGER.info(\"{} is not defined in EventType. \", localName);\n            } else {\n                String val = attributes == null ? null : attributes.getValue(\"val\");\n                if (val != null) {\n                    changes.put(localName, val);\n                }\n            }\n        }\n\n        public Map<String, @Nullable String> getChanges() {\n            return changes;\n        }\n    }\n\n    private static class MetaDataHandler extends DefaultHandler {\n\n        private @Nullable CurrentElement currentElement;\n\n        private String id = \"-1\";\n        private String parentId = \"-1\";\n        private StringBuilder resource = new StringBuilder();\n        private StringBuilder streamContent = new StringBuilder();\n        private StringBuilder albumArtUri = new StringBuilder();\n        private StringBuilder title = new StringBuilder();\n        private StringBuilder upnpClass = new StringBuilder();\n        private StringBuilder creator = new StringBuilder();\n        private StringBuilder album = new StringBuilder();\n        private StringBuilder albumArtist = new StringBuilder();\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            String name = localName == null ? \"\" : localName;\n            switch (name) {\n                case \"item\":\n                    currentElement = CurrentElement.item;\n                    if (attributes != null) {\n                        id = attributes.getValue(\"id\");\n                        parentId = attributes.getValue(\"parentID\");\n                    }\n                    break;\n                case \"res\":\n                    currentElement = CurrentElement.res;\n                    break;\n                case \"streamContent\":\n                    currentElement = CurrentElement.streamContent;\n                    break;\n                case \"albumArtURI\":\n                    currentElement = CurrentElement.albumArtURI;\n                    break;\n                case \"title\":\n                    currentElement = CurrentElement.title;\n                    break;\n                case \"class\":\n                    currentElement = CurrentElement.upnpClass;\n                    break;\n                case \"creator\":\n                    currentElement = CurrentElement.creator;\n                    break;\n                case \"album\":\n                    currentElement = CurrentElement.album;\n                    break;\n                case \"albumArtist\":\n                    currentElement = CurrentElement.albumArtist;\n                    break;\n                default:\n                    // unknown element\n                    currentElement = null;\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            CurrentElement elt = currentElement;\n            if (elt == null) {\n                return;\n            }\n            switch (elt) {\n                case item:\n                    break;\n                case res:\n                    resource.append(ch, start, length);\n                    break;\n                case streamContent:\n                    streamContent.append(ch, start, length);\n                    break;\n                case albumArtURI:\n                    albumArtUri.append(ch, start, length);\n                    break;\n                case title:\n                    title.append(ch, start, length);\n                    break;\n                case upnpClass:\n                    upnpClass.append(ch, start, length);\n                    break;\n                case creator:\n                    creator.append(ch, start, length);\n                    break;\n                case album:\n                    album.append(ch, start, length);\n                    break;\n                case albumArtist:\n                    albumArtist.append(ch, start, length);\n                    break;\n                case desc:\n                    break;\n            }\n        }\n\n        public SonosMetaData getMetaData() {\n            return new SonosMetaData(id, parentId, resource.toString(), streamContent.toString(),\n                    albumArtUri.toString(), title.toString(), upnpClass.toString(), creator.toString(),\n                    album.toString(), albumArtist.toString());\n        }\n    }\n\n    private static class RenderingControlEventHandler extends DefaultHandler {\n\n        private final Map<String, @Nullable String> changes = new HashMap<>();\n\n        private boolean getPresetName = false;\n        private @Nullable String presetName;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (qName == null) {\n                return;\n            }\n            String channel;\n            String val;\n            switch (qName) {\n                case \"Volume\":\n                case \"Mute\":\n                case \"Loudness\":\n                    channel = attributes == null ? null : attributes.getValue(\"channel\");\n                    val = attributes == null ? null : attributes.getValue(\"val\");\n                    if (channel != null && val != null) {\n                        changes.put(qName + channel, val);\n                    }\n                    break;\n                case \"Bass\":\n                case \"Treble\":\n                case \"OutputFixed\":\n                    val = attributes == null ? null : attributes.getValue(\"val\");\n                    if (val != null) {\n                        changes.put(qName, val);\n                    }\n                    break;\n                case \"PresetNameList\":\n                    getPresetName = true;\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            if (getPresetName) {\n                presetName = new String(ch, start, length);\n            }\n        }\n\n        @Override\n        public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName)\n                throws SAXException {\n            if (getPresetName) {\n                getPresetName = false;\n                String preset = presetName;\n                if (qName != null && preset != null) {\n                    changes.put(qName, preset);\n                }\n            }\n        }\n\n        public Map<String, @Nullable String> getChanges() {\n            return changes;\n        }\n    }\n\n    private static class MusicServiceHandler extends DefaultHandler {\n\n        private final List<SonosMusicService> services = new ArrayList<>();\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            // All services are of the form <services Id=\"value\" Name=\"value\">...</Service>\n            if (\"Service\".equals(qName) && attributes != null && attributes.getValue(\"Id\") != null\n                    && attributes.getValue(\"Name\") != null) {\n                services.add(new SonosMusicService(attributes.getValue(\"Id\"), attributes.getValue(\"Name\")));\n            }\n        }\n\n        public List<SonosMusicService> getServices() {\n            return services;\n        }\n    }\n\n    public static @Nullable String getRoomName(String descriptorXML) {\n        RoomNameHandler roomNameHandler = new RoomNameHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(roomNameHandler);\n            URL url = new URL(descriptorXML);\n            reader.parse(new InputSource(url.openStream()));\n        } catch (IOException | SAXException e) {\n            LOGGER.error(\"Could not parse Sonos room name from string '{}'\", descriptorXML);\n        }\n        return roomNameHandler.getRoomName();\n    }\n\n    private static class RoomNameHandler extends DefaultHandler {\n\n        private @Nullable String roomName;\n        private boolean roomNameTag;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"roomName\".equalsIgnoreCase(localName)) {\n                roomNameTag = true;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            if (roomNameTag) {\n                roomName = new String(ch, start, length);\n                roomNameTag = false;\n            }\n        }\n\n        public @Nullable String getRoomName() {\n            return roomName;\n        }\n    }\n\n    public static @Nullable String parseModelDescription(URL descriptorURL) {\n        ModelNameHandler modelNameHandler = new ModelNameHandler();\n        try {\n            XMLReader reader = XMLReaderFactory.createXMLReader();\n            reader.setContentHandler(modelNameHandler);\n            URL url = new URL(descriptorURL.toString());\n            reader.parse(new InputSource(url.openStream()));\n        } catch (IOException | SAXException e) {\n            LOGGER.error(\"Could not parse Sonos model name from string '{}'\", descriptorURL.toString());\n        }\n        return modelNameHandler.getModelName();\n    }\n\n    private static class ModelNameHandler extends DefaultHandler {\n\n        private @Nullable String modelName;\n        private boolean modelNameTag;\n\n        @Override\n        public void startElement(@Nullable String uri, @Nullable String localName, @Nullable String qName,\n                @Nullable Attributes attributes) throws SAXException {\n            if (\"modelName\".equalsIgnoreCase(localName)) {\n                modelNameTag = true;\n            }\n        }\n\n        @Override\n        public void characters(char @Nullable [] ch, int start, int length) throws SAXException {\n            if (modelNameTag) {\n                modelName = new String(ch, start, length);\n                modelNameTag = false;\n            }\n        }\n\n        public @Nullable String getModelName() {\n            return modelName;\n        }\n    }\n\n    /**\n     * The model name provided by upnp is formated like in the example form \"Sonos PLAY:1\" or \"Sonos PLAYBAR\"\n     *\n     * @param sonosModelName Sonos model name provided via upnp device\n     * @return the extracted players model name without column (:) character used for ThingType creation\n     */\n    public static String extractModelName(String sonosModelName) {\n        String ret = sonosModelName;\n        Matcher matcher = Pattern.compile(\"\\\\s(.*)\").matcher(ret);\n        if (matcher.find()) {\n            ret = matcher.group(1);\n        }\n        if (ret.contains(\":\")) {\n            ret = ret.replace(\":\", \"\");\n        }\n        return ret;\n    }\n\n    public static String compileMetadataString(SonosEntry entry) {\n        /**\n         * If the entry contains resource meta data we will override this with\n         * that data.\n         */\n        String id = entry.getId();\n        String parentId = entry.getParentId();\n        String title = entry.getTitle();\n        String upnpClass = entry.getUpnpClass();\n\n        /**\n         * By default 'RINCON_AssociatedZPUDN' is used for most operations,\n         * however when playing a favorite entry that is associated withh a\n         * subscription like pandora we need to use the desc string asscoiated\n         * with that item.\n         */\n        String desc = entry.getDesc();\n        if (desc == null) {\n            desc = \"RINCON_AssociatedZPUDN\";\n        }\n\n        /**\n         * If resource meta data exists, use it over the parent data\n         */\n        SonosResourceMetaData resourceMetaData = entry.getResourceMetaData();\n        if (resourceMetaData != null) {\n            id = resourceMetaData.getId();\n            parentId = resourceMetaData.getParentId();\n            title = resourceMetaData.getTitle();\n            desc = resourceMetaData.getDesc();\n            upnpClass = resourceMetaData.getUpnpClass();\n        }\n\n        title = StringEscapeUtils.escapeXml(title);\n\n        String metadata = METADATA_FORMAT.format(new Object[] { id, parentId, title, upnpClass, desc });\n\n        return metadata;\n    }\n}\n", "target": 0}
{"idx": 962, "func": "package org.bouncycastle.jcajce.provider.asymmetric.dh;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\n\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DHParameterSpec;\nimport javax.crypto.spec.DHPublicKeySpec;\n\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.pkcs.DHParameter;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.DHDomainParameters;\nimport org.bouncycastle.asn1.x9.DomainParameters;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.crypto.params.DHPublicKeyParameters;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.KeyUtil;\n\npublic class BCDHPublicKey\n    implements DHPublicKey\n{\n    static final long serialVersionUID = -216691575254424324L;\n    \n    private BigInteger              y;\n\n    private transient DHParameterSpec         dhSpec;\n    private transient SubjectPublicKeyInfo    info;\n    \n    BCDHPublicKey(\n        DHPublicKeySpec spec)\n    {\n        this.y = spec.getY();\n        this.dhSpec = new DHParameterSpec(spec.getP(), spec.getG());\n    }\n\n    BCDHPublicKey(\n        DHPublicKey key)\n    {\n        this.y = key.getY();\n        this.dhSpec = key.getParams();\n    }\n\n    BCDHPublicKey(\n        DHPublicKeyParameters params)\n    {\n        this.y = params.getY();\n        this.dhSpec = new DHParameterSpec(params.getParameters().getP(), params.getParameters().getG(), params.getParameters().getL());\n    }\n\n    BCDHPublicKey(\n        BigInteger y,\n        DHParameterSpec dhSpec)\n    {\n        this.y = y;\n        this.dhSpec = dhSpec;\n    }\n\n    public BCDHPublicKey(\n        SubjectPublicKeyInfo info)\n    {\n        this.info = info;\n\n        ASN1Integer              derY;\n        try\n        {\n            derY = (ASN1Integer)info.parsePublicKey();\n        }\n        catch (IOException e)\n        {\n            throw new IllegalArgumentException(\"invalid info structure in DH public key\");\n        }\n\n        this.y = derY.getValue();\n\n        ASN1Sequence seq = ASN1Sequence.getInstance(info.getAlgorithm().getParameters());\n        ASN1ObjectIdentifier id = info.getAlgorithm().getAlgorithm();\n\n        // we need the PKCS check to handle older keys marked with the X9 oid.\n        if (id.equals(PKCSObjectIdentifiers.dhKeyAgreement) || isPKCSParam(seq))\n        {\n            DHParameter             params = DHParameter.getInstance(seq);\n\n            if (params.getL() != null)\n            {\n                this.dhSpec = new DHParameterSpec(params.getP(), params.getG(), params.getL().intValue());\n            }\n            else\n            {\n                this.dhSpec = new DHParameterSpec(params.getP(), params.getG());\n            }\n        }\n        else if (id.equals(X9ObjectIdentifiers.dhpublicnumber))\n        {\n            DomainParameters params = DomainParameters.getInstance(seq);\n\n            this.dhSpec = new DHParameterSpec(params.getP(), params.getG());\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"unknown algorithm type: \" + id);\n        }\n    }\n\n    public String getAlgorithm()\n    {\n        return \"DH\";\n    }\n\n    public String getFormat()\n    {\n        return \"X.509\";\n    }\n\n    public byte[] getEncoded()\n    {\n        if (info != null)\n        {\n            return KeyUtil.getEncodedSubjectPublicKeyInfo(info);\n        }\n\n        return KeyUtil.getEncodedSubjectPublicKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.dhKeyAgreement, new DHParameter(dhSpec.getP(), dhSpec.getG(), dhSpec.getL()).toASN1Primitive()), new ASN1Integer(y));\n    }\n\n    public DHParameterSpec getParams()\n    {\n        return dhSpec;\n    }\n\n    public BigInteger getY()\n    {\n        return y;\n    }\n\n    private boolean isPKCSParam(ASN1Sequence seq)\n    {\n        if (seq.size() == 2)\n        {\n            return true;\n        }\n        \n        if (seq.size() > 3)\n        {\n            return false;\n        }\n\n        ASN1Integer l = ASN1Integer.getInstance(seq.getObjectAt(2));\n        ASN1Integer p = ASN1Integer.getInstance(seq.getObjectAt(0));\n\n        if (l.getValue().compareTo(BigInteger.valueOf(p.getValue().bitLength())) > 0)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    public int hashCode()\n    {\n        return this.getY().hashCode() ^ this.getParams().getG().hashCode()\n                ^ this.getParams().getP().hashCode() ^ this.getParams().getL();\n    }\n\n    public boolean equals(\n        Object o)\n    {\n        if (!(o instanceof DHPublicKey))\n        {\n            return false;\n        }\n\n        DHPublicKey other = (DHPublicKey)o;\n\n        return this.getY().equals(other.getY())\n            && this.getParams().getG().equals(other.getParams().getG())\n            && this.getParams().getP().equals(other.getParams().getP())\n            && this.getParams().getL() == other.getParams().getL();\n    }\n\n    private void readObject(\n        ObjectInputStream   in)\n        throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n\n        this.dhSpec = new DHParameterSpec((BigInteger)in.readObject(), (BigInteger)in.readObject(), in.readInt());\n        this.info = null;\n    }\n\n    private void writeObject(\n        ObjectOutputStream  out)\n        throws IOException\n    {\n        out.defaultWriteObject();\n\n        out.writeObject(dhSpec.getP());\n        out.writeObject(dhSpec.getG());\n        out.writeInt(dhSpec.getL());\n    }\n}\n", "target": 1}
{"idx": 963, "func": "package org.bouncycastle.pqc.crypto.test;\n\nimport java.io.IOException;\nimport java.security.SecureRandom;\n\nimport junit.framework.TestCase;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.pqc.crypto.xmss.XMSS;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSMT;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Base64;\n\n/**\n * Test cases for XMSSMTPrivateKey class.\n */\npublic class XMSSMTPrivateKeyTest\n    extends TestCase\n{\n    public void testPrivateKeySerialisation()\n        throws Exception\n    {\n        String stream = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArO0ABXNyACJzdW4ucm1pLnNlcnZlci5BY3RpdmF0aW9uR3JvdXBJbXBsT+r9SAwuMqcCAARaAA1ncm91cEluYWN0aXZlTAAGYWN0aXZldAAVTGphdmEvdXRpbC9IYXNodGFibGU7TAAHZ3JvdXBJRHQAJ0xqYXZhL3JtaS9hY3RpdmF0aW9uL0FjdGl2YXRpb25Hcm91cElEO0wACWxvY2tlZElEc3QAEExqYXZhL3V0aWwvTGlzdDt4cgAjamF2YS5ybWkuYWN0aXZhdGlvbi5BY3RpdmF0aW9uR3JvdXCVLvKwBSnVVAIAA0oAC2luY2FybmF0aW9uTAAHZ3JvdXBJRHEAfgACTAAHbW9uaXRvcnQAJ0xqYXZhL3JtaS9hY3RpdmF0aW9uL0FjdGl2YXRpb25Nb25pdG9yO3hyACNqYXZhLnJtaS5zZXJ2ZXIuVW5pY2FzdFJlbW90ZU9iamVjdEUJEhX14n4xAgADSQAEcG9ydEwAA2NzZnQAKExqYXZhL3JtaS9zZXJ2ZXIvUk1JQ2xpZW50U29ja2V0RmFjdG9yeTtMAANzc2Z0AChMamF2YS9ybWkvc2VydmVyL1JNSVNlcnZlclNvY2tldEZhY3Rvcnk7eHIAHGphdmEucm1pLnNlcnZlci5SZW1vdGVTZXJ2ZXLHGQcSaPM5+wIAAHhyABxqYXZhLnJtaS5zZXJ2ZXIuUmVtb3RlT2JqZWN002G0kQxhMx4DAAB4cHcSABBVbmljYXN0U2VydmVyUmVmeAAAFbNwcAAAAAAAAAAAcHAAcHBw\";\n\n        XMSSParameters params = new XMSSParameters(10, new SHA256Digest());\n\n        byte[] output = Base64.decode(new String(stream).getBytes(\"UTF-8\"));\n\n\n        //Simple Exploit\n\n        try\n        {\n            new XMSSPrivateKeyParameters.Builder(params).withPrivateKey(output, params).build();\n        }\n        catch (IllegalArgumentException e)\n        {\n            assertTrue(e.getCause() instanceof IOException);\n        }\n\n        //Same Exploit other method\n\n        XMSS xmss2 = new XMSS(params, new SecureRandom());\n\n        xmss2.generateKeys();\n\n        byte[] publicKey = xmss2.exportPublicKey();\n\n        try\n        {\n            xmss2.importState(output, publicKey);\n        }\n        catch (IllegalArgumentException e)\n        {\n            assertTrue(e.getCause() instanceof IOException);\n        }\n    }\n\n    public void testPrivateKeyParsingSHA256()\n        throws Exception\n    {\n        XMSSMTParameters params = new XMSSMTParameters(20, 10, new SHA256Digest());\n        XMSSMT mt = new XMSSMT(params, new SecureRandom());\n        mt.generateKeys();\n        byte[] privateKey = mt.exportPrivateKey();\n        byte[] publicKey = mt.exportPublicKey();\n\n        mt.importState(privateKey, publicKey);\n\n        assertTrue(Arrays.areEqual(privateKey, mt.exportPrivateKey()));\n    }\n}\n", "target": 0}
{"idx": 964, "func": "package hudson.diagnosis;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.xml.sax.SAXException;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\nimport com.gargoylesoftware.htmlunit.html.HtmlForm;\nimport com.gargoylesoftware.htmlunit.ElementNotFoundException;\n\nimport java.io.IOException;\n\n/**\n * @author Kohsuke Kawaguchi\n */\npublic class HudsonHomeDiskUsageMonitorTest {\n\n    @Rule\n    public JenkinsRule j = new JenkinsRule();\n\n    @Test\n    public void flow() throws Exception {\n        // manually activate this\n        HudsonHomeDiskUsageMonitor mon = HudsonHomeDiskUsageMonitor.get();\n        mon.activated = true;\n\n        // clicking yes should take us to somewhere\n        j.submit(getForm(mon), \"yes\");\n        assertTrue(mon.isEnabled());\n\n        // now dismiss\n        // submit(getForm(mon),\"no\"); TODO: figure out why this test is fragile\n        mon.doAct(\"no\");\n        assertFalse(mon.isEnabled());\n\n        // and make sure it's gone\n        try {\n            fail(getForm(mon)+\" shouldn't be there\");\n        } catch (ElementNotFoundException e) {\n            // as expected\n        }\n    }\n\n    /**\n     * Gets the warning form.\n     */\n    private HtmlForm getForm(HudsonHomeDiskUsageMonitor mon) throws IOException, SAXException {\n        HtmlPage p = j.createWebClient().goTo(\"manage\");\n        return p.getFormByName(mon.id);\n    }\n}\n", "target": 1}
{"idx": 965, "func": "package jenkins.security.s2m;\n\nimport hudson.Extension;\nimport hudson.model.AdministrativeMonitor;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.QueryParameter;\n\nimport javax.inject.Inject;\nimport java.io.IOException;\n\n/**\n * If {@link AdminWhitelistRule#masterKillSwitch} is on, warn the user.\n *\n * @author Kohsuke Kawaguchi\n * @since 1.THU\n */\n@Extension\npublic class MasterKillSwitchWarning extends AdministrativeMonitor {\n    @Inject\n    AdminWhitelistRule rule;\n\n    @Inject\n    MasterKillSwitchConfiguration config;\n\n    @Override\n    public boolean isActivated() {\n        return rule.getMasterKillSwitch() && config.isRelevant();\n    }\n\n    public HttpResponse doAct(@QueryParameter String dismiss) throws IOException {\n        if(dismiss!=null) {\n            disable(true);\n            return HttpResponses.redirectViaContextPath(\"/manage\");\n        } else {\n            return HttpResponses.redirectViaContextPath(\"configureSecurity\");\n        }\n    }\n}\n", "target": 1}
{"idx": 966, "func": "/*\n * Copyright 2004-2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.web.util;\n\nimport static org.junit.Assert.*;\n\nimport java.io.UnsupportedEncodingException;\n\nimport org.junit.Test;\n\n/**\n * Test fixture for {@link JavaScriptUtils}.\n *\n * @author Rossen Stoyanchev\n */\npublic class JavaScriptUtilsTests {\n\n\t@Test\n\tpublic void escape() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('\"');\n\t\tsb.append(\"'\");\n\t\tsb.append(\"\\\\\");\n\t\tsb.append(\"/\");\n\t\tsb.append(\"\\t\");\n\t\tsb.append(\"\\n\");\n\t\tsb.append(\"\\r\");\n\t\tsb.append(\"\\f\");\n\t\tsb.append(\"\\b\");\n\t\tsb.append(\"\\013\");\n\t\tassertEquals(\"\\\\\\\"\\\\'\\\\\\\\\\\\/\\\\t\\\\n\\\\n\\\\f\\\\b\\\\v\", JavaScriptUtils.javaScriptEscape(sb.toString()));\n\t}\n\n\t// SPR-9983\n\n\t@Test\n\tpublic void escapePsLsLineTerminators() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append('\\u2028');\n\t\tsb.append('\\u2029');\n\t\tString result = JavaScriptUtils.javaScriptEscape(sb.toString());\n\n\t\tassertEquals(\"\\\\u2028\\\\u2029\", result);\n\t}\n\n\t// SPR-9983\n\n\t@Test\n\tpublic void escapeLessThanGreaterThanSigns() throws UnsupportedEncodingException {\n\t\tassertEquals(\"\\\\u003C\\\\u003E\", JavaScriptUtils.javaScriptEscape(\"<>\"));\n\t}\n\n}\n", "target": 0}
{"idx": 967, "func": "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.dlinksmarthome.internal;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Iterator;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.soap.MessageFactory;\nimport javax.xml.soap.MimeHeader;\nimport javax.xml.soap.MimeHeaders;\nimport javax.xml.soap.SOAPBody;\nimport javax.xml.soap.SOAPElement;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.soap.SOAPMessage;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.eclipse.jetty.client.HttpClient;\nimport org.eclipse.jetty.client.api.ContentResponse;\nimport org.eclipse.jetty.client.api.Request;\nimport org.eclipse.jetty.client.util.BytesContentProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link DLinkHNAPCommunication} is responsible for communicating with D-Link\n * Smart Home devices using the HNAP interface.\n *\n * This abstract class handles login and authentication which is common between devices.\n *\n * Reverse engineered from Login.html and soapclient.js retrieved from the device.\n *\n * @author Mike Major - Initial contribution\n */\npublic abstract class DLinkHNAPCommunication {\n\n    // SOAP actions\n    private static final String LOGIN_ACTION = \"\\\"http://purenetworks.com/HNAP1/LOGIN\\\"\";\n\n    // Strings used more than once\n    private static final String LOGIN = \"LOGIN\";\n    private static final String ACTION = \"Action\";\n    private static final String USERNAME = \"Username\";\n    private static final String LOGINPASSWORD = \"LoginPassword\";\n    private static final String CAPTCHA = \"Captcha\";\n    private static final String ADMIN = \"Admin\";\n    private static final String LOGINRESULT = \"LOGINResult\";\n    private static final String COOKIE = \"Cookie\";\n\n    /**\n     * HNAP XMLNS\n     */\n    protected static final String HNAP_XMLNS = \"http://purenetworks.com/HNAP1\";\n    /**\n     * The SOAP action HTML header\n     */\n    protected static final String SOAPACTION = \"SOAPAction\";\n    /**\n     * OK represents a successful action\n     */\n    protected static final String OK = \"OK\";\n\n    /**\n     * Use to log connection issues\n     */\n    private final Logger logger = LoggerFactory.getLogger(DLinkHNAPCommunication.class);\n\n    private URI uri;\n    private final HttpClient httpClient;\n    private final String pin;\n    private String privateKey;\n\n    private DocumentBuilder parser;\n    private SOAPMessage requestAction;\n    private SOAPMessage loginAction;\n\n    private HNAPStatus status = HNAPStatus.INITIALISED;\n\n    /**\n     * Indicates the status of the HNAP interface\n     *\n     */\n    protected enum HNAPStatus {\n        /**\n         * Ready to start communication with device\n         */\n        INITIALISED,\n        /**\n         * Successfully logged in to device\n         */\n        LOGGED_IN,\n        /**\n         * Problem communicating with device\n         */\n        COMMUNICATION_ERROR,\n        /**\n         * Internal error\n         */\n        INTERNAL_ERROR,\n        /**\n         * Error due to unsupported firmware\n         */\n        UNSUPPORTED_FIRMWARE,\n        /**\n         * Error due to invalid pin code\n         */\n        INVALID_PIN\n    }\n\n    /**\n     * Use {@link #getHNAPStatus()} to determine the status of the HNAP connection\n     * after construction.\n     *\n     * @param ipAddress\n     * @param pin\n     */\n    public DLinkHNAPCommunication(final String ipAddress, final String pin) {\n        this.pin = pin;\n\n        httpClient = new HttpClient();\n\n        try {\n            uri = new URI(\"http://\" + ipAddress + \"/HNAP1\");\n            httpClient.start();\n\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            dbf.setXIncludeAware(false);\n            dbf.setExpandEntityReferences(false);\n            parser = dbf.newDocumentBuilder();\n\n            final MessageFactory messageFactory = MessageFactory.newInstance();\n            requestAction = messageFactory.createMessage();\n            loginAction = messageFactory.createMessage();\n\n            buildRequestAction();\n            buildLoginAction();\n        } catch (final SOAPException e) {\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        } catch (final URISyntaxException e) {\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        } catch (final ParserConfigurationException e) {\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        } catch (final Exception e) {\n            // Thrown by httpClient.start()\n            logger.debug(\"DLinkHNAPCommunication - Internal error\", e);\n            status = HNAPStatus.INTERNAL_ERROR;\n        }\n    }\n\n    /**\n     * Stop communicating with the device\n     */\n    public void dispose() {\n        try {\n            httpClient.stop();\n        } catch (final Exception e) {\n            // Ignored\n        }\n    }\n\n    /**\n     * This is the first SOAP message used in the login process and is used to retrieve\n     * the cookie, challenge and public key used for authentication.\n     *\n     * @throws SOAPException\n     */\n    private void buildRequestAction() throws SOAPException {\n        requestAction.getSOAPHeader().detachNode();\n        final SOAPBody soapBody = requestAction.getSOAPBody();\n        final SOAPElement soapBodyElem = soapBody.addChildElement(LOGIN, \"\", HNAP_XMLNS);\n        soapBodyElem.addChildElement(ACTION).addTextNode(\"request\");\n        soapBodyElem.addChildElement(USERNAME).addTextNode(ADMIN);\n        soapBodyElem.addChildElement(LOGINPASSWORD);\n        soapBodyElem.addChildElement(CAPTCHA);\n\n        final MimeHeaders headers = requestAction.getMimeHeaders();\n        headers.addHeader(SOAPACTION, LOGIN_ACTION);\n\n        requestAction.saveChanges();\n    }\n\n    /**\n     * This is the second SOAP message used in the login process and uses a password derived\n     * from the challenge, public key and the device's pin code.\n     *\n     * @throws SOAPException\n     */\n    private void buildLoginAction() throws SOAPException {\n        loginAction.getSOAPHeader().detachNode();\n        final SOAPBody soapBody = loginAction.getSOAPBody();\n        final SOAPElement soapBodyElem = soapBody.addChildElement(LOGIN, \"\", HNAP_XMLNS);\n        soapBodyElem.addChildElement(ACTION).addTextNode(\"login\");\n        soapBodyElem.addChildElement(USERNAME).addTextNode(ADMIN);\n        soapBodyElem.addChildElement(LOGINPASSWORD);\n        soapBodyElem.addChildElement(CAPTCHA);\n\n        final MimeHeaders headers = loginAction.getMimeHeaders();\n        headers.addHeader(SOAPACTION, LOGIN_ACTION);\n    }\n\n    /**\n     * Sets the password for the second login message based on the data received from the\n     * first login message. Also sets the private key used to generate the authentication header.\n     *\n     * @param challenge\n     * @param cookie\n     * @param publicKey\n     * @throws SOAPException\n     * @throws InvalidKeyException\n     * @throws NoSuchAlgorithmException\n     */\n    private void setAuthenticationData(final String challenge, final String cookie, final String publicKey)\n            throws SOAPException, InvalidKeyException, NoSuchAlgorithmException {\n        final MimeHeaders loginHeaders = loginAction.getMimeHeaders();\n        loginHeaders.setHeader(COOKIE, \"uid=\" + cookie);\n\n        privateKey = hash(challenge, publicKey + pin);\n\n        final String password = hash(challenge, privateKey);\n\n        loginAction.getSOAPBody().getElementsByTagName(LOGINPASSWORD).item(0).setTextContent(password);\n        loginAction.saveChanges();\n    }\n\n    /**\n     * Used to hash the authentication data such as the login password and the authentication header\n     * for the detection message.\n     *\n     * @param data\n     * @param key\n     * @return The hashed data\n     * @throws NoSuchAlgorithmException\n     * @throws InvalidKeyException\n     */\n    private String hash(final String data, final String key) throws NoSuchAlgorithmException, InvalidKeyException {\n        final Mac mac = Mac.getInstance(\"HMACMD5\");\n        final SecretKeySpec sKey = new SecretKeySpec(key.getBytes(), \"ASCII\");\n\n        mac.init(sKey);\n        final byte[] bytes = mac.doFinal(data.getBytes());\n\n        final StringBuilder hashBuf = new StringBuilder();\n        for (int i = 0; i < bytes.length; i++) {\n            final String hex = Integer.toHexString(0xFF & bytes[i]).toUpperCase();\n            if (hex.length() == 1) {\n                hashBuf.append('0');\n            }\n            hashBuf.append(hex);\n        }\n\n        return hashBuf.toString();\n    }\n\n    /**\n     * Output unexpected responses to the debug log and sets the FIRMWARE error.\n     *\n     * @param message\n     * @param soapResponse\n     */\n    private void unexpectedResult(final String message, final Document soapResponse) {\n        logUnexpectedResult(message, soapResponse);\n\n        // Best guess when receiving unexpected responses\n        status = HNAPStatus.UNSUPPORTED_FIRMWARE;\n    }\n\n    /**\n     * Get the status of the HNAP interface\n     *\n     * @return the HNAP status\n     */\n    protected HNAPStatus getHNAPStatus() {\n        return status;\n    }\n\n    /**\n     * Sends the two login messages and stores the private key used to generate the\n     * authentication header required for actions.\n     *\n     * Use {@link #getHNAPStatus()} to determine the status of the HNAP connection\n     * after calling this method.\n     *\n     * @param timeout - Connection timeout in milliseconds\n     */\n    protected void login(final int timeout) {\n        if (status != HNAPStatus.INTERNAL_ERROR) {\n            try {\n                Document soapResponse = sendReceive(requestAction, timeout);\n\n                Node result = soapResponse.getElementsByTagName(LOGINRESULT).item(0);\n\n                if (result != null && OK.equals(result.getTextContent())) {\n                    final Node challengeNode = soapResponse.getElementsByTagName(\"Challenge\").item(0);\n                    final Node cookieNode = soapResponse.getElementsByTagName(COOKIE).item(0);\n                    final Node publicKeyNode = soapResponse.getElementsByTagName(\"PublicKey\").item(0);\n\n                    if (challengeNode != null && cookieNode != null && publicKeyNode != null) {\n                        setAuthenticationData(challengeNode.getTextContent(), cookieNode.getTextContent(),\n                                publicKeyNode.getTextContent());\n\n                        soapResponse = sendReceive(loginAction, timeout);\n                        result = soapResponse.getElementsByTagName(LOGINRESULT).item(0);\n\n                        if (result != null) {\n                            if (\"success\".equals(result.getTextContent())) {\n                                status = HNAPStatus.LOGGED_IN;\n                            } else {\n                                logger.debug(\"login - Check pin is correct\");\n                                // Assume pin code problem rather than a firmware change\n                                status = HNAPStatus.INVALID_PIN;\n                            }\n                        } else {\n                            unexpectedResult(\"login - Unexpected login response\", soapResponse);\n                        }\n                    } else {\n                        unexpectedResult(\"login - Unexpected request response\", soapResponse);\n                    }\n                } else {\n                    unexpectedResult(\"login - Unexpected request response\", soapResponse);\n                }\n            } catch (final InvalidKeyException e) {\n                logger.debug(\"login - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final NoSuchAlgorithmException e) {\n                logger.debug(\"login - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final Exception e) {\n                // Assume there has been some problem trying to send one of the messages\n                if (status != HNAPStatus.COMMUNICATION_ERROR) {\n                    logger.debug(\"login - Communication error\", e);\n                    status = HNAPStatus.COMMUNICATION_ERROR;\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets the authentication headers for the action message. This should only be called\n     * after a successful login.\n     *\n     * Use {@link #getHNAPStatus()} to determine the status of the HNAP connection\n     * after calling this method.\n     *\n     * @param action - SOAP Action to add headers\n     */\n    protected void setAuthenticationHeaders(final SOAPMessage action) {\n        if (status == HNAPStatus.LOGGED_IN) {\n            try {\n                final MimeHeaders loginHeaders = loginAction.getMimeHeaders();\n                final MimeHeaders actionHeaders = action.getMimeHeaders();\n\n                actionHeaders.setHeader(COOKIE, loginHeaders.getHeader(COOKIE)[0]);\n\n                final String timeStamp = String.valueOf(System.currentTimeMillis() / 1000);\n                final String auth = hash(timeStamp + actionHeaders.getHeader(SOAPACTION)[0], privateKey) + \" \"\n                        + timeStamp;\n                actionHeaders.setHeader(\"HNAP_AUTH\", auth);\n\n                action.saveChanges();\n            } catch (final InvalidKeyException e) {\n                logger.debug(\"setAuthenticationHeaders - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final NoSuchAlgorithmException e) {\n                logger.debug(\"setAuthenticationHeaders - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            } catch (final SOAPException e) {\n                // No communication happening so assume system error\n                logger.debug(\"setAuthenticationHeaders - Internal error\", e);\n                status = HNAPStatus.INTERNAL_ERROR;\n            }\n        }\n    }\n\n    /**\n     * Send the SOAP message using Jetty HTTP client. Jetty is used in preference to\n     * HttpURLConnection which can result in the HNAP interface becoming unresponsive.\n     *\n     * @param action - SOAP Action to send\n     * @param timeout - Connection timeout in milliseconds\n     * @return The result\n     * @throws IOException\n     * @throws SOAPException\n     * @throws SAXException\n     * @throws ExecutionException\n     * @throws TimeoutException\n     * @throws InterruptedException\n     */\n    protected Document sendReceive(final SOAPMessage action, final int timeout) throws IOException, SOAPException,\n            SAXException, InterruptedException, TimeoutException, ExecutionException {\n        Document result;\n\n        final Request request = httpClient.POST(uri);\n        request.timeout(timeout, TimeUnit.MILLISECONDS);\n\n        final Iterator<?> it = action.getMimeHeaders().getAllHeaders();\n        while (it.hasNext()) {\n            final MimeHeader header = (MimeHeader) it.next();\n            request.header(header.getName(), header.getValue());\n        }\n\n        try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n            action.writeTo(os);\n            request.content(new BytesContentProvider(os.toByteArray()));\n            final ContentResponse response = request.send();\n            try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\n                result = parser.parse(is);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Output unexpected responses to the debug log.\n     *\n     * @param message\n     * @param soapResponse\n     */\n    protected void logUnexpectedResult(final String message, final Document soapResponse) {\n        // No point formatting for output if debug logging is not enabled\n        if (logger.isDebugEnabled()) {\n            try {\n                final TransformerFactory transFactory = TransformerFactory.newInstance();\n                final Transformer transformer = transFactory.newTransformer();\n                final StringWriter buffer = new StringWriter();\n                transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n                transformer.transform(new DOMSource(soapResponse), new StreamResult(buffer));\n                logger.debug(\"{} : {}\", message, buffer);\n            } catch (final TransformerException e) {\n                logger.debug(\"{}\", message);\n            }\n        }\n    }\n}\n", "target": 0}
{"idx": 968, "func": "/*****************************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one                *\n * or more contributor license agreements.  See the NOTICE file              *\n * distributed with this work for additional information                     *\n * regarding copyright ownership.  The ASF licenses this file                *\n * to you under the Apache License, Version 2.0 (the                         *\n * \"License\"); you may not use this file except in compliance                *\n * with the License.  You may obtain a copy of the License at                *\n *                                                                           *\n *     http://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                           *\n * Unless required by applicable law or agreed to in writing,                *\n * software distributed under the License is distributed on an               *\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY                    *\n * KIND, either express or implied.  See the License for the                 *\n * specific language governing permissions and limitations                   *\n * under the License.                                                        *\n *                                                                           *\n *                                                                           *\n * This file is part of the BeanShell Java Scripting distribution.           *\n * Documentation and updates may be found at http://www.beanshell.org/       *\n * Patrick Niemeyer (pat@pat.net)                                            *\n * Author of Learning Java, O'Reilly & Associates                            *\n *                                                                           *\n *****************************************************************************/\n\n\n\npackage bsh;\n\nimport java.lang.reflect.*;\nimport java.lang.reflect.InvocationHandler;\nimport java.io.*;\nimport java.util.Hashtable;\n\n/**\n\tXThis is a dynamically loaded extension which extends This.java and adds \n\tsupport for the generalized interface proxy mechanism introduced in \n\tJDK1.3.  XThis allows bsh scripted objects to implement arbitrary \n\tinterfaces (be arbitrary event listener types).\n\n\tNote: This module relies on new features of JDK1.3 and will not compile\n\twith JDK1.2 or lower.  For those environments simply do not compile this\n\tclass.\n\n\tEventually XThis should become simply This, but for backward compatibility\n\twe will maintain This without requiring support for the proxy mechanism.\n\n\tXThis stands for \"eXtended This\" (I had to call it something).\n\t\n\t@see JThis\t See also JThis with explicit JFC support for compatibility.\n\t@see This\t\n*/\npublic class XThis extends This \n\t{\n\t/**\n\t\tA cache of proxy interface handlers.\n\t\tCurrently just one per interface.\n\t*/\n\tHashtable interfaces;\n\n\tInvocationHandler invocationHandler = new Handler();\n\n\tpublic XThis( NameSpace namespace, Interpreter declaringInterp ) { \n\t\tsuper( namespace, declaringInterp ); \n\t}\n\n\tpublic String toString() {\n\t\treturn \"'this' reference (XThis) to Bsh object: \" + namespace;\n\t}\n\n\t/**\n\t\tGet dynamic proxy for interface, caching those it creates.\n\t*/\n\tpublic Object getInterface( Class clas ) \n\t{\n\t\treturn getInterface( new Class[] { clas } );\n\t}\n\n\t/**\n\t\tGet dynamic proxy for interface, caching those it creates.\n\t*/\n\tpublic Object getInterface( Class [] ca ) \n\t{\n\t\tif ( interfaces == null )\n\t\t\tinterfaces = new Hashtable();\n\n\t\t// Make a hash of the interface hashcodes in order to cache them\n\t\tint hash = 21;\n\t\tfor(int i=0; i<ca.length; i++)\n\t\t\thash *= ca[i].hashCode() + 3;\n\t\tObject hashKey = new Integer(hash);\n\n\t\tObject interf = interfaces.get( hashKey );\n\n\t\tif ( interf == null ) \n\t\t{\n\t\t\tClassLoader classLoader = ca[0].getClassLoader(); // ?\n\t\t\tinterf = Proxy.newProxyInstance( \n\t\t\t\tclassLoader, ca, invocationHandler );\n\t\t\tinterfaces.put( hashKey, interf );\n\t\t}\n\n\t\treturn interf;\n\t}\n\n\t/**\n\t\tThis is the invocation handler for the dynamic proxy.\n\t\t<p>\n\n\t\tNotes:\n\t\tInner class for the invocation handler seems to shield this unavailable\n\t\tinterface from JDK1.2 VM...  \n\t\t\n\t\tI don't understand this.  JThis works just fine even if those\n\t\tclasses aren't there (doesn't it?)  This class shouldn't be loaded\n\t\tif an XThis isn't instantiated in NameSpace.java, should it?\n\t*/\n\tclass Handler implements InvocationHandler, java.io.Serializable \n\t{\n\t\tpublic Object invoke( Object proxy, Method method, Object[] args ) \n\t\t\tthrows Throwable\n\t\t{\n\t\t\ttry { \n\t\t\t\treturn invokeImpl( proxy, method, args );\n\t\t\t} catch ( TargetError te ) {\n\t\t\t\t// Unwrap target exception.  If the interface declares that \n\t\t\t\t// it throws the ex it will be delivered.  If not it will be \n\t\t\t\t// wrapped in an UndeclaredThrowable\n\t\t\t\tthrow te.getTarget();\n\t\t\t} catch ( EvalError ee ) {\n\t\t\t\t// Ease debugging...\n\t\t\t\t// XThis.this refers to the enclosing class instance\n\t\t\t\tif ( Interpreter.DEBUG ) \n\t\t\t\t\tInterpreter.debug( \"EvalError in scripted interface: \"\n\t\t\t\t\t+ XThis.this.toString() + \": \"+ ee );\n\t\t\t\tthrow ee;\n\t\t\t}\n\t\t}\n\n\t\tpublic Object invokeImpl( Object proxy, Method method, Object[] args ) \n\t\t\tthrows EvalError \n\t\t{\n\t\t\tString methodName = method.getName();\n\t\t\tCallStack callstack = new CallStack( namespace );\n\n\t\t\t/*\n\t\t\t\tIf equals() is not explicitly defined we must override the \n\t\t\t\tdefault implemented by the This object protocol for scripted\n\t\t\t\tobject.  To support XThis equals() must test for equality with \n\t\t\t\tthe generated proxy object, not the scripted bsh This object;\n\t\t\t\totherwise callers from outside in Java will not see a the \n\t\t\t\tproxy object as equal to itself.\n\t\t\t*/\n\t\t\tBshMethod equalsMethod = null;\n\t\t\ttry {\n\t\t\t\tequalsMethod = namespace.getMethod( \n\t\t\t\t\t\"equals\", new Class [] { Object.class } );\n\t\t\t} catch ( UtilEvalError e ) {/*leave null*/ }\n\t\t\tif ( methodName.equals(\"equals\" ) && equalsMethod == null ) {\n\t\t\t\tObject obj = args[0];\n\t\t\t\treturn proxy == obj ? Boolean.TRUE : Boolean.FALSE;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t\tIf toString() is not explicitly defined override the default \n\t\t\t\tto show the proxy interfaces.\n\t\t\t*/\n\t\t\tBshMethod toStringMethod = null;\n\t\t\ttry {\n\t\t\t\ttoStringMethod = \n\t\t\t\t\tnamespace.getMethod( \"toString\", new Class [] { } );\n\t\t\t} catch ( UtilEvalError e ) {/*leave null*/ }\n\n\t\t\tif ( methodName.equals(\"toString\" ) && toStringMethod == null)\n\t\t\t{\n\t\t\t\tClass [] ints = proxy.getClass().getInterfaces();\n\t\t\t\t// XThis.this refers to the enclosing class instance\n\t\t\t\tStringBuffer sb = new StringBuffer( \n\t\t\t\t\tXThis.this.toString() + \"\\nimplements:\" );\n\t\t\t\tfor(int i=0; i<ints.length; i++)\n\t\t\t\t\tsb.append( \" \"+ ints[i].getName() \n\t\t\t\t\t\t+ ((ints.length > 1)?\",\":\"\") );\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\n\t\t\tClass [] paramTypes = method.getParameterTypes();\n\t\t\treturn Primitive.unwrap( \n\t\t\t\tinvokeMethod( methodName, Primitive.wrap(args, paramTypes) ) );\n\t\t}\n\t};\n}\n\n\n\n", "target": 1}
{"idx": 969, "func": "/**\n * JBoss, Home of Professional Open Source\n * Copyright 2010, Red Hat, Inc. and individual contributors\n * by the @authors tag. See the copyright.txt in the distribution for a\n * full listing of individual contributors.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n **/\npackage org.ajax4jsf.resource;\n\n/**\n * A marker interface, used to indicate that the class implementing this interfaces is cleared for deserialisation by\n * the LookAheadObjectInputStream\n *\n * @author <a href=\"http://community.jboss.org/people/bleathem\">Brian Leathem</a>\n */\npublic interface SerializableResource extends java.io.Serializable {\n}\n", "target": 0}
{"idx": 970, "func": "package org.orbeon.oxf.xml.xerces;\n\nimport org.orbeon.oxf.common.OXFException;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Hashtable;\nimport java.util.Map;\n\n/**\n * Boasts a couple of improvements over the 'stock' xerces parser factory.\n *\n * o Doesn't create a new parser every time one calls setFeature or getFeature.  Stock one\n *   has to do this because valid feature set is encapsulated in the parser code.\n *\n * o Creates a XercesJAXPSAXParser instead of SaxParserImpl. See XercesJAXPSAXParser for\n *   why this is an improvement.\n *\n * o The improvements cut the time it takes to a SAX parser via JAXP in\n *   half and reduce the amount of garbage created when accessing '/' in\n *   the examples app from 9019216 bytes to 8402880 bytes.\n */\npublic class XercesSAXParserFactoryImpl extends SAXParserFactory {\n\n    private static final Collection recognizedFeaturesNonValidatingXInclude;\n    private static final Map defaultFeaturesNonValidatingXInclude;\n\n    private static final Collection recognizedFeaturesNonValidatingNoXInclude;\n    private static final Map defaultFeaturesNonValidatingNoXInclude;\n\n    private static final Collection recognizedFeaturesValidatingXInclude;\n    private static final Map defaultFeaturesValidatingXInclude;\n\n    private static final Collection recognizedFeaturesValidatingNoXInclude;\n    private static final Map defaultFeaturesValidatingNoXInclude;\n\n    static {\n        {\n            final OrbeonParserConfiguration configuration = XercesSAXParser.makeConfig(false, true);\n            final Collection features = configuration.getRecognizedFeatures();\n            recognizedFeaturesNonValidatingXInclude = Collections.unmodifiableCollection(features);\n            defaultFeaturesNonValidatingXInclude = configuration.getFeatures();\n            // This was being done in XMLUtils.createSaxParserFactory before.  Maybe want to\n            // move it back if we decide to make this class more general purpose.\n            defaultFeaturesNonValidatingXInclude.put(\"http://xml.org/sax/features/namespaces\", Boolean.TRUE);\n            defaultFeaturesNonValidatingXInclude.put(\"http://xml.org/sax/features/namespace-prefixes\", Boolean.FALSE);\n        }\n        {\n            final OrbeonParserConfiguration configuration = XercesSAXParser.makeConfig(false, false);\n            final Collection features = configuration.getRecognizedFeatures();\n            recognizedFeaturesNonValidatingNoXInclude = Collections.unmodifiableCollection(features);\n            defaultFeaturesNonValidatingNoXInclude = configuration.getFeatures();\n            // This was being done in XMLUtils.createSaxParserFactory before.  Maybe want to\n            // move it back if we decide to make this class more general purpose.\n            defaultFeaturesNonValidatingNoXInclude.put(\"http://xml.org/sax/features/namespaces\", Boolean.TRUE);\n            defaultFeaturesNonValidatingNoXInclude.put(\"http://xml.org/sax/features/namespace-prefixes\", Boolean.FALSE);\n        }\n\n        {\n            final OrbeonParserConfiguration configuration = XercesSAXParser.makeConfig(true, true);\n            final Collection features = configuration.getRecognizedFeatures();\n            recognizedFeaturesValidatingXInclude = Collections.unmodifiableCollection(features);\n            defaultFeaturesValidatingXInclude = configuration.getFeatures();\n            // This was being done in XMLUtils.createSaxParserFactory before.  Maybe want to\n            // move it back if we decide to make this class more general purpose.\n            defaultFeaturesValidatingXInclude.put(\"http://xml.org/sax/features/namespaces\", Boolean.TRUE);\n            defaultFeaturesValidatingXInclude.put(\"http://xml.org/sax/features/namespace-prefixes\", Boolean.FALSE);\n        }\n        {\n            final OrbeonParserConfiguration configuration = XercesSAXParser.makeConfig(true, false);\n            final Collection features = configuration.getRecognizedFeatures();\n            recognizedFeaturesValidatingNoXInclude = Collections.unmodifiableCollection(features);\n            defaultFeaturesValidatingNoXInclude = configuration.getFeatures();\n            // This was being done in XMLUtils.createSaxParserFactory before.  Maybe want to\n            // move it back if we decide to make this class more general purpose.\n            defaultFeaturesValidatingNoXInclude.put(\"http://xml.org/sax/features/namespaces\", Boolean.TRUE);\n            defaultFeaturesValidatingNoXInclude.put(\"http://xml.org/sax/features/namespace-prefixes\", Boolean.FALSE);\n        }\n    }\n\n    private final Hashtable features;\n    private final boolean validating;\n    private final boolean handleXInclude;\n\n    public XercesSAXParserFactoryImpl() {\n        this(false, false);\n    }\n\n    public XercesSAXParserFactoryImpl(boolean validating, boolean handleXInclude) {\n        this.validating = validating;\n        this.handleXInclude = handleXInclude;\n        if (!validating) {\n            features = new Hashtable(handleXInclude ? defaultFeaturesNonValidatingXInclude : defaultFeaturesNonValidatingNoXInclude);\n        } else {\n            features = new Hashtable(handleXInclude ? defaultFeaturesValidatingXInclude : defaultFeaturesValidatingNoXInclude);\n        }\n        setNamespaceAware(true); // this is needed by some tools in addition to the feature\n    }\n\n    public boolean getFeature(final String key) throws SAXNotRecognizedException {\n        if (!getRecognizedFeatures().contains(key)) throw new SAXNotRecognizedException(key);\n        return features.get(key) == Boolean.TRUE;\n    }\n\n    public void setFeature(final String key, final boolean val) throws SAXNotRecognizedException {\n        if (!getRecognizedFeatures().contains(key)) throw new SAXNotRecognizedException(key);\n        features.put(key, val ? Boolean.TRUE : Boolean.FALSE);\n    }\n\n    public SAXParser newSAXParser() throws ParserConfigurationException {\n        final SAXParser ret;\n        try {\n            ret = new XercesJAXPSAXParser(this, features, validating, handleXInclude);\n        } catch (final SAXException se) {\n            // Translate to ParserConfigurationException\n            throw new OXFException(se); // so we see a decent stack trace!\n//            throw new ParserConfigurationException(se.getMessage());\n        }\n        return ret;\n    }\n\n    private Collection getRecognizedFeatures() {\n        if (!validating) {\n            return handleXInclude ? recognizedFeaturesNonValidatingXInclude : recognizedFeaturesNonValidatingNoXInclude;\n        } else {\n            return handleXInclude ? recognizedFeaturesValidatingXInclude : recognizedFeaturesValidatingNoXInclude;\n        }\n    }\n}", "target": 1}
{"idx": 971, "func": "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.testsuite.admin;\n\nimport org.junit.Test;\nimport org.keycloak.OAuth2Constants;\nimport org.keycloak.admin.client.resource.ClientResource;\nimport org.keycloak.admin.client.resource.ProtocolMappersResource;\nimport org.keycloak.admin.client.resource.RoleMappingResource;\nimport org.keycloak.common.util.Time;\nimport org.keycloak.events.admin.OperationType;\nimport org.keycloak.events.admin.ResourceType;\nimport org.keycloak.models.AccountRoles;\nimport org.keycloak.models.Constants;\nimport org.keycloak.protocol.oidc.OIDCLoginProtocol;\nimport org.keycloak.protocol.oidc.OIDCLoginProtocolFactory;\nimport org.keycloak.representations.adapters.action.GlobalRequestResult;\nimport org.keycloak.representations.adapters.action.PushNotBeforeAction;\nimport org.keycloak.representations.adapters.action.TestAvailabilityAction;\nimport org.keycloak.representations.idm.ClientRepresentation;\nimport org.keycloak.representations.idm.OAuth2ErrorRepresentation;\nimport org.keycloak.representations.idm.ProtocolMapperRepresentation;\nimport org.keycloak.representations.idm.RoleRepresentation;\nimport org.keycloak.representations.idm.UserRepresentation;\nimport org.keycloak.representations.idm.UserSessionRepresentation;\nimport org.keycloak.testsuite.Assert;\nimport org.keycloak.testsuite.util.AdminEventPaths;\nimport org.keycloak.testsuite.util.ClientBuilder;\nimport org.keycloak.testsuite.util.CredentialBuilder;\nimport org.keycloak.testsuite.util.OAuthClient;\nimport org.keycloak.testsuite.util.OAuthClient.AccessTokenResponse;\nimport org.keycloak.testsuite.util.RoleBuilder;\nimport org.keycloak.testsuite.util.UserBuilder;\n\nimport javax.ws.rs.BadRequestException;\nimport javax.ws.rs.NotFoundException;\nimport javax.ws.rs.core.Response;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.junit.Assert.*;\n\n/**\n * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n */\npublic class ClientTest extends AbstractAdminTest {\n\n    @Test\n    public void getClients() {\n        Assert.assertNames(realm.clients().findAll(), \"account\", \"realm-management\", \"security-admin-console\", \"broker\", Constants.ADMIN_CLI_CLIENT_ID);\n    }\n\n    private ClientRepresentation createClient() {\n        ClientRepresentation rep = new ClientRepresentation();\n        rep.setClientId(\"my-app\");\n        rep.setDescription(\"my-app description\");\n        rep.setEnabled(true);\n        Response response = realm.clients().create(rep);\n        response.close();\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        ClientRepresentation found = ApiUtil.findClientResourceByClientId(realm, \"my-app\").toRepresentation();\n\n        assertEquals(\"my-app\", found.getClientId());\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientResourcePath(id), rep, ResourceType.CLIENT);\n\n        rep.setId(id);\n\n        return rep;\n    }\n\n    @Test\n    public void createClientVerify() {\n        String id = createClient().getId();\n\n        assertNotNull(realm.clients().get(id));\n        Assert.assertNames(realm.clients().findAll(), \"account\", \"realm-management\", \"security-admin-console\", \"broker\", \"my-app\", Constants.ADMIN_CLI_CLIENT_ID);\n    }\n\n    @Test\n    public void removeClient() {\n        String id = createClient().getId();\n\n        assertNotNull(ApiUtil.findClientByClientId(realm, \"my-app\"));\n        realm.clients().get(id).remove();\n        assertNull(ApiUtil.findClientResourceByClientId(realm, \"my-app\"));\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientResourcePath(id), ResourceType.CLIENT);\n    }\n\n    @Test\n    public void getClientRepresentation() {\n        String id = createClient().getId();\n\n        ClientRepresentation rep = realm.clients().get(id).toRepresentation();\n        assertEquals(id, rep.getId());\n        assertEquals(\"my-app\", rep.getClientId());\n        assertTrue(rep.isEnabled());\n    }\n\n    /**\n     * See <a href=\"https://issues.jboss.org/browse/KEYCLOAK-1918\">KEYCLOAK-1918</a>\n     */\n    @Test\n    public void getClientDescription() {\n        String id = createClient().getId();\n\n        ClientRepresentation rep = realm.clients().get(id).toRepresentation();\n        assertEquals(id, rep.getId());\n        assertEquals(\"my-app description\", rep.getDescription());\n    }\n\n    @Test\n    public void getClientSessions() throws Exception {\n        OAuthClient.AccessTokenResponse response = oauth.doGrantAccessTokenRequest(\"password\", \"test-user@localhost\", \"password\");\n        assertEquals(200, response.getStatusCode());\n\n        OAuthClient.AuthorizationEndpointResponse codeResponse = oauth.doLogin(\"test-user@localhost\", \"password\");\n\n        OAuthClient.AccessTokenResponse response2 = oauth.doAccessTokenRequest(codeResponse.getCode(), \"password\");\n        assertEquals(200, response2.getStatusCode());\n\n        ClientResource app = ApiUtil.findClientByClientId(adminClient.realm(\"test\"), \"test-app\");\n\n        assertEquals(2, (long) app.getApplicationSessionCount().get(\"count\"));\n\n        List<UserSessionRepresentation> userSessions = app.getUserSessions(0, 100);\n        assertEquals(2, userSessions.size());\n        assertEquals(1, userSessions.get(0).getClients().size());\n    }\n\n    @Test\n    public void getAllClients() {\n        List<ClientRepresentation> allClients = realm.clients().findAll();\n        assertNotNull(allClients);\n        assertFalse(allClients.isEmpty());\n    }\n\n    @Test\n    public void getClientById() {\n        createClient();\n        ClientRepresentation rep = ApiUtil.findClientResourceByClientId(realm, \"my-app\").toRepresentation();\n        ClientRepresentation gotById = realm.clients().get(rep.getId()).toRepresentation();\n        assertClient(rep, gotById);\n    }\n\n    @Test\n    // KEYCLOAK-1110\n    public void deleteDefaultRole() {\n        ClientRepresentation rep = createClient();\n        String id = rep.getId();\n\n        RoleRepresentation role = new RoleRepresentation(\"test\", \"test\", false);\n        realm.clients().get(id).roles().create(role);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientRoleResourcePath(id, \"test\"), role, ResourceType.CLIENT_ROLE);\n\n        ClientRepresentation foundClientRep = realm.clients().get(id).toRepresentation();\n        foundClientRep.setDefaultRoles(new String[]{\"test\"});\n        realm.clients().get(id).update(foundClientRep);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientResourcePath(id), rep, ResourceType.CLIENT);\n\n        assertArrayEquals(new String[]{\"test\"}, realm.clients().get(id).toRepresentation().getDefaultRoles());\n\n        realm.clients().get(id).roles().deleteRole(\"test\");\n\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientRoleResourcePath(id, \"test\"), ResourceType.CLIENT_ROLE);\n\n        assertNull(realm.clients().get(id).toRepresentation().getDefaultRoles());\n    }\n\n    @Test\n    public void testProtocolMappers() {\n        String clientDbId = createClient().getId();\n        ProtocolMappersResource mappersResource = ApiUtil.findClientByClientId(realm, \"my-app\").getProtocolMappers();\n\n        protocolMappersTest(clientDbId, mappersResource);\n    }\n\n    @Test\n    public void updateClient() {\n        ClientRepresentation client = createClient();\n\n        ClientRepresentation newClient = new ClientRepresentation();\n        newClient.setId(client.getId());\n        newClient.setClientId(client.getClientId());\n        newClient.setBaseUrl(\"http://baseurl\");\n\n        realm.clients().get(client.getId()).update(newClient);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientResourcePath(client.getId()), newClient, ResourceType.CLIENT);\n\n        ClientRepresentation storedClient = realm.clients().get(client.getId()).toRepresentation();\n\n        assertClient(client, storedClient);\n\n        newClient.setSecret(\"new-secret\");\n\n        realm.clients().get(client.getId()).update(newClient);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientResourcePath(client.getId()), newClient, ResourceType.CLIENT);\n\n        storedClient = realm.clients().get(client.getId()).toRepresentation();\n        assertClient(client, storedClient);\n    }\n\n    @Test\n    public void serviceAccount() {\n        Response response = realm.clients().create(ClientBuilder.create().clientId(\"serviceClient\").serviceAccount().build());\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        response.close();\n        UserRepresentation userRep = realm.clients().get(id).getServiceAccountUser();\n        assertEquals(\"service-account-serviceclient\", userRep.getUsername());\n    }\n\n    // KEYCLOAK-3421\n    @Test\n    public void createClientWithFragments() {\n        ClientRepresentation client = ClientBuilder.create()\n                .clientId(\"client-with-fragment\")\n                .rootUrl(\"http://localhost/base#someFragment\")\n                .redirectUris(\"http://localhost/auth\", \"http://localhost/auth#fragment\", \"http://localhost/auth*\", \"/relative\")\n                .build();\n\n        Response response = realm.clients().create(client);\n        assertUriFragmentError(response);\n    }\n\n    // KEYCLOAK-3421\n    @Test\n    public void updateClientWithFragments() {\n        ClientRepresentation client = ClientBuilder.create()\n                .clientId(\"client-with-fragment\")\n                .redirectUris(\"http://localhost/auth\", \"http://localhost/auth*\")\n                .build();\n        Response response = realm.clients().create(client);\n        String clientUuid = ApiUtil.getCreatedId(response);\n        ClientResource clientResource = realm.clients().get(clientUuid);\n        getCleanup().addClientUuid(clientUuid);\n        response.close();\n\n        client = clientResource.toRepresentation();\n        client.setRootUrl(\"http://localhost/base#someFragment\");\n        List<String> redirectUris = client.getRedirectUris();\n        redirectUris.add(\"http://localhost/auth#fragment\");\n        redirectUris.add(\"/relative\");\n        client.setRedirectUris(redirectUris);\n\n        try {\n            clientResource.update(client);\n            fail(\"Should fail\");\n        }\n        catch (BadRequestException e) {\n            assertUriFragmentError(e.getResponse());\n        }\n    }\n\n    private void assertUriFragmentError(Response response) {\n        assertEquals(response.getStatus(), 400);\n        String error = response.readEntity(OAuth2ErrorRepresentation.class).getError();\n        assertTrue(\"Error response doesn't mention Redirect URIs fragments\", error.contains(\"Redirect URIs must not contain an URI fragment\"));\n        assertTrue(\"Error response doesn't mention Root URL fragments\", error.contains(\"Root URL must not contain an URL fragment\"));\n    }\n\n    @Test\n    public void pushRevocation() {\n        testingClient.testApp().clearAdminActions();\n\n        ClientRepresentation client = createAppClient();\n        String id = client.getId();\n\n        realm.clients().get(id).pushRevocation();\n\n        PushNotBeforeAction pushNotBefore = testingClient.testApp().getAdminPushNotBefore();\n        assertEquals(client.getNotBefore().intValue(), pushNotBefore.getNotBefore());\n\n        assertAdminEvents.assertEvent(realmId, OperationType.ACTION, AdminEventPaths.clientPushRevocationPath(id), ResourceType.CLIENT);\n    }\n\n    private ClientRepresentation createAppClient() {\n        String redirectUri = oauth.getRedirectUri().replace(\"/master/\", \"/\" + REALM_NAME + \"/\");\n\n        ClientRepresentation client = new ClientRepresentation();\n        client.setClientId(\"test-app\");\n        client.setAdminUrl(suiteContext.getAuthServerInfo().getContextRoot() + \"/auth/realms/master/app/admin\");\n        client.setRedirectUris(Collections.singletonList(redirectUri));\n        client.setSecret(\"secret\");\n        client.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n\n        int notBefore = Time.currentTime() - 60;\n        client.setNotBefore(notBefore);\n\n        Response response = realm.clients().create(client);\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        response.close();\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientResourcePath(id), client, ResourceType.CLIENT);\n\n        client.setId(id);\n        return client;\n    }\n\n    @Test\n    public void nodes() {\n        testingClient.testApp().clearAdminActions();\n\n        ClientRepresentation client = createAppClient();\n        String id = client.getId();\n\n        String myhost = suiteContext.getAuthServerInfo().getContextRoot().getHost();\n        realm.clients().get(id).registerNode(Collections.singletonMap(\"node\", myhost));\n        realm.clients().get(id).registerNode(Collections.singletonMap(\"node\", \"invalid\"));\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientNodePath(id, myhost), ResourceType.CLUSTER_NODE);\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientNodePath(id, \"invalid\"), ResourceType.CLUSTER_NODE);\n\n        GlobalRequestResult result = realm.clients().get(id).testNodesAvailable();\n        assertEquals(1, result.getSuccessRequests().size());\n        assertEquals(1, result.getFailedRequests().size());\n\n        assertAdminEvents.assertEvent(realmId, OperationType.ACTION, AdminEventPaths.clientTestNodesAvailablePath(id), result, ResourceType.CLUSTER_NODE);\n\n        TestAvailabilityAction testAvailable = testingClient.testApp().getTestAvailable();\n        assertEquals(\"test-app\", testAvailable.getResource());\n\n        assertEquals(2, realm.clients().get(id).toRepresentation().getRegisteredNodes().size());\n\n        realm.clients().get(id).unregisterNode(\"invalid\");\n\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientNodePath(id, \"invalid\"), ResourceType.CLUSTER_NODE);\n\n        assertEquals(1, realm.clients().get(id).toRepresentation().getRegisteredNodes().size());\n    }\n\n    @Test\n    public void offlineUserSessions() throws IOException {\n        ClientRepresentation client = createAppClient();\n        String id = client.getId();\n\n        Response response = realm.users().create(UserBuilder.create().username(\"testuser\").build());\n        String userId = ApiUtil.getCreatedId(response);\n        response.close();\n\n        realm.users().get(userId).resetPassword(CredentialBuilder.create().password(\"password\").build());\n\n        Map<String, Long> offlineSessionCount = realm.clients().get(id).getOfflineSessionCount();\n        assertEquals(new Long(0), offlineSessionCount.get(\"count\"));\n\n        List<UserSessionRepresentation> userSessions = realm.users().get(userId).getOfflineSessions(id);\n        assertEquals(\"There should be no offline sessions\", 0, userSessions.size());\n\n        oauth.realm(REALM_NAME);\n        oauth.redirectUri(client.getRedirectUris().get(0));\n        oauth.scope(OAuth2Constants.OFFLINE_ACCESS);\n        oauth.doLogin(\"testuser\", \"password\");\n        AccessTokenResponse accessTokenResponse = oauth.doAccessTokenRequest(oauth.getCurrentQuery().get(\"code\"), \"secret\");\n        assertEquals(200, accessTokenResponse.getStatusCode());\n\n        offlineSessionCount = realm.clients().get(id).getOfflineSessionCount();\n        assertEquals(new Long(1), offlineSessionCount.get(\"count\"));\n\n        List<UserSessionRepresentation> offlineUserSessions = realm.clients().get(id).getOfflineUserSessions(0, 100);\n        assertEquals(1, offlineUserSessions.size());\n        assertEquals(\"testuser\", offlineUserSessions.get(0).getUsername());\n\n        userSessions = realm.users().get(userId).getOfflineSessions(id);\n        assertEquals(\"There should be one offline session\", 1, userSessions.size());\n        assertOfflineSession(offlineUserSessions.get(0), userSessions.get(0));\n    }\n\n    private void assertOfflineSession(UserSessionRepresentation expected, UserSessionRepresentation actual) {\n        assertEquals(\"id\", expected.getId(), actual.getId());\n        assertEquals(\"userId\", expected.getUserId(), actual.getUserId());\n        assertEquals(\"userName\", expected.getUsername(), actual.getUsername());\n        assertEquals(\"clients\", expected.getClients(), actual.getClients());\n    }\n\n    @Test\n    public void scopes() {\n        Response response = realm.clients().create(ClientBuilder.create().clientId(\"client\").fullScopeEnabled(false).build());\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        response.close();\n\n        assertAdminEvents.poll();\n\n        RoleMappingResource scopesResource = realm.clients().get(id).getScopeMappings();\n\n        RoleRepresentation roleRep1 = RoleBuilder.create().name(\"role1\").build();\n        RoleRepresentation roleRep2 = RoleBuilder.create().name(\"role2\").build();\n        realm.roles().create(roleRep1);\n        realm.roles().create(roleRep2);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.roleResourcePath(\"role1\"), roleRep1, ResourceType.REALM_ROLE);\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.roleResourcePath(\"role2\"), roleRep2, ResourceType.REALM_ROLE);\n\n        roleRep1 = realm.roles().get(\"role1\").toRepresentation();\n        roleRep2 = realm.roles().get(\"role2\").toRepresentation();\n\n        realm.roles().get(\"role1\").addComposites(Collections.singletonList(roleRep2));\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.roleResourceCompositesPath(\"role1\"), Collections.singletonList(roleRep2), ResourceType.REALM_ROLE);\n\n        String accountMgmtId = realm.clients().findByClientId(Constants.ACCOUNT_MANAGEMENT_CLIENT_ID).get(0).getId();\n        RoleRepresentation viewAccountRoleRep = realm.clients().get(accountMgmtId).roles().get(AccountRoles.VIEW_PROFILE).toRepresentation();\n\n        scopesResource.realmLevel().add(Collections.singletonList(roleRep1));\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientScopeMappingsRealmLevelPath(id), Collections.singletonList(roleRep1), ResourceType.REALM_SCOPE_MAPPING);\n\n        scopesResource.clientLevel(accountMgmtId).add(Collections.singletonList(viewAccountRoleRep));\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientScopeMappingsClientLevelPath(id, accountMgmtId), Collections.singletonList(viewAccountRoleRep), ResourceType.CLIENT_SCOPE_MAPPING);\n\n        Assert.assertNames(scopesResource.realmLevel().listAll(), \"role1\");\n        Assert.assertNames(scopesResource.realmLevel().listEffective(), \"role1\", \"role2\");\n        Assert.assertNames(scopesResource.realmLevel().listAvailable(), \"offline_access\", Constants.AUTHZ_UMA_AUTHORIZATION);\n\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAll(), AccountRoles.VIEW_PROFILE);\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listEffective(), AccountRoles.VIEW_PROFILE);\n\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAvailable(), AccountRoles.MANAGE_ACCOUNT, AccountRoles.MANAGE_ACCOUNT_LINKS);\n\n        Assert.assertNames(scopesResource.getAll().getRealmMappings(), \"role1\");\n        Assert.assertNames(scopesResource.getAll().getClientMappings().get(Constants.ACCOUNT_MANAGEMENT_CLIENT_ID).getMappings(), AccountRoles.VIEW_PROFILE);\n\n        scopesResource.realmLevel().remove(Collections.singletonList(roleRep1));\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientScopeMappingsRealmLevelPath(id), Collections.singletonList(roleRep1), ResourceType.REALM_SCOPE_MAPPING);\n\n        scopesResource.clientLevel(accountMgmtId).remove(Collections.singletonList(viewAccountRoleRep));\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientScopeMappingsClientLevelPath(id, accountMgmtId), Collections.singletonList(viewAccountRoleRep), ResourceType.CLIENT_SCOPE_MAPPING);\n\n        Assert.assertNames(scopesResource.realmLevel().listAll());\n        Assert.assertNames(scopesResource.realmLevel().listEffective());\n        Assert.assertNames(scopesResource.realmLevel().listAvailable(), \"offline_access\", Constants.AUTHZ_UMA_AUTHORIZATION, \"role1\", \"role2\");\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAll());\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAvailable(), AccountRoles.VIEW_PROFILE, AccountRoles.MANAGE_ACCOUNT, AccountRoles.MANAGE_ACCOUNT_LINKS);\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listEffective());\n    }\n\n    public void protocolMappersTest(String clientDbId, ProtocolMappersResource mappersResource) {\n        // assert default mappers found\n        List<ProtocolMapperRepresentation> protocolMappers = mappersResource.getMappers();\n\n        String emailMapperId = null;\n        String usernameMapperId = null;\n        String fooMapperId = null;\n        for (ProtocolMapperRepresentation mapper : protocolMappers) {\n            if (mapper.getName().equals(OIDCLoginProtocolFactory.EMAIL)) {\n                emailMapperId = mapper.getId();\n            } else if (mapper.getName().equals(OIDCLoginProtocolFactory.USERNAME)) {\n                usernameMapperId = mapper.getId();\n            } else if (mapper.getName().equals(\"foo\")) {\n                fooMapperId = mapper.getId();\n            }\n        }\n\n        // Builtin mappers are not here\n        assertNull(emailMapperId);\n        assertNull(usernameMapperId);\n\n        assertNull(fooMapperId);\n\n        // Create foo mapper\n        ProtocolMapperRepresentation fooMapper = new ProtocolMapperRepresentation();\n        fooMapper.setName(\"foo\");\n        fooMapper.setProtocol(\"openid-connect\");\n        fooMapper.setProtocolMapper(\"oidc-hardcoded-claim-mapper\");\n        Response response = mappersResource.createMapper(fooMapper);\n        String location = response.getLocation().toString();\n        fooMapperId = location.substring(location.lastIndexOf(\"/\") + 1);\n        response.close();\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientProtocolMapperPath(clientDbId, fooMapperId), fooMapper, ResourceType.PROTOCOL_MAPPER);\n\n        fooMapper = mappersResource.getMapperById(fooMapperId);\n        assertEquals(fooMapper.getName(), \"foo\");\n\n        // Update foo mapper\n        mappersResource.update(fooMapperId, fooMapper);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientProtocolMapperPath(clientDbId, fooMapperId), fooMapper, ResourceType.PROTOCOL_MAPPER);\n\n        fooMapper = mappersResource.getMapperById(fooMapperId);\n\n        // Remove foo mapper\n        mappersResource.delete(fooMapperId);\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientProtocolMapperPath(clientDbId, fooMapperId), ResourceType.PROTOCOL_MAPPER);\n        try {\n            mappersResource.getMapperById(fooMapperId);\n            fail(\"Not expected to find deleted mapper\");\n        } catch (NotFoundException nfe) {\n        }\n    }\n\n    public static void assertClient(ClientRepresentation client, ClientRepresentation storedClient) {\n        if (client.getClientId() != null) Assert.assertEquals(client.getClientId(), storedClient.getClientId());\n        if (client.getName() != null) Assert.assertEquals(client.getName(), storedClient.getName());\n        if (client.isEnabled() != null) Assert.assertEquals(client.isEnabled(), storedClient.isEnabled());\n        if (client.isBearerOnly() != null) Assert.assertEquals(client.isBearerOnly(), storedClient.isBearerOnly());\n        if (client.isPublicClient() != null) Assert.assertEquals(client.isPublicClient(), storedClient.isPublicClient());\n        if (client.isFullScopeAllowed() != null) Assert.assertEquals(client.isFullScopeAllowed(), storedClient.isFullScopeAllowed());\n        if (client.getRootUrl() != null) Assert.assertEquals(client.getRootUrl(), storedClient.getRootUrl());\n        if (client.getAdminUrl() != null) Assert.assertEquals(client.getAdminUrl(), storedClient.getAdminUrl());\n        if (client.getBaseUrl() != null) Assert.assertEquals(client.getBaseUrl(), storedClient.getBaseUrl());\n        if (client.isSurrogateAuthRequired() != null) Assert.assertEquals(client.isSurrogateAuthRequired(), storedClient.isSurrogateAuthRequired());\n        if (client.getClientAuthenticatorType() != null) Assert.assertEquals(client.getClientAuthenticatorType(), storedClient.getClientAuthenticatorType());\n\n        if (client.getNotBefore() != null) {\n            Assert.assertEquals(client.getNotBefore(), storedClient.getNotBefore());\n        }\n        if (client.getDefaultRoles() != null) {\n            Set<String> set = new HashSet<String>();\n            for (String val : client.getDefaultRoles()) {\n                set.add(val);\n            }\n            Set<String> storedSet = new HashSet<String>();\n            for (String val : storedClient.getDefaultRoles()) {\n                storedSet.add(val);\n            }\n\n            Assert.assertEquals(set, storedSet);\n        }\n\n        List<String> redirectUris = client.getRedirectUris();\n        if (redirectUris != null) {\n            Set<String> set = new HashSet<String>();\n            for (String val : client.getRedirectUris()) {\n                set.add(val);\n            }\n            Set<String> storedSet = new HashSet<String>();\n            for (String val : storedClient.getRedirectUris()) {\n                storedSet.add(val);\n            }\n\n            Assert.assertEquals(set, storedSet);\n        }\n\n        List<String> webOrigins = client.getWebOrigins();\n        if (webOrigins != null) {\n            Set<String> set = new HashSet<String>();\n            for (String val : client.getWebOrigins()) {\n                set.add(val);\n            }\n            Set<String> storedSet = new HashSet<String>();\n            for (String val : storedClient.getWebOrigins()) {\n                storedSet.add(val);\n            }\n\n            Assert.assertEquals(set, storedSet);\n        }\n    }\n\n}\n", "target": 1}
{"idx": 972, "func": "package org.bouncycastle.pqc.crypto.rainbow;\n\nimport org.bouncycastle.crypto.CipherParameters;\n\npublic class RainbowParameters\n    implements CipherParameters\n{\n\n    /**\n     * DEFAULT PARAMS\n     */\n    /*\n      * Vi = vinegars per layer whereas n is vu (vu = 33 = n) such that\n      *\n      * v1 = 6; o1 = 12-6 = 6\n      *\n      * v2 = 12; o2 = 17-12 = 5\n      *\n      * v3 = 17; o3 = 22-17 = 5\n      *\n      * v4 = 22; o4 = 33-22 = 11\n      *\n      * v5 = 33; (o5 = 0)\n      */\n    private final int[] DEFAULT_VI = {6, 12, 17, 22, 33};\n\n    private int[] vi;// set of vinegar vars per layer.\n\n    /**\n     * Default Constructor The elements of the array containing the number of\n     * Vinegar variables in each layer are set to the default values here.\n     */\n    public RainbowParameters()\n    {\n        this.vi = this.DEFAULT_VI;\n    }\n\n    /**\n     * Constructor with parameters\n     *\n     * @param vi The elements of the array containing the number of Vinegar\n     *           variables per layer are set to the values of the input array.\n     */\n    public RainbowParameters(int[] vi)\n    {\n        this.vi = vi;\n\n        checkParams();\n    }\n\n    private void checkParams()\n    {\n        if (vi == null)\n        {\n            throw new IllegalArgumentException(\"no layers defined.\");\n        }\n        if (vi.length > 1)\n        {\n            for (int i = 0; i < vi.length - 1; i++)\n            {\n                if (vi[i] >= vi[i + 1])\n                {\n                    throw new IllegalArgumentException(\n                        \"v[i] has to be smaller than v[i+1]\");\n                }\n            }\n        }\n        else\n        {\n            throw new IllegalArgumentException(\n                \"Rainbow needs at least 1 layer, such that v1 < v2.\");\n        }\n    }\n\n    /**\n     * Getter for the number of layers\n     *\n     * @return the number of layers\n     */\n    public int getNumOfLayers()\n    {\n        return this.vi.length - 1;\n    }\n\n    /**\n     * Getter for the number of all the polynomials in Rainbow\n     *\n     * @return the number of the polynomials\n     */\n    public int getDocLength()\n    {\n        return vi[vi.length - 1] - vi[0];\n    }\n\n    /**\n     * Getter for the array containing the number of Vinegar-variables per layer\n     *\n     * @return the numbers of vinegars per layer\n     */\n    public int[] getVi()\n    {\n        return this.vi;\n    }\n}\n", "target": 0}
{"idx": 973, "func": "package org.hswebframework.web.workflow.web;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport io.swagger.annotations.ApiParam;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.activiti.bpmn.converter.BpmnXMLConverter;\nimport org.activiti.bpmn.model.BpmnModel;\nimport org.activiti.editor.language.json.converter.BpmnJsonConverter;\nimport org.activiti.engine.RepositoryService;\nimport org.activiti.engine.impl.persistence.entity.ModelEntity;\nimport org.activiti.engine.repository.Deployment;\nimport org.activiti.engine.repository.Model;\nimport org.activiti.engine.repository.ModelQuery;\nimport org.apache.batik.transcoder.TranscoderException;\nimport org.apache.batik.transcoder.TranscoderInput;\nimport org.apache.batik.transcoder.TranscoderOutput;\nimport org.apache.batik.transcoder.image.PNGTranscoder;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.hswebframework.ezorm.core.PropertyWrapper;\nimport org.hswebframework.ezorm.core.SimplePropertyWrapper;\nimport org.hswebframework.ezorm.core.param.TermType;\nimport org.hswebframework.web.NotFoundException;\nimport org.hswebframework.web.authorization.Permission;\nimport org.hswebframework.web.authorization.annotation.Authorize;\nimport org.hswebframework.web.bean.FastBeanCopier;\nimport org.hswebframework.web.commons.entity.PagerResult;\nimport org.hswebframework.web.commons.entity.param.QueryParamEntity;\nimport org.hswebframework.web.controller.message.ResponseMessage;\nimport org.hswebframework.web.workflow.enums.ModelType;\nimport org.hswebframework.web.workflow.util.QueryUtils;\nimport org.hswebframework.web.workflow.web.request.ModelCreateRequest;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URLEncoder;\nimport java.util.List;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"/workflow/model\")\n@Api(tags = \"-\", description = \"\")\n@Authorize(permission = \"workflow-model\", description = \"\")\n@Slf4j\npublic class FlowableModelManagerController {\n\n    @Autowired\n    private RepositoryService repositoryService;\n\n    private final static String MODEL_ID          = \"modelId\";\n    private final static String MODEL_NAME        = \"name\";\n    private final static String MODEL_REVISION    = \"revision\";\n    private final static String MODEL_DESCRIPTION = \"description\";\n    private final static String MODEL_KEY         = \"key\";\n\n    @GetMapping\n    @Authorize(action = Permission.ACTION_QUERY)\n    @ApiOperation(\"\")\n    public ResponseMessage<PagerResult<Model>> getModelList(QueryParamEntity param) {\n        ModelQuery modelQuery = repositoryService.createModelQuery();\n        return ResponseMessage.ok(\n                QueryUtils.doQuery(modelQuery, param,\n                        model -> FastBeanCopier.copy(model, new ModelEntity()),\n                        (term, modelQuery1) -> {\n                            if (\"latestVersion\".equals(term.getColumn())) {\n                                modelQuery1.latestVersion();\n                            }\n                        }));\n    }\n\n    @PostMapping\n    @ResponseStatus(value = HttpStatus.CREATED)\n    @ApiOperation(\"\")\n    public ResponseMessage<Model> createModel(@RequestBody ModelCreateRequest model) throws Exception {\n        JSONObject stencilset = new JSONObject();\n        stencilset.put(\"namespace\", \"http://b3mn.org/stencilset/bpmn2.0#\");\n        JSONObject editorNode = new JSONObject();\n        editorNode.put(\"id\", \"canvas\");\n        editorNode.put(\"resourceId\", \"canvas\");\n        editorNode.put(\"stencilset\", stencilset);\n        JSONObject modelObjectNode = new JSONObject();\n        modelObjectNode.put(MODEL_REVISION, 1);\n        modelObjectNode.put(MODEL_DESCRIPTION, model.getDescription());\n        modelObjectNode.put(MODEL_KEY, model.getKey());\n        modelObjectNode.put(MODEL_NAME, model.getName());\n\n        Model modelData = repositoryService.newModel();\n        modelData.setMetaInfo(modelObjectNode.toJSONString());\n        modelData.setName(model.getName());\n        modelData.setKey(model.getKey());\n        repositoryService.saveModel(modelData);\n        repositoryService.addModelEditorSource(modelData.getId(), editorNode.toString().getBytes(\"utf-8\"));\n        return ResponseMessage.ok(modelData).status(201);\n    }\n\n    @PostMapping(\"/{modelId}/deploy\")\n    @ApiOperation(\"\")\n    @Authorize(action = \"deploy\")\n    public ResponseMessage<Deployment> deployModel(@PathVariable String modelId) throws Exception {\n        Model modelData = repositoryService.getModel(modelId);\n        if (modelData == null) {\n            throw new NotFoundException(\"!\");\n        }\n        ObjectNode modelNode = (ObjectNode) new ObjectMapper().readTree(repositoryService.getModelEditorSource(modelData.getId()));\n        BpmnModel model = new BpmnJsonConverter().convertToBpmnModel(modelNode);\n        byte[] bpmnBytes = new BpmnXMLConverter().convertToXML(model);\n        String processName = modelData.getName() + \".bpmn20.xml\";\n        Deployment deployment = repositoryService.createDeployment()\n                .name(modelData.getName())\n                .addString(processName, new String(bpmnBytes, \"utf8\"))\n                .deploy();\n        return ResponseMessage.ok(deployment).include(Deployment.class, \"id\", \"name\", \"new\");\n    }\n\n    /**\n     * model\n     *\n     * @param modelId ID\n     * @param type    (bpmn\\json)\n     */\n    @GetMapping(value = \"export/{modelId}/{type}\")\n    @ApiOperation(\"\")\n    @Authorize(action = \"export\")\n    @SneakyThrows\n    public void export(@PathVariable(\"modelId\") @ApiParam(\"ID\") String modelId,\n                       @PathVariable(\"type\") @ApiParam(value = \"\", allowableValues = \"bpmn,json\", example = \"json\")\n                               ModelType type,\n                       @ApiParam(hidden = true) HttpServletResponse response) {\n        Model modelData = repositoryService.getModel(modelId);\n        if (modelData == null) {\n            throw new NotFoundException(\"\");\n        }\n        BpmnJsonConverter jsonConverter = new BpmnJsonConverter();\n        byte[] modelEditorSource = repositoryService.getModelEditorSource(modelData.getId());\n\n        JsonNode editorNode = new ObjectMapper().readTree(modelEditorSource);\n        BpmnModel bpmnModel = jsonConverter.convertToBpmnModel(editorNode);\n\n        // \n        if (bpmnModel.getMainProcess() == null) {\n            throw new UnsupportedOperationException(\":\" + type);\n        }\n\n        String filename = \"\";\n        byte[] exportBytes = null;\n\n        String mainProcessId = bpmnModel.getMainProcess().getId();\n\n        if (type == ModelType.bpmn) {\n            BpmnXMLConverter xmlConverter = new BpmnXMLConverter();\n            exportBytes = xmlConverter.convertToXML(bpmnModel);\n            filename = mainProcessId + \".bpmn20.xml\";\n        } else if (type == ModelType.json) {\n            exportBytes = modelEditorSource;\n            filename = mainProcessId + \".json\";\n\n        } else {\n            throw new UnsupportedOperationException(\":\" + type);\n        }\n\n        response.setCharacterEncoding(\"UTF-8\");\n        response.setContentType(\"application/octet-stream\");\n        response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + URLEncoder.encode(filename, \"UTF-8\"));\n\n        /**/\n        try (ByteArrayInputStream in = new ByteArrayInputStream(exportBytes)) {\n            IOUtils.copy(in, response.getOutputStream());\n            response.flushBuffer();\n        }\n    }\n\n    @GetMapping(value = \"/{modelId}/json\")\n    @Authorize(action = Permission.ACTION_GET)\n    public Object getEditorJson(@PathVariable String modelId) {\n        JSONObject modelNode;\n        Model model = repositoryService.getModel(modelId);\n        if (model == null) throw new NullPointerException(\"\");\n        if (StringUtils.isNotEmpty(model.getMetaInfo())) {\n            modelNode = JSON.parseObject(model.getMetaInfo());\n        } else {\n            modelNode = new JSONObject();\n            modelNode.put(MODEL_NAME, model.getName());\n        }\n        modelNode.put(MODEL_ID, model.getId());\n        modelNode.put(\"model\", JSON.parse(new String(repositoryService.getModelEditorSource(model.getId()))));\n        return modelNode;\n    }\n\n    @PutMapping(value = \"/{modelId}\")\n    @ResponseStatus(value = HttpStatus.OK)\n    @Authorize(action = Permission.ACTION_UPDATE)\n    public void saveModel(@PathVariable String modelId,\n                          @RequestParam Map<String, String> values) throws TranscoderException, IOException {\n        Model model = repositoryService.getModel(modelId);\n        JSONObject modelJson = JSON.parseObject(model.getMetaInfo());\n\n        modelJson.put(MODEL_NAME, values.get(\"name\"));\n        modelJson.put(MODEL_DESCRIPTION, values.get(\"description\"));\n\n        model.setMetaInfo(modelJson.toString());\n        model.setName(values.get(\"name\"));\n\n        repositoryService.saveModel(model);\n\n        repositoryService.addModelEditorSource(model.getId(), values.get(\"json_xml\").getBytes(\"utf-8\"));\n\n        InputStream svgStream = new ByteArrayInputStream(values.get(\"svg_xml\").getBytes(\"utf-8\"));\n        TranscoderInput input = new TranscoderInput(svgStream);\n\n        PNGTranscoder transcoder = new PNGTranscoder();\n        // Setup output\n        ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n        TranscoderOutput output = new TranscoderOutput(outStream);\n\n        // Do the transformation\n        transcoder.transcode(input, output);\n        final byte[] result = outStream.toByteArray();\n        repositoryService.addModelEditorSourceExtra(model.getId(), result);\n        outStream.close();\n    }\n\n    @DeleteMapping(\"/{modelId}\")\n    @Authorize(action = Permission.ACTION_DELETE)\n    public ResponseMessage<Void> delete(@PathVariable String modelId) {\n        repositoryService.deleteModel(modelId);\n        return ResponseMessage.ok();\n    }\n}", "target": 0}
{"idx": 974, "func": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFacotry</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n}\n", "target": 1}
{"idx": 975, "func": "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.exec.internal;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.smarthome.config.core.ConfigConstants;\nimport org.eclipse.smarthome.core.service.AbstractWatchService;\nimport org.osgi.service.component.annotations.Activate;\nimport org.osgi.service.component.annotations.Component;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.WatchEvent;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport static java.nio.file.StandardWatchEventKinds.*;\n\n/**\n * The {@link ExecWhitelistWatchService} provides a whitelist check for exec commands\n *\n * @author Jan N. Klug - Initial contribution\n */\n@Component(service = ExecWhitelistWatchService.class)\n@NonNullByDefault\npublic class ExecWhitelistWatchService extends AbstractWatchService {\n    private static final String COMMAND_WHITELIST_PATH = ConfigConstants.getConfigFolder() + File.separator + \"misc\";\n    private static final String COMMAND_WHITELIST_FILE = \"exec.whitelist\";\n    private final Set<String> commandWhitelist = new HashSet<>();\n\n    @Activate\n    public ExecWhitelistWatchService() {\n        super(COMMAND_WHITELIST_PATH);\n    }\n\n    @Override\n    protected boolean watchSubDirectories() {\n        return false;\n    }\n\n    @Override\n    protected WatchEvent.Kind<?>[] getWatchEventKinds(@Nullable Path directory) {\n        return new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };\n    }\n\n    @Override\n    protected void processWatchEvent(@Nullable WatchEvent<?> event,  WatchEvent.@Nullable Kind<?> kind, @Nullable Path path) {\n        if (path.endsWith(COMMAND_WHITELIST_FILE)) {\n            commandWhitelist.clear();\n            try  {\n                Files.lines(path).forEach(commandWhitelist::add);\n                logger.debug(\"Updated command whitelist: {}\", commandWhitelist);\n            } catch (IOException e) {\n                logger.warn(\"Cannot read whitelist file, exec binding commands won't be processed: {}\", e.getMessage());\n            }\n        }\n    }\n\n    /**\n     * Check if a command is whitelisted\n     *\n     * @param command the command to check alias\n     * @return true if whitelisted, false if not\n     */\n    public boolean isWhitelisted(String command) {\n        return commandWhitelist.contains(command);\n    }\n}\n", "target": 0}
{"idx": 976, "func": "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.util;\n\nimport org.apache.commons.codec.digest.DigestUtils;\n\n/**\n * A password encoder that md5 hashes a password with a salt.\n */\npublic final class PasswordEncoder {\n\n  /**\n   * Private constructor to disallow construction of this utility class.\n   */\n  private PasswordEncoder() {\n  }\n\n  /**\n   * Encode a clear text password.\n   *\n   * @param clearText\n   *          the password\n   * @param salt\n   *          the salt. See http://en.wikipedia.org/wiki/Salt_%28cryptography%29\n   * @return the encoded password\n   * @throws IllegalArgumentException\n   *           if clearText or salt are null\n   */\n  public static String encode(String clearText, Object salt) throws IllegalArgumentException {\n    if (clearText == null || salt == null)\n      throw new IllegalArgumentException(\"clearText and salt must not be null\");\n    return DigestUtils.md5Hex(clearText + \"{\" + salt.toString() + \"}\");\n  }\n\n}\n", "target": 0}
{"idx": 977, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.security;\n\nimport groovy.lang.Binding;\nimport hudson.ExtensionPoint;\nimport hudson.DescriptorExtensionList;\nimport hudson.Extension;\nimport hudson.cli.CLICommand;\nimport hudson.model.AbstractDescribableImpl;\nimport hudson.model.Descriptor;\nimport jenkins.model.Jenkins;\nimport hudson.security.FederatedLoginService.FederatedIdentity;\nimport hudson.security.captcha.CaptchaSupport;\nimport hudson.util.DescriptorList;\nimport hudson.util.PluginServletFilter;\nimport hudson.util.spring.BeanBuilder;\nimport org.acegisecurity.Authentication;\nimport org.acegisecurity.AuthenticationManager;\nimport org.acegisecurity.GrantedAuthorityImpl;\nimport org.acegisecurity.GrantedAuthority;\nimport org.acegisecurity.context.SecurityContext;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.acegisecurity.ui.rememberme.RememberMeServices;\nimport static org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY;\nimport org.acegisecurity.userdetails.UserDetailsService;\nimport org.acegisecurity.userdetails.UserDetails;\nimport org.acegisecurity.userdetails.UsernameNotFoundException;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.dao.DataAccessException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpSession;\nimport javax.servlet.http.Cookie;\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Pluggable security realm that connects external user database to Hudson.\n *\n * <p>\n * If additional views/URLs need to be exposed,\n * an active {@link SecurityRealm} is bound to <tt>CONTEXT_ROOT/securityRealm/</tt>\n * through {@link jenkins.model.Jenkins#getSecurityRealm()}, so you can define additional pages and\n * operations on your {@link SecurityRealm}.\n *\n * <h2>How do I implement this class?</h2>\n * <p>\n * For compatibility reasons, there are two somewhat different ways to implement a custom SecurityRealm.\n *\n * <p>\n * One is to override the {@link #createSecurityComponents()} and create key Acegi components\n * that control the authentication process.\n * The default {@link SecurityRealm#createFilter(FilterConfig)} implementation then assembles them\n * into a chain of {@link Filter}s. All the incoming requests to Hudson go through this filter chain,\n * and when the filter chain is done, {@link SecurityContext#getAuthentication()} would tell us\n * who the current user is.\n *\n * <p>\n * If your {@link SecurityRealm} needs to touch the default {@link Filter} chain configuration\n * (e.g., adding new ones), then you can also override {@link #createFilter(FilterConfig)} to do so.\n *\n * <p>\n * This model is expected to fit most {@link SecurityRealm} implementations.\n *\n *\n * <p>\n * The other way of doing this is to ignore {@link #createSecurityComponents()} completely (by returning\n * {@link SecurityComponents} created by the default constructor) and just concentrate on {@link #createFilter(FilterConfig)}.\n * As long as the resulting filter chain properly sets up {@link Authentication} object at the end of the processing,\n * Hudson doesn't really need you to fit the standard Acegi models like {@link AuthenticationManager} and\n * {@link UserDetailsService}.\n *\n * <p>\n * This model is for those \"weird\" implementations.\n *\n *\n * <h2>Views</h2>\n * <dl>\n * <dt>loginLink.jelly</dt>\n * <dd>\n * This view renders the login link on the top right corner of every page, when the user\n * is anonymous. For {@link SecurityRealm}s that support user sign-up, this is a good place\n * to show a \"sign up\" link. See {@link HudsonPrivateSecurityRealm} implementation\n * for an example of this.\n *\n * <dt>config.jelly</dt>\n * <dd>\n * This view is used to render the configuration page in the system config screen.\n * </dl>\n *\n * @author Kohsuke Kawaguchi\n * @since 1.160\n * @see PluginServletFilter\n */\npublic abstract class SecurityRealm extends AbstractDescribableImpl<SecurityRealm> implements ExtensionPoint {\n    /**\n     * Captcha Support to be used with this SecurityRealm for User Signup\n     */\n    private CaptchaSupport captchaSupport;\n\n    /**\n     * Creates fully-configured {@link AuthenticationManager} that performs authentication\n     * against the user realm. The implementation hides how such authentication manager\n     * is configured.\n     *\n     * <p>\n     * {@link AuthenticationManager} instantiation often depends on the user-specified parameters\n     * (for example, if the authentication is based on LDAP, the user needs to specify\n     * the host name of the LDAP server.) Such configuration is expected to be\n     * presented to the user via <tt>config.jelly</tt> and then\n     * captured as instance variables inside the {@link SecurityRealm} implementation.\n     *\n     * <p>\n     * Your {@link SecurityRealm} may also wants to alter {@link Filter} set up by\n     * overriding {@link #createFilter(FilterConfig)}.\n     */\n    public abstract SecurityComponents createSecurityComponents();\n\n    /**\n     * Creates a {@link CliAuthenticator} object that authenticates an invocation of a CLI command.\n     * See {@link CliAuthenticator} for more details.\n     *\n     * @param command\n     *      The command about to be executed.\n     * @return\n     *      never null. By default, this method returns a no-op authenticator that always authenticates\n     *      the session as authenticated by the transport (which is often just {@link jenkins.model.Jenkins#ANONYMOUS}.)\n     */\n    public CliAuthenticator createCliAuthenticator(final CLICommand command) {\n        return new CliAuthenticator() {\n            public Authentication authenticate() {\n                return command.getTransportAuthentication();\n            }\n        };\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>\n     * {@link SecurityRealm} is a singleton resource in Hudson, and therefore\n     * it's always configured through <tt>config.jelly</tt> and never with\n     * <tt>global.jelly</tt>. \n     */\n    public Descriptor<SecurityRealm> getDescriptor() {\n        return super.getDescriptor();\n    }\n\n    /**\n     * Returns the URL to submit a form for the authentication.\n     * There's no need to override this, except for {@link LegacySecurityRealm}.\n     */\n    public String getAuthenticationGatewayUrl() {\n        return \"j_acegi_security_check\";\n    }\n\n    /**\n     * Gets the target URL of the \"login\" link.\n     * There's no need to override this, except for {@link LegacySecurityRealm}.\n     * On legacy implementation this should point to {@code loginEntry}, which\n     * is protected by <tt>web.xml</tt>, so that the user can be eventually authenticated\n     * by the container.\n     *\n     * <p>\n     * Path is relative from the context root of the Hudson application.\n     * The URL returned by this method will get the \"from\" query parameter indicating\n     * the page that the user was at.\n     */\n    public String getLoginUrl() {\n        return \"login\";\n    }\n\n    /**\n     * Returns true if this {@link SecurityRealm} supports explicit logout operation.\n     *\n     * <p>\n     * If the method returns false, \"logout\" link will not be displayed. This is useful\n     * when authentication doesn't require an explicit login activity (such as NTLM authentication\n     * or Kerberos authentication, where Hudson has no ability to log off the current user.)\n     *\n     * <p>\n     * By default, this method returns true.\n     *\n     * @since 1.307\n     */\n    public boolean canLogOut() {\n        return true;\n    }\n\n    /**\n     * Controls where the user is sent to after a logout. By default, it's the top page\n     * of Hudson, but you can return arbitrary URL.\n     *\n     * @param req\n     *      {@link StaplerRequest} that represents the current request. Primarily so that\n     *      you can get the context path. By the time this method is called, the session\n     *      is already invalidated. Never null.\n     * @param auth\n     *      The {@link Authentication} object that represents the user that was logging in.\n     *      This parameter allows you to redirect people to different pages depending on who they are.\n     * @return\n     *      never null.\n     * @since 1.314\n     * @see #doLogout(StaplerRequest, StaplerResponse) \n     */\n    protected String getPostLogOutUrl(StaplerRequest req, Authentication auth) {\n        return req.getContextPath()+\"/\";\n    }\n\n    public CaptchaSupport getCaptchaSupport() {\n        return captchaSupport;\n    }\n\n    public void setCaptchaSupport(CaptchaSupport captchaSupport) {\n        this.captchaSupport = captchaSupport;\n    }\n\n    public List<Descriptor<CaptchaSupport>> getCaptchaSupportDescriptors() {\n        return CaptchaSupport.all();\n    }\n\n    /**\n     * Handles the logout processing.\n     *\n     * <p>\n     * The default implementation erases the session and do a few other clean up, then\n     * redirect the user to the URL specified by {@link #getPostLogOutUrl(StaplerRequest, Authentication)}.\n     *\n     * @since 1.314\n     */\n    public void doLogout(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        HttpSession session = req.getSession(false);\n        if(session!=null)\n            session.invalidate();\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        SecurityContextHolder.clearContext();\n\n        // reset remember-me cookie\n        Cookie cookie = new Cookie(ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY,\"\");\n        cookie.setPath(req.getContextPath().length()>0 ? req.getContextPath() : \"/\");\n        rsp.addCookie(cookie);\n\n        rsp.sendRedirect2(getPostLogOutUrl(req,auth));\n    }\n\n    /**\n     * Returns true if this {@link SecurityRealm} allows online sign-up.\n     * This creates a hyperlink that redirects users to <tt>CONTEXT_ROOT/signUp</tt>,\n     * which will be served by the <tt>signup.jelly</tt> view of this class.\n     *\n     * <p>\n     * If the implementation needs to redirect the user to a different URL\n     * for signing up, use the following jelly script as <tt>signup.jelly</tt>\n     *\n     * <pre><xmp>\n     * <st:redirect url=\"http://www.sun.com/\" xmlns:st=\"jelly:stapler\"/>\n     * </xmp></pre>\n     */\n    public boolean allowsSignup() {\n        Class clz = getClass();\n        return clz.getClassLoader().getResource(clz.getName().replace('.','/')+\"/signup.jelly\")!=null;\n    }\n\n    /**\n     * Shortcut for {@link UserDetailsService#loadUserByUsername(String)}.\n     *\n     * @throws UserMayOrMayNotExistException\n     *      If the security realm cannot even tell if the user exists or not.\n     * @return\n     *      never null.\n     */\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException, DataAccessException {\n        return getSecurityComponents().userDetails.loadUserByUsername(username);\n    }\n\n    /**\n     * If this {@link SecurityRealm} supports a look up of {@link GroupDetails} by their names, override this method\n     * to provide the look up.\n     *\n     * <p>\n     * This information, when available, can be used by {@link AuthorizationStrategy}s to improve the UI and\n     * error diagnostics for the user.\n     */\n    public GroupDetails loadGroupByGroupname(String groupname) throws UsernameNotFoundException, DataAccessException {\n        throw new UserMayOrMayNotExistException(groupname);\n    }\n\n    /**\n     * Starts the user registration process for a new user that has the given verified identity.\n     *\n     * <p>\n     * If the user logs in through a {@link FederatedLoginService}, verified that the current user\n     * owns an {@linkplain FederatedIdentity identity}, but no existing user account has claimed that identity,\n     * then this method is invoked.\n     *\n     * <p>\n     * The expected behaviour is to confirm that the user would like to create a new account, and\n     * associate this federated identity to the newly created account (via {@link FederatedIdentity#addToCurrentUser()}.\n     *\n     * @throws UnsupportedOperationException\n     *      If this implementation doesn't support the signup through this mechanism.\n     *      This is the default implementation.\n     *\n     * @since 1.394\n     */\n    public HttpResponse commenceSignup(FederatedIdentity identity) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Generates a captcha image.\n     */\n    public final void doCaptcha(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        if (captchaSupport != null) {\n            String id = req.getSession().getId();\n            rsp.setContentType(\"image/png\");\n            rsp.addHeader(\"Cache-Control\", \"no-cache\");\n            captchaSupport.generateImage(id, rsp.getOutputStream());\n        }\n    }\n\n    /**\n     * Validates the captcha.\n     */\n    protected final boolean validateCaptcha(String text) {\n        if (captchaSupport != null) {\n            String id = Stapler.getCurrentRequest().getSession().getId();\n            return captchaSupport.validateCaptcha(id, text);\n        }\n\n        // If no Captcha Support then bogus validation always returns true\n        return true;\n    }\n\n    /**\n     * Picks up the instance of the given type from the spring context.\n     * If there are multiple beans of the same type or if there are none,\n     * this method treats that as an {@link IllegalArgumentException}.\n     *\n     * This method is intended to be used to pick up a Acegi object from\n     * spring once the bean definition file is parsed.\n     */\n    public static <T> T findBean(Class<T> type, ApplicationContext context) {\n        Map m = context.getBeansOfType(type);\n        switch(m.size()) {\n        case 0:\n            throw new IllegalArgumentException(\"No beans of \"+type+\" are defined\");\n        case 1:\n            return type.cast(m.values().iterator().next());\n        default:\n            throw new IllegalArgumentException(\"Multiple beans of \"+type+\" are defined: \"+m);            \n        }\n    }\n\n    /**\n     * Holder for the SecurityComponents.\n     */\n    private transient SecurityComponents securityComponents;\n\n    /**\n     * Use this function to get the security components, without necessarily\n     * recreating them.\n     */\n    public synchronized SecurityComponents getSecurityComponents() {\n        if (this.securityComponents == null) {\n            this.securityComponents = this.createSecurityComponents();\n        }\n        return this.securityComponents;\n    }\n\n    /**\n     * Creates {@link Filter} that all the incoming HTTP requests will go through\n     * for authentication.\n     *\n     * <p>\n     * The default implementation uses {@link #getSecurityComponents()} and builds\n     * a standard filter chain from /WEB-INF/security/SecurityFilters.groovy.\n     * But subclasses can override this to completely change the filter sequence.\n     *\n     * <p>\n     * For other plugins that want to contribute {@link Filter}, see\n     * {@link PluginServletFilter}.\n     *\n     * @since 1.271\n     */\n    public Filter createFilter(FilterConfig filterConfig) {\n        LOGGER.entering(SecurityRealm.class.getName(), \"createFilter\");\n        \n        Binding binding = new Binding();\n        SecurityComponents sc = getSecurityComponents();\n        binding.setVariable(\"securityComponents\", sc);\n        binding.setVariable(\"securityRealm\",this);\n        BeanBuilder builder = new BeanBuilder();\n        builder.parse(filterConfig.getServletContext().getResourceAsStream(\"/WEB-INF/security/SecurityFilters.groovy\"),binding);\n        WebApplicationContext context = builder.createApplicationContext();\n        return (Filter) context.getBean(\"filter\");\n    }\n\n    /**\n     * Singleton constant that represents \"no authentication.\"\n     */\n    public static final SecurityRealm NO_AUTHENTICATION = new None();\n\n    private static class None extends SecurityRealm {\n        public SecurityComponents createSecurityComponents() {\n            return new SecurityComponents(new AuthenticationManager() {\n                public Authentication authenticate(Authentication authentication) {\n                    return authentication;\n                }\n            }, new UserDetailsService() {\n                public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException, DataAccessException {\n                    throw new UsernameNotFoundException(username);\n                }\n            });\n        }\n\n        /**\n         * This special instance is not configurable explicitly,\n         * so it doesn't have a descriptor.\n         */\n        @Override\n        public Descriptor<SecurityRealm> getDescriptor() {\n            return null;\n        }\n\n        /**\n         * There's no group.\n         */\n        @Override\n        public GroupDetails loadGroupByGroupname(String groupname) throws UsernameNotFoundException, DataAccessException {\n            throw new UsernameNotFoundException(groupname);\n        }\n\n        /**\n         * We don't need any filter for this {@link SecurityRealm}.\n         */\n        @Override\n        public Filter createFilter(FilterConfig filterConfig) {\n            return new ChainedServletFilter();\n        }\n\n        /**\n         * Maintain singleton semantics.\n         */\n        private Object readResolve() {\n            return NO_AUTHENTICATION;\n        }\n    }\n\n    /**\n     * Just a tuple so that we can create various inter-related security related objects and\n     * return them all at once.\n     *\n     * <p>\n     * None of the fields are ever null.\n     *\n     * @see SecurityRealm#createSecurityComponents() \n     */\n    public static final class SecurityComponents {\n        public final AuthenticationManager manager;\n        public final UserDetailsService userDetails;\n        public final RememberMeServices rememberMe;\n\n        public SecurityComponents() {\n            // we use AuthenticationManagerProxy here just as an implementation that fails all the time,\n            // not as a proxy. No one is supposed to use this as a proxy.\n            this(new AuthenticationManagerProxy());\n        }\n\n        public SecurityComponents(AuthenticationManager manager) {\n            // we use UserDetailsServiceProxy here just as an implementation that fails all the time,\n            // not as a proxy. No one is supposed to use this as a proxy.\n            this(manager,new UserDetailsServiceProxy());\n        }\n\n        public SecurityComponents(AuthenticationManager manager, UserDetailsService userDetails) {\n            this(manager,userDetails,createRememberMeService(userDetails));\n        }\n\n        public SecurityComponents(AuthenticationManager manager, UserDetailsService userDetails, RememberMeServices rememberMe) {\n            assert manager!=null && userDetails!=null && rememberMe!=null;\n            this.manager = manager;\n            this.userDetails = userDetails;\n            this.rememberMe = rememberMe;\n        }\n\n        private static RememberMeServices createRememberMeService(UserDetailsService uds) {\n            // create our default TokenBasedRememberMeServices, which depends on the availability of the secret key\n            TokenBasedRememberMeServices2 rms = new TokenBasedRememberMeServices2();\n            rms.setUserDetailsService(uds);\n            rms.setKey(Jenkins.getInstance().getSecretKey());\n            rms.setParameter(\"remember_me\"); // this is the form field name in login.jelly\n            return rms;\n        }\n    }\n\n    /**\n     * All registered {@link SecurityRealm} implementations.\n     *\n     * @deprecated as of 1.286\n     *      Use {@link #all()} for read access, and use {@link Extension} for registration.\n     */\n    public static final DescriptorList<SecurityRealm> LIST = new DescriptorList<SecurityRealm>(SecurityRealm.class);\n\n    /**\n     * Returns all the registered {@link SecurityRealm} descriptors.\n     */\n    public static DescriptorExtensionList<SecurityRealm,Descriptor<SecurityRealm>> all() {\n        return Jenkins.getInstance().<SecurityRealm,Descriptor<SecurityRealm>>getDescriptorList(SecurityRealm.class);\n    }\n\n\n    private static final Logger LOGGER = Logger.getLogger(SecurityRealm.class.getName());\n\n    /**\n     * {@link GrantedAuthority} that represents the built-in \"authenticated\" role, which is granted to\n     * anyone non-anonymous.\n     */\n    public static final GrantedAuthority AUTHENTICATED_AUTHORITY = new GrantedAuthorityImpl(\"authenticated\");\n}\n", "target": 1}
{"idx": 978, "func": "/**\n * Copyright (c) 2000-2012 Liferay, Inc. All rights reserved.\n *\n * This library is free software; you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation; either version 2.1 of the License, or (at your option)\n * any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n */\n\npackage com.liferay.portal.freemarker;\n\nimport com.liferay.portal.kernel.templateparser.TemplateContext;\nimport com.liferay.portal.kernel.util.GetterUtil;\nimport com.liferay.portal.kernel.util.SetUtil;\nimport com.liferay.portal.kernel.util.StringPool;\nimport com.liferay.portal.kernel.util.Validator;\nimport com.liferay.portal.model.Theme;\nimport com.liferay.portal.template.TemplateContextHelper;\nimport com.liferay.portal.template.TemplatePortletPreferences;\nimport com.liferay.portal.theme.ThemeDisplay;\nimport com.liferay.portal.util.PropsValues;\nimport com.liferay.portal.util.WebKeys;\n\nimport freemarker.ext.beans.BeansWrapper;\n\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * @author Mika Koivisto\n * @author Raymond Aug\n */\npublic class FreeMarkerTemplateContextHelper extends TemplateContextHelper {\n\n\t@Override\n\tpublic Map<String, Object> getHelperUtilities() {\n\t\tMap<String, Object> helperUtilities = super.getHelperUtilities();\n\n\t\t// Enum util\n\n\t\thelperUtilities.put(\n\t\t\t\"enumUtil\", BeansWrapper.getDefaultInstance().getEnumModels());\n\n\t\t// Object util\n\n\t\thelperUtilities.put(\"objectUtil\", new LiferayObjectConstructor());\n\n\t\t// Portlet preferences\n\n\t\thelperUtilities.put(\n\t\t\t\"freeMarkerPortletPreferences\", new TemplatePortletPreferences());\n\n\t\t// Static class util\n\n\t\thelperUtilities.put(\n\t\t\t\"staticUtil\", BeansWrapper.getDefaultInstance().getStaticModels());\n\n\t\treturn helperUtilities;\n\t}\n\n\t@Override\n\tpublic Set<String> getRestrictedVariables() {\n\t\treturn SetUtil.fromArray(\n\t\t\tPropsValues.JOURNAL_TEMPLATE_FREEMARKER_RESTRICTED_VARIABLES);\n\t}\n\n\t@Override\n\tpublic void prepare(\n\t\tTemplateContext templateContext, HttpServletRequest request) {\n\n\t\tsuper.prepare(templateContext, request);\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (themeDisplay != null) {\n\t\t\tTheme theme = themeDisplay.getTheme();\n\n\t\t\t// Full css and templates path\n\n\t\t\tString servletContextName = GetterUtil.getString(\n\t\t\t\ttheme.getServletContextName());\n\n\t\t\ttemplateContext.put(\n\t\t\t\t\"fullCssPath\",\n\t\t\t\tStringPool.SLASH + servletContextName +\n\t\t\t\t\ttheme.getFreeMarkerTemplateLoader() + theme.getCssPath());\n\n\t\t\ttemplateContext.put(\n\t\t\t\t\"fullTemplatesPath\",\n\t\t\t\tStringPool.SLASH + servletContextName +\n\t\t\t\t\ttheme.getFreeMarkerTemplateLoader() +\n\t\t\t\t\t\ttheme.getTemplatesPath());\n\n\t\t\t// Init\n\n\t\t\ttemplateContext.put(\n\t\t\t\t\"init\",\n\t\t\t\tStringPool.SLASH + themeDisplay.getPathContext() +\n\t\t\t\t\tFreeMarkerTemplateLoader.SERVLET_SEPARATOR +\n\t\t\t\t\t\t\"/html/themes/_unstyled/templates/init.ftl\");\n\t\t}\n\n\t\t// Insert custom ftl variables\n\n\t\tMap<String, Object> ftlVariables =\n\t\t\t(Map<String, Object>)request.getAttribute(WebKeys.FTL_VARIABLES);\n\n\t\tif (ftlVariables != null) {\n\t\t\tfor (Map.Entry<String, Object> entry : ftlVariables.entrySet()) {\n\t\t\t\tString key = entry.getKey();\n\t\t\t\tObject value = entry.getValue();\n\n\t\t\t\tif (Validator.isNotNull(key)) {\n\t\t\t\t\ttemplateContext.put(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}", "target": 0}
{"idx": 979, "func": "/*\n * JBoss, Home of Professional Open Source\n * Copyright 2013, Red Hat, Inc., and individual contributors\n * by the @authors tag. See the copyright.txt in the distribution for a\n * full listing of individual contributors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jboss.weld.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletRequestListener;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\n\nimport org.jboss.weld.Container;\nimport org.jboss.weld.bootstrap.api.Service;\nimport org.jboss.weld.context.cache.RequestScopedCache;\nimport org.jboss.weld.context.http.HttpRequestContext;\nimport org.jboss.weld.context.http.HttpRequestContextImpl;\nimport org.jboss.weld.context.http.HttpSessionContext;\nimport org.jboss.weld.context.http.HttpSessionDestructionContext;\nimport org.jboss.weld.event.FastEvent;\nimport org.jboss.weld.literal.DestroyedLiteral;\nimport org.jboss.weld.literal.InitializedLiteral;\nimport org.jboss.weld.logging.ServletLogger;\nimport org.jboss.weld.manager.BeanManagerImpl;\nimport org.jboss.weld.servlet.spi.HttpContextActivationFilter;\nimport org.jboss.weld.util.reflection.Reflections;\n\n/**\n * Takes care of setting up and tearing down CDI contexts around an HTTP request and dispatching context lifecycle events.\n *\n * @author Jozef Hartinger\n * @author Marko Luksa\n *\n */\npublic class HttpContextLifecycle implements Service {\n\n    private static final String HTTP_SESSION = \"org.jboss.weld.\" + HttpSession.class.getName();\n\n    private static final String INCLUDE_HEADER = \"javax.servlet.include.request_uri\";\n    private static final String FORWARD_HEADER = \"javax.servlet.forward.request_uri\";\n    private static final String REQUEST_DESTROYED = HttpContextLifecycle.class.getName() + \".request.destroyed\";\n\n    private static final String GUARD_PARAMETER_NAME = \"org.jboss.weld.context.ignore.guard.marker\";\n    private static final Object GUARD_PARAMETER_VALUE = new Object();\n\n    private HttpSessionDestructionContext sessionDestructionContextCache;\n    private HttpSessionContext sessionContextCache;\n    private HttpRequestContext requestContextCache;\n\n    private volatile Boolean conversationActivationEnabled;\n    private final boolean ignoreForwards;\n    private final boolean ignoreIncludes;\n\n    private final BeanManagerImpl beanManager;\n    private final ConversationContextActivator conversationContextActivator;\n    private final HttpContextActivationFilter contextActivationFilter;\n\n    private final FastEvent<ServletContext> applicationInitializedEvent;\n    private final FastEvent<ServletContext> applicationDestroyedEvent;\n    private final FastEvent<HttpServletRequest> requestInitializedEvent;\n    private final FastEvent<HttpServletRequest> requestDestroyedEvent;\n    private final FastEvent<HttpSession> sessionInitializedEvent;\n    private final FastEvent<HttpSession> sessionDestroyedEvent;\n\n    private final ServletApiAbstraction servletApi;\n\n    private final ServletContextService servletContextService;\n\n    private final Container container;\n\n    private static final ThreadLocal<Counter> nestedInvocationGuard = new ThreadLocal<HttpContextLifecycle.Counter>();\n    private final boolean nestedInvocationGuardEnabled;\n\n    private static class Counter {\n        private int value = 1;\n    }\n\n    public HttpContextLifecycle(BeanManagerImpl beanManager, HttpContextActivationFilter contextActivationFilter, boolean ignoreForwards, boolean ignoreIncludes, boolean lazyConversationContext, boolean nestedInvocationGuardEnabled) {\n        this.beanManager = beanManager;\n        this.conversationContextActivator = new ConversationContextActivator(beanManager, lazyConversationContext);\n        this.conversationActivationEnabled = null;\n        this.ignoreForwards = ignoreForwards;\n        this.ignoreIncludes = ignoreIncludes;\n        this.contextActivationFilter = contextActivationFilter;\n        this.applicationInitializedEvent = FastEvent.of(ServletContext.class, beanManager, InitializedLiteral.APPLICATION);\n        this.applicationDestroyedEvent = FastEvent.of(ServletContext.class, beanManager, DestroyedLiteral.APPLICATION);\n        this.requestInitializedEvent = FastEvent.of(HttpServletRequest.class, beanManager, InitializedLiteral.REQUEST);\n        this.requestDestroyedEvent = FastEvent.of(HttpServletRequest.class, beanManager, DestroyedLiteral.REQUEST);\n        this.sessionInitializedEvent = FastEvent.of(HttpSession.class, beanManager, InitializedLiteral.SESSION);\n        this.sessionDestroyedEvent = FastEvent.of(HttpSession.class, beanManager, DestroyedLiteral.SESSION);\n        this.servletApi = beanManager.getServices().get(ServletApiAbstraction.class);\n        this.servletContextService = beanManager.getServices().get(ServletContextService.class);\n        this.nestedInvocationGuardEnabled = nestedInvocationGuardEnabled;\n        this.container = Container.instance(beanManager);\n    }\n\n    private HttpSessionDestructionContext getSessionDestructionContext() {\n        if (sessionDestructionContextCache == null) {\n            this.sessionDestructionContextCache = beanManager.instance().select(HttpSessionDestructionContext.class).get();\n        }\n        return sessionDestructionContextCache;\n    }\n\n    private HttpSessionContext getSessionContext() {\n        if (sessionContextCache == null) {\n            this.sessionContextCache = beanManager.instance().select(HttpSessionContext.class).get();\n        }\n        return sessionContextCache;\n    }\n\n    public HttpRequestContext getRequestContext() {\n        if (requestContextCache == null) {\n            this.requestContextCache = beanManager.instance().select(HttpRequestContext.class).get();\n        }\n        return requestContextCache;\n    }\n\n    public void contextInitialized(ServletContext ctx) {\n        servletContextService.contextInitialized(ctx);\n        synchronized (container) {\n            applicationInitializedEvent.fire(ctx);\n        }\n    }\n\n    public void contextDestroyed(ServletContext ctx) {\n        synchronized (container) {\n            applicationDestroyedEvent.fire(ctx);\n        }\n    }\n\n    public void sessionCreated(HttpSession session) {\n        SessionHolder.sessionCreated(session);\n        conversationContextActivator.sessionCreated(session);\n        sessionInitializedEvent.fire(session);\n    }\n\n    public void sessionDestroyed(HttpSession session) {\n        // Mark the session context and conversation contexts to destroy\n        // instances when appropriate\n        deactivateSessionDestructionContext(session);\n        boolean destroyed = getSessionContext().destroy(session);\n        SessionHolder.clear();\n        RequestScopedCache.endRequest();\n        if (destroyed) {\n            // we are outside of a request (the session timed out) and therefore the session was destroyed immediately\n            // we can fire the @Destroyed(SessionScoped.class) event immediately\n            sessionDestroyedEvent.fire(session);\n        } else {\n            // the old session won't be available at the time we destroy this request\n            // let's store its reference until then\n            if (getRequestContext() instanceof HttpRequestContextImpl) {\n                HttpServletRequest request = Reflections.<HttpRequestContextImpl> cast(getRequestContext()).getHttpServletRequest();\n                request.setAttribute(HTTP_SESSION, session);\n            }\n        }\n    }\n\n    private void deactivateSessionDestructionContext(HttpSession session) {\n        HttpSessionDestructionContext context = getSessionDestructionContext();\n        if (context.isActive()) {\n            context.deactivate();\n            context.dissociate(session);\n        }\n    }\n\n    public void requestInitialized(HttpServletRequest request, ServletContext ctx) {\n        if (nestedInvocationGuardEnabled) {\n            Counter counter = nestedInvocationGuard.get();\n            Object marker = request.getAttribute(GUARD_PARAMETER_NAME);\n            if (counter != null && marker != null) {\n                // this is a nested invocation, increment the counter and ignore this invocation\n                counter.value++;\n                return;\n            } else {\n                if (counter != null && marker == null) {\n                    /*\n                     * This request has not been processed yet but the guard is set already.\n                     * That indicates, that the guard leaked from a previous request processing - most likely\n                     * the Servlet container did not invoke listener methods symmetrically.\n                     * Log a warning and recover by re-initializing the guard\n                     */\n                    ServletLogger.LOG.guardLeak(counter.value);\n                }\n                // this is the initial (outer) invocation\n                nestedInvocationGuard.set(new Counter());\n                request.setAttribute(GUARD_PARAMETER_NAME, GUARD_PARAMETER_VALUE);\n            }\n        }\n        if (ignoreForwards && isForwardedRequest(request)) {\n            return;\n        }\n        if (ignoreIncludes && isIncludedRequest(request)) {\n            return;\n        }\n        if (!contextActivationFilter.accepts(request)) {\n            return;\n        }\n\n        ServletLogger.LOG.requestInitialized(request);\n\n        SessionHolder.requestInitialized(request);\n\n        getRequestContext().associate(request);\n        getSessionContext().associate(request);\n        if (conversationActivationEnabled) {\n            conversationContextActivator.associateConversationContext(request);\n        }\n\n        getRequestContext().activate();\n        getSessionContext().activate();\n\n        try {\n            if (conversationActivationEnabled) {\n                conversationContextActivator.activateConversationContext(request);\n            }\n            requestInitializedEvent.fire(request);\n        } catch (RuntimeException e) {\n            try {\n                requestDestroyed(request);\n            } catch (Exception ignored) {\n                // ignored in order to let the original exception be thrown\n            }\n            /*\n             * If the servlet container happens to call the destroyed callback again, ignore it.\n             */\n            request.setAttribute(REQUEST_DESTROYED, Boolean.TRUE);\n            throw e;\n        }\n    }\n\n    public void requestDestroyed(HttpServletRequest request) {\n        if (isRequestDestroyed(request)) {\n            return;\n        }\n        if (nestedInvocationGuardEnabled) {\n            Counter counter = nestedInvocationGuard.get();\n            if (counter != null) {\n                counter.value--;\n                if (counter.value > 0) {\n                    return; // this is a nested invocation, ignore it\n                } else {\n                    nestedInvocationGuard.remove(); // this is the outer invocation\n                    request.removeAttribute(GUARD_PARAMETER_NAME);\n                }\n            } else {\n                ServletLogger.LOG.guardNotSet();\n                return;\n            }\n        }\n        if (ignoreForwards && isForwardedRequest(request)) {\n            return;\n        }\n        if (ignoreIncludes && isIncludedRequest(request)) {\n            return;\n        }\n        if (!contextActivationFilter.accepts(request)) {\n            return;\n        }\n\n        ServletLogger.LOG.requestDestroyed(request);\n\n        try {\n            conversationContextActivator.deactivateConversationContext(request);\n            /*\n             * if this request has been switched to async then do not invalidate the context now\n             * as it will be invalidated at the end of the async operation.\n             */\n            if (!servletApi.isAsyncSupported() || !servletApi.isAsyncStarted(request)) {\n                getRequestContext().invalidate();\n            }\n            getRequestContext().deactivate();\n            // fire @Destroyed(RequestScoped.class)\n            requestDestroyedEvent.fire(request);\n            getSessionContext().deactivate();\n            // fire @Destroyed(SessionScoped.class)\n            if (!getSessionContext().isValid()) {\n                sessionDestroyedEvent.fire((HttpSession) request.getAttribute(HTTP_SESSION));\n            }\n        } finally {\n            getRequestContext().dissociate(request);\n\n            // WFLY-1533 Underlying HTTP session may be invalid\n            try {\n                getSessionContext().dissociate(request);\n            } catch (Exception e) {\n                ServletLogger.LOG.unableToDissociateContext(getSessionContext(), request);\n                ServletLogger.LOG.catchingDebug(e);\n            }\n            // Catch block is inside the activator method so that we're able to log the context\n            conversationContextActivator.disassociateConversationContext(request);\n\n            SessionHolder.clear();\n        }\n    }\n\n    public boolean isConversationActivationSet() {\n        return conversationActivationEnabled != null;\n    }\n\n    public void setConversationActivationEnabled(boolean conversationActivationEnabled) {\n        this.conversationActivationEnabled = conversationActivationEnabled;\n    }\n\n    /**\n     * Some Servlet containers fire HttpServletListeners for include requests (inner requests caused by calling the include method of RequestDispatcher). This\n     * causes problems with context shut down as context manipulation is not reentrant. This method detects if this request is an included request or not.\n     */\n    private boolean isIncludedRequest(HttpServletRequest request) {\n        return request.getAttribute(INCLUDE_HEADER) != null;\n    }\n\n    /**\n     * Some Servlet containers fire HttpServletListeners for forward requests (inner requests caused by calling the forward method of RequestDispatcher). This\n     * causes problems with context shut down as context manipulation is not reentrant. This method detects if this request is an forwarded request or not.\n     */\n    private boolean isForwardedRequest(HttpServletRequest request) {\n        return request.getAttribute(FORWARD_HEADER) != null;\n    }\n\n    /**\n     * The way servlet containers react to an exception that occurs in a {@link ServletRequestListener} differs among servlet listeners. In certain containers\n     * the destroyed callback may be invoked multiple times, causing the latter invocations to fail as thread locals have already been unset. We use the\n     * {@link #REQUEST_DESTROYED} flag to indicate that all further invocations of the\n     * {@link ServletRequestListener#requestDestroyed(javax.servlet.ServletRequestEvent)} should be ignored by Weld.\n     */\n    private boolean isRequestDestroyed(HttpServletRequest request) {\n        return request.getAttribute(REQUEST_DESTROYED) != null;\n    }\n\n    @Override\n    public void cleanup() {\n    }\n}\n", "target": 1}
{"idx": 980, "func": "/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.mechanisms.jaspic;\n\nimport java.util.Map;\nimport java.util.function.Supplier;\n\nimport javax.security.auth.Subject;\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.message.AuthException;\nimport javax.security.auth.message.MessageInfo;\nimport javax.security.auth.message.config.ServerAuthConfig;\nimport javax.security.auth.message.config.ServerAuthContext;\nimport javax.security.auth.message.module.ServerAuthModule;\n\n/**\n * This class functions as a kind of factory for {@link ServerAuthContext} instances, which are delegates for the actual\n * {@link ServerAuthModule} (SAM) that we're after.\n *\n * @author Arjan Tijms\n */\npublic class DefaultServerAuthConfig implements ServerAuthConfig {\n\n    private String layer;\n    private String appContext;\n    private CallbackHandler handler;\n    private Map<String, String> providerProperties;\n    private Supplier<ServerAuthModule> serverAuthModuleSupplier;\n\n    public DefaultServerAuthConfig(String layer, String appContext, CallbackHandler handler,\n        Map<String, String> providerProperties, Supplier<ServerAuthModule> serverAuthModuleSupplier) {\n        this.layer = layer;\n        this.appContext = appContext;\n        this.handler = handler;\n        this.providerProperties = providerProperties;\n        this.serverAuthModuleSupplier = serverAuthModuleSupplier;\n    }\n\n    @Override\n    public ServerAuthContext getAuthContext(String authContextID, Subject serviceSubject,\n        @SuppressWarnings(\"rawtypes\") Map properties) throws AuthException {\n        return new DefaultServerAuthContext(handler, serverAuthModuleSupplier);\n    }\n\n    // ### The methods below mostly just return what has been passed into the\n    // constructor.\n    // ### In practice they don't seem to be called\n\n    @Override\n    public String getMessageLayer() {\n        return layer;\n    }\n\n    /**\n     * It's not entirely clear what the difference is between the \"application context identifier\" (appContext) and the\n     * \"authentication context identifier\" (authContext). In early iterations of the specification, authContext was called\n     * \"operation\" and instead of the MessageInfo it was obtained by something called an \"authParam\".\n     */\n    @Override\n    public String getAuthContextID(MessageInfo messageInfo) {\n        return appContext;\n    }\n\n    @Override\n    public String getAppContext() {\n        return appContext;\n    }\n\n    @Override\n    public void refresh() {\n    }\n\n    @Override\n    public boolean isProtected() {\n        return false;\n    }\n\n    public Map<String, String> getProviderProperties() {\n        return providerProperties;\n    }\n\n}\n", "target": 0}
{"idx": 981, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.thoughtworks.xstream.XStream;\nimport hudson.DescriptorExtensionList;\nimport hudson.Extension;\nimport hudson.XmlFile;\nimport hudson.model.listeners.ItemListener;\nimport hudson.remoting.Callable;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.triggers.Trigger;\nimport hudson.util.DescriptorList;\nimport hudson.util.EditDistance;\nimport hudson.util.XStream2;\nimport jenkins.model.Jenkins;\nimport org.acegisecurity.Authentication;\nimport org.apache.commons.lang.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\n\nimport jenkins.model.DirectlyModifiableTopLevelItemGroup;\nimport org.apache.commons.io.FileUtils;\n\n/**\n * Convenience methods related to {@link Item}.\n * \n * @author Kohsuke Kawaguchi\n */\npublic class Items {\n    /**\n     * List of all installed {@link TopLevelItem} types.\n     *\n     * @deprecated as of 1.286\n     *      Use {@link #all()} for read access and {@link Extension} for registration.\n     */\n    @Deprecated\n    public static final List<TopLevelItemDescriptor> LIST = (List)new DescriptorList<TopLevelItem>(TopLevelItem.class);\n\n    /**\n     * Used to behave differently when loading posted configuration as opposed to persisted configuration.\n     * @see Trigger#start\n     * @since 1.482\n     */\n    private static final ThreadLocal<Boolean> updatingByXml = new ThreadLocal<Boolean>() {\n        @Override protected Boolean initialValue() {\n            return false;\n        }\n    };\n\n    /**\n     * Runs a block while making {@link #currentlyUpdatingByXml} be temporarily true.\n     * Use this when you are creating or changing an item.\n     * @param <V> a return value type (may be {@link Void})\n     * @param <T> an error type (may be {@link Error})\n     * @param callable a block, typically running {@link #load} or {@link Item#onLoad}\n     * @return whatever {@code callable} returned\n     * @throws T anything {@code callable} throws\n     * @since 1.546\n     */\n    public static <V,T extends Throwable> V whileUpdatingByXml(Callable<V,T> callable) throws T {\n        updatingByXml.set(true);\n        try {\n            return callable.call();\n        } finally {\n            updatingByXml.set(false);\n        }\n    }\n\n    /**\n     * Checks whether we are in the middle of creating or configuring an item via XML.\n     * Used to determine the {@code newInstance} parameter for {@link Trigger#start}.\n     * @return true if {@link #whileUpdatingByXml} is currently being called, false for example when merely starting Jenkins or reloading from disk\n     * @since 1.546\n     */\n    public static boolean currentlyUpdatingByXml() {\n        return updatingByXml.get();\n    }\n\n    /**\n     * Returns all the registered {@link TopLevelItemDescriptor}s.\n     */\n    public static DescriptorExtensionList<TopLevelItem,TopLevelItemDescriptor> all() {\n        return Jenkins.getInstance().<TopLevelItem,TopLevelItemDescriptor>getDescriptorList(TopLevelItem.class);\n    }\n\n    /**\n     * Returns all the registered {@link TopLevelItemDescriptor}s that the current security principal is allowed to\n     * create within the specified item group.\n     *\n     * @since TODO\n     */\n    public static List<TopLevelItemDescriptor> all(ItemGroup c) {\n        return all(Jenkins.getAuthentication(), c);\n    }\n\n    /**\n     * Returns all the registered {@link TopLevelItemDescriptor}s that the specified security principal is allowed to\n     * create within the specified item group.\n     *\n     * @since TODO\n     */\n    public static List<TopLevelItemDescriptor> all(Authentication a, ItemGroup c) {\n        List<TopLevelItemDescriptor> result = new ArrayList<TopLevelItemDescriptor>();\n        ACL acl;\n        if (c instanceof AccessControlled) {\n            acl = ((AccessControlled) c).getACL();\n        } else {\n            // fall back to root\n            acl = Jenkins.getInstance().getACL();\n        }\n        for (TopLevelItemDescriptor d: all()) {\n            if (acl.hasCreatePermission(a, c, d) && d.isApplicableIn(c)) {\n                result.add(d);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @deprecated Underspecified what the parameter is. {@link Descriptor#getId}? A {@link Describable} class name?\n     */\n    public static TopLevelItemDescriptor getDescriptor(String fqcn) {\n        return Descriptor.find(all(), fqcn);\n    }\n\n    /**\n     * Converts a list of items into a comma-separated list of full names.\n     */\n    public static String toNameList(Collection<? extends Item> items) {\n        StringBuilder buf = new StringBuilder();\n        for (Item item : items) {\n            if(buf.length()>0)\n                buf.append(\", \");\n            buf.append(item.getFullName());\n        }\n        return buf.toString();\n    }\n\n    /**\n     * @deprecated as of 1.406\n     *      Use {@link #fromNameList(ItemGroup, String, Class)}\n     */\n    @Deprecated\n    public static <T extends Item> List<T> fromNameList(String list, Class<T> type) {\n        return fromNameList(null,list,type);\n    }\n\n    /**\n     * Does the opposite of {@link #toNameList(Collection)}.\n     */\n    public static <T extends Item> List<T> fromNameList(ItemGroup context, @Nonnull String list, @Nonnull Class<T> type) {\n        Jenkins hudson = Jenkins.getInstance();\n\n        List<T> r = new ArrayList<T>();\n        StringTokenizer tokens = new StringTokenizer(list,\",\");\n        while(tokens.hasMoreTokens()) {\n            String fullName = tokens.nextToken().trim();\n            T item = hudson.getItem(fullName, context, type);\n            if(item!=null)\n                r.add(item);\n        }\n        return r;\n    }\n\n    /**\n     * Computes the canonical full name of a relative path in an {@link ItemGroup} context, handling relative\n     * positions \"..\" and \".\" as absolute path starting with \"/\". The resulting name is the item fullName from Jenkins\n     * root.\n     */\n    public static String getCanonicalName(ItemGroup context, String path) {\n        String[] c = context.getFullName().split(\"/\");\n        String[] p = path.split(\"/\");\n\n        Stack<String> name = new Stack<String>();\n        for (int i=0; i<c.length;i++) {\n            if (i==0 && c[i].equals(\"\")) continue;\n            name.push(c[i]);\n        }\n        for (int i=0; i<p.length;i++) {\n            if (i==0 && p[i].equals(\"\")) {\n                // Absolute path starting with a \"/\"\n                name.clear();\n                continue;\n            }\n            if (p[i].equals(\"..\")) {\n                if (name.size() == 0) {\n                    throw new IllegalArgumentException(String.format(\n                            \"Illegal relative path '%s' within context '%s'\", path, context.getFullName()\n                    ));\n                }\n                name.pop();\n                continue;\n            }\n            if (p[i].equals(\".\")) {\n                continue;\n            }\n            name.push(p[i]);\n        }\n        return StringUtils.join(name, '/');\n    }\n\n    /**\n     * Computes the relative name of list of items after a rename or move occurred.\n     * Used to manage job references as names in plugins to support {@link hudson.model.listeners.ItemListener#onLocationChanged}.\n     * <p>\n     * In a hierarchical context, when a plugin has a reference to a job as <code>../foo/bar</code> this method will\n     * handle the relative path as \"foo\" is renamed to \"zot\" to compute <code>../zot/bar</code>\n     *\n     * @param oldFullName the old full name of the item\n     * @param newFullName the new full name of the item\n     * @param relativeNames coma separated list of Item relative names\n     * @param context the {link ItemGroup} relative names refer to\n     * @return relative name for the renamed item, based on the same ItemGroup context\n     */\n    public static String computeRelativeNamesAfterRenaming(String oldFullName, String newFullName, String relativeNames, ItemGroup context) {\n\n        StringTokenizer tokens = new StringTokenizer(relativeNames,\",\");\n        List<String> newValue = new ArrayList<String>();\n        while(tokens.hasMoreTokens()) {\n            String relativeName = tokens.nextToken().trim();\n            String canonicalName = getCanonicalName(context, relativeName);\n            if (canonicalName.equals(oldFullName) || canonicalName.startsWith(oldFullName+'/')) {\n                String newCanonicalName = newFullName + canonicalName.substring(oldFullName.length());\n                if (relativeName.startsWith(\"/\")) {\n                    newValue.add(\"/\" + newCanonicalName);\n                } else {\n                    newValue.add(getRelativeNameFrom(newCanonicalName, context.getFullName()));\n                }\n            } else {\n                newValue.add(relativeName);\n            }\n        }\n        return StringUtils.join(newValue, \",\");\n    }\n\n    // Had difficulty adapting the version in Functions to use no live items, so rewrote it:\n    static String getRelativeNameFrom(String itemFullName, String groupFullName) {\n        String[] itemFullNameA = itemFullName.isEmpty() ? new String[0] : itemFullName.split(\"/\");\n        String[] groupFullNameA = groupFullName.isEmpty() ? new String[0] : groupFullName.split(\"/\");\n        for (int i = 0; ; i++) {\n            if (i == itemFullNameA.length) {\n                if (i == groupFullNameA.length) {\n                    // itemFullName and groupFullName are identical\n                    return \".\";\n                } else {\n                    // itemFullName is an ancestor of groupFullName; insert ../ for rest of groupFullName\n                    StringBuilder b = new StringBuilder();\n                    for (int j = 0; j < groupFullNameA.length - itemFullNameA.length; j++) {\n                        if (j > 0) {\n                            b.append('/');\n                        }\n                        b.append(\"..\");\n                    }\n                    return b.toString();\n                }\n            } else if (i == groupFullNameA.length) {\n                // groupFullName is an ancestor of itemFullName; insert rest of itemFullName\n                StringBuilder b = new StringBuilder();\n                for (int j = i; j < itemFullNameA.length; j++) {\n                    if (j > i) {\n                        b.append('/');\n                    }\n                    b.append(itemFullNameA[j]);\n                }\n                return b.toString();\n            } else if (itemFullNameA[i].equals(groupFullNameA[i])) {\n                // identical up to this point\n                continue;\n            } else {\n                // first mismatch; insert ../ for rest of groupFullName, then rest of itemFullName\n                StringBuilder b = new StringBuilder();\n                for (int j = i; j < groupFullNameA.length; j++) {\n                    if (j > i) {\n                        b.append('/');\n                    }\n                    b.append(\"..\");\n                }\n                for (int j = i; j < itemFullNameA.length; j++) {\n                    b.append('/').append(itemFullNameA[j]);\n                }\n                return b.toString();\n            }\n        }\n    }\n\n    /**\n     * Loads a {@link Item} from a config file.\n     *\n     * @param dir\n     *      The directory that contains the config file, not the config file itself.\n     */\n    public static Item load(ItemGroup parent, File dir) throws IOException {\n        Item item = (Item)getConfigFile(dir).read();\n        item.onLoad(parent,dir.getName());\n        return item;\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    public static XmlFile getConfigFile(File dir) {\n        return new XmlFile(XSTREAM,new File(dir,\"config.xml\"));\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    public static XmlFile getConfigFile(Item item) {\n        return getConfigFile(item.getRootDir());\n    }\n    \n    /**\n     * Gets all the {@link Item}s recursively in the {@link ItemGroup} tree\n     * and filter them by the given type.\n     * \n     * @since 1.512\n     */\n    public static <T extends Item> List<T> getAllItems(final ItemGroup root, Class<T> type) {\n        List<T> r = new ArrayList<T>();\n        getAllItems(root, type, r);\n        return r;\n    }\n    private static <T extends Item> void getAllItems(final ItemGroup root, Class<T> type, List<T> r) {\n        List<Item> items = new ArrayList<Item>(((ItemGroup<?>) root).getItems());\n        Collections.sort(items, new Comparator<Item>() {\n            @Override public int compare(Item i1, Item i2) {\n                return name(i1).compareToIgnoreCase(name(i2));\n            }\n            String name(Item i) {\n                String n = i.getName();\n                if (i instanceof ItemGroup) {\n                    n += '/';\n                }\n                return n;\n            }\n        });\n        for (Item i : items) {\n            if (type.isInstance(i)) {\n                if (i.hasPermission(Item.READ)) {\n                    r.add(type.cast(i));\n                }\n            }\n            if (i instanceof ItemGroup) {\n                getAllItems((ItemGroup) i, type, r);\n            }\n        }\n    }\n\n    /**\n     * Finds an item whose name (when referenced from the specified context) is closest to the given name.\n     * @param <T> the type of item being considered\n     * @param type same as {@code T}\n     * @param name the supplied name\n     * @param context a context to start from (used to compute relative names)\n     * @return the closest available item\n     * @since 1.538\n     */\n    public static @CheckForNull <T extends Item> T findNearest(Class<T> type, String name, ItemGroup context) {\n        List<T> projects = Jenkins.getInstance().getAllItems(type);\n        String[] names = new String[projects.size()];\n        for (int i = 0; i < projects.size(); i++) {\n            names[i] = projects.get(i).getRelativeNameFrom(context);\n        }\n        String nearest = EditDistance.findNearest(name, names);\n        return Jenkins.getInstance().getItem(nearest, context, type);\n    }\n\n    /**\n     * Moves an item between folders (or top level).\n     * Fires all relevant events but does not verify that the items directory is not currently being used in some way (for example by a running build).\n     * Does not check any permissions.\n     * @param item some item (job or folder)\n     * @param destination the destination of the move (a folder or {@link Jenkins}); not the current parent (or you could just call {@link AbstractItem#renameTo})\n     * @return the new item (usually the same object as {@code item})\n     * @throws IOException if the move fails, or some subsequent step fails (directory might have already been moved)\n     * @throws IllegalArgumentException if the move would really be a rename, or the destination cannot accept the item, or the destination already has an item of that name\n     * @since 1.548\n     */\n    public static <I extends AbstractItem & TopLevelItem> I move(I item, DirectlyModifiableTopLevelItemGroup destination) throws IOException, IllegalArgumentException {\n        DirectlyModifiableTopLevelItemGroup oldParent = (DirectlyModifiableTopLevelItemGroup) item.getParent();\n        if (oldParent == destination) {\n            throw new IllegalArgumentException();\n        }\n        // TODO verify that destination is to not equal to, or inside, item\n        if (!destination.canAdd(item)) {\n            throw new IllegalArgumentException();\n        }\n        String name = item.getName();\n        if (destination.getItem(name) != null) {\n            throw new IllegalArgumentException(name + \" already exists\");\n        }\n        String oldFullName = item.getFullName();\n        // TODO AbstractItem.renameTo has a more baroque implementation; factor it out into a utility method perhaps?\n        File destDir = destination.getRootDirFor(item);\n        FileUtils.forceMkdir(destDir.getParentFile());\n        FileUtils.moveDirectory(item.getRootDir(), destDir);\n        oldParent.remove(item);\n        I newItem = destination.add(item, name);\n        item.movedTo(destination, newItem, destDir);\n        ItemListener.fireLocationChange(newItem, oldFullName);\n        return newItem;\n    }\n\n    /**\n     * Used to load/save job configuration.\n     *\n     * When you extend {@link Job} in a plugin, try to put the alias so\n     * that it produces a reasonable XML.\n     */\n    public static final XStream XSTREAM = new XStream2();\n\n    /**\n     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.\n     */\n    public static final XStream2 XSTREAM2 = (XStream2)XSTREAM;\n\n    static {\n        XSTREAM.alias(\"project\",FreeStyleProject.class);\n    }\n}\n", "target": 1}
{"idx": 982, "func": "/*****************************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one                *\n * or more contributor license agreements.  See the NOTICE file              *\n * distributed with this work for additional information                     *\n * regarding copyright ownership.  The ASF licenses this file                *\n * to you under the Apache License, Version 2.0 (the                         *\n * \"License\"); you may not use this file except in compliance                *\n * with the License.  You may obtain a copy of the License at                *\n *                                                                           *\n *     http://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                           *\n * Unless required by applicable law or agreed to in writing,                *\n * software distributed under the License is distributed on an               *\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY                    *\n * KIND, either express or implied.  See the License for the                 *\n * specific language governing permissions and limitations                   *\n * under the License.                                                        *\n *                                                                           *\n/****************************************************************************/\n\npackage bsh;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n * This tests serialization of the beanshell interpreter\n *\n * @author Jessen Yu\n */\npublic class BshSerializationTest {\n\n    /**\n     * Tests that Special.NULL_VALUE is correctly serialized/deserialized\n     *\n     * @throws Exception in case of failure\n     */\n    @Test\n    public void testNullValueSerialization() throws Exception {\n        final Interpreter origInterpreter = new Interpreter();\n        origInterpreter.eval(\"myNull = null;\");\n        Assert.assertNull(origInterpreter.eval(\"myNull\"));\n        final Interpreter deserInterpreter = TestUtil.serDeser(origInterpreter);\n        Assert.assertNull(deserInterpreter.eval(\"myNull\"));\n    }\n\n\n    /**\n     * Tests that Primitive.NULL is correctly serialized/deserialized\n     *\n     * @throws Exception in case of failure\n     */\n    @Test\n    public void testSpecialNullSerialization() throws Exception {\n        final Interpreter originalInterpreter = new Interpreter();\n        originalInterpreter.eval(\"myNull = null;\");\n        Assert.assertTrue((Boolean) originalInterpreter.eval(\"myNull == null\"));\n        final Interpreter deserInterpreter = TestUtil.serDeser(originalInterpreter);\n        Assert.assertTrue((Boolean) deserInterpreter.eval(\"myNull == null\"));\n    }\n\n\n    /**\n     * Tests that a declared method can be serialized (but not exploited)\n     *\n     * @throws Exception in case of failure\n     */\n    @Test\n    public void testMethodSerialization() throws Exception {\n        final Interpreter origInterpreter = new Interpreter();\n        origInterpreter.eval(\"int method() { return 1337; }\");\n        Assert.assertEquals(1337, origInterpreter.eval(\"method()\"));\n        final Interpreter deserInterpreter = TestUtil.serDeser(origInterpreter);\n        Assert.assertEquals(1337, deserInterpreter.eval(\"method()\"));\n    }\n\n}\n", "target": 0}
{"idx": 983, "func": "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.search.impl.persistence;\n\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.impl.jpa.JpaOrganization;\n\nimport java.util.Date;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\nimport javax.persistence.Index;\nimport javax.persistence.JoinColumn;\nimport javax.persistence.Lob;\nimport javax.persistence.NamedQueries;\nimport javax.persistence.NamedQuery;\nimport javax.persistence.OneToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Temporal;\nimport javax.persistence.TemporalType;\n\n/**\n * Entity object for storing search in persistence storage. Media package id is stored as primary key.\n */\n@Entity(name = \"SearchEntity\")\n@Table(name = \"oc_search\", indexes = {\n    @Index(name = \"IX_oc_search_series\", columnList = (\"series_id\")),\n    @Index(name = \"IX_oc_search_organization\", columnList = (\"organization\")) })\n@NamedQueries({\n    @NamedQuery(name = \"Search.findAll\", query = \"SELECT s FROM SearchEntity s\"),\n    @NamedQuery(name = \"Search.getCount\", query = \"SELECT COUNT(s) FROM SearchEntity s\"),\n    @NamedQuery(name = \"Search.findById\", query = \"SELECT s FROM SearchEntity s WHERE s.mediaPackageId=:mediaPackageId\"),\n    @NamedQuery(name = \"Search.findBySeriesId\", query = \"SELECT s FROM SearchEntity s WHERE s.seriesId=:seriesId and \"\n        + \"s.deletionDate is null\"),\n    @NamedQuery(name = \"Search.getNoSeries\", query = \"SELECT s FROM SearchEntity s WHERE s.seriesId IS NULL\")})\npublic class SearchEntity {\n\n  /** media package id, primary key */\n  @Id\n  @Column(name = \"id\", length = 128)\n  private String mediaPackageId;\n\n  @Column(name = \"series_id\", length = 128)\n  protected String seriesId;\n\n  /** Organization id */\n  @OneToOne(targetEntity = JpaOrganization.class)\n  @JoinColumn(name = \"organization\", referencedColumnName = \"id\")\n  protected JpaOrganization organization;\n\n  /** The media package deleted */\n  @Column(name = \"deletion_date\")\n  @Temporal(TemporalType.TIMESTAMP)\n  private Date deletionDate;\n\n  /** The media package deleted */\n  @Column(name = \"modification_date\")\n  @Temporal(TemporalType.TIMESTAMP)\n  private Date modificationDate;\n\n  /** Serialized media package */\n  @Lob\n  @Column(name = \"mediapackage_xml\", length = 65535)\n  private String mediaPackageXML;\n\n  /** Serialized access control */\n  @Lob\n  @Column(name = \"access_control\", length = 65535)\n  protected String accessControl;\n\n  /**\n   * Default constructor without any import.\n   */\n  public SearchEntity() {\n  }\n\n  /**\n   * Returns media package id.\n   *\n   * @return media package id\n   */\n  public String getMediaPackageId() {\n    return mediaPackageId;\n  }\n\n  /**\n   * Sets media package id. Id length limit is 128 charachters.\n   *\n   * @param mediaPackageId\n   */\n  public void setMediaPackageId(String mediaPackageId) {\n    this.mediaPackageId = mediaPackageId;\n  }\n\n  /**\n   * Returns serialized media package.\n   *\n   * @return serialized media package\n   */\n  public String getMediaPackageXML() {\n    return mediaPackageXML;\n  }\n\n  /**\n   * Sets serialized media package\n   *\n   * @param mediaPackageXML\n   */\n  public void setMediaPackageXML(String mediaPackageXML) {\n    this.mediaPackageXML = mediaPackageXML;\n  }\n\n  /**\n   * Returns serialized access control\n   *\n   * @return serialized access control\n   */\n  public String getAccessControl() {\n    return accessControl;\n  }\n\n  /**\n   * Sets serialized access control.\n   *\n   * @param accessControl\n   *          serialized access control\n   */\n  public void setAccessControl(String accessControl) {\n    this.accessControl = accessControl;\n  }\n\n  /**\n   * @return the organization\n   */\n  public JpaOrganization getOrganization() {\n    return organization;\n  }\n\n  /**\n   * @param organization\n   *          the organization to set\n   */\n  public void setOrganization(Organization organization) {\n    if (organization instanceof JpaOrganization) {\n      this.organization = (JpaOrganization) organization;\n    } else {\n      this.organization = new JpaOrganization(organization.getId(), organization.getName(), organization.getServers(),\n          organization.getAdminRole(), organization.getAnonymousRole(), organization.getProperties());\n    }\n  }\n\n  /**\n   * @return the deletion date\n   */\n  public Date getDeletionDate() {\n    return deletionDate;\n  }\n\n  /**\n   * Sets the deletion date\n   *\n   * @param deletionDate\n   *          the deletion date\n   */\n  public void setDeletionDate(Date deletionDate) {\n    this.deletionDate = deletionDate;\n  }\n\n  /**\n   * @return the modification date\n   */\n  public Date getModificationDate() {\n    return modificationDate;\n  }\n\n  /**\n   * Sets the modification date\n   *\n   * @param modificationDate\n   *          the modification date\n   */\n  public void setModificationDate(Date modificationDate) {\n    this.modificationDate = modificationDate;\n  }\n\n  /**\n   * @return the series Id for this search entry\n   */\n  public String getSeriesId() {\n    return seriesId;\n  }\n\n  /**\n   * Sets the series ID\n   *\n   * @param seriesId\n   *          the series ID\n   */\n  public void setSeriesId(String seriesId) {\n    this.seriesId = seriesId;\n  }\n}\n", "target": 0}
{"idx": 984, "func": "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.tellstick.internal.live;\n\nimport java.math.BigDecimal;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.asynchttpclient.AsyncHttpClient;\nimport org.asynchttpclient.AsyncHttpClientConfig;\nimport org.asynchttpclient.DefaultAsyncHttpClient;\nimport org.asynchttpclient.DefaultAsyncHttpClientConfig;\nimport org.asynchttpclient.DefaultAsyncHttpClientConfig.Builder;\nimport org.asynchttpclient.Response;\nimport org.asynchttpclient.oauth.ConsumerKey;\nimport org.asynchttpclient.oauth.OAuthSignatureCalculator;\nimport org.asynchttpclient.oauth.RequestToken;\nimport org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\nimport org.eclipse.smarthome.core.library.types.OnOffType;\nimport org.eclipse.smarthome.core.library.types.PercentType;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.State;\nimport org.openhab.binding.tellstick.internal.TelldusBindingException;\nimport org.openhab.binding.tellstick.internal.handler.TelldusDeviceController;\nimport org.openhab.binding.tellstick.internal.live.xml.TelldusLiveResponse;\nimport org.openhab.binding.tellstick.internal.live.xml.TellstickNetDevice;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.tellstick.JNA;\nimport org.tellstick.device.TellstickDevice;\nimport org.tellstick.device.TellstickDeviceEvent;\nimport org.tellstick.device.TellstickException;\nimport org.tellstick.device.TellstickSensorEvent;\nimport org.tellstick.device.iface.Device;\nimport org.tellstick.device.iface.DeviceChangeListener;\nimport org.tellstick.device.iface.SensorListener;\nimport org.tellstick.device.iface.SwitchableDevice;\n\n/**\n * {@link TelldusLiveDeviceController} is the communication with Telldus Live service (Tellstick.NET and ZNET)\n * This controller uses XML based Rest API to communicate with Telldus Live.\n *\n * @author Jarle Hjortland - Initial contribution\n */\npublic class TelldusLiveDeviceController implements DeviceChangeListener, SensorListener, TelldusDeviceController {\n    private final Logger logger = LoggerFactory.getLogger(TelldusLiveDeviceController.class);\n    private long lastSend = 0;\n    public static final long DEFAULT_INTERVAL_BETWEEN_SEND = 250;\n    static final int REQUEST_TIMEOUT_MS = 5000;\n    private AsyncHttpClient client;\n    static final String HTTP_API_TELLDUS_COM_XML = \"http://api.telldus.com/xml/\";\n    static final String HTTP_TELLDUS_CLIENTS = HTTP_API_TELLDUS_COM_XML + \"clients/list\";\n    static final String HTTP_TELLDUS_DEVICES = HTTP_API_TELLDUS_COM_XML + \"devices/list?supportedMethods=19\";\n    static final String HTTP_TELLDUS_SENSORS = HTTP_API_TELLDUS_COM_XML\n            + \"sensors/list?includeValues=1&includeScale=1&includeUnit=1\";\n    static final String HTTP_TELLDUS_SENSOR_INFO = HTTP_API_TELLDUS_COM_XML + \"sensor/info\";\n    static final String HTTP_TELLDUS_DEVICE_DIM = HTTP_API_TELLDUS_COM_XML + \"device/dim?id=%d&level=%d\";\n    static final String HTTP_TELLDUS_DEVICE_TURNOFF = HTTP_API_TELLDUS_COM_XML + \"device/turnOff?id=%d\";\n    static final String HTTP_TELLDUS_DEVICE_TURNON = HTTP_API_TELLDUS_COM_XML + \"device/turnOn?id=%d\";\n    private static final int MAX_RETRIES = 3;\n\n    public TelldusLiveDeviceController() {\n    }\n\n    @Override\n    public void dispose() {\n        try {\n            client.close();\n        } catch (Exception e) {\n            logger.error(\"Failed to close client\", e);\n        }\n    }\n\n    void connectHttpClient(String publicKey, String privateKey, String token, String tokenSecret) {\n        ConsumerKey consumer = new ConsumerKey(publicKey, privateKey);\n        RequestToken user = new RequestToken(token, tokenSecret);\n        OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);\n        this.client = new DefaultAsyncHttpClient(createAsyncHttpClientConfig());\n        try {\n            this.client.setSignatureCalculator(calc);\n            Response response = client.prepareGet(HTTP_TELLDUS_CLIENTS).execute().get();\n            logger.debug(\"Response {} statusText {}\", response.getResponseBody(), response.getStatusText());\n        } catch (InterruptedException | ExecutionException e) {\n            logger.error(\"Failed to connect\", e);\n        }\n    }\n\n    private AsyncHttpClientConfig createAsyncHttpClientConfig() {\n        Builder builder = new DefaultAsyncHttpClientConfig.Builder();\n        builder.setConnectTimeout(REQUEST_TIMEOUT_MS);\n        return builder.build();\n    }\n\n    @Override\n    public void handleSendEvent(Device device, int resendCount, boolean isdimmer, Command command)\n            throws TellstickException {\n        logger.info(\"Send {} to {}\", command, device);\n        if (device instanceof TellstickNetDevice) {\n            if (command == OnOffType.ON) {\n                turnOn(device);\n            } else if (command == OnOffType.OFF) {\n                turnOff(device);\n            } else if (command instanceof PercentType) {\n                dim(device, (PercentType) command);\n            } else if (command instanceof IncreaseDecreaseType) {\n                increaseDecrease(device, ((IncreaseDecreaseType) command));\n            }\n        } else if (device instanceof SwitchableDevice) {\n            if (command == OnOffType.ON) {\n                if (isdimmer) {\n                    logger.debug(\"Turn off first in case it is allready on\");\n                    turnOff(device);\n                }\n                turnOn(device);\n            } else if (command == OnOffType.OFF) {\n                turnOff(device);\n            }\n        } else {\n            logger.warn(\"Cannot send to {}\", device);\n        }\n    }\n\n    private void increaseDecrease(Device dev, IncreaseDecreaseType increaseDecreaseType) throws TellstickException {\n        String strValue = ((TellstickDevice) dev).getData();\n        double value = 0;\n        if (strValue != null) {\n            value = Double.valueOf(strValue);\n        }\n        int percent = (int) Math.round((value / 255) * 100);\n        if (IncreaseDecreaseType.INCREASE == increaseDecreaseType) {\n            percent = Math.min(percent + 10, 100);\n        } else if (IncreaseDecreaseType.DECREASE == increaseDecreaseType) {\n            percent = Math.max(percent - 10, 0);\n        }\n        dim(dev, new PercentType(percent));\n    }\n\n    private void dim(Device dev, PercentType command) throws TellstickException {\n        double value = command.doubleValue();\n\n        // 0 means OFF and 100 means ON\n        if (value == 0 && dev instanceof TellstickNetDevice) {\n            turnOff(dev);\n        } else if (value == 100 && dev instanceof TellstickNetDevice) {\n            turnOn(dev);\n        } else if (dev instanceof TellstickNetDevice\n                && (((TellstickNetDevice) dev).getMethods() & JNA.CLibrary.TELLSTICK_DIM) > 0) {\n            long tdVal = Math.round((value / 100) * 255);\n            TelldusLiveResponse response = callRestMethod(String.format(HTTP_TELLDUS_DEVICE_DIM, dev.getId(), tdVal),\n                    TelldusLiveResponse.class);\n            handleResponse((TellstickNetDevice) dev, response);\n        } else {\n            throw new TelldusBindingException(\"Cannot send DIM to \" + dev);\n        }\n    }\n\n    private void turnOff(Device dev) throws TellstickException {\n        if (dev instanceof TellstickNetDevice) {\n            TelldusLiveResponse response = callRestMethod(String.format(HTTP_TELLDUS_DEVICE_TURNOFF, dev.getId()),\n                    TelldusLiveResponse.class);\n            handleResponse((TellstickNetDevice) dev, response);\n        } else {\n            throw new TelldusBindingException(\"Cannot send OFF to \" + dev);\n        }\n    }\n\n    private void handleResponse(TellstickNetDevice device, TelldusLiveResponse response) throws TellstickException {\n        if (response == null || (response.status == null && response.error == null)) {\n            throw new TelldusBindingException(\"No response \" + response);\n        } else if (response.error != null) {\n            if (response.error.equals(\"The client for this device is currently offline\")) {\n                device.setOnline(false);\n                device.setUpdated(true);\n            }\n            throw new TelldusBindingException(\"Error \" + response.error);\n        } else if (!response.status.trim().equals(\"success\")) {\n            throw new TelldusBindingException(\"Response \" + response.status);\n        }\n    }\n\n    private void turnOn(Device dev) throws TellstickException {\n        if (dev instanceof TellstickNetDevice) {\n            TelldusLiveResponse response = callRestMethod(String.format(HTTP_TELLDUS_DEVICE_TURNON, dev.getId()),\n                    TelldusLiveResponse.class);\n            handleResponse((TellstickNetDevice) dev, response);\n        } else {\n            throw new TelldusBindingException(\"Cannot send ON to \" + dev);\n        }\n    }\n\n    @Override\n    public State calcState(Device dev) {\n        TellstickNetDevice device = (TellstickNetDevice) dev;\n        State st = null;\n        if (device.getOnline()) {\n            switch (device.getState()) {\n                case JNA.CLibrary.TELLSTICK_TURNON:\n                    st = OnOffType.ON;\n                    break;\n                case JNA.CLibrary.TELLSTICK_TURNOFF:\n                    st = OnOffType.OFF;\n                    break;\n                case JNA.CLibrary.TELLSTICK_DIM:\n                    BigDecimal dimValue = new BigDecimal(device.getStatevalue());\n                    if (dimValue.intValue() == 0) {\n                        st = OnOffType.OFF;\n                    } else if (dimValue.intValue() >= 255) {\n                        st = OnOffType.ON;\n                    } else {\n                        st = OnOffType.ON;\n                    }\n                    break;\n                default:\n                    logger.warn(\"Could not handle {} for {}\", device.getState(), device);\n            }\n        }\n        return st;\n    }\n\n    @Override\n    public BigDecimal calcDimValue(Device device) {\n        BigDecimal dimValue = new BigDecimal(0);\n        switch (((TellstickNetDevice) device).getState()) {\n            case JNA.CLibrary.TELLSTICK_TURNON:\n                dimValue = new BigDecimal(100);\n                break;\n            case JNA.CLibrary.TELLSTICK_TURNOFF:\n                break;\n            case JNA.CLibrary.TELLSTICK_DIM:\n                dimValue = new BigDecimal(((TellstickNetDevice) device).getStatevalue());\n                dimValue = dimValue.multiply(new BigDecimal(100));\n                dimValue = dimValue.divide(new BigDecimal(255), 0, BigDecimal.ROUND_HALF_UP);\n                break;\n            default:\n                logger.warn(\"Could not handle {} for {}\", (((TellstickNetDevice) device).getState()), device);\n        }\n        return dimValue;\n    }\n\n    public long getLastSend() {\n        return lastSend;\n    }\n\n    public void setLastSend(long currentTimeMillis) {\n        lastSend = currentTimeMillis;\n    }\n\n    @Override\n    public void onRequest(TellstickSensorEvent newDevices) {\n        setLastSend(newDevices.getTimestamp());\n    }\n\n    @Override\n    public void onRequest(TellstickDeviceEvent newDevices) {\n        setLastSend(newDevices.getTimestamp());\n    }\n\n    <T> T callRestMethod(String uri, Class<T> response) throws TelldusLiveException {\n        T resultObj = null;\n        try {\n            for (int i = 0; i < MAX_RETRIES; i++) {\n                try {\n                    resultObj = innerCallRest(uri, response);\n                    break;\n                } catch (TimeoutException e) {\n                    logger.warn(\"TimeoutException error in get\", e);\n                } catch (InterruptedException e) {\n                    logger.warn(\"InterruptedException error in get\", e);\n                }\n            }\n        } catch (JAXBException e) {\n            logger.warn(\"Encoding error in get\", e);\n            logResponse(uri, e);\n            throw new TelldusLiveException(e);\n        } catch (XMLStreamException e) {\n            logger.warn(\"Communication error in get\", e);\n            logResponse(uri, e);\n            throw new TelldusLiveException(e);\n        } catch (ExecutionException e) {\n            logger.warn(\"ExecutionException error in get\", e);\n            throw new TelldusLiveException(e);\n        }\n        return resultObj;\n    }\n\n    private <T> T innerCallRest(String uri, Class<T> response) throws InterruptedException, ExecutionException,\n            TimeoutException, JAXBException, FactoryConfigurationError, XMLStreamException {\n        Future<Response> future = client.prepareGet(uri).execute();\n        Response resp = future.get(REQUEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n        // TelldusLiveHandler.logger.info(\"Devices\" + resp.getResponseBody());\n        JAXBContext jc = JAXBContext.newInstance(response);\n        XMLInputFactory xif = XMLInputFactory.newInstance();\n        xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n        XMLStreamReader xsr = xif.createXMLStreamReader(resp.getResponseBodyAsStream());\n        // xsr = new PropertyRenamerDelegate(xsr);\n\n        @SuppressWarnings(\"unchecked\")\n        T obj = (T) jc.createUnmarshaller().unmarshal(xsr);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Request [{}] Response:{}\", uri, resp.getResponseBody());\n        }\n        return obj;\n    }\n\n    private void logResponse(String uri, Exception e) {\n        if (e != null) {\n            logger.warn(\"Request [{}] Failure:{}\", uri, e.getMessage());\n        }\n    }\n}\n", "target": 0}
{"idx": 985, "func": "package org.bouncycastle.jce.provider.test;\n\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.spec.ECGenParameterSpec;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.SealedObject;\n\nimport org.bouncycastle.crypto.agreement.ECDHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.DESEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher;\nimport org.bouncycastle.jce.interfaces.ECPrivateKey;\nimport org.bouncycastle.jce.interfaces.ECPublicKey;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.SimpleTest;\n\n/**\n * Test for ECIES - Elliptic Curve Integrated Encryption Scheme\n */\npublic class ECIESTest\n    extends SimpleTest\n{\n\n    ECIESTest()\n    {\n    }\n\n    public String getName()\n    {\n        return \"ECIES\";\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        byte[] derivation = Hex.decode(\"202122232425262728292a2b2c2d2e2f\");\n        byte[] encoding   = Hex.decode(\"303132333435363738393a3b3c3d3e3f\");\n        \n        \n        IESCipher c1 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIES();\n        IESCipher c2 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIES();\n        IESParameterSpec params = new IESParameterSpec(derivation,encoding,128);\n\n        // Testing ECIES with default curve in streaming mode\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        doTest(\"ECIES with default\", g, \"ECIES\", params);\n        \n        // Testing ECIES with 192-bit curve in streaming mode \n        g.initialize(192, new SecureRandom());\n        doTest(\"ECIES with 192-bit\", g, \"ECIES\", params);\n\n        // Testing ECIES with 256-bit curve in streaming mode \n        g.initialize(256, new SecureRandom());\n        doTest(\"ECIES with 256-bit\", g, \"ECIES\", params);\n\n        \n        c1 = new IESCipher(new IESEngine(new ECDHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));\n        \n        c2 = new IESCipher(new IESEngine(new ECDHBasicAgreement(), \n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest()),\n                new PaddedBufferedBlockCipher(new DESEngine())));  \n    \n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"0001020304050607\"));\n      \n        // Testing ECIES with default curve using DES\n        g = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n\n        // Testing ECIES with 256-bit curve using DES-CBC\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithDESEDE-CBC\", params);\n\n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"0001020304050607\"));\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithDESEDE-CBC\", params);\n\n        try\n        {\n            params = new IESParameterSpec(derivation, encoding, 128, 128, new byte[10]);\n            g.initialize(256, new SecureRandom());\n            doTest(\"256-bit\", g, \"ECIESwithDESEDE-CBC\", params);\n            fail(\"DESEDE no exception!\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            if (!e.getMessage().equals(\"NONCE in IES Parameters needs to be 8 bytes long\"))\n            {\n                fail(\"DESEDE wrong message!\");\n            }\n        }\n\n        c1 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIESwithAESCBC();\n        c2 = new org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.ECIESwithAESCBC();\n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"000102030405060708090a0b0c0d0e0f\"));\n\n        // Testing ECIES with 256-bit curve using AES-CBC\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithAES-CBC\", params);\n\n        params = new IESParameterSpec(derivation, encoding, 128, 128, Hex.decode(\"000102030405060708090a0b0c0d0e0f\"));\n        g.initialize(256, new SecureRandom());\n        doTest(\"256-bit\", g, \"ECIESwithAES-CBC\", params);\n\n        try\n        {\n            params = new IESParameterSpec(derivation, encoding, 128, 128, new byte[10]);\n            g.initialize(256, new SecureRandom());\n            doTest(\"256-bit\", g, \"ECIESwithAES-CBC\", params);\n            fail(\"AES no exception!\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            if (!e.getMessage().equals(\"NONCE in IES Parameters needs to be 16 bytes long\"))\n            {\n                fail(\"AES wrong message!\");\n            }\n        }\n\n        KeyPair       keyPair = g.generateKeyPair();\n        ECPublicKey pub = (ECPublicKey)keyPair.getPublic();\n        ECPrivateKey priv = (ECPrivateKey)keyPair.getPrivate();\n\n        Cipher c = Cipher.getInstance(\"ECIESwithAES-CBC\", \"BC\");\n\n        try\n        {\n            c.init(Cipher.ENCRYPT_MODE, pub, new IESParameterSpec(derivation, encoding, 128, 128, null));\n\n            fail(\"no exception\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            isTrue(\"message \", \"NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n\n        try\n        {\n            c.init(Cipher.DECRYPT_MODE, priv);\n\n            fail(\"no exception\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            isTrue(\"message \", \"cannot handle supplied parameter spec: NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n\n        try\n        {\n            c.init(Cipher.DECRYPT_MODE, priv, new IESParameterSpec(derivation, encoding, 128, 128, null));\n\n            fail(\"no exception\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            isTrue(\"message \", \"NONCE in IES Parameters needs to be 16 bytes long\".equals(e.getMessage()));\n        }\n\n        sealedObjectTest();\n    }\n\n    private void sealedObjectTest()\n        throws Exception\n    {\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECIES\");\n        kpg.initialize(new ECGenParameterSpec(\"secp256r1\"));\n        KeyPair keyPair = kpg.generateKeyPair();\n\n        Cipher cipher = Cipher.getInstance(\"ECIES\");\n        cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());\n\n        String toEncrypt = \"Hello\";\n\n        // Check that cipher works ok\n        cipher.doFinal(toEncrypt.getBytes());\n\n        // Using a SealedObject to encrypt the same string fails with a NullPointerException\n        SealedObject sealedObject = new SealedObject(toEncrypt, cipher);\n\n        cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n\n        String result = (String)sealedObject.getObject(cipher);\n\n        isTrue(\"result wrong\", result.equals(toEncrypt));\n\n        result = (String)sealedObject.getObject(keyPair.getPrivate());\n\n        isTrue(\"result wrong\", result.equals(toEncrypt));\n    }\n\n    public void doTest(\n        String                testname,\n        KeyPairGenerator     g,\n        String              cipher,\n        IESParameterSpec    p)\n        throws Exception\n    {\n\n        byte[] message = Hex.decode(\"0102030405060708090a0b0c0d0e0f10111213141516\");\n        byte[] out1, out2;\n\n        // Generate static key pair\n        KeyPair     KeyPair = g.generateKeyPair();\n        ECPublicKey   Pub = (ECPublicKey) KeyPair.getPublic();\n        ECPrivateKey  Priv = (ECPrivateKey) KeyPair.getPrivate();\n\n        Cipher c1 = Cipher.getInstance(cipher);\n        Cipher c2 = Cipher.getInstance(cipher);\n\n        // Testing with null parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, Pub, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, Priv, c1.getParameters());\n\n        isTrue(\"nonce mismatch\", Arrays.areEqual(c1.getIV(), c2.getIV()));\n\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with null parameters, DHAES mode false.\");\n    \n        \n        // Testing with given parameters and DHAES mode off\n        c1.init(Cipher.ENCRYPT_MODE, Pub, p, new SecureRandom());\n        c2.init(Cipher.DECRYPT_MODE, Priv, p);\n        out1 = c1.doFinal(message, 0, message.length);\n        out2 = c2.doFinal(out1, 0, out1.length);\n        if (!areEqual(out2, message))\n            fail(testname + \" test failed with non-null parameters, DHAES mode false.\");\n        \n        //\n        // corrupted data test\n        //\n        int offset = out1.length - (message.length + 8);\n        byte[] tmp = new byte[out1.length];\n        for (int i = offset; i != out1.length; i++)\n        {\n            System.arraycopy(out1, 0, tmp, 0, tmp.length);\n            tmp[i] = (byte)~tmp[i];\n\n            try\n            {\n                c2.doFinal(tmp, 0, tmp.length);\n\n                fail(\"decrypted corrupted data\");\n            }\n            catch (BadPaddingException e)\n            {\n                isTrue(\"wrong message: \" + e.getMessage(), \"unable to process block\".equals(e.getMessage()));\n            }\n        }\n// TODO: DHAES mode is not currently implemented, perhaps it shouldn't be...\n//        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n//        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\",\"BC\");\n//\n//        // Testing with null parameters and DHAES mode on\n//        c1.init(Cipher.ENCRYPT_MODE, Pub, new SecureRandom());\n//        c2.init(Cipher.DECRYPT_MODE, Priv, new SecureRandom());\n//\n//        out1 = c1.doFinal(message, 0, message.length);\n//        out2 = c2.doFinal(out1, 0, out1.length);\n//        if (!areEqual(out2, message))\n//            fail(testname + \" test failed with null parameters, DHAES mode true.\");\n//\n//        c1 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\");\n//        c2 = Cipher.getInstance(cipher + \"/DHAES/PKCS7Padding\");\n//\n//        // Testing with given parameters and DHAES mode on\n//        c1.init(Cipher.ENCRYPT_MODE, Pub, p, new SecureRandom());\n//        c2.init(Cipher.DECRYPT_MODE, Priv, p, new SecureRandom());\n//\n//        out1 = c1.doFinal(message, 0, message.length);\n//        out2 = c2.doFinal(out1, 0, out1.length);\n//        if (!areEqual(out2, message))\n//            fail(testname + \" test failed with non-null parameters, DHAES mode true.\");\n        \n    }\n\n   \n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new ECIESTest());\n    }\n}\n", "target": 0}
{"idx": 986, "func": "package org.bouncycastle.jcajce.provider.drbg;\n\nimport java.security.SecureRandom;\nimport java.security.SecureRandomSpi;\n\nimport org.bouncycastle.crypto.digests.SHA512Digest;\nimport org.bouncycastle.crypto.prng.SP800SecureRandomBuilder;\nimport org.bouncycastle.jcajce.provider.config.ConfigurableProvider;\nimport org.bouncycastle.jcajce.provider.util.AsymmetricAlgorithmProvider;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.Pack;\nimport org.bouncycastle.util.Strings;\n\npublic class DRBG\n{\n    private static final String PREFIX = DRBG.class.getName();\n\n    private static SecureRandom secureRandom = new SecureRandom();\n\n    public static class Default\n        extends SecureRandomSpi\n    {\n        private SecureRandom random = new SP800SecureRandomBuilder(secureRandom, true)\n            .setPersonalizationString(generateDefaultPersonalizationString(secureRandom))\n            .buildHash(new SHA512Digest(), secureRandom.generateSeed(32), true);\n\n        protected void engineSetSeed(byte[] bytes)\n        {\n            random.setSeed(bytes);\n        }\n\n        protected void engineNextBytes(byte[] bytes)\n        {\n            random.nextBytes(bytes);\n        }\n\n        protected byte[] engineGenerateSeed(int numBytes)\n        {\n            return secureRandom.generateSeed(numBytes);\n        }\n    }\n\n    public static class NonceAndIV\n        extends SecureRandomSpi\n    {\n        private SecureRandom random = new SP800SecureRandomBuilder(secureRandom, true)\n            .setPersonalizationString(generateNonceIVPersonalizationString(secureRandom))\n            .buildHash(new SHA512Digest(), secureRandom.generateSeed(32), false);\n\n        protected void engineSetSeed(byte[] bytes)\n        {\n            random.setSeed(bytes);\n        }\n\n        protected void engineNextBytes(byte[] bytes)\n        {\n            random.nextBytes(bytes);\n        }\n\n        protected byte[] engineGenerateSeed(int numBytes)\n        {\n            return secureRandom.generateSeed(numBytes);\n        }\n    }\n\n    public static class Mappings\n        extends AsymmetricAlgorithmProvider\n    {\n        public Mappings()\n        {\n        }\n\n        public void configure(ConfigurableProvider provider)\n        {\n            provider.addAlgorithm(\"SecureRandom.DEFAULT\", PREFIX + \"$Default\");\n            provider.addAlgorithm(\"SecureRandom.NONCEANDIV\", PREFIX + \"$NonceAndIV\");\n        }\n    }\n\n    private static byte[] generateDefaultPersonalizationString(SecureRandom random)\n    {\n        return Arrays.concatenate(Strings.toByteArray(\"Default\"), random.generateSeed(16),\n            Pack.longToBigEndian(Thread.currentThread().getId()), Pack.longToBigEndian(System.currentTimeMillis()));\n    }\n\n    private static byte[] generateNonceIVPersonalizationString(SecureRandom random)\n    {\n        return Arrays.concatenate(Strings.toByteArray(\"Nonce\"), random.generateSeed(16),\n            Pack.longToLittleEndian(Thread.currentThread().getId()), Pack.longToLittleEndian(System.currentTimeMillis()));\n    }\n}\n", "target": 0}
{"idx": 987, "func": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFacotry</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");   \n        \n        // [databind#2326] (2.7.9.6): one more 3rd party gadget\n        s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\");\n\n        // [databind#2334]: logback-core\n        s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\");\n\n        // [databind#2341]: jdom/jdom2\n        s.add(\"org.jdom.transform.XSLTransformer\");\n        s.add(\"org.jdom2.transform.XSLTransformer\");\n\n        // [databind#2387]: EHCache\n        s.add(\"net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup\");\n\n        // [databind#2389]: logback/jndi\n        s.add(\"ch.qos.logback.core.db.JNDIConnectionSource\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n}\n", "target": 0}
{"idx": 988, "func": "/**\n * Apache License\n * Version 2.0, January 2004\n * http://www.apache.org/licenses/\n *\n * TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n *\n * 1. Definitions.\n *\n * \"License\" shall mean the terms and conditions for use, reproduction,\n * and distribution as defined by Sections 1 through 9 of this document.\n *\n * \"Licensor\" shall mean the copyright owner or entity authorized by\n * the copyright owner that is granting the License.\n *\n * \"Legal Entity\" shall mean the union of the acting entity and all\n * other entities that control, are controlled by, or are under common\n * control with that entity. For the purposes of this definition,\n * \"control\" means (i) the power, direct or indirect, to cause the\n * direction or management of such entity, whether by contract or\n * otherwise, or (ii) ownership of fifty percent (50%) or more of the\n * outstanding shares, or (iii) beneficial ownership of such entity.\n *\n * \"You\" (or \"Your\") shall mean an individual or Legal Entity\n * exercising permissions granted by this License.\n *\n * \"Source\" form shall mean the preferred form for making modifications,\n * including but not limited to software source code, documentation\n * source, and configuration files.\n *\n * \"Object\" form shall mean any form resulting from mechanical\n * transformation or translation of a Source form, including but\n * not limited to compiled object code, generated documentation,\n * and conversions to other media types.\n *\n * \"Work\" shall mean the work of authorship, whether in Source or\n * Object form, made available under the License, as indicated by a\n * copyright notice that is included in or attached to the work\n * (an example is provided in the Appendix below).\n *\n * \"Derivative Works\" shall mean any work, whether in Source or Object\n * form, that is based on (or derived from) the Work and for which the\n * editorial revisions, annotations, elaborations, or other modifications\n * represent, as a whole, an original work of authorship. For the purposes\n * of this License, Derivative Works shall not include works that remain\n * separable from, or merely link (or bind by name) to the interfaces of,\n * the Work and Derivative Works thereof.\n *\n * \"Contribution\" shall mean any work of authorship, including\n * the original version of the Work and any modifications or additions\n * to that Work or Derivative Works thereof, that is intentionally\n * submitted to Licensor for inclusion in the Work by the copyright owner\n * or by an individual or Legal Entity authorized to submit on behalf of\n * the copyright owner. For the purposes of this definition, \"submitted\"\n * means any form of electronic, verbal, or written communication sent\n * to the Licensor or its representatives, including but not limited to\n * communication on electronic mailing lists, source code control systems,\n * and issue tracking systems that are managed by, or on behalf of, the\n * Licensor for the purpose of discussing and improving the Work, but\n * excluding communication that is conspicuously marked or otherwise\n * designated in writing by the copyright owner as \"Not a Contribution.\"\n *\n * \"Contributor\" shall mean Licensor and any individual or Legal Entity\n * on behalf of whom a Contribution has been received by Licensor and\n * subsequently incorporated within the Work.\n *\n * 2. Grant of Copyright License. Subject to the terms and conditions of\n * this License, each Contributor hereby grants to You a perpetual,\n * worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n * copyright license to reproduce, prepare Derivative Works of,\n * publicly display, publicly perform, sublicense, and distribute the\n * Work and such Derivative Works in Source or Object form.\n *\n * 3. Grant of Patent License. Subject to the terms and conditions of\n * this License, each Contributor hereby grants to You a perpetual,\n * worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n * (except as stated in this section) patent license to make, have made,\n * use, offer to sell, sell, import, and otherwise transfer the Work,\n * where such license applies only to those patent claims licensable\n * by such Contributor that are necessarily infringed by their\n * Contribution(s) alone or by combination of their Contribution(s)\n * with the Work to which such Contribution(s) was submitted. If You\n * institute patent litigation against any entity (including a\n * cross-claim or counterclaim in a lawsuit) alleging that the Work\n * or a Contribution incorporated within the Work constitutes direct\n * or contributory patent infringement, then any patent licenses\n * granted to You under this License for that Work shall terminate\n * as of the date such litigation is filed.\n *\n * 4. Redistribution. You may reproduce and distribute copies of the\n * Work or Derivative Works thereof in any medium, with or without\n * modifications, and in Source or Object form, provided that You\n * meet the following conditions:\n *\n * (a) You must give any other recipients of the Work or\n * Derivative Works a copy of this License; and\n *\n * (b) You must cause any modified files to carry prominent notices\n * stating that You changed the files; and\n *\n * (c) You must retain, in the Source form of any Derivative Works\n * that You distribute, all copyright, patent, trademark, and\n * attribution notices from the Source form of the Work,\n * excluding those notices that do not pertain to any part of\n * the Derivative Works; and\n *\n * (d) If the Work includes a \"NOTICE\" text file as part of its\n * distribution, then any Derivative Works that You distribute must\n * include a readable copy of the attribution notices contained\n * within such NOTICE file, excluding those notices that do not\n * pertain to any part of the Derivative Works, in at least one\n * of the following places: within a NOTICE text file distributed\n * as part of the Derivative Works; within the Source form or\n * documentation, if provided along with the Derivative Works; or,\n * within a display generated by the Derivative Works, if and\n * wherever such third-party notices normally appear. The contents\n * of the NOTICE file are for informational purposes only and\n * do not modify the License. You may add Your own attribution\n * notices within Derivative Works that You distribute, alongside\n * or as an addendum to the NOTICE text from the Work, provided\n * that such additional attribution notices cannot be construed\n * as modifying the License.\n *\n * You may add Your own copyright statement to Your modifications and\n * may provide additional or different license terms and conditions\n * for use, reproduction, or distribution of Your modifications, or\n * for any such Derivative Works as a whole, provided Your use,\n * reproduction, and distribution of the Work otherwise complies with\n * the conditions stated in this License.\n *\n * 5. Submission of Contributions. Unless You explicitly state otherwise,\n * any Contribution intentionally submitted for inclusion in the Work\n * by You to the Licensor shall be under the terms and conditions of\n * this License, without any additional terms or conditions.\n * Notwithstanding the above, nothing herein shall supersede or modify\n * the terms of any separate license agreement you may have executed\n * with Licensor regarding such Contributions.\n *\n * 6. Trademarks. This License does not grant permission to use the trade\n * names, trademarks, service marks, or product names of the Licensor,\n * except as required for reasonable and customary use in describing the\n * origin of the Work and reproducing the content of the NOTICE file.\n *\n * 7. Disclaimer of Warranty. Unless required by applicable law or\n * agreed to in writing, Licensor provides the Work (and each\n * Contributor provides its Contributions) on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied, including, without limitation, any warranties or conditions\n * of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n * PARTICULAR PURPOSE. You are solely responsible for determining the\n * appropriateness of using or redistributing the Work and assume any\n * risks associated with Your exercise of permissions under this License.\n *\n * 8. Limitation of Liability. In no event and under no legal theory,\n * whether in tort (including negligence), contract, or otherwise,\n * unless required by applicable law (such as deliberate and grossly\n * negligent acts) or agreed to in writing, shall any Contributor be\n * liable to You for damages, including any direct, indirect, special,\n * incidental, or consequential damages of any character arising as a\n * result of this License or out of the use or inability to use the\n * Work (including but not limited to damages for loss of goodwill,\n * work stoppage, computer failure or malfunction, or any and all\n * other commercial damages or losses), even if such Contributor\n * has been advised of the possibility of such damages.\n *\n * 9. Accepting Warranty or Additional Liability. While redistributing\n * the Work or Derivative Works thereof, You may choose to offer,\n * and charge a fee for, acceptance of support, warranty, indemnity,\n * or other liability obligations and/or rights consistent with this\n * License. However, in accepting such obligations, You may act only\n * on Your own behalf and on Your sole responsibility, not on behalf\n * of any other Contributor, and only if You agree to indemnify,\n * defend, and hold each Contributor harmless for any liability\n * incurred by, or claims asserted against, such Contributor by reason\n * of your accepting any such warranty or additional liability.\n *\n * END OF TERMS AND CONDITIONS\n *\n * APPENDIX: How to apply the Apache License to your work.\n *\n * To apply the Apache License to your work, attach the following\n * boilerplate notice, with the fields enclosed by brackets \"{}\"\n * replaced with your own identifying information. (Don't include\n * the brackets!)  The text should be enclosed in the appropriate\n * comment syntax for the file format. We also recommend that a\n * file or class name and description of purpose be included on the\n * same \"printed page\" as the copyright notice for easier\n * identification within third-party archives.\n *\n * Copyright 2014 Edgar Espina\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jooby;\n\nimport com.google.common.base.Joiner;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkState;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.escape.Escaper;\nimport com.google.common.html.HtmlEscapers;\nimport com.google.common.net.UrlEscapers;\nimport com.google.common.util.concurrent.MoreExecutors;\nimport com.google.inject.Binder;\nimport com.google.inject.Guice;\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.Provider;\nimport com.google.inject.ProvisionException;\nimport com.google.inject.Stage;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.internal.ProviderMethodsModule;\nimport com.google.inject.multibindings.Multibinder;\nimport com.google.inject.name.Named;\nimport com.google.inject.name.Names;\nimport com.google.inject.util.Types;\nimport com.typesafe.config.Config;\nimport com.typesafe.config.ConfigFactory;\nimport com.typesafe.config.ConfigObject;\nimport com.typesafe.config.ConfigValue;\nimport static com.typesafe.config.ConfigValueFactory.fromAnyRef;\nimport static java.util.Objects.requireNonNull;\nimport static org.jooby.Route.CONNECT;\nimport static org.jooby.Route.DELETE;\nimport org.jooby.Route.Definition;\nimport static org.jooby.Route.GET;\nimport static org.jooby.Route.HEAD;\nimport org.jooby.Route.Mapper;\nimport static org.jooby.Route.OPTIONS;\nimport static org.jooby.Route.PATCH;\nimport static org.jooby.Route.POST;\nimport static org.jooby.Route.PUT;\nimport static org.jooby.Route.TRACE;\nimport org.jooby.Session.Store;\nimport org.jooby.funzy.Throwing;\nimport org.jooby.funzy.Try;\nimport org.jooby.handlers.AssetHandler;\nimport org.jooby.internal.AppPrinter;\nimport org.jooby.internal.BuiltinParser;\nimport org.jooby.internal.BuiltinRenderer;\nimport org.jooby.internal.CookieSessionManager;\nimport org.jooby.internal.DefaulErrRenderer;\nimport org.jooby.internal.HttpHandlerImpl;\nimport org.jooby.internal.JvmInfo;\nimport org.jooby.internal.LocaleUtils;\nimport org.jooby.internal.ParameterNameProvider;\nimport org.jooby.internal.RequestScope;\nimport org.jooby.internal.RouteMetadata;\nimport org.jooby.internal.ServerExecutorProvider;\nimport org.jooby.internal.ServerLookup;\nimport org.jooby.internal.ServerSessionManager;\nimport org.jooby.internal.SessionManager;\nimport org.jooby.internal.SourceProvider;\nimport org.jooby.internal.TypeConverters;\nimport org.jooby.internal.handlers.HeadHandler;\nimport org.jooby.internal.handlers.OptionsHandler;\nimport org.jooby.internal.handlers.TraceHandler;\nimport org.jooby.internal.mvc.MvcRoutes;\nimport org.jooby.internal.mvc.MvcWebSocket;\nimport org.jooby.internal.parser.BeanParser;\nimport org.jooby.internal.parser.DateParser;\nimport org.jooby.internal.parser.LocalDateParser;\nimport org.jooby.internal.parser.LocaleParser;\nimport org.jooby.internal.parser.ParserExecutor;\nimport org.jooby.internal.parser.StaticMethodParser;\nimport org.jooby.internal.parser.StringConstructorParser;\nimport org.jooby.internal.parser.ZonedDateTimeParser;\nimport org.jooby.internal.ssl.SslContextProvider;\nimport org.jooby.mvc.Consumes;\nimport org.jooby.mvc.Produces;\nimport org.jooby.scope.Providers;\nimport org.jooby.scope.RequestScoped;\nimport org.jooby.spi.HttpHandler;\nimport org.jooby.spi.Server;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.inject.Singleton;\nimport javax.net.ssl.SSLContext;\nimport java.io.File;\nimport java.lang.reflect.Type;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.text.DecimalFormat;\nimport java.text.NumberFormat;\nimport java.time.ZoneId;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\n/**\n * <h1>jooby</h1>\n * <h2>getting started</h2>\n *\n * <pre>\n * public class MyApp extends Jooby {\n *\n *   {\n *      use(new Jackson()); // 1. JSON serializer.\n *\n *      // 2. Define a route\n *      get(\"/\", req {@literal ->} {\n *        Map{@literal <}String, Object{@literal >} model = ...;\n *        return model;\n *      }\n *   }\n *\n *  public static void main(String[] args) {\n *    run(MyApp::new, args); // 3. Done!\n *  }\n * }\n * </pre>\n *\n * <h2>application.conf</h2>\n * <p>\n * Jooby delegate configuration management to <a\n * href=\"https://github.com/typesafehub/config\">TypeSafe Config</a>.\n * </p>\n *\n * <p>\n * By default Jooby looks for an <code>application.conf</code>. If\n * you want to specify a different file or location, you can do it with {@link #conf(String)}.\n * </p>\n *\n * <p>\n * <a href=\"https://github.com/typesafehub/config\">TypeSafe Config</a> uses a hierarchical model to\n * define and override properties.\n * </p>\n * <p>\n * A {@link Jooby.Module} might provides his own set of properties through the\n * {@link Jooby.Module#config()} method. By default, this method returns an empty config object.\n * </p>\n * For example:\n *\n * <pre>\n *   use(new M1());\n *   use(new M2());\n *   use(new M3());\n * </pre>\n *\n * Previous example had the following order (first-listed are higher priority):\n * <ul>\n * <li>arguments properties</li>\n * <li>System properties</li>\n * <li>application.conf</li>\n * <li>M3 properties</li>\n * <li>M2 properties</li>\n * <li>M1 properties</li>\n * </ul>\n * <p>\n * Command line argmuents or system properties takes precedence over any application specific\n * property.\n * </p>\n *\n * <h2>env</h2>\n * <p>\n * Jooby defines one mode or environment: <strong>dev</strong>. In Jooby, <strong>dev</strong>\n * is special and some modules could apply special settings while running in <strong>dev</strong>.\n * Any other env is usually considered a <code>prod</code> like env. But that depends on module\n * implementor.\n * </p>\n * <p>\n * An <code>environment</code> can be defined in your <code>.conf</code> file using the\n * <code>application.env</code> property. If missing, Jooby set the <code>env</code> for you to\n * <strong>dev</strong>.\n * </p>\n * <p>\n * There is more at {@link Env} please read the {@link Env} javadoc.\n * </p>\n *\n * <h2>modules: the jump to full-stack framework</h2>\n * <p>\n * {@link Jooby.Module Modules} are quite similar to a Guice modules except that the configure\n * callback has been complementing with {@link Env} and {@link Config}.\n * </p>\n *\n * <pre>\n *   public class MyModule implements Jooby.Module {\n *     public void configure(Env env, Config config, Binder binder) {\n *     }\n *   }\n * </pre>\n *\n * From the configure callback you can bind your services as you usually do in a Guice app.\n * <p>\n * There is more at {@link Jooby.Module} so please read the {@link Jooby.Module} javadoc.\n * </p>\n *\n * <h2>path patterns</h2>\n * <p>\n * Jooby supports Ant-style path patterns:\n * </p>\n * <p>\n * Some examples:\n * </p>\n * <ul>\n * <li>{@code com/t?st.html} - matches {@code com/test.html} but also {@code com/tast.html} or\n * {@code com/txst.html}</li>\n * <li>{@code com/*.html} - matches all {@code .html} files in the {@code com} directory</li>\n * <li><code>com/{@literal **}/test.html</code> - matches all {@code test.html} files underneath the\n * {@code com} path</li>\n * <li>{@code **}/{@code *} - matches any path at any level.</li>\n * <li>{@code *} - matches any path at any level, shorthand for {@code **}/{@code *}.</li>\n * </ul>\n *\n * <h3>variables</h3>\n * <p>\n * Jooby supports path parameters too:\n * </p>\n * <p>\n * Some examples:\n * </p>\n * <ul>\n * <li><code> /user/{id}</code> - /user/* and give you access to the <code>id</code> var.</li>\n * <li><code> /user/:id</code> - /user/* and give you access to the <code>id</code> var.</li>\n * <li><code> /user/{id:\\\\d+}</code> - /user/[digits] and give you access to the numeric\n * <code>id</code> var.</li>\n * </ul>\n *\n * <h2>routes</h2>\n * <p>\n * Routes perform actions in response to a server HTTP request.\n * </p>\n * <p>\n * Routes are executed in the order they are defined, for example:\n * </p>\n *\n * <pre>\n *   get(\"/\", (req, rsp) {@literal ->} {\n *     log.info(\"first\"); // start here and go to second\n *   });\n *\n *   get(\"/\", (req, rsp) {@literal ->} {\n *     log.info(\"second\"); // execute after first and go to final\n *   });\n *\n *   get(\"/\", (req, rsp) {@literal ->} {\n *     rsp.send(\"final\"); // done!\n *   });\n * </pre>\n *\n * Previous example can be rewritten using {@link Route.Filter}:\n *\n * <pre>\n *   get(\"/\", (req, rsp, chain) {@literal ->} {\n *     log.info(\"first\"); // start here and go to second\n *     chain.next(req, rsp);\n *   });\n *\n *   get(\"/\", (req, rsp, chain) {@literal ->} {\n *     log.info(\"second\"); // execute after first and go to final\n *     chain.next(req, rsp);\n *   });\n *\n *   get(\"/\", (req, rsp) {@literal ->} {\n *     rsp.send(\"final\"); // done!\n *   });\n * </pre>\n *\n * Due to the use of lambdas a route is a singleton and you should NOT use global variables. For\n * example this is a bad practice:\n *\n * <pre>\n *  List{@literal <}String{@literal >} names = new ArrayList{@literal <}{@literal >}(); // names produces side effects\n *  get(\"/\", (req, rsp) {@literal ->} {\n *     names.add(req.param(\"name\").value();\n *     // response will be different between calls.\n *     rsp.send(names);\n *   });\n * </pre>\n *\n * <h3>mvc routes</h3>\n * <p>\n * A Mvc route use annotations to define routes:\n * </p>\n *\n * <pre>\n *   use(MyRoute.class);\n *   ...\n *\n *   // MyRoute.java\n *   {@literal @}Path(\"/\")\n *   public class MyRoute {\n *\n *    {@literal @}GET\n *    public String hello() {\n *      return \"Hello Jooby\";\n *    }\n *   }\n * </pre>\n * <p>\n * Programming model is quite similar to JAX-RS/Jersey with some minor differences and/or\n * simplifications.\n * </p>\n *\n * <p>\n * To learn more about Mvc Routes, please check {@link org.jooby.mvc.Path},\n * {@link org.jooby.mvc.Produces} {@link org.jooby.mvc.Consumes} javadoc.\n * </p>\n *\n * <h2>static files</h2>\n * <p>\n * Static files, like: *.js, *.css, ..., etc... can be served with:\n * </p>\n *\n * <pre>\n *   assets(\"assets/**\");\n * </pre>\n * <p>\n * Classpath resources under the <code>/assets</code> folder will be accessible from client/browser.\n * </p>\n *\n * <h2>lifecyle</h2>\n * <p>\n * We do provide {@link #onStart(Throwing.Consumer)} and {@link #onStop(Throwing.Consumer)} callbacks.\n * These callbacks are executed are application startup or shutdown time:\n * </p>\n *\n * <pre>{@code\n * {\n *   onStart(() -> {\n *     log.info(\"Welcome!\");\n *   });\n *\n *   onStop(() -> {\n *     log.info(\"Bye!\");\n *   });\n * }\n * }</pre>\n *\n * <p>\n * From life cycle callbacks you can access to application services:\n * </p>\n *\n * <pre>{@code\n * {\n *   onStart(registry -> {\n *     MyDatabase db = registry.require(MyDatabase.class);\n *     // do something with databse:\n *   });\n * }\n * }</pre>\n *\n * @author edgar\n * @see Jooby.Module\n * @since 0.1.0\n */\npublic class Jooby implements Router, LifeCycle, Registry {\n\n  /**\n   * <pre>{@code\n   * {\n   *   on(\"dev\", () -> {\n   *     // run something on dev\n   *   }).orElse(() -> {\n   *     // run something on prod\n   *   });\n   * }\n   * }</pre>\n   */\n  public interface EnvPredicate {\n\n    /**\n     * <pre>{@code\n     * {\n     *   on(\"dev\", () -> {\n     *     // run something on dev\n     *   }).orElse(() -> {\n     *     // run something on prod\n     *   });\n     * }\n     * }</pre>\n     *\n     * @param callback Env callback.\n     */\n    default void orElse(final Runnable callback) {\n      orElse(conf -> callback.run());\n    }\n\n    /**\n     * <pre>{@code\n     * {\n     *   on(\"dev\", () -> {\n     *     // run something on dev\n     *   }).orElse(conf -> {\n     *     // run something on prod\n     *   });\n     * }\n     * }</pre>\n     *\n     * @param callback Env callback.\n     */\n    void orElse(Consumer<Config> callback);\n\n  }\n\n  /**\n   * A module can publish or produces: {@link Route.Definition routes}, {@link Parser},\n   * {@link Renderer}, and any other application specific service or contract of your choice.\n   * <p>\n   * It is similar to {@link com.google.inject.Module} except for the callback method receives a\n   * {@link Env}, {@link Config} and {@link Binder}.\n   * </p>\n   *\n   * <p>\n   * A module can provide his own set of properties through the {@link #config()} method. By\n   * default, this method returns an empty config object.\n   * </p>\n   * For example:\n   *\n   * <pre>\n   *   use(new M1());\n   *   use(new M2());\n   *   use(new M3());\n   * </pre>\n   *\n   * Previous example had the following order (first-listed are higher priority):\n   * <ul>\n   * <li>System properties</li>\n   * <li>application.conf</li>\n   * <li>M3 properties</li>\n   * <li>M2 properties</li>\n   * <li>M1 properties</li>\n   * </ul>\n   *\n   * <p>\n   * A module can provide start/stop methods in order to start or close resources.\n   * </p>\n   *\n   * @author edgar\n   * @see Jooby#use(Jooby.Module)\n   * @since 0.1.0\n   */\n  public interface Module {\n\n    /**\n     * @return Produces a module config object (when need it). By default a module doesn't produce\n     *         any configuration object.\n     */\n    @Nonnull\n    default Config config() {\n      return ConfigFactory.empty();\n    }\n\n    /**\n     * Configure and produces bindings for the underlying application. A module can optimize or\n     * customize a service by checking current the {@link Env application env} and/or the current\n     * application properties available from {@link Config}.\n     *\n     * @param env The current application's env. Not null.\n     * @param conf The current config object. Not null.\n     * @param binder A guice binder. Not null.\n     * @throws Throwable If something goes wrong.\n     */\n    void configure(Env env, Config conf, Binder binder) throws Throwable;\n\n  }\n\n  static class MvcClass implements Route.Props<MvcClass> {\n    Class<?> routeClass;\n\n    String path;\n\n    ImmutableMap.Builder<String, Object> attrs = ImmutableMap.builder();\n\n    private List<MediaType> consumes;\n\n    private String name;\n\n    private List<MediaType> produces;\n\n    private List<String> excludes;\n\n    private Mapper<?> mapper;\n\n    private String prefix;\n\n    private String renderer;\n\n    public MvcClass(final Class<?> routeClass, final String path, final String prefix) {\n      this.routeClass = routeClass;\n      this.path = path;\n      this.prefix = prefix;\n    }\n\n    @Override\n    public MvcClass attr(final String name, final Object value) {\n      attrs.put(name, value);\n      return this;\n    }\n\n    @Override\n    public MvcClass name(final String name) {\n      this.name = name;\n      return this;\n    }\n\n    @Override\n    public MvcClass consumes(final List<MediaType> consumes) {\n      this.consumes = consumes;\n      return this;\n    }\n\n    @Override\n    public MvcClass produces(final List<MediaType> produces) {\n      this.produces = produces;\n      return this;\n    }\n\n    @Override\n    public MvcClass excludes(final List<String> excludes) {\n      this.excludes = excludes;\n      return this;\n    }\n\n    @Override\n    public MvcClass map(final Mapper<?> mapper) {\n      this.mapper = mapper;\n      return this;\n    }\n\n    @Override\n    public String renderer() {\n      return renderer;\n    }\n\n    @Override\n    public MvcClass renderer(final String name) {\n      this.renderer = name;\n      return this;\n    }\n\n    public Route.Definition apply(final Route.Definition route) {\n      attrs.build().forEach(route::attr);\n      if (name != null) {\n        route.name(name);\n      }\n      if (prefix != null) {\n        route.name(prefix + \"/\" + route.name());\n      }\n      if (consumes != null) {\n        route.consumes(consumes);\n      }\n      if (produces != null) {\n        route.produces(produces);\n      }\n      if (excludes != null) {\n        route.excludes(excludes);\n      }\n      if (mapper != null) {\n        route.map(mapper);\n      }\n      if (renderer != null) {\n        route.renderer(renderer);\n      }\n      return route;\n    }\n  }\n\n  private static class EnvDep {\n    Predicate<String> predicate;\n\n    Consumer<Config> callback;\n\n    public EnvDep(final Predicate<String> predicate, final Consumer<Config> callback) {\n      this.predicate = predicate;\n      this.callback = callback;\n    }\n  }\n\n  static {\n    // set pid as system property\n    String pid = System.getProperty(\"pid\", JvmInfo.pid() + \"\");\n    System.setProperty(\"pid\", pid);\n  }\n\n  /**\n   * Keep track of routes.\n   */\n  private transient Set<Object> bag = new LinkedHashSet<>();\n\n  /**\n   * The override config. Optional.\n   */\n  private transient Config srcconf;\n\n  private final transient AtomicBoolean started = new AtomicBoolean(false);\n\n  /** Keep the global injector instance. */\n  private transient Injector injector;\n\n  /** Session store. */\n  private transient Session.Definition session = new Session.Definition(Session.Mem.class);\n\n  /** Env builder. */\n  private transient Env.Builder env = Env.DEFAULT;\n\n  /** Route's prefix. */\n  private transient String prefix;\n\n  /** startup callback . */\n  private transient List<Throwing.Consumer<Registry>> onStart = new ArrayList<>();\n  private transient List<Throwing.Consumer<Registry>> onStarted = new ArrayList<>();\n\n  /** stop callback . */\n  private transient List<Throwing.Consumer<Registry>> onStop = new ArrayList<>();\n\n  /** Mappers . */\n  @SuppressWarnings(\"rawtypes\")\n  private transient Mapper mapper;\n\n  /** Don't add same mapper twice . */\n  private transient Set<String> mappers = new HashSet<>();\n\n  /** Bean parser . */\n  private transient Optional<Parser> beanParser = Optional.empty();\n\n  private transient ServerLookup server = new ServerLookup();\n\n  private transient String dateFormat;\n\n  private transient Charset charset;\n\n  private transient String[] languages;\n\n  private transient ZoneId zoneId;\n\n  private transient Integer port;\n\n  private transient Integer securePort;\n\n  private transient String numberFormat;\n\n  private transient boolean http2;\n\n  private transient List<Consumer<Binder>> executors = new ArrayList<>();\n\n  private transient boolean defaultExecSet;\n\n  private boolean throwBootstrapException;\n\n  /**\n   * creates the injector\n   */\n  private transient BiFunction<Stage, com.google.inject.Module, Injector> injectorFactory = Guice::createInjector;\n\n  private transient List<Jooby> apprefs;\n\n  private transient LinkedList<String> path = new LinkedList<>();\n\n  private transient String confname;\n\n  private transient boolean caseSensitiveRouting = true;\n\n  private transient String classname;\n\n  /**\n   * Creates a new {@link Jooby} application.\n   */\n  public Jooby() {\n    this(null);\n  }\n\n  /**\n   * Creates a new application and prefix all the names of the routes with the given prefix. Useful,\n   * for dynamic/advanced routing. See {@link Route.Chain#next(String, Request, Response)}.\n   *\n   * @param prefix Route name prefix.\n   */\n  public Jooby(final String prefix) {\n    this.prefix = prefix;\n    use(server);\n    this.classname = classname(getClass().getName());\n  }\n\n  @Override\n  public Route.Collection path(String path, Runnable action) {\n    this.path.addLast(Route.normalize(path));\n    Route.Collection collection = with(action);\n    this.path.removeLast();\n    return collection;\n  }\n\n  @Override\n  public Jooby use(final Jooby app) {\n    return use(prefixPath(null), app);\n  }\n\n  private Optional<String> prefixPath(@Nullable String tail) {\n    return path.size() == 0\n        ? tail == null ? Optional.empty() : Optional.of(Route.normalize(tail))\n        : Optional.of(path.stream()\n        .collect(Collectors.joining(\"\", \"\", tail == null\n            ? \"\" : Route.normalize(tail))));\n  }\n\n  @Override\n  public Jooby use(final String path, final Jooby app) {\n    return use(prefixPath(path), app);\n  }\n\n  /**\n   * Use the provided HTTP server.\n   *\n   * @param server Server.\n   * @return This jooby instance.\n   */\n  public Jooby server(final Class<? extends Server> server) {\n    requireNonNull(server, \"Server required.\");\n    // remove server lookup\n    List<Object> tmp = bag.stream()\n        .skip(1)\n        .collect(Collectors.toList());\n    tmp.add(0,\n        (Module) (env, conf, binder) -> binder.bind(Server.class).to(server).asEagerSingleton());\n    bag.clear();\n    bag.addAll(tmp);\n    return this;\n  }\n\n  private Jooby use(final Optional<String> path, final Jooby app) {\n    requireNonNull(app, \"App is required.\");\n\n    Function<Route.Definition, Route.Definition> rewrite = r -> {\n      return path.map(p -> {\n        Route.Definition result = new Route.Definition(r.method(), p + r.pattern(), r.filter());\n        result.consumes(r.consumes());\n        result.produces(r.produces());\n        result.excludes(r.excludes());\n        return result;\n      }).orElse(r);\n    };\n\n    app.bag.forEach(it -> {\n      if (it instanceof Route.Definition) {\n        this.bag.add(rewrite.apply((Definition) it));\n      } else if (it instanceof MvcClass) {\n        Object routes = path.<Object>map(p -> new MvcClass(((MvcClass) it).routeClass, p, prefix))\n            .orElse(it);\n        this.bag.add(routes);\n      } else {\n        // everything else\n        this.bag.add(it);\n      }\n    });\n    // start/stop callback\n    app.onStart.forEach(this.onStart::add);\n    app.onStarted.forEach(this.onStarted::add);\n    app.onStop.forEach(this.onStop::add);\n    // mapper\n    if (app.mapper != null) {\n      this.map(app.mapper);\n    }\n    if (apprefs == null) {\n      apprefs = new ArrayList<>();\n    }\n    apprefs.add(app);\n    return this;\n  }\n\n  /**\n   * Set a custom {@link Env.Builder} to use.\n   *\n   * @param env A custom env builder.\n   * @return This jooby instance.\n   */\n  public Jooby env(final Env.Builder env) {\n    this.env = requireNonNull(env, \"Env builder is required.\");\n    return this;\n  }\n\n  @Override\n  public Jooby onStart(final Throwing.Runnable callback) {\n    LifeCycle.super.onStart(callback);\n    return this;\n  }\n\n  @Override\n  public Jooby onStart(final Throwing.Consumer<Registry> callback) {\n    requireNonNull(callback, \"Callback is required.\");\n    onStart.add(callback);\n    return this;\n  }\n\n  @Override\n  public Jooby onStarted(final Throwing.Runnable callback) {\n    LifeCycle.super.onStarted(callback);\n    return this;\n  }\n\n  @Override\n  public Jooby onStarted(final Throwing.Consumer<Registry> callback) {\n    requireNonNull(callback, \"Callback is required.\");\n    onStarted.add(callback);\n    return this;\n  }\n\n  @Override\n  public Jooby onStop(final Throwing.Runnable callback) {\n    LifeCycle.super.onStop(callback);\n    return this;\n  }\n\n  @Override\n  public Jooby onStop(final Throwing.Consumer<Registry> callback) {\n    requireNonNull(callback, \"Callback is required.\");\n    onStop.add(callback);\n    return this;\n  }\n\n  /**\n   * Run the given callback if and only if, application runs in the given environment.\n   *\n   * <pre>\n   * {\n   *   on(\"dev\", () {@literal ->} {\n   *     use(new DevModule());\n   *   });\n   * }\n   * </pre>\n   *\n   * There is an else clause which is the opposite version of the env predicate:\n   *\n   * <pre>\n   * {\n   *   on(\"dev\", () {@literal ->} {\n   *     use(new DevModule());\n   *   }).orElse(() {@literal ->} {\n   *     use(new RealModule());\n   *   });\n   * }\n   * </pre>\n   *\n   * @param env Environment where we want to run the callback.\n   * @param callback An env callback.\n   * @return This jooby instance.\n   */\n  public EnvPredicate on(final String env, final Runnable callback) {\n    requireNonNull(env, \"Env is required.\");\n    return on(envpredicate(env), callback);\n  }\n\n  /**\n   * Run the given callback if and only if, application runs in the given environment.\n   *\n   * <pre>\n   * {\n   *   on(\"dev\", () {@literal ->} {\n   *     use(new DevModule());\n   *   });\n   * }\n   * </pre>\n   *\n   * There is an else clause which is the opposite version of the env predicate:\n   *\n   * <pre>\n   * {\n   *   on(\"dev\", conf {@literal ->} {\n   *     use(new DevModule());\n   *   }).orElse(conf {@literal ->} {\n   *     use(new RealModule());\n   *   });\n   * }\n   * </pre>\n   *\n   * @param env Environment where we want to run the callback.\n   * @param callback An env callback.\n   * @return This jooby instance.\n   */\n  public EnvPredicate on(final String env, final Consumer<Config> callback) {\n    requireNonNull(env, \"Env is required.\");\n    return on(envpredicate(env), callback);\n  }\n\n  /**\n   * Run the given callback if and only if, application runs in the given envirobment.\n   *\n   * <pre>\n   * {\n   *   on(\"dev\", \"test\", () {@literal ->} {\n   *     use(new DevModule());\n   *   });\n   * }\n   * </pre>\n   *\n   * There is an else clause which is the opposite version of the env predicate:\n   *\n   * <pre>\n   * {\n   *   on(env {@literal ->} env.equals(\"dev\"), () {@literal ->} {\n   *     use(new DevModule());\n   *   }).orElse(() {@literal ->} {\n   *     use(new RealModule());\n   *   });\n   * }\n   * </pre>\n   *\n   * @param predicate Predicate to check the environment.\n   * @param callback An env callback.\n   * @return This jooby instance.\n   */\n  public EnvPredicate on(final Predicate<String> predicate, final Runnable callback) {\n    requireNonNull(predicate, \"Predicate is required.\");\n    requireNonNull(callback, \"Callback is required.\");\n\n    return on(predicate, conf -> callback.run());\n  }\n\n  /**\n   * Run the given callback if and only if, application runs in the given environment.\n   *\n   * <pre>\n   * {\n   *   on(env {@literal ->} env.equals(\"dev\"), conf {@literal ->} {\n   *     use(new DevModule());\n   *   });\n   * }\n   * </pre>\n   *\n   * @param predicate Predicate to check the environment.\n   * @param callback An env callback.\n   * @return This jooby instance.\n   */\n  public EnvPredicate on(final Predicate<String> predicate, final Consumer<Config> callback) {\n    requireNonNull(predicate, \"Predicate is required.\");\n    requireNonNull(callback, \"Callback is required.\");\n    this.bag.add(new EnvDep(predicate, callback));\n\n    return otherwise -> this.bag.add(new EnvDep(predicate.negate(), otherwise));\n  }\n\n  /**\n   * Run the given callback if and only if, application runs in the given environment.\n   *\n   * <pre>\n   * {\n   *   on(\"dev\", \"test\", \"mock\", () {@literal ->} {\n   *     use(new DevModule());\n   *   });\n   * }\n   * </pre>\n   *\n   * @param env1 Environment where we want to run the callback.\n   * @param env2 Environment where we want to run the callback.\n   * @param env3 Environment where we want to run the callback.\n   * @param callback An env callback.\n   * @return This jooby instance.\n   */\n  public Jooby on(final String env1, final String env2, final String env3,\n      final Runnable callback) {\n    on(envpredicate(env1).or(envpredicate(env2)).or(envpredicate(env3)), callback);\n    return this;\n  }\n\n  @Override\n  public <T> T require(final Key<T> type) {\n    checkState(injector != null,\n        \"Registry is not ready. Require calls are available at application startup time, see http://jooby.org/doc/#application-life-cycle\");\n    try {\n      return injector.getInstance(type);\n    } catch (ProvisionException x) {\n      Throwable cause = x.getCause();\n      if (cause instanceof Err) {\n        throw (Err) cause;\n      }\n      throw x;\n    }\n  }\n\n  @Override\n  public Route.OneArgHandler promise(final Deferred.Initializer initializer) {\n    return req -> {\n      return new Deferred(initializer);\n    };\n  }\n\n  @Override\n  public Route.OneArgHandler promise(final String executor,\n      final Deferred.Initializer initializer) {\n    return req -> new Deferred(executor, initializer);\n  }\n\n  @Override\n  public Route.OneArgHandler promise(final Deferred.Initializer0 initializer) {\n    return req -> {\n      return new Deferred(initializer);\n    };\n  }\n\n  @Override\n  public Route.OneArgHandler promise(final String executor,\n      final Deferred.Initializer0 initializer) {\n    return req -> new Deferred(executor, initializer);\n  }\n\n  /**\n   * Setup a session store to use. Useful if you want/need to persist sessions between shutdowns,\n   * apply timeout policies, etc...\n   *\n   * Jooby comes with a dozen of {@link Session.Store}, checkout the\n   * <a href=\"http://jooby.org/doc/session\">session modules</a>.\n   *\n   * This method returns a {@link Session.Definition} objects that let you customize the session\n   * cookie.\n   *\n   * @param store A session store.\n   * @return A session store definition.\n   */\n  public Session.Definition session(final Class<? extends Session.Store> store) {\n    this.session = new Session.Definition(requireNonNull(store, \"A session store is required.\"));\n    return this.session;\n  }\n\n  /**\n   * Setup a session store that saves data in a the session cookie. It makes the application\n   * stateless, which help to scale easily. Keep in mind that a cookie has a limited size (up to\n   * 4kb) so you must pay attention to what you put in the session object (don't use as cache).\n   *\n   * Cookie session signed data using the <code>application.secret</code> property, so you must\n   * provide an <code>application.secret</code> value. On dev environment you can set it in your\n   * <code>.conf</code> file. In prod is probably better to provide as command line argument and/or\n   * environment variable. Just make sure to keep it private.\n   *\n   * Please note {@link Session#id()}, {@link Session#accessedAt()}, etc.. make no sense for cookie\n   * sessions, just the {@link Session#attributes()}.\n   *\n   * This method returns a {@link Session.Definition} objects that let you customize the session\n   * cookie.\n   *\n   * @return A session definition/configuration object.\n   */\n  public Session.Definition cookieSession() {\n    this.session = new Session.Definition();\n    return this.session;\n  }\n\n  /**\n   * Setup a session store to use. Useful if you want/need to persist sessions between shutdowns,\n   * apply timeout policies, etc...\n   *\n   * Jooby comes with a dozen of {@link Session.Store}, checkout the\n   * <a href=\"http://jooby.org/doc/session\">session modules</a>.\n   *\n   * This method returns a {@link Session.Definition} objects that let you customize the session\n   * cookie.\n   *\n   * @param store A session store.\n   * @return A session store definition.\n   */\n  public Session.Definition session(final Session.Store store) {\n    this.session = new Session.Definition(requireNonNull(store, \"A session store is required.\"));\n    return this.session;\n  }\n\n  /**\n   * Register a new param/body converter. See {@link Parser} for more details.\n   *\n   * @param parser A parser.\n   * @return This jooby instance.\n   */\n  public Jooby parser(final Parser parser) {\n    if (parser instanceof BeanParser) {\n      beanParser = Optional.of(parser);\n    } else {\n      bag.add(requireNonNull(parser, \"A parser is required.\"));\n    }\n    return this;\n  }\n\n  /**\n   * Append a response {@link Renderer} for write HTTP messages.\n   *\n   * @param renderer A renderer renderer.\n   * @return This jooby instance.\n   */\n  public Jooby renderer(final Renderer renderer) {\n    this.bag.add(requireNonNull(renderer, \"A renderer is required.\"));\n    return this;\n  }\n\n  @Override\n  public Route.Definition before(final String method, final String pattern,\n      final Route.Before handler) {\n    return appendDefinition(method, pattern, handler);\n  }\n\n  @Override\n  public Route.Definition after(final String method, final String pattern,\n      final Route.After handler) {\n    return appendDefinition(method, pattern, handler);\n  }\n\n  @Override\n  public Route.Definition complete(final String method, final String pattern,\n      final Route.Complete handler) {\n    return appendDefinition(method, pattern, handler);\n  }\n\n  @Override\n  public Route.Definition use(final String path, final Route.Filter filter) {\n    return appendDefinition(\"*\", path, filter);\n  }\n\n  @Override\n  public Route.Definition use(final String verb, final String path, final Route.Filter filter) {\n    return appendDefinition(verb, path, filter);\n  }\n\n  @Override\n  public Route.Definition use(final String verb, final String path, final Route.Handler handler) {\n    return appendDefinition(verb, path, handler);\n  }\n\n  @Override\n  public Route.Definition use(final String path, final Route.Handler handler) {\n    return appendDefinition(\"*\", path, handler);\n  }\n\n  @Override\n  public Route.Definition use(final String path, final Route.OneArgHandler handler) {\n    return appendDefinition(\"*\", path, handler);\n  }\n\n  @Override\n  public Route.Definition get(final String path, final Route.Handler handler) {\n    return appendDefinition(GET, path, handler);\n  }\n\n  @Override\n  public Route.Collection get(final String path1, final String path2, final Route.Handler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{get(path1, handler), get(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection get(final String path1, final String path2, final String path3,\n      final Route.Handler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{get(path1, handler), get(path2, handler), get(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition get(final String path, final Route.OneArgHandler handler) {\n    return appendDefinition(GET, path, handler);\n  }\n\n  @Override\n  public Route.Collection get(final String path1, final String path2,\n      final Route.OneArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{get(path1, handler), get(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection get(final String path1, final String path2,\n      final String path3, final Route.OneArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{get(path1, handler), get(path2, handler), get(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition get(final String path, final Route.ZeroArgHandler handler) {\n    return appendDefinition(GET, path, handler);\n  }\n\n  @Override\n  public Route.Collection get(final String path1, final String path2,\n      final Route.ZeroArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{get(path1, handler), get(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection get(final String path1, final String path2,\n      final String path3, final Route.ZeroArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{get(path1, handler), get(path2, handler), get(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition get(final String path, final Route.Filter filter) {\n    return appendDefinition(GET, path, filter);\n  }\n\n  @Override\n  public Route.Collection get(final String path1, final String path2, final Route.Filter filter) {\n    return new Route.Collection(new Route.Definition[]{get(path1, filter), get(path2, filter)});\n  }\n\n  @Override\n  public Route.Collection get(final String path1, final String path2,\n      final String path3, final Route.Filter filter) {\n    return new Route.Collection(\n        new Route.Definition[]{get(path1, filter), get(path2, filter), get(path3, filter)});\n  }\n\n  @Override\n  public Route.Definition post(final String path, final Route.Handler handler) {\n    return appendDefinition(POST, path, handler);\n  }\n\n  @Override\n  public Route.Collection post(final String path1, final String path2,\n      final Route.Handler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{post(path1, handler), post(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection post(final String path1, final String path2,\n      final String path3, final Route.Handler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{post(path1, handler), post(path2, handler), post(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition post(final String path, final Route.OneArgHandler handler) {\n    return appendDefinition(POST, path, handler);\n  }\n\n  @Override\n  public Route.Collection post(final String path1, final String path2,\n      final Route.OneArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{post(path1, handler), post(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection post(final String path1, final String path2,\n      final String path3, final Route.OneArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{post(path1, handler), post(path2, handler), post(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition post(final String path, final Route.ZeroArgHandler handler) {\n    return appendDefinition(POST, path, handler);\n  }\n\n  @Override\n  public Route.Collection post(final String path1, final String path2,\n      final Route.ZeroArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{post(path1, handler), post(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection post(final String path1, final String path2,\n      final String path3, final Route.ZeroArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{post(path1, handler), post(path2, handler), post(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition post(final String path, final Route.Filter filter) {\n    return appendDefinition(POST, path, filter);\n  }\n\n  @Override\n  public Route.Collection post(final String path1, final String path2,\n      final Route.Filter filter) {\n    return new Route.Collection(\n        new Route.Definition[]{post(path1, filter), post(path2, filter)});\n  }\n\n  @Override\n  public Route.Collection post(final String path1, final String path2,\n      final String path3, final Route.Filter filter) {\n    return new Route.Collection(\n        new Route.Definition[]{post(path1, filter), post(path2, filter), post(path3, filter)});\n  }\n\n  @Override\n  public Route.Definition head(final String path, final Route.Handler handler) {\n    return appendDefinition(HEAD, path, handler);\n  }\n\n  @Override\n  public Route.Definition head(final String path,\n      final Route.OneArgHandler handler) {\n    return appendDefinition(HEAD, path, handler);\n  }\n\n  @Override\n  public Route.Definition head(final String path, final Route.ZeroArgHandler handler) {\n    return appendDefinition(HEAD, path, handler);\n  }\n\n  @Override\n  public Route.Definition head(final String path, final Route.Filter filter) {\n    return appendDefinition(HEAD, path, filter);\n  }\n\n  @Override\n  public Route.Definition head() {\n    return appendDefinition(HEAD, \"*\", filter(HeadHandler.class)).name(\"*.head\");\n  }\n\n  @Override\n  public Route.Definition options(final String path, final Route.Handler handler) {\n    return appendDefinition(OPTIONS, path, handler);\n  }\n\n  @Override\n  public Route.Definition options(final String path,\n      final Route.OneArgHandler handler) {\n    return appendDefinition(OPTIONS, path, handler);\n  }\n\n  @Override\n  public Route.Definition options(final String path,\n      final Route.ZeroArgHandler handler) {\n    return appendDefinition(OPTIONS, path, handler);\n  }\n\n  @Override\n  public Route.Definition options(final String path,\n      final Route.Filter filter) {\n    return appendDefinition(OPTIONS, path, filter);\n  }\n\n  @Override\n  public Route.Definition options() {\n    return appendDefinition(OPTIONS, \"*\", handler(OptionsHandler.class)).name(\"*.options\");\n  }\n\n  @Override\n  public Route.Definition put(final String path,\n      final Route.Handler handler) {\n    return appendDefinition(PUT, path, handler);\n  }\n\n  @Override\n  public Route.Collection put(final String path1, final String path2,\n      final Route.Handler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{put(path1, handler), put(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection put(final String path1, final String path2,\n      final String path3, final Route.Handler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{put(path1, handler), put(path2, handler), put(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition put(final String path,\n      final Route.OneArgHandler handler) {\n    return appendDefinition(PUT, path, handler);\n  }\n\n  @Override\n  public Route.Collection put(final String path1, final String path2,\n      final Route.OneArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{put(path1, handler), put(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection put(final String path1, final String path2,\n      final String path3, final Route.OneArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{put(path1, handler), put(path2, handler), put(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition put(final String path,\n      final Route.ZeroArgHandler handler) {\n    return appendDefinition(PUT, path, handler);\n  }\n\n  @Override\n  public Route.Collection put(final String path1, final String path2,\n      final Route.ZeroArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{put(path1, handler), put(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection put(final String path1, final String path2,\n      final String path3, final Route.ZeroArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{put(path1, handler), put(path2, handler), put(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition put(final String path,\n      final Route.Filter filter) {\n    return appendDefinition(PUT, path, filter);\n  }\n\n  @Override\n  public Route.Collection put(final String path1, final String path2,\n      final Route.Filter filter) {\n    return new Route.Collection(\n        new Route.Definition[]{put(path1, filter), put(path2, filter)});\n  }\n\n  @Override\n  public Route.Collection put(final String path1, final String path2,\n      final String path3, final Route.Filter filter) {\n    return new Route.Collection(\n        new Route.Definition[]{put(path1, filter), put(path2, filter), put(path3, filter)});\n  }\n\n  @Override\n  public Route.Definition patch(final String path, final Route.Handler handler) {\n    return appendDefinition(PATCH, path, handler);\n  }\n\n  @Override\n  public Route.Collection patch(final String path1, final String path2,\n      final Route.Handler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{patch(path1, handler), patch(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection patch(final String path1, final String path2,\n      final String path3, final Route.Handler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{patch(path1, handler), patch(path2, handler),\n            patch(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition patch(final String path, final Route.OneArgHandler handler) {\n    return appendDefinition(PATCH, path, handler);\n  }\n\n  @Override\n  public Route.Collection patch(final String path1, final String path2,\n      final Route.OneArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{patch(path1, handler), patch(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection patch(final String path1, final String path2,\n      final String path3, final Route.OneArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{patch(path1, handler), patch(path2, handler),\n            patch(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition patch(final String path, final Route.ZeroArgHandler handler) {\n    return appendDefinition(PATCH, path, handler);\n  }\n\n  @Override\n  public Route.Collection patch(final String path1, final String path2,\n      final Route.ZeroArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{patch(path1, handler), patch(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection patch(final String path1, final String path2,\n      final String path3, final Route.ZeroArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{patch(path1, handler), patch(path2, handler),\n            patch(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition patch(final String path,\n      final Route.Filter filter) {\n    return appendDefinition(PATCH, path, filter);\n  }\n\n  @Override\n  public Route.Collection patch(final String path1, final String path2,\n      final Route.Filter filter) {\n    return new Route.Collection(\n        new Route.Definition[]{patch(path1, filter), patch(path2, filter)});\n  }\n\n  @Override\n  public Route.Collection patch(final String path1, final String path2,\n      final String path3, final Route.Filter filter) {\n    return new Route.Collection(\n        new Route.Definition[]{patch(path1, filter), patch(path2, filter),\n            patch(path3, filter)});\n  }\n\n  @Override\n  public Route.Definition delete(final String path, final Route.Handler handler) {\n    return appendDefinition(DELETE, path, handler);\n  }\n\n  @Override\n  public Route.Collection delete(final String path1, final String path2,\n      final Route.Handler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{delete(path1, handler), delete(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection delete(final String path1, final String path2, final String path3,\n      final Route.Handler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{delete(path1, handler), delete(path2, handler),\n            delete(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition delete(final String path, final Route.OneArgHandler handler) {\n    return appendDefinition(DELETE, path, handler);\n  }\n\n  @Override\n  public Route.Collection delete(final String path1, final String path2,\n      final Route.OneArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{delete(path1, handler), delete(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection delete(final String path1, final String path2, final String path3,\n      final Route.OneArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{delete(path1, handler), delete(path2, handler),\n            delete(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition delete(final String path,\n      final Route.ZeroArgHandler handler) {\n    return appendDefinition(DELETE, path, handler);\n  }\n\n  @Override\n  public Route.Collection delete(final String path1,\n      final String path2, final Route.ZeroArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{delete(path1, handler), delete(path2, handler)});\n  }\n\n  @Override\n  public Route.Collection delete(final String path1, final String path2, final String path3,\n      final Route.ZeroArgHandler handler) {\n    return new Route.Collection(\n        new Route.Definition[]{delete(path1, handler), delete(path2, handler),\n            delete(path3, handler)});\n  }\n\n  @Override\n  public Route.Definition delete(final String path, final Route.Filter filter) {\n    return appendDefinition(DELETE, path, filter);\n  }\n\n  @Override\n  public Route.Collection delete(final String path1, final String path2,\n      final Route.Filter filter) {\n    return new Route.Collection(\n        new Route.Definition[]{delete(path1, filter), delete(path2, filter)});\n  }\n\n  @Override\n  public Route.Collection delete(final String path1, final String path2, final String path3,\n      final Route.Filter filter) {\n    return new Route.Collection(\n        new Route.Definition[]{delete(path1, filter), delete(path2, filter),\n            delete(path3, filter)});\n  }\n\n  @Override\n  public Route.Definition trace(final String path, final Route.Handler handler) {\n    return appendDefinition(TRACE, path, handler);\n  }\n\n  @Override\n  public Route.Definition trace(final String path, final Route.OneArgHandler handler) {\n    return appendDefinition(TRACE, path, handler);\n  }\n\n  @Override\n  public Route.Definition trace(final String path, final Route.ZeroArgHandler handler) {\n    return appendDefinition(TRACE, path, handler);\n  }\n\n  @Override\n  public Route.Definition trace(final String path, final Route.Filter filter) {\n    return appendDefinition(TRACE, path, filter);\n  }\n\n  @Override\n  public Route.Definition trace() {\n    return appendDefinition(TRACE, \"*\", handler(TraceHandler.class)).name(\"*.trace\");\n  }\n\n  @Override\n  public Route.Definition connect(final String path, final Route.Handler handler) {\n    return appendDefinition(CONNECT, path, handler);\n  }\n\n  @Override\n  public Route.Definition connect(final String path, final Route.OneArgHandler handler) {\n    return appendDefinition(CONNECT, path, handler);\n  }\n\n  @Override\n  public Route.Definition connect(final String path, final Route.ZeroArgHandler handler) {\n    return appendDefinition(CONNECT, path, handler);\n  }\n\n  @Override\n  public Route.Definition connect(final String path, final Route.Filter filter) {\n    return appendDefinition(CONNECT, path, filter);\n  }\n\n  /**\n   * Creates a new {@link Route.Handler} that delegate the execution to the given handler. This is\n   * useful when the target handler requires some dependencies.\n   *\n   * <pre>\n   *   public class MyHandler implements Route.Handler {\n   *     &#64;Inject\n   *     public MyHandler(Dependency d) {\n   *     }\n   *\n   *     public void handle(Request req, Response rsp) throws Exception {\n   *      // do something\n   *     }\n   *   }\n   *   ...\n   *   // external route\n   *   get(\"/\", handler(MyHandler.class));\n   *\n   *   // inline version route\n   *   get(\"/\", (req, rsp) {@literal ->} {\n   *     Dependency d = req.getInstance(Dependency.class);\n   *     // do something\n   *   });\n   * </pre>\n   *\n   * You can access to a dependency from a in-line route too, so the use of external route it is\n   * more or less a matter of taste.\n   *\n   * @param handler The external handler class.\n   * @return A new inline route handler.\n   */\n  private Route.Handler handler(final Class<? extends Route.Handler> handler) {\n    requireNonNull(handler, \"Route handler is required.\");\n    return (req, rsp) -> req.require(handler).handle(req, rsp);\n  }\n\n  /**\n   * Creates a new {@link Route.Filter} that delegate the execution to the given filter. This is\n   * useful when the target handler requires some dependencies.\n   *\n   * <pre>\n   *   public class MyFilter implements Filter {\n   *     &#64;Inject\n   *     public MyFilter(Dependency d) {\n   *     }\n   *\n   *     public void handle(Request req, Response rsp, Route.Chain chain) throws Exception {\n   *      // do something\n   *     }\n   *   }\n   *   ...\n   *   // external filter\n   *   get(\"/\", filter(MyFilter.class));\n   *\n   *   // inline version route\n   *   get(\"/\", (req, rsp, chain) {@literal ->} {\n   *     Dependency d = req.getInstance(Dependency.class);\n   *     // do something\n   *   });\n   * </pre>\n   *\n   * You can access to a dependency from a in-line route too, so the use of external filter it is\n   * more or less a matter of taste.\n   *\n   * @param filter The external filter class.\n   * @return A new inline route.\n   */\n  private Route.Filter filter(final Class<? extends Route.Filter> filter) {\n    requireNonNull(filter, \"Filter is required.\");\n    return (req, rsp, chain) -> req.require(filter).handle(req, rsp, chain);\n  }\n\n  @Override\n  public Route.AssetDefinition assets(final String path, final Path basedir) {\n    return assets(path, new AssetHandler(basedir));\n  }\n\n  @Override\n  public Route.AssetDefinition assets(final String path, final String location) {\n    return assets(path, new AssetHandler(location));\n  }\n\n  @Override\n  public Route.AssetDefinition assets(final String path, final AssetHandler handler) {\n    Route.AssetDefinition route = appendDefinition(GET, path, handler, Route.AssetDefinition::new);\n    return configureAssetHandler(route);\n  }\n\n  @Override\n  public Route.Collection use(final Class<?> routeClass) {\n    return use(\"\", routeClass);\n  }\n\n  @Override\n  public Route.Collection use(final String path, final Class<?> routeClass) {\n    requireNonNull(routeClass, \"Route class is required.\");\n    requireNonNull(path, \"Path is required\");\n    MvcClass mvc = new MvcClass(routeClass, path, prefix);\n    bag.add(mvc);\n    return new Route.Collection(mvc);\n  }\n\n  /**\n   * Keep track of routes in the order user define them.\n   *\n   * @param method Route method.\n   * @param pattern Route pattern.\n   * @param filter Route filter.\n   * @return The same route definition.\n   */\n  private Route.Definition appendDefinition(String method, String pattern, Route.Filter filter) {\n    return appendDefinition(method, pattern, filter, Route.Definition::new);\n  }\n\n  /**\n   * Keep track of routes in the order user define them.\n   *\n   * @param method Route method.\n   * @param pattern Route pattern.\n   * @param filter Route filter.\n   * @param creator Route creator.\n   * @return The same route definition.\n   */\n  private <T extends Route.Definition> T appendDefinition(String method, String pattern,\n      Route.Filter filter, Throwing.Function4<String, String, Route.Filter, Boolean, T> creator) {\n    String pathPattern = prefixPath(pattern).orElse(pattern);\n    T route = creator.apply(method, pathPattern, filter, caseSensitiveRouting);\n    if (prefix != null) {\n      route.prefix = prefix;\n      // reset name will update the name if prefix != null\n      route.name(route.name());\n    }\n    bag.add(route);\n    return route;\n  }\n\n  /**\n   * Import an application {@link Module}.\n   *\n   * @param module The module to import.\n   * @return This jooby instance.\n   * @see Jooby.Module\n   */\n  public Jooby use(final Jooby.Module module) {\n    requireNonNull(module, \"A module is required.\");\n    bag.add(module);\n    return this;\n  }\n\n  /**\n   * Set/specify a custom .conf file, useful when you don't want a <code>application.conf</code>\n   * file.\n   *\n   * @param path Classpath location.\n   * @return This jooby instance.\n   */\n  public Jooby conf(final String path) {\n    this.confname = path;\n    use(ConfigFactory.parseResources(path));\n    return this;\n  }\n\n  /**\n   * Set/specify a custom .conf file, useful when you don't want a <code>application.conf</code>\n   * file.\n   *\n   * @param path File system location.\n   * @return This jooby instance.\n   */\n  public Jooby conf(final File path) {\n    this.confname = path.getName();\n    use(ConfigFactory.parseFile(path));\n    return this;\n  }\n\n  /**\n   * Set the application configuration object. You must call this method when the default file\n   * name: <code>application.conf</code> doesn't work for you or when you need/want to register two\n   * or more files.\n   *\n   * @param config The application configuration object.\n   * @return This jooby instance.\n   * @see Config\n   */\n  public Jooby use(final Config config) {\n    this.srcconf = requireNonNull(config, \"Config required.\");\n    return this;\n  }\n\n  @Override\n  public Jooby err(final Err.Handler err) {\n    this.bag.add(requireNonNull(err, \"An err handler is required.\"));\n    return this;\n  }\n\n  @Override\n  public WebSocket.Definition ws(final String path, final WebSocket.OnOpen handler) {\n    WebSocket.Definition ws = new WebSocket.Definition(path, handler);\n    checkArgument(bag.add(ws), \"Duplicated path: '%s'\", path);\n    return ws;\n  }\n\n  @Override\n  public <T> WebSocket.Definition ws(final String path,\n      final Class<? extends WebSocket.OnMessage<T>> handler) {\n    String fpath = Optional.ofNullable(handler.getAnnotation(org.jooby.mvc.Path.class))\n        .map(it -> path + \"/\" + it.value()[0])\n        .orElse(path);\n\n    WebSocket.Definition ws = ws(fpath, MvcWebSocket.newWebSocket(handler));\n\n    Optional.ofNullable(handler.getAnnotation(Consumes.class))\n        .ifPresent(consumes -> Arrays.asList(consumes.value()).forEach(ws::consumes));\n    Optional.ofNullable(handler.getAnnotation(Produces.class))\n        .ifPresent(produces -> Arrays.asList(produces.value()).forEach(ws::produces));\n    return ws;\n  }\n\n  @Override\n  public Route.Definition sse(final String path, final Sse.Handler handler) {\n    return appendDefinition(GET, path, handler).consumes(MediaType.sse);\n  }\n\n  @Override\n  public Route.Definition sse(final String path, final Sse.Handler1 handler) {\n    return appendDefinition(GET, path, handler).consumes(MediaType.sse);\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  @Override\n  public Route.Collection with(final Runnable callback) {\n    // hacky way of doing what we want... but we do simplify developer life\n    int size = this.bag.size();\n    callback.run();\n    // collect latest routes and apply route props\n    List<Route.Props> local = this.bag.stream()\n        .skip(size)\n        .filter(Route.Props.class::isInstance)\n        .map(Route.Props.class::cast)\n        .collect(Collectors.toList());\n    return new Route.Collection(local.toArray(new Route.Props[local.size()]));\n  }\n\n  /**\n   * Prepare and startup a {@link Jooby} application.\n   *\n   * @param app Application supplier.\n   * @param args Application arguments.\n   */\n  public static void run(final Supplier<? extends Jooby> app, final String... args) {\n    Config conf = ConfigFactory.systemProperties()\n        .withFallback(args(args));\n    System.setProperty(\"logback.configurationFile\", logback(conf));\n    app.get().start(args);\n  }\n\n  /**\n   * Prepare and startup a {@link Jooby} application.\n   *\n   * @param app Application supplier.\n   * @param args Application arguments.\n   */\n  public static void run(final Class<? extends Jooby> app, final String... args) {\n    run(() -> Try.apply(() -> app.newInstance()).get(), args);\n  }\n\n  /**\n   * Export configuration from an application. Useful for tooling, testing, debugging, etc...\n   *\n   * @param app Application to extract/collect configuration.\n   * @return Application conf or <code>empty</code> conf on error.\n   */\n  public static Config exportConf(final Jooby app) {\n    AtomicReference<Config> conf = new AtomicReference<>(ConfigFactory.empty());\n    app.on(\"*\", c -> {\n      conf.set(c);\n    });\n    exportRoutes(app);\n    return conf.get();\n  }\n\n  /**\n   * Export routes from an application. Useful for route analysis, testing, debugging, etc...\n   *\n   * @param app Application to extract/collect routes.\n   * @return Application routes.\n   */\n  public static List<Definition> exportRoutes(final Jooby app) {\n    @SuppressWarnings(\"serial\") class Success extends RuntimeException {\n      List<Definition> routes;\n\n      Success(final List<Route.Definition> routes) {\n        this.routes = routes;\n      }\n    }\n    List<Definition> routes = Collections.emptyList();\n    try {\n      app.start(new String[0], r -> {\n        throw new Success(r);\n      });\n    } catch (Success success) {\n      routes = success.routes;\n    } catch (Throwable x) {\n      logger(app).debug(\"Failed bootstrap: {}\", app, x);\n    }\n    return routes;\n  }\n\n  /**\n   * Start an application. Fire the {@link #onStart(Throwing.Runnable)} event and the\n   * {@link #onStarted(Throwing.Runnable)} events.\n   */\n  public void start() {\n    start(new String[0]);\n  }\n\n  /**\n   * Start an application. Fire the {@link #onStart(Throwing.Runnable)} event and the\n   * {@link #onStarted(Throwing.Runnable)} events.\n   *\n   * @param args Application arguments.\n   */\n  public void start(final String... args) {\n    try {\n      start(args, null);\n    } catch (Throwable x) {\n      stop();\n      String msg = \"An error occurred while starting the application:\";\n      if (throwBootstrapException) {\n        throw new Err(Status.SERVICE_UNAVAILABLE, msg, x);\n      } else {\n        logger(this).error(msg, x);\n      }\n    }\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private void start(final String[] args, final Consumer<List<Route.Definition>> routes)\n      throws Throwable {\n    long start = System.currentTimeMillis();\n\n    started.set(true);\n\n    this.injector = bootstrap(args(args), routes);\n\n    // shutdown hook\n    Runtime.getRuntime().addShutdownHook(new Thread(this::stop));\n\n    Config conf = injector.getInstance(Config.class);\n\n    Logger log = logger(this);\n\n    // inject class\n    injector.injectMembers(this);\n\n    // onStart callbacks via .conf\n    if (conf.hasPath(\"jooby.internal.onStart\")) {\n      ClassLoader loader = getClass().getClassLoader();\n      Object internalOnStart = loader.loadClass(conf.getString(\"jooby.internal.onStart\"))\n          .newInstance();\n      onStart.add((Throwing.Consumer<Registry>) internalOnStart);\n    }\n\n    // start services\n    for (Throwing.Consumer<Registry> onStart : this.onStart) {\n      onStart.accept(this);\n    }\n\n    // route mapper\n    Set<Route.Definition> routeDefs = injector.getInstance(Route.KEY);\n    Set<WebSocket.Definition> sockets = injector.getInstance(WebSocket.KEY);\n    if (mapper != null) {\n      routeDefs.forEach(it -> it.map(mapper));\n    }\n\n    AppPrinter printer = new AppPrinter(routeDefs, sockets, conf);\n    printer.printConf(log, conf);\n\n    // Start server\n    Server server = injector.getInstance(Server.class);\n    String serverName = server.getClass().getSimpleName().replace(\"Server\", \"\").toLowerCase();\n\n    server.start();\n    long end = System.currentTimeMillis();\n\n    log.info(\"[{}@{}]: Server started in {}ms\\n\\n{}\\n\",\n        conf.getString(\"application.env\"),\n        serverName,\n        end - start,\n        printer);\n\n    // started services\n    for (Throwing.Consumer<Registry> onStarted : this.onStarted) {\n      onStarted.accept(this);\n    }\n\n    boolean join = conf.hasPath(\"server.join\") ? conf.getBoolean(\"server.join\") : true;\n    if (join) {\n      server.join();\n    }\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public Jooby map(final Mapper<?> mapper) {\n    requireNonNull(mapper, \"Mapper is required.\");\n    if (mappers.add(mapper.name())) {\n      this.mapper = Optional.ofNullable(this.mapper)\n          .map(next -> Route.Mapper.chain(mapper, next))\n          .orElse((Mapper<Object>) mapper);\n    }\n    return this;\n  }\n\n  /**\n   * Use the injection provider to create the Guice injector\n   *\n   * @param injectorFactory the injection provider\n   * @return this instance.\n   */\n\n  public Jooby injector(\n      final BiFunction<Stage, com.google.inject.Module, Injector> injectorFactory) {\n    this.injectorFactory = injectorFactory;\n    return this;\n  }\n\n  /**\n   * Bind the provided abstract type to the given implementation:\n   *\n   * <pre>\n   * {\n   *   bind(MyInterface.class, MyImplementation.class);\n   * }\n   * </pre>\n   *\n   * @param type Service interface.\n   * @param implementation Service implementation.\n   * @param <T> Service type.\n   * @return This instance.\n   */\n  public <T> Jooby bind(final Class<T> type, final Class<? extends T> implementation) {\n    use((env, conf, binder) -> {\n      binder.bind(type).to(implementation);\n    });\n    return this;\n  }\n\n  /**\n   * Bind the provided abstract type to the given implementation:\n   *\n   * <pre>\n   * {\n   *   bind(MyInterface.class, MyImplementation::new);\n   * }\n   * </pre>\n   *\n   * @param type Service interface.\n   * @param implementation Service implementation.\n   * @param <T> Service type.\n   * @return This instance.\n   */\n  public <T> Jooby bind(final Class<T> type, final Supplier<T> implementation) {\n    use((env, conf, binder) -> {\n      binder.bind(type).toInstance(implementation.get());\n    });\n    return this;\n  }\n\n  /**\n   * Bind the provided type:\n   *\n   * <pre>\n   * {\n   *   bind(MyInterface.class);\n   * }\n   * </pre>\n   *\n   * @param type Service interface.\n   * @param <T> Service type.\n   * @return This instance.\n   */\n  public <T> Jooby bind(final Class<T> type) {\n    use((env, conf, binder) -> {\n      binder.bind(type);\n    });\n    return this;\n  }\n\n  /**\n   * Bind the provided type:\n   *\n   * <pre>\n   * {\n   *   bind(new MyService());\n   * }\n   * </pre>\n   *\n   * @param service Service.\n   * @return This instance.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public Jooby bind(final Object service) {\n    use((env, conf, binder) -> {\n      Class type = service.getClass();\n      binder.bind(type).toInstance(service);\n    });\n    return this;\n  }\n\n  /**\n   * Bind the provided type and object that requires some type of configuration:\n   *\n   * <pre>{@code\n   * {\n   *   bind(MyService.class, conf -> new MyService(conf.getString(\"service.url\")));\n   * }\n   * }</pre>\n   *\n   * @param type Service type.\n   * @param provider Service provider.\n   * @param <T> Service type.\n   * @return This instance.\n   */\n  public <T> Jooby bind(final Class<T> type, final Function<Config, ? extends T> provider) {\n    use((env, conf, binder) -> {\n      T service = provider.apply(conf);\n      binder.bind(type).toInstance(service);\n    });\n    return this;\n  }\n\n  /**\n   * Bind the provided type and object that requires some type of configuration:\n   *\n   * <pre>{@code\n   * {\n   *   bind(conf -> new MyService(conf.getString(\"service.url\")));\n   * }\n   * }</pre>\n   *\n   * @param provider Service provider.\n   * @param <T> Service type.\n   * @return This instance.\n   */\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public <T> Jooby bind(final Function<Config, T> provider) {\n    use((env, conf, binder) -> {\n      Object service = provider.apply(conf);\n      Class type = service.getClass();\n      binder.bind(type).toInstance(service);\n    });\n    return this;\n  }\n\n  /**\n   * Set application date format.\n   *\n   * @param dateFormat A date format.\n   * @return This instance.\n   */\n  public Jooby dateFormat(final String dateFormat) {\n    this.dateFormat = requireNonNull(dateFormat, \"DateFormat required.\");\n    return this;\n  }\n\n  /**\n   * Set application number format.\n   *\n   * @param numberFormat A number format.\n   * @return This instance.\n   */\n  public Jooby numberFormat(final String numberFormat) {\n    this.numberFormat = requireNonNull(numberFormat, \"NumberFormat required.\");\n    return this;\n  }\n\n  /**\n   * Set application/default charset.\n   *\n   * @param charset A charset.\n   * @return This instance.\n   */\n  public Jooby charset(final Charset charset) {\n    this.charset = requireNonNull(charset, \"Charset required.\");\n    return this;\n  }\n\n  /**\n   * Set application locale (first listed are higher priority).\n   *\n   * @param languages List of locale using the language tag format.\n   * @return This instance.\n   */\n  public Jooby lang(final String... languages) {\n    this.languages = languages;\n    return this;\n  }\n\n  /**\n   * Set application time zone.\n   *\n   * @param zoneId ZoneId.\n   * @return This instance.\n   */\n  public Jooby timezone(final ZoneId zoneId) {\n    this.zoneId = requireNonNull(zoneId, \"ZoneId required.\");\n    return this;\n  }\n\n  /**\n   * Set the HTTP port.\n   *\n   * <p>\n   * Keep in mind this work as a default port and can be reset via <code>application.port</code>\n   * property.\n   * </p>\n   *\n   * @param port HTTP port.\n   * @return This instance.\n   */\n  public Jooby port(final int port) {\n    this.port = port;\n    return this;\n  }\n\n  /**\n   * <p>\n   * Set the HTTPS port to use.\n   * </p>\n   *\n   * <p>\n   * Keep in mind this work as a default port and can be reset via <code>application.port</code>\n   * property.\n   * </p>\n   *\n   * <h2>HTTPS</h2>\n   * <p>\n   * Jooby comes with a self-signed certificate, useful for development and test. But of course, you\n   * should NEVER use it in the real world.\n   * </p>\n   *\n   * <p>\n   * In order to setup HTTPS with a secure certificate, you need to set these properties:\n   * </p>\n   *\n   * <ul>\n   * <li>\n   * <code>ssl.keystore.cert</code>: An X.509 certificate chain file in PEM format. It can be an\n   * absolute path or a classpath resource.\n   * </li>\n   * <li>\n   * <code>ssl.keystore.key</code>: A PKCS#8 private key file in PEM format. It can be an absolute\n   * path or a classpath resource.\n   * </li>\n   * </ul>\n   *\n   * <p>\n   * Optionally, you can set these too:\n   * </p>\n   *\n   * <ul>\n   * <li>\n   * <code>ssl.keystore.password</code>: Password of the keystore.key (if any). Default is:\n   * null/empty.\n   * </li>\n   * <li>\n   * <code>ssl.trust.cert</code>: Trusted certificates for verifying the remote endpoints\n   * certificate. The file should contain an X.509 certificate chain in PEM format. Default uses the\n   * system default.\n   * </li>\n   * <li>\n   * <code>ssl.session.cacheSize</code>: Set the size of the cache used for storing SSL session\n   * objects. 0 to use the default value.\n   * </li>\n   * <li>\n   * <code>ssl.session.timeout</code>: Timeout for the cached SSL session objects, in seconds. 0 to\n   * use the default value.\n   * </li>\n   * </ul>\n   *\n   * <p>\n   * As you can see setup is very simple. All you need is your <code>.crt</code> and\n   * <code>.key</code> files.\n   * </p>\n   *\n   * @param port HTTPS port.\n   * @return This instance.\n   */\n  public Jooby securePort(final int port) {\n    this.securePort = port;\n    return this;\n  }\n\n  /**\n   * <p>\n   * Enable <code>HTTP/2</code> protocol. Some servers require special configuration, others just\n   * works. It is a good idea to check the server documentation about\n   * <a href=\"http://jooby.org/doc/servers\">HTTP/2</a>.\n   * </p>\n   *\n   * <p>\n   * In order to use HTTP/2 from a browser you must configure HTTPS, see {@link #securePort(int)}\n   * documentation.\n   * </p>\n   *\n   * <p>\n   * If HTTP/2 clear text is supported then you may skip the HTTPS setup, but of course you won't be\n   * able to use HTTP/2 with browsers.\n   * </p>\n   *\n   * @return This instance.\n   */\n  public Jooby http2() {\n    this.http2 = true;\n    return this;\n  }\n\n  /**\n   * Set the default executor to use from {@link Deferred Deferred API}.\n   *\n   * Default executor runs each task in the thread that invokes {@link Executor#execute execute},\n   * that's a Jooby worker thread. A worker thread in Jooby can block.\n   *\n   * The {@link ExecutorService} will automatically shutdown.\n   *\n   * @param executor Executor to use.\n   * @return This jooby instance.\n   */\n  public Jooby executor(final ExecutorService executor) {\n    executor((Executor) executor);\n    onStop(r -> executor.shutdown());\n    return this;\n  }\n\n  /**\n   * Set the default executor to use from {@link Deferred Deferred API}.\n   *\n   * Default executor runs each task in the thread that invokes {@link Executor#execute execute},\n   * that's a Jooby worker thread. A worker thread in Jooby can block.\n   *\n   * The {@link ExecutorService} will automatically shutdown.\n   *\n   * @param executor Executor to use.\n   * @return This jooby instance.\n   */\n  public Jooby executor(final Executor executor) {\n    this.defaultExecSet = true;\n    this.executors.add(binder -> {\n      binder.bind(Key.get(String.class, Names.named(\"deferred\"))).toInstance(\"deferred\");\n      binder.bind(Key.get(Executor.class, Names.named(\"deferred\"))).toInstance(executor);\n    });\n    return this;\n  }\n\n  /**\n   * Set a named executor to use from {@link Deferred Deferred API}. Useful for override the\n   * default/global executor.\n   *\n   * Default executor runs each task in the thread that invokes {@link Executor#execute execute},\n   * that's a Jooby worker thread. A worker thread in Jooby can block.\n   *\n   * The {@link ExecutorService} will automatically shutdown.\n   *\n   * @param name Name of the executor.\n   * @param executor Executor to use.\n   * @return This jooby instance.\n   */\n  public Jooby executor(final String name, final ExecutorService executor) {\n    executor(name, (Executor) executor);\n    onStop(r -> executor.shutdown());\n    return this;\n  }\n\n  /**\n   * Set a named executor to use from {@link Deferred Deferred API}. Useful for override the\n   * default/global executor.\n   *\n   * Default executor runs each task in the thread that invokes {@link Executor#execute execute},\n   * that's a Jooby worker thread. A worker thread in Jooby can block.\n   *\n   * The {@link ExecutorService} will automatically shutdown.\n   *\n   * @param name Name of the executor.\n   * @param executor Executor to use.\n   * @return This jooby instance.\n   */\n  public Jooby executor(final String name, final Executor executor) {\n    this.executors.add(binder -> {\n      binder.bind(Key.get(Executor.class, Names.named(name))).toInstance(executor);\n    });\n    return this;\n  }\n\n  /**\n   * Set the default executor to use from {@link Deferred Deferred API}. This works as reference to\n   * an executor, application directly or via module must provide an named executor.\n   *\n   * Default executor runs each task in the thread that invokes {@link Executor#execute execute},\n   * that's a Jooby worker thread. A worker thread in Jooby can block.\n   *\n   * @param name Executor to use.\n   * @return This jooby instance.\n   */\n  public Jooby executor(final String name) {\n    defaultExecSet = true;\n    this.executors.add(binder -> {\n      binder.bind(Key.get(String.class, Names.named(\"deferred\"))).toInstance(name);\n    });\n    return this;\n  }\n\n  /**\n   * Set a named executor to use from {@link Deferred Deferred API}. Useful for override the\n   * default/global executor.\n   *\n   * Default executor runs each task in the thread that invokes {@link Executor#execute execute},\n   * that's a Jooby worker thread. A worker thread in Jooby can block.\n   *\n   * @param name Name of the executor.\n   * @param provider Provider for the executor.\n   * @return This jooby instance.\n   */\n  private Jooby executor(final String name, final Class<? extends Provider<Executor>> provider) {\n    this.executors.add(binder -> {\n      binder.bind(Key.get(Executor.class, Names.named(name))).toProvider(provider)\n          .in(Singleton.class);\n    });\n    return this;\n  }\n\n  /**\n   * If the application fails to start all the services are shutdown. Also, the exception is logged\n   * and usually the application is going to exit.\n   *\n   * This options turn off logging and rethrow the exception as {@link Err}. Here is an example:\n   *\n   * <pre>\n   * public class App extends Jooby {\n   *   {\n   *     throwBootstrapException();\n   *     ...\n   *   }\n   * }\n   *\n   * App app = new App();\n   *\n   * try {\n   *   app.start();\n   * } catch (Err err) {\n   *   Throwable cause = err.getCause();\n   * }\n   * </pre>\n   *\n   * @return This instance.\n   */\n  public Jooby throwBootstrapException() {\n    this.throwBootstrapException = true;\n    return this;\n  }\n\n  /**\n   * Configure case for routing algorithm. Default is <code>case sensitive</code>.\n   *\n   * @param enabled True for case sensitive, false otherwise.\n   * @return This instance.\n   */\n  public Jooby caseSensitiveRouting(boolean enabled) {\n    this.caseSensitiveRouting = enabled;\n    return this;\n  }\n\n  private static List<Object> normalize(final List<Object> services, final Env env,\n      final RouteMetadata classInfo, final boolean caseSensitiveRouting) {\n    List<Object> result = new ArrayList<>();\n    List<Object> snapshot = services;\n    /** modules, routes, parsers, renderers and websockets */\n    snapshot.forEach(candidate -> {\n      if (candidate instanceof Route.Definition) {\n        result.add(candidate);\n      } else if (candidate instanceof MvcClass) {\n        MvcClass mvcRoute = ((MvcClass) candidate);\n        Class<?> mvcClass = mvcRoute.routeClass;\n        String path = ((MvcClass) candidate).path;\n        MvcRoutes.routes(env, classInfo, path, caseSensitiveRouting, mvcClass)\n            .forEach(route -> result.add(mvcRoute.apply(route)));\n      } else {\n        result.add(candidate);\n      }\n    });\n    return result;\n  }\n\n  private static List<Object> processEnvDep(final Set<Object> src, final Env env) {\n    List<Object> result = new ArrayList<>();\n    List<Object> bag = new ArrayList<>(src);\n    bag.forEach(it -> {\n      if (it instanceof EnvDep) {\n        EnvDep envdep = (EnvDep) it;\n        if (envdep.predicate.test(env.name())) {\n          int from = src.size();\n          envdep.callback.accept(env.config());\n          int to = src.size();\n          result.addAll(new ArrayList<>(src).subList(from, to));\n        }\n      } else {\n        result.add(it);\n      }\n    });\n    return result;\n  }\n\n  private Injector bootstrap(final Config args,\n      final Consumer<List<Route.Definition>> rcallback) throws Throwable {\n    Config initconf = Optional.ofNullable(srcconf)\n        .orElseGet(() -> ConfigFactory.parseResources(\"application.conf\"));\n    List<Config> modconf = modconf(this.bag);\n    Config conf = buildConfig(initconf, args, modconf);\n\n    final List<Locale> locales = LocaleUtils.parse(conf.getString(\"application.lang\"));\n\n    Env env = this.env.build(conf, this, locales.get(0));\n    String envname = env.name();\n\n    final Charset charset = Charset.forName(conf.getString(\"application.charset\"));\n\n    String dateFormat = conf.getString(\"application.dateFormat\");\n    ZoneId zoneId = ZoneId.of(conf.getString(\"application.tz\"));\n    DateTimeFormatter dateTimeFormatter = DateTimeFormatter\n        .ofPattern(dateFormat, locales.get(0))\n        .withZone(zoneId);\n    DateTimeFormatter zonedDateTimeFormat = DateTimeFormatter\n        .ofPattern(conf.getString(\"application.zonedDateTimeFormat\"));\n\n    DecimalFormat numberFormat = new DecimalFormat(conf.getString(\"application.numberFormat\"));\n\n    // Guice Stage\n    Stage stage = \"dev\".equals(envname) ? Stage.DEVELOPMENT : Stage.PRODUCTION;\n\n    // expand and normalize bag\n    RouteMetadata rm = new RouteMetadata(env);\n    List<Object> realbag = processEnvDep(this.bag, env);\n    List<Config> realmodconf = modconf(realbag);\n    List<Object> bag = normalize(realbag, env, rm, caseSensitiveRouting);\n\n    // collect routes and fire route callback\n    if (rcallback != null) {\n      List<Route.Definition> routes = bag.stream()\n          .filter(it -> it instanceof Route.Definition)\n          .map(it -> (Route.Definition) it)\n          .collect(Collectors.<Route.Definition>toList());\n      rcallback.accept(routes);\n    }\n\n    // final config ? if we add a mod that depends on env\n    Config finalConfig;\n    Env finalEnv;\n    if (modconf.size() != realmodconf.size()) {\n      finalConfig = buildConfig(initconf, args, realmodconf);\n      finalEnv = this.env.build(finalConfig, this, locales.get(0));\n    } else {\n      finalConfig = conf;\n      finalEnv = env;\n    }\n\n    boolean cookieSession = session.store() == null;\n    if (cookieSession && !finalConfig.hasPath(\"application.secret\")) {\n      throw new IllegalStateException(\"Required property 'application.secret' is missing\");\n    }\n\n    /** executors: */\n    if (!defaultExecSet) {\n      // default executor\n      executor(MoreExecutors.directExecutor());\n    }\n    executor(\"direct\", MoreExecutors.directExecutor());\n    executor(\"server\", ServerExecutorProvider.class);\n\n    /** Some basic xss functions. */\n    xss(finalEnv);\n\n    /** dependency injection */\n    @SuppressWarnings(\"unchecked\")\n    com.google.inject.Module joobyModule = binder -> {\n\n      /** type converters */\n      new TypeConverters().configure(binder);\n\n      /** bind config */\n      bindConfig(binder, finalConfig);\n\n      /** bind env */\n      binder.bind(Env.class).toInstance(finalEnv);\n\n      /** bind charset */\n      binder.bind(Charset.class).toInstance(charset);\n\n      /** bind locale */\n      binder.bind(Locale.class).toInstance(locales.get(0));\n      TypeLiteral<List<Locale>> localeType = (TypeLiteral<List<Locale>>) TypeLiteral\n          .get(Types.listOf(Locale.class));\n      binder.bind(localeType).toInstance(locales);\n\n      /** bind time zone */\n      binder.bind(ZoneId.class).toInstance(zoneId);\n      binder.bind(TimeZone.class).toInstance(TimeZone.getTimeZone(zoneId));\n\n      /** bind date format */\n      binder.bind(DateTimeFormatter.class).toInstance(dateTimeFormatter);\n\n      /** bind number format */\n      binder.bind(NumberFormat.class).toInstance(numberFormat);\n      binder.bind(DecimalFormat.class).toInstance(numberFormat);\n\n      /** bind ssl provider. */\n      binder.bind(SSLContext.class).toProvider(SslContextProvider.class);\n\n      /** routes */\n      Multibinder<Definition> definitions = Multibinder\n          .newSetBinder(binder, Definition.class);\n\n      /** web sockets */\n      Multibinder<WebSocket.Definition> sockets = Multibinder\n          .newSetBinder(binder, WebSocket.Definition.class);\n\n      /** tmp dir */\n      File tmpdir = new File(finalConfig.getString(\"application.tmpdir\"));\n      tmpdir.mkdirs();\n      binder.bind(File.class).annotatedWith(Names.named(\"application.tmpdir\"))\n          .toInstance(tmpdir);\n\n      binder.bind(ParameterNameProvider.class).toInstance(rm);\n\n      /** err handler */\n      Multibinder<Err.Handler> ehandlers = Multibinder\n          .newSetBinder(binder, Err.Handler.class);\n\n      /** parsers & renderers */\n      Multibinder<Parser> parsers = Multibinder\n          .newSetBinder(binder, Parser.class);\n\n      Multibinder<Renderer> renderers = Multibinder\n          .newSetBinder(binder, Renderer.class);\n\n      /** basic parser */\n      parsers.addBinding().toInstance(BuiltinParser.Basic);\n      parsers.addBinding().toInstance(BuiltinParser.Collection);\n      parsers.addBinding().toInstance(BuiltinParser.Optional);\n      parsers.addBinding().toInstance(BuiltinParser.Enum);\n      parsers.addBinding().toInstance(BuiltinParser.Bytes);\n\n      /** basic render */\n      renderers.addBinding().toInstance(BuiltinRenderer.asset);\n      renderers.addBinding().toInstance(BuiltinRenderer.bytes);\n      renderers.addBinding().toInstance(BuiltinRenderer.byteBuffer);\n      renderers.addBinding().toInstance(BuiltinRenderer.file);\n      renderers.addBinding().toInstance(BuiltinRenderer.charBuffer);\n      renderers.addBinding().toInstance(BuiltinRenderer.stream);\n      renderers.addBinding().toInstance(BuiltinRenderer.reader);\n      renderers.addBinding().toInstance(BuiltinRenderer.fileChannel);\n\n      /** modules, routes, parsers, renderers and websockets */\n      Set<Object> routeClasses = new HashSet<>();\n      for (Object it : bag) {\n        Try.run(() -> bindService(\n            logger(this),\n            this.bag,\n            finalConfig,\n            finalEnv,\n            rm,\n            binder,\n            definitions,\n            sockets,\n            ehandlers,\n            parsers,\n            renderers,\n            routeClasses,\n            caseSensitiveRouting)\n            .accept(it))\n            .throwException();\n      }\n\n      parsers.addBinding().toInstance(new DateParser(dateFormat));\n      parsers.addBinding().toInstance(new LocalDateParser(dateTimeFormatter));\n      parsers.addBinding().toInstance(new ZonedDateTimeParser(zonedDateTimeFormat));\n      parsers.addBinding().toInstance(new LocaleParser());\n      parsers.addBinding().toInstance(new StaticMethodParser(\"valueOf\"));\n      parsers.addBinding().toInstance(new StaticMethodParser(\"fromString\"));\n      parsers.addBinding().toInstance(new StaticMethodParser(\"forName\"));\n      parsers.addBinding().toInstance(new StringConstructorParser());\n      parsers.addBinding().toInstance(beanParser.orElseGet(() -> new BeanParser(false)));\n\n      binder.bind(ParserExecutor.class).in(Singleton.class);\n\n      /** override(able) renderer */\n      renderers.addBinding().toInstance(new DefaulErrRenderer());\n      renderers.addBinding().toInstance(BuiltinRenderer.text);\n\n      binder.bind(HttpHandler.class).to(HttpHandlerImpl.class).in(Singleton.class);\n\n      RequestScope requestScope = new RequestScope();\n      binder.bind(RequestScope.class).toInstance(requestScope);\n      binder.bindScope(RequestScoped.class, requestScope);\n\n      /** session manager */\n      binder.bind(Session.Definition.class)\n          .toProvider(session(finalConfig.getConfig(\"session\"), session))\n          .asEagerSingleton();\n      Object sstore = session.store();\n      if (cookieSession) {\n        binder.bind(SessionManager.class).to(CookieSessionManager.class)\n            .asEagerSingleton();\n      } else {\n        binder.bind(SessionManager.class).to(ServerSessionManager.class).asEagerSingleton();\n        if (sstore instanceof Class) {\n          binder.bind(Store.class).to((Class<? extends Store>) sstore)\n              .asEagerSingleton();\n        } else {\n          binder.bind(Store.class).toInstance((Store) sstore);\n        }\n      }\n\n      binder.bind(Request.class).toProvider(Providers.outOfScope(Request.class))\n          .in(RequestScoped.class);\n      binder.bind(Route.Chain.class).toProvider(Providers.outOfScope(Route.Chain.class))\n          .in(RequestScoped.class);\n      binder.bind(Response.class).toProvider(Providers.outOfScope(Response.class))\n          .in(RequestScoped.class);\n      /** server sent event */\n      binder.bind(Sse.class).toProvider(Providers.outOfScope(Sse.class))\n          .in(RequestScoped.class);\n\n      binder.bind(Session.class).toProvider(Providers.outOfScope(Session.class))\n          .in(RequestScoped.class);\n\n      /** def err */\n      ehandlers.addBinding().toInstance(new Err.DefHandler());\n\n      /** executors. */\n      executors.forEach(it -> it.accept(binder));\n    };\n\n    Injector injector = injectorFactory.apply(stage, joobyModule);\n    if (apprefs != null) {\n      apprefs.forEach(app -> app.injector = injector);\n      apprefs.clear();\n      apprefs = null;\n    }\n\n    onStart.addAll(0, finalEnv.startTasks());\n    onStarted.addAll(0, finalEnv.startedTasks());\n    onStop.addAll(finalEnv.stopTasks());\n\n    // clear bag and freeze it\n    this.bag.clear();\n    this.bag = ImmutableSet.of();\n    this.executors.clear();\n    this.executors = ImmutableList.of();\n\n    return injector;\n  }\n\n  private void xss(final Env env) {\n    Escaper ufe = UrlEscapers.urlFragmentEscaper();\n    Escaper fpe = UrlEscapers.urlFormParameterEscaper();\n    Escaper pse = UrlEscapers.urlPathSegmentEscaper();\n    Escaper html = HtmlEscapers.htmlEscaper();\n\n    env.xss(\"urlFragment\", ufe::escape)\n        .xss(\"formParam\", fpe::escape)\n        .xss(\"pathSegment\", pse::escape)\n        .xss(\"html\", html::escape);\n  }\n\n  private static Provider<Session.Definition> session(final Config $session,\n      final Session.Definition session) {\n    return () -> {\n      // save interval\n      session.saveInterval(session.saveInterval()\n          .orElse($session.getDuration(\"saveInterval\", TimeUnit.MILLISECONDS)));\n\n      // build cookie\n      Cookie.Definition source = session.cookie();\n\n      source.name(source.name()\n          .orElse($session.getString(\"cookie.name\")));\n\n      if (!source.comment().isPresent() && $session.hasPath(\"cookie.comment\")) {\n        source.comment($session.getString(\"cookie.comment\"));\n      }\n      if (!source.domain().isPresent() && $session.hasPath(\"cookie.domain\")) {\n        source.domain($session.getString(\"cookie.domain\"));\n      }\n      source.httpOnly(source.httpOnly()\n          .orElse($session.getBoolean(\"cookie.httpOnly\")));\n\n      Object maxAge = $session.getAnyRef(\"cookie.maxAge\");\n      if (maxAge instanceof String) {\n        maxAge = $session.getDuration(\"cookie.maxAge\", TimeUnit.SECONDS);\n      }\n      source.maxAge(source.maxAge()\n          .orElse(((Number) maxAge).intValue()));\n\n      source.path(source.path()\n          .orElse($session.getString(\"cookie.path\")));\n\n      source.secure(source.secure()\n          .orElse($session.getBoolean(\"cookie.secure\")));\n\n      return session;\n    };\n  }\n\n  private static Throwing.Consumer<? super Object> bindService(Logger log,\n      final Set<Object> src,\n      final Config conf,\n      final Env env,\n      final RouteMetadata rm,\n      final Binder binder,\n      final Multibinder<Route.Definition> definitions,\n      final Multibinder<WebSocket.Definition> sockets,\n      final Multibinder<Err.Handler> ehandlers,\n      final Multibinder<Parser> parsers,\n      final Multibinder<Renderer> renderers,\n      final Set<Object> routeClasses,\n      final boolean caseSensitiveRouting) {\n    return it -> {\n      if (it instanceof Jooby.Module) {\n        int from = src.size();\n        install(log, (Jooby.Module) it, env, conf, binder);\n        int to = src.size();\n        // collect any route a module might add\n        if (to > from) {\n          List<Object> elements = normalize(new ArrayList<>(src).subList(from, to), env, rm,\n              caseSensitiveRouting);\n          for (Object e : elements) {\n            bindService(log, src,\n                conf,\n                env,\n                rm,\n                binder,\n                definitions,\n                sockets,\n                ehandlers,\n                parsers,\n                renderers,\n                routeClasses, caseSensitiveRouting).accept(e);\n          }\n        }\n      } else if (it instanceof Route.Definition) {\n        Route.Definition rdef = (Definition) it;\n        Route.Filter h = rdef.filter();\n        if (h instanceof Route.MethodHandler) {\n          Class<?> routeClass = ((Route.MethodHandler) h).implementingClass();\n          if (routeClasses.add(routeClass)) {\n            binder.bind(routeClass);\n          }\n          definitions.addBinding().toInstance(rdef);\n        } else {\n          definitions.addBinding().toInstance(rdef);\n        }\n      } else if (it instanceof WebSocket.Definition) {\n        sockets.addBinding().toInstance((WebSocket.Definition) it);\n      } else if (it instanceof Parser) {\n        parsers.addBinding().toInstance((Parser) it);\n      } else if (it instanceof Renderer) {\n        renderers.addBinding().toInstance((Renderer) it);\n      } else {\n        ehandlers.addBinding().toInstance((Err.Handler) it);\n      }\n    };\n  }\n\n  private static List<Config> modconf(final Collection<Object> bag) {\n    return bag.stream()\n        .filter(it -> it instanceof Jooby.Module)\n        .map(it -> ((Jooby.Module) it).config())\n        .filter(c -> !c.isEmpty())\n        .collect(Collectors.toList());\n  }\n\n  /**\n   * Test if the application is up and running.\n   *\n   * @return True if the application is up and running.\n   */\n  public boolean isStarted() {\n    return started.get();\n  }\n\n  /**\n   * Stop the application, fire the {@link #onStop(Throwing.Runnable)} event and shutdown the\n   * web server.\n   *\n   * Stop listeners run in the order they were added:\n   *\n   * <pre>{@code\n   * {\n   *\n   *   onStop(() -> System.out.println(\"first\"));\n   *\n   *   onStop(() -> System.out.println(\"second\"));\n   *\n   *   ...\n   * }\n   * }</pre>\n   *\n   *\n   */\n  public void stop() {\n    if (started.compareAndSet(true, false)) {\n      Logger log = logger(this);\n\n      fireStop(this, log, onStop);\n      if (injector != null) {\n        try {\n          injector.getInstance(Server.class).stop();\n        } catch (Throwable ex) {\n          log.debug(\"server.stop() resulted in exception\", ex);\n        }\n      }\n      injector = null;\n\n      log.info(\"Stopped\");\n    }\n  }\n\n  private static void fireStop(final Jooby app, final Logger log,\n      final List<Throwing.Consumer<Registry>> onStop) {\n    // stop services\n    onStop.forEach(c -> Try.run(() -> c.accept(app))\n        .onFailure(x -> log.error(\"shutdown of {} resulted in error\", c, x)));\n  }\n\n  /**\n   * Build configuration properties, it configure system, app and modules properties.\n   *\n   * @param source Source config to use.\n   * @param args Args conf.\n   * @param modules List of modules.\n   * @return A configuration properties ready to use.\n   */\n  private Config buildConfig(final Config source, final Config args,\n      final List<Config> modules) {\n    // normalize tmpdir\n    Config system = ConfigFactory.systemProperties();\n    Config tmpdir = source.hasPath(\"java.io.tmpdir\") ? source : system;\n\n    // system properties\n    system = system\n        // file encoding got corrupted sometimes, override it.\n        .withValue(\"file.encoding\", fromAnyRef(System.getProperty(\"file.encoding\")))\n        .withValue(\"java.io.tmpdir\",\n            fromAnyRef(Paths.get(tmpdir.getString(\"java.io.tmpdir\")).normalize().toString()));\n\n    // set module config\n    Config moduleStack = ConfigFactory.empty();\n    for (Config module : ImmutableList.copyOf(modules).reverse()) {\n      moduleStack = moduleStack.withFallback(module);\n    }\n\n    String env = Arrays.asList(system, args, source).stream()\n        .filter(it -> it.hasPath(\"application.env\"))\n        .findFirst()\n        .map(c -> c.getString(\"application.env\"))\n        .orElse(\"dev\");\n\n    String cpath = Arrays.asList(system, args, source).stream()\n        .filter(it -> it.hasPath(\"application.path\"))\n        .findFirst()\n        .map(c -> c.getString(\"application.path\"))\n        .orElse(\"/\");\n\n    Config envconf = envConf(source, env);\n\n    // application.[env].conf -> application.conf\n    Config conf = envconf.withFallback(source);\n\n    return system\n        .withFallback(args)\n        .withFallback(conf)\n        .withFallback(moduleStack)\n        .withFallback(MediaType.types)\n        .withFallback(defaultConfig(conf, Route.normalize(cpath)))\n        .resolve();\n  }\n\n  /**\n   * Build a conf from arguments.\n   *\n   * @param args Application arguments.\n   * @return A conf.\n   */\n  static Config args(final String[] args) {\n    if (args == null || args.length == 0) {\n      return ConfigFactory.empty();\n    }\n    Map<String, String> conf = new HashMap<>();\n    for (String arg : args) {\n      String[] values = arg.split(\"=\");\n      String name;\n      String value;\n      if (values.length == 2) {\n        name = values[0];\n        value = values[1];\n      } else {\n        name = \"application.env\";\n        value = values[0];\n      }\n      if (name.indexOf(\".\") == -1) {\n        conf.put(\"application.\" + name, value);\n      }\n      conf.put(name, value);\n    }\n    return ConfigFactory.parseMap(conf, \"args\");\n  }\n\n  /**\n   * Build a env config: <code>[application].[env].[conf]</code>.\n   * Stack looks like\n   *\n   * <pre>\n   *   (file://[origin].[env].[conf])?\n   *   (cp://[origin].[env].[conf])?\n   *   file://application.[env].[conf]\n   *   /application.[env].[conf]\n   * </pre>\n   *\n   * @param source App source to use.\n   * @param env Application env.\n   * @return A config env.\n   */\n  private Config envConf(final Config source, final String env) {\n    String name = Optional.ofNullable(this.confname).orElse(source.origin().resource());\n    Config result = ConfigFactory.empty();\n    if (name != null) {\n      // load [resource].[env].[ext]\n      int dot = name.lastIndexOf('.');\n      name = name.substring(0, dot);\n    } else {\n      name = \"application\";\n    }\n    String envconfname = name + \".\" + env + \".conf\";\n    Config envconf = fileConfig(envconfname);\n    Config appconf = fileConfig(name + \".conf\");\n    return result\n        // file system:\n        .withFallback(envconf)\n        .withFallback(appconf)\n        // classpath:\n        .withFallback(ConfigFactory.parseResources(envconfname));\n  }\n\n  /**\n   * Config from file system.\n   *\n   * @param fname A file name.\n   * @return A config for the file name.\n   */\n  static Config fileConfig(final String fname) {\n    // TODO: sanitization of arguments\n    File dir = new File(System.getProperty(\"user.dir\"));\n    // TODO: sanitization of arguments\n    File froot = new File(dir, fname);\n    if (froot.exists()) {\n      return ConfigFactory.parseFile(froot);\n    } else {\n      // TODO: sanitization of arguments\n      File fconfig = new File(new File(dir, \"conf\"), fname);\n      if (fconfig.exists()) {\n        return ConfigFactory.parseFile(fconfig);\n      }\n    }\n    return ConfigFactory.empty();\n  }\n\n  /**\n   * Build default application.* properties.\n   *\n   * @param conf A source config.\n   * @param cpath Application path.\n   * @return default properties.\n   */\n  private Config defaultConfig(final Config conf, final String cpath) {\n    String ns = Optional.ofNullable(getClass().getPackage())\n        .map(Package::getName)\n        .orElse(\"default.\" + getClass().getName());\n    String[] parts = ns.split(\"\\\\.\");\n    String appname = parts[parts.length - 1];\n\n    // locale\n    final List<Locale> locales;\n    if (!conf.hasPath(\"application.lang\")) {\n      locales = Optional.ofNullable(this.languages)\n          .map(langs -> LocaleUtils.parse(Joiner.on(\",\").join(langs)))\n          .orElse(ImmutableList.of(Locale.getDefault()));\n    } else {\n      locales = LocaleUtils.parse(conf.getString(\"application.lang\"));\n    }\n    Locale locale = locales.iterator().next();\n    String lang = locale.toLanguageTag();\n\n    // time zone\n    final String tz;\n    if (!conf.hasPath(\"application.tz\")) {\n      tz = Optional.ofNullable(zoneId).orElse(ZoneId.systemDefault()).getId();\n    } else {\n      tz = conf.getString(\"application.tz\");\n    }\n\n    // number format\n    final String nf;\n    if (!conf.hasPath(\"application.numberFormat\")) {\n      nf = Optional.ofNullable(numberFormat)\n          .orElseGet(() -> ((DecimalFormat) DecimalFormat.getInstance(locale)).toPattern());\n    } else {\n      nf = conf.getString(\"application.numberFormat\");\n    }\n\n    int processors = Runtime.getRuntime().availableProcessors();\n    String version = Optional.ofNullable(getClass().getPackage())\n        .map(Package::getImplementationVersion)\n        .filter(Objects::nonNull)\n        .orElse(\"0.0.0\");\n    Config defs = ConfigFactory.parseResources(Jooby.class, \"jooby.conf\")\n        .withValue(\"contextPath\", fromAnyRef(cpath.equals(\"/\") ? \"\" : cpath))\n        .withValue(\"application.name\", fromAnyRef(appname))\n        .withValue(\"application.version\", fromAnyRef(version))\n        .withValue(\"application.class\", fromAnyRef(classname))\n        .withValue(\"application.ns\", fromAnyRef(ns))\n        .withValue(\"application.lang\", fromAnyRef(lang))\n        .withValue(\"application.tz\", fromAnyRef(tz))\n        .withValue(\"application.numberFormat\", fromAnyRef(nf))\n        .withValue(\"server.http2.enabled\", fromAnyRef(http2))\n        .withValue(\"runtime.processors\", fromAnyRef(processors))\n        .withValue(\"runtime.processors-plus1\", fromAnyRef(processors + 1))\n        .withValue(\"runtime.processors-plus2\", fromAnyRef(processors + 2))\n        .withValue(\"runtime.processors-x2\", fromAnyRef(processors * 2))\n        .withValue(\"runtime.processors-x4\", fromAnyRef(processors * 4))\n        .withValue(\"runtime.processors-x8\", fromAnyRef(processors * 8))\n        .withValue(\"runtime.concurrencyLevel\", fromAnyRef(Math.max(4, processors)))\n        .withValue(\"server.threads.Min\", fromAnyRef(Math.max(4, processors)))\n        .withValue(\"server.threads.Max\", fromAnyRef(Math.max(32, processors * 8)));\n\n    if (charset != null) {\n      defs = defs.withValue(\"application.charset\", fromAnyRef(charset.name()));\n    }\n    if (port != null) {\n      defs = defs.withValue(\"application.port\", fromAnyRef(port));\n    }\n    if (securePort != null) {\n      defs = defs.withValue(\"application.securePort\", fromAnyRef(securePort));\n    }\n    if (dateFormat != null) {\n      defs = defs.withValue(\"application.dateFormat\", fromAnyRef(dateFormat));\n    }\n    return defs;\n  }\n\n  /**\n   * Install a {@link Jooby.Module}.\n   *\n   * @param log Logger.\n   * @param module The module to install.\n   * @param env Application env.\n   * @param config The configuration object.\n   * @param binder A Guice binder.\n   * @throws Throwable If module bootstrap fails.\n   */\n  private static void install(final Logger log, final Jooby.Module module, final Env env, final Config config,\n      final Binder binder) throws Throwable {\n    module.configure(env, config, binder);\n    try {\n      binder.install(ProviderMethodsModule.forObject(module));\n    } catch (NoClassDefFoundError x) {\n      // Allow dynamic linking of optional dependencies (required by micrometer module), we ignore\n      // missing classes here, if there is a missing class Jooby is going to fails early (not here)\n      log.debug(\"ignoring class not found from guice provider method\", x);\n    }\n  }\n\n  /**\n   * Bind a {@link Config} and make it available for injection. Each property of the config is also\n   * binded it and ready to be injected with {@link javax.inject.Named}.\n   *\n   * @param binder Guice binder.\n   * @param config App config.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void bindConfig(final Binder binder, final Config config) {\n    // root nodes\n    traverse(binder, \"\", config.root());\n\n    // terminal nodes\n    for (Entry<String, ConfigValue> entry : config.entrySet()) {\n      String name = entry.getKey();\n      Named named = Names.named(name);\n      Object value = entry.getValue().unwrapped();\n      if (value instanceof List) {\n        List<Object> values = (List<Object>) value;\n        Type listType = values.size() == 0\n            ? String.class\n            : Types.listOf(values.iterator().next().getClass());\n        Key<Object> key = (Key<Object>) Key.get(listType, Names.named(name));\n        binder.bind(key).toInstance(values);\n      } else {\n        binder.bindConstant().annotatedWith(named).to(value.toString());\n      }\n    }\n    // bind config\n    binder.bind(Config.class).toInstance(config);\n  }\n\n  private static void traverse(final Binder binder, final String p, final ConfigObject root) {\n    root.forEach((n, v) -> {\n      if (v instanceof ConfigObject) {\n        ConfigObject child = (ConfigObject) v;\n        String path = p + n;\n        Named named = Names.named(path);\n        binder.bind(Config.class).annotatedWith(named).toInstance(child.toConfig());\n        traverse(binder, path + \".\", child);\n      }\n    });\n  }\n\n  private static Predicate<String> envpredicate(final String candidate) {\n    return env -> env.equalsIgnoreCase(candidate) || candidate.equals(\"*\");\n  }\n\n  static String logback(final Config conf) {\n    // Avoid warning message from logback when multiples files are present\n    String logback;\n    if (conf.hasPath(\"logback.configurationFile\")) {\n      logback = conf.getString(\"logback.configurationFile\");\n    } else {\n      String env = conf.hasPath(\"application.env\") ? conf.getString(\"application.env\") : null;\n      ImmutableList.Builder<File> files = ImmutableList.builder();\n      // TODO: sanitization of arguments\n      File userdir = new File(System.getProperty(\"user.dir\"));\n      File confdir = new File(userdir, \"conf\");\n      if (env != null) {\n        files.add(new File(userdir, \"logback.\" + env + \".xml\"));\n        files.add(new File(confdir, \"logback.\" + env + \".xml\"));\n      }\n      files.add(new File(userdir, \"logback.xml\"));\n      files.add(new File(confdir, \"logback.xml\"));\n      logback = files.build()\n          .stream()\n          .filter(File::exists)\n          .map(File::getAbsolutePath)\n          .findFirst()\n          .orElseGet(() -> {\n            return Optional.ofNullable(Jooby.class.getResource(\"/logback.\" + env + \".xml\"))\n                .map(Objects::toString)\n                .orElse(\"logback.xml\");\n          });\n    }\n    return logback;\n  }\n\n  private static Logger logger(final Jooby app) {\n    return LoggerFactory.getLogger(app.getClass());\n  }\n\n  private Route.AssetDefinition configureAssetHandler(final Route.AssetDefinition handler) {\n    onStart(r -> {\n      Config conf = r.require(Config.class);\n      handler\n          .cdn(conf.getString(\"assets.cdn\"))\n          .lastModified(conf.getBoolean(\"assets.lastModified\"))\n          .etag(conf.getBoolean(\"assets.etag\"))\n          .maxAge(conf.getString(\"assets.cache.maxAge\"));\n    });\n    return handler;\n  }\n\n  /**\n   * Class name is this, except for script bootstrap.\n   *\n   * @param name Default classname.\n   * @return Classname.\n   */\n  private String classname(String name) {\n    if (name.equals(Jooby.class.getName()) || name.equals(\"org.jooby.Kooby\")) {\n      return SourceProvider.INSTANCE.get()\n          .map(StackTraceElement::getClassName)\n          .orElse(name);\n    }\n    return name;\n  }\n}\n", "target": 1}
{"idx": 989, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi, CloudBees, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.util;\n\nimport groovy.lang.Binding;\nimport groovy.lang.GroovyShell;\nimport hudson.FilePath;\nimport hudson.Functions;\nimport jenkins.model.Jenkins;\nimport hudson.remoting.AsyncFutureImpl;\nimport hudson.remoting.Callable;\nimport hudson.remoting.DelegatingCallable;\nimport hudson.remoting.Future;\nimport hudson.remoting.VirtualChannel;\nimport hudson.security.AccessControlled;\nimport org.codehaus.groovy.control.CompilerConfiguration;\nimport org.codehaus.groovy.control.customizers.ImportCustomizer;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.WebMethod;\n\nimport javax.management.JMException;\nimport javax.management.MBeanServer;\nimport javax.management.ObjectName;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadInfo;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * Various remoting operations related to diagnostics.\n *\n * <p>\n * These code are useful wherever {@link VirtualChannel} is used, such as master, slaves, Maven JVMs, etc.\n *\n * @author Kohsuke Kawaguchi\n * @since 1.175\n */\npublic final class RemotingDiagnostics {\n    public static Map<Object,Object> getSystemProperties(VirtualChannel channel) throws IOException, InterruptedException {\n        if(channel==null)\n            return Collections.<Object,Object>singletonMap(\"N/A\",\"N/A\");\n        return channel.call(new GetSystemProperties());\n    }\n\n    private static final class GetSystemProperties implements Callable<Map<Object,Object>,RuntimeException> {\n        public Map<Object,Object> call() {\n            return new TreeMap<Object,Object>(System.getProperties());\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    public static Map<String,String> getThreadDump(VirtualChannel channel) throws IOException, InterruptedException {\n        if(channel==null)\n            return Collections.singletonMap(\"N/A\",\"N/A\");\n        return channel.call(new GetThreadDump());\n    }\n\n    public static Future<Map<String,String>> getThreadDumpAsync(VirtualChannel channel) throws IOException, InterruptedException {\n        if(channel==null)\n            return new AsyncFutureImpl<Map<String, String>>(Collections.singletonMap(\"N/A\",\"offline\"));\n        return channel.callAsync(new GetThreadDump());\n    }\n\n    private static final class GetThreadDump implements Callable<Map<String,String>,RuntimeException> {\n        public Map<String,String> call() {\n            Map<String,String> r = new LinkedHashMap<String,String>();\n            try {\n                ThreadInfo[] data = Functions.getThreadInfos();\n                Functions.ThreadGroupMap map = Functions.sortThreadsAndGetGroupMap(data);\n                for (ThreadInfo ti : data)\n                    r.put(ti.getThreadName(),Functions.dumpThreadInfo(ti,map));\n            } catch (LinkageError _) {\n                // not in JDK6. fall back to JDK5\n                r.clear();\n                for (Map.Entry<Thread,StackTraceElement[]> t : Functions.dumpAllThreads().entrySet()) {\n                    StringBuilder buf = new StringBuilder();\n                    for (StackTraceElement e : t.getValue())\n                        buf.append(e).append('\\n');\n                    r.put(t.getKey().getName(),buf.toString());\n                }\n            }\n            return r;\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     * Executes Groovy script remotely.\n     */\n    public static String executeGroovy(String script, VirtualChannel channel) throws IOException, InterruptedException {\n        return channel.call(new Script(script));\n    }\n\n    private static final class Script implements DelegatingCallable<String,RuntimeException> {\n        private final String script;\n        private transient ClassLoader cl;\n\n        private Script(String script) {\n            this.script = script;\n            cl = getClassLoader();\n        }\n\n        public ClassLoader getClassLoader() {\n            return Jenkins.getInstance().getPluginManager().uberClassLoader;\n        }\n\n        public String call() throws RuntimeException {\n            // if we run locally, cl!=null. Otherwise the delegating classloader will be available as context classloader.\n            if (cl==null)       cl = Thread.currentThread().getContextClassLoader();\n            CompilerConfiguration cc = new CompilerConfiguration();\n            cc.addCompilationCustomizers(new ImportCustomizer().addStarImports(\n                    \"jenkins\",\n                    \"jenkins.model\",\n                    \"hudson\",\n                    \"hudson.model\"));\n            GroovyShell shell = new GroovyShell(cl,new Binding(),cc);\n\n            StringWriter out = new StringWriter();\n            PrintWriter pw = new PrintWriter(out);\n            shell.setVariable(\"out\", pw);\n            try {\n                Object output = shell.evaluate(script);\n                if(output!=null)\n                pw.println(\"Result: \"+output);\n            } catch (Throwable t) {\n                t.printStackTrace(pw);\n            }\n            return out.toString();\n        }\n    }\n\n    /**\n     * Obtains the heap dump in an HPROF file.\n     */\n    public static FilePath getHeapDump(VirtualChannel channel) throws IOException, InterruptedException {\n        return channel.call(new Callable<FilePath, IOException>() {\n            public FilePath call() throws IOException {\n                final File hprof = File.createTempFile(\"hudson-heapdump\", \"hprof\");\n                hprof.delete();\n                try {\n                    MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n                    server.invoke(new ObjectName(\"com.sun.management:type=HotSpotDiagnostic\"), \"dumpHeap\",\n                            new Object[]{hprof.getAbsolutePath(), true}, new String[]{String.class.getName(), boolean.class.getName()});\n\n                    return new FilePath(hprof);\n                } catch (JMException e) {\n                    throw new IOException2(e);\n                }\n            }\n\n            private static final long serialVersionUID = 1L;\n        });\n    }\n\n    /**\n     * Heap dump, exposable to URL via Stapler.\n     *\n     */\n    public static class HeapDump {\n        private final AccessControlled owner;\n        private final VirtualChannel channel;\n\n        public HeapDump(AccessControlled owner, VirtualChannel channel) {\n            this.owner = owner;\n            this.channel = channel;\n        }\n\n        /**\n         * Obtains the heap dump.\n         */\n        public void doIndex(StaplerResponse rsp) throws IOException {\n            rsp.sendRedirect(\"heapdump.hprof\");\n        }\n\n        @WebMethod(name=\"heapdump.hprof\")\n        public void doHeapDump(StaplerRequest req, StaplerResponse rsp) throws IOException, InterruptedException {\n            owner.checkPermission(Jenkins.ADMINISTER);\n            rsp.setContentType(\"application/octet-stream\");\n\n            FilePath dump = obtain();\n            try {\n                dump.copyTo(rsp.getCompressedOutputStream(req));\n            } finally {\n                dump.delete();\n            }\n        }\n\n        public FilePath obtain() throws IOException, InterruptedException {\n            return RemotingDiagnostics.getHeapDump(channel);\n        }\n    }\n}\n", "target": 1}
{"idx": 990, "func": "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.gce.internal.model;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.smarthome.io.net.http.HttpUtil;\nimport org.openhab.binding.gce.internal.handler.Ipx800EventListener;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * This class takes care of interpreting the status.xml file\n *\n * @author Gal L'hopital - Initial contribution\n */\n@NonNullByDefault\npublic class StatusFileInterpreter {\n    private static final String URL_TEMPLATE = \"http://%s/globalstatus.xml\";\n    private final Logger logger = LoggerFactory.getLogger(StatusFileInterpreter.class);\n    private final String hostname;\n    private @Nullable Document doc;\n    private final Ipx800EventListener listener;\n\n    public static enum StatusEntry {\n        VERSION,\n        CONFIG_MAC;\n    }\n\n    public StatusFileInterpreter(String hostname, Ipx800EventListener listener) {\n        this.hostname = hostname;\n        this.listener = listener;\n    }\n\n    public void read() {\n        try {\n            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n            String statusPage = HttpUtil.executeUrl(\"GET\", String.format(URL_TEMPLATE, hostname), 5000);\n            InputStream inputStream = new ByteArrayInputStream(statusPage.getBytes());\n            Document document = builder.parse(inputStream);\n            document.getDocumentElement().normalize();\n            doc = document;\n            pushDatas();\n            inputStream.close();\n        } catch (IOException | SAXException | ParserConfigurationException e) {\n            logger.warn(\"Unable to read IPX800 status page : {}\", e.getMessage());\n            doc = null;\n        }\n    }\n\n    private void pushDatas() {\n        Element root = getRoot();\n        if (root != null) {\n            PortDefinition.asStream().forEach(portDefinition -> {\n                List<Node> xmlNodes = getMatchingNodes(root.getChildNodes(), portDefinition.getNodeName());\n                xmlNodes.forEach(xmlNode -> {\n                    String sPortNum = xmlNode.getNodeName().replace(portDefinition.getNodeName(), \"\");\n                    int portNum = Integer.parseInt(sPortNum) + 1;\n                    double value = Double.parseDouble(xmlNode.getTextContent().replace(\"dn\", \"1\").replace(\"up\", \"0\"));\n                    listener.dataReceived(String.format(\"%s%d\", portDefinition.getPortName(), portNum), value);\n                });\n            });\n        }\n    }\n\n    public String getElement(StatusEntry entry) {\n        Element root = getRoot();\n        if (root != null) {\n            return root.getElementsByTagName(entry.name().toLowerCase()).item(0).getTextContent();\n        } else {\n            return \"\";\n        }\n    }\n\n    private List<Node> getMatchingNodes(NodeList nodeList, String criteria) {\n        return IntStream.range(0, nodeList.getLength()).boxed().map(nodeList::item)\n                .filter(node -> node.getNodeName().startsWith(criteria))\n                .sorted(Comparator.comparing(o -> o.getNodeName())).collect(Collectors.toList());\n    }\n\n    public int getMaxNumberofNodeType(PortDefinition portDefinition) {\n        Element root = getRoot();\n        if (root != null) {\n            List<Node> filteredNodes = getMatchingNodes(root.getChildNodes(), portDefinition.getNodeName());\n            return filteredNodes.size();\n        }\n        return 0;\n    }\n\n    private @Nullable Element getRoot() {\n        if (doc == null) {\n            read();\n        }\n        if (doc != null) {\n            return doc.getDocumentElement();\n        }\n        return null;\n    }\n}\n", "target": 1}
{"idx": 991, "func": "/*\n * Copyright (c) 2011-2017 Contributors to the Eclipse Foundation\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n * which is available at https://www.apache.org/licenses/LICENSE-2.0.\n *\n * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n */\n\npackage io.vertx.core.http.impl;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.CompositeByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.vertx.codegen.annotations.Nullable;\nimport io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.http.CaseInsensitiveHeaders;\nimport io.vertx.core.http.HttpClientRequest;\nimport io.vertx.core.http.HttpClientResponse;\nimport io.vertx.core.http.HttpConnection;\nimport io.vertx.core.http.HttpFrame;\nimport io.vertx.core.http.HttpMethod;\nimport io.vertx.core.http.HttpVersion;\nimport io.vertx.core.impl.ContextInternal;\nimport io.vertx.core.impl.VertxInternal;\nimport io.vertx.core.logging.Logger;\nimport io.vertx.core.logging.LoggerFactory;\nimport io.vertx.core.net.NetSocket;\n\nimport java.util.List;\nimport java.util.Objects;\n\nimport static io.vertx.core.http.HttpHeaders.*;\n\n/**\n * This class is optimised for performance when used on the same event loop that is was passed to the handler with.\n * However it can be used safely from other threads.\n *\n * The internal state is protected using the synchronized keyword. If always used on the same event loop, then\n * we benefit from biased locking which makes the overhead of synchronized near zero.\n *\n * This class uses {@code this} for synchronization purpose. The {@link #client}  or{@link #stream} instead are\n * called must not be called under this lock to avoid deadlocks.\n *\n * @author <a href=\"http://tfox.org\">Tim Fox</a>\n */\npublic class HttpClientRequestImpl extends HttpClientRequestBase implements HttpClientRequest {\n\n  static final Logger log = LoggerFactory.getLogger(ConnectionManager.class);\n\n  private final VertxInternal vertx;\n  private Handler<HttpClientResponse> respHandler;\n  private Handler<Void> endHandler;\n  private boolean chunked;\n  private String hostHeader;\n  private String rawMethod;\n  private Handler<Void> continueHandler;\n  private Handler<Void> drainHandler;\n  private Handler<HttpClientRequest> pushHandler;\n  private Handler<HttpConnection> connectionHandler;\n  private boolean completed;\n  private Handler<Void> completionHandler;\n  private Long reset;\n  private ByteBuf pendingChunks;\n  private int pendingMaxSize = -1;\n  private int followRedirects;\n  private long written;\n  private CaseInsensitiveHeaders headers;\n\n  private HttpClientStream stream;\n  private boolean connecting;\n\n  // completed => drainHandler = null\n\n  HttpClientRequestImpl(HttpClientImpl client, boolean ssl, HttpMethod method, String host, int port,\n                        String relativeURI, VertxInternal vertx) {\n    super(client, ssl, method, host, port, relativeURI);\n    this.chunked = false;\n    this.vertx = vertx;\n  }\n\n  @Override\n  public int streamId() {\n    HttpClientStream s;\n    synchronized (this) {\n      if ((s = stream) == null) {\n        return -1;\n      }\n    }\n    return s.id();\n  }\n\n  @Override\n  public  synchronized HttpClientRequest handler(Handler<HttpClientResponse> handler) {\n    if (handler != null) {\n      checkComplete();\n      respHandler = checkConnect(method, handler);\n    } else {\n      respHandler = null;\n    }\n    return this;\n  }\n\n  @Override\n  public HttpClientRequest pause() {\n    return this;\n  }\n\n  @Override\n  public HttpClientRequest resume() {\n    return this;\n  }\n\n  @Override\n  public HttpClientRequest setFollowRedirects(boolean followRedirects) {\n    synchronized (this) {\n      checkComplete();\n      if (followRedirects) {\n        this.followRedirects = client.getOptions().getMaxRedirects() - 1;\n      } else {\n        this.followRedirects = 0;\n      }\n      return this;\n    }\n  }\n\n  @Override\n  public HttpClientRequest endHandler(Handler<Void> handler) {\n    synchronized (this) {\n      if (handler != null) {\n        checkComplete();\n      }\n      endHandler = handler;\n      return this;\n    }\n  }\n\n  @Override\n  public HttpClientRequestImpl setChunked(boolean chunked) {\n    synchronized (this) {\n      checkComplete();\n      if (written > 0) {\n        throw new IllegalStateException(\"Cannot set chunked after data has been written on request\");\n      }\n      // HTTP 1.0 does not support chunking so we ignore this if HTTP 1.0\n      if (client.getOptions().getProtocolVersion() != io.vertx.core.http.HttpVersion.HTTP_1_0) {\n        this.chunked = chunked;\n      }\n      return this;\n    }\n  }\n\n  @Override\n  public synchronized boolean isChunked() {\n    return chunked;\n  }\n\n  @Override\n  public synchronized String getRawMethod() {\n    return rawMethod;\n  }\n\n  @Override\n  public synchronized HttpClientRequest setRawMethod(String method) {\n    this.rawMethod = method;\n    return this;\n  }\n\n  @Override\n  public synchronized HttpClientRequest setHost(String host) {\n    this.hostHeader = host;\n    return this;\n  }\n\n  @Override\n  public synchronized String getHost() {\n    return hostHeader;\n  }\n\n  @Override\n  public synchronized MultiMap headers() {\n    if (headers == null) {\n      headers = new CaseInsensitiveHeaders();\n    }\n    return headers;\n  }\n\n  @Override\n  public synchronized HttpClientRequest putHeader(String name, String value) {\n    checkComplete();\n    headers().set(name, value);\n    return this;\n  }\n\n  @Override\n  public synchronized HttpClientRequest putHeader(String name, Iterable<String> values) {\n    checkComplete();\n    headers().set(name, values);\n    return this;\n  }\n\n  @Override\n  public HttpClientRequest setWriteQueueMaxSize(int maxSize) {\n    HttpClientStream s;\n    synchronized (this) {\n      checkComplete();\n      if ((s = stream) == null) {\n        pendingMaxSize = maxSize;\n        return this;\n      }\n    }\n    s.doSetWriteQueueMaxSize(maxSize);\n    return this;\n  }\n\n  @Override\n  public boolean writeQueueFull() {\n    HttpClientStream s;\n    synchronized (this) {\n      checkComplete();\n      if ((s = stream) == null) {\n        // Should actually check with max queue size and not always blindly return false\n        return false;\n      }\n    }\n    return s.isNotWritable();\n  }\n\n  @Override\n  public HttpClientRequest drainHandler(Handler<Void> handler) {\n    synchronized (this) {\n      if (handler != null) {\n        checkComplete();\n        drainHandler = handler;\n        HttpClientStream s;\n        if ((s = stream) == null) {\n          return this;\n        }\n        s.getContext().runOnContext(v -> {\n          synchronized (HttpClientRequestImpl.this) {\n            if (!stream.isNotWritable()) {\n              handleDrained();\n            }\n          }\n        });\n      } else {\n        drainHandler = null;\n      }\n      return this;\n    }\n  }\n\n  @Override\n  public synchronized HttpClientRequest continueHandler(Handler<Void> handler) {\n    if (handler != null) {\n      checkComplete();\n    }\n    this.continueHandler = handler;\n    return this;\n  }\n\n  @Override\n  public HttpClientRequest sendHead() {\n    return sendHead(null);\n  }\n\n  @Override\n  public synchronized HttpClientRequest sendHead(Handler<HttpVersion> headersHandler) {\n    checkComplete();\n    checkResponseHandler();\n    if (stream != null) {\n      throw new IllegalStateException(\"Head already written\");\n    } else {\n      connect(headersHandler);\n    }\n    return this;\n  }\n\n  @Override\n  public synchronized HttpClientRequest putHeader(CharSequence name, CharSequence value) {\n    checkComplete();\n    headers().set(name, value);\n    return this;\n  }\n\n  @Override\n  public synchronized HttpClientRequest putHeader(CharSequence name, Iterable<CharSequence> values) {\n    checkComplete();\n    headers().set(name, values);\n    return this;\n  }\n\n  @Override\n  public synchronized HttpClientRequest pushHandler(Handler<HttpClientRequest> handler) {\n    pushHandler = handler;\n    return this;\n  }\n\n  @Override\n  public boolean reset(long code) {\n    HttpClientStream s;\n    synchronized (this) {\n      if (reset != null) {\n        return false;\n      }\n      reset = code;\n      if (tryComplete()) {\n        if (completionHandler != null) {\n          completionHandler.handle(null);\n        }\n      }\n      s = stream;\n    }\n    if (s != null) {\n      s.reset(code);\n    }\n    return true;\n  }\n\n  private boolean tryComplete() {\n    if (!completed) {\n      completed = true;\n      drainHandler = null;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  @Override\n  public HttpConnection connection() {\n    HttpClientStream s;\n    synchronized (this) {\n      if ((s = stream) == null) {\n        return null;\n      }\n    }\n    return s.connection();\n  }\n\n  @Override\n  public synchronized HttpClientRequest connectionHandler(@Nullable Handler<HttpConnection> handler) {\n    connectionHandler = handler;\n    return this;\n  }\n\n  @Override\n  public synchronized HttpClientRequest writeCustomFrame(int type, int flags, Buffer payload) {\n    HttpClientStream s;\n    synchronized (this) {\n      checkComplete();\n      if ((s = stream) == null) {\n        throw new IllegalStateException(\"Not yet connected\");\n      }\n    }\n    s.writeFrame(type, flags, payload.getByteBuf());\n    return this;\n  }\n\n  void handleDrained() {\n    Handler<Void> handler;\n    synchronized (this) {\n      if ((handler = drainHandler) == null) {\n        return;\n      }\n    }\n    try {\n      handler.handle(null);\n    } catch (Throwable t) {\n      handleException(t);\n    }\n  }\n\n  private void handleNextRequest(HttpClientRequestImpl next, long timeoutMs) {\n    next.handler(respHandler);\n    next.exceptionHandler(exceptionHandler());\n    exceptionHandler(null);\n    next.endHandler(endHandler);\n    next.pushHandler = pushHandler;\n    next.followRedirects = followRedirects - 1;\n    next.written = written;\n    if (next.hostHeader == null) {\n      next.hostHeader = hostHeader;\n    }\n    if (headers != null && next.headers == null) {\n      next.headers().addAll(headers);\n    }\n    Future<Void> fut = Future.future();\n    fut.setHandler(ar -> {\n      if (ar.succeeded()) {\n        if (timeoutMs > 0) {\n          next.setTimeout(timeoutMs);\n        }\n        next.end();\n      } else {\n        next.handleException(ar.cause());\n      }\n    });\n    if (exceptionOccurred != null) {\n      fut.fail(exceptionOccurred);\n    }\n    else if (completed) {\n      fut.complete();\n    } else {\n      exceptionHandler(err -> {\n        if (!fut.isComplete()) {\n          fut.fail(err);\n        }\n      });\n      completionHandler = v -> {\n        if (!fut.isComplete()) {\n          fut.complete();\n        }\n      };\n    }\n  }\n\n  protected void doHandleResponse(HttpClientResponseImpl resp, long timeoutMs) {\n    if (reset == null) {\n      int statusCode = resp.statusCode();\n      if (followRedirects > 0 && statusCode >= 300 && statusCode < 400) {\n        Future<HttpClientRequest> next = client.redirectHandler().apply(resp);\n        if (next != null) {\n          next.setHandler(ar -> {\n            if (ar.succeeded()) {\n              handleNextRequest((HttpClientRequestImpl) ar.result(), timeoutMs);\n            } else {\n              handleException(ar.cause());\n            }\n          });\n          return;\n        }\n      }\n      if (statusCode == 100) {\n        if (continueHandler != null) {\n          continueHandler.handle(null);\n        }\n      } else {\n        if (respHandler != null) {\n          respHandler.handle(resp);\n        }\n        if (endHandler != null) {\n          endHandler.handle(null);\n        }\n      }\n    }\n  }\n\n  @Override\n  protected String hostHeader() {\n    return hostHeader != null ? hostHeader : super.hostHeader();\n  }\n\n  private Handler<HttpClientResponse> checkConnect(io.vertx.core.http.HttpMethod method, Handler<HttpClientResponse> handler) {\n    if (method == io.vertx.core.http.HttpMethod.CONNECT) {\n      // special handling for CONNECT\n      handler = connectHandler(handler);\n    }\n    return handler;\n  }\n\n  private Handler<HttpClientResponse> connectHandler(Handler<HttpClientResponse> responseHandler) {\n    Objects.requireNonNull(responseHandler, \"no null responseHandler accepted\");\n    return resp -> {\n      HttpClientResponse response;\n      if (resp.statusCode() == 200) {\n        // connect successful force the modification of the ChannelPipeline\n        // beside this also pause the socket for now so the user has a chance to register its dataHandler\n        // after received the NetSocket\n        NetSocket socket = resp.netSocket();\n        socket.pause();\n\n        response = new HttpClientResponse() {\n          private boolean resumed;\n\n          @Override\n          public HttpClientRequest request() {\n            return resp.request();\n          }\n\n          @Override\n          public int statusCode() {\n            return resp.statusCode();\n          }\n\n          @Override\n          public String statusMessage() {\n            return resp.statusMessage();\n          }\n\n          @Override\n          public MultiMap headers() {\n            return resp.headers();\n          }\n\n          @Override\n          public String getHeader(String headerName) {\n            return resp.getHeader(headerName);\n          }\n\n          @Override\n          public String getHeader(CharSequence headerName) {\n            return resp.getHeader(headerName);\n          }\n\n          @Override\n          public String getTrailer(String trailerName) {\n            return resp.getTrailer(trailerName);\n          }\n\n          @Override\n          public MultiMap trailers() {\n            return resp.trailers();\n          }\n\n          @Override\n          public List<String> cookies() {\n            return resp.cookies();\n          }\n\n          @Override\n          public HttpVersion version() {\n            return resp.version();\n          }\n\n          @Override\n          public HttpClientResponse bodyHandler(Handler<Buffer> bodyHandler) {\n            resp.bodyHandler(bodyHandler);\n            return this;\n          }\n\n          @Override\n          public HttpClientResponse customFrameHandler(Handler<HttpFrame> handler) {\n            resp.customFrameHandler(handler);\n            return this;\n          }\n\n          @Override\n          public synchronized NetSocket netSocket() {\n            if (!resumed) {\n              resumed = true;\n              vertx.getContext().runOnContext((v) -> socket.resume()); // resume the socket now as the user had the chance to register a dataHandler\n            }\n            return socket;\n          }\n\n          @Override\n          public HttpClientResponse endHandler(Handler<Void> endHandler) {\n            resp.endHandler(endHandler);\n            return this;\n          }\n\n          @Override\n          public HttpClientResponse handler(Handler<Buffer> handler) {\n            resp.handler(handler);\n            return this;\n          }\n\n          @Override\n          public HttpClientResponse pause() {\n            resp.pause();\n            return this;\n          }\n\n          @Override\n          public HttpClientResponse resume() {\n            resp.resume();\n            return this;\n          }\n\n          @Override\n          public HttpClientResponse exceptionHandler(Handler<Throwable> handler) {\n            resp.exceptionHandler(handler);\n            return this;\n          }\n        };\n      } else {\n        response = resp;\n      }\n      responseHandler.handle(response);\n    };\n  }\n\n  private synchronized void connect(Handler<HttpVersion> headersHandler) {\n    if (!connecting) {\n\n      if (method == HttpMethod.OTHER && rawMethod == null) {\n        throw new IllegalStateException(\"You must provide a rawMethod when using an HttpMethod.OTHER method\");\n      }\n\n      String peerHost;\n      if (hostHeader != null) {\n        int idx = hostHeader.lastIndexOf(':');\n        if (idx != -1) {\n          peerHost = hostHeader.substring(0, idx);\n        } else {\n          peerHost = hostHeader;\n        }\n      } else {\n        peerHost = host;\n      }\n\n      // Capture some stuff\n      Handler<HttpConnection> initializer = connectionHandler;\n      ContextInternal connectCtx = vertx.getOrCreateContext();\n\n      // We defer actual connection until the first part of body is written or end is called\n      // This gives the user an opportunity to set an exception handler before connecting so\n      // they can capture any exceptions on connection\n      connecting = true;\n      client.getConnectionForRequest(connectCtx, peerHost, ssl, port, host, ar1 -> {\n        if (ar1.succeeded()) {\n          HttpClientStream stream = ar1.result();\n          ContextInternal ctx = (ContextInternal) stream.getContext();\n          if (stream.id() == 1 && initializer != null) {\n            ctx.executeFromIO(v -> {\n              initializer.handle(stream.connection());\n            });\n          }\n          // No need to synchronize as the thread is the same that set exceptionOccurred to true\n          // exceptionOccurred=true getting the connection => it's a TimeoutException\n          if (exceptionOccurred != null || reset != null) {\n            stream.reset(0);\n          } else {\n            ctx.executeFromIO(v -> {\n              connected(headersHandler, stream);\n            });\n          }\n        } else {\n          connectCtx.executeFromIO(v -> {\n            handleException(ar1.cause());\n          });\n        }\n      });\n    }\n  }\n\n  private void connected(Handler<HttpVersion> headersHandler, HttpClientStream stream) {\n    synchronized (this) {\n      this.stream = stream;\n      stream.beginRequest(this);\n\n      // If anything was written or the request ended before we got the connection, then\n      // we need to write it now\n\n      if (pendingMaxSize != -1) {\n        stream.doSetWriteQueueMaxSize(pendingMaxSize);\n      }\n\n      if (pendingChunks != null) {\n        ByteBuf pending = pendingChunks;\n        pendingChunks = null;\n\n        if (completed) {\n          // we also need to write the head so optimize this and write all out in once\n          stream.writeHead(method, rawMethod, uri, headers, hostHeader(), chunked, pending, true);\n          stream.reportBytesWritten(written);\n          stream.endRequest();\n        } else {\n          stream.writeHead(method, rawMethod, uri, headers, hostHeader(), chunked, pending, false);\n        }\n      } else {\n        if (completed) {\n          // we also need to write the head so optimize this and write all out in once\n          stream.writeHead(method, rawMethod, uri, headers, hostHeader(), chunked, null, true);\n          stream.reportBytesWritten(written);\n          stream.endRequest();\n        } else {\n          stream.writeHead(method, rawMethod, uri, headers, hostHeader(), chunked, null, false);\n        }\n      }\n      this.connecting = false;\n      this.stream = stream;\n    }\n    if (headersHandler != null) {\n      headersHandler.handle(stream.version());\n    }\n  }\n\n  private boolean contentLengthSet() {\n    return headers != null && headers().contains(CONTENT_LENGTH);\n  }\n\n  @Override\n  public void end(String chunk) {\n    end(Buffer.buffer(chunk));\n  }\n\n  @Override\n  public void end(String chunk, String enc) {\n    Objects.requireNonNull(enc, \"no null encoding accepted\");\n    end(Buffer.buffer(chunk, enc));\n  }\n\n  @Override\n  public void end(Buffer chunk) {\n    write(chunk.getByteBuf(), true);\n  }\n\n  @Override\n  public void end() {\n    write(null, true);\n  }\n\n  @Override\n  public HttpClientRequestImpl write(Buffer chunk) {\n    ByteBuf buf = chunk.getByteBuf();\n    write(buf, false);\n    return this;\n  }\n\n  @Override\n  public HttpClientRequestImpl write(String chunk) {\n    return write(Buffer.buffer(chunk));\n  }\n\n  @Override\n  public HttpClientRequestImpl write(String chunk, String enc) {\n    Objects.requireNonNull(enc, \"no null encoding accepted\");\n    return write(Buffer.buffer(chunk, enc));\n  }\n\n  private void write(ByteBuf buff, boolean end) {\n    HttpClientStream s;\n    synchronized (this) {\n      checkComplete();\n      checkResponseHandler();\n      if (end) {\n        if (buff != null && !chunked && !contentLengthSet()) {\n          headers().set(CONTENT_LENGTH, String.valueOf(buff.readableBytes()));\n        }\n      } else {\n        if (!chunked && !contentLengthSet()) {\n          throw new IllegalStateException(\"You must set the Content-Length header to be the total size of the message \"\n            + \"body BEFORE sending any data if you are not using HTTP chunked encoding.\");\n        }\n      }\n      if (buff == null && !end) {\n        // nothing to write to the connection just return\n        return;\n      }\n      if (buff != null) {\n        written += buff.readableBytes();\n      }\n      if ((s = stream) == null) {\n        if (buff != null) {\n          if (pendingChunks == null) {\n            pendingChunks = buff;\n          } else {\n            CompositeByteBuf pending;\n            if (pendingChunks instanceof CompositeByteBuf) {\n              pending = (CompositeByteBuf) pendingChunks;\n            } else {\n              pending = Unpooled.compositeBuffer();\n              pending.addComponent(true, pendingChunks);\n              pendingChunks = pending;\n            }\n            pending.addComponent(true, buff);\n          }\n        }\n        if (end) {\n          tryComplete();\n          if (completionHandler != null) {\n            completionHandler.handle(null);\n          }\n        }\n        connect(null);\n        return;\n      }\n    }\n    s.writeBuffer(buff, end);\n    if (end) {\n      s.reportBytesWritten(written); // MUST BE READ UNDER SYNCHRONIZATION\n    }\n    if (end) {\n      Handler<Void> handler;\n      synchronized (this) {\n        tryComplete();\n        s.endRequest();\n        if ((handler = completionHandler) == null) {\n          return;\n        }\n      }\n      handler.handle(null);\n    }\n  }\n\n  protected void checkComplete() {\n    if (completed) {\n      throw new IllegalStateException(\"Request already complete\");\n    }\n  }\n\n  private void checkResponseHandler() {\n    if (respHandler == null) {\n      throw new IllegalStateException(\"You must set an handler for the HttpClientResponse before connecting\");\n    }\n  }\n\n  synchronized Handler<HttpClientRequest> pushHandler() {\n    return pushHandler;\n  }\n}\n", "target": 1}
{"idx": 992, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Martin Eigenbrodt, Matthew R. Harrah, Red Hat, Inc., Stephen Connolly, Tom Huybrechts, CloudBees, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.Collections2;\nimport com.infradna.tool.bridge_method_injector.WithBridgeMethods;\nimport hudson.EnvVars;\nimport hudson.Extension;\nimport hudson.ExtensionPoint;\nimport hudson.PermalinkList;\nimport hudson.Util;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.Fingerprint.Range;\nimport hudson.model.Fingerprint.RangeSet;\nimport hudson.model.PermalinkProjectAction.Permalink;\nimport hudson.model.listeners.ItemListener;\nimport hudson.search.QuickSilver;\nimport hudson.search.SearchIndex;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.search.SearchItem;\nimport hudson.search.SearchItems;\nimport hudson.security.ACL;\nimport hudson.tasks.LogRotator;\nimport hudson.util.AlternativeUiTextProvider;\nimport hudson.util.ChartUtil;\nimport hudson.util.ColorPalette;\nimport hudson.util.CopyOnWriteList;\nimport hudson.util.DataSetBuilder;\nimport hudson.util.DescribableList;\nimport hudson.util.FormApply;\nimport hudson.util.Graph;\nimport hudson.util.ProcessTree;\nimport hudson.util.RunList;\nimport hudson.util.ShiftedCategoryAxis;\nimport hudson.util.StackedAreaRenderer2;\nimport hudson.util.TextFile;\nimport hudson.widgets.HistoryWidget;\nimport hudson.widgets.HistoryWidget.Adapter;\nimport hudson.widgets.Widget;\nimport jenkins.model.Jenkins;\nimport jenkins.model.ProjectNamingStrategy;\nimport jenkins.util.io.OnMaster;\nimport net.sf.json.JSONException;\nimport net.sf.json.JSONObject;\nimport org.jfree.chart.ChartFactory;\nimport org.jfree.chart.JFreeChart;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.CategoryLabelPositions;\nimport org.jfree.chart.axis.NumberAxis;\nimport org.jfree.chart.plot.CategoryPlot;\nimport org.jfree.chart.plot.PlotOrientation;\nimport org.jfree.chart.renderer.category.StackedAreaRenderer;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.ui.RectangleInsets;\nimport org.jvnet.localizer.Localizable;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.CmdLineException;\nimport org.kohsuke.stapler.StaplerOverridable;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport javax.servlet.ServletException;\nimport java.awt.*;\nimport java.io.*;\nimport java.net.URLEncoder;\nimport java.util.*;\nimport java.util.List;\n\nimport static javax.servlet.http.HttpServletResponse.*;\n\n/**\n * A job is an runnable entity under the monitoring of Hudson.\n * \n * <p>\n * Every time it \"runs\", it will be recorded as a {@link Run} object.\n *\n * <p>\n * To create a custom job type, extend {@link TopLevelItemDescriptor} and put {@link Extension} on it.\n *\n * @author Kohsuke Kawaguchi\n */\npublic abstract class Job<JobT extends Job<JobT, RunT>, RunT extends Run<JobT, RunT>>\n        extends AbstractItem implements ExtensionPoint, StaplerOverridable, OnMaster {\n\n    /**\n     * Next build number. Kept in a separate file because this is the only\n     * information that gets updated often. This allows the rest of the\n     * configuration to be in the VCS.\n     * <p>\n     * In 1.28 and earlier, this field was stored in the project configuration\n     * file, so even though this is marked as transient, don't move it around.\n     */\n    protected transient volatile int nextBuildNumber = 1;\n\n    /**\n     * Newly copied jobs get this flag set, so that Hudson doesn't try to run the job until its configuration\n     * is saved once.\n     */\n    private transient volatile boolean holdOffBuildUntilSave;\n\n    private volatile LogRotator logRotator;\n\n    /**\n     * Not all plugins are good at calculating their health report quickly.\n     * These fields are used to cache the health reports to speed up rendering\n     * the main page.\n     */\n    private transient Integer cachedBuildHealthReportsBuildNumber = null;\n    private transient List<HealthReport> cachedBuildHealthReports = null;\n\n    private boolean keepDependencies;\n\n    /**\n     * List of {@link UserProperty}s configured for this project.\n     */\n    // this should have been DescribableList but now it's too late\n    protected CopyOnWriteList<JobProperty<? super JobT>> properties = new CopyOnWriteList<JobProperty<? super JobT>>();\n\n    protected Job(ItemGroup parent, String name) {\n        super(parent, name);\n    }\n\n    @Override\n    public synchronized void save() throws IOException {\n        super.save();\n        holdOffBuildUntilSave = false;\n    }\n\n    @Override\n    public void onLoad(ItemGroup<? extends Item> parent, String name)\n            throws IOException {\n        super.onLoad(parent, name);\n\n        TextFile f = getNextBuildNumberFile();\n        if (f.exists()) {\n            // starting 1.28, we store nextBuildNumber in a separate file.\n            // but old Hudson didn't do it, so if the file doesn't exist,\n            // assume that nextBuildNumber was read from config.xml\n            try {\n                synchronized (this) {\n                    this.nextBuildNumber = Integer.parseInt(f.readTrim());\n                }\n            } catch (NumberFormatException e) {\n                // try to infer the value of the next build number from the existing build records. See JENKINS-11563\n                File[] folders = this.getBuildDir().listFiles(new FileFilter() {\n                    public boolean accept(File file) {\n                        return file.isDirectory() && file.getName().matches(\"[0-9]+\");\n                    }\n                });\n\n                if (folders == null || folders.length == 0) {\n                    this.nextBuildNumber = 1;\n                } else {\n                    Collection<Integer> foldersInt = Collections2.transform(Arrays.asList(folders), new Function<File, Integer>() {\n                        public Integer apply(File file) {\n                            return Integer.parseInt(file.getName());\n                        }\n                    });\n                    this.nextBuildNumber = Collections.max(foldersInt) + 1;\n                }\n                saveNextBuildNumber();\n            }\n        } else {\n            // From the old Hudson, or doCreateItem. Create this file now.\n            saveNextBuildNumber();\n            save(); // and delete it from the config.xml\n        }\n\n        if (properties == null) // didn't exist < 1.72\n            properties = new CopyOnWriteList<JobProperty<? super JobT>>();\n\n        for (JobProperty p : properties)\n            p.setOwner(this);\n    }\n\n    @Override\n    public void onCopiedFrom(Item src) {\n        super.onCopiedFrom(src);\n        synchronized (this) {\n            this.nextBuildNumber = 1; // reset the next build number\n            this.holdOffBuildUntilSave = true;\n        }\n    }\n\n    @Override\n    protected void performDelete() throws IOException, InterruptedException {\n        // if a build is in progress. Cancel it.\n        RunT lb = getLastBuild();\n        if (lb != null) {\n            Executor e = lb.getExecutor();\n            if (e != null) {\n                e.interrupt();\n                // should we block until the build is cancelled?\n            }\n        }\n        super.performDelete();\n    }\n\n    /*package*/ TextFile getNextBuildNumberFile() {\n        return new TextFile(new File(this.getRootDir(), \"nextBuildNumber\"));\n    }\n\n    protected boolean isHoldOffBuildUntilSave() {\n        return holdOffBuildUntilSave;\n    }\n\n    protected synchronized void saveNextBuildNumber() throws IOException {\n        if (nextBuildNumber == 0) { // #3361\n            nextBuildNumber = 1;\n        }\n        getNextBuildNumberFile().write(String.valueOf(nextBuildNumber) + '\\n');\n    }\n\n    @Exported\n    public boolean isInQueue() {\n        return false;\n    }\n\n    /**\n     * If this job is in the build queue, return its item.\n     */\n    @Exported\n    public Queue.Item getQueueItem() {\n        return null;\n    }\n\n    /**\n     * Returns true if a build of this project is in progress.\n     */\n    public boolean isBuilding() {\n        RunT b = getLastBuild();\n        return b!=null && b.isBuilding();\n    }\n    \n    /**\n     * Returns true if the log file is still being updated.\n     */\n    public boolean isLogUpdated() {\n        RunT b = getLastBuild();\n        return b!=null && b.isLogUpdated();\n    }    \n\n    @Override\n    public String getPronoun() {\n        return AlternativeUiTextProvider.get(PRONOUN, this, Messages.Job_Pronoun());\n    }\n\n    /**\n     * Returns whether the name of this job can be changed by user.\n     */\n    public boolean isNameEditable() {\n        return true;\n    }\n\n    /**\n     * If true, it will keep all the build logs of dependency components.\n     */\n    @Exported\n    public boolean isKeepDependencies() {\n        return keepDependencies;\n    }\n\n    /**\n     * Allocates a new buildCommand number.\n     */\n    public synchronized int assignBuildNumber() throws IOException {\n        int r = nextBuildNumber++;\n        saveNextBuildNumber();\n        return r;\n    }\n\n    /**\n     * Peeks the next build number.\n     */\n    @Exported\n    public int getNextBuildNumber() {\n        return nextBuildNumber;\n    }\n\n    /**\n     * Builds up the environment variable map that's sufficient to identify a process\n     * as ours. This is used to kill run-away processes via {@link ProcessTree#killAll(Map)}.\n     */\n    public EnvVars getCharacteristicEnvVars() {\n        EnvVars env = new EnvVars();\n        env.put(\"JENKINS_SERVER_COOKIE\",Util.getDigestOf(\"ServerID:\"+ Jenkins.getInstance().getSecretKey()));\n        env.put(\"HUDSON_SERVER_COOKIE\",Util.getDigestOf(\"ServerID:\"+ Jenkins.getInstance().getSecretKey())); // Legacy compatibility\n        env.put(\"JOB_NAME\",getFullName());\n        return env;\n    }\n\n    /**\n     * Creates an environment variable override for launching processes for this project.\n     *\n     * <p>\n     * This is for process launching outside the build execution (such as polling, tagging, deployment, etc.)\n     * that happens in a context of a specific job.\n     *\n     * @param node\n     *      Node to eventually run a process on. The implementation must cope with this parameter being null\n     *      (in which case none of the node specific properties would be reflected in the resulting override.)\n     */\n    public EnvVars getEnvironment(Node node, TaskListener listener) throws IOException, InterruptedException {\n        EnvVars env;\n\n        if (node!=null)\n            env = node.toComputer().buildEnvironment(listener);\n        else\n            env = new EnvVars();\n\n        env.putAll(getCharacteristicEnvVars());\n\n        // servlet container may have set CLASSPATH in its launch script,\n        // so don't let that inherit to the new child process.\n        // see http://www.nabble.com/Run-Job-with-JDK-1.4.2-tf4468601.html\n        env.put(\"CLASSPATH\",\"\");\n\n        return env;\n    }\n\n    /**\n     * Programatically updates the next build number.\n     * \n     * <p>\n     * Much of Hudson assumes that the build number is unique and monotonic, so\n     * this method can only accept a new value that's bigger than\n     * {@link #getLastBuild()} returns. Otherwise it'll be no-op.\n     * \n     * @since 1.199 (before that, this method was package private.)\n     */\n    public synchronized void updateNextBuildNumber(int next) throws IOException {\n        RunT lb = getLastBuild();\n        if (lb!=null ?  next>lb.getNumber() : next>0) {\n            this.nextBuildNumber = next;\n            saveNextBuildNumber();\n        }\n    }\n\n    /**\n     * Returns the log rotator for this job, or null if none.\n     */\n    public LogRotator getLogRotator() {\n        return logRotator;\n    }\n\n    public void setLogRotator(LogRotator logRotator) {\n        this.logRotator = logRotator;\n    }\n\n    /**\n     * Perform log rotation.\n     */\n    public void logRotate() throws IOException, InterruptedException {\n        LogRotator lr = getLogRotator();\n        if (lr != null)\n            lr.perform(this);\n    }\n\n    /**\n     * True if this instance supports log rotation configuration.\n     */\n    public boolean supportsLogRotator() {\n        return true;\n    }\n\n    @Override\n    protected SearchIndexBuilder makeSearchIndex() {\n        return super.makeSearchIndex().add(new SearchIndex() {\n            public void find(String token, List<SearchItem> result) {\n                try {\n                    if (token.startsWith(\"#\"))\n                        token = token.substring(1); // ignore leading '#'\n                    int n = Integer.parseInt(token);\n                    Run b = getBuildByNumber(n);\n                    if (b == null)\n                        return; // no such build\n                    result.add(SearchItems.create(\"#\" + n, \"\" + n, b));\n                } catch (NumberFormatException e) {\n                    // not a number.\n                }\n            }\n\n            public void suggest(String token, List<SearchItem> result) {\n                find(token, result);\n            }\n        }).add(\"configure\", \"config\", \"configure\");\n    }\n\n    public Collection<? extends Job> getAllJobs() {\n        return Collections.<Job> singleton(this);\n    }\n\n    /**\n     * Adds {@link JobProperty}.\n     * \n     * @since 1.188\n     */\n    public void addProperty(JobProperty<? super JobT> jobProp) throws IOException {\n        ((JobProperty)jobProp).setOwner(this);\n        properties.add(jobProp);\n        save();\n    }\n\n    /**\n     * Removes {@link JobProperty}\n     *\n     * @since 1.279\n     */\n    public void removeProperty(JobProperty<? super JobT> jobProp) throws IOException {\n        properties.remove(jobProp);\n        save();\n    }\n\n    /**\n     * Removes the property of the given type.\n     *\n     * @return\n     *      The property that was just removed.\n     * @since 1.279\n     */\n    public <T extends JobProperty> T removeProperty(Class<T> clazz) throws IOException {\n        for (JobProperty<? super JobT> p : properties) {\n            if (clazz.isInstance(p)) {\n                removeProperty(p);\n                return clazz.cast(p);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets all the job properties configured for this job.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Map<JobPropertyDescriptor, JobProperty<? super JobT>> getProperties() {\n        return Descriptor.toMap((Iterable) properties);\n    }\n\n    /**\n     * List of all {@link JobProperty} exposed primarily for the remoting API.\n     * @since 1.282\n     */\n    @Exported(name=\"property\",inline=true)\n    public List<JobProperty<? super JobT>> getAllProperties() {\n        return properties.getView();\n    }\n\n    /**\n     * Gets the specific property, or null if the propert is not configured for\n     * this job.\n     */\n    public <T extends JobProperty> T getProperty(Class<T> clazz) {\n        for (JobProperty p : properties) {\n            if (clazz.isInstance(p))\n                return clazz.cast(p);\n        }\n        return null;\n    }\n\n    /**\n     * Bind {@link JobProperty}s to URL spaces.\n     *\n     * @since 1.403\n     */\n    public JobProperty getProperty(String className) {\n        for (JobProperty p : properties)\n            if (p.getClass().getName().equals(className))\n                return p;\n        return null;\n    }\n\n    /**\n     * Overrides from job properties.\n     * @see JobProperty#getJobOverrides\n     */\n    public Collection<?> getOverrides() {\n        List<Object> r = new ArrayList<Object>();\n        for (JobProperty<? super JobT> p : properties)\n            r.addAll(p.getJobOverrides());\n        return r;\n    }\n\n    public List<Widget> getWidgets() {\n        ArrayList<Widget> r = new ArrayList<Widget>();\n        r.add(createHistoryWidget());\n        return r;\n    }\n\n    protected HistoryWidget createHistoryWidget() {\n        return new HistoryWidget<Job, RunT>(this, getBuilds(), HISTORY_ADAPTER);\n    }\n\n    protected static final HistoryWidget.Adapter<Run> HISTORY_ADAPTER = new Adapter<Run>() {\n        public int compare(Run record, String key) {\n            try {\n                int k = Integer.parseInt(key);\n                return record.getNumber() - k;\n            } catch (NumberFormatException nfe) {\n                return String.valueOf(record.getNumber()).compareTo(key);\n            }\n        }\n\n        public String getKey(Run record) {\n            return String.valueOf(record.getNumber());\n        }\n\n        public boolean isBuilding(Run record) {\n            return record.isBuilding();\n        }\n\n        public String getNextKey(String key) {\n            try {\n                int k = Integer.parseInt(key);\n                return String.valueOf(k + 1);\n            } catch (NumberFormatException nfe) {\n                return \"-unable to determine next key-\";\n            }\n        }\n    };\n\n    /**\n     * Renames a job.\n     */\n    @Override\n    public void renameTo(String newName) throws IOException {\n        super.renameTo(newName);\n    }\n\n    /**\n     * Returns true if we should display \"build now\" icon\n     */\n    @Exported\n    public abstract boolean isBuildable();\n\n    /**\n     * Gets the read-only view of all the builds.\n     * \n     * @return never null. The first entry is the latest build.\n     */\n    @Exported(name=\"allBuilds\",visibility=-2)\n    @WithBridgeMethods(List.class)\n    public RunList<RunT> getBuilds() {\n        return RunList.fromRuns(_getRuns().values());\n    }\n\n    /**\n     * Gets the read-only view of the recent builds.\n     *\n     * @since 1.485\n     */\n    @Exported(name=\"builds\")\n    public RunList<RunT> getNewBuilds() {\n        return getBuilds().newBuilds();\n    }\n\n    /**\n     * Obtains all the {@link Run}s whose build numbers matches the given {@link RangeSet}.\n     */\n    public synchronized List<RunT> getBuilds(RangeSet rs) {\n        List<RunT> builds = new LinkedList<RunT>();\n\n        for (Range r : rs.getRanges()) {\n            for (RunT b = getNearestBuild(r.start); b!=null && b.getNumber()<r.end; b=b.getNextBuild()) {\n                builds.add(b);\n            }\n        }\n\n        return builds;\n    }\n\n    /**\n     * Gets all the builds in a map.\n     */\n    public SortedMap<Integer, RunT> getBuildsAsMap() {\n        return Collections.unmodifiableSortedMap(_getRuns());\n    }\n\n    /**\n     * @deprecated since 2008-06-15.\n     *     This is only used to support backward compatibility with old URLs.\n     */\n    @Deprecated\n    public RunT getBuild(String id) {\n        for (RunT r : _getRuns().values()) {\n            if (r.getId().equals(id))\n                return r;\n        }\n        return null;\n    }\n\n    /**\n     * @param n\n     *            The build number.\n     * @return null if no such build exists.\n     * @see Run#getNumber()\n     */\n    public RunT getBuildByNumber(int n) {\n        return _getRuns().get(n);\n    }\n\n    /**\n     * Obtains a list of builds, in the descending order, that are within the specified time range [start,end).\n     *\n     * @return can be empty but never null.\n     * @deprecated\n     *      as of 1.372. Should just do {@code getBuilds().byTimestamp(s,e)} to avoid code bloat in {@link Job}.\n     */\n    @WithBridgeMethods(List.class)\n    public RunList<RunT> getBuildsByTimestamp(long start, long end) {\n        return getBuilds().byTimestamp(start,end);\n    }\n\n    @CLIResolver\n    public RunT getBuildForCLI(@Argument(required=true,metaVar=\"BUILD#\",usage=\"Build number\") String id) throws CmdLineException {\n        try {\n            int n = Integer.parseInt(id);\n            RunT r = getBuildByNumber(n);\n            if (r==null)\n                throw new CmdLineException(null, \"No such build '#\"+n+\"' exists\");\n            return r;\n        } catch (NumberFormatException e) {\n            throw new CmdLineException(null, id+ \"is not a number\");\n        }\n    }\n\n    /**\n     * Gets the youngest build #m that satisfies <tt>n&lt;=m</tt>.\n     * \n     * This is useful when you'd like to fetch a build but the exact build might\n     * be already gone (deleted, rotated, etc.)\n     */\n    public RunT getNearestBuild(int n) {\n        SortedMap<Integer, ? extends RunT> m = _getRuns().headMap(n - 1); // the map should\n                                                                          // include n, so n-1\n        if (m.isEmpty())\n            return null;\n        return m.get(m.lastKey());\n    }\n\n    /**\n     * Gets the latest build #m that satisfies <tt>m&lt;=n</tt>.\n     * \n     * This is useful when you'd like to fetch a build but the exact build might\n     * be already gone (deleted, rotated, etc.)\n     */\n    public RunT getNearestOldBuild(int n) {\n        SortedMap<Integer, ? extends RunT> m = _getRuns().tailMap(n);\n        if (m.isEmpty())\n            return null;\n        return m.get(m.firstKey());\n    }\n\n    @Override\n    public Object getDynamic(String token, StaplerRequest req,\n            StaplerResponse rsp) {\n        try {\n            // try to interpret the token as build number\n            return getBuildByNumber(Integer.valueOf(token));\n        } catch (NumberFormatException e) {\n            // try to map that to widgets\n            for (Widget w : getWidgets()) {\n                if (w.getUrlName().equals(token))\n                    return w;\n            }\n\n            // is this a permalink?\n            for (Permalink p : getPermalinks()) {\n                if(p.getId().equals(token))\n                    return p.resolve(this);\n            }\n\n            return super.getDynamic(token, req, rsp);\n        }\n    }\n\n    /**\n     * Directory for storing {@link Run} records.\n     * <p>\n     * Some {@link Job}s may not have backing data store for {@link Run}s, but\n     * those {@link Job}s that use file system for storing data should use this\n     * directory for consistency.\n     * \n     * @see RunMap\n     */\n    protected File getBuildDir() {\n        return Jenkins.getInstance().getBuildDirFor(this);\n    }\n\n    /**\n     * Gets all the runs.\n     * \n     * The resulting map must be treated immutable (by employing copy-on-write\n     * semantics.) The map is descending order, with newest builds at the top.\n     */\n    protected abstract SortedMap<Integer, ? extends RunT> _getRuns();\n\n    /**\n     * Called from {@link Run} to remove it from this job.\n     * \n     * The files are deleted already. So all the callee needs to do is to remove\n     * a reference from this {@link Job}.\n     */\n    protected abstract void removeRun(RunT run);\n\n    /**\n     * Returns the last build.\n     */\n    @Exported\n    @QuickSilver\n    public RunT getLastBuild() {\n        SortedMap<Integer, ? extends RunT> runs = _getRuns();\n\n        if (runs.isEmpty())\n            return null;\n        return runs.get(runs.firstKey());\n    }\n\n    /**\n     * Returns the oldest build in the record.\n     */\n    @Exported\n    @QuickSilver\n    public RunT getFirstBuild() {\n        SortedMap<Integer, ? extends RunT> runs = _getRuns();\n\n        if (runs.isEmpty())\n            return null;\n        return runs.get(runs.lastKey());\n    }\n\n    /**\n     * Returns the last successful build, if any. Otherwise null. A successful build\n     * would include either {@link Result#SUCCESS} or {@link Result#UNSTABLE}.\n     * \n     * @see #getLastStableBuild()\n     */\n    @Exported\n    @QuickSilver\n    public RunT getLastSuccessfulBuild() {\n        RunT r = getLastBuild();\n        // temporary hack till we figure out what's causing this bug\n        while (r != null\n                && (r.isBuilding() || r.getResult() == null || r.getResult()\n                        .isWorseThan(Result.UNSTABLE)))\n            r = r.getPreviousBuild();\n        return r;\n    }\n\n    /**\n     * Returns the last build that was anything but stable, if any. Otherwise null.\n     * @see #getLastSuccessfulBuild\n     */\n    @Exported\n    @QuickSilver\n    public RunT getLastUnsuccessfulBuild() {\n        RunT r = getLastBuild();\n        while (r != null\n                && (r.isBuilding() || r.getResult() == Result.SUCCESS))\n            r = r.getPreviousBuild();\n        return r;\n    }\n\n    /**\n     * Returns the last unstable build, if any. Otherwise null.\n     * @see #getLastSuccessfulBuild\n     */\n    @Exported\n    @QuickSilver\n    public RunT getLastUnstableBuild() {\n        RunT r = getLastBuild();\n        while (r != null\n                && (r.isBuilding() || r.getResult() != Result.UNSTABLE))\n            r = r.getPreviousBuild();\n        return r;\n    }\n\n    /**\n     * Returns the last stable build, if any. Otherwise null.\n     * @see #getLastSuccessfulBuild\n     */\n    @Exported\n    @QuickSilver\n    public RunT getLastStableBuild() {\n        RunT r = getLastBuild();\n        while (r != null\n                && (r.isBuilding() || r.getResult().isWorseThan(Result.SUCCESS)))\n            r = r.getPreviousBuild();\n        return r;\n    }\n\n    /**\n     * Returns the last failed build, if any. Otherwise null.\n     */\n    @Exported\n    @QuickSilver\n    public RunT getLastFailedBuild() {\n        RunT r = getLastBuild();\n        while (r != null && (r.isBuilding() || r.getResult() != Result.FAILURE))\n            r = r.getPreviousBuild();\n        return r;\n    }\n\n    /**\n     * Returns the last completed build, if any. Otherwise null.\n     */\n    @Exported\n    @QuickSilver\n    public RunT getLastCompletedBuild() {\n        RunT r = getLastBuild();\n        while (r != null && r.isBuilding())\n            r = r.getPreviousBuild();\n        return r;\n    }\n    \n    /**\n     * Returns the last 'numberOfBuilds' builds with a build result >= 'threshold'\n     * \n     * @return a list with the builds. May be smaller than 'numberOfBuilds' or even empty\n     *   if not enough builds satisfying the threshold have been found. Never null.\n     */\n    public List<RunT> getLastBuildsOverThreshold(int numberOfBuilds, Result threshold) {\n        \n        List<RunT> result = new ArrayList<RunT>(numberOfBuilds);\n        \n        RunT r = getLastBuild();\n        while (r != null && result.size() < numberOfBuilds) {\n            if (!r.isBuilding() && \n                 (r.getResult() != null && r.getResult().isBetterOrEqualTo(threshold))) {\n                result.add(r);\n            }\n            r = r.getPreviousBuild();\n        }\n        \n        return result;\n    }\n    \n    public long getEstimatedDuration() {\n        List<RunT> builds = getLastBuildsOverThreshold(3, Result.UNSTABLE);\n        \n        if(builds.isEmpty())     return -1;\n\n        long totalDuration = 0;\n        for (RunT b : builds) {\n            totalDuration += b.getDuration();\n        }\n        if(totalDuration==0) return -1;\n\n        return Math.round((double)totalDuration / builds.size());\n    }\n\n    /**\n     * Gets all the {@link Permalink}s defined for this job.\n     *\n     * @return never null\n     */\n    public PermalinkList getPermalinks() {\n        // TODO: shall we cache this?\n        PermalinkList permalinks = new PermalinkList(Permalink.BUILTIN);\n        for (Action a : getActions()) {\n            if (a instanceof PermalinkProjectAction) {\n                PermalinkProjectAction ppa = (PermalinkProjectAction) a;\n                permalinks.addAll(ppa.getPermalinks());\n            }\n        }\n        return permalinks;\n    }\n\n    /**\n     * Used as the color of the status ball for the project.\n     */\n    @Exported(visibility = 2, name = \"color\")\n    public BallColor getIconColor() {\n        RunT lastBuild = getLastBuild();\n        while (lastBuild != null && lastBuild.hasntStartedYet())\n            lastBuild = lastBuild.getPreviousBuild();\n\n        if (lastBuild != null)\n            return lastBuild.getIconColor();\n        else\n            return BallColor.GREY;\n    }\n\n    /**\n     * Get the current health report for a job.\n     * \n     * @return the health report. Never returns null\n     */\n    public HealthReport getBuildHealth() {\n        List<HealthReport> reports = getBuildHealthReports();\n        return reports.isEmpty() ? new HealthReport() : reports.get(0);\n    }\n\n    @Exported(name = \"healthReport\")\n    public List<HealthReport> getBuildHealthReports() {\n        List<HealthReport> reports = new ArrayList<HealthReport>();\n        RunT lastBuild = getLastBuild();\n\n        if (lastBuild != null && lastBuild.isBuilding()) {\n            // show the previous build's report until the current one is\n            // finished building.\n            lastBuild = lastBuild.getPreviousBuild();\n        }\n\n        // check the cache\n        if (cachedBuildHealthReportsBuildNumber != null\n                && cachedBuildHealthReports != null\n                && lastBuild != null\n                && cachedBuildHealthReportsBuildNumber.intValue() == lastBuild\n                        .getNumber()) {\n            reports.addAll(cachedBuildHealthReports);\n        } else if (lastBuild != null) {\n            for (HealthReportingAction healthReportingAction : lastBuild\n                    .getActions(HealthReportingAction.class)) {\n                final HealthReport report = healthReportingAction\n                        .getBuildHealth();\n                if (report != null) {\n                    if (report.isAggregateReport()) {\n                        reports.addAll(report.getAggregatedReports());\n                    } else {\n                        reports.add(report);\n                    }\n                }\n            }\n            final HealthReport report = getBuildStabilityHealthReport();\n            if (report != null) {\n                if (report.isAggregateReport()) {\n                    reports.addAll(report.getAggregatedReports());\n                } else {\n                    reports.add(report);\n                }\n            }\n\n            Collections.sort(reports);\n\n            // store the cache\n            cachedBuildHealthReportsBuildNumber = lastBuild.getNumber();\n            cachedBuildHealthReports = new ArrayList<HealthReport>(reports);\n        }\n\n        return reports;\n    }\n\n    private HealthReport getBuildStabilityHealthReport() {\n        // we can give a simple view of build health from the last five builds\n        int failCount = 0;\n        int totalCount = 0;\n        RunT i = getLastBuild();\n        while (totalCount < 5 && i != null) {\n            switch (i.getIconColor()) {\n            case BLUE:\n            case YELLOW:\n                // failCount stays the same\n                totalCount++;\n                break;\n            case RED:\n                failCount++;\n                totalCount++;\n                break;\n\n            default:\n                // do nothing as these are inconclusive statuses\n                break;\n            }\n            i = i.getPreviousBuild();\n        }\n        if (totalCount > 0) {\n            int score = (int) ((100.0 * (totalCount - failCount)) / totalCount);\n\n            Localizable description;\n            if (failCount == 0) {\n                description = Messages._Job_NoRecentBuildFailed();\n            } else if (totalCount == failCount) {\n                // this should catch the case where totalCount == 1\n                // as failCount must be between 0 and totalCount\n                // and we can't get here if failCount == 0\n                description = Messages._Job_AllRecentBuildFailed();\n            } else {\n                description = Messages._Job_NOfMFailed(failCount, totalCount);\n            }\n            return new HealthReport(score, Messages._Job_BuildStability(description));\n        }\n        return null;\n    }\n\n    //\n    //\n    // actions\n    //\n    //\n    /**\n     * Accepts submission from the configuration page.\n     */\n    @RequirePOST\n    public synchronized void doConfigSubmit(StaplerRequest req,\n            StaplerResponse rsp) throws IOException, ServletException, FormException {\n        checkPermission(CONFIGURE);\n\n        description = req.getParameter(\"description\");\n\n        keepDependencies = req.getParameter(\"keepDependencies\") != null;\n\n        try {\n            JSONObject json = req.getSubmittedForm();\n\n            setDisplayName(json.optString(\"displayNameOrNull\"));\n\n            if (req.getParameter(\"logrotate\") != null)\n                logRotator = LogRotator.DESCRIPTOR.newInstance(req,json.getJSONObject(\"logrotate\"));\n            else\n                logRotator = null;\n\n            DescribableList<JobProperty<?>, JobPropertyDescriptor> t = new DescribableList<JobProperty<?>, JobPropertyDescriptor>(NOOP,getAllProperties());\n            t.rebuild(req,json.optJSONObject(\"properties\"),JobPropertyDescriptor.getPropertyDescriptors(Job.this.getClass()));\n            properties.clear();\n            for (JobProperty p : t) {\n                p.setOwner(this);\n                properties.add(p);\n            }\n\n            submit(req, rsp);\n\n            save();\n            ItemListener.fireOnUpdated(this);\n\n            String newName = req.getParameter(\"name\");\n            final ProjectNamingStrategy namingStrategy = Jenkins.getInstance().getProjectNamingStrategy();\n            if (newName != null && !newName.equals(name)) {\n                // check this error early to avoid HTTP response splitting.\n                Jenkins.checkGoodName(newName);\n                namingStrategy.checkName(newName);\n                rsp.sendRedirect(\"rename?newName=\" + URLEncoder.encode(newName, \"UTF-8\"));\n            } else {\n                if(namingStrategy.isForceExistingJobs()){\n                    namingStrategy.checkName(name);\n                }\n                FormApply.success(\".\").generateResponse(req, rsp, null);\n            }\n        } catch (JSONException e) {\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            pw.println(\"Failed to parse form data. Please report this problem as a bug\");\n            pw.println(\"JSON=\" + req.getSubmittedForm());\n            pw.println();\n            e.printStackTrace(pw);\n\n            rsp.setStatus(SC_BAD_REQUEST);\n            sendError(sw.toString(), req, rsp, true);\n        }\n    }\n\n    /**\n     * Derived class can override this to perform additional config submission\n     * work.\n     */\n    protected void submit(StaplerRequest req, StaplerResponse rsp)\n            throws IOException, ServletException, FormException {\n    }\n\n    /**\n     * Accepts and serves the job description\n     */\n    public void doDescription(StaplerRequest req, StaplerResponse rsp)\n            throws IOException {\n        if (req.getMethod().equals(\"GET\")) {\n            //read\n            rsp.setContentType(\"text/plain;charset=UTF-8\");\n            rsp.getWriter().write(Util.fixNull(this.getDescription()));\n            return;\n        }\n        if (req.getMethod().equals(\"POST\")) {\n            checkPermission(CONFIGURE);\n\n            // submission\n            if (req.getParameter(\"description\") != null) {\n                this.setDescription(req.getParameter(\"description\"));\n                rsp.sendError(SC_NO_CONTENT);\n                return;\n            }\n        }\n\n        // huh?\n        rsp.sendError(SC_BAD_REQUEST);\n    }\n\n    /**\n     * Returns the image that shows the current buildCommand status.\n     */\n    public void doBuildStatus(StaplerRequest req, StaplerResponse rsp)\n            throws IOException {\n        rsp.sendRedirect2(req.getContextPath() + \"/images/48x48/\" + getBuildStatusUrl());\n    }\n\n    public String getBuildStatusUrl() {\n        return getIconColor().getImage();\n    }\n\n    public Graph getBuildTimeGraph() {\n        return new Graph(getLastBuild().getTimestamp(),500,400) {\n            @Override\n            protected JFreeChart createGraph() {\n                class ChartLabel implements Comparable<ChartLabel> {\n                    final Run run;\n\n                    public ChartLabel(Run r) {\n                        this.run = r;\n                    }\n\n                    public int compareTo(ChartLabel that) {\n                        return this.run.number - that.run.number;\n                    }\n\n                    @Override\n                    public boolean equals(Object o) {\n                        // HUDSON-2682 workaround for Eclipse compilation bug\n                        // on (c instanceof ChartLabel)\n                        if (o == null || !ChartLabel.class.isAssignableFrom( o.getClass() ))  {\n                            return false;\n                        }\n                        ChartLabel that = (ChartLabel) o;\n                        return run == that.run;\n                    }\n\n                    public Color getColor() {\n                        // TODO: consider gradation. See\n                        // http://www.javadrive.jp/java2d/shape/index9.html\n                        Result r = run.getResult();\n                        if (r == Result.FAILURE)\n                            return ColorPalette.RED;\n                        else if (r == Result.UNSTABLE)\n                            return ColorPalette.YELLOW;\n                        else if (r == Result.ABORTED || r == Result.NOT_BUILT)\n                            return ColorPalette.GREY;\n                        else\n                            return ColorPalette.BLUE;\n                    }\n\n                    @Override\n                    public int hashCode() {\n                        return run.hashCode();\n                    }\n\n                    @Override\n                    public String toString() {\n                        String l = run.getDisplayName();\n                        if (run instanceof Build) {\n                            String s = ((Build) run).getBuiltOnStr();\n                            if (s != null)\n                                l += ' ' + s;\n                        }\n                        return l;\n                    }\n\n                }\n\n                DataSetBuilder<String, ChartLabel> data = new DataSetBuilder<String, ChartLabel>();\n                for (Run r : getBuilds()) {\n                    if (r.isBuilding())\n                        continue;\n                    data.add(((double) r.getDuration()) / (1000 * 60), \"min\",\n                            new ChartLabel(r));\n                }\n\n                final CategoryDataset dataset = data.build();\n\n                final JFreeChart chart = ChartFactory.createStackedAreaChart(null, // chart\n                                                                                    // title\n                        null, // unused\n                        Messages.Job_minutes(), // range axis label\n                        dataset, // data\n                        PlotOrientation.VERTICAL, // orientation\n                        false, // include legend\n                        true, // tooltips\n                        false // urls\n                        );\n\n                chart.setBackgroundPaint(Color.white);\n\n                final CategoryPlot plot = chart.getCategoryPlot();\n\n                // plot.setAxisOffset(new Spacer(Spacer.ABSOLUTE, 5.0, 5.0, 5.0, 5.0));\n                plot.setBackgroundPaint(Color.WHITE);\n                plot.setOutlinePaint(null);\n                plot.setForegroundAlpha(0.8f);\n                // plot.setDomainGridlinesVisible(true);\n                // plot.setDomainGridlinePaint(Color.white);\n                plot.setRangeGridlinesVisible(true);\n                plot.setRangeGridlinePaint(Color.black);\n\n                CategoryAxis domainAxis = new ShiftedCategoryAxis(null);\n                plot.setDomainAxis(domainAxis);\n                domainAxis.setCategoryLabelPositions(CategoryLabelPositions.UP_90);\n                domainAxis.setLowerMargin(0.0);\n                domainAxis.setUpperMargin(0.0);\n                domainAxis.setCategoryMargin(0.0);\n\n                final NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis();\n                ChartUtil.adjustChebyshev(dataset, rangeAxis);\n                rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());\n\n                StackedAreaRenderer ar = new StackedAreaRenderer2() {\n                    @Override\n                    public Paint getItemPaint(int row, int column) {\n                        ChartLabel key = (ChartLabel) dataset.getColumnKey(column);\n                        return key.getColor();\n                    }\n\n                    @Override\n                    public String generateURL(CategoryDataset dataset, int row,\n                            int column) {\n                        ChartLabel label = (ChartLabel) dataset.getColumnKey(column);\n                        return String.valueOf(label.run.number);\n                    }\n\n                    @Override\n                    public String generateToolTip(CategoryDataset dataset, int row,\n                            int column) {\n                        ChartLabel label = (ChartLabel) dataset.getColumnKey(column);\n                        return label.run.getDisplayName() + \" : \"\n                                + label.run.getDurationString();\n                    }\n                };\n                plot.setRenderer(ar);\n\n                // crop extra space around the graph\n                plot.setInsets(new RectangleInsets(0, 0, 0, 5.0));\n\n                return chart;\n            }\n        };\n    }\n\n    /**\n     * Renames this job.\n     */\n    @RequirePOST\n    public/* not synchronized. see renameTo() */void doDoRename(\n            StaplerRequest req, StaplerResponse rsp) throws IOException,\n            ServletException {\n\n        if (!hasPermission(CONFIGURE)) {\n            // rename is essentially delete followed by a create\n            checkPermission(CREATE);\n            checkPermission(DELETE);\n        }\n\n        String newName = req.getParameter(\"newName\");\n        Jenkins.checkGoodName(newName);\n\n        if (isBuilding()) {\n            // redirect to page explaining that we can't rename now\n            rsp.sendRedirect(\"rename?newName=\" + URLEncoder.encode(newName, \"UTF-8\"));\n            return;\n        }\n\n        renameTo(newName);\n        // send to the new job page\n        // note we can't use getUrl() because that would pick up old name in the\n        // Ancestor.getUrl()\n        rsp.sendRedirect2(\"../\" + newName);\n    }\n\n    public void doRssAll(StaplerRequest req, StaplerResponse rsp)\n            throws IOException, ServletException {\n        rss(req, rsp, \" all builds\", getBuilds());\n    }\n\n    public void doRssFailed(StaplerRequest req, StaplerResponse rsp)\n            throws IOException, ServletException {\n        rss(req, rsp, \" failed builds\", getBuilds().failureOnly());\n    }\n\n    private void rss(StaplerRequest req, StaplerResponse rsp, String suffix,\n            RunList runs) throws IOException, ServletException {\n        RSS.forwardToRss(getDisplayName() + suffix, getUrl(), runs.newBuilds(),\n                Run.FEED_ADAPTER, req, rsp);\n    }\n\n    /**\n     * Returns the {@link ACL} for this object.\n     * We need to override the identical method in AbstractItem because we won't\n     * call getACL(Job) otherwise (single dispatch)\n     */\n    @Override\n    public ACL getACL() {\n        return Jenkins.getInstance().getAuthorizationStrategy().getACL(this);\n    }\n\n    public BuildTimelineWidget getTimeline() {\n        return new BuildTimelineWidget(getBuilds());\n    }\n}\n", "target": 1}
{"idx": 993, "func": "/**\n * Copyright (c) 2000-2012 Liferay, Inc. All rights reserved.\n *\n * This library is free software; you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation; either version 2.1 of the License, or (at your option)\n * any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n */\n\npackage com.liferay.portal.freemarker;\n\nimport com.liferay.portal.kernel.template.TemplateException;\nimport com.liferay.portal.security.lang.PortalSecurityManagerThreadLocal;\nimport com.liferay.portal.security.pacl.PACLPolicy;\nimport com.liferay.portal.template.TemplateContextHelper;\n\nimport freemarker.template.Configuration;\n\nimport java.io.Writer;\n\nimport java.util.Map;\n\n/**\n * @author Raymond Aug\n */\npublic class PACLFreeMarkerTemplate extends FreeMarkerTemplate {\n\n\tpublic PACLFreeMarkerTemplate(\n\t\tString templateId, String templateContent, String errorTemplateId,\n\t\tString errorTemplateContent, Map<String, Object> context,\n\t\tConfiguration configuration,\n\t\tTemplateContextHelper templateContextHelper,\n\t\tStringTemplateLoader stringTemplateLoader, PACLPolicy paclPolicy) {\n\n\t\tsuper(\n\t\t\ttemplateId, templateContent, errorTemplateId, errorTemplateContent,\n\t\t\tcontext, configuration, templateContextHelper,\n\t\t\tstringTemplateLoader);\n\n\t\t_paclPolicy = paclPolicy;\n\t}\n\n\t@Override\n\tpublic boolean processTemplate(Writer writer) throws TemplateException {\n\t\tPACLPolicy initialPolicy =\n\t\t\tPortalSecurityManagerThreadLocal.getPACLPolicy();\n\n\t\ttry {\n\t\t\tPortalSecurityManagerThreadLocal.setPACLPolicy(_paclPolicy);\n\n\t\t\treturn super.processTemplate(writer);\n\t\t}\n\t\tfinally {\n\t\t\tPortalSecurityManagerThreadLocal.setPACLPolicy(initialPolicy);\n\t\t}\n\t}\n\n\tprivate PACLPolicy _paclPolicy;\n\n}", "target": 0}
{"idx": 994, "func": "/*\n * Copyright 2013-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.jpa.domain;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.persistence.metamodel.Attribute;\nimport javax.persistence.metamodel.PluralAttribute;\n\nimport org.springframework.data.domain.Sort;\nimport org.springframework.util.Assert;\n\n/**\n * Sort option for queries that wraps JPA meta-model {@link Attribute}s for sorting.\n * \n * @author Thomas Darimont\n * @author Oliver Gierke\n */\npublic class JpaSort extends Sort {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * Creates a new {@link JpaSort} for the given attributes with the default sort direction.\n\t * \n\t * @param attributes must not be {@literal null} or empty.\n\t */\n\tpublic JpaSort(Attribute<?, ?>... attributes) {\n\t\tthis(DEFAULT_DIRECTION, attributes);\n\t}\n\n\t/**\n\t * Creates a new {@link JpaSort} instance with the given {@link Path}s.\n\t * \n\t * @param paths must not be {@literal null} or empty.\n\t */\n\tpublic JpaSort(JpaSort.Path<?, ?>... paths) {\n\t\tthis(DEFAULT_DIRECTION, paths);\n\t}\n\n\t/**\n\t * Creates a new {@link JpaSort} for the given direction and attributes.\n\t * \n\t * @param direction the sorting direction.\n\t * @param attributes must not be {@literal null} or empty.\n\t */\n\tpublic JpaSort(Direction direction, Attribute<?, ?>... attributes) {\n\t\tthis(direction, paths(attributes));\n\t}\n\n\t/**\n\t * Creates a new {@link JpaSort} for the given direction and {@link Path}s.\n\t * \n\t * @param direction the sorting direction.\n\t * @param paths must not be {@literal null} or empty.\n\t */\n\tpublic JpaSort(Direction direction, Path<?, ?>... paths) {\n\t\tthis(direction, Arrays.asList(paths));\n\t}\n\n\tprivate JpaSort(Direction direction, List<Path<?, ?>> paths) {\n\t\tthis(Collections.<Order> emptyList(), direction, paths);\n\t}\n\n\tprivate JpaSort(List<Order> orders, Direction direction, List<Path<?, ?>> paths) {\n\t\tsuper(combine(orders, direction, paths));\n\t}\n\n\t/**\n\t * Returns a new {@link JpaSort} with the given sorting criteria added to the current one.\n\t * \n\t * @param direction can be {@literal null}.\n\t * @param attributes must not be {@literal null}.\n\t * @return\n\t */\n\tpublic JpaSort and(Direction direction, Attribute<?, ?>... attributes) {\n\n\t\tAssert.notNull(attributes, \"Attributes must not be null!\");\n\n\t\treturn and(direction, paths(attributes));\n\t}\n\n\t/**\n\t * Returns a new {@link JpaSort} with the given sorting criteria added to the current one.\n\t * \n\t * @param direction can be {@literal null}.\n\t * @param paths must not be {@literal null}.\n\t * @return\n\t */\n\tpublic JpaSort and(Direction direction, Path<?, ?>... paths) {\n\n\t\tAssert.notNull(paths, \"Paths must not be null!\");\n\n\t\tList<Order> existing = new ArrayList<Order>();\n\n\t\tfor (Order order : this) {\n\t\t\texisting.add(order);\n\t\t}\n\n\t\treturn new JpaSort(existing, direction, Arrays.asList(paths));\n\t}\n\n\t/**\n\t * Turns the given {@link Attribute}s into {@link Path}s.\n\t * \n\t * @param attributes must not be {@literal null} or empty.\n\t * @return\n\t */\n\tprivate static Path<?, ?>[] paths(Attribute<?, ?>[] attributes) {\n\n\t\tAssert.notNull(attributes, \"Attributes must not be null!\");\n\t\tAssert.isTrue(attributes.length > 0, \"Attributes must not be empty\");\n\n\t\tPath<?, ?>[] paths = new Path[attributes.length];\n\n\t\tfor (int i = 0; i < attributes.length; i++) {\n\t\t\tpaths[i] = path(attributes[i]);\n\t\t}\n\n\t\treturn paths;\n\t}\n\n\tprivate static List<Order> combine(List<Order> orders, Direction direction, List<Path<?, ?>> paths) {\n\n\t\tList<Order> result = new ArrayList<Sort.Order>(orders);\n\n\t\tfor (Path<?, ?> path : paths) {\n\t\t\tresult.add(new Order(direction, path.toString()));\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates a new {@link Path} for the given {@link Attribute}.\n\t * \n\t * @param attribute must not be {@literal null}.\n\t * @return\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <A extends Attribute<T, S>, T, S> Path<T, S> path(A attribute) {\n\n\t\tAssert.notNull(attribute, \"Attribute must not be null!\");\n\t\treturn new Path<T, S>(Arrays.asList(attribute));\n\t}\n\n\t/**\n\t * Creates a new {@link Path} for the given {@link PluralAttribute}.\n\t * \n\t * @param attribute must not be {@literal null}.\n\t * @return\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <P extends PluralAttribute<T, ?, S>, T, S> Path<T, S> path(P attribute) {\n\n\t\tAssert.notNull(attribute, \"Attribute must not be null!\");\n\t\treturn new Path<T, S>(Arrays.asList(attribute));\n\t}\n\n\t/**\n\t * Value object to abstract a collection of {@link Attribute}s.\n\t * \n\t * @author Oliver Gierke\n\t */\n\tpublic static class Path<T, S> {\n\n\t\tprivate final Collection<Attribute<?, ?>> attributes;\n\n\t\tprivate Path(List<? extends Attribute<?, ?>> attributes) {\n\t\t\tthis.attributes = Collections.unmodifiableList(attributes);\n\t\t}\n\n\t\t/**\n\t\t * Collects the given {@link Attribute} and returning a new {@link Path} pointing to the attribute type.\n\t\t * \n\t\t * @param attribute must not be {@literal null}.\n\t\t * @return\n\t\t */\n\t\tpublic <A extends Attribute<S, U>, U> Path<S, U> dot(A attribute) {\n\t\t\treturn new Path<S, U>(add(attribute));\n\t\t}\n\n\t\t/**\n\t\t * Collects the given {@link PluralAttribute} and returning a new {@link Path} pointing to the attribute type.\n\t\t * \n\t\t * @param attribute must not be {@literal null}.\n\t\t * @return\n\t\t */\n\t\tpublic <P extends PluralAttribute<S, ?, U>, U> Path<S, U> dot(P attribute) {\n\t\t\treturn new Path<S, U>(add(attribute));\n\t\t}\n\n\t\tprivate List<Attribute<?, ?>> add(Attribute<?, ?> attribute) {\n\n\t\t\tAssert.notNull(attribute, \"Attribute must not be null!\");\n\n\t\t\tList<Attribute<?, ?>> newAttributes = new ArrayList<Attribute<?, ?>>(attributes.size() + 1);\n\t\t\tnewAttributes.addAll(attributes);\n\t\t\tnewAttributes.add(attribute);\n\t\t\treturn newAttributes;\n\t\t}\n\n\t\t/*\n\t\t * (non-Javadoc)\n\t\t * @see java.lang.Object#toString()\n\t\t */\n\t\t@Override\n\t\tpublic String toString() {\n\n\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\tfor (Attribute<?, ?> attribute : attributes) {\n\t\t\t\tbuilder.append(attribute.getName()).append(\".\");\n\t\t\t}\n\n\t\t\treturn builder.length() == 0 ? \"\" : builder.substring(0, builder.lastIndexOf(\".\"));\n\t\t}\n\t}\n}\n", "target": 1}
{"idx": 995, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi, David Calavera, Seiji Sogabe\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.security;\n\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport hudson.Extension;\nimport hudson.Util;\nimport hudson.diagnosis.OldDataMonitor;\nimport hudson.model.Descriptor;\nimport jenkins.model.Jenkins;\nimport hudson.model.ManagementLink;\nimport hudson.model.ModelObject;\nimport hudson.model.User;\nimport hudson.model.UserProperty;\nimport hudson.model.UserPropertyDescriptor;\nimport hudson.security.FederatedLoginService.FederatedIdentity;\nimport hudson.security.captcha.CaptchaSupport;\nimport hudson.util.PluginServletFilter;\nimport hudson.util.Protector;\nimport hudson.util.Scrambler;\nimport hudson.util.XStream2;\nimport net.sf.json.JSONObject;\nimport org.acegisecurity.Authentication;\nimport org.acegisecurity.AuthenticationException;\nimport org.acegisecurity.BadCredentialsException;\nimport org.acegisecurity.GrantedAuthority;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.acegisecurity.providers.UsernamePasswordAuthenticationToken;\nimport org.acegisecurity.providers.encoding.PasswordEncoder;\nimport org.acegisecurity.providers.encoding.ShaPasswordEncoder;\nimport org.acegisecurity.userdetails.UserDetails;\nimport org.acegisecurity.userdetails.UsernameNotFoundException;\nimport org.apache.tools.ant.taskdefs.email.Mailer;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.ForwardToView;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.mindrot.jbcrypt.BCrypt;\nimport org.springframework.dao.DataAccessException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport static javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED;\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.security.SecureRandom;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * {@link SecurityRealm} that performs authentication by looking up {@link User}.\n *\n * <p>\n * Implements {@link AccessControlled} to satisfy view rendering, but in reality the access control\n * is done against the {@link jenkins.model.Jenkins} object.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class HudsonPrivateSecurityRealm extends AbstractPasswordBasedSecurityRealm implements ModelObject, AccessControlled {\n    /**\n     * If true, sign up is not allowed.\n     * <p>\n     * This is a negative switch so that the default value 'false' remains compatible with older installations. \n     */\n    private final boolean disableSignup;\n\n    /**\n     * If true, captcha will be enabled.\n     */\n    private final boolean enableCaptcha;\n\n    @Deprecated\n    public HudsonPrivateSecurityRealm(boolean allowsSignup) {\n        this(allowsSignup, false, (CaptchaSupport) null);\n    }\n\n    @DataBoundConstructor\n    public HudsonPrivateSecurityRealm(boolean allowsSignup, boolean enableCaptcha, CaptchaSupport captchaSupport) {\n        this.disableSignup = !allowsSignup;\n        this.enableCaptcha = enableCaptcha;\n        setCaptchaSupport(captchaSupport);\n        if(!allowsSignup && !hasSomeUser()) {\n            // if Hudson is newly set up with the security realm and there's no user account created yet,\n            // insert a filter that asks the user to create one\n            try {\n                PluginServletFilter.addFilter(CREATE_FIRST_USER_FILTER);\n            } catch (ServletException e) {\n                throw new AssertionError(e); // never happen because our Filter.init is no-op\n            }\n        }\n    }\n\n    @Override\n    public boolean allowsSignup() {\n        return !disableSignup;\n    }\n\n    /**\n     * Checks if captcha is enabled on user signup.\n     *\n     * @return true if captcha is enabled on signup.\n     */\n    public boolean isEnableCaptcha() {\n        return enableCaptcha;\n    }\n\n    /**\n     * Computes if this Hudson has some user accounts configured.\n     *\n     * <p>\n     * This is used to check for the initial\n     */\n    private static boolean hasSomeUser() {\n        for (User u : User.getAll())\n            if(u.getProperty(Details.class)!=null)\n                return true;\n        return false;\n    }\n\n    /**\n     * This implementation doesn't support groups.\n     */\n    @Override\n    public GroupDetails loadGroupByGroupname(String groupname) throws UsernameNotFoundException, DataAccessException {\n        throw new UsernameNotFoundException(groupname);\n    }\n\n    @Override\n    public Details loadUserByUsername(String username) throws UsernameNotFoundException, DataAccessException {\n        User u = User.get(username,false);\n        Details p = u!=null ? u.getProperty(Details.class) : null;\n        if(p==null)\n            throw new UsernameNotFoundException(\"Password is not set: \"+username);\n        if(p.getUser()==null)\n            throw new AssertionError();\n        return p;\n    }\n\n    @Override\n    protected Details authenticate(String username, String password) throws AuthenticationException {\n        Details u = loadUserByUsername(username);\n        if (!u.isPasswordCorrect(password))\n            throw new BadCredentialsException(\"Failed to login as \"+username);\n        return u;\n    }\n\n    /**\n     * Show the sign up page with the data from the identity.\n     */\n    @Override\n    public HttpResponse commenceSignup(final FederatedIdentity identity) {\n        // store the identity in the session so that we can use this later\n        Stapler.getCurrentRequest().getSession().setAttribute(FEDERATED_IDENTITY_SESSION_KEY,identity);\n        return new ForwardToView(this,\"signupWithFederatedIdentity.jelly\") {\n            @Override\n            public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {\n                SignupInfo si = new SignupInfo(identity);\n                si.errorMessage = Messages.HudsonPrivateSecurityRealm_WouldYouLikeToSignUp(identity.getPronoun(),identity.getIdentifier());\n                req.setAttribute(\"data\", si);\n                super.generateResponse(req, rsp, node);\n            }\n        };\n    }\n\n    /**\n     * Creates an account and associates that with the given identity. Used in conjunction\n     * with {@link #commenceSignup(FederatedIdentity)}.\n     */\n    public User doCreateAccountWithFederatedIdentity(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        User u = _doCreateAccount(req,rsp,\"signupWithFederatedIdentity.jelly\");\n        if (u!=null)\n            ((FederatedIdentity)req.getSession().getAttribute(FEDERATED_IDENTITY_SESSION_KEY)).addTo(u);\n        return u;\n    }\n\n    private static final String FEDERATED_IDENTITY_SESSION_KEY = HudsonPrivateSecurityRealm.class.getName()+\".federatedIdentity\";\n\n    /**\n     * Creates an user account. Used for self-registration.\n     */\n    public User doCreateAccount(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        return _doCreateAccount(req, rsp, \"signup.jelly\");\n    }\n\n    private User _doCreateAccount(StaplerRequest req, StaplerResponse rsp, String formView) throws ServletException, IOException {\n        if(!allowsSignup())\n            throw HttpResponses.error(SC_UNAUTHORIZED,new Exception(\"User sign up is prohibited\"));\n\n        boolean firstUser = !hasSomeUser();\n        User u = createAccount(req, rsp, enableCaptcha, formView);\n        if(u!=null) {\n            if(firstUser)\n                tryToMakeAdmin(u);  // the first user should be admin, or else there's a risk of lock out\n            loginAndTakeBack(req, rsp, u);\n        }\n        return u;\n    }\n\n    /**\n     * Lets the current user silently login as the given user and report back accordingly.\n     */\n    private void loginAndTakeBack(StaplerRequest req, StaplerResponse rsp, User u) throws ServletException, IOException {\n        // ... and let him login\n        Authentication a = new UsernamePasswordAuthenticationToken(u.getId(),req.getParameter(\"password1\"));\n        a = this.getSecurityComponents().manager.authenticate(a);\n        SecurityContextHolder.getContext().setAuthentication(a);\n\n        // then back to top\n        req.getView(this,\"success.jelly\").forward(req,rsp);\n    }\n\n    /**\n     * Creates an user account. Used by admins.\n     *\n     * This version behaves differently from {@link #doCreateAccount(StaplerRequest, StaplerResponse)} in that\n     * this is someone creating another user.\n     */\n    public void doCreateAccountByAdmin(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(Jenkins.ADMINISTER);\n        if(createAccount(req, rsp, false, \"addUser.jelly\")!=null) {\n            rsp.sendRedirect(\".\");  // send the user back to the listing page\n        }\n    }\n\n    /**\n     * Creates a first admin user account.\n     *\n     * <p>\n     * This can be run by anyone, but only to create the very first user account.\n     */\n    public void doCreateFirstAccount(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        if(hasSomeUser()) {\n            rsp.sendError(SC_UNAUTHORIZED,\"First user was already created\");\n            return;\n        }\n        User u = createAccount(req, rsp, false, \"firstUser.jelly\");\n        if (u!=null) {\n            tryToMakeAdmin(u);\n            loginAndTakeBack(req, rsp, u);\n        }\n    }\n\n    /**\n     * Try to make this user a super-user\n     */\n    private void tryToMakeAdmin(User u) {\n        AuthorizationStrategy as = Jenkins.getInstance().getAuthorizationStrategy();\n        if (as instanceof GlobalMatrixAuthorizationStrategy) {\n            GlobalMatrixAuthorizationStrategy ma = (GlobalMatrixAuthorizationStrategy) as;\n            ma.add(Jenkins.ADMINISTER,u.getId());\n        }\n    }\n\n    /**\n     * @return\n     *      null if failed. The browser is already redirected to retry by the time this method returns.\n     *      a valid {@link User} object if the user creation was successful.\n     */\n    private User createAccount(StaplerRequest req, StaplerResponse rsp, boolean selfRegistration, String formView) throws ServletException, IOException {\n        // form field validation\n        // this pattern needs to be generalized and moved to stapler\n        SignupInfo si = new SignupInfo(req);\n\n        if(selfRegistration && !validateCaptcha(si.captcha))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage();\n\n        if(si.password1 != null && !si.password1.equals(si.password2))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch();\n\n        if(!(si.password1 != null && si.password1.length() != 0))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired();\n\n        if(si.username==null || si.username.length()==0)\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired();\n        else {\n            User user = User.get(si.username, false);\n            if (null != user)\n                si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken();\n        }\n\n        if(si.fullname==null || si.fullname.length()==0)\n            si.fullname = si.username;\n\n        if(si.email==null || !si.email.contains(\"@\"))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress();\n\n        if(si.errorMessage!=null) {\n            // failed. ask the user to try again.\n            req.setAttribute(\"data\",si);\n            req.getView(this, formView).forward(req,rsp);\n            return null;\n        }\n\n        // register the user\n        User user = createAccount(si.username,si.password1);\n        user.setFullName(si.fullname);\n        try {\n            // legacy hack. mail support has moved out to a separate plugin\n            Class<?> up = Jenkins.getInstance().pluginManager.uberClassLoader.loadClass(\"hudson.tasks.Mailer$UserProperty\");\n            Constructor<?> c = up.getDeclaredConstructor(String.class);\n            user.addProperty((UserProperty)c.newInstance(si.email));\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            LOGGER.log(Level.WARNING, \"Failed to set the e-mail address\",e);\n        }\n        user.save();\n        return user;\n    }\n\n    /**\n     * Creates a new user account by registering a password to the user.\n     */\n    public User createAccount(String userName, String password) throws IOException {\n        User user = User.get(userName);\n        user.addProperty(Details.fromPlainPassword(password));\n        return user;\n    }\n\n    /**\n     * This is used primarily when the object is listed in the breadcrumb, in the user management screen.\n     */\n    public String getDisplayName() {\n        return \"User Database\";\n    }\n\n    public ACL getACL() {\n        return Jenkins.getInstance().getACL();\n    }\n\n    public void checkPermission(Permission permission) {\n        Jenkins.getInstance().checkPermission(permission);\n    }\n\n    public boolean hasPermission(Permission permission) {\n        return Jenkins.getInstance().hasPermission(permission);\n    }\n\n\n    /**\n     * All users who can login to the system.\n     */\n    public List<User> getAllUsers() {\n        List<User> r = new ArrayList<User>();\n        for (User u : User.getAll()) {\n            if(u.getProperty(Details.class)!=null)\n                r.add(u);\n        }\n        Collections.sort(r);\n        return r;\n    }\n\n    /**\n     * This is to map users under the security realm URL.\n     * This in turn helps us set up the right navigation breadcrumb.\n     */\n    public User getUser(String id) {\n        return User.get(id);\n    }\n\n    // TODO\n    private static final GrantedAuthority[] TEST_AUTHORITY = {AUTHENTICATED_AUTHORITY};\n\n    public static final class SignupInfo {\n        public String username,password1,password2,fullname,email,captcha;\n\n        /**\n         * To display an error message, set it here.\n         */\n        public String errorMessage;\n\n        public SignupInfo() {\n        }\n\n        public SignupInfo(StaplerRequest req) {\n            req.bindParameters(this);\n        }\n\n        public SignupInfo(FederatedIdentity i) {\n            this.username = i.getNickname();\n            this.fullname = i.getFullName();\n            this.email = i.getEmailAddress();\n        }\n    }\n\n    /**\n     * {@link UserProperty} that provides the {@link UserDetails} view of the User object.\n     *\n     * <p>\n     * When a {@link User} object has this property on it, it means the user is configured\n     * for log-in.\n     *\n     * <p>\n     * When a {@link User} object is re-configured via the UI, the password\n     * is sent to the hidden input field by using {@link Protector}, so that\n     * the same password can be retained but without leaking information to the browser.\n     */\n    public static final class Details extends UserProperty implements InvalidatableUserDetails {\n        /**\n         * Hashed password.\n         */\n        private /*almost final*/ String passwordHash;\n\n        /**\n         * @deprecated Scrambled password.\n         * Field kept here to load old (pre 1.283) user records,\n         * but now marked transient so field is no longer saved.\n         */\n        private transient String password;\n\n        private Details(String passwordHash) {\n            this.passwordHash = passwordHash;\n        }\n\n        static Details fromHashedPassword(String hashed) {\n            return new Details(hashed);\n        }\n\n        static Details fromPlainPassword(String rawPassword) {\n            return new Details(PASSWORD_ENCODER.encodePassword(rawPassword,null));\n        }\n\n        public GrantedAuthority[] getAuthorities() {\n            // TODO\n            return TEST_AUTHORITY;\n        }\n\n        public String getPassword() {\n            return passwordHash;\n        }\n\n        public boolean isPasswordCorrect(String candidate) {\n            return PASSWORD_ENCODER.isPasswordValid(getPassword(),candidate,null);\n        }\n\n        public String getProtectedPassword() {\n            // put session Id in it to prevent a replay attack.\n            return Protector.protect(Stapler.getCurrentRequest().getSession().getId()+':'+getPassword());\n        }\n\n        public String getUsername() {\n            return user.getId();\n        }\n\n        /*package*/ User getUser() {\n            return user;\n        }\n\n        public boolean isAccountNonExpired() {\n            return true;\n        }\n\n        public boolean isAccountNonLocked() {\n            return true;\n        }\n\n        public boolean isCredentialsNonExpired() {\n            return true;\n        }\n\n        public boolean isEnabled() {\n            return true;\n        }\n\n        public boolean isInvalid() {\n            return user==null;\n        }\n\n        public static class ConverterImpl extends XStream2.PassthruConverter<Details> {\n            public ConverterImpl(XStream2 xstream) { super(xstream); }\n            @Override protected void callback(Details d, UnmarshallingContext context) {\n                // Convert to hashed password and report to monitor if we load old data\n                if (d.password!=null && d.passwordHash==null) {\n                    d.passwordHash = PASSWORD_ENCODER.encodePassword(Scrambler.descramble(d.password),null);\n                    OldDataMonitor.report(context, \"1.283\");\n                }\n            }\n        }\n\n        @Extension\n        public static final class DescriptorImpl extends UserPropertyDescriptor {\n            public String getDisplayName() {\n                // this feature is only when HudsonPrivateSecurityRealm is enabled\n                if(isEnabled())\n                    return Messages.HudsonPrivateSecurityRealm_Details_DisplayName();\n                else\n                    return null;\n            }\n\n            @Override\n            public Details newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n                String pwd = Util.fixEmpty(req.getParameter(\"user.password\"));\n                String pwd2= Util.fixEmpty(req.getParameter(\"user.password2\"));\n\n                if(!Util.fixNull(pwd).equals(Util.fixNull(pwd2)))\n                    throw new FormException(\"Please confirm the password by typing it twice\",\"user.password2\");\n\n                String data = Protector.unprotect(pwd);\n                if(data!=null) {\n                    String prefix = Stapler.getCurrentRequest().getSession().getId() + ':';\n                    if(data.startsWith(prefix))\n                        return Details.fromHashedPassword(data.substring(prefix.length()));\n                }\n                return Details.fromPlainPassword(Util.fixNull(pwd));\n            }\n\n            @Override\n            public boolean isEnabled() {\n                return Jenkins.getInstance().getSecurityRealm() instanceof HudsonPrivateSecurityRealm;\n            }\n\n            public UserProperty newInstance(User user) {\n                return null;\n            }\n        }\n    }\n\n    /**\n     * Displays \"manage users\" link in the system config if {@link HudsonPrivateSecurityRealm}\n     * is in effect.\n     */\n    @Extension\n    public static final class ManageUserLinks extends ManagementLink {\n        public String getIconFileName() {\n            if(Jenkins.getInstance().getSecurityRealm() instanceof HudsonPrivateSecurityRealm)\n                return \"user.png\";\n            else\n                return null;    // not applicable now\n        }\n\n        public String getUrlName() {\n            return \"securityRealm/\";\n        }\n\n        public String getDisplayName() {\n            return Messages.HudsonPrivateSecurityRealm_ManageUserLinks_DisplayName();\n        }\n\n        @Override\n        public String getDescription() {\n            return Messages.HudsonPrivateSecurityRealm_ManageUserLinks_Description();\n        }\n    }\n\n    /**\n     * {@link PasswordEncoder} based on SHA-256 and random salt generation.\n     *\n     * <p>\n     * The salt is prepended to the hashed password and returned. So the encoded password is of the form\n     * <tt>SALT ':' hash(PASSWORD,SALT)</tt>.\n     *\n     * <p>\n     * This abbreviates the need to store the salt separately, which in turn allows us to hide the salt handling\n     * in this little class. The rest of the Acegi thinks that we are not using salt.\n     */\n    /*package*/ static final PasswordEncoder CLASSIC = new PasswordEncoder() {\n        private final PasswordEncoder passwordEncoder = new ShaPasswordEncoder(256);\n\n        public String encodePassword(String rawPass, Object _) throws DataAccessException {\n            return hash(rawPass);\n        }\n\n        public boolean isPasswordValid(String encPass, String rawPass, Object _) throws DataAccessException {\n            // pull out the sale from the encoded password\n            int i = encPass.indexOf(':');\n            if(i<0) return false;\n            String salt = encPass.substring(0,i);\n            return encPass.substring(i+1).equals(passwordEncoder.encodePassword(rawPass,salt));\n        }\n\n        /**\n         * Creates a hashed password by generating a random salt.\n         */\n        private String hash(String password) {\n            String salt = generateSalt();\n            return salt+':'+passwordEncoder.encodePassword(password,salt);\n        }\n\n        /**\n         * Generates random salt.\n         */\n        private String generateSalt() {\n            StringBuilder buf = new StringBuilder();\n            SecureRandom sr = new SecureRandom();\n            for( int i=0; i<6; i++ ) {// log2(52^6)=34.20... so, this is about 32bit strong.\n                boolean upper = sr.nextBoolean();\n                char ch = (char)(sr.nextInt(26) + 'a');\n                if(upper)   ch=Character.toUpperCase(ch);\n                buf.append(ch);\n            }\n            return buf.toString();\n        }\n    };\n\n    /**\n     * {@link PasswordEncoder} that uses jBCrypt.\n     */\n    private static final PasswordEncoder JBCRYPT_ENCODER = new PasswordEncoder() {\n        public String encodePassword(String rawPass, Object _) throws DataAccessException {\n            return BCrypt.hashpw(rawPass,BCrypt.gensalt());\n        }\n\n        public boolean isPasswordValid(String encPass, String rawPass, Object _) throws DataAccessException {\n            return BCrypt.checkpw(rawPass,encPass);\n        }\n    };\n\n    /**\n     * Combines {@link #JBCRYPT_ENCODER} and {@link #CLASSIC} into one so that we can continue\n     * to accept {@link #CLASSIC} format but new encoding will always done via {@link #JBCRYPT_ENCODER}.\n     */\n    public static final PasswordEncoder PASSWORD_ENCODER = new PasswordEncoder() {\n        /*\n            CLASSIC encoder outputs \"salt:hash\" where salt is [a-z]+, so we use unique prefix '#jbcyrpt\"\n            to designate JBCRYPT-format hash.\n\n            '#' is neither in base64 nor hex, which makes it a good choice.\n         */\n        public String encodePassword(String rawPass, Object salt) throws DataAccessException {\n            return JBCRYPT_HEADER+JBCRYPT_ENCODER.encodePassword(rawPass,salt);\n        }\n\n        public boolean isPasswordValid(String encPass, String rawPass, Object salt) throws DataAccessException {\n            if (encPass.startsWith(JBCRYPT_HEADER))\n                return JBCRYPT_ENCODER.isPasswordValid(encPass.substring(JBCRYPT_HEADER.length()),rawPass,salt);\n            else\n                return CLASSIC.isPasswordValid(encPass,rawPass,salt);\n        }\n\n        private static final String JBCRYPT_HEADER = \"#jbcrypt:\";\n    };\n\n    @Extension\n    public static final class DescriptorImpl extends Descriptor<SecurityRealm> {\n        public String getDisplayName() {\n            return Messages.HudsonPrivateSecurityRealm_DisplayName();\n        }\n\n        @Override\n        public String getHelpFile() {\n            return \"/help/security/private-realm.html\"; \n        }\n    }\n\n    private static final Filter CREATE_FIRST_USER_FILTER = new Filter() {\n        public void init(FilterConfig config) throws ServletException {\n        }\n\n        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n            HttpServletRequest req = (HttpServletRequest) request;\n\n            if(req.getRequestURI().equals(req.getContextPath()+\"/\")) {\n                if (needsToCreateFirstUser()) {\n                    ((HttpServletResponse)response).sendRedirect(\"securityRealm/firstUser\");\n                } else {// the first user already created. the role of this filter is over.\n                    PluginServletFilter.removeFilter(this);\n                    chain.doFilter(request,response);\n                }\n            } else\n                chain.doFilter(request,response);\n        }\n\n        private boolean needsToCreateFirstUser() {\n            return !hasSomeUser()\n                && Jenkins.getInstance().getSecurityRealm() instanceof HudsonPrivateSecurityRealm;\n        }\n\n        public void destroy() {\n        }\n    };\n\n    private static final Logger LOGGER = Logger.getLogger(HudsonPrivateSecurityRealm.class.getName());\n}\n", "target": 1}
{"idx": 996, "func": "package jenkins.security;\n\nimport hudson.Extension;\nimport jenkins.model.Jenkins;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport java.io.IOException;\nimport java.security.SecureRandom;\n\n/**\n * The actual storage for the data held by {@link ConfidentialKey}s, and the holder\n * of the master secret.\n *\n * <p>\n * This class is only relevant for the implementers of {@link ConfidentialKey}s.\n * Most plugin code should interact with {@link ConfidentialKey}s.\n *\n * <p>\n * OEM distributions of Jenkins can provide a custom {@link ConfidentialStore} implementation\n * by writing a subclass, mark it with {@link Extension} annotation, package it as a Jenkins module,\n * and bundling it with the war file.\n *\n * @author Kohsuke Kawaguchi\n * @since 1.498\n */\npublic abstract class ConfidentialStore {\n    /**\n     * Persists the payload of {@link ConfidentialKey} to a persisted storage (such as disk.)\n     * The expectation is that the persisted form is secure.\n     */\n    protected abstract void store(ConfidentialKey key, byte[] payload) throws IOException;\n\n    /**\n     * Reverse operation of {@link #store(ConfidentialKey, byte[])}\n     *\n     * @return\n     *      null the data has not been previously persisted, or if the data was tampered.\n     */\n    protected abstract @CheckForNull byte[] load(ConfidentialKey key) throws IOException;\n\n    /**\n     * Works like {@link SecureRandom#nextBytes(byte[])}.\n     *\n     * This enables implementations to consult other entropy sources, if it's available.\n     */\n    public abstract byte[] randomBytes(int size);\n\n    /**\n     * Retrieves the currently active singleton instance of {@link ConfidentialStore}.\n     */\n    public static @Nonnull ConfidentialStore get() {\n        if (TEST!=null) return TEST.get();\n        return Jenkins.getInstance().getExtensionList(ConfidentialStore.class).get(0);\n    }\n\n    /**\n     * Testing only. Used for testing {@link ConfidentialKey} without {@link Jenkins}\n     */\n    /*package*/ static ThreadLocal<ConfidentialStore> TEST = null;\n}\n", "target": 1}
{"idx": 997, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.time.Duration;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.function.Consumer;\nimport java.util.logging.Level;\n\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\nimport org.junit.After;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.Service.ProcessingStage;\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceHost.RequestRateInfo;\nimport com.vmware.xenon.common.ServiceHost.ServiceAlreadyStartedException;\nimport com.vmware.xenon.common.ServiceHost.ServiceHostState;\nimport com.vmware.xenon.common.ServiceHost.ServiceHostState.MemoryLimitType;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.AggregationType;\nimport com.vmware.xenon.common.jwt.Rfc7519Claims;\nimport com.vmware.xenon.common.jwt.Signer;\nimport com.vmware.xenon.common.jwt.Verifier;\nimport com.vmware.xenon.common.test.AuthTestUtils;\nimport com.vmware.xenon.common.test.MinimalTestServiceState;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestProperty;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleNonPersistedService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.ExampleServiceHost;\nimport com.vmware.xenon.services.common.FileContentService;\nimport com.vmware.xenon.services.common.LuceneDocumentIndexService;\nimport com.vmware.xenon.services.common.MinimalFactoryTestService;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupState;\nimport com.vmware.xenon.services.common.NodeState;\nimport com.vmware.xenon.services.common.OnDemandLoadFactoryService;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.ServiceHostLogService.LogServiceState;\nimport com.vmware.xenon.services.common.ServiceHostManagementService;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UiFileContentService;\nimport com.vmware.xenon.services.common.UserService;\n\npublic class TestServiceHost {\n\n    public static class AuthCheckService extends ExampleService {\n        public static final String FACTORY_LINK = ServiceUriPaths.CORE + \"/auth-check-services\";\n\n        static final String IS_AUTHORIZE_REQUEST_CALLED = \"isAuthorizeRequestCalled\";\n\n        public static FactoryService createFactory() {\n            return FactoryService.create(AuthCheckService.class);\n        }\n\n        public AuthCheckService() {\n            super();\n            // non persisted, owner selection service\n            toggleOption(ServiceOption.PERSISTENCE, false);\n            toggleOption(ServiceOption.INSTRUMENTATION, true);\n        }\n\n        @Override\n        public void authorizeRequest(Operation op) {\n            adjustStat(IS_AUTHORIZE_REQUEST_CALLED, 1);\n            op.complete();\n        }\n    }\n\n    private static final int MAINTENANCE_INTERVAL_MILLIS = 100;\n\n    private VerificationHost host;\n\n    public String testURI;\n\n    public int requestCount = 1000;\n\n    public int rateLimitedRequestCount = 10;\n\n    public int connectionCount = 32;\n\n    public long serviceCount = 10;\n\n    public int iterationCount = 1;\n\n    public long testDurationSeconds = 0;\n\n    public int indexFileThreshold = 100;\n\n    public long serviceCacheClearDelaySeconds = 2;\n\n    @Rule\n    public TemporaryFolder tmpFolder = new TemporaryFolder();\n\n\n    public void beforeHostStart(VerificationHost host) {\n        host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                .toMicros(MAINTENANCE_INTERVAL_MILLIS));\n    }\n\n    private void setUp(boolean initOnly) throws Exception {\n        CommandLineArgumentParser.parseFromProperties(this);\n        this.host = VerificationHost.create(0);\n        CommandLineArgumentParser.parseFromProperties(this.host);\n        if (initOnly) {\n            return;\n        }\n\n        try {\n            this.host.start();\n        } catch (Throwable e) {\n            throw new Exception(e);\n        }\n    }\n\n    @Test\n    public void allocateExecutor() throws Throwable {\n        setUp(false);\n        Service s = this.host.startServiceAndWait(MinimalTestService.class, UUID.randomUUID()\n                .toString());\n        ExecutorService exec = this.host.allocateExecutor(s);\n        this.host.testStart(1);\n        exec.execute(() -> {\n            this.host.completeIteration();\n        });\n        this.host.testWait();\n    }\n\n    @Test\n    public void operationTracingFineFiner() throws Throwable {\n        setUp(false);\n        TestRequestSender sender = this.host.getTestRequestSender();\n        this.host.toggleOperationTracing(this.host.getUri(), Level.FINE, true);\n        // send some requests and confirm stats get populated\n\n        URI factoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, (op) -> {\n                    ExampleServiceState st = new ExampleServiceState();\n                    st.name = \"foo\";\n                    op.setBody(st);\n                }, factoryUri);\n        TestContext ctx = this.host.testCreate(states.size() * 2);\n        for (URI u : states.keySet()) {\n            ExampleServiceState state = new ExampleServiceState();\n            state.name = this.host.nextUUID();\n            sender.sendRequest(Operation.createGet(u).setCompletion(ctx.getCompletion()));\n            sender.sendRequest(\n                    Operation.createPatch(u)\n                            .setContextId(this.host.nextUUID())\n                            .setBody(state).setCompletion(ctx.getCompletion()));\n        }\n        ctx.await();\n        ServiceStats after = sender.sendStatsGetAndWait(this.host.getManagementServiceUri());\n        for (URI u : states.keySet()) {\n            String getStatName = u.getPath() + \":\" + Action.GET;\n            String patchStatName = u.getPath() + \":\" + Action.PATCH;\n            ServiceStat getStat = after.entries.get(getStatName);\n            assertTrue(getStat != null && getStat.latestValue > 0);\n            ServiceStat patchStat = after.entries.get(patchStatName);\n            assertTrue(patchStat != null && getStat.latestValue > 0);\n        }\n        this.host.toggleOperationTracing(this.host.getUri(), Level.FINE, false);\n\n        // toggle on again, to FINER, confirm we get some log output\n        this.host.toggleOperationTracing(this.host.getUri(), Level.FINER, true);\n\n        // send some operations\n        ctx = this.host.testCreate(states.size() * 2);\n        for (URI u : states.keySet()) {\n            ExampleServiceState state = new ExampleServiceState();\n            state.name = this.host.nextUUID();\n            sender.sendRequest(Operation.createGet(u).setCompletion(ctx.getCompletion()));\n            sender.sendRequest(\n                    Operation.createPatch(u).setContextId(this.host.nextUUID()).setBody(state)\n                            .setCompletion(ctx.getCompletion()));\n        }\n        ctx.await();\n\n        LogServiceState logsAfterFiner = sender.sendGetAndWait(\n                UriUtils.buildUri(this.host, ServiceUriPaths.PROCESS_LOG),\n                LogServiceState.class);\n\n        boolean foundTrace = false;\n        for (String line : logsAfterFiner.items) {\n            for (URI u : states.keySet()) {\n                if (line.contains(u.getPath())) {\n                    foundTrace = true;\n                    break;\n                }\n            }\n        }\n        assertTrue(foundTrace);\n    }\n\n    @Test\n    public void buildDocumentDescription() throws Throwable {\n        setUp(false);\n        URI factoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, (op) -> {\n                    ExampleServiceState st = new ExampleServiceState();\n                    st.name = \"foo\";\n                    op.setBody(st);\n                }, factoryUri);\n\n        // verify we have valid descriptions for all example services we created\n        // explicitly\n        validateDescriptions(states);\n\n        // verify we can recover a description, even for services that are stopped\n        TestContext ctx = this.host.testCreate(states.size());\n        for (URI childUri : states.keySet()) {\n            Operation delete = Operation.createDelete(childUri)\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(delete);\n        }\n        this.host.testWait(ctx);\n\n        // do the description lookup again, on stopped services\n        validateDescriptions(states);\n    }\n\n    private void validateDescriptions(Map<URI, ExampleServiceState> states) {\n        for (URI childUri : states.keySet()) {\n            ServiceDocumentDescription desc = this.host\n                    .buildDocumentDescription(childUri.getPath());\n            // do simple verification of returned description, its not exhaustive\n            assertTrue(desc != null);\n            assertTrue(desc.serviceCapabilities.contains(ServiceOption.PERSISTENCE));\n            assertTrue(desc.serviceCapabilities.contains(ServiceOption.INSTRUMENTATION));\n            assertTrue(desc.propertyDescriptions.size() > 1);\n            // check that a description was replaced with contents from HTML file\n            assertTrue(desc.propertyDescriptions.get(\"keyValues\").propertyDocumentation.startsWith(\"Key/Value\"));\n        }\n    }\n\n    @Test\n    public void requestRateLimits() throws Throwable {\n        CommandLineArgumentParser.parseFromProperties(this);\n        for (int i = 0; i < this.iterationCount; i++) {\n            doRequestRateLimits();\n            tearDown();\n        }\n    }\n\n    private void doRequestRateLimits() throws Throwable {\n        setUp(true);\n\n        this.host.setAuthorizationService(new AuthorizationContextService());\n        this.host.setAuthorizationEnabled(true);\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n        this.host.start();\n\n        this.host.setSystemAuthorizationContext();\n\n        String userPath = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, \"example-user\");\n        String exampleUser = \"example@localhost\";\n        TestContext authCtx = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserSelfLink(userPath)\n                .setUserEmail(exampleUser)\n                .setUserPassword(exampleUser)\n                .setIsAdmin(false)\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setCompletion(authCtx.getCompletion())\n                .start();\n        authCtx.await();\n\n        this.host.resetAuthorizationContext();\n\n        this.host.assumeIdentity(userPath);\n\n        URI factoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, (op) -> {\n                    ExampleServiceState st = new ExampleServiceState();\n                    st.name = exampleUser;\n                    op.setBody(st);\n                }, factoryUri);\n\n        try {\n            RequestRateInfo ri = new RequestRateInfo();\n            this.host.setRequestRateLimit(userPath, ri);\n            throw new IllegalStateException(\"call should have failed, rate limit is zero\");\n        } catch (IllegalArgumentException e) {\n\n        }\n\n        try {\n            RequestRateInfo ri = new RequestRateInfo();\n            // use a custom time series but of the wrong aggregation type\n            ri.timeSeries = new TimeSeriesStats(10,\n                    TimeUnit.SECONDS.toMillis(1),\n                    EnumSet.of(AggregationType.AVG));\n            this.host.setRequestRateLimit(userPath, ri);\n            throw new IllegalStateException(\"call should have failed, aggregation is not SUM\");\n        } catch (IllegalArgumentException e) {\n\n        }\n\n        RequestRateInfo ri = new RequestRateInfo();\n        ri.limit = 1.1;\n        this.host.setRequestRateLimit(userPath, ri);\n        // verify no side effects on instance we supplied\n        assertTrue(ri.timeSeries == null);\n\n        double limit = (this.rateLimitedRequestCount * this.serviceCount) / 100;\n\n        // set limit for this user to 1 request / second, overwrite previous limit\n        this.host.setRequestRateLimit(userPath, limit);\n\n        ri = this.host.getRequestRateLimit(userPath);\n        assertTrue(Double.compare(ri.limit, limit) == 0);\n        assertTrue(!ri.options.isEmpty());\n        assertTrue(ri.options.contains(RequestRateInfo.Option.FAIL));\n        assertTrue(ri.timeSeries != null);\n        assertTrue(ri.timeSeries.numBins == 60);\n        assertTrue(ri.timeSeries.aggregationType.contains(AggregationType.SUM));\n\n        // set maintenance to default time to see how throttling behaves with default interval\n        this.host.setMaintenanceIntervalMicros(\n                ServiceHostState.DEFAULT_MAINTENANCE_INTERVAL_MICROS);\n\n        AtomicInteger failureCount = new AtomicInteger();\n        AtomicInteger successCount = new AtomicInteger();\n\n        // send N requests, at once, clearly violating the limit, and expect failures\n        int count = this.rateLimitedRequestCount;\n        TestContext ctx = this.host.testCreate(count * states.size());\n        ctx.setTestName(\"Rate limiting with failure\").logBefore();\n        CompletionHandler c = (o, e) -> {\n            if (e != null) {\n                if (o.getStatusCode() != Operation.STATUS_CODE_UNAVAILABLE) {\n                    ctx.failIteration(e);\n                    return;\n                }\n                failureCount.incrementAndGet();\n            } else {\n                successCount.incrementAndGet();\n            }\n\n            ctx.completeIteration();\n        };\n\n        ExampleServiceState patchBody = new ExampleServiceState();\n        patchBody.name = Utils.getSystemNowMicrosUtc() + \"\";\n        for (URI serviceUri : states.keySet()) {\n            for (int i = 0; i < count; i++) {\n                Operation op = Operation.createPatch(serviceUri)\n                        .setBody(patchBody)\n                        .forceRemote()\n                        .setCompletion(c);\n                this.host.send(op);\n            }\n        }\n        this.host.testWait(ctx);\n        ctx.logAfter();\n\n        assertTrue(failureCount.get() > 0);\n\n        // now change the options, and instead of fail, request throttling. this will literally\n        // throttle the HTTP listener (does not work on local, in process calls)\n\n        ri = new RequestRateInfo();\n        ri.limit = limit;\n        ri.options = EnumSet.of(RequestRateInfo.Option.PAUSE_PROCESSING);\n        this.host.setRequestRateLimit(userPath, ri);\n\n        this.host.setSystemAuthorizationContext();\n        ServiceStat rateLimitStatBefore = getRateLimitOpCountStat();\n        this.host.resetSystemAuthorizationContext();\n\n        this.host.assumeIdentity(userPath);\n\n        if (rateLimitStatBefore == null) {\n            rateLimitStatBefore = new ServiceStat();\n            rateLimitStatBefore.latestValue = 0.0;\n        }\n        TestContext ctx2 = this.host.testCreate(count * states.size());\n        ctx2.setTestName(\"Rate limiting with auto-read pause of channels\").logBefore();\n        for (URI serviceUri : states.keySet()) {\n            for (int i = 0; i < count; i++) {\n                // expect zero failures, but rate limit applied stat should have hits\n                Operation op = Operation.createPatch(serviceUri)\n                        .setBody(patchBody)\n                        .forceRemote()\n                        .setCompletion(ctx2.getCompletion());\n                this.host.send(op);\n            }\n        }\n        this.host.testWait(ctx2);\n        ctx2.logAfter();\n\n        this.host.setSystemAuthorizationContext();\n        ServiceStat rateLimitStatAfter = getRateLimitOpCountStat();\n        this.host.resetSystemAuthorizationContext();\n        assertTrue(rateLimitStatAfter.latestValue > rateLimitStatBefore.latestValue);\n\n        this.host.setMaintenanceIntervalMicros(\n                TimeUnit.MILLISECONDS.toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n\n        // effectively remove limit, verify all requests complete\n        ri = new RequestRateInfo();\n        ri.limit = 1000000;\n        ri.options = EnumSet.of(RequestRateInfo.Option.PAUSE_PROCESSING);\n        this.host.setRequestRateLimit(userPath, ri);\n        this.host.assumeIdentity(userPath);\n\n        count = this.rateLimitedRequestCount;\n        TestContext ctx3 = this.host.testCreate(count * states.size());\n        ctx3.setTestName(\"No limit\").logBefore();\n        for (URI serviceUri : states.keySet()) {\n            for (int i = 0; i < count; i++) {\n                // expect zero failures\n                Operation op = Operation.createPatch(serviceUri)\n                        .setBody(patchBody)\n                        .forceRemote()\n                        .setCompletion(ctx3.getCompletion());\n                this.host.send(op);\n            }\n        }\n        this.host.testWait(ctx3);\n        ctx3.logAfter();\n\n        // verify rate limiting did not happen\n        this.host.setSystemAuthorizationContext();\n        ServiceStat rateLimitStatExpectSame = getRateLimitOpCountStat();\n        this.host.resetSystemAuthorizationContext();\n        assertTrue(rateLimitStatAfter.latestValue == rateLimitStatExpectSame.latestValue);\n    }\n\n    @Test\n    public void postFailureOnAlreadyStarted() throws Throwable {\n        setUp(false);\n        Service s = this.host.startServiceAndWait(MinimalTestService.class, UUID.randomUUID()\n                .toString());\n        this.host.testStart(1);\n        Operation post = Operation.createPost(s.getUri()).setCompletion(\n                (o, e) -> {\n                    if (e == null) {\n                        this.host.failIteration(new IllegalStateException(\n                                \"Request should have failed\"));\n                        return;\n                    }\n\n                    if (!(e instanceof ServiceAlreadyStartedException)) {\n                        this.host.failIteration(new IllegalStateException(\n                                \"Request should have failed with different exception\"));\n                        return;\n                    }\n                    this.host.completeIteration();\n                });\n        this.host.startService(post, new MinimalTestService());\n        this.host.testWait();\n    }\n\n    @Test\n    public void startUpWithArgumentsAndHostConfigValidation() throws Throwable {\n        setUp(false);\n        ExampleServiceHost h = new ExampleServiceHost();\n        try {\n            String bindAddress = \"127.0.0.1\";\n            URI publicUri = new URI(\"http://somehost.com:1234\");\n            String hostId = UUID.randomUUID().toString();\n\n            String[] args = {\n                    \"--sandbox=\" + this.tmpFolder.getRoot().toURI(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--publicUri=\" + publicUri.toString(),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args);\n\n            // set memory limits for some services\n            double queryTasksRelativeLimit = 0.1;\n            double hostLimit = 0.29;\n            h.setServiceMemoryLimit(ServiceHost.ROOT_PATH, hostLimit);\n            h.setServiceMemoryLimit(ServiceUriPaths.CORE_QUERY_TASKS, queryTasksRelativeLimit);\n\n            // attempt to set limit that brings total > 1.0\n            try {\n                h.setServiceMemoryLimit(ServiceUriPaths.CORE_OPERATION_INDEX, 0.99);\n                throw new IllegalStateException(\"Should have failed\");\n            } catch (Throwable e) {\n\n            }\n\n            h.start();\n\n            assertTrue(UriUtils.isHostEqual(h, publicUri));\n            assertTrue(UriUtils.isHostEqual(h, new URI(\"http://127.0.0.1:\" + h.getPort())));\n            assertFalse(UriUtils.isHostEqual(h, new URI(\"https://somehost.com:\" + h.getPort())));\n            assertFalse(UriUtils.isHostEqual(h, new URI(\"http://somehost.com\")));\n            assertFalse(UriUtils.isHostEqual(h, new URI(\"http://somehost2.com:1234\")));\n\n            assertEquals(bindAddress, h.getPreferredAddress());\n\n            assertEquals(bindAddress, h.getUri().getHost());\n\n            assertEquals(hostId, h.getId());\n            assertEquals(publicUri, h.getPublicUri());\n\n            // confirm the node group self node entry uses the public URI for the bind address\n            NodeGroupState ngs = this.host.getServiceState(null, NodeGroupState.class,\n                    UriUtils.buildUri(h.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP));\n\n            NodeState selfEntry = ngs.nodes.get(h.getId());\n            assertEquals(publicUri.getHost(), selfEntry.groupReference.getHost());\n            assertEquals(publicUri.getPort(), selfEntry.groupReference.getPort());\n\n            // validate memory limits per service\n            long maxMemory = Runtime.getRuntime().maxMemory() / (1024 * 1024);\n            double hostRelativeLimit = hostLimit;\n            double indexRelativeLimit = ServiceHost.DEFAULT_PCT_MEMORY_LIMIT_DOCUMENT_INDEX;\n\n            long expectedHostLimitMB = (long) (maxMemory * hostRelativeLimit);\n            Long hostLimitMB = h.getServiceMemoryLimitMB(ServiceHost.ROOT_PATH,\n                    MemoryLimitType.EXACT);\n            assertTrue(\"Expected host limit outside bounds\",\n                    Math.abs(expectedHostLimitMB - hostLimitMB) < 10);\n\n            long expectedIndexLimitMB = (long) (maxMemory * indexRelativeLimit);\n            Long indexLimitMB = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_DOCUMENT_INDEX,\n                    MemoryLimitType.EXACT);\n            assertTrue(\"Expected index service limit outside bounds\",\n                    Math.abs(expectedIndexLimitMB - indexLimitMB) < 10);\n\n            long expectedQueryTaskLimitMB = (long) (maxMemory * queryTasksRelativeLimit);\n            Long queryTaskLimitMB = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_QUERY_TASKS,\n                    MemoryLimitType.EXACT);\n            assertTrue(\"Expected host limit outside bounds\",\n                    Math.abs(expectedQueryTaskLimitMB - queryTaskLimitMB) < 10);\n\n            // also check the water marks\n            long lowW = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_QUERY_TASKS,\n                    MemoryLimitType.LOW_WATERMARK);\n            assertTrue(\"Expected  low watermark to be less than exact\",\n                    lowW < queryTaskLimitMB);\n\n            long highW = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_QUERY_TASKS,\n                    MemoryLimitType.HIGH_WATERMARK);\n            assertTrue(\"Expected high watermark to be greater than low but less than exact\",\n                    highW > lowW && highW < queryTaskLimitMB);\n\n            // attempt to set the limit for a service after a host has started, it should fail\n            try {\n                h.setServiceMemoryLimit(ServiceUriPaths.CORE_OPERATION_INDEX, 0.2);\n                throw new IllegalStateException(\"Should have failed\");\n            } catch (Throwable e) {\n\n            }\n\n            // verify service host configuration file reflects command line arguments\n            File s = new File(h.getStorageSandbox());\n            s = new File(s, ServiceHost.SERVICE_HOST_STATE_FILE);\n\n            this.host.testStart(1);\n            ServiceHostState [] state = new ServiceHostState[1];\n            Operation get = Operation.createGet(h.getUri()).setCompletion((o, e) -> {\n                if (e != null) {\n                    this.host.failIteration(e);\n                    return;\n                }\n                state[0] = o.getBody(ServiceHostState.class);\n                this.host.completeIteration();\n            });\n            FileUtils.readFileAndComplete(get, s);\n            this.host.testWait();\n\n            assertEquals(h.getStorageSandbox(), state[0].storageSandboxFileReference);\n            assertEquals(h.getOperationTimeoutMicros(), state[0].operationTimeoutMicros);\n            assertEquals(h.getMaintenanceIntervalMicros(), state[0].maintenanceIntervalMicros);\n            assertEquals(bindAddress, state[0].bindAddress);\n            assertEquals(h.getPort(), state[0].httpPort);\n            assertEquals(hostId, state[0].id);\n\n            // now stop the host, change some arguments, restart, verify arguments override config\n            h.stop();\n\n            bindAddress = \"localhost\";\n            hostId = UUID.randomUUID().toString();\n\n            String [] args2 = {\n                    \"--port=\" + 0,\n                    \"--bindAddress=\" + bindAddress,\n                    \"--sandbox=\" + this.tmpFolder.getRoot().toURI(),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args2);\n            h.start();\n\n            assertEquals(bindAddress, h.getState().bindAddress);\n            assertEquals(hostId, h.getState().id);\n\n            verifyAuthorizedServiceMethods(h);\n\n            verifyCoreServiceOption(h);\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    private void verifyCoreServiceOption(ExampleServiceHost h) {\n        List<URI> coreServices = new ArrayList<>();\n        URI defaultNodeGroup = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n        URI defaultNodeSelector = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n        coreServices.add(UriUtils.buildConfigUri(defaultNodeGroup));\n        coreServices.add(UriUtils.buildConfigUri(defaultNodeSelector));\n        coreServices.add(UriUtils.buildConfigUri(h.getDocumentIndexServiceUri()));\n        Map<URI, ServiceConfiguration> cfgs = this.host.getServiceState(null,\n                ServiceConfiguration.class, coreServices);\n        for (ServiceConfiguration c : cfgs.values()) {\n            assertTrue(c.options.contains(ServiceOption.CORE));\n        }\n    }\n\n    private void verifyAuthorizedServiceMethods(ServiceHost h) {\n        MinimalTestService s = new MinimalTestService();\n        try {\n            h.getAuthorizationContext(s, UUID.randomUUID().toString());\n            throw new IllegalStateException(\"call should have failed\");\n        } catch (IllegalStateException e) {\n            throw e;\n        } catch (RuntimeException e) {\n\n        }\n\n        try {\n            h.cacheAuthorizationContext(s,\n                    this.host.getGuestAuthorizationContext());\n            throw new IllegalStateException(\"call should have failed\");\n        } catch (IllegalStateException e) {\n            throw e;\n        } catch (RuntimeException e) {\n\n        }\n    }\n\n    @Test\n    public void setPublicUri() throws Throwable {\n        setUp(false);\n        ExampleServiceHost h = new ExampleServiceHost();\n\n        try {\n\n            // try invalid arguments\n            ServiceHost.Arguments hostArgs = new ServiceHost.Arguments();\n            hostArgs.publicUri = \"\";\n            try {\n                h.initialize(hostArgs);\n                throw new IllegalStateException(\"should have failed\");\n            } catch (IllegalArgumentException e) {\n\n            }\n\n            hostArgs = new ServiceHost.Arguments();\n            hostArgs.bindAddress = \"\";\n            try {\n                h.initialize(hostArgs);\n                throw new IllegalStateException(\"should have failed\");\n            } catch (IllegalArgumentException e) {\n\n            }\n\n            hostArgs = new ServiceHost.Arguments();\n            hostArgs.port = -2;\n            try {\n                h.initialize(hostArgs);\n                throw new IllegalStateException(\"should have failed\");\n            } catch (IllegalArgumentException e) {\n\n            }\n\n            String bindAddress = \"127.0.0.1\";\n            String publicAddress = \"10.1.1.19\";\n            int publicPort = 1634;\n            String hostId = UUID.randomUUID().toString();\n\n            String[] args = {\n                    \"--sandbox=\" + this.tmpFolder.getRoot().getAbsolutePath(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--publicUri=\" + new URI(\"http://\" + publicAddress + \":\" + publicPort),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args);\n            h.start();\n\n            assertEquals(bindAddress, h.getPreferredAddress());\n\n            assertEquals(h.getPort(), h.getUri().getPort());\n            assertEquals(bindAddress, h.getUri().getHost());\n\n            // confirm that public URI takes precedence over bind address\n            assertEquals(publicAddress, h.getPublicUri().getHost());\n            assertEquals(publicPort, h.getPublicUri().getPort());\n\n            // confirm the node group self node entry uses the public URI for the bind address\n            NodeGroupState ngs = this.host.getServiceState(null, NodeGroupState.class,\n                    UriUtils.buildUri(h.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP));\n\n            NodeState selfEntry = ngs.nodes.get(h.getId());\n            assertEquals(publicAddress, selfEntry.groupReference.getHost());\n            assertEquals(publicPort, selfEntry.groupReference.getPort());\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void jwtSecret() throws Throwable {\n        setUp(false);\n\n        Claims claims = new Claims.Builder().setSubject(\"foo\").getResult();\n\n        Signer bogusSigner = new Signer(\"bogus\".getBytes());\n        Signer defaultSigner = this.host.getTokenSigner();\n        Verifier defaultVerifier = this.host.getTokenVerifier();\n\n        String signedByBogus = bogusSigner.sign(claims);\n        String signedByDefault = defaultSigner.sign(claims);\n\n        try {\n            defaultVerifier.verify(signedByBogus);\n            fail(\"Signed by bogusSigner should be invalid for defaultVerifier.\");\n        } catch (Verifier.InvalidSignatureException ex) {\n        }\n\n        Rfc7519Claims verified = defaultVerifier.verify(signedByDefault);\n        assertEquals(\"foo\", verified.getSubject());\n\n        this.host.stop();\n\n        // assign cert and private-key. private-key is used for JWT seed.\n        URI certFileUri = getClass().getResource(\"/ssl/server.crt\").toURI();\n        URI keyFileUri = getClass().getResource(\"/ssl/server.pem\").toURI();\n\n        this.host.setCertificateFileReference(certFileUri);\n        this.host.setPrivateKeyFileReference(keyFileUri);\n        // must assign port to zero, so we get a *new*, available port on restart.\n        this.host.setPort(0);\n        this.host.start();\n\n        Signer newSigner = this.host.getTokenSigner();\n        Verifier newVerifier = this.host.getTokenVerifier();\n\n        assertNotSame(\"new signer must be created\", defaultSigner, newSigner);\n        assertNotSame(\"new verifier must be created\", defaultVerifier, newVerifier);\n\n        try {\n            newVerifier.verify(signedByDefault);\n            fail(\"Signed by defaultSigner should be invalid for newVerifier\");\n        } catch (Verifier.InvalidSignatureException ex) {\n        }\n\n        // sign by newSigner\n        String signedByNewSigner = newSigner.sign(claims);\n\n        verified = newVerifier.verify(signedByNewSigner);\n        assertEquals(\"foo\", verified.getSubject());\n\n        try {\n            defaultVerifier.verify(signedByNewSigner);\n            fail(\"Signed by newSigner should be invalid for defaultVerifier\");\n        } catch (Verifier.InvalidSignatureException ex) {\n        }\n\n    }\n\n    @Test\n    public void startWithNonEncryptedPem() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        String tmpFolderPath = this.tmpFolder.getRoot().getAbsolutePath();\n\n        // We run test from filesystem so far, thus expect files to be on file system.\n        // For example, if we run test from jar file, needs to copy the resource to tmp dir.\n        Path certFilePath = Paths.get(getClass().getResource(\"/ssl/server.crt\").toURI());\n        Path keyFilePath = Paths.get(getClass().getResource(\"/ssl/server.pem\").toURI());\n        String certFile = certFilePath.toFile().getAbsolutePath();\n        String keyFile = keyFilePath.toFile().getAbsolutePath();\n\n        String[] args = {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n        } finally {\n            h.stop();\n        }\n\n        // with wrong password\n        args = new String[] {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n                \"--keyPassphrase=WRONG_PASSWORD\",\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n            fail(\"Host should NOT start with password for non-encrypted pem key\");\n        } catch (Exception ex) {\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void startWithEncryptedPem() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        String tmpFolderPath = this.tmpFolder.getRoot().getAbsolutePath();\n\n        // We run test from filesystem so far, thus expect files to be on file system.\n        // For example, if we run test from jar file, needs to copy the resource to tmp dir.\n        Path certFilePath = Paths.get(getClass().getResource(\"/ssl/server.crt\").toURI());\n        Path keyFilePath = Paths.get(getClass().getResource(\"/ssl/server-with-pass.p8\").toURI());\n        String certFile = certFilePath.toFile().getAbsolutePath();\n        String keyFile = keyFilePath.toFile().getAbsolutePath();\n\n        String[] args = {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n                \"--keyPassphrase=password\",\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n        } finally {\n            h.stop();\n        }\n\n        // with wrong password\n        args = new String[] {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n                \"--keyPassphrase=WRONG_PASSWORD\",\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n            fail(\"Host should NOT start with wrong password for encrypted pem key\");\n        } catch (Exception ex) {\n        } finally {\n            h.stop();\n        }\n\n        // with no password\n        args = new String[] {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n            fail(\"Host should NOT start when no password is specified for encrypted pem key\");\n        } catch (Exception ex) {\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void httpsOnly() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        String tmpFolderPath = this.tmpFolder.getRoot().getAbsolutePath();\n\n        // We run test from filesystem so far, thus expect files to be on file system.\n        // For example, if we run test from jar file, needs to copy the resource to tmp dir.\n        Path certFilePath = Paths.get(getClass().getResource(\"/ssl/server.crt\").toURI());\n        Path keyFilePath = Paths.get(getClass().getResource(\"/ssl/server.pem\").toURI());\n        String certFile = certFilePath.toFile().getAbsolutePath();\n        String keyFile = keyFilePath.toFile().getAbsolutePath();\n\n        // set -1 to disable http\n        String[] args = {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=-1\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n\n            assertNull(\"http should be disabled\", h.getListener());\n            assertNotNull(\"https should be enabled\", h.getSecureListener());\n        } finally {\n            h.stop();\n        }\n    }\n\n\n    @Test\n    public void setAuthEnforcement() throws Throwable {\n        setUp(false);\n        ExampleServiceHost h = new ExampleServiceHost();\n        try {\n            String bindAddress = \"127.0.0.1\";\n            String hostId = UUID.randomUUID().toString();\n\n            String[] args = {\n                    \"--sandbox=\" + this.tmpFolder.getRoot().getAbsolutePath(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--isAuthorizationEnabled=\" + Boolean.TRUE.toString(),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args);\n            assertTrue(h.isAuthorizationEnabled());\n            h.setAuthorizationEnabled(false);\n            assertFalse(h.isAuthorizationEnabled());\n            h.setAuthorizationEnabled(true);\n            h.start();\n\n            this.host.testStart(1);\n            h.sendRequest(Operation\n                    .createGet(UriUtils.buildUri(h.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP))\n                    .setReferer(this.host.getReferer())\n                    .setCompletion((o, e) -> {\n                        if (o.getStatusCode() == Operation.STATUS_CODE_FORBIDDEN) {\n                            this.host.completeIteration();\n                            return;\n                        }\n                        this.host.failIteration(new IllegalStateException(\n                                \"Op succeded when failure expected\"));\n                    }));\n            this.host.testWait();\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void serviceStartExpiration() throws Throwable {\n        setUp(false);\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS.toMicros(100);\n        // set a small period so its pretty much guaranteed to execute\n        // maintenance during this test\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n\n        // start a service but tell it to not complete the start POST. This will induce a timeout\n        // failure from the host\n\n        MinimalTestServiceState initialState = new MinimalTestServiceState();\n        initialState.id = MinimalTestService.STRING_MARKER_TIMEOUT_REQUEST;\n        this.host.testStart(1);\n        Operation startPost = Operation\n                .createPost(UriUtils.buildUri(this.host, UUID.randomUUID().toString()))\n                .setExpiration(Utils.fromNowMicrosUtc(maintenanceIntervalMicros))\n                .setBody(initialState)\n                .setCompletion(this.host.getExpectedFailureCompletion());\n        this.host.startService(startPost, new MinimalTestService());\n        this.host.testWait();\n    }\n\n    @Test\n    public void startServiceSelfLinkWithStar() throws Throwable {\n        setUp(false);\n        MinimalTestServiceState initialState = new MinimalTestServiceState();\n        initialState.id = this.host.nextUUID();\n        TestContext ctx = this.host.testCreate(1);\n        Operation startPost = Operation\n                .createPost(UriUtils.buildUri(this.host, this.host.nextUUID() + \"*\"))\n                .setBody(initialState).setCompletion(ctx.getExpectedFailureCompletion());\n        this.host.startService(startPost, new MinimalTestService());\n        this.host.testWait(ctx);\n    }\n\n    public static class StopOrderTestService extends StatefulService {\n\n        public int stopOrder;\n\n        public AtomicInteger globalStopOrder;\n\n        public StopOrderTestService() {\n            super(MinimalTestServiceState.class);\n        }\n\n        @Override\n        public void handleStop(Operation delete) {\n            this.stopOrder = this.globalStopOrder.incrementAndGet();\n            delete.complete();\n        }\n\n    }\n\n    public static class PrivilegedStopOrderTestService extends StatefulService {\n\n        public int stopOrder;\n\n        public AtomicInteger globalStopOrder;\n\n        public PrivilegedStopOrderTestService() {\n            super(MinimalTestServiceState.class);\n        }\n\n        @Override\n        public void handleStop(Operation delete) {\n            this.stopOrder = this.globalStopOrder.incrementAndGet();\n            delete.complete();\n        }\n\n    }\n\n    @Test\n    public void serviceStopOrder() throws Throwable {\n        setUp(false);\n\n        // start a service but tell it to not complete the start POST. This will induce a timeout\n        // failure from the host\n\n        int serviceCount = 10;\n        AtomicInteger order = new AtomicInteger(0);\n        this.host.testStart(serviceCount);\n        List<StopOrderTestService> normalServices = new ArrayList<>();\n        for (int i = 0; i < serviceCount; i++) {\n            MinimalTestServiceState initialState = new MinimalTestServiceState();\n            initialState.id = UUID.randomUUID().toString();\n            StopOrderTestService normalService = new StopOrderTestService();\n            normalServices.add(normalService);\n            normalService.globalStopOrder = order;\n            Operation post = Operation.createPost(UriUtils.buildUri(this.host, initialState.id))\n                    .setBody(initialState)\n                    .setCompletion(this.host.getCompletion());\n            this.host.startService(post, normalService);\n        }\n        this.host.testWait();\n\n\n        this.host.addPrivilegedService(PrivilegedStopOrderTestService.class);\n        List<PrivilegedStopOrderTestService> pServices = new ArrayList<>();\n        this.host.testStart(serviceCount);\n        for (int i = 0; i < serviceCount; i++) {\n            MinimalTestServiceState initialState = new MinimalTestServiceState();\n            initialState.id = UUID.randomUUID().toString();\n            PrivilegedStopOrderTestService ps = new PrivilegedStopOrderTestService();\n            pServices.add(ps);\n            ps.globalStopOrder = order;\n            Operation post = Operation.createPost(UriUtils.buildUri(this.host, initialState.id))\n                    .setBody(initialState)\n                    .setCompletion(this.host.getCompletion());\n            this.host.startService(post, ps);\n        }\n        this.host.testWait();\n\n        this.host.stop();\n\n        for (PrivilegedStopOrderTestService pService : pServices) {\n            for (StopOrderTestService normalService : normalServices) {\n                this.host.log(\"normal order: %d, privileged: %d\", normalService.stopOrder,\n                        pService.stopOrder);\n                assertTrue(normalService.stopOrder < pService.stopOrder);\n            }\n        }\n    }\n\n    @Test\n    public void maintenanceAndStatsReporting() throws Throwable {\n        CommandLineArgumentParser.parseFromProperties(this);\n        for (int i = 0; i < this.iterationCount; i++) {\n            this.tearDown();\n            doMaintenanceAndStatsReporting();\n        }\n    }\n\n    private void doMaintenanceAndStatsReporting() throws Throwable {\n        setUp(true);\n\n        // induce host to clear service state cache by setting mem limit low\n        this.host.setServiceMemoryLimit(ServiceHost.ROOT_PATH, 0.0001);\n        this.host.setServiceMemoryLimit(LuceneDocumentIndexService.SELF_LINK, 0.0001);\n        long maintIntervalMillis = 100;\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS.toMicros(maintIntervalMillis);\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n        this.host.setServiceCacheClearDelayMicros(TimeUnit.MILLISECONDS\n                .toMicros(maintIntervalMillis / 2));\n        this.host.start();\n\n        verifyMaintenanceDelayStat(maintenanceIntervalMicros);\n\n        long opCount = 2;\n        EnumSet<ServiceOption> caps = EnumSet.of(ServiceOption.PERSISTENCE,\n                ServiceOption.INSTRUMENTATION, ServiceOption.PERIODIC_MAINTENANCE);\n\n        List<Service> services = this.host.doThroughputServiceStart(\n                this.serviceCount, MinimalTestService.class, this.host.buildMinimalTestState(),\n                caps,\n                null);\n\n        long start = System.nanoTime() / 1000;\n        List<Service> slowMaintServices = this.host.doThroughputServiceStart(null,\n                this.serviceCount, MinimalTestService.class, this.host.buildMinimalTestState(),\n                caps,\n                null, maintenanceIntervalMicros * 10);\n\n        List<URI> uris = new ArrayList<>();\n        for (Service s : services) {\n            uris.add(s.getUri());\n        }\n\n        this.host.doPutPerService(opCount, EnumSet.of(TestProperty.FORCE_REMOTE),\n                services);\n\n        long cacheMissCount = 0;\n        long cacheClearCount = 0;\n        ServiceStat cacheClearStat = null;\n        Map<URI, ServiceStats> servicesWithMaintenance = new HashMap<>();\n\n        double maintCount = getHostMaintenanceCount();\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > maintCount + 10;\n        });\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            // issue GET to actually make the cache miss occur (if the cache has been cleared)\n            this.host.getServiceState(null, MinimalTestServiceState.class, uris);\n\n            // verify each service show at least a couple of maintenance requests\n            URI[] statUris = buildStatsUris(this.serviceCount, services);\n            Map<URI, ServiceStats> stats = this.host.getServiceState(null,\n                    ServiceStats.class, statUris);\n\n            for (Entry<URI, ServiceStats> e : stats.entrySet()) {\n                long maintFailureCount = 0;\n                ServiceStats s = e.getValue();\n\n                for (ServiceStat st : s.entries.values()) {\n\n                    if (st.name.equals(Service.STAT_NAME_CACHE_MISS_COUNT)) {\n                        cacheMissCount += (long) st.latestValue;\n                        continue;\n                    }\n\n                    if (st.name.equals(Service.STAT_NAME_CACHE_CLEAR_COUNT)) {\n                        cacheClearCount += (long) st.latestValue;\n                        continue;\n                    }\n                    if (st.name.equals(MinimalTestService.STAT_NAME_MAINTENANCE_SUCCESS_COUNT)) {\n                        servicesWithMaintenance.put(e.getKey(), e.getValue());\n                        continue;\n                    }\n                    if (st.name.equals(MinimalTestService.STAT_NAME_MAINTENANCE_FAILURE_COUNT)) {\n                        maintFailureCount++;\n                        continue;\n                    }\n                }\n\n                assertTrue(\"maintenance failed\", maintFailureCount == 0);\n            }\n\n            // verify that every single service has seen at least one maintenance interval\n            if (servicesWithMaintenance.size() < this.serviceCount) {\n                this.host.log(\"Services with maintenance: %d, expected %d\",\n                        servicesWithMaintenance.size(), this.serviceCount);\n                Thread.sleep(maintIntervalMillis * 2);\n                continue;\n            }\n\n            if (cacheMissCount < 1) {\n                this.host.log(\"No cache misses seen\");\n                Thread.sleep(maintIntervalMillis * 2);\n                continue;\n            }\n\n            if (cacheClearCount < 1) {\n                this.host.log(\"No cache clears seen\");\n                Thread.sleep(maintIntervalMillis * 2);\n                continue;\n            }\n\n            Map<String, ServiceStat> mgmtStats = this.host.getServiceStats(this.host.getManagementServiceUri());\n            cacheClearStat = mgmtStats.get(ServiceHostManagementService.STAT_NAME_SERVICE_CACHE_CLEAR_COUNT);\n            if (cacheClearStat == null || cacheClearStat.latestValue < 1) {\n                this.host.log(\"Cache clear stat on management service not seen\");\n                Thread.sleep(maintIntervalMillis * 2);\n                continue;\n            }\n            break;\n        }\n        long end = System.nanoTime() / 1000;\n\n        if (cacheClearStat == null || cacheClearStat.latestValue < 1) {\n            throw new IllegalStateException(\n                    \"Cache clear stat on management service not observed\");\n        }\n\n        this.host.log(\"State cache misses: %d, cache clears: %d\", cacheMissCount, cacheClearCount);\n\n        double expectedMaintIntervals = Math.max(1,\n                (end - start) / this.host.getMaintenanceIntervalMicros());\n\n        // allow variance up to 2x of expected intervals. We have the interval set to 100ms\n        // and we are running tests on VMs, in over subscribed CI. So we expect significant\n        // scheduling variance. This test is extremely consistent on a local machine\n        expectedMaintIntervals *= 2;\n\n        for (Entry<URI, ServiceStats> e : servicesWithMaintenance.entrySet()) {\n\n            ServiceStat maintStat = e.getValue().entries.get(Service.STAT_NAME_MAINTENANCE_COUNT);\n            this.host.log(\"%s has %f intervals\", e.getKey(), maintStat.latestValue);\n            if (maintStat.latestValue > expectedMaintIntervals + 2) {\n                String error = String.format(\"Expected %f, got %f. Too many stats for service %s\",\n                        expectedMaintIntervals + 2,\n                        maintStat.latestValue,\n                        e.getKey());\n                throw new IllegalStateException(error);\n            }\n\n        }\n\n\n        if (cacheMissCount < 1) {\n            throw new IllegalStateException(\n                    \"No cache misses observed through stats\");\n        }\n\n        long slowMaintInterval = this.host.getMaintenanceIntervalMicros() * 10;\n        end = System.nanoTime() / 1000;\n        expectedMaintIntervals = Math.max(1, (end - start) / slowMaintInterval);\n\n        // verify that services with slow maintenance did not get more than one maint cycle\n        URI[] statUris = buildStatsUris(this.serviceCount, slowMaintServices);\n        Map<URI, ServiceStats> stats = this.host.getServiceState(null,\n                ServiceStats.class, statUris);\n\n        for (ServiceStats s : stats.values()) {\n\n            for (ServiceStat st : s.entries.values()) {\n                if (st.name.equals(Service.STAT_NAME_MAINTENANCE_COUNT)) {\n                    // give a slop of 3 extra intervals:\n                    // 1 due to rounding, 2 due to interval running before we do setMaintenance\n                    // to a slower interval ( notice we start services, then set the interval)\n                    if (st.latestValue > expectedMaintIntervals + 3) {\n                        throw new IllegalStateException(\n                                \"too many maintenance runs for slow maint. service:\"\n                                        + st.latestValue);\n                    }\n                }\n            }\n        }\n\n        this.host.testStart(services.size());\n        // delete all minimal service instances\n        for (Service s : services) {\n            this.host.send(Operation.createDelete(s.getUri()).setBody(new ServiceDocument())\n                    .setCompletion(this.host.getCompletion()));\n        }\n        this.host.testWait();\n\n        this.host.testStart(slowMaintServices.size());\n        // delete all minimal service instances\n        for (Service s : slowMaintServices) {\n            this.host.send(Operation.createDelete(s.getUri()).setBody(new ServiceDocument())\n                    .setCompletion(this.host.getCompletion()));\n        }\n        this.host.testWait();\n\n        // before we increase maintenance interval, verify stats reported by MGMT service\n        verifyMgmtServiceStats();\n\n        // now validate that service handleMaintenance does not get called right after start, but at least\n        // one interval later. We set the interval to 30 seconds so we can verify it did not get called within\n        // one second or so\n        long maintMicros = TimeUnit.SECONDS.toMicros(30);\n        this.host.setMaintenanceIntervalMicros(maintMicros);\n\n        // there is a small race: if the host scheduled a maintenance task already, using the default\n        // 1 second interval, its possible it executes maintenance on the newly added services using\n        // the 1 second schedule, instead of 30 seconds. So wait at least one maint. interval with the\n        // default interval\n        Thread.sleep(1000);\n\n        slowMaintServices = this.host.doThroughputServiceStart(\n                this.serviceCount, MinimalTestService.class, this.host.buildMinimalTestState(),\n                caps,\n                null);\n\n        // sleep again and check no maintenance run right after start\n        Thread.sleep(250);\n\n        statUris = buildStatsUris(this.serviceCount, slowMaintServices);\n        stats = this.host.getServiceState(null,\n                ServiceStats.class, statUris);\n\n        for (ServiceStats s : stats.values()) {\n            for (ServiceStat st : s.entries.values()) {\n                if (st.name.equals(Service.STAT_NAME_MAINTENANCE_COUNT)) {\n                    throw new IllegalStateException(\"Maintenance run before first expiration:\"\n                            + Utils.toJsonHtml(s));\n                }\n            }\n        }\n\n        // some services are at 100ms maintenance and the host is at 30 seconds, verify the\n        // check maintenance interval is the minimum of the two\n        long currentMaintInterval = this.host.getMaintenanceIntervalMicros();\n        long currentCheckInterval = this.host.getMaintenanceCheckIntervalMicros();\n        assertTrue(currentMaintInterval > currentCheckInterval);\n\n        // create new set of services\n        services = this.host.doThroughputServiceStart(\n                this.serviceCount, MinimalTestService.class, this.host.buildMinimalTestState(),\n                caps,\n                null);\n\n        // set the  interval for a service to something smaller than the host interval, then confirm\n        // that only the maintenance *check* interval changed, not the host global maintenance interval, which\n        // can affect all services\n        for (Service s : services) {\n            s.setMaintenanceIntervalMicros(currentCheckInterval / 2);\n            break;\n        }\n\n        this.host.waitFor(\"check interval not updated\", () -> {\n            // verify the check interval is now lower\n            if (currentCheckInterval / 2 != this.host.getMaintenanceCheckIntervalMicros()) {\n                return false;\n            }\n            if (currentMaintInterval != this.host.getMaintenanceIntervalMicros()) {\n                return false;\n            }\n            return true;\n        });\n    }\n\n    private void verifyMgmtServiceStats() {\n        URI serviceHostMgmtURI = UriUtils.buildUri(this.host, ServiceUriPaths.CORE_MANAGEMENT);\n        this.host.waitFor(\"wait for http stat update.\", () -> {\n            Operation get = Operation.createGet(this.host, ServiceHostManagementService.SELF_LINK);\n            this.host.send(get.forceRemote());\n            this.host.send(get.clone().forceRemote().setConnectionSharing(true));\n\n            Map<String, ServiceStat> hostMgmtStats = this.host\n                    .getServiceStats(serviceHostMgmtURI);\n            ServiceStat http1ConnectionCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_CONNECTION_COUNT_PER_DAY);\n            if (http1ConnectionCountDaily == null\n                    || http1ConnectionCountDaily.version < 3) {\n                return false;\n            }\n            ServiceStat http2ConnectionCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_CONNECTION_COUNT_PER_DAY);\n            if (http2ConnectionCountDaily == null\n                    || http2ConnectionCountDaily.version < 3) {\n                return false;\n            }\n            return true;\n        });\n\n\n        this.host.waitFor(\"stats never populated\", () -> {\n            // confirm host global time series stats have been created / updated\n            Map<String, ServiceStat> hostMgmtStats = this.host.getServiceStats(serviceHostMgmtURI);\n\n            ServiceStat serviceCount = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_SERVICE_COUNT);\n            if (serviceCount == null || serviceCount.latestValue < 2) {\n                this.host.log(\"not ready: %s\", Utils.toJson(serviceCount));\n                return false;\n            }\n\n            ServiceStat freeMemDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_MEMORY_BYTES_PER_DAY);\n            if (!isTimeSeriesStatReady(freeMemDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeMemDaily));\n                return false;\n            }\n            ServiceStat freeMemHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_MEMORY_BYTES_PER_HOUR);\n            if (!isTimeSeriesStatReady(freeMemHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeMemHourly));\n                return false;\n            }\n            ServiceStat freeDiskDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_DISK_BYTES_PER_DAY);\n            if (!isTimeSeriesStatReady(freeDiskDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeDiskDaily));\n                return false;\n            }\n            ServiceStat freeDiskHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_DISK_BYTES_PER_HOUR);\n            if (!isTimeSeriesStatReady(freeDiskHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeDiskHourly));\n                return false;\n            }\n            ServiceStat cpuUsageDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_CPU_USAGE_PCT_PER_DAY);\n            if (!isTimeSeriesStatReady(cpuUsageDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(cpuUsageDaily));\n                return false;\n            }\n            ServiceStat cpuUsageHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_CPU_USAGE_PCT_PER_HOUR);\n            if (!isTimeSeriesStatReady(cpuUsageHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(cpuUsageHourly));\n                return false;\n            }\n            ServiceStat threadCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_JVM_THREAD_COUNT_PER_DAY);\n            if (!isTimeSeriesStatReady(threadCountDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(threadCountDaily));\n                return false;\n            }\n            ServiceStat threadCountHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_JVM_THREAD_COUNT_PER_HOUR);\n            if (!isTimeSeriesStatReady(threadCountHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(threadCountHourly));\n                return false;\n            }\n\n            ServiceStat http1PendingCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_PENDING_OP_COUNT_PER_DAY);\n            if (!isTimeSeriesStatReady(http1PendingCountDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http1PendingCountDaily));\n                return false;\n            }\n            ServiceStat http1PendingCountHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_PENDING_OP_COUNT_PER_HOUR);\n            if (!isTimeSeriesStatReady(http1PendingCountHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http1PendingCountHourly));\n                return false;\n            }\n            ServiceStat http2PendingCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_PENDING_OP_COUNT_PER_DAY);\n            if (!isTimeSeriesStatReady(http2PendingCountDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http2PendingCountDaily));\n                return false;\n            }\n            ServiceStat http2PendingCountHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_PENDING_OP_COUNT_PER_HOUR);\n            if (!isTimeSeriesStatReady(http2PendingCountHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http2PendingCountHourly));\n                return false;\n            }\n\n            ServiceStat http1AvailableConnectionCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_AVAILABLE_CONNECTION_COUNT_PER_DAY);\n            if (!isTimeSeriesStatReady(http1AvailableConnectionCountDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http1AvailableConnectionCountDaily));\n                return false;\n            }\n            ServiceStat http1AvailableConnectionCountHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_AVAILABLE_CONNECTION_COUNT_PER_HOUR);\n            if (!isTimeSeriesStatReady(http1AvailableConnectionCountHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http1AvailableConnectionCountHourly));\n                return false;\n            }\n            ServiceStat http2AvailableConnectionCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_AVAILABLE_CONNECTION_COUNT_PER_DAY);\n            if (!isTimeSeriesStatReady(http2AvailableConnectionCountDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http2AvailableConnectionCountDaily));\n                return false;\n            }\n            ServiceStat http2AvailableConnectionCountHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_AVAILABLE_CONNECTION_COUNT_PER_HOUR);\n            if (!isTimeSeriesStatReady(http2AvailableConnectionCountHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http2AvailableConnectionCountHourly));\n                return false;\n            }\n\n            TestUtilityService.validateTimeSeriesStat(freeMemDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(freeMemHourly, TimeUnit.MINUTES.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(freeDiskDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(freeDiskHourly, TimeUnit.MINUTES.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(cpuUsageDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(cpuUsageHourly, TimeUnit.MINUTES.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(threadCountDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(threadCountHourly,\n                    TimeUnit.MINUTES.toMillis(1));\n            return true;\n        });\n    }\n\n    private boolean isTimeSeriesStatReady(ServiceStat st) {\n        return st != null && st.timeSeriesStats != null;\n    }\n\n    private void verifyMaintenanceDelayStat(long intervalMicros) throws Throwable {\n        // verify state on maintenance delay takes hold\n        this.host.setMaintenanceIntervalMicros(intervalMicros);\n        MinimalTestService ts = new MinimalTestService();\n        ts.delayMaintenance = true;\n        ts.toggleOption(ServiceOption.PERIODIC_MAINTENANCE, true);\n        ts.toggleOption(ServiceOption.INSTRUMENTATION, true);\n        MinimalTestServiceState body = new MinimalTestServiceState();\n        body.id = UUID.randomUUID().toString();\n        ts = (MinimalTestService) this.host.startServiceAndWait(ts, UUID.randomUUID().toString(),\n                body);\n        MinimalTestService finalTs = ts;\n        this.host.waitFor(\"Maintenance delay stat never reported\", () -> {\n            ServiceStats stats = this.host.getServiceState(null, ServiceStats.class,\n                    UriUtils.buildStatsUri(finalTs.getUri()));\n            if (stats.entries == null || stats.entries.isEmpty()) {\n                Thread.sleep(intervalMicros / 1000);\n                return false;\n            }\n\n            ServiceStat delayStat = stats.entries\n                    .get(Service.STAT_NAME_MAINTENANCE_COMPLETION_DELAYED_COUNT);\n            ServiceStat durationStat = stats.entries.get(Service.STAT_NAME_MAINTENANCE_DURATION);\n            if (delayStat == null) {\n                Thread.sleep(intervalMicros / 1000);\n                return false;\n            }\n\n            if (durationStat == null || (durationStat != null && durationStat.logHistogram == null)) {\n                return false;\n            }\n            return true;\n        });\n\n        ts.toggleOption(ServiceOption.PERIODIC_MAINTENANCE, false);\n    }\n\n    @Test\n    public void testCacheClearAndRefresh() throws Throwable {\n        setUp(false);\n        this.host.setServiceCacheClearDelayMicros(TimeUnit.MILLISECONDS.toMicros(1));\n\n        URI factoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, (op) -> {\n                    ExampleServiceState st = new ExampleServiceState();\n                    st.name = UUID.randomUUID().toString();\n                    op.setBody(st);\n                }, factoryUri);\n\n        this.host.waitFor(\"Service state cache eviction failed to occur\", () -> {\n            for (URI serviceUri : states.keySet()) {\n                Map<String, ServiceStat> stats = this.host.getServiceStats(serviceUri);\n                ServiceStat cacheMissStat = stats.get(Service.STAT_NAME_CACHE_MISS_COUNT);\n                if (cacheMissStat != null && cacheMissStat.latestValue > 0) {\n                    throw new IllegalStateException(\"Upexpected cache miss stat value \"\n                            + cacheMissStat.latestValue);\n                }\n\n                ServiceStat cacheClearStat = stats.get(Service.STAT_NAME_CACHE_CLEAR_COUNT);\n                if (cacheClearStat == null || cacheClearStat.latestValue == 0) {\n                    return false;\n                } else if (cacheClearStat.latestValue > 1) {\n                    throw new IllegalStateException(\"Unexpected cache clear stat value \"\n                            + cacheClearStat.latestValue);\n                }\n            }\n\n            return true;\n        });\n\n        this.host.setServiceCacheClearDelayMicros(\n                ServiceHostState.DEFAULT_OPERATION_TIMEOUT_MICROS);\n\n        // Perform a GET on each service to repopulate the service state cache\n        TestContext ctx = this.host.testCreate(states.size());\n        for (URI serviceUri : states.keySet()) {\n            Operation get = Operation.createGet(serviceUri).setCompletion(ctx.getCompletion());\n            this.host.send(get);\n        }\n        this.host.testWait(ctx);\n\n        // Now do many more overlapping gets -- since the operations above have returned, these\n        // should all hit the cache.\n        int requestCount = 10;\n        ctx = this.host.testCreate(requestCount * states.size());\n        for (URI serviceUri : states.keySet()) {\n            for (int i = 0; i < requestCount; i++) {\n                Operation get = Operation.createGet(serviceUri).setCompletion(ctx.getCompletion());\n                this.host.send(get);\n            }\n        }\n        this.host.testWait(ctx);\n\n        for (URI serviceUri : states.keySet()) {\n            Map<String, ServiceStat> stats = this.host.getServiceStats(serviceUri);\n            ServiceStat cacheMissStat = stats.get(Service.STAT_NAME_CACHE_MISS_COUNT);\n            assertNotNull(cacheMissStat);\n            assertEquals(1, cacheMissStat.latestValue, 0.01);\n        }\n    }\n\n    @Test\n    public void registerForServiceAvailabilityTimeout()\n            throws Throwable {\n        setUp(false);\n        int c = 10;\n        this.host.testStart(c);\n        // issue requests to service paths we know do not exist, but induce the automatic\n        // queuing behavior for service availability, by setting targetReplicated = true\n        for (int i = 0; i < c; i++) {\n            this.host.send(Operation\n                    .createGet(UriUtils.buildUri(this.host, UUID.randomUUID().toString()))\n                    .setTargetReplicated(true)\n                    .setExpiration(Utils.fromNowMicrosUtc(TimeUnit.SECONDS.toMicros(1)))\n                    .setCompletion(this.host.getExpectedFailureCompletion()));\n        }\n        this.host.testWait();\n    }\n\n    @Test\n    public void registerForFactoryServiceAvailability()\n            throws Throwable {\n        setUp(false);\n        this.host.startFactoryServicesSynchronously(new TestFactoryService.SomeFactoryService(),\n                SomeExampleService.createFactory());\n        this.host.waitForServiceAvailable(SomeExampleService.FACTORY_LINK);\n        this.host.waitForServiceAvailable(TestFactoryService.SomeFactoryService.SELF_LINK);\n        try {\n            // not a factory so will fail\n            this.host.startFactoryServicesSynchronously(new ExampleService());\n            throw new IllegalStateException(\"Should have failed\");\n        } catch (IllegalArgumentException e) {\n\n        }\n\n        try {\n            // does not have SELF_LINK/FACTORY_LINK so will fail\n            this.host.startFactoryServicesSynchronously(new MinimalFactoryTestService());\n            throw new IllegalStateException(\"Should have failed\");\n        } catch (IllegalArgumentException e) {\n\n        }\n    }\n\n    public static class SomeExampleService extends StatefulService {\n        public static final String FACTORY_LINK = UUID.randomUUID().toString();\n\n        public static Service createFactory() {\n            return FactoryService.create(SomeExampleService.class, SomeExampleServiceState.class);\n        }\n\n        public SomeExampleService() {\n            super(SomeExampleServiceState.class);\n        }\n\n        public static class SomeExampleServiceState extends ServiceDocument {\n            public String name ;\n        }\n    }\n\n    @Test\n    public void registerForServiceAvailabilityBeforeAndAfterMultiple()\n            throws Throwable {\n        setUp(false);\n        int serviceCount = 100;\n        this.host.testStart(serviceCount * 3);\n        String[] links = new String[serviceCount];\n        for (int i = 0; i < serviceCount; i++) {\n            URI u = UriUtils.buildUri(this.host, UUID.randomUUID().toString());\n            links[i] = u.getPath();\n            this.host.registerForServiceAvailability(this.host.getCompletion(),\n                    u.getPath());\n            this.host.startService(Operation.createPost(u),\n                    ExampleService.createFactory());\n            this.host.registerForServiceAvailability(this.host.getCompletion(),\n                    u.getPath());\n        }\n        this.host.registerForServiceAvailability(this.host.getCompletion(),\n                links);\n\n        this.host.testWait();\n    }\n\n    @Test\n    public void registerForServiceAvailabilityWithReplicaBeforeAndAfterMultiple()\n            throws Throwable {\n        setUp(true);\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n\n        String[] links = new String[] {\n                ExampleService.FACTORY_LINK,\n                ServiceUriPaths.CORE_AUTHZ_RESOURCE_GROUPS,\n                ServiceUriPaths.CORE_AUTHZ_USERS,\n                ServiceUriPaths.CORE_AUTHZ_ROLES,\n                ServiceUriPaths.CORE_AUTHZ_USER_GROUPS };\n\n        // register multiple factories, before host start\n        TestContext ctx = this.host.testCreate(links.length * 10);\n        for (int i = 0; i < 10; i++) {\n            this.host.registerForServiceAvailability(ctx.getCompletion(), true, links);\n        }\n        this.host.start();\n        this.host.testWait(ctx);\n\n        // register multiple factories, after host start\n        for (int i = 0; i < 10; i++) {\n            ctx = this.host.testCreate(links.length);\n            this.host.registerForServiceAvailability(ctx.getCompletion(), true, links);\n            this.host.testWait(ctx);\n        }\n\n        // verify that the new replica aware service available works with child services\n        int serviceCount = 10;\n        ctx = this.host.testCreate(serviceCount * 3);\n        links = new String[serviceCount];\n        for (int i = 0; i < serviceCount; i++) {\n            URI u = UriUtils.buildUri(this.host, UUID.randomUUID().toString());\n            links[i] = u.getPath();\n            this.host.registerForServiceAvailability(ctx.getCompletion(),\n                    u.getPath());\n            this.host.startService(Operation.createPost(u),\n                    ExampleService.createFactory());\n            this.host.registerForServiceAvailability(ctx.getCompletion(), true,\n                    u.getPath());\n        }\n        this.host.registerForServiceAvailability(ctx.getCompletion(),\n                links);\n\n        this.host.testWait(ctx);\n    }\n\n    public static class ParentService extends StatefulService {\n\n        public static final String FACTORY_LINK = \"/test/parent\";\n\n        public static Service createFactory() {\n            return FactoryService.create(ParentService.class);\n        }\n\n        public ParentService() {\n            super(ExampleServiceState.class);\n            super.toggleOption(ServiceOption.PERSISTENCE, true);\n        }\n    }\n\n    public static class ChildDependsOnParentService extends StatefulService {\n        public static final String FACTORY_LINK = \"/test/child-of-parent\";\n\n        public static Service createFactory() {\n            return FactoryService.create(ChildDependsOnParentService.class);\n        }\n\n        public ChildDependsOnParentService() {\n            super(ExampleServiceState.class);\n            super.toggleOption(ServiceOption.PERSISTENCE, true);\n        }\n\n        @Override\n        public void handleStart(Operation post) {\n            // do not complete post for start, until we see a instance of the parent\n            // being available. If there is an issue with factory start, this will\n            // deadlock\n            ExampleServiceState st = getBody(post);\n            String id = Service.getId(st.documentSelfLink);\n            String parentPath = UriUtils.buildUriPath(ParentService.FACTORY_LINK, id);\n            post.nestCompletion((o, e) -> {\n                if (e != null) {\n                    post.fail(e);\n                    return;\n                }\n                logInfo(\"Parent service started!\");\n                post.complete();\n            });\n            getHost().registerForServiceAvailability(post, parentPath);\n        }\n    }\n\n    @Test\n    public void registerForServiceAvailabilityWithCrossDependencies()\n            throws Throwable {\n        setUp(false);\n        this.host.startFactoryServicesSynchronously(ParentService.createFactory(),\n                ChildDependsOnParentService.createFactory());\n        String id = UUID.randomUUID().toString();\n        TestContext ctx = this.host.testCreate(2);\n        // start a parent instance and a child instance.\n        ExampleServiceState st = new ExampleServiceState();\n        st.documentSelfLink = id;\n        st.name = id;\n        Operation post = Operation\n                .createPost(UriUtils.buildUri(this.host, ParentService.FACTORY_LINK))\n                .setCompletion(ctx.getCompletion())\n                .setBody(st);\n        this.host.send(post);\n        post = Operation\n                .createPost(UriUtils.buildUri(this.host, ChildDependsOnParentService.FACTORY_LINK))\n                .setCompletion(ctx.getCompletion())\n                .setBody(st);\n        this.host.send(post);\n        ctx.await();\n\n        // we create the two persisted instances, and they started. Now stop the host and confirm restart occurs\n        this.host.stop();\n        this.host.setPort(0);\n        if (!VerificationHost.restartStatefulHost(this.host, true)) {\n            this.host.log(\"Failed restart of host, aborting\");\n            return;\n        }\n        this.host.startFactoryServicesSynchronously(ParentService.createFactory(),\n                ChildDependsOnParentService.createFactory());\n\n        // verify instance services started\n        ctx = this.host.testCreate(1);\n        String childPath = UriUtils.buildUriPath(ChildDependsOnParentService.FACTORY_LINK, id);\n        Operation get = Operation.createGet(UriUtils.buildUri(this.host, childPath))\n                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_QUEUE_FOR_SERVICE_AVAILABILITY)\n                .setCompletion(ctx.getCompletion());\n        this.host.send(get);\n        ctx.await();\n    }\n\n    @Test\n    public void queueRequestForServiceWithNonFactoryParent() throws Throwable {\n        setUp(false);\n        class DelayedStartService extends StatelessService {\n            @Override\n            public void handleStart(Operation start) {\n                getHost().schedule(() -> {\n                    start.complete();\n                }, 100, TimeUnit.MILLISECONDS);\n            }\n\n            @Override\n            public void handleGet(Operation get) {\n                get.complete();\n            }\n        }\n\n        Operation startOp = Operation.createPost(UriUtils.buildUri(this.host, \"/delayed\"));\n        this.host.startService(startOp, new DelayedStartService());\n\n        // Don't wait for the service to be started, because it intentionally takes a while.\n        // The GET operation below should be queued until the service's start completes.\n        Operation getOp = Operation\n                .createGet(UriUtils.buildUri(this.host, \"/delayed\"))\n                .setCompletion(this.host.getCompletion());\n        this.host.testStart(1);\n        this.host.send(getOp);\n        this.host.testWait();\n    }\n\n    @Test\n    public void serviceStopDueToMemoryPressure() throws Throwable {\n        setUp(true);\n        this.host.setAuthorizationService(new AuthorizationContextService());\n        this.host.setAuthorizationEnabled(true);\n\n        if (this.serviceCount >= 1000) {\n            this.host.setStressTest(true);\n        }\n\n        // Set the threshold low to induce it during this test, several times. This will\n        // verify that refreshing the index writer does not break the index semantics\n        LuceneDocumentIndexService\n                .setIndexFileCountThresholdForWriterRefresh(this.indexFileThreshold);\n\n        // set memory limit low to force service stop\n        this.host.setServiceMemoryLimit(ServiceHost.ROOT_PATH, 0.00001);\n        beforeHostStart(this.host);\n\n        this.host.setPort(0);\n        long delayMicros = TimeUnit.SECONDS\n                .toMicros(this.serviceCacheClearDelaySeconds);\n        this.host.setServiceCacheClearDelayMicros(delayMicros);\n\n        // disable auto sync since it might cause a false negative (skipped pauses) when\n        // it kicks in within a few milliseconds from host start, during induced pause\n        this.host.setPeerSynchronizationEnabled(false);\n        long delayMicrosAfter = this.host.getServiceCacheClearDelayMicros();\n        assertTrue(delayMicros == delayMicrosAfter);\n        this.host.start();\n\n        this.host.setSystemAuthorizationContext();\n        TestContext ctxQuery = this.host.testCreate(1);\n        String user = \"foo@bar.com\";\n        Query.Builder queryBuilder = Query.Builder.create()\n                .addFieldClause(ServiceDocument.FIELD_NAME_KIND, Utils.buildKind(ExampleServiceState.class));\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserEmail(user)\n                .setUserSelfLink(user)\n                .setUserPassword(user)\n                .setResourceQuery(queryBuilder.build())\n                .setCompletion((ex) -> {\n                    if (ex != null) {\n                        ctxQuery.failIteration(ex);\n                        return;\n                    }\n                    ctxQuery.completeIteration();\n                }).start();\n        ctxQuery.await();\n        String factoryLink = OnDemandLoadFactoryService.create(this.host);\n        URI factoryURI = UriUtils.buildUri(this.host, factoryLink);\n        this.host.resetSystemAuthorizationContext();\n\n        AtomicLong selfLinkCounter = new AtomicLong();\n        String prefix = \"instance-\";\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            s.documentSelfLink = prefix + selfLinkCounter.incrementAndGet();\n            o.setBody(s);\n        };\n\n        // Create a number of child services.\n        this.host.assumeIdentity(UriUtils.buildUriPath(UserService.FACTORY_LINK, user));\n\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        // Wait for the next maintenance interval to trigger. This will stop all the services\n        // we just created since the memory limit was set so low.\n        long expectedStopTime = Utils.fromNowMicrosUtc(this.host\n                .getMaintenanceIntervalMicros() * 5);\n        while (this.host.getState().lastMaintenanceTimeUtcMicros < expectedStopTime) {\n            // memory limits are applied during maintenance, so wait for a few intervals.\n            Thread.sleep(this.host.getMaintenanceIntervalMicros() / 1000);\n        }\n\n        // Let's now issue some updates to verify stopped services get started.\n        int updateCount = 100;\n        if (this.testDurationSeconds > 0 || this.host.isStressTest()) {\n            updateCount = 1;\n        }\n        patchExampleServices(states, updateCount);\n\n        TestContext ctxGet = this.host.testCreate(states.size());\n        for (ExampleServiceState st : states.values()) {\n            Operation get = Operation.createGet(UriUtils.buildUri(this.host, st.documentSelfLink))\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e != null) {\n                                    this.host.failIteration(e);\n                                    return;\n                                }\n\n                                ExampleServiceState rsp = o.getBody(ExampleServiceState.class);\n                                if (!rsp.name.startsWith(\"updated\")) {\n                                    ctxGet.fail(new IllegalStateException(Utils\n                                            .toJsonHtml(rsp)));\n                                    return;\n                                }\n                                ctxGet.complete();\n                            });\n            this.host.send(get);\n        }\n        this.host.testWait(ctxGet);\n\n        // Let's set the service memory limit back to normal and issue more updates to ensure\n        // that the services still continue to operate as expected.\n        this.host\n                .setServiceMemoryLimit(ServiceHost.ROOT_PATH, ServiceHost.DEFAULT_PCT_MEMORY_LIMIT);\n        patchExampleServices(states, updateCount);\n\n        states.clear();\n        // Long running test. Keep adding services, expecting stop to occur and free up memory so the\n        // number of service instances exceeds available memory.\n        Date exp = new Date(TimeUnit.MICROSECONDS.toMillis(\n                Utils.getSystemNowMicrosUtc())\n                + TimeUnit.SECONDS.toMillis(this.testDurationSeconds));\n\n        this.host.setOperationTimeOutMicros(\n                TimeUnit.SECONDS.toMicros(this.host.getTimeoutSeconds()));\n\n        while (new Date().before(exp)) {\n            states = this.host.doFactoryChildServiceStart(null,\n                    this.serviceCount,\n                    ExampleServiceState.class, bodySetter, factoryURI);\n            Thread.sleep(500);\n\n            this.host.log(\"created %d services, created so far: %d, attached count: %d\",\n                    this.serviceCount,\n                    selfLinkCounter.get(),\n                    this.host.getState().serviceCount);\n            Runtime.getRuntime().gc();\n            this.host.logMemoryInfo();\n\n            File f = new File(this.host.getStorageSandbox());\n            this.host.log(\"Sandbox: %s, Disk: free %d, usable: %d, total: %d\", f.toURI(),\n                    f.getFreeSpace(),\n                    f.getUsableSpace(),\n                    f.getTotalSpace());\n\n            // let a couple of maintenance intervals run\n            Thread.sleep(TimeUnit.MICROSECONDS.toMillis(this.host.getMaintenanceIntervalMicros()) * 2);\n\n            // ping every service we created to see if they can be started\n            TestContext getCtx = this.host.testCreate(states.size());\n            for (URI u : states.keySet()) {\n                Operation get = Operation.createGet(u).setCompletion((o, e) -> {\n                    if (e == null) {\n                        getCtx.complete();\n                        return;\n                    }\n\n                    if (o.getStatusCode() == Operation.STATUS_CODE_TIMEOUT) {\n                        // check the document index, if we ever created this service\n                        try {\n                            this.host.createAndWaitSimpleDirectQuery(\n                                    ServiceDocument.FIELD_NAME_SELF_LINK, o.getUri().getPath(), 1, 1);\n                        } catch (Throwable e1) {\n                            getCtx.fail(e1);\n                            return;\n                        }\n                    }\n                    getCtx.fail(e);\n                });\n                this.host.send(get);\n            }\n            this.host.testWait(getCtx);\n\n            long limit = this.serviceCount * 30;\n            if (selfLinkCounter.get() <= limit) {\n                continue;\n            }\n\n            TestContext ctxDelete = this.host.testCreate(states.size());\n            // periodically, delete services we created (and likely stopped) several passes ago\n            for (int i = 0; i < states.size(); i++) {\n                String childPath = UriUtils.buildUriPath(factoryURI.getPath(), prefix + \"\"\n                        + (selfLinkCounter.get() - limit + i));\n                Operation delete = Operation.createDelete(this.host, childPath);\n                delete.setCompletion((o, e) -> {\n                    ctxDelete.complete();\n                });\n                this.host.send(delete);\n            }\n            ctxDelete.await();\n        }\n    }\n\n    @Test\n    public void maintenanceForOnDemandLoadServices() throws Throwable {\n        setUp(true);\n\n        long maintenanceIntervalMillis = 100;\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS\n                .toMicros(maintenanceIntervalMillis);\n\n        // induce host to clear service state cache by setting mem limit low\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n        this.host.setServiceCacheClearDelayMicros(maintenanceIntervalMicros / 2);\n        this.host.start();\n\n        EnumSet<ServiceOption> caps = EnumSet.of(ServiceOption.PERSISTENCE,\n                ServiceOption.INSTRUMENTATION, ServiceOption.ON_DEMAND_LOAD, ServiceOption.FACTORY_ITEM);\n\n        // Start the factory service. it will be needed to start services on-demand\n        MinimalFactoryTestService factoryService = new MinimalFactoryTestService();\n        factoryService.setChildServiceCaps(caps);\n        this.host.startServiceAndWait(factoryService, \"service\", null);\n\n        // Start some test services with ServiceOption.ON_DEMAND_LOAD\n        List<Service> services = this.host.doThroughputServiceStart(this.serviceCount,\n                MinimalTestService.class, this.host.buildMinimalTestState(), caps, null);\n        List<URI> statsUris = new ArrayList<>();\n        for (Service s : services) {\n            statsUris.add(UriUtils.buildStatsUri(s.getUri()));\n        }\n\n        // guarantee at least a few maintenance intervals have passed.\n        Thread.sleep(maintenanceIntervalMillis * 10);\n\n        // Let's verify now that all of the services have stopped by now.\n        this.host.waitFor(\n                \"Service stats did not get updated\",\n                () -> {\n                    Map<String, ServiceStat> stats = this.host.getServiceStats(this.host\n                            .getManagementServiceUri());\n\n                    ServiceStat odlCacheClears = stats\n                            .get(ServiceHostManagementService.STAT_NAME_ODL_CACHE_CLEAR_COUNT);\n                    if (odlCacheClears == null || odlCacheClears.latestValue < this.serviceCount) {\n                        this.host.log(\n                                \"ODL Service Cache Clears %s were less than expected %d\",\n                                odlCacheClears == null ? \"null\" : String\n                                        .valueOf(odlCacheClears.latestValue),\n                                this.serviceCount);\n                        return false;\n                    }\n\n                    ServiceStat cacheClears = stats\n                            .get(ServiceHostManagementService.STAT_NAME_SERVICE_CACHE_CLEAR_COUNT);\n                    if (cacheClears == null || cacheClears.latestValue < this.serviceCount) {\n                        this.host.log(\n                                \"Service Cache Clears %s were less than expected %d\",\n                                cacheClears == null ? \"null\" : String\n                                        .valueOf(cacheClears.latestValue),\n                                this.serviceCount);\n                        return false;\n                    }\n\n                    return true;\n                });\n    }\n\n    private void patchExampleServices(Map<URI, ExampleServiceState> states, int count)\n            throws Throwable {\n        TestContext ctx = this.host.testCreate(states.size() * count);\n        for (ExampleServiceState st : states.values()) {\n            for (int i = 0; i < count; i++) {\n                st.name = \"updated\" + Utils.getNowMicrosUtc() + \"\";\n                Operation patch = Operation\n                        .createPatch(UriUtils.buildUri(this.host, st.documentSelfLink))\n                        .setCompletion((o, e) -> {\n                            if (e != null) {\n                                ctx.fail(e);\n                                return;\n                            }\n                            ctx.complete();\n                        }).setBody(st);\n                this.host.send(patch);\n            }\n        }\n        this.host.testWait(ctx);\n    }\n\n    @Test\n    public void onDemandServiceStopCheckWithReadAndWriteAccess() throws Throwable {\n        for (int i = 0; i < this.iterationCount; i++) {\n            tearDown();\n            doOnDemandServiceStopCheckWithReadAndWriteAccess();\n        }\n    }\n\n    private void doOnDemandServiceStopCheckWithReadAndWriteAccess() throws Throwable {\n        setUp(true);\n\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS.toMicros(100);\n\n        // induce host to stop ON_DEMAND_SERVICE more often by setting maintenance interval short\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n        this.host.setServiceCacheClearDelayMicros(maintenanceIntervalMicros / 2);\n        this.host.start();\n\n        // Start some test services with ServiceOption.ON_DEMAND_LOAD\n        EnumSet<ServiceOption> caps = EnumSet.of(ServiceOption.PERSISTENCE,\n                ServiceOption.ON_DEMAND_LOAD,\n                ServiceOption.FACTORY_ITEM);\n\n        MinimalFactoryTestService factoryService = new MinimalFactoryTestService();\n        factoryService.setChildServiceCaps(caps);\n        this.host.startServiceAndWait(factoryService, \"/service\", null);\n\n        final double stopCount = getODLStopCountStat() != null ? getODLStopCountStat().latestValue : 0;\n\n        // Test DELETE works on ODL service as it works on non-ODL service.\n        // Delete on non-existent service should fail, and should not leave any side effects behind.\n        Operation deleteOp = Operation.createDelete(this.host, \"/service/foo\")\n                .setBody(new ServiceDocument());\n\n        this.host.sendAndWaitExpectFailure(deleteOp);\n\n        // create a ON_DEMAND_LOAD service\n        MinimalTestServiceState initialState = new MinimalTestServiceState();\n        initialState.id = \"foo\";\n        initialState.documentSelfLink = \"/foo\";\n        Operation startPost = Operation\n                .createPost(UriUtils.buildUri(this.host, \"/service\"))\n                .setBody(initialState);\n        this.host.sendAndWaitExpectSuccess(startPost);\n\n        String servicePath = \"/service/foo\";\n\n        // wait for the service to be stopped and stat to be populated\n        // This also verifies that ON_DEMAND_LOAD service will stop while it is idle for some duration\n        this.host.waitFor(\"Waiting ON_DEMAND_LOAD service to be stopped\",\n                () -> this.host.getServiceStage(servicePath) == null\n                        && getODLStopCountStat() != null\n                        && getODLStopCountStat().latestValue > stopCount\n        );\n        long lastODLStopTime = getODLStopCountStat().lastUpdateMicrosUtc;\n\n        int requestCount = 10;\n        int requestDelayMills = 40;\n\n        // Keep the time right before sending the last request.\n        // Use this time to check the service was not stopped at this moment. Since we keep\n        // sending the request with 40ms apart, when last request has sent, service should not\n        // be stopped(within maintenance window and cacheclear delay).\n        long beforeLastRequestSentTime = 0;\n\n        // send 10 GET request 40ms apart to make service receive GET request during a couple\n        // of maintenance windows\n        TestContext testContextForGet = this.host.testCreate(requestCount);\n        for (int i = 0; i < requestCount; i++) {\n            Operation get = Operation\n                    .createGet(this.host, servicePath)\n                    .setCompletion(testContextForGet.getCompletion());\n            beforeLastRequestSentTime = Utils.getNowMicrosUtc();\n            this.host.send(get);\n            Thread.sleep(requestDelayMills);\n        }\n        testContextForGet.await();\n\n        // wait for the service to be stopped\n        final long beforeLastGetSentTime = beforeLastRequestSentTime;\n        this.host.waitFor(\"Waiting ON_DEMAND_LOAD service to be stopped\",\n                () -> {\n                    long currentStopTime = getODLStopCountStat().lastUpdateMicrosUtc;\n                    return lastODLStopTime < currentStopTime\n                            && beforeLastGetSentTime < currentStopTime\n                            && this.host.getServiceStage(servicePath) == null;\n                }\n        );\n\n        long afterGetODLStopTime = getODLStopCountStat().lastUpdateMicrosUtc;\n\n        // send 10 update request 40ms apart to make service receive PATCH request during a couple\n        // of maintenance windows\n        TestContext ctx = this.host.testCreate(requestCount);\n        for (int i = 0; i < requestCount; i++) {\n            Operation patch = createMinimalTestServicePatch(servicePath, ctx);\n            beforeLastRequestSentTime = Utils.getNowMicrosUtc();\n            this.host.send(patch);\n            Thread.sleep(requestDelayMills);\n        }\n        ctx.await();\n\n        // wait for the service to be stopped\n        final long beforeLastPatchSentTime = beforeLastRequestSentTime;\n        this.host.waitFor(\"Waiting ON_DEMAND_LOAD service to be stopped\",\n                () -> {\n                    long currentStopTime = getODLStopCountStat().lastUpdateMicrosUtc;\n                    return afterGetODLStopTime < currentStopTime\n                            && beforeLastPatchSentTime < currentStopTime\n                            && this.host.getServiceStage(servicePath) == null;\n                }\n        );\n\n        double maintCount = getHostMaintenanceCount();\n        // issue multiple PATCHs while directly stopping a ODL service to induce collision\n        // of stop with active requests. First prevent automatic stop of ODL by extending\n        // cache clear time\n        this.host.setServiceCacheClearDelayMicros(TimeUnit.DAYS.toMicros(1));\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > maintCount + 1;\n        });\n\n\n        // first cause a on demand load (start)\n        Operation patch = createMinimalTestServicePatch(servicePath, null);\n        this.host.sendAndWaitExpectSuccess(patch);\n\n        assertEquals(ProcessingStage.AVAILABLE, this.host.getServiceStage(servicePath));\n\n        requestCount = this.requestCount;\n        // service is started. issue updates in parallel and then stop service while requests are\n        // still being issued\n        ctx = this.host.testCreate(requestCount);\n        for (int i = 0; i < requestCount; i++) {\n            patch = createMinimalTestServicePatch(servicePath, ctx);\n            this.host.send(patch);\n            if (i == Math.min(10, requestCount / 2)) {\n                Operation deleteStop = Operation.createDelete(this.host, servicePath)\n                        .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NO_INDEX_UPDATE);\n                this.host.send(deleteStop);\n            }\n        }\n        ctx.await();\n\n        verifyOnDemandLoadUpdateDeleteContention();\n    }\n\n    void verifyOnDemandLoadUpdateDeleteContention() throws Throwable {\n        Operation patch;\n        Consumer<Operation> bodySetter = (o) -> {\n            ExampleServiceState body = new ExampleServiceState();\n            body.name = \"prefix-\" + UUID.randomUUID();\n            o.setBody(body);\n        };\n        String factoryLink = OnDemandLoadFactoryService.create(this.host);\n\n        // before we start service attempt a GET on a ODL service we know does not\n        // exist. Make sure its handleStart is NOT called (we will fail the POST if handleStart\n        // is called, with no body)\n\n        Operation get = Operation.createGet(UriUtils.buildUri(\n                this.host, UriUtils.buildUriPath(factoryLink, \"does-not-exist\")));\n        this.host.sendAndWaitExpectFailure(get, Operation.STATUS_CODE_NOT_FOUND);\n\n        // create another set of services\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(\n                null,\n                this.serviceCount,\n                ExampleServiceState.class,\n                bodySetter,\n                UriUtils.buildUri(this.host, factoryLink));\n\n        // set aggressive cache clear again so ODL services stop\n        double nowCount = getHostMaintenanceCount();\n        this.host.setServiceCacheClearDelayMicros(this.host.getMaintenanceIntervalMicros() / 2);\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > nowCount + 1;\n        });\n\n        // now patch these services, while we issue deletes. The PATCHs can fail, but not\n        // the DELETEs\n        TestContext patchAndDeleteCtx = this.host.testCreate(states.size() * 2);\n        patchAndDeleteCtx.setTestName(\"Concurrent PATCH / DELETE on ODL\").logBefore();\n        for (Entry<URI, ExampleServiceState> e : states.entrySet()) {\n            patch = Operation.createPatch(e.getKey())\n                    .setBody(e.getValue())\n                    .setCompletion((o, ex) -> {\n                        patchAndDeleteCtx.complete();\n                    });\n            this.host.send(patch);\n            // in parallel send a DELETE\n            this.host.send(Operation.createDelete(e.getKey())\n                    .setCompletion(patchAndDeleteCtx.getCompletion()));\n        }\n        patchAndDeleteCtx.await();\n        patchAndDeleteCtx.logAfter();\n    }\n\n    double getHostMaintenanceCount() {\n        Map<String, ServiceStat> hostStats = this.host.getServiceStats(\n                UriUtils.buildUri(this.host, ServiceHostManagementService.SELF_LINK));\n        ServiceStat stat = hostStats.get(Service.STAT_NAME_SERVICE_HOST_MAINTENANCE_COUNT);\n        if (stat == null) {\n            return 0.0;\n        }\n        return stat.latestValue;\n    }\n\n    Operation createMinimalTestServicePatch(String servicePath, TestContext ctx) {\n        MinimalTestServiceState body = new MinimalTestServiceState();\n        body.id = Utils.buildUUID(\"foo\");\n        Operation patch = Operation\n                .createPatch(UriUtils.buildUri(this.host, servicePath))\n                .setBody(body);\n        if (ctx != null) {\n            patch.setCompletion(ctx.getCompletion());\n        }\n        return patch;\n    }\n\n    private ServiceStat getODLStopCountStat() throws Throwable {\n        URI managementServiceUri = this.host.getManagementServiceUri();\n        return this.host.getServiceStats(managementServiceUri)\n                .get(ServiceHostManagementService.STAT_NAME_ODL_STOP_COUNT);\n    }\n\n    private ServiceStat getRateLimitOpCountStat() throws Throwable {\n        URI managementServiceUri = this.host.getManagementServiceUri();\n        ServiceStat stats = this.host.getServiceStats(managementServiceUri)\n                .get(ServiceHostManagementService.STAT_NAME_RATE_LIMITED_OP_COUNT);\n        return stats;\n    }\n\n    @Test\n    public void thirdPartyClientPost() throws Throwable {\n        setUp(false);\n        this.host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        long c = 1;\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        String contentType = Operation.MEDIA_TYPE_APPLICATION_JSON;\n        for (ExampleServiceState initialState : states.values()) {\n            String json = this.host.sendWithJavaClient(\n                    UriUtils.buildUri(this.host, initialState.documentSelfLink), contentType, null);\n            ExampleServiceState javaClientRsp = Utils.fromJson(json, ExampleServiceState.class);\n            assertTrue(javaClientRsp.name.equals(initialState.name));\n        }\n\n        // Now issue POST with third party client\n        s.name = UUID.randomUUID().toString();\n        String body = Utils.toJson(s);\n        // first use proper content type\n        String json = this.host.sendWithJavaClient(factoryURI,\n                Operation.MEDIA_TYPE_APPLICATION_JSON, body);\n        ExampleServiceState javaClientRsp = Utils.fromJson(json, ExampleServiceState.class);\n        assertTrue(javaClientRsp.name.equals(s.name));\n\n        // POST to a service we know does not exist and verify our request did not get implicitly\n        // queued, but failed instantly instead\n\n        json = this.host.sendWithJavaClient(\n                UriUtils.extendUri(factoryURI, UUID.randomUUID().toString()),\n                Operation.MEDIA_TYPE_APPLICATION_JSON, null);\n\n        ServiceErrorResponse r = Utils.fromJson(json, ServiceErrorResponse.class);\n        assertEquals(Operation.STATUS_CODE_NOT_FOUND, r.statusCode);\n    }\n\n    private URI[] buildStatsUris(long serviceCount, List<Service> services) {\n        URI[] statUris = new URI[(int) serviceCount];\n        int i = 0;\n        for (Service s : services) {\n            statUris[i++] = UriUtils.extendUri(s.getUri(),\n                    ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        }\n        return statUris;\n    }\n\n    @Test\n    public void queryServiceUris() throws Throwable {\n        setUp(false);\n        int serviceCount = 5;\n        this.host.createExampleServices(this.host, serviceCount, Utils.getNowMicrosUtc());\n\n        EnumSet<ServiceOption> options = EnumSet.of(ServiceOption.INSTRUMENTATION,\n                ServiceOption.OWNER_SELECTION, ServiceOption.FACTORY_ITEM);\n\n        Operation get = Operation.createGet(this.host.getUri());\n        final ServiceDocumentQueryResult[] results = new ServiceDocumentQueryResult[1];\n\n        get.setCompletion((o, e) -> {\n            if (e != null) {\n                this.host.failIteration(e);\n                return;\n            }\n            results[0] = o.getBody(ServiceDocumentQueryResult.class);\n            this.host.completeIteration();\n        });\n\n        // use path prefix match\n        this.host.testStart(1);\n        this.host.queryServiceUris(ExampleService.FACTORY_LINK + \"/*\", get.clone());\n        this.host.testWait();\n        assertEquals(serviceCount, results[0].documentLinks.size());\n        assertEquals((long) serviceCount, (long) results[0].documentCount);\n\n        this.host.testStart(1);\n        this.host.queryServiceUris(options, true, get.clone());\n        this.host.testWait();\n        assertEquals(serviceCount, results[0].documentLinks.size());\n        assertEquals((long) serviceCount, (long) results[0].documentCount);\n        this.host.testStart(1);\n        this.host.queryServiceUris(options, false, get.clone());\n        this.host.testWait();\n        assertTrue(results[0].documentLinks.size() >= serviceCount);\n        assertEquals((long) results[0].documentLinks.size(), (long) results[0].documentCount);\n    }\n\n    @Test\n    public void queryServiceUrisWithAuth() throws Throwable {\n        setUp(true);\n        this.host.setAuthorizationService(new AuthorizationContextService());\n        this.host.setAuthorizationEnabled(true);\n        this.host.start();\n\n        AuthTestUtils.setSystemAuthorizationContext(this.host);\n\n        // Start Statefull with Non-Persisted service\n        this.host.startFactory(new ExampleNonPersistedService());\n        this.host.waitForServiceAvailable(ExampleNonPersistedService.FACTORY_LINK);\n\n        TestRequestSender sender = this.host.getTestRequestSender();\n\n        // create user foo@example.com who has access to ExampleServiceState with name=\"foo\"\n        TestContext createUserFoo = this.host.testCreate(1);\n        String userFoo = \"foo@example.com\";\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserEmail(userFoo)\n                .setUserSelfLink(userFoo)\n                .setUserPassword(\"password\")\n                .setResourceQuery(Query.Builder.create()\n                        .addFieldClause(ServiceDocument.FIELD_NAME_KIND, Utils.buildKind(ExampleServiceState.class))\n                        .addFieldClause(ExampleServiceState.FIELD_NAME_NAME, \"foo\")\n                        .build())\n                .setCompletion(createUserFoo.getCompletion())\n                .start();\n        createUserFoo.await();\n\n        // create user bar@example.com who has access to ExampleServiceState with name=\"foo\"\n        TestContext createUserBar = this.host.testCreate(1);\n        String userBar = \"bar@example.com\";\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserEmail(userBar)\n                .setUserSelfLink(userBar)\n                .setUserPassword(\"password\")\n                .setResourceQuery(Query.Builder.create()\n                        .addFieldClause(ServiceDocument.FIELD_NAME_KIND, Utils.buildKind(ExampleServiceState.class))\n                        .addFieldClause(ExampleServiceState.FIELD_NAME_NAME, \"bar\")\n                        .build())\n                .setCompletion(createUserBar.getCompletion())\n                .start();\n        createUserBar.await();\n\n        // create foo & bar documents\n        ExampleServiceState exampleFoo = new ExampleServiceState();\n        exampleFoo.name = \"foo\";\n        exampleFoo.documentSelfLink = \"foo\";\n\n        ExampleServiceState exampleBar = new ExampleServiceState();\n        exampleBar.name = \"bar\";\n        exampleBar.documentSelfLink = \"bar\";\n\n        List<Operation> posts = new ArrayList<>();\n        posts.add(Operation.createPost(this.host, ExampleNonPersistedService.FACTORY_LINK).setBody(exampleFoo));\n        posts.add(Operation.createPost(this.host, ExampleNonPersistedService.FACTORY_LINK).setBody(exampleBar));\n        sender.sendAndWait(posts);\n\n        AuthTestUtils.resetAuthorizationContext(this.host);\n\n        // login as foo\n        AuthTestUtils.loginAndSetToken(this.host, \"foo@example.com\", \"password\");\n\n        Operation factoryGetFoo = Operation.createGet(this.host, ExampleNonPersistedService.FACTORY_LINK);\n        ServiceDocumentQueryResult factoryGetResultFoo = sender.sendAndWait(factoryGetFoo, ServiceDocumentQueryResult.class);\n        assertEquals(1, factoryGetResultFoo.documentLinks.size());\n        assertEquals(\"/core/nonpersist-examples/foo\", factoryGetResultFoo.documentLinks.get(0));\n\n\n        // login as bar\n        AuthTestUtils.loginAndSetToken(this.host, \"bar@example.com\", \"password\");\n        Operation factoryGetBar = Operation.createGet(this.host, ExampleNonPersistedService.FACTORY_LINK);\n        ServiceDocumentQueryResult factoryGetResultBar = sender.sendAndWait(factoryGetBar, ServiceDocumentQueryResult.class);\n        assertEquals(1, factoryGetResultBar.documentLinks.size());\n        assertEquals(\"/core/nonpersist-examples/bar\", factoryGetResultBar.documentLinks.get(0));\n    }\n\n    /**\n     * This test verify the custom Ui path resource of service\n     **/\n    @Test\n    public void testServiceCustomUIPath() throws Throwable {\n        setUp(false);\n        String resourcePath = \"customUiPath\";\n        // Service with custom path\n        class CustomUiPathService extends StatelessService {\n            public static final String SELF_LINK = \"/custom\";\n\n            public CustomUiPathService() {\n                super();\n                toggleOption(ServiceOption.HTML_USER_INTERFACE, true);\n            }\n\n            @Override\n            public ServiceDocument getDocumentTemplate() {\n                ServiceDocument serviceDocument = new ServiceDocument();\n                serviceDocument.documentDescription = new ServiceDocumentDescription();\n                serviceDocument.documentDescription.userInterfaceResourcePath = resourcePath;\n                return serviceDocument;\n            }\n        }\n\n        // Starting the  CustomUiPathService service\n        this.host.startServiceAndWait(new CustomUiPathService(), CustomUiPathService.SELF_LINK, null);\n\n        String htmlPath = \"/user-interface/resources/\" + resourcePath + \"/custom.html\";\n        // Sending get request for html\n        String htmlResponse = this.host.sendWithJavaClient(\n                UriUtils.buildUri(this.host, htmlPath),\n                Operation.MEDIA_TYPE_TEXT_HTML, null);\n\n        assertEquals(\"<html>customHtml</html>\", htmlResponse);\n    }\n\n    @Test\n    public void testRootUiService() throws Throwable {\n        setUp(false);\n\n        // Stopping the RootNamespaceService\n        this.host.waitForResponse(Operation\n                .createDelete(UriUtils.buildUri(this.host, UriUtils.URI_PATH_CHAR)));\n\n        class RootUiService extends UiFileContentService {\n            public static final String SELF_LINK = UriUtils.URI_PATH_CHAR;\n        }\n\n        // Starting the CustomUiService service\n        this.host.startServiceAndWait(new RootUiService(), RootUiService.SELF_LINK, null);\n\n        // Loading the default page\n        Operation result = this.host.waitForResponse(Operation\n                .createGet(UriUtils.buildUri(this.host, RootUiService.SELF_LINK)));\n        assertEquals(\"<html><title>Root</title></html>\", result.getBodyRaw());\n    }\n\n    @Test\n    public void testClientSideRouting() throws Throwable {\n        setUp(false);\n\n        class AppUiService extends UiFileContentService {\n            public static final String SELF_LINK = \"/app\";\n        }\n\n        // Starting the AppUiService service\n        AppUiService s = new AppUiService();\n        this.host.startServiceAndWait(s, AppUiService.SELF_LINK, null);\n\n        // Finding the default page file\n        Path baseResourcePath = Utils.getServiceUiResourcePath(s);\n        Path baseUriPath = Paths.get(AppUiService.SELF_LINK);\n        String prefix = baseResourcePath.toString().replace('\\\\', '/');\n        Map<Path, String> pathToURIPath = new HashMap<>();\n        this.host.discoverJarResources(baseResourcePath, s, pathToURIPath, baseUriPath, prefix);\n        File defaultFile = pathToURIPath.entrySet()\n                .stream()\n                .filter((entry) -> {\n                    return entry.getValue().equals(AppUiService.SELF_LINK +\n                            UriUtils.URI_PATH_CHAR + ServiceUriPaths.UI_RESOURCE_DEFAULT_FILE);\n                })\n                .map(Map.Entry::getKey)\n                .findFirst()\n                .get()\n                .toFile();\n\n        List<String> routes = Arrays.asList(\"/app/1\", \"/app/2\");\n\n        // Starting all route services\n        for (String route : routes) {\n            this.host.startServiceAndWait(new FileContentService(defaultFile), route, null);\n        }\n\n        // Loading routes\n        for (String route : routes) {\n            Operation result = this.host.waitForResponse(Operation\n                    .createGet(UriUtils.buildUri(this.host, route)));\n            assertEquals(\"<html><title>App</title></html>\", result.getBodyRaw());\n        }\n\n        // Loading the about page\n        Operation about = this.host.waitForResponse(Operation\n                .createGet(UriUtils.buildUri(this.host, AppUiService.SELF_LINK + \"/about.html\")));\n        assertEquals(\"<html><title>About</title></html>\", about.getBodyRaw());\n    }\n\n    @Test\n    public void httpScheme() throws Throwable {\n        setUp(true);\n\n        // SSL config for https\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        this.host.setCertificateFileReference(ssc.certificate().toURI());\n        this.host.setPrivateKeyFileReference(ssc.privateKey().toURI());\n\n        assertEquals(\"before starting, scheme is NONE\", ServiceHost.HttpScheme.NONE,\n                this.host.getCurrentHttpScheme());\n\n        this.host.setPort(0);\n        this.host.setSecurePort(0);\n        this.host.start();\n\n        ServiceRequestListener httpListener = this.host.getListener();\n        ServiceRequestListener httpsListener = this.host.getSecureListener();\n\n        assertTrue(\"http listener should be on\", httpListener.isListening());\n        assertTrue(\"https listener should be on\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTP_AND_HTTPS, this.host.getCurrentHttpScheme());\n        assertTrue(\"public uri scheme should be HTTP\",\n                this.host.getPublicUri().getScheme().equals(\"http\"));\n\n        httpsListener.stop();\n        assertTrue(\"http listener should be on \", httpListener.isListening());\n        assertFalse(\"https listener should be off\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTP_ONLY, this.host.getCurrentHttpScheme());\n        assertTrue(\"public uri scheme should be HTTP\",\n                this.host.getPublicUri().getScheme().equals(\"http\"));\n\n        httpListener.stop();\n        assertFalse(\"http listener should be off\", httpListener.isListening());\n        assertFalse(\"https listener should be off\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.NONE, this.host.getCurrentHttpScheme());\n\n        // re-start listener even host is stopped, verify getCurrentHttpScheme only\n        httpsListener.start(0, ServiceHost.LOOPBACK_ADDRESS);\n        assertFalse(\"http listener should be off\", httpListener.isListening());\n        assertTrue(\"https listener should be on\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTPS_ONLY, this.host.getCurrentHttpScheme());\n        httpsListener.stop();\n\n        this.host.stop();\n        // set HTTP port to disabled, restart host. Verify scheme is HTTPS only. We must\n        // set both HTTP and secure port, to null out the listeners from the host instance.\n        this.host.setPort(ServiceHost.PORT_VALUE_LISTENER_DISABLED);\n        this.host.setSecurePort(0);\n        VerificationHost.createAndAttachSSLClient(this.host);\n        this.host.start();\n\n        httpListener = this.host.getListener();\n        httpsListener = this.host.getSecureListener();\n\n        assertTrue(\"http listener should be null, default port value set to disabled\",\n                httpListener == null);\n        assertTrue(\"https listener should be on\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTPS_ONLY, this.host.getCurrentHttpScheme());\n        assertTrue(\"public uri scheme should be HTTPS\",\n                this.host.getPublicUri().getScheme().equals(\"https\"));\n    }\n\n    @Test\n    public void create() throws Throwable {\n        ServiceHost h = ServiceHost.create(\"--port=0\");\n        try {\n            h.start();\n            h.startDefaultCoreServicesSynchronously();\n\n            // Start the example service factory\n            h.startFactory(ExampleService.class, ExampleService::createFactory);\n\n            boolean[] isReady = new boolean[1];\n            h.registerForServiceAvailability((o, e) -> {\n                isReady[0] = true;\n            }, ExampleService.FACTORY_LINK);\n\n\n            Duration timeout = Duration.of(ServiceHost.ServiceHostState.DEFAULT_MAINTENANCE_INTERVAL_MICROS * 5, ChronoUnit.MICROS);\n            TestContext.waitFor(timeout, () -> {\n                return isReady[0];\n            }, \"ExampleService did not start\");\n\n            // verify ExampleService exists\n            TestRequestSender sender = new TestRequestSender(h);\n            Operation get = Operation.createGet(h, ExampleService.FACTORY_LINK);\n            sender.sendAndWait(get);\n        } finally {\n            if (h != null) {\n                h.unregisterRuntimeShutdownHook();\n                h.stop();\n            }\n        }\n    }\n\n    @Test\n    public void restartAndVerifyManagementService() throws Throwable {\n        setUp(false);\n\n        // management service should be accessible\n        Operation get = Operation.createGet(this.host, ServiceUriPaths.CORE_MANAGEMENT);\n        this.host.getTestRequestSender().sendAndWait(get);\n\n        // restart\n        this.host.stop();\n        this.host.setPort(0);\n        this.host.start();\n\n        // verify management service is accessible.\n        get = Operation.createGet(this.host, ServiceUriPaths.CORE_MANAGEMENT);\n        this.host.getTestRequestSender().sendAndWait(get);\n    }\n\n    @After\n    public void tearDown() throws IOException {\n        LuceneDocumentIndexService.setIndexFileCountThresholdForWriterRefresh(\n                LuceneDocumentIndexService\n                        .DEFAULT_INDEX_FILE_COUNT_THRESHOLD_FOR_WRITER_REFRESH);\n\n        if (this.host == null) {\n            return;\n        }\n\n        if (!this.host.isStopping()) {\n            AuthTestUtils.logout(this.host);\n        }\n        this.host.tearDown();\n        this.host = null;\n    }\n\n\n    @Test\n    public void authorizeRequestOnOwnerSelectionService() throws Throwable {\n        setUp(true);\n\n        this.host.setAuthorizationService(new AuthorizationContextService());\n        this.host.setAuthorizationEnabled(true);\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n        this.host.start();\n\n        AuthTestUtils.setSystemAuthorizationContext(this.host);\n\n        // Start Statefull with Non-Persisted service\n        this.host.startFactory(new AuthCheckService());\n        this.host.waitForServiceAvailable(AuthCheckService.FACTORY_LINK);\n\n        TestRequestSender sender = this.host.getTestRequestSender();\n\n\n        this.host.setSystemAuthorizationContext();\n\n        String adminUser = \"admin@vmware.com\";\n        String adminPass = \"password\";\n        TestContext authCtx = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserEmail(adminUser)\n                .setUserPassword(adminPass)\n                .setIsAdmin(true)\n                .setCompletion(authCtx.getCompletion())\n                .start();\n        authCtx.await();\n\n        // create foo\n        ExampleServiceState exampleFoo = new ExampleServiceState();\n        exampleFoo.name = \"foo\";\n        exampleFoo.documentSelfLink = \"foo\";\n\n        Operation post = Operation.createPost(this.host, AuthCheckService.FACTORY_LINK).setBody(exampleFoo);\n        ExampleServiceState postResult = sender.sendAndWait(post, ExampleServiceState.class);\n\n        URI statsUri = UriUtils.buildUri(this.host, postResult.documentSelfLink);\n\n        ServiceStats stats = sender.sendStatsGetAndWait(statsUri);\n        assertFalse(stats.entries.containsKey(AuthCheckService.IS_AUTHORIZE_REQUEST_CALLED));\n\n        this.host.resetAuthorizationContext();\n\n        TestRequestSender.FailureResponse failureResponse = sender.sendAndWaitFailure(Operation.createGet(this.host, postResult.documentSelfLink));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n\n        this.host.setSystemAuthorizationContext();\n\n        stats = sender.sendStatsGetAndWait(statsUri);\n        ServiceStat stat = stats.entries.get(AuthCheckService.IS_AUTHORIZE_REQUEST_CALLED);\n        assertNotNull(stat);\n        assertEquals(1, stat.latestValue, 0);\n\n        this.host.resetAuthorizationContext();\n\n    }\n\n}\n", "target": 0}
{"idx": 998, "func": "package org.uberfire.io.regex;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.AfterClass;\nimport org.junit.Assert;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.uberfire.io.CommonIOServiceDotFileTest;\nimport org.uberfire.io.IOService;\nimport org.uberfire.io.impl.IOServiceDotFileImpl;\nimport org.uberfire.java.nio.file.Path;\nimport org.uberfire.java.nio.file.Paths;\n\nimport static org.uberfire.io.regex.AntPathMatcher.*;\n\npublic class AntPathMatcherTest {\n\n    final static IOService ioService = new IOServiceDotFileImpl();\n    private static File path = null;\n\n    @BeforeClass\n    public static void setup() throws IOException {\n        path = CommonIOServiceDotFileTest.createTempDirectory();\n        System.setProperty( \"org.uberfire.nio.git.dir\", path.getAbsolutePath() );\n        System.out.println( \".niogit: \" + path.getAbsolutePath() );\n\n        final URI newRepo = URI.create( \"git://antpathmatcher\" );\n\n        ioService.newFileSystem( newRepo, new HashMap<String, Object>() );\n    }\n\n    @AfterClass\n    @BeforeClass\n    public static void cleanup() {\n        if ( path != null ) {\n            FileUtils.deleteQuietly( path );\n        }\n    }\n\n    @Test\n    public void testIncludes() {\n        final Collection<String> patterns = new ArrayList<String>() {{\n            add( \"git://**\" );\n            add( \"**/repo/**\" );\n        }};\n\n        {\n            final Path path = Paths.get( URI.create( \"file:///Users/home\" ) );\n            Assert.assertFalse( includes( patterns, path ) );\n        }\n\n        {\n            final Path path = Paths.get( URI.create( \"git://antpathmatcher\" ) );\n            Assert.assertTrue( includes( patterns, path ) );\n        }\n\n        {\n            final Path path = Paths.get( URI.create( \"git://master@antpathmatcher\" ) );\n            Assert.assertTrue( includes( patterns, path ) );\n        }\n    }\n\n    @Test\n    public void testIncludesMid() {\n        final Collection<String> patterns = new ArrayList<String>() {{\n            add( \"default://**\" );\n            add( \"**/repo/**\" );\n        }};\n\n        {\n            final Path path = Paths.get( URI.create( \"file:///Users/home\" ) );\n            Assert.assertTrue( includes( patterns, path ) );\n        }\n\n        {\n            final Path path = Paths.get( URI.create( \"git://antpathmatcher\" ) );\n            Assert.assertFalse( includes( patterns, path ) );\n        }\n\n        {\n            final Path path = Paths.get( URI.create( \"git://master@antpathmatcher/repo/sss\" ) );\n            Assert.assertTrue( includes( patterns, path ) );\n        }\n    }\n\n    @Test\n    public void testExcludes() {\n        final Collection<String> patterns = new ArrayList<String>() {{\n            add( \"git://**\" );\n            add( \"**/repo/**\" );\n        }};\n\n        {\n            final Path path = Paths.get( URI.create( \"file:///Users/home\" ) );\n            Assert.assertFalse( excludes( patterns, path ) );\n        }\n\n        {\n            final Path path = Paths.get( URI.create( \"git://antpathmatcher\" ) );\n            Assert.assertTrue( excludes( patterns, path ) );\n        }\n\n        {\n            final Path path = Paths.get( URI.create( \"git://master@antpathmatcher\" ) );\n            Assert.assertTrue( excludes( patterns, path ) );\n        }\n    }\n\n    @Test\n    public void testExcludesMid() {\n        final Collection<String> patterns = new ArrayList<String>() {{\n            add( \"default://**\" );\n            add( \"**/repo/**\" );\n        }};\n\n        {\n            final Path path = Paths.get( URI.create( \"file:///Users/home\" ) );\n            Assert.assertTrue( excludes( patterns, path ) );\n        }\n\n        {\n            final Path path = Paths.get( URI.create( \"git://antpathmatcher\" ) );\n            Assert.assertFalse( excludes( patterns, path ) );\n        }\n\n        {\n            final Path path = Paths.get( URI.create( \"git://master@antpathmatcher/repo/sss\" ) );\n            Assert.assertTrue( excludes( patterns, path ) );\n        }\n    }\n\n    @Test\n    public void testFilter() {\n        final Collection<String> includes = new ArrayList<String>() {{\n            add( \"git://**\" );\n        }};\n        final Collection<String> excludes = new ArrayList<String>() {{\n            add( \"default://**\" );\n        }};\n\n        {\n            final Path path = Paths.get( URI.create( \"file:///Users/home\" ) );\n            Assert.assertFalse( filter( includes, excludes, path ) );\n        }\n\n        {\n            final Path path = Paths.get( URI.create( \"git://antpathmatcher\" ) );\n            Assert.assertTrue( filter( includes, excludes, path ) );\n        }\n\n        {\n            final Path path = Paths.get( URI.create( \"git://master@antpathmatcher/repo/sss\" ) );\n            Assert.assertTrue( filter( includes, excludes, path ) );\n        }\n\n        Assert.assertTrue( filter( Collections.<String>emptyList(), Collections.<String>emptyList(), Paths.get( URI.create( \"git://master@antpathmatcher/repo/sss\" ) ) ) );\n        Assert.assertTrue( filter( Collections.<String>emptyList(), Collections.<String>emptyList(), Paths.get( URI.create( \"git://antpathmatcher\" ) ) ) );\n    }\n\n    @Test\n    public void testIncludesUri() {\n        final Collection<String> patterns = new ArrayList<String>() {{\n            add( \"git://**\" );\n            add( \"**/repo/**\" );\n        }};\n\n        Assert.assertFalse( includes( patterns, URI.create( \"file:///Users/home\" ) ) );\n\n        Assert.assertTrue( includes( patterns, URI.create( \"git://antpathmatcher\" ) ) );\n\n        Assert.assertTrue( includes( patterns, URI.create( \"git://master@antpathmatcher\" ) ) );\n    }\n\n    @Test\n    public void testIncludesMidUri() {\n        final Collection<String> patterns = new ArrayList<String>() {{\n            add( \"file://**\" );\n            add( \"**/repo/**\" );\n        }};\n\n        Assert.assertTrue( includes( patterns, URI.create( \"file:///Users/home\" ) ) );\n\n        Assert.assertFalse( includes( patterns, URI.create( \"git://antpathmatcher\" ) ) );\n\n        Assert.assertTrue( includes( patterns, URI.create( \"git://master@antpathmatcher/repo/sss\" ) ) );\n    }\n\n    @Test\n    public void testExcludesUri() {\n        final Collection<String> patterns = new ArrayList<String>() {{\n            add( \"git://**\" );\n            add( \"**/repo/**\" );\n        }};\n\n        Assert.assertFalse( excludes( patterns, URI.create( \"file:///Users/home\" ) ) );\n\n        Assert.assertTrue( excludes( patterns, URI.create( \"git://antpathmatcher\" ) ) );\n\n        Assert.assertTrue( excludes( patterns, URI.create( \"git://master@antpathmatcher\" ) ) );\n    }\n\n    @Test\n    public void testExcludesMidUri() {\n        final Collection<String> patterns = new ArrayList<String>() {{\n            add( \"file://**\" );\n            add( \"**/repo/**\" );\n        }};\n\n        Assert.assertTrue( excludes( patterns, URI.create( \"file:///Users/home\" ) ) );\n\n        Assert.assertFalse( excludes( patterns, URI.create( \"git://antpathmatcher\" ) ) );\n\n        Assert.assertTrue( excludes( patterns, URI.create( \"git://master@antpathmatcher/repo/sss\" ) ) );\n    }\n\n    @Test\n    public void testFilterUri() {\n        final Collection<String> includes = new ArrayList<String>() {{\n            add( \"git://**\" );\n        }};\n        final Collection<String> excludes = new ArrayList<String>() {{\n            add( \"file://**\" );\n        }};\n\n        Assert.assertFalse( filter( includes, excludes, URI.create( \"file:///Users/home\" ) ) );\n\n        Assert.assertTrue( filter( includes, excludes, URI.create( \"git://antpathmatcher\" ) ) );\n\n        Assert.assertTrue( filter( includes, excludes, URI.create( \"git://master@antpathmatcher/repo/sss\" ) ) );\n\n        Assert.assertTrue( filter( Collections.<String>emptyList(), Collections.<String>emptyList(), URI.create( \"file:///Users/home\" ) ) );\n\n        Assert.assertTrue( filter( Collections.<String>emptyList(), Collections.<String>emptyList(), URI.create( \"git://master@antpathmatcher/repo/sss\" ) ) );\n\n    }\n}\n", "target": 0}
{"idx": 999, "func": "package org.openmrs.module.htmlformentry.web.controller;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.StringWriter;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.SystemUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.openmrs.Patient;\nimport org.openmrs.api.context.Context;\nimport org.openmrs.module.htmlformentry.FormEntryContext.Mode;\nimport org.openmrs.module.htmlformentry.FormEntrySession;\nimport org.openmrs.module.htmlformentry.HtmlForm;\nimport org.openmrs.module.htmlformentry.HtmlFormEntryUtil;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.web.multipart.MultipartHttpServletRequest;\n\n/**\n * The controller for previewing a HtmlForm by loading the xml file that defines that HtmlForm from\n * disk.\n * <p/>\n * Handles {@code htmlFormFromFile.form} requests. Renders view {@code htmlFormFromFile.jsp}.\n */\n@Controller\npublic class HtmlFormFromFileController {\n\t\n\tprivate static final String TEMP_HTML_FORM_FILE_PREFIX = \"html_form_\";\n\t\n\t/** Logger for this class and subclasses */\n\tprotected final Log log = LogFactory.getLog(getClass());\n\t\n\t@RequestMapping(\"/module/htmlformentry/htmlFormFromFile.form\")\n\tpublic void handleRequest(Model model, @RequestParam(value = \"filePath\", required = false) String filePath,\n\t                          @RequestParam(value = \"patientId\", required = false) Integer pId,\n\t                          @RequestParam(value = \"isFileUpload\", required = false) boolean isFileUpload,\n\t                          HttpServletRequest request) throws Exception {\n\n        Context.requirePrivilege(\"Manage Forms\");\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"In reference data...\");\n\t\t\n\t\tmodel.addAttribute(\"previewHtml\", \"\");\n\t\tString message = \"\";\n\t\tFile f = null;\n\t\ttry {\n\t\t\tif (isFileUpload) {\n\t\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\t\tMultipartFile multipartFile = multipartRequest.getFile(\"htmlFormFile\");\n\t\t\t\tif (multipartFile != null) {\n\t\t\t\t\t//use the same file for the logged in user\n\t\t\t\t\tf = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX\n\t\t\t\t\t        + Context.getAuthenticatedUser().getSystemId());\n\t\t\t\t\tif (!f.exists())\n\t\t\t\t\t\tf.createNewFile();\n\t\t\t\t\t\n\t\t\t\t\tfilePath = f.getAbsolutePath();\n\t\t\t\t\tFileOutputStream fileOut = new FileOutputStream(f);\n\t\t\t\t\tIOUtils.copy(multipartFile.getInputStream(), fileOut);\n\t\t\t\t\tfileOut.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (StringUtils.hasText(filePath)) {\n\t\t\t\t\tf = new File(filePath);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = \"You must specify a file path to preview from file\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f != null && f.exists() && f.canRead()) {\n\t\t\t\tmodel.addAttribute(\"filePath\", filePath);\n\t\t\t\t\n\t\t\t\tStringWriter writer = new StringWriter();\n\t\t\t\tIOUtils.copy(new FileInputStream(f), writer, \"UTF-8\");\n\t\t\t\tString xml = writer.toString();\n\t\t\t\t\n\t\t\t\tPatient p = null;\n\t\t\t\tif (pId != null) {\n\t\t\t\t\tp = Context.getPatientService().getPatient(pId);\n\t\t\t\t} else {\n\t\t\t\t\tp = HtmlFormEntryUtil.getFakePerson();\n\t\t\t\t}\n\t\t\t\tHtmlForm fakeForm = new HtmlForm();\n\t\t\t\tfakeForm.setXmlData(xml);\n\t\t\t\tFormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());\n\t\t\t\tString html = fes.getHtmlToDisplay();\n\t\t\t\tif (fes.getFieldAccessorJavascript() != null) {\n                \thtml += \"<script>\" + fes.getFieldAccessorJavascript() + \"</script>\";\n                }\n\t\t\t\tmodel.addAttribute(\"previewHtml\", html);\n\t\t\t\t//clear the error message\n\t\t\t\tmessage = \"\";\n\t\t\t} else {\n\t\t\t\tmessage = \"Please specify a valid file path or select a valid file.\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\"An error occurred while loading the html.\", e);\n\t\t\tmessage = \"An error occurred while loading the html. \" + e.getMessage();\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\"message\", message);\n\t\tmodel.addAttribute(\"isFileUpload\", isFileUpload);\n\t}\n}\n", "target": 0}
{"idx": 1000, "func": "/*\n * Copyright (c) 2011-2017 Contributors to the Eclipse Foundation\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n * which is available at https://www.apache.org/licenses/LICENSE-2.0.\n *\n * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n */\n\npackage io.vertx.core.http.impl;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.vertx.codegen.annotations.Nullable;\nimport io.vertx.core.AsyncResult;\nimport io.vertx.core.Context;\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.core.MultiMap;\nimport io.vertx.core.VertxException;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.http.HttpMethod;\nimport io.vertx.core.http.HttpServerResponse;\nimport io.vertx.core.http.StreamResetException;\nimport io.vertx.core.logging.Logger;\nimport io.vertx.core.logging.LoggerFactory;\nimport io.vertx.core.net.impl.ConnectionBase;\nimport io.vertx.core.spi.metrics.HttpServerMetrics;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\n\nimport static io.vertx.core.spi.metrics.Metrics.METRICS_ENABLED;\n\n/**\n * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n */\npublic class Http2ServerResponseImpl implements HttpServerResponse {\n\n  private static final Logger log = LoggerFactory.getLogger(Http2ServerResponseImpl.class);\n\n  private final VertxHttp2Stream stream;\n  private final ChannelHandlerContext ctx;\n  private final Http2ServerConnection conn;\n  private final boolean push;\n  private final Object metric;\n  private final String host;\n  private Http2Headers headers = new DefaultHttp2Headers();\n  private Http2HeadersAdaptor headersMap;\n  private Http2Headers trailers;\n  private Http2HeadersAdaptor trailedMap;\n  private boolean chunked;\n  private boolean headWritten;\n  private boolean ended;\n  private int statusCode = 200;\n  private String statusMessage; // Not really used but we keep the message for the getStatusMessage()\n  private Handler<Void> drainHandler;\n  private Handler<Throwable> exceptionHandler;\n  private Handler<Void> headersEndHandler;\n  private Handler<Void> bodyEndHandler;\n  private Handler<Void> closeHandler;\n  private Handler<Void> endHandler;\n  private long bytesWritten;\n  private int numPush;\n  private boolean inHandler;\n\n  public Http2ServerResponseImpl(Http2ServerConnection conn, VertxHttp2Stream stream, Object metric, boolean push, String contentEncoding, String host) {\n\n    this.metric = metric;\n    this.stream = stream;\n    this.ctx = conn.handlerContext;\n    this.conn = conn;\n    this.push = push;\n    this.host = host;\n\n    if (contentEncoding != null) {\n      putHeader(HttpHeaderNames.CONTENT_ENCODING, contentEncoding);\n    }\n  }\n\n  public Http2ServerResponseImpl(\n      Http2ServerConnection conn,\n      VertxHttp2Stream stream,\n      HttpMethod method,\n      String path,\n      boolean push,\n      String contentEncoding) {\n    this.stream = stream;\n    this.ctx = conn.handlerContext;\n    this.conn = conn;\n    this.push = push;\n    this.host = null;\n\n    if (contentEncoding != null) {\n      putHeader(HttpHeaderNames.CONTENT_ENCODING, contentEncoding);\n    }\n\n    HttpServerMetrics metrics = conn.metrics();\n    this.metric = (METRICS_ENABLED && metrics != null) ? metrics.responsePushed(conn.metric(), method, path, this) : null;\n  }\n\n  synchronized void beginRequest() {\n    inHandler = true;\n  }\n\n  synchronized boolean endRequest() {\n    inHandler = false;\n    return numPush > 0;\n  }\n\n  void callReset(long code) {\n    handleEnded(true);\n    handleError(new StreamResetException(code));\n  }\n\n  void handleError(Throwable cause) {\n    if (exceptionHandler != null) {\n      exceptionHandler.handle(cause);\n    }\n  }\n\n  void handleClose() {\n    handleEnded(true);\n  }\n\n  private void checkHeadWritten() {\n    if (headWritten) {\n      throw new IllegalStateException(\"Header already sent\");\n    }\n  }\n\n  @Override\n  public HttpServerResponse exceptionHandler(Handler<Throwable> handler) {\n    synchronized (conn) {\n      if (handler != null) {\n        checkEnded();\n      }\n      exceptionHandler = handler;\n      return this;\n    }\n  }\n\n  @Override\n  public int getStatusCode() {\n    synchronized (conn) {\n      return statusCode;\n    }\n  }\n\n  @Override\n  public HttpServerResponse setStatusCode(int statusCode) {\n    if (statusCode < 0) {\n      throw new IllegalArgumentException(\"code: \" + statusCode + \" (expected: 0+)\");\n    }\n    synchronized (conn) {\n      checkHeadWritten();\n      this.statusCode = statusCode;\n      return this;\n    }\n  }\n\n  @Override\n  public String getStatusMessage() {\n    synchronized (conn) {\n      if (statusMessage == null) {\n        return HttpResponseStatus.valueOf(statusCode).reasonPhrase();\n      }\n      return statusMessage;\n    }\n  }\n\n  @Override\n  public HttpServerResponse setStatusMessage(String statusMessage) {\n    synchronized (conn) {\n      checkHeadWritten();\n      this.statusMessage = statusMessage;\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse setChunked(boolean chunked) {\n    synchronized (conn) {\n      checkHeadWritten();\n      this.chunked = true;\n      return this;\n    }\n  }\n\n  @Override\n  public boolean isChunked() {\n    synchronized (conn) {\n      return chunked;\n    }\n  }\n\n  @Override\n  public MultiMap headers() {\n    synchronized (conn) {\n      if (headersMap == null) {\n        headersMap = new Http2HeadersAdaptor(headers);\n      }\n      return headersMap;\n    }\n  }\n\n  @Override\n  public HttpServerResponse putHeader(String name, String value) {\n    synchronized (conn) {\n      checkHeadWritten();\n      headers().set(name, value);\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse putHeader(CharSequence name, CharSequence value) {\n    synchronized (conn) {\n      checkHeadWritten();\n      headers().set(name, value);\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse putHeader(String name, Iterable<String> values) {\n    synchronized (conn) {\n      checkHeadWritten();\n      headers().set(name, values);\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse putHeader(CharSequence name, Iterable<CharSequence> values) {\n    synchronized (conn) {\n      checkHeadWritten();\n      headers().set(name, values);\n      return this;\n    }\n  }\n\n  @Override\n  public MultiMap trailers() {\n    synchronized (conn) {\n      if (trailedMap == null) {\n        trailedMap = new Http2HeadersAdaptor(trailers = new DefaultHttp2Headers());\n      }\n      return trailedMap;\n    }\n  }\n\n  @Override\n  public HttpServerResponse putTrailer(String name, String value) {\n    synchronized (conn) {\n      checkEnded();\n      trailers().set(name, value);\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse putTrailer(CharSequence name, CharSequence value) {\n    synchronized (conn) {\n      checkEnded();\n      trailers().set(name, value);\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse putTrailer(String name, Iterable<String> values) {\n    synchronized (conn) {\n      checkEnded();\n      trailers().set(name, values);\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse putTrailer(CharSequence name, Iterable<CharSequence> value) {\n    synchronized (conn) {\n      checkEnded();\n      trailers().set(name, value);\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse closeHandler(Handler<Void> handler) {\n    synchronized (conn) {\n      if (handler != null) {\n        checkEnded();\n      }\n      closeHandler = handler;\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse endHandler(@Nullable Handler<Void> handler) {\n    synchronized (conn) {\n      if (handler != null) {\n        checkEnded();\n      }\n      endHandler = handler;\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse writeContinue() {\n    synchronized (conn) {\n      checkHeadWritten();\n      stream.writeHeaders(new DefaultHttp2Headers().status(\"100\"), false);\n      ctx.flush();\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse write(Buffer chunk) {\n    ByteBuf buf = chunk.getByteBuf();\n    return write(buf);\n  }\n\n  @Override\n  public HttpServerResponse write(String chunk, String enc) {\n    return write(Buffer.buffer(chunk, enc).getByteBuf());\n  }\n\n  @Override\n  public HttpServerResponse write(String chunk) {\n    return write(Buffer.buffer(chunk).getByteBuf());\n  }\n\n  private Http2ServerResponseImpl write(ByteBuf chunk) {\n    write(chunk, false);\n    return this;\n  }\n\n  @Override\n  public void end(String chunk) {\n    end(Buffer.buffer(chunk));\n  }\n\n  @Override\n  public void end(String chunk, String enc) {\n    end(Buffer.buffer(chunk, enc));\n  }\n\n  @Override\n  public void end(Buffer chunk) {\n    end(chunk.getByteBuf());\n  }\n\n  @Override\n  public void end() {\n    end((ByteBuf) null);\n  }\n\n  void toNetSocket() {\n    checkEnded();\n    checkSendHeaders(false);\n    handleEnded(false);\n  }\n\n  private void end(ByteBuf chunk) {\n    synchronized (conn) {\n      write(chunk, true);\n    }\n  }\n\n  private boolean checkSendHeaders(boolean end) {\n    if (!headWritten) {\n      if (headersEndHandler != null) {\n        headersEndHandler.handle(null);\n      }\n      headWritten = true;\n      headers.status(Integer.toString(statusCode));\n      stream.writeHeaders(headers, end);\n      if (end) {\n        ctx.flush();\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  void write(ByteBuf chunk, boolean end) {\n    synchronized (conn) {\n      checkEnded();\n      boolean hasBody = false;\n      if (chunk != null) {\n        hasBody = true;\n        bytesWritten += chunk.readableBytes();\n      } else {\n        chunk = Unpooled.EMPTY_BUFFER;\n      }\n      if (end) {\n        if (!headWritten && !headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n          headers().set(HttpHeaderNames.CONTENT_LENGTH, String.valueOf(chunk.readableBytes()));\n        }\n        handleEnded(false);\n      }\n      boolean sent = checkSendHeaders(end && !hasBody && trailers == null);\n      if (hasBody || (!sent && end)) {\n        stream.writeData(chunk, end && trailers == null);\n      }\n      if (end && trailers != null) {\n        stream.writeHeaders(trailers, true);\n      }\n      if (end && bodyEndHandler != null) {\n        bodyEndHandler.handle(null);\n      }\n    }\n  }\n\n  @Override\n  public HttpServerResponse writeCustomFrame(int type, int flags, Buffer payload) {\n    synchronized (conn) {\n      checkEnded();\n      checkSendHeaders(false);\n      stream.writeFrame(type, flags, payload.getByteBuf());\n      ctx.flush();\n      return this;\n    }\n  }\n\n  private void checkEnded() {\n    if (ended) {\n      throw new IllegalStateException(\"Response has already been written\");\n    }\n  }\n\n  private void handleEnded(boolean failed) {\n    if (!ended) {\n      ended = true;\n      if (METRICS_ENABLED && metric != null) {\n        // Null in case of push response : handle this case\n        if (failed) {\n          conn.metrics().requestReset(metric);\n        } else {\n          conn.reportBytesWritten(bytesWritten);\n          conn.metrics().responseEnd(metric, this);\n        }\n      }\n      if (exceptionHandler != null) {\n        conn.getContext().runOnContext(v -> exceptionHandler.handle(ConnectionBase.CLOSED_EXCEPTION));\n      }\n      if (endHandler != null) {\n        conn.getContext().runOnContext(endHandler);\n      }\n      if (closeHandler != null) {\n        conn.getContext().runOnContext(closeHandler);\n      }\n    }\n  }\n\n  void writabilityChanged() {\n    if (!ended && !writeQueueFull() && drainHandler != null) {\n      drainHandler.handle(null);\n    }\n  }\n\n  @Override\n  public boolean writeQueueFull() {\n    synchronized (conn) {\n      checkEnded();\n      return stream.isNotWritable();\n    }\n  }\n\n  @Override\n  public HttpServerResponse setWriteQueueMaxSize(int maxSize) {\n    synchronized (conn) {\n      checkEnded();\n      // It does not seem to be possible to configure this at the moment\n    }\n    return this;\n  }\n\n  @Override\n  public HttpServerResponse drainHandler(Handler<Void> handler) {\n    synchronized (conn) {\n      if (handler != null) {\n        checkEnded();\n      }\n      drainHandler = handler;\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse sendFile(String filename, long offset, long length) {\n    return sendFile(filename, offset, length, null);\n  }\n\n  @Override\n  public HttpServerResponse sendFile(String filename, long offset, long length, Handler<AsyncResult<Void>> resultHandler) {\n    synchronized (conn) {\n      checkEnded();\n\n      Context resultCtx = resultHandler != null ? stream.vertx.getOrCreateContext() : null;\n\n      File file = stream.vertx.resolveFile(filename);\n      if (!file.exists()) {\n        if (resultHandler != null) {\n          resultCtx.runOnContext((v) -> resultHandler.handle(Future.failedFuture(new FileNotFoundException())));\n        } else {\n           log.error(\"File not found: \" + filename);\n        }\n        return this;\n      }\n\n      RandomAccessFile raf;\n      try {\n        raf = new RandomAccessFile(file, \"r\");\n      } catch (IOException e) {\n        if (resultHandler != null) {\n          resultCtx.runOnContext((v) -> resultHandler.handle(Future.failedFuture(e)));\n        } else {\n          log.error(\"Failed to send file\", e);\n        }\n        return this;\n      }\n\n      long contentLength = Math.min(length, file.length() - offset);\n      if (headers.get(HttpHeaderNames.CONTENT_LENGTH) == null) {\n        putHeader(HttpHeaderNames.CONTENT_LENGTH, String.valueOf(contentLength));\n      }\n      if (headers.get(HttpHeaderNames.CONTENT_TYPE) == null) {\n        String contentType = MimeMapping.getMimeTypeForFilename(filename);\n        if (contentType != null) {\n          putHeader(HttpHeaderNames.CONTENT_TYPE, contentType);\n        }\n      }\n      checkSendHeaders(false);\n\n      Future<Long> result = Future.future();\n      result.setHandler(ar -> {\n        if (ar.succeeded()) {\n          bytesWritten += ar.result();\n          end();\n        }\n        if (resultHandler != null) {\n          resultCtx.runOnContext(v -> {\n            resultHandler.handle(Future.succeededFuture());\n          });\n        }\n      });\n\n      FileStreamChannel fileChannel = new FileStreamChannel(result, stream, offset, contentLength);\n      drainHandler(fileChannel.drainHandler);\n      ctx.channel()\n        .eventLoop()\n        .register(fileChannel)\n        .addListener((ChannelFutureListener) future -> {\n        if (future.isSuccess()) {\n          fileChannel.pipeline().fireUserEventTriggered(raf);\n        } else {\n          result.tryFail(future.cause());\n        }\n      });\n    }\n    return this;\n  }\n\n  @Override\n  public void close() {\n    conn.close();\n  }\n\n  @Override\n  public boolean ended() {\n    synchronized (conn) {\n      return ended;\n    }\n  }\n\n  @Override\n  public boolean closed() {\n    return conn.isClosed();\n  }\n\n  @Override\n  public boolean headWritten() {\n    synchronized (conn) {\n      return headWritten;\n    }\n  }\n\n  @Override\n  public HttpServerResponse headersEndHandler(@Nullable Handler<Void> handler) {\n    synchronized (conn) {\n      headersEndHandler = handler;\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse bodyEndHandler(@Nullable Handler<Void> handler) {\n    synchronized (conn) {\n      bodyEndHandler = handler;\n      return this;\n    }\n  }\n\n  @Override\n  public long bytesWritten() {\n    synchronized (conn) {\n      return bytesWritten;\n    }\n  }\n\n  @Override\n  public int streamId() {\n    return stream.id();\n  }\n\n  @Override\n  public void reset(long code) {\n    synchronized (conn) {\n      checkEnded();\n      handleEnded(true);\n      stream.writeReset(code);\n      ctx.flush();\n    }\n  }\n\n  @Override\n  public HttpServerResponse push(HttpMethod method, String host, String path, Handler<AsyncResult<HttpServerResponse>> handler) {\n    return push(method, host, path, null, handler);\n  }\n\n  @Override\n  public HttpServerResponse push(HttpMethod method, String path, MultiMap headers, Handler<AsyncResult<HttpServerResponse>> handler) {\n    return push(method, null, path, headers, handler);\n  }\n\n  @Override\n  public HttpServerResponse push(HttpMethod method, String host, String path, MultiMap headers, Handler<AsyncResult<HttpServerResponse>> handler) {\n    synchronized (conn) {\n      if (push) {\n        throw new IllegalStateException(\"A push response cannot promise another push\");\n      }\n      checkEnded();\n      conn.sendPush(stream.id(), host, method, headers, path, handler);\n      if (!inHandler) {\n        ctx.flush();\n      }\n      numPush++;\n      return this;\n    }\n  }\n\n  @Override\n  public HttpServerResponse push(HttpMethod method, String path, Handler<AsyncResult<HttpServerResponse>> handler) {\n    return push(method, host, path, handler);\n  }\n}\n", "target": 1}
{"idx": 1001, "func": "/**\n * License Agreement.\n *\n * Rich Faces - Natural Ajax for Java Server Faces (JSF)\n *\n * Copyright (C) 2007 Exadel, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License version 2.1 as published by the Free Software Foundation.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\npackage org.ajax4jsf.resource;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.StreamCorruptedException;\nimport java.io.StringReader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.Deflater;\nimport java.util.zip.Inflater;\n\nimport javax.faces.FacesException;\nimport javax.faces.context.FacesContext;\nimport javax.imageio.ImageIO;\nimport javax.servlet.ServletContext;\n\nimport org.ajax4jsf.Messages;\nimport org.ajax4jsf.resource.util.URLToStreamHelper;\nimport org.ajax4jsf.util.base64.Codec;\nimport org.ajax4jsf.webapp.WebXml;\nimport org.apache.commons.digester.Digester;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * Produce instances of InternetResource's for any types - jar resource, dynamic\n * created image, component-incapsulated etc. Realised as singleton class to\n * support cache, configuration etc.\n * \n * @author shura (latest modification by $Author: alexsmirnov $)\n * @version $Revision: 1.1.2.1 $ $Date: 2007/01/09 18:56:58 $\n * \n */\npublic class ResourceBuilderImpl extends InternetResourceBuilder {\n\n\tprivate static final Log log = LogFactory.getLog(ResourceBuilderImpl.class);\n\n\tprivate static final String DATA_SEPARATOR = \"/DATA/\";\n\tprivate static final String DATA_BYTES_SEPARATOR = \"/DATB/\";\n\n\tprivate static final Pattern DATA_SEPARATOR_PATTERN = Pattern\n\t\t\t.compile(\"/DAT(A|B)/\");\n\n\n\tprivate static final ResourceRenderer defaultRenderer = new MimeRenderer(null);\n\n\tprivate Map<String, ResourceRenderer> renderers;\n\t/**\n\t * keep resources instances . TODO - put this map to application-scope\n\t * attribute, for support clastering environment.\n\t */\n\tprivate Map<String, InternetResource> resources = Collections.synchronizedMap(new HashMap<String, InternetResource>());\n\n\tprivate long _startTime;\n\n\tprivate Codec codec;\n\n\tprivate static final ResourceRenderer scriptRenderer = new ScriptRenderer();\n\t\n\tprivate static final ResourceRenderer styleRenderer = new StyleRenderer();\n\n\tstatic {\n\t\t// renderers.put(\".htc\",new BehaviorRenderer());\n\t\t// set in-memory caching ImageIO\n\t\tThread thread = Thread.currentThread();\n\t\tClassLoader initialTCCL = thread.getContextClassLoader();\n\t\t\n\t\ttry {\n\t\t\tClassLoader systemCL = ClassLoader.getSystemClassLoader();\n\t\t\tthread.setContextClassLoader(systemCL);\n\t\t\tImageIO.setUseCache(false);\n\t\t} finally {\n\t\t\tthread.setContextClassLoader(initialTCCL);\n\t\t}\n\n\t}\n\n\tpublic WebXml getWebXml(FacesContext context) {\n\t\tWebXml webXml = WebXml.getInstance(context);\n\t\tif (null == webXml) {\n\t\t\tthrow new FacesException(\n\t\t\t\t\t\"Resources framework is not initialised, check web.xml for Filter configuration\");\n\t\t}\n\t\treturn webXml;\n\t}\n\n\tpublic ResourceBuilderImpl() {\n\t\tsuper();\n\t\t_startTime = System.currentTimeMillis();\n\t\tcodec = new Codec();\n\t\trenderers = new HashMap<String, ResourceRenderer>();\n\t\t// append known renderers for extentions.\n\t\trenderers.put(\".gif\", new GifRenderer());\n\t\tResourceRenderer renderer = new JpegRenderer();\n\t\trenderers.put(\".jpeg\", renderer);\n\t\trenderers.put(\".jpg\", renderer);\n\t\trenderers.put(\".png\", new PngRenderer());\n\t\trenderers.put(\".js\", getScriptRenderer());\n\t\trenderers.put(\".css\", getStyleRenderer());\n\t\trenderers.put(\".log\", new LogfileRenderer());\n\t\trenderers.put(\".html\", new HTMLRenderer());\n\t\trenderers.put(\".xhtml\", new MimeRenderer(\"application/xhtml+xml\"));\n\t\trenderers.put(\".xml\", new MimeRenderer(\"text/xml\"));\n\t\trenderers.put(\".xcss\", new TemplateCSSRenderer());\n\t\trenderers.put(\".swf\", new MimeRenderer(\"application/x-shockwave-flash\"));\n\t}\n\n\t/**\n\t * @throws FacesException\n\t */\n\tprotected void registerResources() throws FacesException {\n\t\ttry {\n\t\t\tClassLoader loader = Thread.currentThread().getContextClassLoader();\n\t\t\tEnumeration<URL> e = loader\n\t\t\t\t\t.getResources(\"META-INF/resources-config.xml\");\n\t\t\twhile (e.hasMoreElements()) {\n\t\t\t\tURL resource = e.nextElement();\n\t\t\t\tregisterConfig(resource);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new FacesException(e);\n\t\t}\n\t}\n\n\tprivate void registerConfig(URL resourceConfig) {\n\t\ttry {\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"Process resources configuration file \"\n\t\t\t\t\t\t+ resourceConfig.toExternalForm());\n\t\t\t}\n\n\t\t\tInputStream in = URLToStreamHelper.urlToStream(resourceConfig);\n\t\t\ttry {\n\t\t\t\tDigester digester = new Digester();\n\t\t\t\tdigester.setValidating(false);\n\t\t\t\tdigester.setEntityResolver(new EntityResolver() {\n\t\t\t\t\t// Dummi resolver - alvays do nothing\n\t\t\t\t\tpublic InputSource resolveEntity(String publicId,\n\t\t\t\t\t\t\tString systemId) throws SAXException, IOException {\n\t\t\t\t\t\treturn new InputSource(new StringReader(\"\"));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tdigester.setNamespaceAware(false);\n\t\t\t\tdigester.setUseContextClassLoader(true);\n\t\t\t\tdigester.push(this);\n\t\t\t\tdigester.addObjectCreate(\"resource-config/resource\", \"class\",\n\t\t\t\t\t\tJarResource.class);\n\t\t\t\tdigester.addObjectCreate(\"resource-config/resource/renderer\",\n\t\t\t\t\t\t\"class\", HTMLRenderer.class);\n\t\t\t\tdigester.addCallMethod(\n\t\t\t\t\t\t\"resource-config/resource/renderer/content-type\",\n\t\t\t\t\t\t\"setContentType\", 0);\n\t\t\t\tdigester.addSetNext(\"resource-config/resource/renderer\",\n\t\t\t\t\t\t\"setRenderer\", ResourceRenderer.class.getName());\n\t\t\t\tdigester.addCallMethod(\"resource-config/resource/name\",\n\t\t\t\t\t\t\"setKey\", 0);\n\t\t\t\tdigester.addCallMethod(\"resource-config/resource/path\",\n\t\t\t\t\t\t\"setPath\", 0);\n\t\t\t\tdigester.addCallMethod(\"resource-config/resource/cacheable\",\n\t\t\t\t\t\t\"setCacheable\", 0);\n\t\t\t\tdigester.addCallMethod(\n\t\t\t\t\t\t\"resource-config/resource/session-aware\",\n\t\t\t\t\t\t\"setSessionAware\", 0);\n\t\t\t\tdigester.addCallMethod(\"resource-config/resource/property\",\n\t\t\t\t\t\t\"setProperty\", 2);\n\t\t\t\tdigester.addCallParam(\"resource-config/resource/property/name\",\n\t\t\t\t\t\t0);\n\t\t\t\tdigester.addCallParam(\n\t\t\t\t\t\t\"resource-config/resource/property/value\", 1);\n\t\t\t\tdigester.addCallMethod(\"resource-config/resource/content-type\",\n\t\t\t\t\t\t\"setContentType\", 0);\n\t\t\t\tdigester.addSetNext(\"resource-config/resource\", \"addResource\",\n\t\t\t\t\t\tInternetResource.class.getName());\n\t\t\t\tdigester.parse(in);\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new FacesException(e);\n\t\t} catch (SAXException e) {\n\t\t\tthrow new FacesException(e);\n\t\t}\n\t}\n\n\t/**\n\t */\n\tpublic void init() throws FacesException {\n\t\t// TODO - mace codec configurable.\n\t\tregisterResources();\n\t}\n\n\t/**\n\t * Base point for creating resource. Must detect type and build appropriate\n\t * instance. Currently - make static resource for ordinary request, or\n\t * instance of class.\n\t * \n\t * @param base\n\t *            base object for resource ( resourcess in classpath will be get\n\t *            relative to it package )\n\t * @param path\n\t *            key - path to resource, resource class name etc.\n\t * @return\n\t * @throws FacesException\n\t */\n\tpublic InternetResource createResource(Object base, String path)\n\t\t\tthrows FacesException {\n\t\t// TODO - detect type of resource ( for example, resources location path\n\t\t// in Skin\n\t\ttry {\n\t\t\treturn getResource(path);\n\t\t} catch (ResourceNotFoundException e) {\n\t\t\ttry {\n\t\t\t\treturn getResource(buildKey(base, path));\n\t\t\t} catch (ResourceNotFoundException e1) {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(Messages.getMessage(Messages.BUILD_RESOURCE_INFO,\n\t\t\t\t\t\t\tpath));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// path - is class name ?\n\t\tInternetResource res;\n\t\ttry {\n\t\t\tClass<?> resourceClass = Class.forName(path);\n\t\t\tres = createDynamicResource(path, resourceClass);\n\t\t} catch (Exception e) {\n\t\t\ttry {\n\t\t\t\tres = createJarResource(base, path);\n\t\t\t} catch (ResourceNotFoundException ex) {\n\t\t\t\tres = createStaticResource(path);\n\t\t\t}\n\t\t\t// TODO - if resource not found, create static ?\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate String buildKey(Object base, String path) {\n\t\tif (path.startsWith(\"/\")) {\n\t\t\treturn path.substring(1);\n\t\t}\n\t\tif (null == base) {\n\t\t\treturn path;\n\t\t}\n\t\tStringBuffer packageName = new StringBuffer(base.getClass()\n\t\t\t\t.getPackage().getName().replace('.', '/'));\n\t\treturn packageName.append(\"/\").append(path).toString();\n\t}\n\n\tpublic String getUri(InternetResource resource, FacesContext context,\n\t\t\tObject storeData) {\n\t\tStringBuffer uri = new StringBuffer();// ResourceServlet.DEFAULT_SERVLET_PATH).append(\"/\");\n\t\turi.append(resource.getKey());\n\t\t// append serialized data as Base-64 encoded request string.\n\t\tif (storeData != null) {\n\t\t\ttry {\n\t\t\t\tbyte[] objectData;\n\t\t\t\tif (storeData instanceof byte[]) {\n\t\t\t\t\tobjectData = (byte[]) storeData;\n\t\t\t\t\turi.append(DATA_BYTES_SEPARATOR);\n\t\t\t\t} else {\n\t\t\t\t\tByteArrayOutputStream dataSteram = new ByteArrayOutputStream(\n\t\t\t\t\t\t\t1024);\n\t\t\t\t\tObjectOutputStream objStream = new ObjectOutputStream(\n\t\t\t\t\t\t\tdataSteram);\n\t\t\t\t\tobjStream.writeObject(storeData);\n\t\t\t\t\tobjStream.flush();\n\t\t\t\t\tobjStream.close();\n\t\t\t\t\tdataSteram.close();\n\t\t\t\t\tobjectData = dataSteram.toByteArray();\n\t\t\t\t\turi.append(DATA_SEPARATOR);\n\t\t\t\t}\n\t\t\t\tbyte[] dataArray = encrypt(objectData);\n\t\t\t\turi.append(new String(dataArray, \"ISO-8859-1\"));\n\n\t\t\t\t// / byte[] objectData = dataSteram.toByteArray();\n\t\t\t\t// / uri.append(\"?\").append(new\n\t\t\t\t// String(Base64.encodeBase64(objectData),\n\t\t\t\t// / \"ISO-8859-1\"));\n\t\t\t} catch (Exception e) {\n\t\t\t\t// Ignore errors, log it\n\t\t\t\tlog.error(Messages\n\t\t\t\t\t\t.getMessage(Messages.QUERY_STRING_BUILDING_ERROR), e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean isGlobal = !resource.isSessionAware();\n\t\t\n\t\tString resourceURL = getWebXml(context).getFacesResourceURL(context,\n\t\t\t\turi.toString(), isGlobal);// context.getApplication().getViewHandler().getResourceURL(context,uri.toString());\n\t\tif (!isGlobal) {\n\t\t\tresourceURL = context.getExternalContext().encodeResourceURL(\n\t\t\t\t\tresourceURL);\n\t\t}\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(Messages.getMessage(Messages.BUILD_RESOURCE_URI_INFO,\n\t\t\t\t\tresource.getKey(), resourceURL));\n\t\t}\n\t\treturn resourceURL;// context.getExternalContext().encodeResourceURL(resourceURL);\n\n\t}\n\n\t/**\n\t * @param key\n\t * @return\n\t */\n\tpublic InternetResource getResourceForKey(String key)\n\t\t\tthrows ResourceNotFoundException {\n\n\t\tMatcher matcher = DATA_SEPARATOR_PATTERN.matcher(key);\n\t\tif (matcher.find()) {\n\t\t\tint data = matcher.start();\n\t\t\tkey = key.substring(0, data);\n\t\t}\n\n\t\treturn getResource(key);\n\t}\n\n\tpublic Object getResourceDataForKey(String key) {\n\t\tObject data = null;\n\t\tString dataString = null;\n\t\tMatcher matcher = DATA_SEPARATOR_PATTERN.matcher(key);\n\t\tif (matcher.find()) {\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(Messages.getMessage(\n\t\t\t\t\t\tMessages.RESTORE_DATA_FROM_RESOURCE_URI_INFO, key,\n\t\t\t\t\t\tdataString));\n\t\t\t}\n\t\t\tint dataStart = matcher.end();\n\t\t\tdataString = key.substring(dataStart);\n\t\t\tbyte[] objectArray = null;\n\t\t\tbyte[] dataArray;\n\t\t\ttry {\n\t\t\t\tdataArray = dataString.getBytes(\"ISO-8859-1\");\n\t\t\t\tobjectArray = decrypt(dataArray);\n\t\t\t} catch (UnsupportedEncodingException e1) {\n\t\t\t\t// default encoding always presented.\n\t\t\t}\n\t\t\tif (\"B\".equals(matcher.group(1))) {\n\t\t\t\tdata = objectArray;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tObjectInputStream in = new LookAheadObjectInputStream(new ByteArrayInputStream(objectArray));\n\t\t\t\t\tdata = in.readObject();\n\t\t\t\t} catch (StreamCorruptedException e) {\n\t\t\t\t\tlog.error(Messages\n\t\t\t\t\t\t\t.getMessage(Messages.STREAM_CORRUPTED_ERROR), e);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlog.error(Messages\n\t\t\t\t\t\t\t.getMessage(Messages.DESERIALIZE_DATA_INPUT_ERROR),\n\t\t\t\t\t\t\te);\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tlog\n\t\t\t\t\t\t\t.error(\n\t\t\t\t\t\t\t\t\tMessages\n\t\t\t\t\t\t\t\t\t\t\t.getMessage(Messages.DATA_CLASS_NOT_FOUND_ERROR),\n\t\t\t\t\t\t\t\t\te);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tpublic InternetResource getResource(String path)\n\t\t\tthrows ResourceNotFoundException {\n\n\t\tInternetResource internetResource = (InternetResource) resources\n\t\t\t\t.get(path);\n\t\tif (null == internetResource) {\n\t\t\tthrow new ResourceNotFoundException(\"Resource not registered : \"\n\t\t\t\t\t+ path);\n\t\t} else {\n\t\t\treturn internetResource;\n\t\t}\n\t}\n\n\tpublic void addResource(InternetResource resource) {\n\t\tresources.put(resource.getKey(), resource);\n\t\tResourceRenderer renderer = resource.getRenderer(null);\n\t\tif (renderer == null) {\n\t\t\tsetRenderer(resource, resource.getKey());\n\t\t}\n\t}\n\n\tpublic void addResource(String key, InternetResource resource) {\n\t\tresources.put(key, resource);\n\t\tresource.setKey(key);\n\t\t// TODO - set renderer ?\n\t}\n\n\t// public String getFacesResourceKey(HttpServletRequest request) {\n\t// return getWebXml(context).getFacesResourceKey(request);\n\t// }\n\n\tpublic String getFacesResourceURL(FacesContext context, String Url, boolean isGlobal) {\n\t\treturn getWebXml(context).getFacesResourceURL(context, Url, isGlobal);\n\t}\n\n\t/**\n\t * Build resource for link to static context in webapp.\n\t * \n\t * @param path\n\t * @return\n\t * @throws FacesException\n\t */\n\tprotected InternetResource createStaticResource(String path)\n\t\t\tthrows ResourceNotFoundException, FacesException {\n\t\tFacesContext context = FacesContext.getCurrentInstance();\n\t\tif (null != context) {\n\t\t\tif (context.getExternalContext().getContext() instanceof ServletContext) {\n\t\t\t\tServletContext servletContext = (ServletContext) context\n\t\t\t\t\t\t.getExternalContext().getContext();\n\t\t\t\tInputStream in = servletContext.getResourceAsStream(path);\n\t\t\t\tif (null != in) {\n\t\t\t\t\tInternetResourceBase res = new StaticResource(path);\n\t\t\t\t\tsetRenderer(res, path);\n\t\t\t\t\tres.setLastModified(new Date(getStartTime()));\n\t\t\t\t\taddResource(path, res);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tin.close();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new ResourceNotFoundException(Messages.getMessage(\n\t\t\t\tMessages.STATIC_RESOURCE_NOT_FOUND_ERROR, path));\n\t}\n\n\tprivate void setRenderer(InternetResource res, String path)\n\t\t\tthrows FacesException {\n\t\tint lastPoint = path.lastIndexOf('.');\n\t\tif (lastPoint > 0) {\n\t\t\tString ext = path.substring(lastPoint);\n\t\t\tResourceRenderer resourceRenderer =  getRendererByExtension(ext);\n\t\t\tif (null != resourceRenderer) {\n\t\t\t\tres.setRenderer(resourceRenderer);\n\t\t\t} else {\n\t\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(Messages.getMessage(\n\t\t\t\t\t\t\tMessages.NO_RESOURCE_REGISTERED_ERROR_2, path,\n\t\t\t\t\t\t\trenderers.keySet()));\n\t\t\t\t}\n\n\t\t\t\t// String mimeType = servletContext.getMimeType(path);\n\t\t\t\tres.setRenderer(defaultRenderer);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param ext\n\t * @return\n\t */\n\tprotected ResourceRenderer getRendererByExtension(String ext) {\n\t\treturn renderers\n\t\t\t\t.get(ext);\n\t}\n\n\t/**\n\t * Create resurce to send from classpath relative to base class.\n\t * \n\t * @param base\n\t * @param path\n\t * @return\n\t * @throws FacesException\n\t */\n\tprotected InternetResource createJarResource(Object base, String path)\n\t\t\tthrows ResourceNotFoundException, FacesException {\n\t\tString key = buildKey(base, path);\n\t\tClassLoader loader = Thread.currentThread().getContextClassLoader();\n\t\tif (null != loader.getResource(key)) {\n\t\t\tJarResource res = new JarResource(key);\n\t\t\tsetRenderer(res, path);\n\t\t\tres.setLastModified(new Date(getStartTime()));\n\t\t\taddResource(key, res);\n\t\t\treturn res;\n\t\t} else {\n\t\t\tthrow new ResourceNotFoundException(Messages.getMessage(\n\t\t\t\t\tMessages.NO_RESOURCE_EXISTS_ERROR, key));\n\t\t}\n\n\t}\n\n\t/**\n\t * Create resource by instatiate given class.\n\t * \n\t * @param path\n\t * @param instatiate\n\t * @return\n\t */\n\tprotected InternetResource createDynamicResource(String path,\n\t\t\tClass<?> instatiate) throws ResourceNotFoundException {\n\t\tif (InternetResource.class.isAssignableFrom(instatiate)) {\n\t\t\tInternetResource resource;\n\t\t\ttry {\n\t\t\t\tresource = (InternetResource) instatiate.newInstance();\n\t\t\t\taddResource(path, resource);\n\t\t\t} catch (Exception e) {\n\t\t\t\tString message = Messages.getMessage(\n\t\t\t\t\t\tMessages.INSTANTIATE_RESOURCE_ERROR, instatiate\n\t\t\t\t\t\t\t\t.toString());\n\t\t\t\tlog.error(message, e);\n\t\t\t\tthrow new ResourceNotFoundException(message, e);\n\t\t\t}\n\t\t\treturn resource;\n\t\t}\n\t\tthrow new FacesException(Messages\n\t\t\t\t.getMessage(Messages.INSTANTIATE_CLASS_ERROR));\n\t}\n\n\t/**\n\t * Create resource by instatiate {@link UserResource} class with given\n\t * properties ( or got from cache ).\n\t * \n\t * @param cacheable\n\t * @param session\n\t * @param mime\n\t * @return\n\t * @throws FacesException\n\t */\n\tpublic InternetResource createUserResource(boolean cacheable,\n\t\t\tboolean session, String mime) throws FacesException {\n\t\tString path = getUserResourceKey(cacheable, session, mime);\n\t\tInternetResource userResource;\n\t\ttry {\n\t\t\tuserResource = getResource(path);\n\t\t} catch (ResourceNotFoundException e) {\n\t\t\tuserResource = new UserResource(cacheable, session, mime);\n\t\t\taddResource(path, userResource);\n\t\t}\n\t\treturn userResource;\n\t}\n\n\t/**\n\t * Generate resource key for user-generated resource with given properties.\n\t * \n\t * @param cacheable\n\t * @param session\n\t * @param mime\n\t * @return\n\t */\n\tprivate String getUserResourceKey(boolean cacheable, boolean session,\n\t\t\tString mime) {\n\t\tStringBuffer pathBuffer = new StringBuffer(UserResource.class.getName());\n\t\tpathBuffer.append(cacheable ? \"/c\" : \"/n\");\n\t\tpathBuffer.append(session ? \"/s\" : \"/n\");\n\t\tif (null != mime) {\n\t\t\tpathBuffer.append('/').append(mime.hashCode());\n\t\t}\n\t\tString path = pathBuffer.toString();\n\t\treturn path;\n\t}\n\n\t/**\n\t * @return Returns the startTime for application.\n\t */\n\tpublic long getStartTime() {\n\t\treturn _startTime;\n\t}\n\n\tprotected byte[] encrypt(byte[] src) {\n\t\ttry {\n\t\t\tDeflater compressor = new Deflater(Deflater.BEST_SPEED);\n\t\t\tbyte[] compressed = new byte[src.length + 100];\n\t\t\tcompressor.setInput(src);\n\t\t\tcompressor.finish();\n\t\t\tint totalOut = compressor.deflate(compressed);\n\t\t\tbyte[] zipsrc = new byte[totalOut];\n\t\t\tSystem.arraycopy(compressed, 0, zipsrc, 0, totalOut);\n\t\t\tcompressor.end();\n\t\t\treturn codec.encode(zipsrc);\n\t\t} catch (Exception e) {\n\t\t\tthrow new FacesException(\"Error encode resource data\", e);\n\t\t}\n\t}\n\n\tprotected byte[] decrypt(byte[] src) {\n\t\ttry {\n\t\t\tbyte[] zipsrc = codec.decode(src);\n\t\t\tInflater decompressor = new Inflater();\n\t\t\tbyte[] uncompressed = new byte[zipsrc.length * 5];\n\t\t\tdecompressor.setInput(zipsrc);\n\t\t\tint totalOut = decompressor.inflate(uncompressed);\n\t\t\tbyte[] out = new byte[totalOut];\n\t\t\tSystem.arraycopy(uncompressed, 0, out, 0, totalOut);\n\t\t\tdecompressor.end();\n\t\t\treturn out;\n\t\t} catch (Exception e) {\n\t\t\tthrow new FacesException(\"Error decode resource data\", e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResourceRenderer getScriptRenderer() {\n\t\treturn scriptRenderer;\n\t}\n\n\t@Override\n\tpublic ResourceRenderer getStyleRenderer() {\n\t\treturn styleRenderer;\n\t}\n}\n", "target": 0}
{"idx": 1002, "func": "package io.onedev.server.migration;\n\nimport java.beans.IntrospectionException;\nimport java.beans.PropertyDescriptor;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.hibernate.proxy.HibernateProxyHelper;\nimport org.yaml.snakeyaml.DumperOptions;\nimport org.yaml.snakeyaml.DumperOptions.FlowStyle;\nimport org.yaml.snakeyaml.Yaml;\nimport org.yaml.snakeyaml.constructor.Constructor;\nimport org.yaml.snakeyaml.emitter.Emitter;\nimport org.yaml.snakeyaml.introspector.BeanAccess;\nimport org.yaml.snakeyaml.introspector.MethodProperty;\nimport org.yaml.snakeyaml.introspector.Property;\nimport org.yaml.snakeyaml.introspector.PropertyUtils;\nimport org.yaml.snakeyaml.nodes.MappingNode;\nimport org.yaml.snakeyaml.nodes.Node;\nimport org.yaml.snakeyaml.nodes.NodeTuple;\nimport org.yaml.snakeyaml.nodes.ScalarNode;\nimport org.yaml.snakeyaml.nodes.Tag;\nimport org.yaml.snakeyaml.representer.Representer;\nimport org.yaml.snakeyaml.resolver.Resolver;\nimport org.yaml.snakeyaml.serializer.Serializer;\n\nimport edu.emory.mathcs.backport.java.util.Collections;\nimport io.onedev.commons.launcher.loader.ImplementationRegistry;\nimport io.onedev.commons.utils.ClassUtils;\nimport io.onedev.server.OneDev;\nimport io.onedev.server.GeneralException;\nimport io.onedev.server.util.BeanUtils;\nimport io.onedev.server.web.editable.annotation.Editable;\n\npublic class VersionedYamlDoc extends MappingNode {\n\n\tpublic VersionedYamlDoc(MappingNode wrapped) {\n\t\tsuper(wrapped.getTag(), wrapped.getValue(), wrapped.getFlowStyle());\n\t}\n\t\n\tpublic static VersionedYamlDoc fromYaml(String yaml) {\n\t\treturn new VersionedYamlDoc((MappingNode) new OneYaml().compose(new StringReader(yaml)));\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T toBean(Class<T> beanClass) {\n        setTag(new Tag(beanClass));\n        \n\t\tif (getVersion() != null) {\n\t\t\ttry {\n\t\t\t\tMigrationHelper.migrate(getVersion(), beanClass.newInstance(), this);\n\t\t\t\tremoveVersion();\n\t\t\t} catch (InstantiationException | IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\t\n        return (T) new OneYaml().construct(this);\n\t}\n\t\n\tpublic static VersionedYamlDoc fromBean(Object bean) {\n\t\tVersionedYamlDoc doc = new VersionedYamlDoc((MappingNode) new OneYaml().represent(bean));\n\t\tdoc.setVersion(MigrationHelper.getVersion(HibernateProxyHelper.getClassWithoutInitializingProxy(bean)));\n\t\treturn doc;\n\t}\n\t\n\tprivate String getVersion() {\n\t\tfor (NodeTuple tuple: getValue()) {\n\t\t\tScalarNode keyNode = (ScalarNode) tuple.getKeyNode();\n\t\t\tif (keyNode.getValue().equals(\"version\")) \n\t\t\t\treturn ((ScalarNode)tuple.getValueNode()).getValue();\n\t\t}\n\t\tthrow new GeneralException(\"Unable to find version\");\n\t}\n\t\n\tprivate void removeVersion() {\n\t\tfor (Iterator<NodeTuple> it = getValue().iterator(); it.hasNext();) {\n\t\t\tScalarNode keyNode = (ScalarNode) it.next().getKeyNode();\n\t\t\tif (keyNode.getValue().equals(\"version\")) \n\t\t\t\tit.remove();\n\t\t}\n\t}\n\t\n\tprivate void setVersion(String version) {\n\t\tScalarNode versionNode = null;\n\t\tfor (NodeTuple tuple:  getValue()) {\n\t\t\tScalarNode keyNode = (ScalarNode) tuple.getKeyNode();\n\t\t\tif (keyNode.getValue().equals(\"version\")) {\n\t\t\t\t((ScalarNode) tuple.getValueNode()).setValue(version);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (versionNode == null) {\n\t\t\tScalarNode keyNode = new ScalarNode(Tag.STR, \"version\", null, null, DumperOptions.ScalarStyle.PLAIN);\n\t\t\tversionNode = new ScalarNode(Tag.INT, version, null, null, DumperOptions.ScalarStyle.PLAIN);\n\t\t\tgetValue().add(0, new NodeTuple(keyNode, versionNode));\n\t\t}\n\t}\n\t\n\tpublic String toYaml() {\n\t\tStringWriter writer = new StringWriter();\n\t\tDumperOptions dumperOptions = new DumperOptions();\n\t\tSerializer serializer = new Serializer(new Emitter(writer, dumperOptions), \n\t\t\t\tnew Resolver(), dumperOptions, Tag.MAP);\n\t\ttry {\n\t\t\tserializer.open();\n\t\t\tserializer.serialize(this);\n\t\t\tserializer.close();\n\t\t\treturn writer.toString();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t\n\tprivate static class OneConstructor extends Constructor {\n\t\t\n\t\tpublic Object construct(Node node) {\n\t\t\treturn constructDocument(node);\n\t\t}\n\n\t\t@Override\n\t\tprotected Class<?> getClassForNode(Node node) {\n\t\t\tClass<?> type = node.getType();\n\t\t\tif (type.getAnnotation(Editable.class) != null && !ClassUtils.isConcrete(type)) {\n\t\t\t\tImplementationRegistry registry = OneDev.getInstance(ImplementationRegistry.class);\n\t\t\t\tfor (Class<?> implementationClass: registry.getImplementations(node.getType())) {\n\t\t\t\t\tString implementationTag = new Tag(\"!\" + implementationClass.getSimpleName()).getValue();\n\t\t\t\t\tif (implementationTag.equals(node.getTag().getValue()))\n\t\t\t\t\t\treturn implementationClass;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn super.getClassForNode(node);\n\t\t}\n\t\t\n\t}\n\t\n\tprivate static class OneYaml extends Yaml {\n\n\t\tOneYaml() {\n\t\t\tsuper(newConstructor(), newRepresenter());\n\t\t\t\n\t\t\t/*\n\t\t\t * Use property here as yaml will be read by human and we want to make \n\t\t\t * it consistent with presented in UI \n\t\t\t */\n\t\t\tsetBeanAccess(BeanAccess.PROPERTY);\n\t\t}\n\t\t\n\t\tprivate static Representer newRepresenter() {\n\t\t\tRepresenter representer = new Representer() {\n\t\t\t\t\n\t\t\t    @SuppressWarnings(\"rawtypes\")\n\t\t\t\t@Override\n\t\t\t    protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, \n\t\t\t    \t\tObject propertyValue,Tag customTag) {\n\t\t\t        if (propertyValue == null \n\t\t\t        \t\t|| propertyValue instanceof Collection && ((Collection) propertyValue).isEmpty()\n\t\t\t        \t\t|| propertyValue instanceof Map && ((Map) propertyValue).isEmpty()) { \n\t\t\t        \treturn null;\n\t\t\t        } else {\n\t\t\t        \treturn super.representJavaBeanProperty(javaBean, property, propertyValue, customTag);\n\t\t\t        }\n\t\t\t    }\n\n\t\t\t};\n\t\t\trepresenter.setDefaultFlowStyle(FlowStyle.BLOCK);\n\t\t\trepresenter.setPropertyUtils(new PropertyUtils() {\n\n\t\t\t\t@Override\n\t\t\t\tprotected Set<Property> createPropertySet(Class<? extends Object> type, BeanAccess bAccess) {\n\t\t\t\t\tList<Property> properties = new ArrayList<>();\n\t\t\t\t\tMap<String, Integer> orders = new HashMap<>();\n\t\t\t\t\tif (type.getAnnotation(Editable.class) != null) {\n\t\t\t\t\t\tfor (Method getter: BeanUtils.findGetters(type)) {\n\t\t\t\t\t\t\tEditable editable = getter.getAnnotation(Editable.class);\n\t\t\t\t\t\t\tMethod setter = BeanUtils.findSetter(getter);\n\t\t\t\t\t\t\tif (editable != null && setter != null) {\n\t\t\t\t\t\t\t\tString propertyName = BeanUtils.getPropertyName(getter);\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tproperties.add(new MethodProperty(new PropertyDescriptor(propertyName, getter, setter)));\n\t\t\t\t\t\t\t\t} catch (IntrospectionException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\torders.put(propertyName, editable.order());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tCollections.sort(properties, new Comparator<Property>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic int compare(Property o1, Property o2) {\n\t\t\t\t\t\t\treturn orders.get(o1.getName()) - orders.get(o2.getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t});\n\t\t\t\t\treturn new LinkedHashSet<>(properties);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\treturn representer;\n\t\t}\n\t\t\n\t\tprivate static OneConstructor newConstructor() {\n\t\t\treturn new OneConstructor();\n\t\t}\n\t\t\n\t\tpublic Object construct(Node node) {\n\t        return ((OneConstructor)constructor).construct(node);\n\t\t}\n\t    \n\t}\n\n}\n", "target": 1}
{"idx": 1003, "func": "/*\n * Copyright (c) 2011-2017 Contributors to the Eclipse Foundation\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0\n * which is available at https://www.apache.org/licenses/LICENSE-2.0.\n *\n * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n */\n\npackage io.vertx.test.core;\n\nimport io.vertx.core.MultiMap;\nimport io.vertx.core.http.impl.headers.VertxHttpHeaders;\nimport org.junit.Test;\n\n/**\n * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n */\npublic class VertxHttpHeadersTest extends CaseInsensitiveHeadersTest {\n\n  @Override\n  protected MultiMap newMultiMap() {\n    return new VertxHttpHeaders();\n  }\n\n  @Override\n  public void testHashMININT() {\n    // Does not apply\n  }\n}\n", "target": 0}
{"idx": 1004, "func": "package io.onedev.server.rest;\n\nimport java.util.Collection;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.QueryParam;\nimport javax.ws.rs.core.Context;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.UriInfo;\n\nimport org.apache.shiro.authz.UnauthorizedException;\nimport org.hibernate.criterion.Restrictions;\nimport org.hibernate.validator.constraints.Email;\n\nimport io.onedev.server.entitymanager.UserManager;\nimport io.onedev.server.model.User;\nimport io.onedev.server.persistence.dao.EntityCriteria;\nimport io.onedev.server.rest.jersey.ValidQueryParams;\nimport io.onedev.server.security.SecurityUtils;\n\n@Path(\"/users\")\n@Consumes(MediaType.WILDCARD)\n@Produces(MediaType.APPLICATION_JSON)\n@Singleton\npublic class UserResource {\n\n\tprivate final UserManager userManager;\n\t\n\t@Inject\n\tpublic UserResource(UserManager userManager) {\n\t\tthis.userManager = userManager;\n\t}\n\t\n\t@ValidQueryParams\n\t@GET\n\tpublic Response query(@QueryParam(\"name\") String name, @Email @QueryParam(\"email\") String email, \n\t\t\t@QueryParam(\"offset\") Integer offset, @QueryParam(\"count\") Integer count, @Context UriInfo uriInfo) {\n    \tif (!SecurityUtils.isAdministrator())\n    \t\tthrow new UnauthorizedException(\"Unauthorized access to user profiles\");\n    \t\n    \tEntityCriteria<User> criteria = EntityCriteria.of(User.class);\n    \tif (name != null)\n    \t\tcriteria.add(Restrictions.eq(\"name\", name));\n\t\tif (email != null)\n\t\t\tcriteria.add(Restrictions.eq(\"email\", email));\n\t\t\n    \tif (offset == null)\n    \t\toffset = 0;\n    \t\n    \tif (count == null || count > RestConstants.PAGE_SIZE) \n    \t\tcount = RestConstants.PAGE_SIZE;\n\n    \tCollection<User> users = userManager.query(criteria, offset, count);\n\t\t\n\t\treturn Response.ok(users, RestConstants.JSON_UTF8).build();\n\t}\n\t\n    @GET\n    @Path(\"/{userId}\")\n    public User get(@PathParam(\"userId\") Long userId) {\n    \treturn userManager.load(userId);\n    }\n    \n}\n", "target": 1}
{"idx": 1005, "func": "/**\n * Copyright (c) 2009 - 2012 Red Hat, Inc.\n *\n * This software is licensed to you under the GNU General Public License,\n * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n * along with this software; if not, see\n * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n *\n * Red Hat trademarks are not licensed under GPLv2. No permission is\n * granted to use or replicate Red Hat trademarks that are incorporated\n * in this software or its documentation.\n */\npackage org.candlepin.sync;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport javax.persistence.PersistenceException;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.log4j.Logger;\nimport org.candlepin.audit.EventSink;\nimport org.candlepin.config.Config;\nimport org.candlepin.controller.PoolManager;\nimport org.candlepin.controller.Refresher;\nimport org.candlepin.model.CertificateSerialCurator;\nimport org.candlepin.model.ConsumerType;\nimport org.candlepin.model.ConsumerTypeCurator;\nimport org.candlepin.model.ContentCurator;\nimport org.candlepin.model.ExporterMetadata;\nimport org.candlepin.model.ExporterMetadataCurator;\nimport org.candlepin.model.Owner;\nimport org.candlepin.model.OwnerCurator;\nimport org.candlepin.model.Product;\nimport org.candlepin.model.ProductCurator;\nimport org.candlepin.model.Subscription;\nimport org.candlepin.model.SubscriptionCurator;\nimport org.candlepin.pki.PKIUtility;\nimport org.candlepin.util.VersionUtil;\nimport org.codehaus.jackson.map.ObjectMapper;\nimport org.hibernate.exception.ConstraintViolationException;\nimport org.xnap.commons.i18n.I18n;\n\nimport com.google.inject.Inject;\nimport com.google.inject.persist.Transactional;\n\n\n/**\n * Importer\n */\npublic class Importer {\n    private static Logger log = Logger.getLogger(Importer.class);\n\n    /**\n     *\n     * files we use to perform import\n     */\n    enum ImportFile {\n        META(\"meta.json\"),\n        CONSUMER_TYPE(\"consumer_types\"),\n        CONSUMER(\"consumer.json\"),\n        ENTITLEMENTS(\"entitlements\"),\n        ENTITLEMENT_CERTIFICATES(\"entitlement_certificates\"),\n        PRODUCTS(\"products\"),\n        RULES(\"rules\");\n\n        private String fileName;\n        ImportFile(String fileName) {\n            this.fileName = fileName;\n        }\n\n        public String fileName() {\n            return fileName;\n        }\n\n    }\n\n    /**\n     * Keys representing the various errors that can occur during a manifest\n     * import, but be overridden with forces.\n     */\n    public enum Conflict {\n        MANIFEST_OLD, MANIFEST_SAME, DISTRIBUTOR_CONFLICT, SIGNATURE_CONFLICT\n    }\n\n\n\n\n    private ConsumerTypeCurator consumerTypeCurator;\n    private ProductCurator productCurator;\n    private ObjectMapper mapper;\n    private RulesImporter rulesImporter;\n    private OwnerCurator ownerCurator;\n    private ContentCurator contentCurator;\n    private SubscriptionCurator subCurator;\n    private PoolManager poolManager;\n    private PKIUtility pki;\n    private Config config;\n    private ExporterMetadataCurator expMetaCurator;\n    private CertificateSerialCurator csCurator;\n    private EventSink sink;\n    private I18n i18n;\n\n    @Inject\n    public Importer(ConsumerTypeCurator consumerTypeCurator, ProductCurator productCurator,\n        RulesImporter rulesImporter, OwnerCurator ownerCurator,\n        ContentCurator contentCurator, SubscriptionCurator subCurator, PoolManager pm,\n        PKIUtility pki, Config config, ExporterMetadataCurator emc,\n        CertificateSerialCurator csc, EventSink sink, I18n i18n) {\n\n        this.config = config;\n        this.consumerTypeCurator = consumerTypeCurator;\n        this.productCurator = productCurator;\n        this.rulesImporter = rulesImporter;\n        this.ownerCurator = ownerCurator;\n        this.contentCurator = contentCurator;\n        this.subCurator = subCurator;\n        this.poolManager = pm;\n        this.mapper = SyncUtils.getObjectMapper(this.config);\n        this.pki = pki;\n        this.expMetaCurator = emc;\n        this.csCurator = csc;\n        this.sink = sink;\n        this.i18n = i18n;\n    }\n\n    /**\n     * Check to make sure the meta data is newer than the imported data.\n     * @param type ExporterMetadata.TYPE_PER_USER or TYPE_SYSTEM\n     * @param owner Owner in the case of PER_USER\n     * @param meta meta.json file\n     * @param forcedConflicts Conflicts we will override if encountered\n     * @throws IOException thrown if there's a problem reading the file\n     * @throws ImporterException thrown if the metadata is invalid.\n     */\n    public void validateMetadata(String type, Owner owner, File meta,\n        ConflictOverrides forcedConflicts)\n        throws IOException, ImporterException {\n\n        Meta m = mapper.readValue(meta, Meta.class);\n        if (type == null) {\n            throw new ImporterException(i18n.tr(\"Wrong metadata type\"));\n        }\n\n        ExporterMetadata lastrun = null;\n        if (ExporterMetadata.TYPE_SYSTEM.equals(type)) {\n            lastrun = expMetaCurator.lookupByType(type);\n        }\n        else if (ExporterMetadata.TYPE_PER_USER.equals(type)) {\n            if (owner == null) {\n                throw new ImporterException(i18n.tr(\"Invalid owner\"));\n            }\n            lastrun = expMetaCurator.lookupByTypeAndOwner(type, owner);\n        }\n\n        if (lastrun == null) {\n            // this is our first import, let's create a new entry\n            lastrun = new ExporterMetadata(type, m.getCreated(), owner);\n            lastrun = expMetaCurator.create(lastrun);\n        }\n        else {\n            if (lastrun.getExported().compareTo(m.getCreated()) > 0) {\n                if (!forcedConflicts.isForced(Importer.Conflict.MANIFEST_OLD)) {\n                    throw new ImportConflictException(i18n.tr(\n                        \"Import is older than existing data\"),\n                        Importer.Conflict.MANIFEST_OLD);\n                }\n                else {\n                    log.warn(\"Manifest older than existing data.\");\n                }\n            }\n            else if (lastrun.getExported().compareTo(m.getCreated()) == 0) {\n                if (!forcedConflicts.isForced(Importer.Conflict.MANIFEST_SAME)) {\n                    throw new ImportConflictException(i18n.tr(\n                        \"Import is the same as existing data\"),\n                        Importer.Conflict.MANIFEST_SAME);\n                }\n                else {\n                    log.warn(\"Manifest same as existing data.\");\n                }\n            }\n\n            lastrun.setExported(m.getCreated());\n            expMetaCurator.merge(lastrun);\n        }\n    }\n\n    public Map<String, Object> loadExport(Owner owner, File exportFile,\n        ConflictOverrides overrides)\n        throws ImporterException {\n        File tmpDir = null;\n        InputStream exportStream = null;\n        Map<String, Object> result = new HashMap<String, Object>();\n        try {\n            tmpDir = new SyncUtils(config).makeTempDir(\"import\");\n            extractArchive(tmpDir, exportFile);\n\n//           only need this call when sig file is verified\n//            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));\n\n            /*\n             * Disabling this once again for a little bit longer. Dependent projects\n             * are not yet ready for it, and we're having some difficulty with the actual\n             * upstream cert to use.\n             *\n             * When we bring this back, we should probably report this conflict\n             * immediately, rather than continuing to extract and trying to find any\n             * other conflicts to pass back.\n             */\n//            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(\n//                exportStream,\n//                loadSignature(new File(tmpDir, \"signature\")));\n//            if (!verifiedSignature) {\n//                log.warn(\"Manifest signature check failed.\");\n//                if (!forcedConflicts\n//                    .isForced(ImportConflicts.Conflict.SIGNATURE_CONFLICT)) {\n//                    conflicts.addConflict(\n//                        i18n.tr(\"Failed import file hash check.\"),\n//                        ImportConflicts.Conflict.SIGNATURE_CONFLICT);\n//                }\n//                else {\n//                    log.warn(\"Ignoring signature check failure.\");\n//                }\n//            }\n\n            File signature = new File(tmpDir, \"signature\");\n            if (signature.length() == 0) {\n                throw new ImportExtractionException(i18n.tr(\"The archive does not \" +\n                                          \"contain the required signature file\"));\n            }\n\n            File consumerExport = new File(tmpDir, \"consumer_export.zip\");\n            File exportDir = extractArchive(tmpDir, consumerExport);\n\n            Map<String, File> importFiles = new HashMap<String, File>();\n            File[] listFiles = exportDir.listFiles();\n            if (listFiles == null || listFiles.length == 0) {\n                throw new ImportExtractionException(i18n.tr(\"The consumer_export \" +\n                    \"archive has no contents\"));\n            }\n            for (File file : listFiles) {\n                importFiles.put(file.getName(), file);\n            }\n\n            ConsumerDto consumer = importObjects(owner, importFiles, overrides);\n            Meta m = mapper.readValue(importFiles.get(ImportFile.META.fileName()),\n                Meta.class);\n            result.put(\"consumer\", consumer);\n            result.put(\"meta\", m);\n            return result;\n        }\n//        catch (CertificateException e) {\n//            log.error(\"Exception caught importing archive\", e);\n//            throw new ImportExtractionException(\"unable to extract export archive\", e);\n//        }\n        catch (FileNotFoundException fnfe) {\n            log.error(\"Archive file does not contain consumer_export.zip\", fnfe);\n            throw new ImportExtractionException(i18n.tr(\"The archive does not contain \" +\n                                           \"the required consumer_export.zip file\"));\n        }\n        catch (ConstraintViolationException cve) {\n            log.error(\"Failed to import archive\", cve);\n            throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                cve);\n        }\n        catch (PersistenceException pe) {\n            log.error(\"Failed to import archive\", pe);\n            throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                pe);\n        }\n        catch (IOException e) {\n            log.error(\"Exception caught importing archive\", e);\n            throw new ImportExtractionException(\"unable to extract export archive\", e);\n        }\n        finally {\n            if (tmpDir != null) {\n                try {\n                    FileUtils.deleteDirectory(tmpDir);\n                }\n                catch (IOException e) {\n                    log.error(\"Failed to delete extracted export\", e);\n                }\n            }\n            if (exportStream != null) {\n                try {\n                    exportStream.close();\n                }\n                catch (Exception e) {\n                    // nothing we can do.\n                }\n            }\n        }\n    }\n\n    @Transactional(rollbackOn = {IOException.class, ImporterException.class,\n            RuntimeException.class, ImportConflictException.class})\n    // WARNING: Keep this method public, otherwise @Transactional is ignored:\n    ConsumerDto importObjects(Owner owner, Map<String, File> importFiles,\n        ConflictOverrides overrides)\n        throws IOException, ImporterException {\n\n        File metadata = importFiles.get(ImportFile.META.fileName());\n        if (metadata == null) {\n            throw new ImporterException(i18n.tr(\"The archive does not contain the \" +\n                                   \"required meta.json file\"));\n        }\n        File rules = importFiles.get(ImportFile.RULES.fileName());\n        if (rules == null) {\n            throw new ImporterException(i18n.tr(\"The archive does not contain the \" +\n                                    \"required rules directory\"));\n        }\n        if (rules.listFiles().length == 0) {\n            throw new ImporterException(i18n.tr(\"The archive does not contain the \" +\n                \"required rules file(s)\"));\n        }\n        File consumerTypes = importFiles.get(ImportFile.CONSUMER_TYPE.fileName());\n        if (consumerTypes == null) {\n            throw new ImporterException(i18n.tr(\"The archive does not contain the \" +\n                                    \"required consumer_types directory\"));\n        }\n        File consumerFile = importFiles.get(ImportFile.CONSUMER.fileName());\n        if (consumerFile == null) {\n            throw new ImporterException(i18n.tr(\"The archive does not contain the \" +\n                \"required consumer.json file\"));\n        }\n        File products = importFiles.get(ImportFile.PRODUCTS.fileName());\n        File entitlements = importFiles.get(ImportFile.ENTITLEMENTS.fileName());\n        if (products != null && entitlements == null) {\n            throw new ImporterException(i18n.tr(\"The archive does not contain the \" +\n                                        \"required entitlements directory\"));\n        }\n\n        // system level elements\n        /*\n         * Checking a system wide last import date breaks multi-tenant deployments whenever\n         * one org imports a manifest slightly older than another org who has already\n         * imported. Disabled for now. See bz #769644.\n         */\n//        validateMetadata(ExporterMetadata.TYPE_SYSTEM, null, metadata, force);\n\n        // If any calls find conflicts we'll assemble them into one exception detailing all\n        // the conflicts which occurred, so the caller can override them all at once\n        // if desired:\n        List<ImportConflictException> conflictExceptions =\n            new LinkedList<ImportConflictException>();\n\n        importRules(rules.listFiles(), metadata);\n\n        importConsumerTypes(consumerTypes.listFiles());\n\n        // per user elements\n        try {\n            validateMetadata(ExporterMetadata.TYPE_PER_USER, owner, metadata,\n                overrides);\n        }\n        catch (ImportConflictException e) {\n            conflictExceptions.add(e);\n        }\n\n        ConsumerDto consumer = null;\n        try {\n            consumer = importConsumer(owner, consumerFile, overrides);\n        }\n        catch (ImportConflictException e) {\n            conflictExceptions.add(e);\n        }\n\n        // At this point we're done checking for any potential conflicts:\n        if (!conflictExceptions.isEmpty()) {\n            log.error(\"Conflicts occurred during import that were not overridden:\");\n            for (ImportConflictException e : conflictExceptions) {\n                log.error(e.message().getConflicts());\n            }\n            throw new ImportConflictException(conflictExceptions);\n        }\n\n        // If the consumer has no entitlements, this products directory will end up empty.\n        // This also implies there will be no entitlements to import.\n        if (importFiles.get(ImportFile.PRODUCTS.fileName()) != null) {\n            Refresher refresher = poolManager.getRefresher();\n            ProductImporter importer = new ProductImporter(productCurator, contentCurator, poolManager);\n\n            Set<Product> productsToImport = importProducts(\n                importFiles.get(ImportFile.PRODUCTS.fileName()).listFiles(),\n                importer);\n\n            Set<Product> modifiedProducts = importer.getChangedProducts(productsToImport);\n            for (Product product : modifiedProducts) {\n                refresher.add(product);\n            }\n\n            importer.store(productsToImport);\n\n            importEntitlements(owner, productsToImport, entitlements.listFiles());\n\n            refresher.add(owner);\n            refresher.run();\n        }\n        else {\n            log.warn(\"No products found to import, skipping product and entitlement import.\");\n        }\n\n\n        return consumer;\n    }\n\n    public void importRules(File[] rulesFiles, File metadata) throws IOException {\n\n        // only import rules if versions are ok\n        Meta m = mapper.readValue(metadata, Meta.class);\n\n        if (VersionUtil.getRulesVersionCompatibility(m.getVersion())) {\n            // Only importing a single rules file now.\n            Reader reader = null;\n            try {\n                reader = new FileReader(rulesFiles[0]);\n                rulesImporter.importObject(reader, m.getVersion());\n            }\n            finally {\n                if (reader != null) {\n                    reader.close();\n                }\n            }\n        }\n        else {\n            log.warn(\n                i18n.tr(\n                    \"Incompatible rules: import version {0} older than our version {1}.\",\n                    m.getVersion(), VersionUtil.getVersionString()));\n            log.warn(\n                i18n.tr(\"Manifest data will be imported without rules import.\"));\n        }\n\n    }\n\n    public void importConsumerTypes(File[] consumerTypes) throws IOException {\n        ConsumerTypeImporter importer = new ConsumerTypeImporter(consumerTypeCurator);\n        Set<ConsumerType> consumerTypeObjs = new HashSet<ConsumerType>();\n        for (File consumerType : consumerTypes) {\n            Reader reader = null;\n            try {\n                reader = new FileReader(consumerType);\n                consumerTypeObjs.add(importer.createObject(mapper, reader));\n            }\n            finally {\n                if (reader != null) {\n                    reader.close();\n                }\n            }\n        }\n        importer.store(consumerTypeObjs);\n    }\n\n    public ConsumerDto importConsumer(Owner owner, File consumerFile,\n        ConflictOverrides forcedConflicts)\n        throws IOException, SyncDataFormatException {\n        ConsumerImporter importer = new ConsumerImporter(ownerCurator, i18n);\n        Reader reader = null;\n        ConsumerDto consumer = null;\n        try {\n            reader = new FileReader(consumerFile);\n            consumer = importer.createObject(mapper, reader);\n            importer.store(owner, consumer, forcedConflicts);\n        }\n        finally {\n            if (reader != null) {\n                reader.close();\n            }\n        }\n        return consumer;\n    }\n\n    public Set<Product> importProducts(File[] products, ProductImporter importer)\n        throws IOException {\n        Set<Product> productsToImport = new HashSet<Product>();\n        for (File product : products) {\n            // Skip product.pem's, we just need the json to import:\n            if (product.getName().endsWith(\".json\")) {\n                log.debug(\"Import product: \" + product.getName());\n                Reader reader = null;\n                try {\n                    reader = new FileReader(product);\n                    productsToImport.add(importer.createObject(mapper, reader));\n                }\n                finally {\n                    if (reader != null) {\n                        reader.close();\n                    }\n                }\n            }\n        }\n\n        // TODO: Do we need to cleanup unused products? Looked at this earlier and it\n        // looks somewhat complex and a little bit dangerous, so we're leaving them\n        // around for now.\n\n        return productsToImport;\n    }\n\n    public void importEntitlements(Owner owner, Set<Product> products, File[] entitlements)\n        throws IOException, SyncDataFormatException {\n        EntitlementImporter importer = new EntitlementImporter(subCurator, csCurator,\n            sink, i18n);\n\n        Map<String, Product> productsById = new HashMap<String, Product>();\n        for (Product product : products) {\n            productsById.put(product.getId(), product);\n        }\n\n        Set<Subscription> subscriptionsToImport = new HashSet<Subscription>();\n        for (File entitlement : entitlements) {\n            Reader reader = null;\n            try {\n                log.debug(\"Import entitlement: \" + entitlement.getName());\n                reader = new FileReader(entitlement);\n                subscriptionsToImport.add(importer.importObject(mapper, reader, owner, productsById));\n            }\n            finally {\n                if (reader != null) {\n                    reader.close();\n                }\n            }\n        }\n\n        importer.store(owner, subscriptionsToImport);\n    }\n\n    /**\n     * Create a tar.gz archive of the exported directory.\n     *\n     * @param exportDir Directory where Candlepin data was exported.\n     * @return File reference to the new archive tar.gz.\n     */\n    private File extractArchive(File tempDir, File exportFile)\n        throws IOException, ImportExtractionException {\n        log.info(\"Extracting archive to: \" + tempDir.getAbsolutePath());\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = new ZipInputStream(new FileInputStream(exportFile));\n        ZipEntry zipentry = zipinputstream.getNextEntry();\n\n        if (zipentry == null) {\n            throw new ImportExtractionException(i18n.tr(\"The archive {0} is not \" +\n                \"a properly compressed file or is empty\", exportFile.getName()));\n        }\n\n        while (zipentry != null) {\n            //for each entry to be extracted\n            String entryName = zipentry.getName();\n            if (log.isDebugEnabled()) {\n                log.debug(\"entryname \" + entryName);\n            }\n            FileOutputStream fileoutputstream;\n            File newFile = new File(entryName);\n            String directory = newFile.getParent();\n            if (directory != null) {\n                new File(tempDir, directory).mkdirs();\n            }\n\n            fileoutputstream = new FileOutputStream(new File(tempDir, entryName));\n\n            int n;\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) {\n                fileoutputstream.write(buf, 0, n);\n            }\n\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n            zipentry = zipinputstream.getNextEntry();\n\n        }\n\n        zipinputstream.close();\n\n        return new File(tempDir.getAbsolutePath(), \"export\");\n    }\n\n    private byte[] loadSignature(File signatureFile) throws IOException {\n        FileInputStream signature = null;\n        // signature is never going to be a huge file, therefore cast is a-okay\n        byte[] signatureBytes = new byte[(int) signatureFile.length()];\n\n        try {\n            signature = new FileInputStream(signatureFile);\n\n            int offset = 0;\n            int numRead = 0;\n            while (offset < signatureBytes.length && numRead >= 0) {\n                numRead = signature.read(signatureBytes, offset,\n                    signatureBytes.length - offset);\n                offset += numRead;\n            }\n            return signatureBytes;\n        }\n        finally {\n            if (signature != null) {\n                try {\n                    signature.close();\n                }\n                catch (IOException e) {\n                    // nothing we can do about this\n                }\n            }\n        }\n    }\n}\n", "target": 1}
{"idx": 1006, "func": "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.samsungtv.internal.service;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.HashMap;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * The {@link SamsungTvUtils} provides some utilities for internal use.\n *\n * @author Pauli Anttila - Initial contribution\n */\n@NonNullByDefault\npublic class SamsungTvUtils {\n\n    /**\n     * Build {@link String} type {@link HashMap} from variable number of\n     * {@link String}s.\n     *\n     * @param data\n     *            Variable number of {@link String} parameters which will be\n     *            added to hash map.\n     */\n    public static HashMap<String, String> buildHashMap(String... data) {\n        HashMap<String, String> result = new HashMap<>();\n\n        if (data.length % 2 != 0) {\n            throw new IllegalArgumentException(\"Odd number of arguments\");\n        }\n        String key = null;\n        Integer step = -1;\n\n        for (String value : data) {\n            step++;\n            switch (step % 2) {\n                case 0:\n                    if (value == null) {\n                        throw new IllegalArgumentException(\"Null key value\");\n                    }\n                    key = value;\n                    continue;\n                case 1:\n                    if (key != null) {\n                        result.put(key, value);\n                    }\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Build {@link Document} from {@link String} which contains XML content.\n     *\n     * @param xml\n     *            {@link String} which contains XML content.\n     * @return {@link Document} or null if convert has failed.\n     */\n    public static @Nullable Document loadXMLFromString(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xml));\n            return builder.parse(is);\n\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            // Silently ignore exception and return null.\n        }\n\n        return null;\n    }\n}\n", "target": 0}
{"idx": 1007, "func": "/*\n * Copyright 2019 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.channel;\n\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.Test;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.Channels;\nimport java.nio.channels.WritableByteChannel;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\npublic class DefaultFileRegionTest {\n\n    private static final byte[] data = new byte[1048576 * 10];\n\n    static {\n        PlatformDependent.threadLocalRandom().nextBytes(data);\n    }\n\n    private static File newFile() throws IOException {\n        File file = PlatformDependent.createTempFile(\"netty-\", \".tmp\", null);\n        file.deleteOnExit();\n\n        final FileOutputStream out = new FileOutputStream(file);\n        out.write(data);\n        out.close();\n        return file;\n    }\n\n    @Test\n    public void testCreateFromFile() throws IOException  {\n        File file = newFile();\n        try {\n            testFileRegion(new DefaultFileRegion(file, 0, data.length));\n        } finally {\n            file.delete();\n        }\n    }\n\n    @Test\n    public void testCreateFromFileChannel() throws IOException  {\n        File file = newFile();\n        RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\");\n        try {\n            testFileRegion(new DefaultFileRegion(randomAccessFile.getChannel(), 0, data.length));\n        } finally {\n            randomAccessFile.close();\n            file.delete();\n        }\n    }\n\n    private static void testFileRegion(FileRegion region) throws IOException  {\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        WritableByteChannel channel = Channels.newChannel(outputStream);\n\n        try {\n            assertEquals(data.length, region.count());\n            assertEquals(0, region.transferred());\n            assertEquals(data.length, region.transferTo(channel, 0));\n            assertEquals(data.length, region.count());\n            assertEquals(data.length, region.transferred());\n            assertArrayEquals(data, outputStream.toByteArray());\n        } finally {\n            channel.close();\n        }\n    }\n\n    @Test\n    public void testTruncated() throws IOException  {\n        File file = newFile();\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        WritableByteChannel channel = Channels.newChannel(outputStream);\n        RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"rw\");\n\n        try {\n            FileRegion region = new DefaultFileRegion(randomAccessFile.getChannel(), 0, data.length);\n\n            randomAccessFile.getChannel().truncate(data.length - 1024);\n\n            assertEquals(data.length, region.count());\n            assertEquals(0, region.transferred());\n\n            assertEquals(data.length - 1024, region.transferTo(channel, 0));\n            assertEquals(data.length, region.count());\n            assertEquals(data.length - 1024, region.transferred());\n            try {\n                region.transferTo(channel, data.length - 1024);\n                fail();\n            } catch (IOException expected) {\n                // expected\n            }\n        } finally {\n            channel.close();\n\n            randomAccessFile.close();\n            file.delete();\n        }\n    }\n}\n", "target": 0}
{"idx": 1008, "func": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016, 2020 Synacor, Inc.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software Foundation,\n * version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n * You should have received a copy of the GNU General Public License along with this program.\n * If not, see <https://www.gnu.org/licenses/>.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.service.account;\n\nimport java.util.Map;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.soap.AccountConstants;\nimport com.zimbra.common.soap.Element;\nimport com.zimbra.cs.account.Account;\nimport com.zimbra.cs.account.Provisioning;\nimport com.zimbra.cs.gal.GalSearchControl;\nimport com.zimbra.cs.gal.GalSearchParams;\nimport com.zimbra.soap.ZimbraSoapContext;\nimport com.zimbra.soap.type.GalSearchType;\n\n/**\n * @since May 26, 2004\n * @author schemers\n */\npublic class AutoCompleteGal extends GalDocumentHandler {\n\n    @Override\n    public Element handle(Element request, Map<String, Object> context) throws ServiceException {\n        ZimbraSoapContext zsc = getZimbraSoapContext(context);\n        Account account = getRequestedAccount(getZimbraSoapContext(context));\n\n        if (!canAccessAccount(zsc, account))\n            throw ServiceException.PERM_DENIED(\"can not access account\");\n        \n        String name = request.getAttribute(AccountConstants.E_NAME);\n        String typeStr = request.getAttribute(AccountConstants.A_TYPE, \"account\");\n        GalSearchType type = GalSearchType.fromString(typeStr);\n\n        boolean needCanExpand = request.getAttributeBool(AccountConstants.A_NEED_EXP, false);\n\n        String galAcctId = request.getAttribute(AccountConstants.A_GAL_ACCOUNT_ID, null);\n        \n        GalSearchParams params = new GalSearchParams(account, zsc);\n        params.setType(type);\n        params.setRequest(request);\n        params.setQuery(name);\n        params.setLimit(account.getContactAutoCompleteMaxResults());\n        params.setNeedCanExpand(needCanExpand);\n        params.setResponseName(AccountConstants.AUTO_COMPLETE_GAL_RESPONSE);\n        if (galAcctId != null) {\n            Account galAccount = Provisioning.getInstance().getAccountById(galAcctId);\n            if (galAccount != null && (!account.getDomainId().equals(galAccount.getDomainId()))) {\n                throw ServiceException\n                    .PERM_DENIED(\"can not access galsync account of different domain\");\n            }\n            params.setGalSyncAccount(galAccount);\n        }\n        GalSearchControl gal = new GalSearchControl(params);\n        gal.autocomplete();\n        return params.getResultCallback().getResponse();\n    }\n\n    @Override\n    public boolean needsAuth(Map<String, Object> context) {\n        return true;\n    }\n}\n", "target": 0}
{"idx": 1009, "func": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.io.FileWriteMode.APPEND;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.TreeTraverser;\nimport com.google.common.graph.SuccessorsFunction;\nimport com.google.common.graph.Traverser;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Provides utility methods for working with {@linkplain File files}.\n *\n * <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the\n * JDK's {@link java.nio.file.Files} class.\n *\n * @author Chris Nokleberg\n * @author Colin Decker\n * @since 1.0\n */\n@GwtIncompatible\npublic final class Files {\n\n  /** Maximum loop count when creating temp directories. */\n  private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n  private Files() {}\n\n  /**\n   * Returns a buffered reader that reads from a file using the given character set.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the buffered reader\n   */\n  @Beta\n  public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n  }\n\n  /**\n   * Returns a buffered writer that writes to a file using the given character set.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n   * java.nio.file.OpenOption...)}.\n   *\n   * @param file the file to write to\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the buffered writer\n   */\n  @Beta\n  public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n  }\n\n  /**\n   * Returns a new {@link ByteSource} for reading bytes from the given file.\n   *\n   * @since 14.0\n   */\n  public static ByteSource asByteSource(File file) {\n    return new FileByteSource(file);\n  }\n\n  private static final class FileByteSource extends ByteSource {\n\n    private final File file;\n\n    private FileByteSource(File file) {\n      this.file = checkNotNull(file);\n    }\n\n    @Override\n    public FileInputStream openStream() throws IOException {\n      return new FileInputStream(file);\n    }\n\n    @Override\n    public Optional<Long> sizeIfKnown() {\n      if (file.isFile()) {\n        return Optional.of(file.length());\n      } else {\n        return Optional.absent();\n      }\n    }\n\n    @Override\n    public long size() throws IOException {\n      if (!file.isFile()) {\n        throw new FileNotFoundException(file.toString());\n      }\n      return file.length();\n    }\n\n    @Override\n    public byte[] read() throws IOException {\n      Closer closer = Closer.create();\n      try {\n        FileInputStream in = closer.register(openStream());\n        return ByteStreams.toByteArray(in, in.getChannel().size());\n      } catch (Throwable e) {\n        throw closer.rethrow(e);\n      } finally {\n        closer.close();\n      }\n    }\n\n    @Override\n    public String toString() {\n      return \"Files.asByteSource(\" + file + \")\";\n    }\n  }\n\n  /**\n   * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n   * control how the file is opened for writing. When no mode is provided, the file will be\n   * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n   * will append to the end of the file without truncating it.\n   *\n   * @since 14.0\n   */\n  public static ByteSink asByteSink(File file, FileWriteMode... modes) {\n    return new FileByteSink(file, modes);\n  }\n\n  private static final class FileByteSink extends ByteSink {\n\n    private final File file;\n    private final ImmutableSet<FileWriteMode> modes;\n\n    private FileByteSink(File file, FileWriteMode... modes) {\n      this.file = checkNotNull(file);\n      this.modes = ImmutableSet.copyOf(modes);\n    }\n\n    @Override\n    public FileOutputStream openStream() throws IOException {\n      return new FileOutputStream(file, modes.contains(APPEND));\n    }\n\n    @Override\n    public String toString() {\n      return \"Files.asByteSink(\" + file + \", \" + modes + \")\";\n    }\n  }\n\n  /**\n   * Returns a new {@link CharSource} for reading character data from the given file using the given\n   * character set.\n   *\n   * @since 14.0\n   */\n  public static CharSource asCharSource(File file, Charset charset) {\n    return asByteSource(file).asCharSource(charset);\n  }\n\n  /**\n   * Returns a new {@link CharSink} for writing character data to the given file using the given\n   * character set. The given {@code modes} control how the file is opened for writing. When no mode\n   * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n   * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n   *\n   * @since 14.0\n   */\n  public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes) {\n    return asByteSink(file, modes).asCharSink(charset);\n  }\n\n  /**\n   * Reads all bytes from a file into a byte array.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.\n   *\n   * @param file the file to read from\n   * @return a byte array containing all the bytes from file\n   * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n   *     (2^31 - 1)\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static byte[] toByteArray(File file) throws IOException {\n    return asByteSource(file).read();\n  }\n\n  /**\n   * Reads all characters from a file into a {@link String}, using the given character set.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return a string containing all the characters from the file\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public static String toString(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).read();\n  }\n\n  /**\n   * Overwrites a file with the contents of a byte array.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n   *\n   * @param from the bytes to write\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static void write(byte[] from, File to) throws IOException {\n    asByteSink(to).write(from);\n  }\n\n  /**\n   * Writes a character sequence (such as a string) to a file using the given character set.\n   *\n   * @param from the character sequence to write\n   * @param to the destination file\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public static void write(CharSequence from, File to, Charset charset) throws IOException {\n    asCharSink(to, charset).write(from);\n  }\n\n  /**\n   * Copies all bytes from a file to an output stream.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n   *\n   * @param from the source file\n   * @param to the output stream\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static void copy(File from, OutputStream to) throws IOException {\n    asByteSource(from).copyTo(to);\n  }\n\n  /**\n   * Copies all the bytes from one file to another.\n   *\n   * <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\n   * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\n   * need to guard against those conditions, you should employ other file-level synchronization.\n   *\n   * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n   * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n   * file, the contents of that file will be deleted.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n   *\n   * @param from the source file\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   * @throws IllegalArgumentException if {@code from.equals(to)}\n   */\n  @Beta\n  public static void copy(File from, File to) throws IOException {\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n    asByteSource(from).copyTo(asByteSink(to));\n  }\n\n  /**\n   * Copies all characters from a file to an appendable object, using the given character set.\n   *\n   * @param from the source file\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @param to the appendable object\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to\n   *     be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static void copy(File from, Charset charset, Appendable to) throws IOException {\n    asCharSource(from, charset).copyTo(to);\n  }\n\n  /**\n   * Appends a character sequence (such as a string) to a file using the given character set.\n   *\n   * @param from the character sequence to append\n   * @param to the destination file\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n   *     method is scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static void append(CharSequence from, File to, Charset charset) throws IOException {\n    asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n  }\n\n  /**\n   * Returns true if the given files exist, are not directories, and contain the same bytes.\n   *\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static boolean equal(File file1, File file2) throws IOException {\n    checkNotNull(file1);\n    checkNotNull(file2);\n    if (file1 == file2 || file1.equals(file2)) {\n      return true;\n    }\n\n    /*\n     * Some operating systems may return zero as the length for files denoting system-dependent\n     * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n     * directly.\n     */\n    long len1 = file1.length();\n    long len2 = file2.length();\n    if (len1 != 0 && len2 != 0 && len1 != len2) {\n      return false;\n    }\n    return asByteSource(file1).contentEquals(asByteSource(file2));\n  }\n\n  /**\n   * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n   * defined by the {@code java.io.tmpdir} system property), and returns its name.\n   *\n   * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n   * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n   * delete the file and create a directory in its place, but this leads a race condition which can\n   * be exploited to create security vulnerabilities, especially when executable files are to be\n   * written into the directory.\n   *\n   * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n   * and that it will not be called thousands of times per second.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#createTempDirectory}.\n   *\n   * @return the newly-created directory\n   * @throws IllegalStateException if the directory could not be created\n   */\n  @Beta\n  public static File createTempDir() {\n    File baseDir = new File(System.getProperty(\"java.io.tmpdir\"));\n    @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n    String baseName = System.currentTimeMillis() + \"-\";\n\n    for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++) {\n      File tempDir = new File(baseDir, baseName + counter);\n      if (tempDir.mkdir()) {\n        return tempDir;\n      }\n    }\n    throw new IllegalStateException(\n        \"Failed to create directory within \"\n            + TEMP_DIR_ATTEMPTS\n            + \" attempts (tried \"\n            + baseName\n            + \"0 to \"\n            + baseName\n            + (TEMP_DIR_ATTEMPTS - 1)\n            + ')');\n  }\n\n  /**\n   * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n   * the same name.\n   *\n   * @param file the file to create or update\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n  public static void touch(File file) throws IOException {\n    checkNotNull(file);\n    if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {\n      throw new IOException(\"Unable to update modification time of \" + file);\n    }\n  }\n\n  /**\n   * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n   * this operation fails it may have succeeded in creating some (but not all) of the necessary\n   * parent directories.\n   *\n   * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n   *     directories of the specified file could not be created.\n   * @since 4.0\n   */\n  @Beta\n  public static void createParentDirs(File file) throws IOException {\n    checkNotNull(file);\n    File parent = file.getCanonicalFile().getParentFile();\n    if (parent == null) {\n      /*\n       * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n       * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n       * -- or even that the caller can create it, but this method makes no such guarantees even for\n       * non-root files.\n       */\n      return;\n    }\n    parent.mkdirs();\n    if (!parent.isDirectory()) {\n      throw new IOException(\"Unable to create parent directories of \" + file);\n    }\n  }\n\n  /**\n   * Moves a file from one path to another. This method can rename a file and/or move it to a\n   * different directory. In either case {@code to} must be the target path for the file itself; not\n   * just the new name for the file or the path to the new parent directory.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n   *\n   * @param from the source file\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   * @throws IllegalArgumentException if {@code from.equals(to)}\n   */\n  @Beta\n  public static void move(File from, File to) throws IOException {\n    checkNotNull(from);\n    checkNotNull(to);\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n\n    if (!from.renameTo(to)) {\n      copy(from, to);\n      if (!from.delete()) {\n        if (!to.delete()) {\n          throw new IOException(\"Unable to delete \" + to);\n        }\n        throw new IOException(\"Unable to delete \" + from);\n      }\n    }\n  }\n\n  /**\n   * Reads the first line from a file. The line does not include line-termination characters, but\n   * does include other leading and trailing whitespace.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the first line, or null if the file is empty\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\n   *     scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static String readFirstLine(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).readFirstLine();\n  }\n\n  /**\n   * Reads all of the lines from a file. The lines do not include line-termination characters, but\n   * do include other leading and trailing whitespace.\n   *\n   * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n   * Files.asCharSource(file, charset).readLines()}.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return a mutable {@link List} containing all the lines\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static List<String> readLines(File file, Charset charset) throws IOException {\n    // don't use asCharSource(file, charset).readLines() because that returns\n    // an immutable list, which would change the behavior of this method\n    return asCharSource(file, charset)\n        .readLines(\n            new LineProcessor<List<String>>() {\n              final List<String> result = Lists.newArrayList();\n\n              @Override\n              public boolean processLine(String line) {\n                result.add(line);\n                return true;\n              }\n\n              @Override\n              public List<String> getResult() {\n                return result;\n              }\n            });\n  }\n\n  /**\n   * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n   * all of the lines.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @param callback the {@link LineProcessor} to use to handle the lines\n   * @return the output of processing the lines\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is\n   *     scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  @CanIgnoreReturnValue // some processors won't return a useful result\n  public\n  static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException {\n    return asCharSource(file, charset).readLines(callback);\n  }\n\n  /**\n   * Process the bytes of a file.\n   *\n   * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n   *\n   * @param file the file to read\n   * @param processor the object to which the bytes of the file are passed.\n   * @return the result of the byte processor\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  @CanIgnoreReturnValue // some processors won't return a useful result\n  public\n  static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {\n    return asByteSource(file).read(processor);\n  }\n\n  /**\n   * Computes the hash code of the {@code file} using {@code hashFunction}.\n   *\n   * @param file the file to read\n   * @param hashFunction the hash function to use to hash the data\n   * @return the {@link HashCode} of all of the bytes in the file\n   * @throws IOException if an I/O error occurs\n   * @since 12.0\n   * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to\n   *     be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static HashCode hash(File file, HashFunction hashFunction) throws IOException {\n    return asByteSource(file).hash(hashFunction);\n  }\n\n  /**\n   * Fully maps a file read-only in to memory as per {@link\n   * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.\n   *\n   * <p>Files are mapped from offset 0 to its length.\n   *\n   * <p>This only works for files  {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @return a read-only buffer reflecting {@code file}\n   * @throws FileNotFoundException if the {@code file} does not exist\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file) throws IOException {\n    checkNotNull(file);\n    return map(file, MapMode.READ_ONLY);\n  }\n\n  /**\n   * Fully maps a file in to memory as per {@link\n   * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link\n   * MapMode}.\n   *\n   * <p>Files are mapped from offset 0 to its length.\n   *\n   * <p>This only works for files  {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @param mode the mode to use when mapping {@code file}\n   * @return a buffer reflecting {@code file}\n   * @throws FileNotFoundException if the {@code file} does not exist\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file, MapMode mode) throws IOException {\n    return mapInternal(file, mode, -1);\n  }\n\n  /**\n   * Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,\n   * long, long)} using the requested {@link MapMode}.\n   *\n   * <p>Files are mapped from offset 0 to {@code size}.\n   *\n   * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n   * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n   * which do not yet exist.\n   *\n   * <p>This only works for files  {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @param mode the mode to use when mapping {@code file}\n   * @return a buffer reflecting {@code file}\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException {\n    checkArgument(size >= 0, \"size (%s) may not be negative\", size);\n    return mapInternal(file, mode, size);\n  }\n\n  private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n      throws IOException {\n    checkNotNull(file);\n    checkNotNull(mode);\n\n    Closer closer = Closer.create();\n    try {\n      RandomAccessFile raf =\n          closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n      FileChannel channel = closer.register(raf.getChannel());\n      return channel.map(mode, 0, size == -1 ? channel.size() : size);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }\n\n  /**\n   * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n   * to the original. The following heuristics are used:\n   *\n   * <ul>\n   *   <li>empty string becomes .\n   *   <li>. stays as .\n   *   <li>fold out ./\n   *   <li>fold out ../ when possible\n   *   <li>collapse multiple slashes\n   *   <li>delete trailing slashes (unless the path is just \"/\")\n   * </ul>\n   *\n   * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n   * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n   * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n   * sibling of {@code a} referred to by {@code b}.\n   *\n   * @since 11.0\n   */\n  @Beta\n  public static String simplifyPath(String pathname) {\n    checkNotNull(pathname);\n    if (pathname.length() == 0) {\n      return \".\";\n    }\n\n    // split the path apart\n    Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n    List<String> path = new ArrayList<>();\n\n    // resolve ., .., and //\n    for (String component : components) {\n      switch (component) {\n        case \".\":\n          continue;\n        case \"..\":\n          if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\")) {\n            path.remove(path.size() - 1);\n          } else {\n            path.add(\"..\");\n          }\n          break;\n        default:\n          path.add(component);\n          break;\n      }\n    }\n\n    // put it back together\n    String result = Joiner.on('/').join(path);\n    if (pathname.charAt(0) == '/') {\n      result = \"/\" + result;\n    }\n\n    while (result.startsWith(\"/../\")) {\n      result = result.substring(3);\n    }\n    if (result.equals(\"/..\")) {\n      result = \"/\";\n    } else if (\"\".equals(result)) {\n      result = \".\";\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n   * the given file name, or the empty string if the file has no extension. The result does not\n   * include the '{@code .}'.\n   *\n   * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n   * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n   * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n   * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n   * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n   * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n   *\n   * @since 11.0\n   */\n  @Beta\n  public static String getFileExtension(String fullName) {\n    checkNotNull(fullName);\n    String fileName = new File(fullName).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n  }\n\n  /**\n   * Returns the file name without its <a\n   * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n   * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n   *\n   * @param file The name of the file to trim the extension from. This can be either a fully\n   *     qualified file name (including a path) or just a file name.\n   * @return The file name without its path or extension.\n   * @since 14.0\n   */\n  @Beta\n  public static String getNameWithoutExtension(String file) {\n    checkNotNull(file);\n    String fileName = new File(file).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n  }\n\n  /**\n   * Returns a {@link TreeTraverser} instance for {@link File} trees.\n   *\n   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n   * this case, iterables created by this traverser could contain files that are outside of the\n   * given directory or even be infinite if there is a symbolic link loop.\n   *\n   * @since 15.0\n   * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method\n   *     {@link #fileTraverser()} instead with the same semantics as this method.\n   */\n  @Deprecated\n  static TreeTraverser<File> fileTreeTraverser() {\n    return FILE_TREE_TRAVERSER;\n  }\n\n  private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n      new TreeTraverser<File>() {\n        @Override\n        public Iterable<File> children(File file) {\n          return fileTreeChildren(file);\n        }\n\n        @Override\n        public String toString() {\n          return \"Files.fileTreeTraverser()\";\n        }\n      };\n\n  /**\n   * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n   * starts from a {@link File} and will return all files and directories it encounters.\n   *\n   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n   * this case, iterables created by this traverser could contain files that are outside of the\n   * given directory or even be infinite if there is a symbolic link loop.\n   *\n   * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n   * except that it doesn't follow symbolic links and returns {@code Path} instances.\n   *\n   * <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not\n   * a directory, no exception will be thrown and the returned {@link Iterable} will contain a\n   * single element: that file.\n   *\n   * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(\"/\"))} may return files\n   * with the following paths: {@code [\"/\", \"/etc\", \"/etc/config.txt\", \"/etc/fonts\", \"/home\",\n   * \"/home/alice\", ...]}\n   *\n   * @since 23.5\n   */\n  @Beta\n  public static Traverser<File> fileTraverser() {\n    return Traverser.forTree(FILE_TREE);\n  }\n\n  private static final SuccessorsFunction<File> FILE_TREE =\n      new SuccessorsFunction<File>() {\n        @Override\n        public Iterable<File> successors(File file) {\n          return fileTreeChildren(file);\n        }\n      };\n\n  private static Iterable<File> fileTreeChildren(File file) {\n    // check isDirectory() just because it may be faster than listFiles() on a non-directory\n    if (file.isDirectory()) {\n      File[] files = file.listFiles();\n      if (files != null) {\n        return Collections.unmodifiableList(Arrays.asList(files));\n      }\n    }\n\n    return Collections.emptyList();\n  }\n\n  /**\n   * Returns a predicate that returns the result of {@link File#isDirectory} on input files.\n   *\n   * @since 15.0\n   */\n  @Beta\n  public static Predicate<File> isDirectory() {\n    return FilePredicate.IS_DIRECTORY;\n  }\n\n  /**\n   * Returns a predicate that returns the result of {@link File#isFile} on input files.\n   *\n   * @since 15.0\n   */\n  @Beta\n  public static Predicate<File> isFile() {\n    return FilePredicate.IS_FILE;\n  }\n\n  private enum FilePredicate implements Predicate<File> {\n    IS_DIRECTORY {\n      @Override\n      public boolean apply(File file) {\n        return file.isDirectory();\n      }\n\n      @Override\n      public String toString() {\n        return \"Files.isDirectory()\";\n      }\n    },\n\n    IS_FILE {\n      @Override\n      public boolean apply(File file) {\n        return file.isFile();\n      }\n\n      @Override\n      public String toString() {\n        return \"Files.isFile()\";\n      }\n    }\n  }\n}\n", "target": 1}
{"idx": 1010, "func": "package org.jooby.internal;\n\nimport com.google.common.base.Strings;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\npublic interface AssetSource {\n  URL getResource(String name);\n\n  static AssetSource fromClassPath(ClassLoader loader, String source) {\n    if (Strings.isNullOrEmpty(source) || \"/\".equals(source.trim())) {\n      throw new IllegalArgumentException(\n          \"For security reasons root classpath access is not allowed: \" + source);\n    }\n    return path -> {\n      URL resource = loader.getResource(path);\n      if (resource == null) {\n        return null;\n      }\n      String realPath = resource.getPath();\n      if (realPath.startsWith(source)) {\n        return resource;\n      }\n      return null;\n    };\n  }\n\n  static AssetSource fromFileSystem(Path basedir) {\n    return name -> {\n      Path path = basedir.resolve(name).normalize();\n      if (Files.exists(path) && path.startsWith(basedir)) {\n        try {\n          return path.toUri().toURL();\n        } catch (MalformedURLException x) {\n          // shh\n        }\n      }\n      return null;\n    };\n  }\n}\n", "target": 0}
{"idx": 1011, "func": "package org.jbpm.designer.bpmn2.resource;\n\n\nimport bpsim.impl.BpsimPackageImpl;\nimport org.eclipse.bpmn2.*;\nimport org.eclipse.bpmn2.util.Bpmn2ResourceImpl;\nimport org.eclipse.emf.common.util.URI;\nimport org.eclipse.emf.common.util.WrappedException;\nimport org.eclipse.emf.ecore.EObject;\nimport org.eclipse.emf.ecore.EStructuralFeature;\nimport org.eclipse.emf.ecore.xmi.XMLLoad;\nimport org.eclipse.emf.ecore.xmi.XMLResource;\nimport org.eclipse.emf.ecore.xmi.XMLSave;\nimport org.eclipse.emf.ecore.xmi.impl.XMLLoadImpl;\nimport org.eclipse.emf.ecore.resource.Resource;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class JBPMBpmn2ResourceImpl extends Bpmn2ResourceImpl {\n\n    public HashMap xmlNameToFeatureMap = new HashMap();\n\n\tpublic JBPMBpmn2ResourceImpl(URI uri) {\n\t\tsuper(uri);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DEFER_IDREF_RESOLUTION, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DISABLE_NOTIFY, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_USE_XML_NAME_TO_FEATURE_MAP, xmlNameToFeatureMap);\n\n        // Switch off DTD external entity processing\n        Map parserFeatures = new HashMap();\n        parserFeatures.put(\"http://xml.org/sax/features/external-general-entities\", false);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_PARSER_FEATURES, parserFeatures);\n\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_ENCODING, \"UTF-8\");\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_PROCESS_DANGLING_HREF, XMLResource.OPTION_PROCESS_DANGLING_HREF_DISCARD);\n\t}\n\t\n\t@Override\n    protected XMLSave createXMLSave() {\n        prepareSave();\n        return new JBPMXMLSaveImpl(createXMLHelper()) {\n            @Override\n            protected boolean shouldSaveFeature(EObject o, EStructuralFeature f) {\n                if (Bpmn2Package.eINSTANCE.getDocumentation_Text().equals(f))\n                    return false;\n                if (Bpmn2Package.eINSTANCE.getFormalExpression_Body().equals(f))\n                    return false;\n                return super.shouldSaveFeature(o, f);\n            }\n        };\n    }\n\n    @Override\n    protected XMLLoad createXMLLoad() {\n//        DroolsPackageImpl.init();\n//        BpsimPackageImpl.init();\n        return new XMLLoadImpl(createXMLHelper()) {\n\n            @Override\n            public void load(XMLResource resource, InputStream inputStream, Map<?, ?> options) throws IOException {\n                try {\n                    super.load(resource, inputStream, options);\n                }\n                catch (Exception e) {\n                    DiagnosticWrappedException error = new DiagnosticWrappedException(e);\n                    resource.getErrors().add(error);\n                }\n            }\n        };\n    }\n\n    class DiagnosticWrappedException extends WrappedException implements Resource.Diagnostic {\n        private static final long serialVersionUID = 1L;\n        private String location;\n        private int column;\n        private int line;\n\n        public DiagnosticWrappedException(Exception exception) {\n            super(exception);\n        }\n\n        public void setLocation(String location) {\n            this.location = location;\n        }\n\n        public String getLocation() {\n            return location;\n        }\n\n        public void setColumn(int column) {\n            this.column = column;;\n        }\n\n        public int getColumn() {\n            return column;\n        }\n\n        public void setLine(int line) {\n            this.line = line;\n        }\n\n        public int getLine() {\n            return line;\n        }\n    }\n}", "target": 1}
{"idx": 1012, "func": "package eu.hinsch.spring.boot.actuator.logview;\n\nimport org.apache.catalina.ssi.ByteArrayServletOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.junit.rules.TemporaryFolder;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.springframework.ui.ExtendedModelMap;\nimport org.springframework.ui.Model;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.zip.GZIPOutputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\nimport static java.util.stream.Collectors.toList;\nimport static org.hamcrest.Matchers.*;\nimport static org.junit.Assert.assertThat;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@SuppressWarnings(\"unchecked\")\npublic class LogViewEndpointTest {\n\n    @Rule\n    public TemporaryFolder temporaryFolder = new TemporaryFolder();\n\n    @Rule\n    public ExpectedException expectedException = ExpectedException.none();\n\n    @Mock\n    private HttpServletResponse response;\n\n    private LogViewEndpoint logViewEndpoint;\n\n    private Model model;\n    private long now;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        logViewEndpoint = new LogViewEndpoint(temporaryFolder.getRoot().getAbsolutePath(),\n                new LogViewEndpointAutoconfig.EndpointConfiguration().getStylesheets());\n        model = new ExtendedModelMap();\n        now = new Date().getTime();\n    }\n\n    @Test\n    public void shouldReturnEmptyFileListForEmptyDirectory() throws Exception {\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(model.containsAttribute(\"files\"), is(true));\n        assertThat(getFileEntries(), hasSize(0));\n    }\n\n    @Test\n    public void shouldListSortedByFilename() throws Exception {\n        // given\n        createFile(\"B.log\", \"x\", now);\n        createFile(\"A.log\", \"x\", now);\n        createFile(\"C.log\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"A.log\", \"B.log\", \"C.log\"));\n    }\n\n    @Test\n    public void shouldListReverseSortedByFilename() throws Exception {\n        // given\n        createFile(\"B.log\", \"x\", now);\n        createFile(\"A.log\", \"x\", now);\n        createFile(\"C.log\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, true, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"C.log\", \"B.log\", \"A.log\"));\n    }\n\n    @Test\n    public void shouldListSortedBySize() throws Exception {\n        // given\n        createFile(\"A.log\", \"xx\", now);\n        createFile(\"B.log\", \"x\", now);\n        createFile(\"C.log\", \"xxx\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.SIZE, false, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"B.log\", \"A.log\", \"C.log\"));\n        assertThat(getFileSizes(), contains(1L, 2L, 3L));\n    }\n\n    @Test\n    public void shouldListSortedByDate() throws Exception {\n        // given\n        // TODO java 8 date api\n        createFile(\"A.log\", \"x\", now);\n        createFile(\"B.log\", \"x\", now - 10 * 60 * 1000);\n        createFile(\"C.log\", \"x\", now - 5 * 60 * 1000);\n\n        // when\n        logViewEndpoint.list(model, SortBy.MODIFIED, false, null);\n\n        // then\n        assertThat(getFileNames(), contains(\"B.log\", \"C.log\", \"A.log\"));\n        assertThat(getFilePrettyTimes(), contains(\"10 minutes ago\", \"5 minutes ago\", \"moments ago\"));\n    }\n\n    @Test\n    public void shouldSetFileTypeForFile() throws Exception {\n        // given\n        createFile(\"A.log\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(getFileEntries().get(0).getFileType(), is(FileType.FILE));\n    }\n\n    @Test\n    public void shouldSetFileTypeForArchive() throws Exception {\n        // given\n        createFile(\"A.log.tar.gz\", \"x\", now);\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(getFileEntries().get(0).getFileType(), is(FileType.ARCHIVE));\n    }\n\n    @Test\n    public void shouldContainEmptyParentLinkInBaseFolder() throws Exception {\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        assertThat(model.asMap().get(\"parent\"), is(\"\"));\n    }\n\n    @Test\n    public void shouldContainEmptyParentLinkInSubfolder() throws Exception {\n        // given\n        temporaryFolder.newFolder(\"subfolder\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"subfolder\");\n\n        // then\n        assertThat(model.asMap().get(\"parent\"), is(\"\"));\n    }\n\n    @Test\n    public void shouldContainEmptyParentLinkInNestedSubfolder() throws Exception {\n        // given\n        temporaryFolder.newFolder(\"subfolder\");\n        temporaryFolder.newFolder(\"subfolder\", \"nested\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"subfolder/nested\");\n\n        // then\n        assertThat(model.asMap().get(\"parent\"), is(\"/subfolder\"));\n    }\n\n    @Test\n    public void shouldIncludeSubfolderEntry() throws Exception {\n        // given\n        temporaryFolder.newFolder(\"subfolder\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, null);\n\n        // then\n        List<FileEntry> fileEntries = getFileEntries();\n        assertThat(fileEntries, hasSize(1));\n        FileEntry fileEntry = fileEntries.get(0);\n        assertThat(fileEntry.getFileType(), is(FileType.DIRECTORY));\n        assertThat(fileEntry.getFilename(), is(\"subfolder\"));\n    }\n\n    @Test\n    public void shouldListZipContent() throws Exception {\n        // given\n        createZipArchive(\"file.zip\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"file.zip\");\n\n        // then\n        List<FileEntry> fileEntries = getFileEntries();\n        assertThat(fileEntries, hasSize(1));\n        FileEntry fileEntry = fileEntries.get(0);\n        assertThat(fileEntry.getFilename(), is(\"A.log\"));\n    }\n\n    @Test\n    public void shouldViewZipFileContent() throws Exception {\n        // given\n        createZipArchive(\"file.zip\", \"A.log\", \"content\");\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.zip\", null, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), is(\"content\"));\n    }\n\n    private void createZipArchive(String archiveFileName, String contentFileName, String content) throws Exception {\n        try(ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(temporaryFolder.getRoot(), archiveFileName)))) {\n            ZipEntry zipEntry = new ZipEntry(contentFileName);\n            zos.putNextEntry(zipEntry);\n            IOUtils.write(content, zos);\n        }\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void shouldThrowExceptionWhenCallingTailForZip() throws Exception {\n        // given\n        createZipArchive(\"file.zip\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.zip\", 1, response);\n\n        // then -> exception\n    }\n\n    @Test\n    public void shouldListTarGzContent() throws Exception {\n        // given\n        createTarGzArchive(\"file.tar.gz\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.list(model, SortBy.FILENAME, false, \"file.tar.gz\");\n\n        // then\n        List<FileEntry> fileEntries = getFileEntries();\n        assertThat(fileEntries, hasSize(1));\n        FileEntry fileEntry = fileEntries.get(0);\n        assertThat(fileEntry.getFilename(), is(\"A.log\"));\n    }\n\n    @Test\n    public void shouldViewTarGzFileContent() throws Exception {\n        // given\n        createTarGzArchive(\"file.tar.gz\", \"A.log\", \"content\");\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.tar.gz\", null, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), is(\"content\"));\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void shouldThrowExceptionWhenCallingTailForTarGz() throws Exception {\n        // given\n        createTarGzArchive(\"file.tar.gz\", \"A.log\", \"content\");\n\n        // when\n        logViewEndpoint.view(\"A.log\", \"file.tar.gz\", 1, response);\n\n        // then -> exception\n    }\n\n    private void createTarGzArchive(String archiveFileName, String contentFileName, String content) throws Exception {\n\n        try(TarArchiveOutputStream tos = new TarArchiveOutputStream(new GZIPOutputStream(\n                new BufferedOutputStream(new FileOutputStream(\n                        new File(temporaryFolder.getRoot(), archiveFileName)))))) {\n            tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_STAR);\n            tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n            TarArchiveEntry archiveEntry = new TarArchiveEntry(contentFileName);\n            archiveEntry.setSize(content.length());\n            tos.putArchiveEntry(archiveEntry);\n            IOUtils.write(content, tos);\n            tos.closeArchiveEntry();\n        }\n    }\n\n    @Test\n    public void shouldRedirectWithoutTrainingSlash() throws IOException {\n        // when\n        logViewEndpoint.redirect(response);\n\n        // then\n        verify(response).sendRedirect(\"log/\");\n    }\n\n    @Test\n    public void shouldEndpointBeSensitive() {\n        assertThat(logViewEndpoint.isSensitive(), is(true));\n    }\n\n    @Test\n    public void shouldReturnContextPath() {\n        assertThat(logViewEndpoint.getPath(), is(\"/log\"));\n    }\n\n    @Test\n    public void shouldReturnNullEndpointType() {\n        assertThat(logViewEndpoint.getEndpointType(), is(nullValue()));\n    }\n\n    @Test\n    public void shouldNotAllowToListFileOutsideRoot() throws Exception {\n        // given\n        expectedException.expect(IllegalArgumentException.class);\n        expectedException.expectMessage(containsString(\"may not be located outside base path\"));\n\n        // when\n        logViewEndpoint.view(\"../somefile\", null, null, null);\n    }\n\n    @Test\n    public void shouldNotAllowToListWithBaseOutsideRoot() throws Exception {\n        // given\n        expectedException.expect(IllegalArgumentException.class);\n        expectedException.expectMessage(containsString(\"may not be located outside base path\"));\n\n        // when\n        logViewEndpoint.view(\"somefile\", \"../otherdir\", null, null);\n    }\n\n    @Test\n    public void shouldViewFile() throws Exception {\n        // given\n        createFile(\"file.log\", \"abc\", now);\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"file.log\", null, null, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), is(\"abc\"));\n    }\n\n    @Test\n    public void shouldTailViewOnlyLastLine() throws Exception {\n        // given\n        createFile(\"file.log\", \"line1\" + System.lineSeparator() + \"line2\" + System.lineSeparator(), now);\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.view(\"file.log\", null, 1, response);\n\n        // then\n        assertThat(new String(outputStream.toByteArray()), not(containsString(\"line1\")));\n        assertThat(new String(outputStream.toByteArray()), containsString(\"line2\"));\n    }\n\n    @Test\n    public void shouldSearchInFiles() throws Exception {\n        // given\n        String sep = System.lineSeparator();\n        createFile(\"A.log\", \"A-line1\" + sep + \"A-line2\" + sep + \"A-line3\", now - 1);\n        createFile(\"B.log\", \"B-line1\" + sep + \"B-line2\" + sep + \"B-line3\", now);\n        ByteArrayServletOutputStream outputStream = mockResponseOutputStream();\n\n        // when\n        logViewEndpoint.search(\"line2\", response);\n\n        // then\n        String output = new String(outputStream.toByteArray());\n        assertThat(output, containsString(\"[A.log] A-line2\"));\n        assertThat(output, containsString(\"[B.log] B-line2\"));\n        assertThat(output, not(containsString(\"line1\")));\n        assertThat(output, not(containsString(\"line3\")));\n    }\n\n    private ByteArrayServletOutputStream mockResponseOutputStream() throws Exception {\n        ByteArrayServletOutputStream outputStream = new ByteArrayServletOutputStream();\n        when(response.getOutputStream()).thenReturn(outputStream);\n        return outputStream;\n    }\n\n    private List<String> getFileNames() {\n        return getFileEntries()\n                .stream()\n                .map(FileEntry::getFilename)\n                .collect(toList());\n    }\n\n    private List<Long> getFileSizes() {\n        return getFileEntries()\n                .stream()\n                .map(FileEntry::getSize)\n                .collect(toList());\n    }\n\n    private List<String> getFilePrettyTimes() {\n        return getFileEntries()\n                .stream()\n                .map(FileEntry::getModifiedPretty)\n                .collect(toList());\n    }\n\n    private List<FileEntry> getFileEntries() {\n        return (List<FileEntry>) model.asMap().get(\"files\");\n    }\n\n    private void createFile(String filename, String content, long modified) throws Exception {\n        File file = new File(temporaryFolder.getRoot(), filename);\n        FileUtils.write(file, content);\n        assertThat(file.setLastModified(modified), is(true));\n    }\n\n}", "target": 0}
{"idx": 1013, "func": "/**\n * Copyright (C) 2011 Xavier Jodoin (xavier@jodoin.me)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.torpedoquery.jpa;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.torpedoquery.jpa.Torpedo.from;\nimport static org.torpedoquery.jpa.Torpedo.select;\nimport static org.torpedoquery.jpa.Torpedo.where;\nimport static org.torpedoquery.jpa.TorpedoFunction.length;\nimport static org.torpedoquery.jpa.TorpedoFunction.lower;\nimport static org.torpedoquery.jpa.TorpedoFunction.substring;\nimport static org.torpedoquery.jpa.TorpedoFunction.trim;\nimport static org.torpedoquery.jpa.TorpedoFunction.upper;\n\nimport org.junit.Test;\nimport org.torpedoquery.jpa.test.bo.Entity;\n\n/**\n *\n *substring(), trim(), lower(), upper(), length()\n *\n * @author xjodoin\n * @version $Id: $Id\n * @since 2.0.0\n */\npublic class StringFunctionsTest {\n\n\t/**\n\t * <p>testTrimFunction.</p>\n\t */\n\t@Test\n\tpublic void testTrimFunction() {\n\t\tEntity from = from(Entity.class);\n\t\tQuery<String> select = select(trim(from.getCode()));\n\t\tassertEquals(\"select trim(entity_0.code) from Entity entity_0\", select.getQuery());\n\t}\n\n\t/**\n\t * <p>testLowerFunction.</p>\n\t */\n\t@Test\n\tpublic void testLowerFunction() {\n\t\tEntity from = from(Entity.class);\n\t\tQuery<String> select = select(lower(from.getCode()));\n\t\tassertEquals(\"select lower(entity_0.code) from Entity entity_0\", select.getQuery());\n\t}\n\n\t/**\n\t * <p>testUpperFunction.</p>\n\t */\n\t@Test\n\tpublic void testUpperFunction() {\n\t\tEntity from = from(Entity.class);\n\t\tQuery<String> select = select(upper(from.getCode()));\n\t\tassertEquals(\"select upper(entity_0.code) from Entity entity_0\", select.getQuery());\n\t}\n\t\n\t/**\n\t * <p>testLengthFunction.</p>\n\t */\n\t@Test\n\tpublic void testLengthFunction() {\n\t\tEntity from = from(Entity.class);\n\t\tQuery<Integer> select = select(length(from.getCode()));\n\t\tassertEquals(\"select length(entity_0.code) from Entity entity_0\", select.getQuery());\n\t}\n\t\n\t/**\n\t * <p>testLengthFunctionWithFunction.</p>\n\t */\n\t@Test\n\tpublic void testLengthFunctionWithFunction() {\n\t\tEntity from = from(Entity.class);\n\t\tQuery<Integer> select = select(length(trim(from.getCode())));\n\t\tassertEquals(\"select length(trim(entity_0.code)) from Entity entity_0\", select.getQuery());\n\t}\n\t\n\t/**\n\t * <p>testWhereWithStringFunction.</p>\n\t */\n\t@Test\n\tpublic void testWhereWithStringFunction() {\n\t\tEntity from = from(Entity.class);\n\t\twhere(lower(from.getCode())).like().any(\"test\");\n\t\tQuery<Entity> select = select(from);\n\t\tassertEquals(\"select entity_0 from Entity entity_0 where lower(entity_0.code) like '%test%'\", select.getQuery());\n\t}\n\t\n\t@Test\n\tpublic void testWhereWithLikeFunction() {\n\t\tEntity from = from(Entity.class);\n\t\twhere(lower(from.getCode())).like(\"%test%\");\n\t\tQuery<Entity> select = select(from);\n\t\tassertEquals(\"select entity_0 from Entity entity_0 where lower(entity_0.code) like '%test%'\", select.getQuery());\n\t}\n\t\n\t@Test\n\tpublic void testWhereWithNotLikeFunction() {\n\t\tEntity from = from(Entity.class);\n\t\twhere(lower(from.getCode())).notLike(\"%test%\");\n\t\tQuery<Entity> select = select(from);\n\t\tassertEquals(\"select entity_0 from Entity entity_0 where lower(entity_0.code) not like '%test%'\", select.getQuery());\n\t}\n\t\n\t/**\n\t * <p>testSubstringFunction.</p>\n\t */\n\t@Test\n\tpublic void testSubstringFunction() {\n\t\tEntity from = from(Entity.class);\n\t\tQuery<String> select = select(substring(from.getCode(),2,4));\n\t\tassertEquals(\"select substring(entity_0.code,2,4) from Entity entity_0\", select.getQuery());\n\t}\n\t\n}\n", "target": 1}
