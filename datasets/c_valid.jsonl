{"idx": 4681, "func": "int crl2pkcs7_main(int argc, char **argv)\n{\n    BIO *in = NULL, *out = NULL;\n    PKCS7 *p7 = NULL;\n    PKCS7_SIGNED *p7s = NULL;\n    STACK_OF(OPENSSL_STRING) *certflst = NULL;\n    STACK_OF(X509) *cert_stack = NULL;\n    STACK_OF(X509_CRL) *crl_stack = NULL;\n    X509_CRL *crl = NULL;\n    char *infile = NULL, *outfile = NULL, *prog, *certfile;\n    int i = 0, informat = FORMAT_PEM, outformat = FORMAT_PEM, ret = 1, nocrl =\n        0;\n    OPTION_CHOICE o;\n\n    prog = opt_init(argc, argv, crl2pkcs7_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(crl2pkcs7_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_NOCRL:\n            nocrl = 1;\n            break;\n        case OPT_CERTFILE:\n            if ((certflst == NULL)\n                && (certflst = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (!sk_OPENSSL_STRING_push(certflst, *(++argv))) {\n                sk_OPENSSL_STRING_free(certflst);\n                goto end;\n            }\n            break;\n        }\n    }\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (!app_load_modules(NULL))\n        goto end;\n\n    if (!nocrl) {\n        in = bio_open_default(infile, 'r', informat);\n        if (in == NULL)\n            goto end;\n\n        if (informat == FORMAT_ASN1)\n            crl = d2i_X509_CRL_bio(in, NULL);\n        else if (informat == FORMAT_PEM)\n            crl = PEM_read_bio_X509_CRL(in, NULL, NULL, NULL);\n        if (crl == NULL) {\n            BIO_printf(bio_err, \"unable to load CRL\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if ((p7 = PKCS7_new()) == NULL)\n        goto end;\n    if ((p7s = PKCS7_SIGNED_new()) == NULL)\n        goto end;\n    p7->type = OBJ_nid2obj(NID_pkcs7_signed);\n    p7->d.sign = p7s;\n    p7s->contents->type = OBJ_nid2obj(NID_pkcs7_data);\n\n    if (!ASN1_INTEGER_set(p7s->version, 1))\n        goto end;\n    if ((crl_stack = sk_X509_CRL_new_null()) == NULL)\n        goto end;\n    p7s->crl = crl_stack;\n    if (crl != NULL) {\n        sk_X509_CRL_push(crl_stack, crl);\n        crl = NULL;             /* now part of p7 for OPENSSL_freeing */\n    }\n\n    if ((cert_stack = sk_X509_new_null()) == NULL)\n        goto end;\n    p7s->cert = cert_stack;\n\n    if (certflst)\n        for (i = 0; i < sk_OPENSSL_STRING_num(certflst); i++) {\n            certfile = sk_OPENSSL_STRING_value(certflst, i);\n            if (add_certs_from_file(cert_stack, certfile) < 0) {\n                BIO_printf(bio_err, \"error loading certificates\\n\");\n                ERR_print_errors(bio_err);\n                goto end;\n            }\n        }\n\n    sk_OPENSSL_STRING_free(certflst);\n\n    out = bio_open_default(outfile, 'w', outformat);\n    if (out == NULL)\n        goto end;\n\n    if (outformat == FORMAT_ASN1)\n        i = i2d_PKCS7_bio(out, p7);\n    else if (outformat == FORMAT_PEM)\n        i = PEM_write_bio_PKCS7(out, p7);\n    if (!i) {\n        BIO_printf(bio_err, \"unable to write pkcs7 object\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    ret = 0;\n end:\n    BIO_free(in);\n    BIO_free_all(out);\n    PKCS7_free(p7);\n    X509_CRL_free(crl);\n\n    return (ret);\n}", "target": 0}
{"idx": 4682, "func": "int SCT_CTX_verify(const SCT_CTX *sctx, const SCT *sct)\n{\n    EVP_MD_CTX *ctx = NULL;\n    int ret = 0;\n\n    if (!SCT_is_complete(sct) || sctx->pkey == NULL ||\n        sct->entry_type == CT_LOG_ENTRY_TYPE_NOT_SET ||\n        (sct->entry_type == CT_LOG_ENTRY_TYPE_PRECERT && sctx->ihash == NULL)) {\n        CTerr(CT_F_SCT_CTX_VERIFY, CT_R_SCT_NOT_SET);\n        return 0;\n    }\n    if (sct->version != SCT_VERSION_V1) {\n        CTerr(CT_F_SCT_CTX_VERIFY, CT_R_SCT_UNSUPPORTED_VERSION);\n        return 0;\n    }\n    if (sct->log_id_len != sctx->pkeyhashlen ||\n        memcmp(sct->log_id, sctx->pkeyhash, sctx->pkeyhashlen) != 0) {\n        CTerr(CT_F_SCT_CTX_VERIFY, CT_R_SCT_LOG_ID_MISMATCH);\n        return 0;\n    }\n    if (sct->timestamp > sctx->epoch_time_in_ms) {\n        CTerr(CT_F_SCT_CTX_VERIFY, CT_R_SCT_FUTURE_TIMESTAMP);\n        return 0;\n    }\n\n    ctx = EVP_MD_CTX_new();\n    if (ctx == NULL)\n        goto end;\n\n    if (!EVP_DigestVerifyInit(ctx, NULL, EVP_sha256(), NULL, sctx->pkey))\n        goto end;\n\n    if (!sct_ctx_update(ctx, sctx, sct))\n        goto end;\n\n    /* Verify signature */\n    ret = EVP_DigestVerifyFinal(ctx, sct->sig, sct->sig_len);\n    /* If ret < 0 some other error: fall through without setting error */\n    if (ret == 0)\n        CTerr(CT_F_SCT_CTX_VERIFY, CT_R_SCT_INVALID_SIGNATURE);\n\nend:\n    EVP_MD_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"idx": 4683, "func": "int ff_add_channel_layout(AVFilterChannelLayouts **l, uint64_t channel_layout)\n{\n    ADD_FORMAT(l, channel_layout, uint64_t, channel_layouts, nb_channel_layouts);\n}", "target": 1}
{"idx": 4684, "func": "int ff_mpv_common_frame_size_change(MpegEncContext *s)\n{\n    int i, err = 0;\n\n    if (!s->context_initialized)\n        return AVERROR(EINVAL);\n\n    if (s->slice_context_count > 1) {\n        for (i = 0; i < s->slice_context_count; i++) {\n            free_duplicate_context(s->thread_context[i]);\n        }\n        for (i = 1; i < s->slice_context_count; i++) {\n            av_freep(&s->thread_context[i]);\n        }\n    } else\n        free_duplicate_context(s);\n\n    free_context_frame(s);\n\n    if (s->picture)\n        for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n                s->picture[i].needs_realloc = 1;\n        }\n\n    s->last_picture_ptr         =\n    s->next_picture_ptr         =\n    s->current_picture_ptr      = NULL;\n\n    // init\n    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n        s->mb_height = (s->height + 31) / 32 * 2;\n    else\n        s->mb_height = (s->height + 15) / 16;\n\n    if ((s->width || s->height) &&\n        (err = av_image_check_size(s->width, s->height, 0, s->avctx)) < 0)\n        goto fail;\n\n    if ((err = init_context_frame(s)))\n        goto fail;\n\n    memset(s->thread_context, 0, sizeof(s->thread_context));\n    s->thread_context[0]   = s;\n\n    if (s->width && s->height) {\n        int nb_slices = s->slice_context_count;\n        if (nb_slices > 1) {\n            for (i = 0; i < nb_slices; i++) {\n                if (i) {\n                    s->thread_context[i] = av_memdup(s, sizeof(MpegEncContext));\n                    if (!s->thread_context[i]) {\n                        err = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                }\n                if ((err = init_duplicate_context(s->thread_context[i])) < 0)\n                    goto fail;\n                    s->thread_context[i]->start_mb_y =\n                        (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n                    s->thread_context[i]->end_mb_y   =\n                        (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n            }\n        } else {\n            err = init_duplicate_context(s);\n            if (err < 0)\n                goto fail;\n            s->start_mb_y = 0;\n            s->end_mb_y   = s->mb_height;\n        }\n        s->slice_context_count = nb_slices;\n    }\n\n    return 0;\n fail:\n    ff_mpv_common_end(s);\n    return err;\n}", "target": 0}
{"idx": 4685, "func": "static void copy_cell(Indeo3DecodeContext *ctx, Plane *plane, Cell *cell)\n{\n    int     h, w, mv_x, mv_y, offset, offset_dst;\n    uint8_t *src, *dst;\n\n    /* setup output and reference pointers */\n    offset_dst  = (cell->ypos << 2) * plane->pitch + (cell->xpos << 2);\n    dst         = plane->pixels[ctx->buf_sel] + offset_dst;\n    if(cell->mv_ptr){\n    mv_y        = cell->mv_ptr[0];\n    mv_x        = cell->mv_ptr[1];\n    }else\n        mv_x= mv_y= 0;\n    offset      = offset_dst + mv_y * plane->pitch + mv_x;\n    src         = plane->pixels[ctx->buf_sel ^ 1] + offset;\n\n    h = cell->height << 2;\n\n    for (w = cell->width; w > 0;) {\n        /* copy using 16xH blocks */\n        if (!((cell->xpos << 2) & 15) && w >= 4) {\n            for (; w >= 4; src += 16, dst += 16, w -= 4)\n                ctx->dsp.put_no_rnd_pixels_tab[0][0](dst, src, plane->pitch, h);\n        }\n\n        /* copy using 8xH blocks */\n        if (!((cell->xpos << 2) & 7) && w >= 2) {\n            ctx->dsp.put_no_rnd_pixels_tab[1][0](dst, src, plane->pitch, h);\n            w -= 2;\n            src += 8;\n            dst += 8;\n        }\n\n        if (w >= 1) {\n            copy_block4(dst, src, plane->pitch, plane->pitch, h);\n            w--;\n            src += 4;\n            dst += 4;\n        }\n    }\n}", "target": 0}
{"idx": 4686, "func": "static int early_data_skip_helper(int hrr, int idx)\n{\n    SSL_CTX *cctx = NULL, *sctx = NULL;\n    SSL *clientssl = NULL, *serverssl = NULL;\n    int testresult = 0;\n    SSL_SESSION *sess = NULL;\n    unsigned char buf[20];\n    size_t readbytes, written;\n\n    if (!TEST_true(setupearly_data_test(&cctx, &sctx, &clientssl,\n                                        &serverssl, &sess, idx)))\n        goto end;\n\n    if (hrr) {\n        /* Force an HRR to occur */\n        if (!TEST_true(SSL_set1_groups_list(serverssl, \"P-256\")))\n            goto end;\n    } else if (idx == 2) {\n        /*\n         * We force early_data rejection by ensuring the PSK identity is\n         * unrecognised\n         */\n        srvid = \"Dummy Identity\";\n    } else {\n        /*\n         * Deliberately corrupt the creation time. We take 20 seconds off the\n         * time. It could be any value as long as it is not within tolerance.\n         * This should mean the ticket is rejected.\n         */\n        if (!TEST_true(SSL_SESSION_set_time(sess, (long)(time(NULL) - 20))))\n            goto end;\n    }\n\n    /* Write some early data */\n    if (!TEST_true(SSL_write_early_data(clientssl, MSG1, strlen(MSG1),\n                                        &written))\n            || !TEST_size_t_eq(written, strlen(MSG1)))\n        goto end;\n\n    /* Server should reject the early data and skip over it */\n    if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),\n                                         &readbytes),\n                     SSL_READ_EARLY_DATA_FINISH)\n            || !TEST_size_t_eq(readbytes, 0)\n            || !TEST_int_eq(SSL_get_early_data_status(serverssl),\n                            SSL_EARLY_DATA_REJECTED))\n        goto end;\n\n    if (hrr) {\n        /*\n         * Finish off the handshake. We perform the same writes and reads as\n         * further down but we expect them to fail due to the incomplete\n         * handshake.\n         */\n        if (!TEST_false(SSL_write_ex(clientssl, MSG2, strlen(MSG2), &written))\n                || !TEST_false(SSL_read_ex(serverssl, buf, sizeof(buf),\n                               &readbytes)))\n            goto end;\n    }\n\n    /* Should be able to send normal data despite rejection of early data */\n    if (!TEST_true(SSL_write_ex(clientssl, MSG2, strlen(MSG2), &written))\n            || !TEST_size_t_eq(written, strlen(MSG2))\n            || !TEST_int_eq(SSL_get_early_data_status(clientssl),\n                            SSL_EARLY_DATA_REJECTED)\n            || !TEST_true(SSL_read_ex(serverssl, buf, sizeof(buf), &readbytes))\n            || !TEST_mem_eq(buf, readbytes, MSG2, strlen(MSG2)))\n        goto end;\n\n    testresult = 1;\n\n end:\n    SSL_SESSION_free(clientpsk);\n    SSL_SESSION_free(serverpsk);\n    clientpsk = serverpsk = NULL;\n    SSL_SESSION_free(sess);\n    SSL_free(serverssl);\n    SSL_free(clientssl);\n    SSL_CTX_free(sctx);\n    SSL_CTX_free(cctx);\n    return testresult;\n}", "target": 0}
{"idx": 4687, "func": "enum AVPixelFormat avpriv_fmt_v4l2ff(uint32_t v4l2_fmt, enum AVCodecID codec_id)\n{\n    int i;\n\n    for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {\n        if (avpriv_fmt_conversion_table[i].v4l2_fmt == v4l2_fmt &&\n            avpriv_fmt_conversion_table[i].codec_id == codec_id) {\n            return avpriv_fmt_conversion_table[i].ff_fmt;\n        }\n    }\n\n    return AV_PIX_FMT_NONE;\n}", "target": 1}
{"idx": 4688, "func": "static int\nTIFFFillStripPartial( TIFF *tif, int strip, tmsize_t read_ahead, int restart )\n{\n\tstatic const char module[] = \"TIFFFillStripPartial\";\n\tregister TIFFDirectory *td = &tif->tif_dir;\n        tmsize_t unused_data;\n        uint64 read_offset;\n        tmsize_t to_read;\n        tmsize_t read_ahead_mod;\n        /* tmsize_t bytecountm; */\n        \n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n        \n        /*\n         * Expand raw data buffer, if needed, to hold data\n         * strip coming from file (perhaps should set upper\n         * bound on the size of a buffer we'll use?).\n         */\n\n        /* bytecountm=(tmsize_t) td->td_stripbytecount[strip]; */\n\n        /* Not completely sure where the * 2 comes from, but probably for */\n        /* an exponentional growth strategy of tif_rawdatasize */\n        if( read_ahead < TIFF_TMSIZE_T_MAX / 2 )\n                read_ahead_mod = read_ahead * 2;\n        else\n                read_ahead_mod = read_ahead;\n        if (read_ahead_mod > tif->tif_rawdatasize) {\n                assert( restart );\n                \n                tif->tif_curstrip = NOSTRIP;\n                if ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\n                        TIFFErrorExt(tif->tif_clientdata, module,\n                                     \"Data buffer too small to hold part of strip %lu\",\n                                     (unsigned long) strip);\n                        return (0);\n                }\n        }\n\n        if( restart )\n        {\n                tif->tif_rawdataloaded = 0;\n                tif->tif_rawdataoff = 0;\n        }\n\n        /*\n        ** If we are reading more data, move any unused data to the\n        ** start of the buffer.\n        */\n        if( tif->tif_rawdataloaded > 0 )\n                unused_data = tif->tif_rawdataloaded - (tif->tif_rawcp - tif->tif_rawdata);\n        else\n                unused_data = 0;\n        \n        if( unused_data > 0 )\n        {\n\t\tassert((tif->tif_flags&TIFF_BUFFERMMAP)==0);\n                memmove( tif->tif_rawdata, tif->tif_rawcp, unused_data );\n        }\n\n        /*\n        ** Seek to the point in the file where more data should be read.\n        */\n        read_offset = td->td_stripoffset[strip]\n                + tif->tif_rawdataoff + tif->tif_rawdataloaded;\n\n        if (!SeekOK(tif, read_offset)) {\n                TIFFErrorExt(tif->tif_clientdata, module,\n                             \"Seek error at scanline %lu, strip %lu\",\n                             (unsigned long) tif->tif_row, (unsigned long) strip);\n                return 0;\n        }\n\n        /*\n        ** How much do we want to read?\n        */\n        if( read_ahead_mod > tif->tif_rawdatasize )\n                to_read = read_ahead_mod - unused_data;\n        else\n                to_read = tif->tif_rawdatasize - unused_data;\n        if( (uint64) to_read > td->td_stripbytecount[strip] \n            - tif->tif_rawdataoff - tif->tif_rawdataloaded )\n        {\n                to_read = (tmsize_t) td->td_stripbytecount[strip]\n                        - tif->tif_rawdataoff - tif->tif_rawdataloaded;\n        }\n\n\tassert((tif->tif_flags&TIFF_BUFFERMMAP)==0);\n        if( !TIFFReadAndRealloc( tif, to_read, unused_data,\n                                 1, /* is_strip */\n                                 0, /* strip_or_tile */\n                                 module) )\n        {\n                return 0;\n        }\n\n        tif->tif_rawdataoff = tif->tif_rawdataoff + tif->tif_rawdataloaded - unused_data ;\n        tif->tif_rawdataloaded = unused_data + to_read;\n\n        tif->tif_rawcc = tif->tif_rawdataloaded;\n        tif->tif_rawcp = tif->tif_rawdata;\n                        \n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0) {\n\t\tassert((tif->tif_flags&TIFF_BUFFERMMAP)==0);\n                TIFFReverseBits(tif->tif_rawdata + unused_data, to_read );\n\t}\n\n        /*\n        ** When starting a strip from the beginning we need to\n        ** restart the decoder.\n        */\n        if( restart )\n        {\n\n#ifdef JPEG_SUPPORT\n            /* A bit messy since breaks the codec abstraction. Ultimately */\n            /* there should be a function pointer for that, but it seems */\n            /* only JPEG is affected. */\n            /* For JPEG, if there are multiple scans (can generally be known */\n            /* with the  read_ahead used), we need to read the whole strip */\n            if( tif->tif_dir.td_compression==COMPRESSION_JPEG &&\n                (uint64)tif->tif_rawcc < td->td_stripbytecount[strip] )\n            {\n                if( TIFFJPEGIsFullStripRequired(tif) )\n                {\n                    return TIFFFillStrip(tif, strip);\n                }\n            }\n#endif\n\n            return TIFFStartStrip(tif, strip);\n        }\n        else\n        {\n                return 1;\n        }\n}", "target": 1}
{"idx": 4689, "func": "static int apply_window_and_mdct(vorbis_enc_context *venc, int samples)\n{\n    int channel;\n    const float * win = venc->win[0];\n    int window_len = 1 << (venc->log2_blocksize[0] - 1);\n    float n = (float)(1 << venc->log2_blocksize[0]) / 4.0;\n    AVFloatDSPContext *fdsp = venc->fdsp;\n\n    for (channel = 0; channel < venc->channels; channel++) {\n        float *offset = venc->samples + channel * window_len * 2;\n\n        fdsp->vector_fmul(offset, offset, win, samples);\n        fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        offset += window_len;\n\n        fdsp->vector_fmul_reverse(offset, offset, win, samples);\n        fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        venc->mdct[0].mdct_calc(&venc->mdct[0], venc->coeffs + channel * window_len,\n                     venc->samples + channel * window_len * 2);\n    }\n    return 1;\n}", "target": 0}
{"idx": 4690, "func": "static int decode_format80(GetByteContext *gb, int src_size,\n    unsigned char *dest, int dest_size, int check_size) {\n\n    int dest_index = 0;\n    int count, opcode, start;\n    int src_pos;\n    unsigned char color;\n    int i;\n\n    start = bytestream2_tell(gb);\n    while (bytestream2_tell(gb) - start < src_size) {\n        opcode = bytestream2_get_byte(gb);\n        av_dlog(NULL, \"      opcode %02X: \", opcode);\n\n        /* 0x80 means that frame is finished */\n        if (opcode == 0x80)\n            return 0;\n\n        if (dest_index >= dest_size) {\n            av_log(NULL, AV_LOG_ERROR, \"  VQA video: decode_format80 problem: dest_index (%d) exceeded dest_size (%d)\\n\",\n                dest_index, dest_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (opcode == 0xFF) {\n\n            count   = bytestream2_get_le16(gb);\n            src_pos = bytestream2_get_le16(gb);\n            av_dlog(NULL, \"(1) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n            CHECK_COUNT();\n            CHECK_COPY(src_pos);\n            for (i = 0; i < count; i++)\n                dest[dest_index + i] = dest[src_pos + i];\n            dest_index += count;\n\n        } else if (opcode == 0xFE) {\n\n            count = bytestream2_get_le16(gb);\n            color = bytestream2_get_byte(gb);\n            av_dlog(NULL, \"(2) set %X bytes to %02X\\n\", count, color);\n            CHECK_COUNT();\n            memset(&dest[dest_index], color, count);\n            dest_index += count;\n\n        } else if ((opcode & 0xC0) == 0xC0) {\n\n            count = (opcode & 0x3F) + 3;\n            src_pos = bytestream2_get_le16(gb);\n            av_dlog(NULL, \"(3) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n            CHECK_COUNT();\n            CHECK_COPY(src_pos);\n            for (i = 0; i < count; i++)\n                dest[dest_index + i] = dest[src_pos + i];\n            dest_index += count;\n\n        } else if (opcode > 0x80) {\n\n            count = opcode & 0x3F;\n            av_dlog(NULL, \"(4) copy %X bytes from source to dest\\n\", count);\n            CHECK_COUNT();\n            bytestream2_get_buffer(gb, &dest[dest_index], count);\n            dest_index += count;\n\n        } else {\n\n            count = ((opcode & 0x70) >> 4) + 3;\n            src_pos = bytestream2_get_byte(gb) | ((opcode & 0x0F) << 8);\n            av_dlog(NULL, \"(5) copy %X bytes from relpos %X\\n\", count, src_pos);\n            CHECK_COUNT();\n            CHECK_COPY(dest_index - src_pos);\n            for (i = 0; i < count; i++)\n                dest[dest_index + i] = dest[dest_index - src_pos + i];\n            dest_index += count;\n        }\n    }\n\n    /* validate that the entire destination buffer was filled; this is\n     * important for decoding frame maps since each vector needs to have a\n     * codebook entry; it is not important for compressed codebooks because\n     * not every entry needs to be filled */\n    if (check_size)\n        if (dest_index < dest_size)\n            av_log(NULL, AV_LOG_ERROR, \"  VQA video: decode_format80 problem: decode finished with dest_index (%d) < dest_size (%d)\\n\",\n                dest_index, dest_size);\n\n    return 0; // let's display what we decoded anyway\n}", "target": 0}
{"idx": 4691, "func": "void ERR_put_error(int lib, int func, int reason, const char *file,\n\t     int line)\n\t{\n\tERR_STATE *es;\n\n#ifdef _OSD_POSIX\n\t/* In the BS2000-OSD POSIX subsystem, the compiler generates\n\t * path names in the form \"*POSIX(/etc/passwd)\".\n\t * This dirty hack strips them to something sensible.\n\t * @@@ We shouldn't modify a const string, though.\n\t */\n\tif (strncmp(file,\"*POSIX(\", sizeof(\"*POSIX(\")-1) == 0) {\n\t\tchar *end;\n\n\t\t/* Skip the \"*POSIX(\" prefix */\n\t\tfile += sizeof(\"*POSIX(\")-1;\n\t\tend = &file[strlen(file)-1];\n\t\tif (*end == ')')\n\t\t\t*end = '\\0';\n\t\t/* Optional: use the basename of the path only. */\n\t\tif ((end = strrchr(file, '/')) != NULL)\n\t\t\tfile = &end[1];\n\t}\n#endif\n\tes=ERR_get_state();\n\n\tes->top=(es->top+1)%ERR_NUM_ERRORS;\n\tif (es->top == es->bottom)\n\t\tes->bottom=(es->bottom+1)%ERR_NUM_ERRORS;\n\tes->err_buffer[es->top]=ERR_PACK(lib,func,reason);\n\tes->err_file[es->top]=file;\n\tes->err_line[es->top]=line;\n\terr_clear_data(es,es->top);\n\t}", "target": 1}
{"idx": 4692, "func": "static int ape_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    APEContext *s = avctx->priv_data;\n    int16_t *samples = data;\n    uint32_t nblocks;\n    int i;\n    int blockstodecode;\n    int bytes_used;\n\n    /* should not happen but who knows */\n    if (BLOCKS_PER_LOOP * 2 * avctx->channels > *data_size) {\n        av_log (avctx, AV_LOG_ERROR, \"Output buffer is too small.\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if(!s->samples){\n        uint32_t offset;\n        void *tmp_data;\n\n        if (buf_size < 8) {\n            av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        tmp_data = av_realloc(s->data, (buf_size + 3) & ~3);\n        if (!tmp_data)\n            return AVERROR(ENOMEM);\n        s->data = tmp_data;\n        s->dsp.bswap_buf((uint32_t*)s->data, (const uint32_t*)buf, buf_size >> 2);\n        s->ptr = s->last_ptr = s->data;\n        s->data_end = s->data + buf_size;\n\n        nblocks = bytestream_get_be32(&s->ptr);\n        offset  = bytestream_get_be32(&s->ptr);\n        if (offset > 3) {\n            av_log(avctx, AV_LOG_ERROR, \"Incorrect offset passed\\n\");\n            s->data = NULL;\n            return AVERROR_INVALIDDATA;\n        }\n        if (s->data_end - s->ptr < offset) {\n            av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        s->ptr += offset;\n\n        if (!nblocks || nblocks > INT_MAX) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %u.\\n\", nblocks);\n            return AVERROR_INVALIDDATA;\n        }\n        s->currentframeblocks = s->samples = nblocks;\n\n        memset(s->decoded0,  0, sizeof(s->decoded0));\n        memset(s->decoded1,  0, sizeof(s->decoded1));\n\n        /* Initialize the frame decoder */\n        if (init_frame_decoder(s) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Error reading frame header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (!s->data) {\n        *data_size = 0;\n        return buf_size;\n    }\n\n    nblocks = s->samples;\n    blockstodecode = FFMIN(BLOCKS_PER_LOOP, nblocks);\n\n    s->error=0;\n\n    if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO))\n        ape_unpack_mono(s, blockstodecode);\n    else\n        ape_unpack_stereo(s, blockstodecode);\n    emms_c();\n\n    if(s->error || s->ptr > s->data_end){\n        s->samples=0;\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding frame\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < blockstodecode; i++) {\n        *samples++ = s->decoded0[i];\n        if(s->channels == 2)\n            *samples++ = s->decoded1[i];\n    }\n\n    s->samples -= blockstodecode;\n\n    *data_size = blockstodecode * 2 * s->channels;\n    bytes_used = s->samples ? s->ptr - s->last_ptr : buf_size;\n    s->last_ptr = s->ptr;\n    return bytes_used;\n}", "target": 0}
{"idx": 4693, "func": "static av_cold int allocate_frame_buffers(Indeo3DecodeContext *ctx,\n                                          AVCodecContext *avctx, int luma_width, int luma_height)\n{\n    int p, chroma_width, chroma_height;\n    int luma_pitch, chroma_pitch, luma_size, chroma_size;\n\n    if (luma_width  < 16 || luma_width  > 640 ||\n        luma_height < 16 || luma_height > 480 ||\n        luma_width  &  3 || luma_height &   3) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid picture dimensions: %d x %d!\\n\",\n               luma_width, luma_height);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->width  = luma_width ;\n    ctx->height = luma_height;\n\n    chroma_width  = FFALIGN(luma_width  >> 2, 4);\n    chroma_height = FFALIGN(luma_height >> 2, 4);\n\n    luma_pitch   = FFALIGN(luma_width,   16);\n    chroma_pitch = FFALIGN(chroma_width, 16);\n\n    /* Calculate size of the luminance plane.  */\n    /* Add one line more for INTRA prediction. */\n    luma_size = luma_pitch * (luma_height + 1);\n\n    /* Calculate size of a chrominance planes. */\n    /* Add one line more for INTRA prediction. */\n    chroma_size = chroma_pitch * (chroma_height + 1);\n\n    /* allocate frame buffers */\n    for (p = 0; p < 3; p++) {\n        ctx->planes[p].pitch  = !p ? luma_pitch  : chroma_pitch;\n        ctx->planes[p].width  = !p ? luma_width  : chroma_width;\n        ctx->planes[p].height = !p ? luma_height : chroma_height;\n\n        ctx->planes[p].buffers[0] = av_malloc(!p ? luma_size : chroma_size);\n        ctx->planes[p].buffers[1] = av_malloc(!p ? luma_size : chroma_size);\n\n        /* fill the INTRA prediction lines with the middle pixel value = 64 */\n        memset(ctx->planes[p].buffers[0], 0x40, ctx->planes[p].pitch);\n        memset(ctx->planes[p].buffers[1], 0x40, ctx->planes[p].pitch);\n\n        /* set buffer pointers = buf_ptr + pitch and thus skip the INTRA prediction line */\n        ctx->planes[p].pixels[0] = ctx->planes[p].buffers[0] + ctx->planes[p].pitch;\n        ctx->planes[p].pixels[1] = ctx->planes[p].buffers[1] + ctx->planes[p].pitch;\n        memset(ctx->planes[p].pixels[0], 0, ctx->planes[p].pitch * ctx->planes[p].height);\n        memset(ctx->planes[p].pixels[1], 0, ctx->planes[p].pitch * ctx->planes[p].height);\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 4694, "func": "static void perform_idle_server_maintenance(int child_bucket, int num_buckets)\n{\n    int i, j;\n    int idle_thread_count = 0;\n    worker_score *ws;\n    process_score *ps;\n    int free_length = 0;\n    int free_slots[MAX_SPAWN_RATE];\n    int last_non_dead = -1;\n    int total_non_dead = 0;\n    int active_thread_count = 0;\n\n    for (i = 0; i < ap_daemons_limit; ++i) {\n        /* Initialization to satisfy the compiler. It doesn't know\n         * that threads_per_child is always > 0 */\n        int status = SERVER_DEAD;\n        int any_dying_threads = 0;\n        int any_dead_threads = 0;\n        int all_dead_threads = 1;\n        int child_threads_active = 0;\n\n        if (i >= retained->max_daemons_limit &&\n            free_length == retained->idle_spawn_rate[child_bucket]) {\n            /* short cut if all active processes have been examined and\n             * enough empty scoreboard slots have been found\n             */\n\n            break;\n        }\n        ps = &ap_scoreboard_image->parent[i];\n        for (j = 0; j < threads_per_child; j++) {\n            ws = &ap_scoreboard_image->servers[i][j];\n            status = ws->status;\n\n            /* XXX any_dying_threads is probably no longer needed    GLA */\n            any_dying_threads = any_dying_threads ||\n                (status == SERVER_GRACEFUL);\n            any_dead_threads = any_dead_threads || (status == SERVER_DEAD);\n            all_dead_threads = all_dead_threads &&\n                (status == SERVER_DEAD || status == SERVER_GRACEFUL);\n\n            /* We consider a starting server as idle because we started it\n             * at least a cycle ago, and if it still hasn't finished starting\n             * then we're just going to swamp things worse by forking more.\n             * So we hopefully won't need to fork more if we count it.\n             * This depends on the ordering of SERVER_READY and SERVER_STARTING.\n             */\n            if (ps->pid != 0) { /* XXX just set all_dead_threads in outer\n                                   for loop if no pid?  not much else matters */\n                if (status <= SERVER_READY && !ps->quiescing && !ps->not_accepting\n                    && ps->generation == retained->my_generation\n                    && ps->bucket == child_bucket)\n                {\n                    ++idle_thread_count;\n                }\n                if (status >= SERVER_READY && status < SERVER_GRACEFUL) {\n                    ++child_threads_active;\n                }\n            }\n        }\n        active_thread_count += child_threads_active;\n        if (!ps->pid && free_length < retained->idle_spawn_rate[child_bucket])\n        {\n            free_slots[free_length++] = i;\n        }\n        else if (child_threads_active == threads_per_child) {\n            had_healthy_child = 1;\n        }\n        /* XXX if (!ps->quiescing)     is probably more reliable  GLA */\n        if (!any_dying_threads) {\n            last_non_dead = i;\n            ++total_non_dead;\n        }\n    }\n\n    if (retained->sick_child_detected) {\n        if (had_healthy_child) {\n            /* Assume this is a transient error, even though it may not be.  Leave\n             * the server up in case it is able to serve some requests or the\n             * problem will be resolved.\n             */\n            retained->sick_child_detected = 0;\n        }\n        else {\n            /* looks like a basket case, as no child ever fully initialized; give up.\n             */\n            shutdown_pending = 1;\n            child_fatal = 1;\n            ap_log_error(APLOG_MARK, APLOG_ALERT, 0,\n                         ap_server_conf, APLOGNO(02324)\n                         \"A resource shortage or other unrecoverable failure \"\n                         \"was encountered before any child process initialized \"\n                         \"successfully... httpd is exiting!\");\n            /* the child already logged the failure details */\n            return;\n        }\n    }\n\n    retained->max_daemons_limit = last_non_dead + 1;\n\n    if (idle_thread_count > max_spare_threads / num_buckets) {\n        /* Kill off one child */\n        ap_mpm_podx_signal(all_buckets[child_bucket].pod,\n                           AP_MPM_PODX_GRACEFUL);\n        retained->idle_spawn_rate[child_bucket] = 1;\n    }\n    else if (idle_thread_count < min_spare_threads / num_buckets) {\n        /* terminate the free list */\n        if (free_length == 0) { /* scoreboard is full, can't fork */\n\n            if (active_thread_count >= max_workers) {\n                if (!retained->maxclients_reported) {\n                    /* only report this condition once */\n                    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00484)\n                                 \"server reached MaxRequestWorkers setting, \"\n                                 \"consider raising the MaxRequestWorkers \"\n                                 \"setting\");\n                    retained->maxclients_reported = 1;\n                }\n            }\n            else {\n                ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(00485)\n                             \"scoreboard is full, not at MaxRequestWorkers\");\n            }\n            retained->idle_spawn_rate[child_bucket] = 1;\n        }\n        else {\n            if (free_length > retained->idle_spawn_rate[child_bucket]) {\n                free_length = retained->idle_spawn_rate[child_bucket];\n            }\n            if (retained->idle_spawn_rate[child_bucket] >= 8) {\n                ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(00486)\n                             \"server seems busy, (you may need \"\n                             \"to increase StartServers, ThreadsPerChild \"\n                             \"or Min/MaxSpareThreads), \"\n                             \"spawning %d children, there are around %d idle \"\n                             \"threads, and %d total children\", free_length,\n                             idle_thread_count, total_non_dead);\n            }\n            for (i = 0; i < free_length; ++i) {\n                make_child(ap_server_conf, free_slots[i], child_bucket);\n            }\n            /* the next time around we want to spawn twice as many if this\n             * wasn't good enough, but not if we've just done a graceful\n             */\n            if (retained->hold_off_on_exponential_spawning) {\n                --retained->hold_off_on_exponential_spawning;\n            }\n            else if (retained->idle_spawn_rate[child_bucket]\n                     < MAX_SPAWN_RATE / num_buckets) {\n                retained->idle_spawn_rate[child_bucket] *= 2;\n            }\n        }\n    }\n    else {\n        retained->idle_spawn_rate[child_bucket] = 1;\n    }\n}", "target": 0}
{"idx": 4695, "func": "static int\nTIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)\n{\n\tstatic const char module[] = \"TIFFAdvanceDirectory\";\n\tif (isMapped(tif))\n\t{\n\t\tuint64 poff=*nextdir;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\ttmsize_t poffa,poffb,poffc,poffd;\n\t\t\tuint16 dircount;\n\t\t\tuint32 nextdir32;\n\t\t\tpoffa=(tmsize_t)poff;\n\t\t\tpoffb=poffa+sizeof(uint16);\n\t\t\tif (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint16))||(poffb>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory count\");\n                                  *nextdir=0;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(&dircount,tif->tif_base+poffa,sizeof(uint16));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount);\n\t\t\tpoffc=poffb+dircount*12;\n\t\t\tpoffd=poffc+sizeof(uint32);\n\t\t\tif ((poffc<poffb)||(poffc<dircount*12)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint32))||(poffd>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory link\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (off!=NULL)\n\t\t\t\t*off=(uint64)poffc;\n\t\t\t_TIFFmemcpy(&nextdir32,tif->tif_base+poffc,sizeof(uint32));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&nextdir32);\n\t\t\t*nextdir=nextdir32;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmsize_t poffa,poffb,poffc,poffd;\n\t\t\tuint64 dircount64;\n\t\t\tuint16 dircount16;\n\t\t\tpoffa=(tmsize_t)poff;\n\t\t\tpoffb=poffa+sizeof(uint64);\n\t\t\tif (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint64))||(poffb>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory count\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(&dircount64,tif->tif_base+poffa,sizeof(uint64));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>0xFFFF)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Sanity check on directory count failed\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tdircount16=(uint16)dircount64;\n\t\t\tpoffc=poffb+dircount16*20;\n\t\t\tpoffd=poffc+sizeof(uint64);\n\t\t\tif ((poffc<poffb)||(poffc<dircount16*20)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint64))||(poffd>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory link\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (off!=NULL)\n\t\t\t\t*off=(uint64)poffc;\n\t\t\t_TIFFmemcpy(nextdir,tif->tif_base+poffc,sizeof(uint64));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(nextdir);\n\t\t}\n\t\treturn(1);\n\t}\n\telse\n\t{\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint16 dircount;\n\t\t\tuint32 nextdir32;\n\t\t\tif (!SeekOK(tif, *nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount, sizeof (uint16))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount);\n\t\t\tif (off != NULL)\n\t\t\t\t*off = TIFFSeekFile(tif,\n\t\t\t\t    dircount*12, SEEK_CUR);\n\t\t\telse\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    dircount*12, SEEK_CUR);\n\t\t\tif (!ReadOK(tif, &nextdir32, sizeof (uint32))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory link\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&nextdir32);\n\t\t\t*nextdir=nextdir32;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 dircount64;\n\t\t\tuint16 dircount16;\n\t\t\tif (!SeekOK(tif, *nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount64, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>0xFFFF)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error fetching directory count\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tif (off != NULL)\n\t\t\t\t*off = TIFFSeekFile(tif,\n\t\t\t\t    dircount16*20, SEEK_CUR);\n\t\t\telse\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    dircount16*20, SEEK_CUR);\n\t\t\tif (!ReadOK(tif, nextdir, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n                                             \"%s: Error fetching directory link\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(nextdir);\n\t\t}\n\t\treturn (1);\n\t}\n}", "target": 1}
{"idx": 4696, "func": "static int encode_frame(AVCodecContext *avctx, unsigned char *buf,\n                        int buf_size, void *data)\n{\n    const AVFrame *pic = data;\n    int aligned_width = ((avctx->width + 47) / 48) * 48;\n    int stride = aligned_width * 8 / 3;\n    int h, w;\n    const uint16_t *y = (const uint16_t*)pic->data[0];\n    const uint16_t *u = (const uint16_t*)pic->data[1];\n    const uint16_t *v = (const uint16_t*)pic->data[2];\n    uint8_t *p = buf;\n    uint8_t *pdst = buf;\n\n    if (buf_size < aligned_width * avctx->height * 8 / 3) {\n        av_log(avctx, AV_LOG_ERROR, \"output buffer too small\\n\");\n        return -1;\n    }\n\n#define CLIP(v) av_clip(v, 4, 1019)\n\n#define WRITE_PIXELS(a, b, c)           \\\n    do {                                \\\n        val =   CLIP(*a++);             \\\n        val |= (CLIP(*b++) << 10) |     \\\n               (CLIP(*c++) << 20);      \\\n        bytestream_put_le32(&p, val);   \\\n    } while (0)\n\n    for (h = 0; h < avctx->height; h++) {\n        uint32_t val;\n        for (w = 0; w < avctx->width - 5; w += 6) {\n            WRITE_PIXELS(u, y, v);\n            WRITE_PIXELS(y, u, y);\n            WRITE_PIXELS(v, y, u);\n            WRITE_PIXELS(y, v, y);\n        }\n        if (w < avctx->width - 1) {\n            WRITE_PIXELS(u, y, v);\n\n            val = CLIP(*y++);\n            if (w == avctx->width - 2)\n                bytestream_put_le32(&p, val);\n        }\n        if (w < avctx->width - 3) {\n            val |= (CLIP(*u++) << 10) | (CLIP(*y++) << 20);\n            bytestream_put_le32(&p, val);\n\n            val = CLIP(*v++) | (CLIP(*y++) << 10);\n            bytestream_put_le32(&p, val);\n        }\n\n        pdst += stride;\n        memset(p, 0, pdst - p);\n        p = pdst;\n        y += pic->linesize[0] / 2 - avctx->width;\n        u += pic->linesize[1] / 2 - avctx->width / 2;\n        v += pic->linesize[2] / 2 - avctx->width / 2;\n    }\n\n    return p - buf;\n}", "target": 1}
{"idx": 4697, "func": "static av_always_inline\nint vp78_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                      AVPacket *avpkt, int is_vp7)\n{\n    VP8Context *s = avctx->priv_data;\n    int ret, i, referenced, num_jobs;\n    enum AVDiscard skip_thresh;\n    VP8Frame *av_uninit(curframe), *prev_frame;\n\n    if (is_vp7)\n        ret = vp7_decode_frame_header(s, avpkt->data, avpkt->size);\n    else\n        ret = vp8_decode_frame_header(s, avpkt->data, avpkt->size);\n\n    if (ret < 0)\n        goto err;\n\n    prev_frame = s->framep[VP56_FRAME_CURRENT];\n\n    referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT ||\n                 s->update_altref == VP56_FRAME_CURRENT;\n\n    skip_thresh = !referenced ? AVDISCARD_NONREF\n                              : !s->keyframe ? AVDISCARD_NONKEY\n                                             : AVDISCARD_ALL;\n\n    if (avctx->skip_frame >= skip_thresh) {\n        s->invisible = 1;\n        memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);\n        goto skip_decode;\n    }\n    s->deblock_filter = s->filter.level && avctx->skip_loop_filter < skip_thresh;\n\n    // release no longer referenced frames\n    for (i = 0; i < 5; i++)\n        if (s->frames[i].tf.f->data[0] &&\n            &s->frames[i] != prev_frame &&\n            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&\n            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN]   &&\n            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2])\n            vp8_release_frame(s, &s->frames[i]);\n\n    curframe = s->framep[VP56_FRAME_CURRENT] = vp8_find_free_buffer(s);\n\n    /* Given that arithmetic probabilities are updated every frame, it's quite\n     * likely that the values we have on a random interframe are complete\n     * junk if we didn't start decode on a keyframe. So just don't display\n     * anything rather than junk. */\n    if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||\n                         !s->framep[VP56_FRAME_GOLDEN]   ||\n                         !s->framep[VP56_FRAME_GOLDEN2])) {\n        av_log(avctx, AV_LOG_WARNING,\n               \"Discarding interframe without a prior keyframe!\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto err;\n    }\n\n    curframe->tf.f->key_frame = s->keyframe;\n    curframe->tf.f->pict_type = s->keyframe ? AV_PICTURE_TYPE_I\n                                            : AV_PICTURE_TYPE_P;\n    if ((ret = vp8_alloc_frame(s, curframe, referenced))) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed!\\n\");\n        goto err;\n    }\n\n    // check if golden and altref are swapped\n    if (s->update_altref != VP56_FRAME_NONE)\n        s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[s->update_altref];\n    else\n        s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[VP56_FRAME_GOLDEN2];\n\n    if (s->update_golden != VP56_FRAME_NONE)\n        s->next_framep[VP56_FRAME_GOLDEN] = s->framep[s->update_golden];\n    else\n        s->next_framep[VP56_FRAME_GOLDEN] = s->framep[VP56_FRAME_GOLDEN];\n\n    if (s->update_last)\n        s->next_framep[VP56_FRAME_PREVIOUS] = curframe;\n    else\n        s->next_framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_PREVIOUS];\n\n    s->next_framep[VP56_FRAME_CURRENT] = curframe;\n\n    ff_thread_finish_setup(avctx);\n\n    s->linesize   = curframe->tf.f->linesize[0];\n    s->uvlinesize = curframe->tf.f->linesize[1];\n\n    memset(s->top_nnz, 0, s->mb_width * sizeof(*s->top_nnz));\n    /* Zero macroblock structures for top/top-left prediction\n     * from outside the frame. */\n    if (!s->mb_layout)\n        memset(s->macroblocks + s->mb_height * 2 - 1, 0,\n               (s->mb_width + 1) * sizeof(*s->macroblocks));\n    if (!s->mb_layout && s->keyframe)\n        memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width * 4);\n\n    memset(s->ref_count, 0, sizeof(s->ref_count));\n\n    if (s->mb_layout == 1) {\n        // Make sure the previous frame has read its segmentation map,\n        // if we re-use the same map.\n        if (prev_frame && s->segmentation.enabled &&\n            !s->segmentation.update_map)\n            ff_thread_await_progress(&prev_frame->tf, 1, 0);\n        if (is_vp7)\n            vp7_decode_mv_mb_modes(avctx, curframe, prev_frame);\n        else\n            vp8_decode_mv_mb_modes(avctx, curframe, prev_frame);\n    }\n\n    if (avctx->active_thread_type == FF_THREAD_FRAME)\n        num_jobs = 1;\n    else\n        num_jobs = FFMIN(s->num_coeff_partitions, avctx->thread_count);\n    s->num_jobs   = num_jobs;\n    s->curframe   = curframe;\n    s->prev_frame = prev_frame;\n    s->mv_min.y   = -MARGIN;\n    s->mv_max.y   = ((s->mb_height - 1) << 6) + MARGIN;\n    for (i = 0; i < MAX_THREADS; i++) {\n        s->thread_data[i].thread_mb_pos = 0;\n        s->thread_data[i].wait_mb_pos   = INT_MAX;\n    }\n    if (is_vp7)\n        avctx->execute2(avctx, vp7_decode_mb_row_sliced, s->thread_data, NULL,\n                        num_jobs);\n    else\n        avctx->execute2(avctx, vp8_decode_mb_row_sliced, s->thread_data, NULL,\n                        num_jobs);\n\n    ff_thread_report_progress(&curframe->tf, INT_MAX, 0);\n    memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4);\n\nskip_decode:\n    // if future frames don't use the updated probabilities,\n    // reset them to the values we saved\n    if (!s->update_probabilities)\n        s->prob[0] = s->prob[1];\n\n    if (!s->invisible) {\n        if ((ret = av_frame_ref(data, curframe->tf.f)) < 0)\n            return ret;\n        *got_frame = 1;\n    }\n\n    return avpkt->size;\nerr:\n    memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);\n    return ret;\n}", "target": 0}
{"idx": 4698, "func": "static void\nngx_conf_flush_files(ngx_cycle_t *cycle)\n{\n    ssize_t           n, len;\n    ngx_uint_t        i;\n    ngx_list_part_t  *part;\n    ngx_open_file_t  *file;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_CORE, cycle->log, 0, \"flush files\");\n\n    part = &cycle->open_files.part;\n    file = part->elts;\n\n    for (i = 0; /* void */ ; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            file = part->elts;\n            i = 0;\n        }\n\n        len = file[i].pos - file[i].buffer;\n\n        if (file[i].buffer == NULL || len == 0) {\n            continue;\n        }\n\n        n = ngx_write_fd(file[i].fd, file[i].buffer, len);\n\n        if (n == -1) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          ngx_write_fd_n \" to \\\"%s\\\" failed\",\n                          file[i].name.data);\n\n        } else if (n != len) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,\n                          ngx_write_fd_n \" to \\\"%s\\\" was incomplete: %z of %uz\",\n                          file[i].name.data, n, len);\n        }\n    }\n}", "target": 1}
{"idx": 4699, "func": "static void restore_median_il(uint8_t *src, int step, int stride,\n                              int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask   = ~(rmode ? 3 : 1);\n    const int stride2 = stride << 1;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start    = ((slice * height) / slices) & cmask;\n        slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                         slice_start;\n        slice_height >>= 1;\n\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            bsrc[stride + i] += A;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        if (slice_height == 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride2];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride2];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            B                 = bsrc[i - stride];\n            bsrc[stride + i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C                 = B;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride2];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            for (i = 0; i < width * step; i += step) {\n                B                 = bsrc[i - stride];\n                bsrc[i + stride] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C                 = B;\n                A                 = bsrc[i + stride];\n            }\n            bsrc += stride2;\n        }\n    }\n}", "target": 1}
{"idx": 4700, "func": "int CRYPTO_add_lock(int *pointer, int amount, int type, const char *file,\n\t     int line)\n\t{\n\tint ret = 0;\n\n\tif (add_lock_callback != NULL)\n\t\t{\n#ifdef LOCK_DEBUG\n\t\tint before= *pointer;\n#endif\n\n\t\tret=add_lock_callback(pointer,amount,type,file,line);\n#ifdef LOCK_DEBUG\n\t\tfprintf(stderr,\"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\\n\",\n\t\t\tCRYPTO_thread_id(),\n\t\t\tbefore,amount,ret,\n\t\t\tCRYPTO_get_lock_name(type),\n\t\t\tfile,line);\n#endif\n\t\t*pointer=ret;\n\t\t}\n\telse\n\t\t{\n\t\tCRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,file,line);\n\n\t\tret= *pointer+amount;\n#ifdef LOCK_DEBUG\n\t\tfprintf(stderr,\"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\\n\",\n\t\t\tCRYPTO_thread_id(),\n\t\t\t*pointer,amount,ret,\n\t\t\tCRYPTO_get_lock_name(type),\n\t\t\tfile,line);\n#endif\n\t\t*pointer=ret;\n\t\tCRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,file,line);\n\t\t}\n\treturn(ret);\n\t}", "target": 1}
{"idx": 4701, "func": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509 **pissuer,\n\t\t\tint *pscore, unsigned int *preasons,\n\t\t\tSTACK_OF(X509_CRL) *crls)\n\t{\n\tint i, crl_score, best_score = *pscore;\n\tunsigned int reasons, best_reasons;\n\tX509 *x = ctx->current_cert;\n\tX509_CRL *crl, *best_crl = NULL;\n\tX509 *crl_issuer, *best_crl_issuer = NULL;\n\tfor (i = 0; i < sk_X509_CRL_num(crls); i++)\n\t\t{\n\t\tcrl = sk_X509_CRL_value(crls, i);\n\t\treasons = *preasons;\n\t\tcrl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n\n\t\tif (crl_score > best_score)\n\t\t\t{\n\t\t\tbest_crl = crl;\n\t\t\tbest_crl_issuer = crl_issuer;\n\t\t\tbest_score = crl_score;\n\t\t\tbest_reasons = reasons;\n\t\t\t}\n\t\t}\n\n\tif (best_crl)\n\t\t{\n\t\tif (*pcrl)\n\t\t\tX509_CRL_free(*pcrl);\n\t\t*pcrl = best_crl;\n\t\t*pissuer = best_crl_issuer;\n\t\t*pscore = best_score;\n\t\t*preasons = best_reasons;\n\t\tCRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509);\n\t\t}\n\n\n\tif (best_score >= CRL_SCORE_VALID)\n\t\treturn 1;\n\n\treturn 0;\n\t}", "target": 0}
{"idx": 4702, "func": "int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\n{\n\tint i,idx=0,n=0,len,nid;\n\tunsigned long l;\n\tunsigned char *p;\n\tconst char *s;\n\tchar tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];\n\n\tif (buf_len <= 0) return(0);\n\n\tif ((a == NULL) || (a->data == NULL)) {\n\t\tbuf[0]='\\0';\n\t\treturn(0);\n\t}\n\n\tif (no_name || (nid=OBJ_obj2nid(a)) == NID_undef) {\n\t\tlen=a->length;\n\t\tp=a->data;\n\n\t\tidx=0;\n\t\tl=0;\n\t\twhile (idx < a->length) {\n\t\t\tl|=(p[idx]&0x7f);\n\t\t\tif (!(p[idx] & 0x80)) break;\n\t\t\tl<<=7L;\n\t\t\tidx++;\n\t\t}\n\t\tidx++;\n\t\ti=(int)(l/40);\n\t\tif (i > 2) i=2;\n\t\tl-=(long)(i*40);\n\n\t\tBIO_snprintf(tbuf,sizeof tbuf,\"%d.%lu\",i,l);\n\t\ti=strlen(tbuf);\n\t\tBUF_strlcpy(buf,tbuf,buf_len);\n\t\tbuf_len-=i;\n\t\tbuf+=i;\n\t\tn+=i;\n\n\t\tl=0;\n\t\tfor (; idx<len; idx++) {\n\t\t\tl|=p[idx]&0x7f;\n\t\t\tif (!(p[idx] & 0x80)) {\n\t\t\t\tBIO_snprintf(tbuf,sizeof tbuf,\".%lu\",l);\n\t\t\t\ti=strlen(tbuf);\n\t\t\t\tif (buf_len > 0)\n\t\t\t\t\tBUF_strlcpy(buf,tbuf,buf_len);\n\t\t\t\tbuf_len-=i;\n\t\t\t\tbuf+=i;\n\t\t\t\tn+=i;\n\t\t\t\tl=0;\n\t\t\t}\n\t\t\tl<<=7L;\n\t\t}\n\t} else {\n\t\ts=OBJ_nid2ln(nid);\n\t\tif (s == NULL)\n\t\t\ts=OBJ_nid2sn(nid);\n\t\tBUF_strlcpy(buf,s,buf_len);\n\t\tn=strlen(s);\n\t}\n\treturn(n);\n}", "target": 0}
{"idx": 4703, "func": "X509_STORE_CTX *X509_STORE_CTX_new(void)\n{\n\tX509_STORE_CTX *ctx;\n\tctx = (X509_STORE_CTX *)OPENSSL_malloc(sizeof(X509_STORE_CTX));\n\tif(ctx) memset(ctx, 0, sizeof(X509_STORE_CTX));\n\treturn ctx;\n}", "target": 1}
{"idx": 4704, "func": "static av_cold int vc2_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n                                      const AVFrame *frame, int *got_packet)\n{\n    int ret = 0;\n    int sig_size = 256;\n    VC2EncContext *s = avctx->priv_data;\n    const char aux_data[] = LIBAVCODEC_IDENT;\n    const int aux_data_size = sizeof(aux_data);\n    const int header_size = 100 + aux_data_size;\n    int64_t max_frame_bytes, r_bitrate = avctx->bit_rate >> (s->interlaced);\n\n    s->avctx = avctx;\n    s->size_scaler = 1;\n    s->prefix_bytes = 0;\n    s->last_parse_code = 0;\n    s->next_parse_offset = 0;\n\n    /* Rate control */\n    max_frame_bytes = (av_rescale(r_bitrate, s->avctx->time_base.num,\n                                  s->avctx->time_base.den) >> 3) - header_size;\n\n    /* Find an appropriate size scaler */\n    while (sig_size > 255) {\n        s->slice_max_bytes = FFALIGN(av_rescale(max_frame_bytes, 1,\n                                                s->num_x*s->num_y), s->size_scaler);\n        s->slice_max_bytes += 4 + s->prefix_bytes;\n        sig_size = s->slice_max_bytes/s->size_scaler; /* Signalled slize size */\n        s->size_scaler <<= 1;\n    }\n\n    s->slice_min_bytes = s->slice_max_bytes - s->slice_max_bytes*(s->tolerance/100.0f);\n\n    ret = encode_frame(s, avpkt, frame, aux_data, header_size, s->interlaced);\n    if (ret)\n        return ret;\n    if (s->interlaced) {\n        ret = encode_frame(s, avpkt, frame, aux_data, header_size, 2);\n        if (ret)\n            return ret;\n    }\n\n    flush_put_bits(&s->pb);\n    avpkt->size = put_bits_count(&s->pb) >> 3;\n\n    *got_packet = 1;\n\n    return 0;\n}", "target": 1}
{"idx": 4705, "func": "static int do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509, const EVP_MD *dgst,\n\t     STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial, char *subj,\n\t     int multirdn,\n\t     int email_dn, char *startdate, char *enddate, long days, int batch,\n\t     int verbose, X509_REQ *req, char *ext_sect, CONF *lconf,\n\t     unsigned long certopt, unsigned long nameopt, int default_op,\n\t     int ext_copy, int selfsign)\n\t{\n\tX509_NAME *name=NULL,*CAname=NULL,*subject=NULL, *dn_subject=NULL;\n\tASN1_UTCTIME *tm,*tmptm;\n\tASN1_STRING *str,*str2;\n\tASN1_OBJECT *obj;\n\tX509 *ret=NULL;\n\tX509_CINF *ci;\n\tX509_NAME_ENTRY *ne;\n\tX509_NAME_ENTRY *tne,*push;\n\tEVP_PKEY *pktmp;\n\tint ok= -1,i,j,last,nid;\n\tchar *p;\n\tCONF_VALUE *cv;\n\tchar *row[DB_NUMBER],**rrow=NULL,**irow=NULL;\n\tchar buf[25];\n\n\ttmptm=ASN1_UTCTIME_new();\n\tif (tmptm == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"malloc error\\n\");\n\t\treturn(0);\n\t\t}\n\n\tfor (i=0; i<DB_NUMBER; i++)\n\t\trow[i]=NULL;\n\n\tif (subj)\n\t\t{\n\t\tX509_NAME *n = parse_name(subj, MBSTRING_ASC, multirdn);\n\n\t\tif (!n)\n\t\t\t{\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto err;\n\t\t\t}\n\t\tX509_REQ_set_subject_name(req,n);\n\t\treq->req_info->enc.modified = 1;\n\t\tX509_NAME_free(n);\n\t\t}\n\n\tif (default_op)\n\t\tBIO_printf(bio_err,\"The Subject's Distinguished Name is as follows\\n\");\n\n\tname=X509_REQ_get_subject_name(req);\n\tfor (i=0; i<X509_NAME_entry_count(name); i++)\n\t\t{\n\t\tne= X509_NAME_get_entry(name,i);\n\t\tstr=X509_NAME_ENTRY_get_data(ne);\n\t\tobj=X509_NAME_ENTRY_get_object(ne);\n\n\t\tif (msie_hack)\n\t\t\t{\n\t\t\t/* assume all type should be strings */\n\t\t\tnid=OBJ_obj2nid(ne->object);\n\n\t\t\tif (str->type == V_ASN1_UNIVERSALSTRING)\n\t\t\t\tASN1_UNIVERSALSTRING_to_string(str);\n\n\t\t\tif ((str->type == V_ASN1_IA5STRING) &&\n\t\t\t\t(nid != NID_pkcs9_emailAddress))\n\t\t\t\tstr->type=V_ASN1_T61STRING;\n\n\t\t\tif ((nid == NID_pkcs9_emailAddress) &&\n\t\t\t\t(str->type == V_ASN1_PRINTABLESTRING))\n\t\t\t\tstr->type=V_ASN1_IA5STRING;\n\t\t\t}\n\n\t\t/* If no EMAIL is wanted in the subject */\n\t\tif ((OBJ_obj2nid(obj) == NID_pkcs9_emailAddress) && (!email_dn))\n\t\t\tcontinue;\n\n\t\t/* check some things */\n\t\tif ((OBJ_obj2nid(obj) == NID_pkcs9_emailAddress) &&\n\t\t\t(str->type != V_ASN1_IA5STRING))\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"\\nemailAddress type needs to be of type IA5STRING\\n\");\n\t\t\tgoto err;\n\t\t\t}\n\t\tif ((str->type != V_ASN1_BMPSTRING) && (str->type != V_ASN1_UTF8STRING))\n\t\t\t{\n\t\t\tj=ASN1_PRINTABLE_type(str->data,str->length);\n\t\t\tif (\t((j == V_ASN1_T61STRING) &&\n\t\t\t\t (str->type != V_ASN1_T61STRING)) ||\n\t\t\t\t((j == V_ASN1_IA5STRING) &&\n\t\t\t\t (str->type == V_ASN1_PRINTABLESTRING)))\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err,\"\\nThe string contains characters that are illegal for the ASN.1 type\\n\");\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif (default_op)\n\t\t\told_entry_print(bio_err, obj, str);\n\t\t}\n\n\t/* Ok, now we check the 'policy' stuff. */\n\tif ((subject=X509_NAME_new()) == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\tgoto err;\n\t\t}\n\n\t/* take a copy of the issuer name before we mess with it. */\n\tif (selfsign)\n\t\tCAname=X509_NAME_dup(name);\n\telse\n\t\tCAname=X509_NAME_dup(x509->cert_info->subject);\n\tif (CAname == NULL) goto err;\n\tstr=str2=NULL;\n\n\tfor (i=0; i<sk_CONF_VALUE_num(policy); i++)\n\t\t{\n\t\tcv=sk_CONF_VALUE_value(policy,i); /* get the object id */\n\t\tif ((j=OBJ_txt2nid(cv->name)) == NID_undef)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"%s:unknown object type in 'policy' configuration\\n\",cv->name);\n\t\t\tgoto err;\n\t\t\t}\n\t\tobj=OBJ_nid2obj(j);\n\n\t\tlast= -1;\n\t\tfor (;;)\n\t\t\t{\n\t\t\t/* lookup the object in the supplied name list */\n\t\t\tj=X509_NAME_get_index_by_OBJ(name,obj,last);\n\t\t\tif (j < 0)\n\t\t\t\t{\n\t\t\t\tif (last != -1) break;\n\t\t\t\ttne=NULL;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ttne=X509_NAME_get_entry(name,j);\n\t\t\t\t}\n\t\t\tlast=j;\n\n\t\t\t/* depending on the 'policy', decide what to do. */\n\t\t\tpush=NULL;\n\t\t\tif (strcmp(cv->value,\"optional\") == 0)\n\t\t\t\t{\n\t\t\t\tif (tne != NULL)\n\t\t\t\t\tpush=tne;\n\t\t\t\t}\n\t\t\telse if (strcmp(cv->value,\"supplied\") == 0)\n\t\t\t\t{\n\t\t\t\tif (tne == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\"The %s field needed to be supplied and was missing\\n\",cv->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpush=tne;\n\t\t\t\t}\n\t\t\telse if (strcmp(cv->value,\"match\") == 0)\n\t\t\t\t{\n\t\t\t\tint last2;\n\n\t\t\t\tif (tne == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\"The mandatory %s field was missing\\n\",cv->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\n\t\t\t\tlast2= -1;\n\nagain2:\n\t\t\t\tj=X509_NAME_get_index_by_OBJ(CAname,obj,last2);\n\t\t\t\tif ((j < 0) && (last2 == -1))\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\"The %s field does not exist in the CA certificate,\\nthe 'policy' is misconfigured\\n\",cv->name);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\tif (j >= 0)\n\t\t\t\t\t{\n\t\t\t\t\tpush=X509_NAME_get_entry(CAname,j);\n\t\t\t\t\tstr=X509_NAME_ENTRY_get_data(tne);\n\t\t\t\t\tstr2=X509_NAME_ENTRY_get_data(push);\n\t\t\t\t\tlast2=j;\n\t\t\t\t\tif (ASN1_STRING_cmp(str,str2) != 0)\n\t\t\t\t\t\tgoto again2;\n\t\t\t\t\t}\n\t\t\t\tif (j < 0)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err,\"The %s field needed to be the same in the\\nCA certificate (%s) and the request (%s)\\n\",cv->name,((str2 == NULL)?\"NULL\":(char *)str2->data),((str == NULL)?\"NULL\":(char *)str->data));\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err,\"%s:invalid type in 'policy' configuration\\n\",cv->value);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\tif (push != NULL)\n\t\t\t\t{\n\t\t\t\tif (!X509_NAME_add_entry(subject,push, -1, 0))\n\t\t\t\t\t{\n\t\t\t\t\tif (push != NULL)\n\t\t\t\t\t\tX509_NAME_ENTRY_free(push);\n\t\t\t\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (j < 0) break;\n\t\t\t}\n\t\t}\n\n\tif (preserve)\n\t\t{\n\t\tX509_NAME_free(subject);\n\t\t/* subject=X509_NAME_dup(X509_REQ_get_subject_name(req)); */\n\t\tsubject=X509_NAME_dup(name);\n\t\tif (subject == NULL) goto err;\n\t\t}\n\n\tif (verbose)\n\t\tBIO_printf(bio_err,\"The subject name appears to be ok, checking data base for clashes\\n\");\n\n\t/* Build the correct Subject if no e-mail is wanted in the subject */\n\t/* and add it later on because of the method extensions are added (altName) */\n\t \n\tif (email_dn)\n\t\tdn_subject = subject;\n\telse\n\t\t{\n\t\tX509_NAME_ENTRY *tmpne;\n\t\t/* Its best to dup the subject DN and then delete any email\n\t\t * addresses because this retains its structure.\n\t\t */\n\t\tif (!(dn_subject = X509_NAME_dup(subject)))\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\t\tgoto err;\n\t\t\t}\n\t\twhile((i = X509_NAME_get_index_by_NID(dn_subject,\n\t\t\t\t\tNID_pkcs9_emailAddress, -1)) >= 0)\n\t\t\t{\n\t\t\ttmpne = X509_NAME_get_entry(dn_subject, i);\n\t\t\tX509_NAME_delete_entry(dn_subject, i);\n\t\t\tX509_NAME_ENTRY_free(tmpne);\n\t\t\t}\n\t\t}\n\n\tif (BN_is_zero(serial))\n\t\trow[DB_serial]=BUF_strdup(\"00\");\n\telse\n\t\trow[DB_serial]=BN_bn2hex(serial);\n\tif (row[DB_serial] == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\tgoto err;\n\t\t}\n\n\tif (db->attributes.unique_subject)\n\t\t{\n\t\trrow=TXT_DB_get_by_index(db->db,DB_name,row);\n\t\tif (rrow != NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\n\t\t\t\t\"ERROR:There is already a certificate for %s\\n\",\n\t\t\t\trow[DB_name]);\n\t\t\t}\n\t\t}\n\tif (rrow == NULL)\n\t\t{\n\t\trrow=TXT_DB_get_by_index(db->db,DB_serial,row);\n\t\tif (rrow != NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"ERROR:Serial number %s has already been issued,\\n\",\n\t\t\t\trow[DB_serial]);\n\t\t\tBIO_printf(bio_err,\"      check the database/serial_file for corruption\\n\");\n\t\t\t}\n\t\t}\n\n\tif (rrow != NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\n\t\t\t\"The matching entry has the following details\\n\");\n\t\tif (rrow[DB_type][0] == 'E')\n\t\t\tp=\"Expired\";\n\t\telse if (rrow[DB_type][0] == 'R')\n\t\t\tp=\"Revoked\";\n\t\telse if (rrow[DB_type][0] == 'V')\n\t\t\tp=\"Valid\";\n\t\telse\n\t\t\tp=\"\\ninvalid type, Data base error\\n\";\n\t\tBIO_printf(bio_err,\"Type\t  :%s\\n\",p);;\n\t\tif (rrow[DB_type][0] == 'R')\n\t\t\t{\n\t\t\tp=rrow[DB_exp_date]; if (p == NULL) p=\"undef\";\n\t\t\tBIO_printf(bio_err,\"Was revoked on:%s\\n\",p);\n\t\t\t}\n\t\tp=rrow[DB_exp_date]; if (p == NULL) p=\"undef\";\n\t\tBIO_printf(bio_err,\"Expires on    :%s\\n\",p);\n\t\tp=rrow[DB_serial]; if (p == NULL) p=\"undef\";\n\t\tBIO_printf(bio_err,\"Serial Number :%s\\n\",p);\n\t\tp=rrow[DB_file]; if (p == NULL) p=\"undef\";\n\t\tBIO_printf(bio_err,\"File name     :%s\\n\",p);\n\t\tp=rrow[DB_name]; if (p == NULL) p=\"undef\";\n\t\tBIO_printf(bio_err,\"Subject Name  :%s\\n\",p);\n\t\tok= -1; /* This is now a 'bad' error. */\n\t\tgoto err;\n\t\t}\n\n\t/* We are now totally happy, lets make and sign the certificate */\n\tif (verbose)\n\t\tBIO_printf(bio_err,\"Everything appears to be ok, creating and signing the certificate\\n\");\n\n\tif ((ret=X509_new()) == NULL) goto err;\n\tci=ret->cert_info;\n\n#ifdef X509_V3\n\t/* Make it an X509 v3 certificate. */\n\tif (!X509_set_version(ret,2)) goto err;\n#endif\n\n\tif (BN_to_ASN1_INTEGER(serial,ci->serialNumber) == NULL)\n\t\tgoto err;\n\tif (selfsign)\n\t\t{\n\t\tif (!X509_set_issuer_name(ret,subject))\n\t\t\tgoto err;\n\t\t}\n\telse\n\t\t{\n\t\tif (!X509_set_issuer_name(ret,X509_get_subject_name(x509)))\n\t\t\tgoto err;\n\t\t}\n\n\tif (strcmp(startdate,\"today\") == 0)\n\t\tX509_gmtime_adj(X509_get_notBefore(ret),0);\n\telse ASN1_UTCTIME_set_string(X509_get_notBefore(ret),startdate);\n\n\tif (enddate == NULL)\n\t\tX509_gmtime_adj(X509_get_notAfter(ret),(long)60*60*24*days);\n\telse ASN1_UTCTIME_set_string(X509_get_notAfter(ret),enddate);\n\n\tif (!X509_set_subject_name(ret,subject)) goto err;\n\n\tpktmp=X509_REQ_get_pubkey(req);\n\ti = X509_set_pubkey(ret,pktmp);\n\tEVP_PKEY_free(pktmp);\n\tif (!i) goto err;\n\n\t/* Lets add the extensions, if there are any */\n\tif (ext_sect)\n\t\t{\n\t\tX509V3_CTX ctx;\n\t\tif (ci->version == NULL)\n\t\t\tif ((ci->version=ASN1_INTEGER_new()) == NULL)\n\t\t\t\tgoto err;\n\t\tASN1_INTEGER_set(ci->version,2); /* version 3 certificate */\n\n\t\t/* Free the current entries if any, there should not\n\t\t * be any I believe */\n\t\tif (ci->extensions != NULL)\n\t\t\tsk_X509_EXTENSION_pop_free(ci->extensions,\n\t\t\t\t\t\t   X509_EXTENSION_free);\n\n\t\tci->extensions = NULL;\n\n\t\t/* Initialize the context structure */\n\t\tif (selfsign)\n\t\t\tX509V3_set_ctx(&ctx, ret, ret, req, NULL, 0);\n\t\telse\n\t\t\tX509V3_set_ctx(&ctx, x509, ret, req, NULL, 0);\n\n\t\tif (extconf)\n\t\t\t{\n\t\t\tif (verbose)\n\t\t\t\tBIO_printf(bio_err, \"Extra configuration file found\\n\");\n \n\t\t\t/* Use the extconf configuration db LHASH */\n\t\t\tX509V3_set_nconf(&ctx, extconf);\n \n\t\t\t/* Test the structure (needed?) */\n\t\t\t/* X509V3_set_ctx_test(&ctx); */\n\n\t\t\t/* Adds exts contained in the configuration file */\n\t\t\tif (!X509V3_EXT_add_nconf(extconf, &ctx, ext_sect,ret))\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t    \"ERROR: adding extensions in section %s\\n\",\n\t\t\t\t\t\t\t\text_sect);\n\t\t\t\tERR_print_errors(bio_err);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (verbose)\n\t\t\t\tBIO_printf(bio_err, \"Successfully added extensions from file.\\n\");\n\t\t\t}\n\t\telse if (ext_sect)\n\t\t\t{\n\t\t\t/* We found extensions to be set from config file */\n\t\t\tX509V3_set_nconf(&ctx, lconf);\n\n\t\t\tif(!X509V3_EXT_add_nconf(lconf, &ctx, ext_sect, ret))\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err, \"ERROR: adding extensions in section %s\\n\", ext_sect);\n\t\t\t\tERR_print_errors(bio_err);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\tif (verbose) \n\t\t\t\tBIO_printf(bio_err, \"Successfully added extensions from config\\n\");\n\t\t\t}\n\t\t}\n\n\t/* Copy extensions from request (if any) */\n\n\tif (!copy_extensions(ret, req, ext_copy))\n\t\t{\n\t\tBIO_printf(bio_err, \"ERROR: adding extensions from request\\n\");\n\t\tERR_print_errors(bio_err);\n\t\tgoto err;\n\t\t}\n\n\t/* Set the right value for the noemailDN option */\n\tif( email_dn == 0 )\n\t\t{\n\t\tif (!X509_set_subject_name(ret,dn_subject)) goto err;\n\t\t}\n\n\tif (!default_op)\n\t\t{\n\t\tBIO_printf(bio_err, \"Certificate Details:\\n\");\n\t\t/* Never print signature details because signature not present */\n\t\tcertopt |= X509_FLAG_NO_SIGDUMP | X509_FLAG_NO_SIGNAME;\n\t\tX509_print_ex(bio_err, ret, nameopt, certopt); \n\t\t}\n\n\tBIO_printf(bio_err,\"Certificate is to be certified until \");\n\tASN1_UTCTIME_print(bio_err,X509_get_notAfter(ret));\n\tif (days) BIO_printf(bio_err,\" (%ld days)\",days);\n\tBIO_printf(bio_err, \"\\n\");\n\n\tif (!batch)\n\t\t{\n\n\t\tBIO_printf(bio_err,\"Sign the certificate? [y/n]:\");\n\t\t(void)BIO_flush(bio_err);\n\t\tbuf[0]='\\0';\n\t\tfgets(buf,sizeof(buf)-1,stdin);\n\t\tif (!((buf[0] == 'y') || (buf[0] == 'Y')))\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"CERTIFICATE WILL NOT BE CERTIFIED\\n\");\n\t\t\tok=0;\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\n#ifndef OPENSSL_NO_DSA\n\tif (pkey->type == EVP_PKEY_DSA) dgst=EVP_dss1();\n\tpktmp=X509_get_pubkey(ret);\n\tif (EVP_PKEY_missing_parameters(pktmp) &&\n\t\t!EVP_PKEY_missing_parameters(pkey))\n\t\tEVP_PKEY_copy_parameters(pktmp,pkey);\n\tEVP_PKEY_free(pktmp);\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\tif (pkey->type == EVP_PKEY_EC)\n\t\tdgst = EVP_ecdsa();\n\tpktmp = X509_get_pubkey(ret);\n\tif (EVP_PKEY_missing_parameters(pktmp) &&\n\t\t!EVP_PKEY_missing_parameters(pkey))\n\t\tEVP_PKEY_copy_parameters(pktmp, pkey);\n\tEVP_PKEY_free(pktmp);\n#endif\n\n\n\tif (!X509_sign(ret,pkey,dgst))\n\t\tgoto err;\n\n\t/* We now just add it to the database */\n\trow[DB_type]=(char *)OPENSSL_malloc(2);\n\n\ttm=X509_get_notAfter(ret);\n\trow[DB_exp_date]=(char *)OPENSSL_malloc(tm->length+1);\n\tmemcpy(row[DB_exp_date],tm->data,tm->length);\n\trow[DB_exp_date][tm->length]='\\0';\n\n\trow[DB_rev_date]=NULL;\n\n\t/* row[DB_serial] done already */\n\trow[DB_file]=(char *)OPENSSL_malloc(8);\n\trow[DB_name]=X509_NAME_oneline(X509_get_subject_name(ret),NULL,0);\n\n\tif ((row[DB_type] == NULL) || (row[DB_exp_date] == NULL) ||\n\t\t(row[DB_file] == NULL) || (row[DB_name] == NULL))\n\t\t{\n\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\tgoto err;\n\t\t}\n\tBUF_strlcpy(row[DB_file],\"unknown\",8);\n\trow[DB_type][0]='V';\n\trow[DB_type][1]='\\0';\n\n\tif ((irow=(char **)OPENSSL_malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"Memory allocation failure\\n\");\n\t\tgoto err;\n\t\t}\n\n\tfor (i=0; i<DB_NUMBER; i++)\n\t\t{\n\t\tirow[i]=row[i];\n\t\trow[i]=NULL;\n\t\t}\n\tirow[DB_NUMBER]=NULL;\n\n\tif (!TXT_DB_insert(db->db,irow))\n\t\t{\n\t\tBIO_printf(bio_err,\"failed to update database\\n\");\n\t\tBIO_printf(bio_err,\"TXT_DB error number %ld\\n\",db->db->error);\n\t\tgoto err;\n\t\t}\n\tok=1;\nerr:\n\tfor (i=0; i<DB_NUMBER; i++)\n\t\tif (row[i] != NULL) OPENSSL_free(row[i]);\n\n\tif (CAname != NULL)\n\t\tX509_NAME_free(CAname);\n\tif (subject != NULL)\n\t\tX509_NAME_free(subject);\n\tif ((dn_subject != NULL) && !email_dn)\n\t\tX509_NAME_free(dn_subject);\n\tif (tmptm != NULL)\n\t\tASN1_UTCTIME_free(tmptm);\n\tif (ok <= 0)\n\t\t{\n\t\tif (ret != NULL) X509_free(ret);\n\t\tret=NULL;\n\t\t}\n\telse\n\t\t*xret=ret;\n\treturn(ok);\n\t}", "target": 0}
{"idx": 4706, "func": "void av_dict_free(AVDictionary **pm)\n{\n    AVDictionary *m = *pm;\n\n    if (m) {\n        while (m->count--) {\n            av_free(m->elems[m->count].key);\n            av_free(m->elems[m->count].value);\n        }\n        av_free(m->elems);\n    }\n    av_freep(pm);\n}", "target": 1}
{"idx": 4707, "func": "static int can_merge_formats(AVFilterFormats *a_arg,\n                             AVFilterFormats *b_arg,\n                             enum AVMediaType type,\n                             int is_sample_rate)\n{\n    AVFilterFormats *a, *b, *ret;\n    if (a == b)\n        return 1;\n    a = clone_filter_formats(a_arg);\n    b = clone_filter_formats(b_arg);\n    if (is_sample_rate) {\n        ret = ff_merge_samplerates(a, b);\n    } else {\n        ret = ff_merge_formats(a, b, type);\n    }\n    if (ret) {\n        av_freep(&ret->formats);\n        av_freep(&ret);\n        return 1;\n    } else {\n        av_freep(&a->formats);\n        av_freep(&b->formats);\n        av_freep(&a);\n        av_freep(&b);\n        return 0;\n    }\n}", "target": 1}
{"idx": 4708, "func": "static int alloc_frame_buffer(MpegEncContext *s, Picture *pic)\n{\n    int edges_needed = av_codec_is_encoder(s->avctx->codec);\n    int r, ret;\n\n    pic->tf.f = pic->f;\n    if (s->codec_id != AV_CODEC_ID_WMV3IMAGE &&\n        s->codec_id != AV_CODEC_ID_VC1IMAGE  &&\n        s->codec_id != AV_CODEC_ID_MSS2) {\n        if (edges_needed) {\n            pic->f->width  = s->avctx->width  + 2 * EDGE_WIDTH;\n            pic->f->height = s->avctx->height + 2 * EDGE_WIDTH;\n        }\n\n        r = ff_thread_get_buffer(s->avctx, &pic->tf,\n                                 pic->reference ? AV_GET_BUFFER_FLAG_REF : 0);\n    } else {\n        pic->f->width  = s->avctx->width;\n        pic->f->height = s->avctx->height;\n        pic->f->format = s->avctx->pix_fmt;\n        r = avcodec_default_get_buffer2(s->avctx, pic->f, 0);\n    }\n\n    if (r < 0 || !pic->f->buf[0]) {\n        av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (%d %p)\\n\",\n               r, pic->f->data[0]);\n        return -1;\n    }\n\n    if (edges_needed) {\n        int i;\n        for (i = 0; pic->f->data[i]; i++) {\n            int offset = (EDGE_WIDTH >> (i ? s->chroma_y_shift : 0)) *\n                         pic->f->linesize[i] +\n                         (EDGE_WIDTH >> (i ? s->chroma_x_shift : 0));\n            pic->f->data[i] += offset;\n        }\n        pic->f->width  = s->avctx->width;\n        pic->f->height = s->avctx->height;\n    }\n\n    if (s->avctx->hwaccel) {\n        assert(!pic->hwaccel_picture_private);\n        if (s->avctx->hwaccel->priv_data_size) {\n            pic->hwaccel_priv_buf = av_buffer_allocz(s->avctx->hwaccel->priv_data_size);\n            if (!pic->hwaccel_priv_buf) {\n                av_log(s->avctx, AV_LOG_ERROR, \"alloc_frame_buffer() failed (hwaccel private data allocation)\\n\");\n                return -1;\n            }\n            pic->hwaccel_picture_private = pic->hwaccel_priv_buf->data;\n        }\n    }\n\n    if (s->linesize && (s->linesize   != pic->f->linesize[0] ||\n                        s->uvlinesize != pic->f->linesize[1])) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"get_buffer() failed (stride changed)\\n\");\n        ff_mpeg_unref_picture(s, pic);\n        return -1;\n    }\n\n    if (pic->f->linesize[1] != pic->f->linesize[2]) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"get_buffer() failed (uv stride mismatch)\\n\");\n        ff_mpeg_unref_picture(s, pic);\n        return -1;\n    }\n\n    if (!s->edge_emu_buffer &&\n        (ret = frame_size_alloc(s, pic->f->linesize[0])) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"get_buffer() failed to allocate context scratch buffers.\\n\");\n        ff_mpeg_unref_picture(s, pic);\n        return ret;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 4709, "func": "int BN_reciprocal(BIGNUM *r, const BIGNUM *m, int len, BN_CTX *ctx)\n\t{\n\tint ret= -1;\n\tBIGNUM *t;\n\n\tBN_CTX_start(ctx);\n\tif((t = BN_CTX_get(ctx)) == NULL) goto err;\n\n\tif (!BN_set_bit(t,len)) goto err;\n\n\tif (!BN_div(r,NULL,t,m,ctx)) goto err;\n\n\tret=len;\nerr:\n\tbn_check_top(r);\n\tBN_CTX_end(ctx);\n\treturn(ret);\n\t}", "target": 0}
{"idx": 4710, "func": "void ff_vp3_v_loop_filter_c(uint8_t *first_pixel, int stride, int *bounding_values)\n{\n    unsigned char *end;\n    int filter_value;\n    const int nstride= -stride;\n\n    for (end= first_pixel + 8; first_pixel < end; first_pixel++) {\n        filter_value =\n            (first_pixel[2 * nstride] - first_pixel[ stride])\n         +3*(first_pixel[0          ] - first_pixel[nstride]);\n        filter_value = bounding_values[(filter_value + 4) >> 3];\n        first_pixel[nstride] = av_clip_uint8(first_pixel[nstride] + filter_value);\n        first_pixel[0] = av_clip_uint8(first_pixel[0] - filter_value);\n    }\n}", "target": 1}
{"idx": 4711, "func": "static int frame_thread_init(AVCodecContext *avctx)\n{\n    int thread_count = avctx->thread_count;\n    AVCodec *codec = avctx->codec;\n    AVCodecContext *src = avctx;\n    FrameThreadContext *fctx;\n    int i, err = 0;\n\n    if (thread_count <= 1) {\n        avctx->active_thread_type = 0;\n        return 0;\n    }\n\n    avctx->thread_opaque = fctx = av_mallocz(sizeof(FrameThreadContext));\n\n    fctx->threads = av_mallocz(sizeof(PerThreadContext) * thread_count);\n    pthread_mutex_init(&fctx->buffer_mutex, NULL);\n    fctx->delaying = 1;\n\n    for (i = 0; i < thread_count; i++) {\n        AVCodecContext *copy = av_malloc(sizeof(AVCodecContext));\n        PerThreadContext *p  = &fctx->threads[i];\n\n        pthread_mutex_init(&p->mutex, NULL);\n        pthread_mutex_init(&p->progress_mutex, NULL);\n        pthread_cond_init(&p->input_cond, NULL);\n        pthread_cond_init(&p->progress_cond, NULL);\n        pthread_cond_init(&p->output_cond, NULL);\n\n        p->parent = fctx;\n        p->avctx  = copy;\n\n        *copy = *src;\n        copy->thread_opaque = p;\n        copy->pkt = &p->avpkt;\n\n        if (!i) {\n            src = copy;\n\n            if (codec->init)\n                err = codec->init(copy);\n\n            update_context_from_thread(avctx, copy, 1);\n        } else {\n            copy->is_copy   = 1;\n            copy->priv_data = av_malloc(codec->priv_data_size);\n            memcpy(copy->priv_data, src->priv_data, codec->priv_data_size);\n\n            if (codec->init_thread_copy)\n                err = codec->init_thread_copy(copy);\n        }\n\n        if (err) goto error;\n\n        pthread_create(&p->thread, NULL, frame_worker_thread, p);\n    }\n\n    return 0;\n\nerror:\n    frame_thread_free(avctx, i+1);\n\n    return err;\n}", "target": 1}
{"idx": 4712, "func": "AP_DECLARE(void) ap_update_vhost_from_headers(request_rec *r)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"Host\");\n    int is_v6literal = 0;\n    int have_hostname_from_url = 0;\n\n    if (r->hostname) {\n        /*\n         * If there was a host part in the Request-URI, ignore the 'Host'\n         * header.\n         */\n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (r->status != HTTP_OK)\n        return;\n\n    if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n        /*\n         * If we have both hostname from an absoluteURI and a Host header,\n         * we must ignore the Host header (RFC 2616 5.2).\n         * To enforce this, we reset the Host header to the value from the\n         * request line.\n         */\n        if (have_hostname_from_url && host_header != NULL) {\n            const char *repl = construct_host_header(r, is_v6literal);\n            apr_table_set(r->headers_in, \"Host\", repl);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"Replacing host header '%s' with host '%s' given \"\n                          \"in the request uri\", host_header, repl);\n        }\n    }\n\n    /* check if we tucked away a name_chain */\n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            check_hostalias(r);\n        else\n            check_serverpath(r);\n    }\n}", "target": 0}
{"idx": 4713, "func": "static int codec_reinit(AVCodecContext *avctx, int width, int height, int quality) {\n    NuvContext *c = avctx->priv_data;\n    width = (width + 1) & ~1;\n    height = (height + 1) & ~1;\n    if (quality >= 0)\n        get_quant_quality(c, quality);\n    if (width != c->width || height != c->height) {\n        if (av_image_check_size(height, width, 0, avctx) < 0)\n            return 0;\n        avctx->width = c->width = width;\n        avctx->height = c->height = height;\n        c->decomp_size = c->height * c->width * 3 / 2;\n        c->decomp_buf = av_realloc(c->decomp_buf, c->decomp_size + AV_LZO_OUTPUT_PADDING);\n        if (!c->decomp_buf) {\n            av_log(avctx, AV_LOG_ERROR, \"Can't allocate decompression buffer.\\n\");\n            return 0;\n        }\n        rtjpeg_decode_init(&c->rtj, &c->dsp, c->width, c->height, c->lq, c->cq);\n    } else if (quality != c->quality)\n        rtjpeg_decode_init(&c->rtj, &c->dsp, c->width, c->height, c->lq, c->cq);\n    return 1;\n}", "target": 0}
{"idx": 4714, "func": "ngx_int_t\nngx_walk_tree(ngx_tree_ctx_t *ctx, ngx_str_t *tree)\n{\n    void       *data, *prev;\n    u_char     *p, *name;\n    size_t      len;\n    ngx_int_t   rc;\n    ngx_err_t   err;\n    ngx_str_t   file, buf;\n    ngx_dir_t   dir;\n\n    ngx_str_null(&buf);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                   \"walk tree \\\"%V\\\"\", tree);\n\n    if (ngx_open_dir(tree, &dir) == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_CRIT, ctx->log, ngx_errno,\n                      ngx_open_dir_n \" \\\"%s\\\" failed\", tree->data);\n        return NGX_ERROR;\n    }\n\n    prev = ctx->data;\n\n    if (ctx->alloc) {\n        data = ngx_alloc(ctx->alloc, ctx->log);\n        if (data == NULL) {\n            goto failed;\n        }\n\n        if (ctx->init_handler(data, prev) == NGX_ABORT) {\n            goto failed;\n        }\n\n        ctx->data = data;\n\n    } else {\n        data = NULL;\n    }\n\n    for ( ;; ) {\n\n        ngx_set_errno(0);\n\n        if (ngx_read_dir(&dir) == NGX_ERROR) {\n            err = ngx_errno;\n\n            if (err == NGX_ENOMOREFILES) {\n                rc = NGX_OK;\n\n            } else {\n                ngx_log_error(NGX_LOG_CRIT, ctx->log, err,\n                              ngx_read_dir_n \" \\\"%s\\\" failed\", tree->data);\n                rc = NGX_ERROR;\n            }\n\n            goto done;\n        }\n\n        len = ngx_de_namelen(&dir);\n        name = ngx_de_name(&dir);\n\n        ngx_log_debug2(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                      \"tree name %uz:\\\"%s\\\"\", len, name);\n\n        if (len == 1 && name[0] == '.') {\n            continue;\n        }\n\n        if (len == 2 && name[0] == '.' && name[1] == '.') {\n            continue;\n        }\n\n        file.len = tree->len + 1 + len;\n\n        if (file.len + NGX_DIR_MASK_LEN > buf.len) {\n\n            if (buf.len) {\n                ngx_free(buf.data);\n            }\n\n            buf.len = tree->len + 1 + len + NGX_DIR_MASK_LEN;\n\n            buf.data = ngx_alloc(buf.len + 1, ctx->log);\n            if (buf.data == NULL) {\n                goto failed;\n            }\n        }\n\n        p = ngx_cpymem(buf.data, tree->data, tree->len);\n        *p++ = '/';\n        ngx_memcpy(p, name, len + 1);\n\n        file.data = buf.data;\n\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                       \"tree path \\\"%s\\\"\", file.data);\n\n        if (!dir.valid_info) {\n            if (ngx_de_info(file.data, &dir) == NGX_FILE_ERROR) {\n                ngx_log_error(NGX_LOG_CRIT, ctx->log, ngx_errno,\n                              ngx_de_info_n \" \\\"%s\\\" failed\", file.data);\n                continue;\n            }\n        }\n\n        if (ngx_de_is_file(&dir)) {\n\n            ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                           \"tree file \\\"%s\\\"\", file.data);\n\n            ctx->size = ngx_de_size(&dir);\n            ctx->fs_size = ngx_de_fs_size(&dir);\n            ctx->access = ngx_de_access(&dir);\n            ctx->mtime = ngx_de_mtime(&dir);\n\n            if (ctx->file_handler(ctx, &file) == NGX_ABORT) {\n                goto failed;\n            }\n\n        } else if (ngx_de_is_dir(&dir)) {\n\n            ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                           \"tree enter dir \\\"%s\\\"\", file.data);\n\n            ctx->access = ngx_de_access(&dir);\n            ctx->mtime = ngx_de_mtime(&dir);\n\n            rc = ctx->pre_tree_handler(ctx, &file);\n\n            if (rc == NGX_ABORT) {\n                goto failed;\n            }\n\n            if (rc == NGX_DECLINED) {\n                ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                               \"tree skip dir \\\"%s\\\"\", file.data);\n                continue;\n            }\n\n            if (ngx_walk_tree(ctx, &file) == NGX_ABORT) {\n                goto failed;\n            }\n\n            ctx->access = ngx_de_access(&dir);\n            ctx->mtime = ngx_de_mtime(&dir);\n\n            if (ctx->post_tree_handler(ctx, &file) == NGX_ABORT) {\n                goto failed;\n            }\n\n        } else {\n\n            ngx_log_debug1(NGX_LOG_DEBUG_CORE, ctx->log, 0,\n                           \"tree special \\\"%s\\\"\", file.data);\n\n            if (ctx->spec_handler(ctx, &file) == NGX_ABORT) {\n                goto failed;\n            }\n        }\n    }\n\nfailed:\n\n    rc = NGX_ABORT;\n\ndone:\n\n    if (buf.len) {\n        ngx_free(buf.data);\n    }\n\n    if (data) {\n        ngx_free(data);\n        ctx->data = prev;\n    }\n\n    if (ngx_close_dir(&dir) == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_CRIT, ctx->log, ngx_errno,\n                      ngx_close_dir_n \" \\\"%s\\\" failed\", tree->data);\n    }\n\n    return rc;\n}", "target": 1}
{"idx": 4715, "func": "static int wav_parse_fmt_tag(AVFormatContext *s, int64_t size, AVStream **st)\n{\n    AVIOContext *pb = s->pb;\n    int ret;\n\n    /* parse fmt header */\n    *st = av_new_stream(s, 0);\n    if (!*st)\n        return AVERROR(ENOMEM);\n\n    ret = ff_get_wav_header(pb, (*st)->codec, size);\n    if (ret < 0)\n        return ret;\n    (*st)->need_parsing = AVSTREAM_PARSE_FULL;\n\n    av_set_pts_info(*st, 64, 1, (*st)->codec->sample_rate);\n\n    return 0;\n}", "target": 0}
{"idx": 4716, "func": "static int cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,\n                                   int chunk_id, int size, const uint8_t *data)\n{\n    const uint8_t   *eod = (data + size);\n    uint32_t         flag, mask;\n    uint8_t         *cb0, *cb1, *cb2, *cb3;\n    unsigned int     x, y;\n    char            *ip0, *ip1, *ip2, *ip3;\n\n    flag = 0;\n    mask = 0;\n\n    for (y=strip->y1; y < strip->y2; y+=4) {\n\n/* take care of y dimension not being multiple of 4, such streams exist */\n        ip0 = ip1 = ip2 = ip3 = s->frame->data[0] +\n          (s->palette_video?strip->x1:strip->x1*3) + (y * s->frame->linesize[0]);\n        if(s->avctx->height - y > 1) {\n            ip1 = ip0 + s->frame->linesize[0];\n            if(s->avctx->height - y > 2) {\n                ip2 = ip1 + s->frame->linesize[0];\n                if(s->avctx->height - y > 3) {\n                    ip3 = ip2 + s->frame->linesize[0];\n                }\n            }\n        }\n/* to get the correct picture for not-multiple-of-4 cases let us fill\n * each block from the bottom up, thus possibly overwriting the top line\n * more than once but ending with the correct data in place\n * (instead of in-loop checking) */\n\n        for (x=strip->x1; x < strip->x2; x+=4) {\n            if ((chunk_id & 0x01) && !(mask >>= 1)) {\n                if ((data + 4) > eod)\n                    return AVERROR_INVALIDDATA;\n\n                flag  = AV_RB32 (data);\n                data += 4;\n                mask  = 0x80000000;\n            }\n\n            if (!(chunk_id & 0x01) || (flag & mask)) {\n                if (!(chunk_id & 0x02) && !(mask >>= 1)) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    flag  = AV_RB32 (data);\n                    data += 4;\n                    mask  = 0x80000000;\n                }\n\n                if ((chunk_id & 0x02) || (~flag & mask)) {\n                    uint8_t *p;\n                    if (data >= eod)\n                        return AVERROR_INVALIDDATA;\n\n                    p = strip->v1_codebook[*data++];\n                    if (s->palette_video) {\n                        ip3[0] = ip3[1] = ip2[0] = ip2[1] = p[6];\n                        ip3[2] = ip3[3] = ip2[2] = ip2[3] = p[9];\n                        ip1[0] = ip1[1] = ip0[0] = ip0[1] = p[0];\n                        ip1[2] = ip1[3] = ip0[2] = ip0[3] = p[3];\n                    } else {\n                        p += 6;\n                        memcpy(ip3 + 0, p, 3); memcpy(ip3 + 3, p, 3);\n                        memcpy(ip2 + 0, p, 3); memcpy(ip2 + 3, p, 3);\n                        p += 3; /* ... + 9 */\n                        memcpy(ip3 + 6, p, 3); memcpy(ip3 + 9, p, 3);\n                        memcpy(ip2 + 6, p, 3); memcpy(ip2 + 9, p, 3);\n                        p -= 9; /* ... + 0 */\n                        memcpy(ip1 + 0, p, 3); memcpy(ip1 + 3, p, 3);\n                        memcpy(ip0 + 0, p, 3); memcpy(ip0 + 3, p, 3);\n                        p += 3; /* ... + 3 */\n                        memcpy(ip1 + 6, p, 3); memcpy(ip1 + 9, p, 3);\n                        memcpy(ip0 + 6, p, 3); memcpy(ip0 + 9, p, 3);\n                    }\n\n                } else if (flag & mask) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    cb0 = strip->v4_codebook[*data++];\n                    cb1 = strip->v4_codebook[*data++];\n                    cb2 = strip->v4_codebook[*data++];\n                    cb3 = strip->v4_codebook[*data++];\n                    if (s->palette_video) {\n                        uint8_t *p;\n                        p = ip3;\n                        *p++ = cb2[6];\n                        *p++ = cb2[9];\n                        *p++ = cb3[6];\n                        *p   = cb3[9];\n                        p = ip2;\n                        *p++ = cb2[0];\n                        *p++ = cb2[3];\n                        *p++ = cb3[0];\n                        *p   = cb3[3];\n                        p = ip1;\n                        *p++ = cb0[6];\n                        *p++ = cb0[9];\n                        *p++ = cb1[6];\n                        *p   = cb1[9];\n                        p = ip0;\n                        *p++ = cb0[0];\n                        *p++ = cb0[3];\n                        *p++ = cb1[0];\n                        *p   = cb1[3];\n                    } else {\n                        memcpy(ip3 + 0, cb2 + 6, 6);\n                        memcpy(ip3 + 6, cb3 + 6, 6);\n                        memcpy(ip2 + 0, cb2 + 0, 6);\n                        memcpy(ip2 + 6, cb3 + 0, 6);\n                        memcpy(ip1 + 0, cb0 + 6, 6);\n                        memcpy(ip1 + 6, cb1 + 6, 6);\n                        memcpy(ip0 + 0, cb0 + 0, 6);\n                        memcpy(ip0 + 6, cb1 + 0, 6);\n                    }\n\n                }\n            }\n\n            if (s->palette_video) {\n                ip0 += 4;  ip1 += 4;\n                ip2 += 4;  ip3 += 4;\n            } else {\n                ip0 += 12;  ip1 += 12;\n                ip2 += 12;  ip3 += 12;\n            }\n        }\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 4717, "func": "int ff_lock_avcodec(AVCodecContext *log_ctx)\n{\n    if (ff_lockmgr_cb) {\n        if ((*ff_lockmgr_cb)(&codec_mutex, AV_LOCK_OBTAIN))\n            return -1;\n    }\n    entangled_thread_counter++;\n    if (entangled_thread_counter != 1) {\n        av_log(log_ctx, AV_LOG_ERROR, \"Insufficient thread locking around avcodec_open/close()\\n\");\n        return AVERROR(EINVAL);\n    }\n    av_assert0(!ff_avcodec_locked);\n    ff_avcodec_locked = 1;\n    return 0;\n}", "target": 1}
{"idx": 4718, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx,\n                                 const uint8_t *buf, int buf_size)\n{\n    Mpeg1Context *s1  = avctx->priv_data;\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n    int width, height;\n    int i, v, j;\n\n    init_get_bits(&s->gb, buf, buf_size * 8);\n\n    width  = get_bits(&s->gb, 12);\n    height = get_bits(&s->gb, 12);\n    if (width == 0 || height == 0) {\n        av_log(avctx, AV_LOG_WARNING,\n               \"Invalid horizontal or vertical size value.\\n\");\n        if (avctx->err_recognition & (AV_EF_BITSTREAM | AV_EF_COMPLIANT))\n            return AVERROR_INVALIDDATA;\n    }\n    s->aspect_ratio_info = get_bits(&s->gb, 4);\n    if (s->aspect_ratio_info == 0) {\n        av_log(avctx, AV_LOG_ERROR, \"aspect ratio has forbidden 0 value\\n\");\n        if (avctx->err_recognition & (AV_EF_BITSTREAM | AV_EF_COMPLIANT))\n            return AVERROR_INVALIDDATA;\n    }\n    s->frame_rate_index = get_bits(&s->gb, 4);\n    if (s->frame_rate_index == 0 || s->frame_rate_index > 13) {\n        av_log(avctx, AV_LOG_WARNING,\n               \"frame_rate_index %d is invalid\\n\", s->frame_rate_index);\n        s->frame_rate_index = 1;\n    }\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n    if (check_marker(&s->gb, \"in sequence header\") == 0) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->avctx->rc_buffer_size = get_bits(&s->gb, 10) * 1024 * 16;\n    skip_bits(&s->gb, 1);\n\n    /* get matrix */\n    if (get_bits1(&s->gb)) {\n        load_matrix(s, s->chroma_intra_matrix, s->intra_matrix, 1);\n    } else {\n        for (i = 0; i < 64; i++) {\n            j = s->idsp.idct_permutation[i];\n            v = ff_mpeg1_default_intra_matrix[i];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(&s->gb)) {\n        load_matrix(s, s->chroma_inter_matrix, s->inter_matrix, 0);\n    } else {\n        for (i = 0; i < 64; i++) {\n            int j = s->idsp.idct_permutation[i];\n            v = ff_mpeg1_default_non_intra_matrix[i];\n            s->inter_matrix[j]        = v;\n            s->chroma_inter_matrix[j] = v;\n        }\n    }\n\n    if (show_bits(&s->gb, 23) != 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"sequence header damaged\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->width  = width;\n    s->height = height;\n\n    /* We set MPEG-2 parameters so that it emulates MPEG-1. */\n    s->progressive_sequence = 1;\n    s->progressive_frame    = 1;\n    s->picture_structure    = PICT_FRAME;\n    s->first_field          = 0;\n    s->frame_pred_frame_dct = 1;\n    s->chroma_format        = 1;\n    s->codec_id             =\n    s->avctx->codec_id      = AV_CODEC_ID_MPEG1VIDEO;\n    s->out_format           = FMT_MPEG1;\n    s->swap_uv              = 0; // AFAIK VCR2 does not have SEQ_HEADER\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(s->avctx, AV_LOG_DEBUG, \"vbv buffer: %d, bitrate:%\"PRId64\", aspect_ratio_info: %d \\n\",\n               s->avctx->rc_buffer_size, s->bit_rate, s->aspect_ratio_info);\n\n    return 0;\n}", "target": 1}
{"idx": 4719, "func": "SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth)\n{\n    SSL_CTX *ret = NULL;\n\n    if (meth == NULL) {\n        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_NULL_SSL_METHOD_PASSED);\n        return NULL;\n    }\n\n    if (!OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS, NULL))\n        return NULL;\n\n    if (SSL_get_ex_data_X509_STORE_CTX_idx() < 0) {\n        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_X509_VERIFICATION_SETUP_PROBLEMS);\n        goto err;\n    }\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL)\n        goto err;\n\n    ret->method = meth;\n    ret->min_proto_version = 0;\n    ret->max_proto_version = 0;\n    ret->mode = SSL_MODE_AUTO_RETRY;\n    ret->session_cache_mode = SSL_SESS_CACHE_SERVER;\n    ret->session_cache_size = SSL_SESSION_CACHE_MAX_SIZE_DEFAULT;\n    /* We take the system default. */\n    ret->session_timeout = meth->get_timeout();\n    ret->references = 1;\n    ret->lock = CRYPTO_THREAD_lock_new();\n    if (ret->lock == NULL) {\n        SSLerr(SSL_F_SSL_CTX_NEW, ERR_R_MALLOC_FAILURE);\n        OPENSSL_free(ret);\n        return NULL;\n    }\n    ret->max_cert_list = SSL_MAX_CERT_LIST_DEFAULT;\n    ret->verify_mode = SSL_VERIFY_NONE;\n    if ((ret->cert = ssl_cert_new()) == NULL)\n        goto err;\n\n    ret->sessions = lh_SSL_SESSION_new(ssl_session_hash, ssl_session_cmp);\n    if (ret->sessions == NULL)\n        goto err;\n    ret->cert_store = X509_STORE_new();\n    if (ret->cert_store == NULL)\n        goto err;\n#ifndef OPENSSL_NO_CT\n    ret->ctlog_store = CTLOG_STORE_new();\n    if (ret->ctlog_store == NULL)\n        goto err;\n#endif\n\n    if (!SSL_CTX_set_ciphersuites(ret, TLS_DEFAULT_CIPHERSUITES))\n        goto err;\n\n    if (!ssl_create_cipher_list(ret->method,\n                                ret->tls13_ciphersuites,\n                                &ret->cipher_list, &ret->cipher_list_by_id,\n                                SSL_DEFAULT_CIPHER_LIST, ret->cert)\n        || sk_SSL_CIPHER_num(ret->cipher_list) <= 0) {\n        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_LIBRARY_HAS_NO_CIPHERS);\n        goto err2;\n    }\n\n    ret->param = X509_VERIFY_PARAM_new();\n    if (ret->param == NULL)\n        goto err;\n\n    if ((ret->md5 = EVP_get_digestbyname(\"ssl3-md5\")) == NULL) {\n        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES);\n        goto err2;\n    }\n    if ((ret->sha1 = EVP_get_digestbyname(\"ssl3-sha1\")) == NULL) {\n        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES);\n        goto err2;\n    }\n\n    if ((ret->ca_names = sk_X509_NAME_new_null()) == NULL)\n        goto err;\n\n    if ((ret->client_ca_names = sk_X509_NAME_new_null()) == NULL)\n        goto err;\n\n    if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_CTX, ret, &ret->ex_data))\n        goto err;\n\n    if ((ret->ext.secure = OPENSSL_secure_zalloc(sizeof(*ret->ext.secure))) == NULL)\n        goto err;\n\n    /* No compression for DTLS */\n    if (!(meth->ssl3_enc->enc_flags & SSL_ENC_FLAG_DTLS))\n        ret->comp_methods = SSL_COMP_get_compression_methods();\n\n    ret->max_send_fragment = SSL3_RT_MAX_PLAIN_LENGTH;\n    ret->split_send_fragment = SSL3_RT_MAX_PLAIN_LENGTH;\n\n    /* Setup RFC5077 ticket keys */\n    if ((RAND_bytes(ret->ext.tick_key_name,\n                    sizeof(ret->ext.tick_key_name)) <= 0)\n        || (RAND_priv_bytes(ret->ext.secure->tick_hmac_key,\n                       sizeof(ret->ext.secure->tick_hmac_key)) <= 0)\n        || (RAND_priv_bytes(ret->ext.secure->tick_aes_key,\n                       sizeof(ret->ext.secure->tick_aes_key)) <= 0))\n        ret->options |= SSL_OP_NO_TICKET;\n\n    if (RAND_priv_bytes(ret->ext.cookie_hmac_key,\n                   sizeof(ret->ext.cookie_hmac_key)) <= 0)\n        goto err;\n\n#ifndef OPENSSL_NO_SRP\n    if (!SSL_CTX_SRP_CTX_init(ret))\n        goto err;\n#endif\n#ifndef OPENSSL_NO_ENGINE\n# ifdef OPENSSL_SSL_CLIENT_ENGINE_AUTO\n#  define eng_strx(x)     #x\n#  define eng_str(x)      eng_strx(x)\n    /* Use specific client engine automatically... ignore errors */\n    {\n        ENGINE *eng;\n        eng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));\n        if (!eng) {\n            ERR_clear_error();\n            ENGINE_load_builtin_engines();\n            eng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));\n        }\n        if (!eng || !SSL_CTX_set_client_cert_engine(ret, eng))\n            ERR_clear_error();\n    }\n# endif\n#endif\n    /*\n     * Default is to connect to non-RI servers. When RI is more widely\n     * deployed might change this.\n     */\n    ret->options |= SSL_OP_LEGACY_SERVER_CONNECT;\n    /*\n     * Disable compression by default to prevent CRIME. Applications can\n     * re-enable compression by configuring\n     * SSL_CTX_clear_options(ctx, SSL_OP_NO_COMPRESSION);\n     * or by using the SSL_CONF library. Similarly we also enable TLSv1.3\n     * middlebox compatibility by default. This may be disabled by default in\n     * a later OpenSSL version.\n     */\n    ret->options |= SSL_OP_NO_COMPRESSION | SSL_OP_ENABLE_MIDDLEBOX_COMPAT;\n\n    ret->ext.status_type = TLSEXT_STATUSTYPE_nothing;\n\n    /*\n     * We cannot usefully set a default max_early_data here (which gets\n     * propagated in SSL_new(), for the following reason: setting the\n     * SSL field causes tls_construct_stoc_early_data() to tell the\n     * client that early data will be accepted when constructing a TLS 1.3\n     * session ticket, and the client will accordingly send us early data\n     * when using that ticket (if the client has early data to send).\n     * However, in order for the early data to actually be consumed by\n     * the application, the application must also have calls to\n     * SSL_read_early_data(); otherwise we'll just skip past the early data\n     * and ignore it.  So, since the application must add calls to\n     * SSL_read_early_data(), we also require them to add\n     * calls to SSL_CTX_set_max_early_data() in order to use early data,\n     * eliminating the bandwidth-wasting early data in the case described\n     * above.\n     */\n    ret->max_early_data = 0;\n\n    /*\n     * Default recv_max_early_data is a fully loaded single record. Could be\n     * split across multiple records in practice. We set this differently to\n     * max_early_data so that, in the default case, we do not advertise any\n     * support for early_data, but if a client were to send us some (e.g.\n     * because of an old, stale ticket) then we will tolerate it and skip over\n     * it.\n     */\n    ret->recv_max_early_data = SSL3_RT_MAX_PLAIN_LENGTH;\n\n    /* By default we send two session tickets automatically in TLSv1.3 */\n    ret->num_tickets = 2;\n\n    ssl_ctx_system_config(ret);\n\n    return ret;\n err:\n    SSLerr(SSL_F_SSL_CTX_NEW, ERR_R_MALLOC_FAILURE);\n err2:\n    SSL_CTX_free(ret);\n    return NULL;\n}", "target": 0}
{"idx": 4720, "func": "AP_DECLARE(const char *) ap_scan_http_field_content(const char *ptr)\n{\n    for ( ; !TEST_CHAR(*ptr, T_HTTP_CTRLS); ++ptr) ;\n\n    return ptr;\n}", "target": 1}
{"idx": 4721, "func": "static av_always_inline void prefetch_motion(H264Context *h, int list,\n                                             int pixel_shift, int chroma_idc)\n{\n    /* fetch pixels for estimated mv 4 macroblocks ahead\n     * optimized for 64byte cache lines */\n    const int refn = h->ref_cache[list][scan8[0]];\n    if (refn >= 0) {\n        const int mx  = (h->mv_cache[list][scan8[0]][0] >> 2) + 16 * h->mb_x + 8;\n        const int my  = (h->mv_cache[list][scan8[0]][1] >> 2) + 16 * h->mb_y;\n        uint8_t **src = h->ref_list[list][refn].f.data;\n        int off       = (mx << pixel_shift) +\n                        (my + (h->mb_x & 3) * 4) * h->mb_linesize +\n                        (64 << pixel_shift);\n        h->vdsp.prefetch(src[0] + off, h->linesize, 4);\n        if (chroma_idc == 3 /* yuv444 */) {\n            h->vdsp.prefetch(src[1] + off, h->linesize, 4);\n            h->vdsp.prefetch(src[2] + off, h->linesize, 4);\n        } else {\n            off= (((mx>>1)+64)<<pixel_shift) + ((my>>1) + (h->mb_x&7))*h->uvlinesize;\n            h->vdsp.prefetch(src[1] + off, src[2] - src[1], 2);\n        }\n    }\n}", "target": 1}
{"idx": 4722, "func": "static inline void decode_subblock3(DCTELEM *dst, int code, const int is_block2, GetBitContext *gb, VLC *vlc,\n                                    int q_dc, int q_ac1, int q_ac2)\n{\n    int coeffs[4];\n\n    coeffs[0] = modulo_three_table[code][0];\n    coeffs[1] = modulo_three_table[code][1];\n    coeffs[2] = modulo_three_table[code][2];\n    coeffs[3] = modulo_three_table[code][3];\n    decode_coeff(dst  , coeffs[0], 3, gb, vlc, q_dc);\n    if(is_block2){\n        decode_coeff(dst+8, coeffs[1], 2, gb, vlc, q_ac1);\n        decode_coeff(dst+1, coeffs[2], 2, gb, vlc, q_ac1);\n    }else{\n        decode_coeff(dst+1, coeffs[1], 2, gb, vlc, q_ac1);\n        decode_coeff(dst+8, coeffs[2], 2, gb, vlc, q_ac1);\n    }\n    decode_coeff(dst+9, coeffs[3], 2, gb, vlc, q_ac2);\n}", "target": 1}
{"idx": 4723, "func": "int av_set_string3(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out)\n{\n    int ret;\n    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n    if (o_out)\n        *o_out = o;\n    if (!o)\n        return AVERROR_OPTION_NOT_FOUND;\n    if ((!val && o->type != FF_OPT_TYPE_STRING) || o->offset<=0)\n        return AVERROR(EINVAL);\n\n    if (o->type == FF_OPT_TYPE_BINARY) {\n        uint8_t **dst = (uint8_t **)(((uint8_t*)obj) + o->offset);\n        int *lendst = (int *)(dst + 1);\n        uint8_t *bin, *ptr;\n        int len = strlen(val);\n        av_freep(dst);\n        *lendst = 0;\n        if (len & 1) return AVERROR(EINVAL);\n        len /= 2;\n        ptr = bin = av_malloc(len);\n        while (*val) {\n            int a = hexchar2int(*val++);\n            int b = hexchar2int(*val++);\n            if (a < 0 || b < 0) {\n                av_free(bin);\n                return AVERROR(EINVAL);\n            }\n            *ptr++ = (a << 4) | b;\n        }\n        *dst = bin;\n        *lendst = len;\n        return 0;\n    }\n    if (o->type != FF_OPT_TYPE_STRING) {\n        int notfirst=0;\n        for (;;) {\n            int i;\n            char buf[256];\n            int cmd=0;\n            double d;\n\n            if (*val == '+' || *val == '-')\n                cmd= *(val++);\n\n            for (i=0; i<sizeof(buf)-1 && val[i] && val[i]!='+' && val[i]!='-'; i++)\n                buf[i]= val[i];\n            buf[i]=0;\n\n            {\n                const AVOption *o_named = av_opt_find(obj, buf, o->unit, 0, 0);\n                if (o_named && o_named->type == FF_OPT_TYPE_CONST)\n                    d= o_named->default_val.dbl;\n                else if (!strcmp(buf, \"default\")) d= o->default_val.dbl;\n                else if (!strcmp(buf, \"max\"    )) d= o->max;\n                else if (!strcmp(buf, \"min\"    )) d= o->min;\n                else if (!strcmp(buf, \"none\"   )) d= 0;\n                else if (!strcmp(buf, \"all\"    )) d= ~0;\n                else {\n                    int res = av_expr_parse_and_eval(&d, buf, const_names, const_values, NULL, NULL, NULL, NULL, NULL, 0, obj);\n                    if (res < 0) {\n                        av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\"\\n\", val);\n                        return res;\n                    }\n                }\n            }\n            if (o->type == FF_OPT_TYPE_FLAGS) {\n                if      (cmd=='+') d= av_get_int(obj, name, NULL) | (int64_t)d;\n                else if (cmd=='-') d= av_get_int(obj, name, NULL) &~(int64_t)d;\n            } else {\n                if      (cmd=='+') d= notfirst*av_get_double(obj, name, NULL) + d;\n                else if (cmd=='-') d= notfirst*av_get_double(obj, name, NULL) - d;\n            }\n\n            if ((ret = av_set_number2(obj, name, d, 1, 1, o_out)) < 0)\n                return ret;\n            val+= i;\n            if (!*val)\n                return 0;\n            notfirst=1;\n        }\n    }\n\n    if (alloc) {\n        av_free(*(void**)(((uint8_t*)obj) + o->offset));\n        val= av_strdup(val);\n    }\n\n    memcpy(((uint8_t*)obj) + o->offset, &val, sizeof(val));\n    return 0;\n}", "target": 1}
{"idx": 4724, "func": "static av_always_inline void\nyuv2rgb_full_X_c_template(SwsContext *c, const int16_t *lumFilter,\n                          const int16_t **lumSrc, int lumFilterSize,\n                          const int16_t *chrFilter, const int16_t **chrUSrc,\n                          const int16_t **chrVSrc, int chrFilterSize,\n                          const int16_t **alpSrc, uint8_t *dest,\n                          int dstW, int y, enum AVPixelFormat target, int hasAlpha)\n{\n    int i;\n    int step = (target == AV_PIX_FMT_RGB24 || target == AV_PIX_FMT_BGR24) ? 3 : 4;\n    int err[4] = {0};\n\n    if(   target == AV_PIX_FMT_BGR4_BYTE || target == AV_PIX_FMT_RGB4_BYTE\n       || target == AV_PIX_FMT_BGR8      || target == AV_PIX_FMT_RGB8)\n        step = 1;\n\n    for (i = 0; i < dstW; i++) {\n        int j;\n        int Y = 1<<9;\n        int U = (1<<9)-(128 << 19);\n        int V = (1<<9)-(128 << 19);\n        int A;\n\n        for (j = 0; j < lumFilterSize; j++) {\n            Y += lumSrc[j][i] * lumFilter[j];\n        }\n        for (j = 0; j < chrFilterSize; j++) {\n            U += chrUSrc[j][i] * chrFilter[j];\n            V += chrVSrc[j][i] * chrFilter[j];\n        }\n        Y >>= 10;\n        U >>= 10;\n        V >>= 10;\n        if (hasAlpha) {\n            A = 1 << 18;\n            for (j = 0; j < lumFilterSize; j++) {\n                A += alpSrc[j][i] * lumFilter[j];\n            }\n            A >>= 19;\n            if (A & 0x100)\n                A = av_clip_uint8(A);\n        }\n        yuv2rgb_write_full(c, dest, i, Y, A, U, V, y, target, hasAlpha, err);\n        dest += step;\n    }\n    c->dither_error[0][i] = err[0];\n    c->dither_error[1][i] = err[1];\n    c->dither_error[2][i] = err[2];\n}", "target": 1}
{"idx": 4725, "func": "static int dnxhd_mb_var_thread(AVCodecContext *avctx, void *arg, int jobnr, int threadnr)\n{\n    DNXHDEncContext *ctx = avctx->priv_data;\n    int mb_y = jobnr, mb_x;\n    ctx = ctx->thread[threadnr];\n    if (ctx->cid_table->bit_depth == 8) {\n        uint8_t *pix = ctx->thread[0]->src[0] + ((mb_y<<4) * ctx->m.linesize);\n        for (mb_x = 0; mb_x < ctx->m.mb_width; ++mb_x, pix += 16) {\n            unsigned mb  = mb_y * ctx->m.mb_width + mb_x;\n            int sum = ctx->m.dsp.pix_sum(pix, ctx->m.linesize);\n            int varc = (ctx->m.dsp.pix_norm1(pix, ctx->m.linesize) - (((unsigned)sum*sum)>>8)+128)>>8;\n            ctx->mb_cmp[mb].value = varc;\n            ctx->mb_cmp[mb].mb = mb;\n        }\n    } else { // 10-bit\n        int const linesize = ctx->m.linesize >> 1;\n        for (mb_x = 0; mb_x < ctx->m.mb_width; ++mb_x) {\n            uint16_t *pix = (uint16_t*)ctx->thread[0]->src[0] + ((mb_y << 4) * linesize) + (mb_x << 4);\n            unsigned mb  = mb_y * ctx->m.mb_width + mb_x;\n            int sum = 0;\n            int sqsum = 0;\n            int mean, sqmean;\n            int i, j;\n            // Macroblocks are 16x16 pixels, unlike DCT blocks which are 8x8.\n            for (i = 0; i < 16; ++i) {\n                for (j = 0; j < 16; ++j) {\n                    // Turn 16-bit pixels into 10-bit ones.\n                    int const sample = (unsigned)pix[j] >> 6;\n                    sum += sample;\n                    sqsum += sample * sample;\n                    // 2^10 * 2^10 * 16 * 16 = 2^28, which is less than INT_MAX\n                }\n                pix += linesize;\n            }\n            mean = sum >> 8; // 16*16 == 2^8\n            sqmean = sqsum >> 8;\n            ctx->mb_cmp[mb].value = sqmean - mean * mean;\n            ctx->mb_cmp[mb].mb = mb;\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": 4726, "func": "static void filter_unblock(AVFilterContext *filter)\n{\n    unsigned i;\n\n    for (i = 0; i < filter->nb_outputs; i++)\n        filter->outputs[i]->frame_blocked_in = 0;\n}", "target": 1}
{"idx": 4727, "func": "static ngx_int_t\nngx_http_variable_realpath_root(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    u_char                    *real;\n    size_t                     len;\n    ngx_str_t                  path;\n    ngx_http_core_loc_conf_t  *clcf;\n#if (NGX_HAVE_MAX_PATH)\n    u_char                     buffer[NGX_MAX_PATH];\n#endif\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf->root_lengths == NULL) {\n        path = clcf->root;\n\n    } else {\n        if (ngx_http_script_run(r, &path, clcf->root_lengths->elts, 1,\n                                clcf->root_values->elts)\n            == NULL)\n        {\n            return NGX_ERROR;\n        }\n\n        path.data[path.len - 1] = '\\0';\n\n        if (ngx_conf_full_name((ngx_cycle_t *) ngx_cycle, &path, 0) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    }\n\n#if (NGX_HAVE_MAX_PATH)\n    real = buffer;\n#else\n    real = NULL;\n#endif\n\n    real = ngx_realpath(path.data, real);\n\n    if (real == NULL) {\n        ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,\n                      ngx_realpath_n \" \\\"%s\\\" failed\", path.data);\n        return NGX_ERROR;\n    }\n\n    len = ngx_strlen(real);\n\n    v->data = ngx_pnalloc(r->pool, len);\n    if (v->data == NULL) {\n#if !(NGX_HAVE_MAX_PATH)\n        ngx_free(real);\n#endif\n        return NGX_ERROR;\n    }\n\n    v->len = len;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    ngx_memcpy(v->data, real, len);\n\n#if !(NGX_HAVE_MAX_PATH)\n    ngx_free(real);\n#endif\n\n    return NGX_OK;\n}", "target": 0}
{"idx": 4728, "func": "int ffv1_init_slice_contexts(FFV1Context *f)\n{\n    int i;\n\n    f->slice_count = f->num_h_slices * f->num_v_slices;\n    if (f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    for (i = 0; i < f->slice_count; i++) {\n        FFV1Context *fs = av_mallocz(sizeof(*fs));\n        int sx          = i % f->num_h_slices;\n        int sy          = i / f->num_h_slices;\n        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n        int sys         = f->avctx->height *  sy      / f->num_v_slices;\n        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n        f->slice_context[i] = fs;\n        memcpy(fs, f, sizeof(*fs));\n        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n\n        fs->slice_width  = sxe - sxs;\n        fs->slice_height = sye - sys;\n        fs->slice_x      = sxs;\n        fs->slice_y      = sys;\n\n        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *\n                                      sizeof(*fs->sample_buffer));\n        if (!fs->sample_buffer)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"idx": 4729, "func": "static int allocate_buffers(ALACContext *alac)\n{\n    int ch;\n    int buf_size;\n\n    if (alac->max_samples_per_frame > INT_MAX / sizeof(int32_t))\n        goto buf_alloc_fail;\n    buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n                         buf_size, buf_alloc_fail);\n\n        alac->direct_output = alac->sample_size > 16 && av_sample_fmt_is_planar(alac->avctx->sample_fmt);\n        if (!alac->direct_output) {\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n                             buf_size, buf_alloc_fail);\n        }\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n                         buf_size, buf_alloc_fail);\n    }\n    return 0;\nbuf_alloc_fail:\n    alac_decode_close(alac->avctx);\n    return AVERROR(ENOMEM);\n}", "target": 0}
{"idx": 4730, "func": "static void do_streamcopy(InputStream *ist, OutputStream *ost, const AVPacket *pkt)\n{\n    OutputFile *of = output_files[ost->file_index];\n    InputFile   *f = input_files [ist->file_index];\n    int64_t start_time = (of->start_time == AV_NOPTS_VALUE) ? 0 : of->start_time;\n    int64_t ost_tb_start_time = av_rescale_q(start_time, AV_TIME_BASE_Q, ost->st->time_base);\n    AVPicture pict;\n    AVPacket opkt;\n\n    av_init_packet(&opkt);\n\n    if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) &&\n        !ost->copy_initial_nonkeyframes)\n        return;\n\n    if (!ost->frame_number && !ost->copy_prior_start) {\n        int64_t comp_start = start_time;\n        if (copy_ts && f->start_time != AV_NOPTS_VALUE)\n            comp_start = FFMAX(start_time, f->start_time + f->ts_offset);\n        if (pkt->pts == AV_NOPTS_VALUE ?\n            ist->pts < comp_start :\n            pkt->pts < av_rescale_q(comp_start, AV_TIME_BASE_Q, ist->st->time_base))\n            return;\n    }\n\n    if (of->recording_time != INT64_MAX &&\n        ist->pts >= of->recording_time + start_time) {\n        close_output_stream(ost);\n        return;\n    }\n\n    if (f->recording_time != INT64_MAX) {\n        start_time = f->ctx->start_time;\n        if (f->start_time != AV_NOPTS_VALUE && copy_ts)\n            start_time += f->start_time;\n        if (ist->pts >= f->recording_time + start_time) {\n            close_output_stream(ost);\n            return;\n        }\n    }\n\n    /* force the input stream PTS */\n    if (ost->enc_ctx->codec_type == AVMEDIA_TYPE_VIDEO)\n        ost->sync_opts++;\n\n    if (pkt->pts != AV_NOPTS_VALUE)\n        opkt.pts = av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time;\n    else\n        opkt.pts = AV_NOPTS_VALUE;\n\n    if (pkt->dts == AV_NOPTS_VALUE)\n        opkt.dts = av_rescale_q(ist->dts, AV_TIME_BASE_Q, ost->st->time_base);\n    else\n        opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base);\n    opkt.dts -= ost_tb_start_time;\n\n    if (ost->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) {\n        int duration = av_get_audio_frame_duration(ist->dec_ctx, pkt->size);\n        if(!duration)\n            duration = ist->dec_ctx->frame_size;\n        opkt.dts = opkt.pts = av_rescale_delta(ist->st->time_base, pkt->dts,\n                                               (AVRational){1, ist->dec_ctx->sample_rate}, duration, &ist->filter_in_rescale_delta_last,\n                                               ost->st->time_base) - ost_tb_start_time;\n    }\n\n    opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base);\n    opkt.flags    = pkt->flags;\n    // FIXME remove the following 2 lines they shall be replaced by the bitstream filters\n    if (  ost->st->codecpar->codec_id != AV_CODEC_ID_H264\n       && ost->st->codecpar->codec_id != AV_CODEC_ID_MPEG1VIDEO\n       && ost->st->codecpar->codec_id != AV_CODEC_ID_MPEG2VIDEO\n       && ost->st->codecpar->codec_id != AV_CODEC_ID_VC1\n       ) {\n        int ret = av_parser_change(ost->parser, ost->st->codec,\n                             &opkt.data, &opkt.size,\n                             pkt->data, pkt->size,\n                             pkt->flags & AV_PKT_FLAG_KEY);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_FATAL, \"av_parser_change failed: %s\\n\",\n                   av_err2str(ret));\n            exit_program(1);\n        }\n        if (ret) {\n            opkt.buf = av_buffer_create(opkt.data, opkt.size, av_buffer_default_free, NULL, 0);\n            if (!opkt.buf)\n                exit_program(1);\n        }\n    } else {\n        opkt.data = pkt->data;\n        opkt.size = pkt->size;\n    }\n    av_copy_packet_side_data(&opkt, pkt);\n\n#if FF_API_LAVF_FMT_RAWPICTURE\n    if (ost->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&\n        ost->st->codecpar->codec_id == AV_CODEC_ID_RAWVIDEO &&\n        (of->ctx->oformat->flags & AVFMT_RAWPICTURE)) {\n        /* store AVPicture in AVPacket, as expected by the output format */\n        int ret = avpicture_fill(&pict, opkt.data, ost->st->codecpar->format, ost->st->codecpar->width, ost->st->codecpar->height);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_FATAL, \"avpicture_fill failed: %s\\n\",\n                   av_err2str(ret));\n            exit_program(1);\n        }\n        opkt.data = (uint8_t *)&pict;\n        opkt.size = sizeof(AVPicture);\n        opkt.flags |= AV_PKT_FLAG_KEY;\n    }\n#endif\n\n    output_packet(of->ctx, &opkt, ost);\n}", "target": 0}
{"idx": 4731, "func": "static int scan_for_extensions(AVCodecContext *avctx)\n{\n    DCAContext *s = avctx->priv_data;\n    int core_ss_end, ret = 0;\n\n    core_ss_end = FFMIN(s->frame_size, s->dca_buffer_size) * 8;\n\n    /* only scan for extensions if ext_descr was unknown or indicated a\n     * supported XCh extension */\n    if (s->core_ext_mask < 0 || s->core_ext_mask & DCA_EXT_XCH) {\n        /* if ext_descr was unknown, clear s->core_ext_mask so that the\n         * extensions scan can fill it up */\n        s->core_ext_mask = FFMAX(s->core_ext_mask, 0);\n\n        /* extensions start at 32-bit boundaries into bitstream */\n        skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n\n        while (core_ss_end - get_bits_count(&s->gb) >= 32) {\n            uint32_t bits = get_bits_long(&s->gb, 32);\n            int i;\n\n            switch (bits) {\n            case DCA_SYNCWORD_XCH: {\n                int ext_amode, xch_fsize;\n\n                s->xch_base_channel = s->prim_channels;\n\n                /* validate sync word using XCHFSIZE field */\n                xch_fsize = show_bits(&s->gb, 10);\n                if ((s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize) &&\n                    (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + xch_fsize + 1))\n                    continue;\n\n                /* skip length-to-end-of-frame field for the moment */\n                skip_bits(&s->gb, 10);\n\n                s->core_ext_mask |= DCA_EXT_XCH;\n\n                /* extension amode(number of channels in extension) should be 1 */\n                /* AFAIK XCh is not used for more channels */\n                if ((ext_amode = get_bits(&s->gb, 4)) != 1) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"XCh extension amode %d not supported!\\n\",\n                           ext_amode);\n                    continue;\n                }\n\n                /* much like core primary audio coding header */\n                dca_parse_audio_coding_header(s, s->xch_base_channel);\n\n                for (i = 0; i < (s->sample_blocks / 8); i++)\n                    if ((ret = dca_decode_block(s, s->xch_base_channel, i))) {\n                        av_log(avctx, AV_LOG_ERROR, \"error decoding XCh extension\\n\");\n                        continue;\n                    }\n\n                s->xch_present = 1;\n                break;\n            }\n            case DCA_SYNCWORD_XXCH:\n                /* XXCh: extended channels */\n                /* usually found either in core or HD part in DTS-HD HRA streams,\n                 * but not in DTS-ES which contains XCh extensions instead */\n                s->core_ext_mask |= DCA_EXT_XXCH;\n                break;\n\n            case 0x1d95f262: {\n                int fsize96 = show_bits(&s->gb, 12) + 1;\n                if (s->frame_size != (get_bits_count(&s->gb) >> 3) - 4 + fsize96)\n                    continue;\n\n                av_log(avctx, AV_LOG_DEBUG, \"X96 extension found at %d bits\\n\",\n                       get_bits_count(&s->gb));\n                skip_bits(&s->gb, 12);\n                av_log(avctx, AV_LOG_DEBUG, \"FSIZE96 = %d bytes\\n\", fsize96);\n                av_log(avctx, AV_LOG_DEBUG, \"REVNO = %d\\n\", get_bits(&s->gb, 4));\n\n                s->core_ext_mask |= DCA_EXT_X96;\n                break;\n            }\n            }\n\n            skip_bits_long(&s->gb, (-get_bits_count(&s->gb)) & 31);\n        }\n    } else {\n        /* no supported extensions, skip the rest of the core substream */\n        skip_bits_long(&s->gb, core_ss_end - get_bits_count(&s->gb));\n    }\n\n    if (s->core_ext_mask & DCA_EXT_X96)\n        s->profile = FF_PROFILE_DTS_96_24;\n    else if (s->core_ext_mask & (DCA_EXT_XCH | DCA_EXT_XXCH))\n        s->profile = FF_PROFILE_DTS_ES;\n\n    /* check for ExSS (HD part) */\n    if (s->dca_buffer_size - s->frame_size > 32 &&\n        get_bits_long(&s->gb, 32) == DCA_SYNCWORD_SUBSTREAM)\n        ff_dca_exss_parse_header(s);\n\n    return ret;\n}", "target": 0}
{"idx": 4732, "func": "static int read_packet(AVFormatContext *avctx, AVPacket *pkt)\n{\n    MlvContext *mlv = avctx->priv_data;\n    AVIOContext *pb;\n    AVStream *st = avctx->streams[mlv->stream_index];\n    int index, ret;\n    unsigned int size, space;\n\n    if (mlv->pts >= st->duration)\n        return AVERROR_EOF;\n\n    index = av_index_search_timestamp(st, mlv->pts, AVSEEK_FLAG_ANY);\n    if (index < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"could not find index entry for frame %\"PRId64\"\\n\", mlv->pts);\n        return AVERROR(EIO);\n    }\n\n    pb = mlv->pb[st->index_entries[index].size];\n    avio_seek(pb, st->index_entries[index].pos, SEEK_SET);\n\n    avio_skip(pb, 4); // blockType\n    size = avio_rl32(pb);\n    if (size < 16)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 12); //timestamp, frameNumber\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n        avio_skip(pb, 8); // cropPosX, cropPosY, panPosX, panPosY\n    space = avio_rl32(pb);\n    avio_skip(pb, space);\n\n    if ((mlv->class[st->id] & (MLV_CLASS_FLAG_DELTA|MLV_CLASS_FLAG_LZMA))) {\n        ret = AVERROR_PATCHWELCOME;\n    } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n        ret = av_get_packet(pb, pkt, (st->codec->width * st->codec->height * st->codec->bits_per_coded_sample + 7) >> 3);\n    } else { // AVMEDIA_TYPE_AUDIO\n        if (space > UINT_MAX - 24 || size < (24 + space))\n            return AVERROR_INVALIDDATA;\n        ret = av_get_packet(pb, pkt, size - (24 + space));\n    }\n\n    if (ret < 0)\n        return ret;\n\n    pkt->stream_index = mlv->stream_index;\n    pkt->pts = mlv->pts;\n\n    mlv->stream_index++;\n    if (mlv->stream_index == avctx->nb_streams) {\n        mlv->stream_index = 0;\n        mlv->pts++;\n    }\n    return 0;\n}", "target": 1}
{"idx": 4733, "func": "static void ff_id3v2_parse(AVFormatContext *s, int len, uint8_t version, uint8_t flags, ID3v2ExtraMeta **extra_meta)\n{\n    int isv34, tlen, unsync;\n    char tag[5];\n    int64_t next, end = avio_tell(s->pb) + len;\n    int taghdrlen;\n    const char *reason = NULL;\n    AVIOContext pb;\n    AVIOContext *pbx;\n    unsigned char *buffer = NULL;\n    int buffer_size = 0;\n    void (*extra_func)(AVFormatContext*, AVIOContext*, int, char*, ID3v2ExtraMeta**) = NULL;\n\n    switch (version) {\n    case 2:\n        if (flags & 0x40) {\n            reason = \"compression\";\n            goto error;\n        }\n        isv34 = 0;\n        taghdrlen = 6;\n        break;\n\n    case 3:\n    case 4:\n        isv34 = 1;\n        taghdrlen = 10;\n        break;\n\n    default:\n        reason = \"version\";\n        goto error;\n    }\n\n    unsync = flags & 0x80;\n\n    if (isv34 && flags & 0x40) /* Extended header present, just skip over it */\n        avio_skip(s->pb, get_size(s->pb, 4));\n\n    while (len >= taghdrlen) {\n        unsigned int tflags = 0;\n        int tunsync = 0;\n\n        if (isv34) {\n            avio_read(s->pb, tag, 4);\n            tag[4] = 0;\n            if(version==3){\n                tlen = avio_rb32(s->pb);\n            }else\n                tlen = get_size(s->pb, 4);\n            tflags = avio_rb16(s->pb);\n            tunsync = tflags & ID3v2_FLAG_UNSYNCH;\n        } else {\n            avio_read(s->pb, tag, 3);\n            tag[3] = 0;\n            tlen = avio_rb24(s->pb);\n        }\n        if (tlen < 0 || tlen > len - taghdrlen) {\n            av_log(s, AV_LOG_WARNING, \"Invalid size in frame %s, skipping the rest of tag.\\n\", tag);\n            break;\n        }\n        len -= taghdrlen + tlen;\n        next = avio_tell(s->pb) + tlen;\n\n        if (!tlen) {\n            if (tag[0])\n                av_log(s, AV_LOG_DEBUG, \"Invalid empty frame %s, skipping.\\n\", tag);\n            continue;\n        }\n\n        if (tflags & ID3v2_FLAG_DATALEN) {\n            avio_rb32(s->pb);\n            tlen -= 4;\n        }\n\n        if (tflags & (ID3v2_FLAG_ENCRYPTION | ID3v2_FLAG_COMPRESSION)) {\n            av_log(s, AV_LOG_WARNING, \"Skipping encrypted/compressed ID3v2 frame %s.\\n\", tag);\n            avio_skip(s->pb, tlen);\n        /* check for text tag or supported special meta tag */\n        } else if (tag[0] == 'T' || (extra_meta && (extra_func = get_extra_meta_func(tag, isv34)->read))) {\n            if (unsync || tunsync) {\n                int i, j;\n                av_fast_malloc(&buffer, &buffer_size, tlen);\n                if (!buffer) {\n                    av_log(s, AV_LOG_ERROR, \"Failed to alloc %d bytes\\n\", tlen);\n                    goto seek;\n                }\n                for (i = 0, j = 0; i < tlen; i++, j++) {\n                    buffer[j] = avio_r8(s->pb);\n                    if (j > 0 && !buffer[j] && buffer[j - 1] == 0xff) {\n                        /* Unsynchronised byte, skip it */\n                        j--;\n                    }\n                }\n                ffio_init_context(&pb, buffer, j, 0, NULL, NULL, NULL, NULL);\n                tlen = j;\n                pbx = &pb; // read from sync buffer\n            } else {\n                pbx = s->pb; // read straight from input\n            }\n            if (tag[0] == 'T')\n                /* parse text tag */\n                read_ttag(s, pbx, tlen, tag);\n            else\n                /* parse special meta tag */\n                extra_func(s, pbx, tlen, tag, extra_meta);\n        }\n        else if (!tag[0]) {\n            if (tag[1])\n                av_log(s, AV_LOG_WARNING, \"invalid frame id, assuming padding\");\n            avio_skip(s->pb, tlen);\n            break;\n        }\n        /* Skip to end of tag */\nseek:\n        avio_seek(s->pb, next, SEEK_SET);\n    }\n\n    if (version == 4 && flags & 0x10) /* Footer preset, always 10 bytes, skip over it */\n        end += 10;\n\n  error:\n    if (reason)\n        av_log(s, AV_LOG_INFO, \"ID3v2.%d tag skipped, cannot handle %s\\n\", version, reason);\n    avio_seek(s->pb, end, SEEK_SET);\n    av_free(buffer);\n    return;\n}", "target": 0}
{"idx": 4734, "func": "static void mpeg_decode_sequence_extension(Mpeg1Context *s1)\n{\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n    int horiz_size_ext, vert_size_ext;\n    int bit_rate_ext;\n\n    skip_bits(&s->gb, 1); /* profile and level esc*/\n    s->avctx->profile       = get_bits(&s->gb, 3);\n    s->avctx->level         = get_bits(&s->gb, 4);\n    s->progressive_sequence = get_bits1(&s->gb);   /* progressive_sequence */\n    s->chroma_format        = get_bits(&s->gb, 2); /* chroma_format 1=420, 2=422, 3=444 */\n\n    if (!s->chroma_format) {\n        s->chroma_format = 1;\n        av_log(s->avctx, AV_LOG_WARNING, \"Chroma format invalid\\n\");\n    }\n\n    horiz_size_ext          = get_bits(&s->gb, 2);\n    vert_size_ext           = get_bits(&s->gb, 2);\n    s->width  |= (horiz_size_ext << 12);\n    s->height |= (vert_size_ext  << 12);\n    bit_rate_ext = get_bits(&s->gb, 12);  /* XXX: handle it */\n    s->bit_rate += (bit_rate_ext << 18) * 400;\n    check_marker(&s->gb, \"after bit rate extension\");\n    s->avctx->rc_buffer_size += get_bits(&s->gb, 8) * 1024 * 16 << 10;\n\n    s->low_delay = get_bits1(&s->gb);\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n\n    s1->frame_rate_ext.num = get_bits(&s->gb, 2) + 1;\n    s1->frame_rate_ext.den = get_bits(&s->gb, 5) + 1;\n\n    ff_dlog(s->avctx, \"sequence extension\\n\");\n    s->codec_id = s->avctx->codec_id = AV_CODEC_ID_MPEG2VIDEO;\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(s->avctx, AV_LOG_DEBUG,\n               \"profile: %d, level: %d ps: %d cf:%d vbv buffer: %d, bitrate:%\"PRId64\"\\n\",\n               s->avctx->profile, s->avctx->level, s->progressive_sequence, s->chroma_format,\n               s->avctx->rc_buffer_size, s->bit_rate);\n}", "target": 1}
{"idx": 4735, "func": "static void ctr_XOR(DRBG_CTR_CTX *cctx, const unsigned char *in, size_t inlen)\n{\n    size_t i, n;\n\n    if (in == NULL || inlen == 0)\n        return;\n\n    /*\n     * Any zero padding will have no effect on the result as we\n     * are XORing. So just process however much input we have.\n     */\n    n = inlen < cctx->keylen ? inlen : cctx->keylen;\n    for (i = 0; i < n; i++)\n        cctx->K[i] ^= in[i];\n    if (inlen <= cctx->keylen)\n        return;\n\n    n = inlen - cctx->keylen;\n    if (n > 16) {\n        /* Should never happen */\n        n = 16;\n    }\n    for (i = 0; i < n; i++)\n        cctx->V[i] ^= in[i + cctx->keylen];\n}", "target": 1}
{"idx": 4736, "func": "AVIOContext *avio_alloc_context(\n                  unsigned char *buffer,\n                  int buffer_size,\n                  int write_flag,\n                  void *opaque,\n                  int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),\n                  int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),\n                  int64_t (*seek)(void *opaque, int64_t offset, int whence))\n{\n    AVIOContext *s = av_mallocz(sizeof(AVIOContext));\n    if (!s)\n        return NULL;\n    ffio_init_context(s, buffer, buffer_size, write_flag, opaque,\n                  read_packet, write_packet, seek);\n    return s;\n}", "target": 0}
{"idx": 4737, "func": "static int BN_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont)\n\t{\n\tBIGNUM *n;\n\tBN_ULONG *ap,*np,*rp,n0,v,*nrp;\n\tint al,nl,max,i,x,ri;\n\n\tn= &(mont->N);\n\t/* mont->ri is the size of mont->N in bits (rounded up\n\t   to the word size) */\n\tal=ri=mont->ri/BN_BITS2;\n\n\tnl=n->top;\n\tif ((al == 0) || (nl == 0)) { ret->top=0; return(1); }\n\n\tmax=(nl+al+1); /* allow for overflow (no?) XXX */\n\tif (bn_wexpand(r,max) == NULL) return(0);\n\n\tr->neg^=n->neg;\n\tnp=n->d;\n\trp=r->d;\n\tnrp= &(r->d[nl]);\n\n\t/* clear the top words of T */\n#if 1\n\tfor (i=r->top; i<max; i++) /* memset? XXX */\n\t\tr->d[i]=0;\n#else\n\tmemset(&(r->d[r->top]),0,(max-r->top)*sizeof(BN_ULONG)); \n#endif\n\n\tr->top=max;\n\tn0=mont->n0[0];\n\n#ifdef BN_COUNT\n\tfprintf(stderr,\"word BN_from_montgomery_word %d * %d\\n\",nl,nl);\n#endif\n\tfor (i=0; i<nl; i++)\n\t\t{\n#ifdef __TANDEM\n                {\n                   long long t1;\n                   long long t2;\n                   long long t3;\n                   t1 = rp[0] * (n0 & 0177777);\n                   t2 = 037777600000l;\n                   t2 = n0 & t2;\n                   t3 = rp[0] & 0177777;\n                   t2 = (t3 * t2) & BN_MASK2;\n                   t1 = t1 + t2;\n                   v=bn_mul_add_words(rp,np,nl,(BN_ULONG) t1);\n                }\n#else\n\t\tv=bn_mul_add_words(rp,np,nl,(rp[0]*n0)&BN_MASK2);\n#endif\n\t\tnrp++;\n\t\trp++;\n\t\tif (((nrp[-1]+=v)&BN_MASK2) >= v)\n\t\t\tcontinue;\n\t\telse\n\t\t\t{\n\t\t\tif (((++nrp[0])&BN_MASK2) != 0) continue;\n\t\t\tif (((++nrp[1])&BN_MASK2) != 0) continue;\n\t\t\tfor (x=2; (((++nrp[x])&BN_MASK2) == 0); x++) ;\n\t\t\t}\n\t\t}\n\tbn_correct_top(r);\n\t\n\t/* mont->ri will be a multiple of the word size */\n#if 0\n\tBN_rshift(ret,r,mont->ri);\n#else\n\tif (r->top < ri)\n\t\t{\n\t\tret->top=0;\n\t\treturn(1);\n\t\t}\n\tal=r->top-ri;\n\tif (bn_wexpand(ret,al) == NULL) return(0);\n\tret->neg=r->neg;\n\tret->top=al;\n\n\trp=ret->d;\n\tap=&(r->d[ri]);\n\tal-=4;\n\tfor (i=0; i<al; i+=4)\n\t\t{\n\t\tBN_ULONG t1,t2,t3,t4;\n\t\t\n\t\tt1=ap[i+0];\n\t\tt2=ap[i+1];\n\t\tt3=ap[i+2];\n\t\tt4=ap[i+3];\n\t\trp[i+0]=t1;\n\t\trp[i+1]=t2;\n\t\trp[i+2]=t3;\n\t\trp[i+3]=t4;\n\t\t}\n\tal+=4;\n\tfor (; i<al; i++)\n\t\trp[i]=ap[i];\n#endif\n\n\tif (BN_ucmp(ret, &(mont->N)) >= 0)\n\t\t{\n\t\tif (!BN_usub(ret,ret,&(mont->N))) return(0);\n\t\t}\n\tbn_check_top(ret);\n\n\treturn(1);\n\t}", "target": 1}
{"idx": 4738, "func": "OPENSSL_STACK *OPENSSL_sk_dup(const OPENSSL_STACK *sk)\n{\n    OPENSSL_STACK *ret;\n\n    if (sk->num < 0)\n        return NULL;\n\n    if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL)\n        return NULL;\n\n    /* direct structure assignment */\n    *ret = *sk;\n\n    if ((ret->data = OPENSSL_malloc(sizeof(*ret->data) * sk->num_alloc)) == NULL)\n        goto err;\n    memcpy(ret->data, sk->data, sizeof(void *) * sk->num);\n    return ret;\n err:\n    OPENSSL_sk_free(ret);\n    return NULL;\n}", "target": 0}
{"idx": 4739, "func": "void ff_update_duplicate_context(MpegEncContext *dst, MpegEncContext *src){\n    MpegEncContext bak;\n    int i;\n    //FIXME copy only needed parts\n//START_TIMER\n    backup_duplicate_context(&bak, dst);\n    memcpy(dst, src, sizeof(MpegEncContext));\n    backup_duplicate_context(dst, &bak);\n    for(i=0;i<12;i++){\n        dst->pblocks[i] = &dst->block[i];\n    }\n//STOP_TIMER(\"update_duplicate_context\") //about 10k cycles / 0.01 sec for 1000frames on 1ghz with 2 threads\n}", "target": 1}
{"idx": 4740, "func": "static void\nreal_parse_asm_rulebook(AVFormatContext *s, AVStream *orig_st,\n                        const char *p)\n{\n    const char *end;\n    int n_rules = 0, odd = 0;\n    AVStream *st;\n\n    /**\n     * The ASMRuleBook contains a list of comma-separated strings per rule,\n     * and each rule is separated by a ;. The last one also has a ; at the\n     * end so we can use it as delimiter.\n     * Every rule occurs twice, once for when the RTSP packet header marker\n     * is set and once for if it isn't. We only read the first because we\n     * don't care much (that's what the \"odd\" variable is for).\n     * Each rule contains a set of one or more statements, optionally\n     * preceeded by a single condition. If there's a condition, the rule\n     * starts with a '#'. Multiple conditions are merged between brackets,\n     * so there are never multiple conditions spread out over separate\n     * statements. Generally, these conditions are bitrate limits (min/max)\n     * for multi-bitrate streams.\n     */\n    if (*p == '\\\"') p++;\n    while (1) {\n        if (!(end = strchr(p, ';')))\n            break;\n        if (!odd && end != p) {\n            if (n_rules > 0)\n                st = add_dstream(s, orig_st);\n            else\n                st = orig_st;\n            if (!st)\n                break;\n            real_parse_asm_rule(st, p, end);\n            n_rules++;\n        }\n        p = end + 1;\n        odd ^= 1;\n    }\n}", "target": 0}
{"idx": 4741, "func": "static int allocate_buffers(ShortenContext *s)\n{\n    int i, chan;\n    int *coeffs;\n    void *tmp_ptr;\n\n    for (chan=0; chan<s->channels; chan++) {\n        if(FFMAX(1, s->nmean) >= UINT_MAX/sizeof(int32_t)){\n            av_log(s->avctx, AV_LOG_ERROR, \"nmean too large\\n\");\n            return -1;\n        }\n        if(s->blocksize + s->nwrap >= UINT_MAX/sizeof(int32_t) || s->blocksize + s->nwrap <= (unsigned)s->nwrap){\n            av_log(s->avctx, AV_LOG_ERROR, \"s->blocksize + s->nwrap too large\\n\");\n            return -1;\n        }\n\n        tmp_ptr = av_realloc(s->offset[chan], sizeof(int32_t)*FFMAX(1, s->nmean));\n        if (!tmp_ptr)\n            return AVERROR(ENOMEM);\n        s->offset[chan] = tmp_ptr;\n\n        tmp_ptr = av_realloc(s->decoded[chan], sizeof(int32_t)*(s->blocksize + s->nwrap));\n        if (!tmp_ptr)\n            return AVERROR(ENOMEM);\n        s->decoded[chan] = tmp_ptr;\n        for (i=0; i<s->nwrap; i++)\n            s->decoded[chan][i] = 0;\n        s->decoded[chan] += s->nwrap;\n    }\n\n    coeffs = av_realloc(s->coeffs, s->nwrap * sizeof(*s->coeffs));\n    if (!coeffs)\n        return AVERROR(ENOMEM);\n    s->coeffs = coeffs;\n\n    return 0;\n}", "target": 1}
{"idx": 4742, "func": "int ASN1_get_object(unsigned char **pp, long *plength, int *ptag, int *pclass,\n\t     long omax)\n\t{\n\tint i,ret;\n\tlong l;\n\tunsigned char *p= *pp;\n\tint tag,xclass,inf;\n\tlong max=omax;\n\n\tif (!max) goto err;\n\tret=(*p&V_ASN1_CONSTRUCTED);\n\txclass=(*p&V_ASN1_PRIVATE);\n\ti= *p&V_ASN1_PRIMITIVE_TAG;\n\tif (i == V_ASN1_PRIMITIVE_TAG)\n\t\t{\t\t/* high-tag */\n\t\tp++;\n\t\tif (--max == 0) goto err;\n\t\tl=0;\n\t\twhile (*p&0x80)\n\t\t\t{\n\t\t\tl<<=7L;\n\t\t\tl|= *(p++)&0x7f;\n\t\t\tif (--max == 0) goto err;\n\t\t\t}\n\t\tl<<=7L;\n\t\tl|= *(p++)&0x7f;\n\t\ttag=(int)l;\n\t\t}\n\telse\n\t\t{ \n\t\ttag=i;\n\t\tp++;\n\t\tif (--max == 0) goto err;\n\t\t}\n\t*ptag=tag;\n\t*pclass=xclass;\n\tif (!asn1_get_length(&p,&inf,plength,(int)max)) goto err;\n\n#if 0\n\tfprintf(stderr,\"p=%d + *plength=%ld > omax=%ld + *pp=%d  (%d > %d)\\n\", \n\t\t(int)p,*plength,omax,(int)*pp,(int)(p+ *plength),\n\t\t(int)(omax+ *pp));\n\n#endif\n#if 0\n\tif ((p+ *plength) > (omax+ *pp))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_GET_OBJECT,ASN1_R_TOO_LONG);\n\t\t/* Set this so that even if things are not long enough\n\t\t * the values are set correctly */\n\t\tret|=0x80;\n\t\t}\n#endif\n\t*pp=p;\n\treturn(ret|inf);\nerr:\n\tASN1err(ASN1_F_ASN1_GET_OBJECT,ASN1_R_HEADER_TOO_LONG);\n\treturn(0x80);\n\t}", "target": 1}
{"idx": 4743, "func": "void\nngx_slab_init(ngx_slab_pool_t *pool)\n{\n    u_char           *p;\n    size_t            size;\n    ngx_int_t         m;\n    ngx_uint_t        i, n, pages;\n    ngx_slab_page_t  *slots, *page;\n\n    /* STUB */\n    if (ngx_slab_max_size == 0) {\n        ngx_slab_max_size = ngx_pagesize / 2;\n        ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t));\n        for (n = ngx_slab_exact_size; n >>= 1; ngx_slab_exact_shift++) {\n            /* void */\n        }\n    }\n    /**/\n\n    pool->min_size = 1 << pool->min_shift;\n\n    slots = ngx_slab_slots(pool);\n\n    p = (u_char *) slots;\n    size = pool->end - p;\n\n    ngx_slab_junk(p, size);\n\n    n = ngx_pagesize_shift - pool->min_shift;\n\n    for (i = 0; i < n; i++) {\n        /* only \"next\" is used in list head */\n        slots[i].slab = 0;\n        slots[i].next = &slots[i];\n        slots[i].prev = 0;\n    }\n\n    p += n * sizeof(ngx_slab_page_t);\n\n    pool->stats = (ngx_slab_stat_t *) p;\n    ngx_memzero(pool->stats, n * sizeof(ngx_slab_stat_t));\n\n    p += n * sizeof(ngx_slab_stat_t);\n\n    size -= n * (sizeof(ngx_slab_page_t) + sizeof(ngx_slab_stat_t));\n\n    pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t)));\n\n    pool->pages = (ngx_slab_page_t *) p;\n    ngx_memzero(pool->pages, pages * sizeof(ngx_slab_page_t));\n\n    page = pool->pages;\n\n    /* only \"next\" is used in list head */\n    pool->free.slab = 0;\n    pool->free.next = page;\n    pool->free.prev = 0;\n\n    page->slab = pages;\n    page->next = &pool->free;\n    page->prev = (uintptr_t) &pool->free;\n\n    pool->start = ngx_align_ptr(p + pages * sizeof(ngx_slab_page_t),\n                                ngx_pagesize);\n\n    m = pages - (pool->end - pool->start) / ngx_pagesize;\n    if (m > 0) {\n        pages -= m;\n        page->slab = pages;\n    }\n\n    pool->last = pool->pages + pages;\n\n    pool->log_nomem = 1;\n    pool->log_ctx = &pool->zero;\n    pool->zero = '\\0';\n}", "target": 0}
{"idx": 4744, "func": "static int make_cp_exchange_key(BIGNUM *priv_key,EVP_PKEY *pubk, unsigned char *shared_key)\n\t{\n\tunsigned char dh_key [128];\n\tint ret;\n\tgost_hash_ctx hash_ctx;\n\tDH *dh = DH_new();\n\t\n\tmemset(dh_key,0,128);\n\tdh->g = BN_dup(pubk->pkey.dsa->g);\n\tdh->p = BN_dup(pubk->pkey.dsa->p);\n\tdh->priv_key = BN_dup(priv_key);\n\tret=compute_pair_key_le(dh_key,((DSA *)(EVP_PKEY_get0(pubk)))->pub_key,dh) ;\n\tDH_free(dh);\n\tif (!ret)\treturn 0;\n\tinit_gost_hash_ctx(&hash_ctx,&GostR3411_94_CryptoProParamSet);\n\tstart_hash(&hash_ctx);\n\thash_block(&hash_ctx,dh_key,128);\n\tfinish_hash(&hash_ctx,shared_key);\n\tdone_gost_hash_ctx(&hash_ctx);\n\treturn 1;\n\t}", "target": 1}
{"idx": 4745, "func": "void gost_key(gost_ctx *c, const byte *k) \n\t{ \n\tint i,j; \n\tfor(i=0,j=0;i<8;i++,j+=4)\n\t\t{\n\t\tc->k[i]=k[j]|(k[j+1]<<8)|(k[j+2]<<16)|(k[j+3]<<24);\n\t\t}\t\t\n\t}", "target": 1}
{"idx": 4746, "func": "static void new_video_stream(AVFormatContext *oc, int file_idx)\n{\n    AVStream *st;\n    AVCodecContext *video_enc;\n    enum CodecID codec_id;\n    AVCodec *codec= NULL;\n\n    st = av_new_stream(oc, oc->nb_streams < nb_streamid_map ? streamid_map[oc->nb_streams] : 0);\n    if (!st) {\n        fprintf(stderr, \"Could not alloc stream\\n\");\n        ffmpeg_exit(1);\n    }\n\n    output_codecs = grow_array(output_codecs, sizeof(*output_codecs), &nb_output_codecs, nb_output_codecs + 1);\n    if(!video_stream_copy){\n        if (video_codec_name) {\n            codec_id = find_codec_or_die(video_codec_name, AVMEDIA_TYPE_VIDEO, 1,\n                                         avcodec_opts[AVMEDIA_TYPE_VIDEO]->strict_std_compliance);\n            codec = avcodec_find_encoder_by_name(video_codec_name);\n            output_codecs[nb_output_codecs-1] = codec;\n        } else {\n            codec_id = av_guess_codec(oc->oformat, NULL, oc->filename, NULL, AVMEDIA_TYPE_VIDEO);\n            codec = avcodec_find_encoder(codec_id);\n        }\n    }\n\n    avcodec_get_context_defaults3(st->codec, codec);\n    bitstream_filters[file_idx] =\n        grow_array(bitstream_filters[file_idx],\n                   sizeof(*bitstream_filters[file_idx]),\n                   &nb_bitstream_filters[file_idx], oc->nb_streams);\n    bitstream_filters[file_idx][oc->nb_streams - 1]= video_bitstream_filters;\n    video_bitstream_filters= NULL;\n\n    avcodec_thread_init(st->codec, thread_count);\n\n    video_enc = st->codec;\n\n    if(video_codec_tag)\n        video_enc->codec_tag= video_codec_tag;\n\n    if(   (video_global_header&1)\n       || (video_global_header==0 && (oc->oformat->flags & AVFMT_GLOBALHEADER))){\n        video_enc->flags |= CODEC_FLAG_GLOBAL_HEADER;\n        avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags|= CODEC_FLAG_GLOBAL_HEADER;\n    }\n    if(video_global_header&2){\n        video_enc->flags2 |= CODEC_FLAG2_LOCAL_HEADER;\n        avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags2|= CODEC_FLAG2_LOCAL_HEADER;\n    }\n\n    if (video_stream_copy) {\n        st->stream_copy = 1;\n        video_enc->codec_type = AVMEDIA_TYPE_VIDEO;\n        video_enc->sample_aspect_ratio =\n        st->sample_aspect_ratio = av_d2q(frame_aspect_ratio*frame_height/frame_width, 255);\n    } else {\n        const char *p;\n        int i;\n        AVRational fps= frame_rate.num ? frame_rate : (AVRational){25,1};\n\n        video_enc->codec_id = codec_id;\n        set_context_opts(video_enc, avcodec_opts[AVMEDIA_TYPE_VIDEO], AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM, codec);\n\n        if (codec && codec->supported_framerates && !force_fps)\n            fps = codec->supported_framerates[av_find_nearest_q_idx(fps, codec->supported_framerates)];\n        video_enc->time_base.den = fps.num;\n        video_enc->time_base.num = fps.den;\n\n        video_enc->width = frame_width;\n        video_enc->height = frame_height;\n        video_enc->sample_aspect_ratio = av_d2q(frame_aspect_ratio*video_enc->height/video_enc->width, 255);\n        video_enc->pix_fmt = frame_pix_fmt;\n        st->sample_aspect_ratio = video_enc->sample_aspect_ratio;\n\n        choose_pixel_fmt(st, codec);\n\n        if (intra_only)\n            video_enc->gop_size = 0;\n        if (video_qscale || same_quality) {\n            video_enc->flags |= CODEC_FLAG_QSCALE;\n            video_enc->global_quality=\n                st->quality = FF_QP2LAMBDA * video_qscale;\n        }\n\n        if(intra_matrix)\n            video_enc->intra_matrix = intra_matrix;\n        if(inter_matrix)\n            video_enc->inter_matrix = inter_matrix;\n\n        p= video_rc_override_string;\n        for(i=0; p; i++){\n            int start, end, q;\n            int e=sscanf(p, \"%d,%d,%d\", &start, &end, &q);\n            if(e!=3){\n                fprintf(stderr, \"error parsing rc_override\\n\");\n                ffmpeg_exit(1);\n            }\n            video_enc->rc_override=\n                av_realloc(video_enc->rc_override,\n                           sizeof(RcOverride)*(i+1));\n            video_enc->rc_override[i].start_frame= start;\n            video_enc->rc_override[i].end_frame  = end;\n            if(q>0){\n                video_enc->rc_override[i].qscale= q;\n                video_enc->rc_override[i].quality_factor= 1.0;\n            }\n            else{\n                video_enc->rc_override[i].qscale= 0;\n                video_enc->rc_override[i].quality_factor= -q/100.0;\n            }\n            p= strchr(p, '/');\n            if(p) p++;\n        }\n        video_enc->rc_override_count=i;\n        if (!video_enc->rc_initial_buffer_occupancy)\n            video_enc->rc_initial_buffer_occupancy = video_enc->rc_buffer_size*3/4;\n        video_enc->me_threshold= me_threshold;\n        video_enc->intra_dc_precision= intra_dc_precision - 8;\n\n        if (do_psnr)\n            video_enc->flags|= CODEC_FLAG_PSNR;\n\n        /* two pass mode */\n        if (do_pass) {\n            if (do_pass == 1) {\n                video_enc->flags |= CODEC_FLAG_PASS1;\n            } else {\n                video_enc->flags |= CODEC_FLAG_PASS2;\n            }\n        }\n    }\n    if (video_language) {\n        av_metadata_set2(&st->metadata, \"language\", video_language, 0);\n        av_freep(&video_language);\n    }\n\n    /* reset some key parameters */\n    video_disable = 0;\n    av_freep(&video_codec_name);\n    video_stream_copy = 0;\n    frame_pix_fmt = PIX_FMT_NONE;\n}", "target": 0}
{"idx": 4747, "func": "int ff_dirac_golomb_read_16bit(DiracGolombLUT *lut_ctx, const uint8_t *buf,\n                               int bytes, uint8_t *_dst, int coeffs)\n{\n    int i, b, c_idx = 0;\n    int16_t *dst = (int16_t *)_dst;\n    DiracGolombLUT *future[4], *l = &lut_ctx[2*LUT_SIZE + buf[0]];\n    INIT_RESIDUE(res);\n\n    for (b = 1; b <= bytes; b++) {\n        future[0] = &lut_ctx[buf[b]];\n        future[1] = future[0] + 1*LUT_SIZE;\n        future[2] = future[0] + 2*LUT_SIZE;\n        future[3] = future[0] + 3*LUT_SIZE;\n\n        if ((c_idx + 1) > coeffs)\n            return c_idx;\n\n        if (res_bits && l->sign) {\n            int32_t coeff = 1;\n            APPEND_RESIDUE(res, l->preamble);\n            for (i = 0; i < (res_bits >> 1) - 1; i++) {\n                coeff <<= 1;\n                coeff |= (res >> (RSIZE_BITS - 2*i - 2)) & 1;\n            }\n            dst[c_idx++] = l->sign * (coeff - 1);\n            res_bits = res = 0;\n        }\n\n        for (i = 0; i < LUT_BITS; i++)\n            dst[c_idx + i] = l->ready[i];\n        c_idx += l->ready_num;\n\n        APPEND_RESIDUE(res, l->leftover);\n\n        l = future[l->need_s ? 3 : !res_bits ? 2 : res_bits & 1];\n    }\n\n    return c_idx;\n}", "target": 1}
{"idx": 4748, "func": "void DH_free(DH *r)\n\t{\n\tDH_METHOD *meth;\n\tint i;\n\tif(r == NULL) return;\n\ti = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_DH);\n#ifdef REF_PRINT\n\tREF_PRINT(\"DH\",r);\n#endif\n\tif (i > 0) return;\n#ifdef REF_CHECK\n\tif (i < 0)\n\t\t{\n\t\tfprintf(stderr,\"DH_free, bad reference count\\n\");\n\t\tabort();\n\t}\n#endif\n\n\tCRYPTO_free_ex_data(dh_meth, r, &r->ex_data);\n\n\tmeth = ENGINE_get_DH(r->engine);\n\tif(meth->finish) meth->finish(r);\n\tENGINE_finish(r->engine);\n\n\tif (r->p != NULL) BN_clear_free(r->p);\n\tif (r->g != NULL) BN_clear_free(r->g);\n\tif (r->q != NULL) BN_clear_free(r->q);\n\tif (r->j != NULL) BN_clear_free(r->j);\n\tif (r->seed) OPENSSL_free(r->seed);\n\tif (r->counter != NULL) BN_clear_free(r->counter);\n\tif (r->pub_key != NULL) BN_clear_free(r->pub_key);\n\tif (r->priv_key != NULL) BN_clear_free(r->priv_key);\n\tOPENSSL_free(r);\n\t}", "target": 0}
{"idx": 4749, "func": "static inline int xiph_lacing_full(const uint8_t **ptr, const uint8_t *end)\n{\n    int val = 0;\n    int next;\n\n    while (1) {\n        if (*ptr >= end || val > INT_MAX - 254)\n            return AVERROR_INVALIDDATA;\n        next = *(*ptr)++;\n        val += next;\n        if (next < 255)\n            break;\n        else\n            val--;\n    }\n    return val;\n}", "target": 1}
{"idx": 4750, "func": "AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb)\n{\n    char *last_field = NULL;\n    apr_size_t last_len = 0;\n    apr_size_t alloc_len = 0;\n    char *field;\n    char *value;\n    apr_size_t len;\n    int fields_read = 0;\n    char *tmp_field;\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    int strictspaces = (conf->http_whitespace != AP_HTTP_WHITESPACE_UNSAFE);\n\n    /*\n     * Read header lines until we get the empty separator line, a read error,\n     * the connection closes (EOF), reach the server limit, or we timeout.\n     */\n    while(1) {\n        apr_status_t rv;\n\n        field = NULL;\n        rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2,\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_TIMEUP(rv)) {\n                r->status = HTTP_REQUEST_TIME_OUT;\n            }\n            else {\n                r->status = HTTP_BAD_REQUEST;\n            }\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the buffer before\n             * finding the end-of-line.  This is only going to happen if it\n             * exceeds the configured limit for a field size.\n             */\n            if (rv == APR_ENOSPC) {\n                apr_table_setn(r->notes, \"error-notes\",\n                               \"Size of a request header field \"\n                               \"exceeds server limit.\");\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00561)\n                              \"Request header exceeds LimitRequestFieldSize%s\"\n                              \"%.*s\",\n                              (field && *field) ? \": \" : \"\",\n                              (field) ? field_name_len(field) : 0,\n                              (field) ? field : \"\");\n            }\n            return;\n        }\n\n        if (strictspaces && strpbrk(field, \"\\n\\v\\f\\r\")) {\n            r->status = HTTP_BAD_REQUEST;\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(03451)\n                          \"Request header line presented bad whitespace \"\n                          \"(disallowed by StrictWhitespace)\");\n            return;\n        }\n        else {\n            /* Ensure no unusual whitespace is present in the resulting\n             * header field input line, even in unsafe mode, by replacing\n             * bad whitespace with SP before collapsing whitespace\n             */\n            char *ll = field;\n            while ((ll = strpbrk(ll, \"\\n\\v\\f\\r\")))\n                *(ll++) = ' ';\n        }\n\n        /* For all header values, and all obs-fold lines, the presence of\n         * additional whitespace is a no-op, so collapse trailing whitespace\n         * to save buffer allocation and optimize copy operations.\n         * Do not remove the last single whitespace under any condition.\n         */\n        while (len > 1 && (field[len-1] == '\\t' || field[len-1] == ' ')) {\n            field[--len] = '\\0';\n        } \n\n        if (*field == '\\t' || *field == ' ') {\n\n            /* Append any newly-read obs-fold line onto the preceding\n             * last_field line we are processing\n             */\n            apr_size_t fold_len;\n\n            if (last_field == NULL) {\n                r->status = HTTP_BAD_REQUEST;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(03442)\n                              \"Line folding encountered before first\"\n                              \" header line\");\n                return;\n            }\n\n            if (field[1] == '\\0') {\n                r->status = HTTP_BAD_REQUEST;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(03443)\n                              \"Empty folded line encountered\");\n                return;\n            }\n\n            /* Leading whitespace on an obs-fold line can be\n             * similarly discarded */\n            while (field[1] == '\\t' || field[1] == ' ') {\n                ++field; --len;\n            }\n\n            /* This line is a continuation of the preceding line(s),\n             * so append it to the line that we've set aside.\n             * Note: this uses a power-of-two allocator to avoid\n             * doing O(n) allocs and using O(n^2) space for\n             * continuations that span many many lines.\n             */\n            fold_len = last_len + len + 1; /* trailing null */\n\n            if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {\n                r->status = HTTP_BAD_REQUEST;\n                /* report what we have accumulated so far before the\n                 * overflow (last_field) as the field with the problem\n                 */\n                apr_table_setn(r->notes, \"error-notes\",\n                               \"Size of a request header field \"\n                               \"exceeds server limit.\");\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00562)\n                              \"Request header exceeds LimitRequestFieldSize \"\n                              \"after folding: %.*s\",\n                              field_name_len(last_field), last_field);\n                return;\n            }\n\n            if (fold_len > alloc_len) {\n                char *fold_buf;\n                alloc_len += alloc_len;\n                if (fold_len > alloc_len) {\n                    alloc_len = fold_len;\n                }\n                fold_buf = (char *)apr_palloc(r->pool, alloc_len);\n                memcpy(fold_buf, last_field, last_len);\n                last_field = fold_buf;\n            }\n            memcpy(last_field + last_len, field, len +1); /* +1 for nul */\n            /* Replace obs-fold w/ SP per RFC 7230 3.2.4 */\n            last_field[last_len] = ' ';\n            last_len += len;\n\n            /* We've appended this obs-fold line to last_len, proceed to\n             * read the next input line\n             */\n            continue;\n        }\n        else if (last_field != NULL) {\n\n            /* Process the previous last_field header line with all obs-folded\n             * segments already concatinated (this is not operating on the\n             * most recently read input line).\n             */\n\n            if (r->server->limit_req_fields\n                    && (++fields_read > r->server->limit_req_fields)) {\n                r->status = HTTP_BAD_REQUEST;\n                apr_table_setn(r->notes, \"error-notes\",\n                               \"The number of request header fields \"\n                               \"exceeds this server's limit.\");\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00563)\n                              \"Number of request headers exceeds \"\n                              \"LimitRequestFields\");\n                return;\n            }\n\n            if (!strict)\n            {\n                /* Not Strict ('Unsafe' mode), using the legacy parser */\n\n                if (!(value = strchr(last_field, ':'))) { /* Find ':' or */\n                    r->status = HTTP_BAD_REQUEST;   /* abort bad request */\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00564)\n                                  \"Request header field is missing ':' \"\n                                  \"separator: %.*s\", (int)LOG_NAME_MAX_LEN,\n                                  last_field);\n                    return;\n                }\n\n                /* last character of field-name */\n                tmp_field = value - (value > last_field ? 1 : 0);\n\n                *value++ = '\\0'; /* NUL-terminate at colon */\n\n                if (strictspaces && strpbrk(last_field, \" \\t\")) {\n                    r->status = HTTP_BAD_REQUEST;\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(03452)\n                                  \"Request header field name with whitespace \"\n                                  \"(disallowed by StrictWhitespace)\");\n                    return;\n                }\n\n                while (*value == ' ' || *value == '\\t') {\n                     ++value;            /* Skip to start of value   */\n                }\n\n                /* Strip LWS after field-name: */\n                while (tmp_field > last_field\n                           && (*tmp_field == ' ' || *tmp_field == '\\t')) {\n                    *(tmp_field--) = '\\0';\n                }\n\n                if (tmp_field == last_field) {\n                    r->status = HTTP_BAD_REQUEST;\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(03453)\n                                  \"Request header field name was empty\");\n                    return;\n                }\n            }\n            else /* Using strict RFC7230 parsing */\n            {\n                /* Ensure valid token chars before ':' per RFC 7230 3.2.4 */\n                value = (char *)ap_scan_http_token(last_field);\n                if ((value == last_field) || *value != ':') {\n                    r->status = HTTP_BAD_REQUEST;\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02426)\n                                  \"Request header field name is malformed: \"\n                                  \"%.*s\", (int)LOG_NAME_MAX_LEN, last_field);\n                    return;\n                }\n\n                *value++ = '\\0'; /* NUL-terminate last_field name at ':' */\n\n                while (*value == ' ' || *value == '\\t') {\n                    ++value;     /* Skip LWS of value */\n                }\n\n                /* Find invalid, non-HT ctrl char, or the trailing NULL */\n                tmp_field = (char *)ap_scan_http_field_content(value);\n\n                /* Reject value for all garbage input (CTRLs excluding HT)\n                 * e.g. only VCHAR / SP / HT / obs-text are allowed per\n                 * RFC7230 3.2.6 - leave all more explicit rule enforcement\n                 * for specific header handler logic later in the cycle\n                 */\n                if (*tmp_field != '\\0') {\n                    r->status = HTTP_BAD_REQUEST;\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02427)\n                                  \"Request header value is malformed: \"\n                                  \"%.*s\", (int)LOG_NAME_MAX_LEN, value);\n                    return;\n                }\n            }\n\n            apr_table_addn(r->headers_in, last_field, value);\n\n            /* This last_field header is now stored in headers_in,\n             * resume processing of the current input line.\n             */\n        }\n\n        /* Found the terminating empty end-of-headers line, stop. */\n        if (len == 0) {\n            break;\n        }\n\n        /* Keep track of this new header line so that we can extend it across\n         * any obs-fold or parse it on the next loop iteration. We referenced\n         * our previously allocated buffer in r->headers_in,\n         * so allocate a fresh buffer if required.\n         */\n        alloc_len = 0;\n        last_field = field;\n        last_len = len;\n    }\n\n    /* Combine multiple message-header fields with the same\n     * field-name, following RFC 2616, 4.2.\n     */\n    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);\n\n    /* enforce LimitRequestFieldSize for merged headers */\n    apr_table_do(table_do_fn_check_lengths, r, r->headers_in, NULL);\n}", "target": 0}
{"idx": 4751, "func": "static void do_subtitle_out(AVFormatContext *s,\n                            AVOutputStream *ost,\n                            AVInputStream *ist,\n                            AVSubtitle *sub,\n                            int64_t pts)\n{\n    static uint8_t *subtitle_out = NULL;\n    int subtitle_out_max_size = 65536;\n    int subtitle_out_size, nb, i;\n    AVCodecContext *enc;\n    AVPacket pkt;\n\n    if (pts == AV_NOPTS_VALUE) {\n        fprintf(stderr, \"Subtitle packets must have a pts\\n\");\n        if (exit_on_error)\n            av_exit(1);\n        return;\n    }\n\n    enc = ost->st->codec;\n\n    if (!subtitle_out) {\n        subtitle_out = av_malloc(subtitle_out_max_size);\n    }\n\n    /* Note: DVB subtitle need one packet to draw them and one other\n       packet to clear them */\n    /* XXX: signal it in the codec context ? */\n    if (enc->codec_id == CODEC_ID_DVB_SUBTITLE)\n        nb = 2;\n    else\n        nb = 1;\n\n    for(i = 0; i < nb; i++) {\n        subtitle_out_size = avcodec_encode_subtitle(enc, subtitle_out,\n                                                    subtitle_out_max_size, sub);\n\n        av_init_packet(&pkt);\n        pkt.stream_index = ost->index;\n        pkt.data = subtitle_out;\n        pkt.size = subtitle_out_size;\n        pkt.pts = av_rescale_q(pts, ist->st->time_base, ost->st->time_base);\n        if (enc->codec_id == CODEC_ID_DVB_SUBTITLE) {\n            /* XXX: the pts correction is handled here. Maybe handling\n               it in the codec would be better */\n            if (i == 0)\n                pkt.pts += 90 * sub->start_display_time;\n            else\n                pkt.pts += 90 * sub->end_display_time;\n        }\n        write_frame(s, &pkt, ost->st->codec, bitstream_filters[ost->file_index][pkt.stream_index]);\n    }\n}", "target": 1}
{"idx": 4752, "func": "static LHASH_NODE **getrn(LHASH *lh, void *data, unsigned long *rhash)\n\t{\n\tLHASH_NODE **ret,*n1;\n\tunsigned long hash,nn;\n\tint (*cf)();\n\n\thash=(*(lh->hash))(data);\n\tlh->num_hash_calls++;\n\t*rhash=hash;\n\n\tnn=hash%lh->pmax;\n\tif (nn < lh->p)\n\t\tnn=hash%lh->num_alloc_nodes;\n\n\tcf=lh->comp;\n\tret= &(lh->b[(int)nn]);\n\tfor (n1= *ret; n1 != NULL; n1=n1->next)\n\t\t{\n#ifndef NO_HASH_COMP\n\t\tlh->num_hash_comps++;\n\t\tif (n1->hash != hash)\n\t\t\t{\n\t\t\tret= &(n1->next);\n\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\tlh->num_comp_calls++;\n\t\tif ((*cf)(n1->data,data) == 0)\n\t\t\tbreak;\n\t\tret= &(n1->next);\n\t\t}\n\treturn(ret);\n\t}", "target": 1}
{"idx": 4753, "func": "static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, \n\t\t\t\t\t uint32 imagelength, uint32 imagewidth, \n                                         uint32 tw, uint32 tl,\n                                         uint16 spp, uint16 bps)\n  {\n  int     i, status = 1, sample;\n  int     shift_width, bytes_per_pixel;\n  uint16  bytes_per_sample;\n  uint32  row, col;     /* Current row and col of image */\n  uint32  nrow, ncol;   /* Number of rows and cols in current tile */\n  uint32  row_offset, col_offset; /* Output buffer offsets */\n  tsize_t tbytes = 0, tilesize = TIFFTileSize(in);\n  tsample_t s;\n  uint8*  bufp = (uint8*)obuf;\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *tbuff = NULL;\n\n  bytes_per_sample = (bps + 7) / 8;\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    srcbuffs[sample] = NULL;\n    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);\n    if (!tbuff)\n      {\n      TIFFError (\"readSeparateTilesIntoBuffer\", \n                 \"Unable to allocate tile read buffer for sample %d\", sample);\n      for (i = 0; i < sample; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[sample] = tbuff;\n    } \n  /* Each tile contains only the data for a single plane\n   * arranged in scanlines of tw * bytes_per_sample bytes.\n   */\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      for (s = 0; s < spp && s < MAX_SAMPLES; s++)\n        {  /* Read each plane of a tile set into srcbuffs[s] */\n\ttbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);\n        if (tbytes < 0  && !ignore)\n          {\n\t  TIFFError(TIFFFileName(in),\n                 \"Error, can't read tile for row %lu col %lu, \"\n\t\t \"sample %lu\",\n\t\t (unsigned long) col, (unsigned long) row,\n\t\t (unsigned long) s);\n\t\t status = 0;\n          for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n            {\n            tbuff = srcbuffs[sample];\n            if (tbuff != NULL)\n              _TIFFfree(tbuff);\n            }\n          return status;\n\t  }\n\t}\n     /* Tiles on the right edge may be padded out to tw \n      * which must be a multiple of 16.\n      * Ncol represents the visible (non padding) portion.  \n      */\n      if (col + tw > imagewidth)\n        ncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      row_offset = row * (((imagewidth * spp * bps) + 7) / 8);\n      col_offset = ((col * spp * bps) + 7) / 8;\n      bufp = obuf + row_offset + col_offset;\n\n      if ((bps % 8) == 0)\n        {\n        if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,\n\t\t\t\t\t    tw, spp, bps, NULL, 0, 0))\n\t  {\n          status = 0;\n          break;\n      \t  }\n\t}\n      else\n        {\n        bytes_per_pixel  = ((bps * spp) + 7) / 8;\n        if (bytes_per_pixel < (bytes_per_sample + 1))\n          shift_width = bytes_per_pixel;\n        else\n          shift_width = bytes_per_sample + 1;\n\n        switch (shift_width)\n          {\n          case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n      \t            }\n\t          break;\n          case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n       \t            }\n                  break;\n          case 4: \n          case 5:\n          case 6:\n          case 7:\n          case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          default: TIFFError (\"readSeparateTilesIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  status = 0;\n                  break;\n          }\n        }\n      }\n    }\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    tbuff = srcbuffs[sample];\n    if (tbuff != NULL)\n      _TIFFfree(tbuff);\n    }\n \n  return status;\n  }", "target": 0}
{"idx": 4754, "func": "static int read_key(void)\n{\n#if HAVE_TERMIOS_H\n    int n = 1;\n    unsigned char ch;\n    struct timeval tv;\n    fd_set rfds;\n\n    FD_ZERO(&rfds);\n    FD_SET(0, &rfds);\n    tv.tv_sec = 0;\n    tv.tv_usec = 0;\n    n = select(1, &rfds, NULL, NULL, &tv);\n    if (n > 0) {\n        n = read(0, &ch, 1);\n        if (n == 1)\n            return ch;\n\n        return n;\n    }\n#elif HAVE_CONIO_H\n    if(kbhit())\n        return(getch());\n#endif\n    return -1;\n}", "target": 1}
{"idx": 4755, "func": "int64_t avio_seek(AVIOContext *s, int64_t offset, int whence)\n{\n    int64_t offset1;\n    int64_t pos;\n    int force = whence & AVSEEK_FORCE;\n    whence &= ~AVSEEK_FORCE;\n\n    if(!s)\n        return AVERROR(EINVAL);\n\n    pos = s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));\n\n    if (whence != SEEK_CUR && whence != SEEK_SET)\n        return AVERROR(EINVAL);\n\n    if (whence == SEEK_CUR) {\n        offset1 = pos + (s->buf_ptr - s->buffer);\n        if (offset == 0)\n            return offset1;\n        offset += offset1;\n    }\n    offset1 = offset - pos;\n    if (!s->must_flush &&\n        offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {\n        /* can do the seek inside the buffer */\n        s->buf_ptr = s->buffer + offset1;\n    } else if ((!(s->seekable & AVIO_SEEKABLE_NORMAL) ||\n               offset1 <= s->buf_end + SHORT_SEEK_THRESHOLD - s->buffer) &&\n               !s->write_flag && offset1 >= 0 &&\n              (whence != SEEK_END || force)) {\n        while(s->pos < offset && !s->eof_reached)\n            fill_buffer(s);\n        if (s->eof_reached)\n            return AVERROR_EOF;\n        s->buf_ptr = s->buf_end + offset - s->pos;\n    } else {\n        int64_t res;\n\n        if (s->write_flag) {\n            flush_buffer(s);\n            s->must_flush = 1;\n        }\n        if (!s->seek)\n            return AVERROR(EPIPE);\n        if ((res = s->seek(s->opaque, offset, SEEK_SET)) < 0)\n            return res;\n        if (!s->write_flag)\n            s->buf_end = s->buffer;\n        s->buf_ptr = s->buffer;\n        s->pos = offset;\n    }\n    s->eof_reached = 0;\n    return offset;\n}", "target": 0}
{"idx": 4756, "func": "static void decode_profile_tier_level(HEVCContext *s, ProfileTierLevel *ptl)\n{\n    int i;\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb = &lc->gb;\n\n    ptl->profile_space = get_bits(gb, 2);\n    ptl->tier_flag     = get_bits1(gb);\n    ptl->profile_idc   = get_bits(gb, 5);\n    if (ptl->profile_idc == 1)\n        av_log(s->avctx, AV_LOG_DEBUG, \"Main profile bitstream\\n\");\n    else if (ptl->profile_idc == 2)\n        av_log(s->avctx, AV_LOG_DEBUG, \"Main10 profile bitstream\\n\");\n    else\n        av_log(s->avctx, AV_LOG_WARNING, \"No profile indication! (%d)\\n\", ptl->profile_idc);\n\n    for (i = 0; i < 32; i++)\n        ptl->profile_compatibility_flag[i] = get_bits1(gb);\n    ptl->progressive_source_flag    = get_bits1(gb);\n    ptl->interlaced_source_flag     = get_bits1(gb);\n    ptl->non_packed_constraint_flag = get_bits1(gb);\n    ptl->frame_only_constraint_flag = get_bits1(gb);\n\n    skip_bits(gb, 16); // XXX_reserved_zero_44bits[0..15]\n    skip_bits(gb, 16); // XXX_reserved_zero_44bits[16..31]\n    skip_bits(gb, 12); // XXX_reserved_zero_44bits[32..43]\n}", "target": 0}
{"idx": 4757, "func": "char *DSO_convert_filename(DSO *dso, const char *filename)\n\t{\n\tchar *result = NULL;\n\n\tif(dso == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DSO_CONVERT_FILENAME,ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn(NULL);\n\t\t}\n\tif(filename == NULL)\n\t\tfilename = dso->filename;\n\tif(filename == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DSO_CONVERT_FILENAME,DSO_R_NO_FILENAME);\n\t\treturn(NULL);\n\t\t}\n\tif((dso->flags & DSO_FLAG_NO_NAME_TRANSLATION) == 0)\n\t\t{\n\t\tif(dso->name_converter != NULL)\n\t\t\tresult = dso->name_converter(dso, filename);\n\t\telse if(dso->meth->dso_name_converter != NULL)\n\t\t\tresult = dso->meth->dso_name_converter(dso, filename);\n\t\t}\n\tif(result == NULL)\n\t\t{\n\t\tresult = OPENSSL_malloc(strlen(filename) + 1);\n\t\tif(result == NULL)\n\t\t\t{\n\t\t\tDSOerr(DSO_F_DSO_CONVERT_FILENAME,\n\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\treturn(NULL);\n\t\t\t}\n\t\tBUF_strlcpy(result, filename, strlen(filename) + 1);\n\t\t}\n\treturn(result);\n\t}", "target": 0}
{"idx": 4758, "func": "static int test_is_prime(int i)\n{\n    int ret = 0;\n    BIGNUM *r = NULL;\n    int trial;\n\n    if (!TEST_ptr(r = BN_new()))\n        goto err;\n\n    for (trial = 0; trial <= 1; ++trial) {\n        if (!TEST_true(BN_set_word(r, primes[i]))\n                || !TEST_int_eq(BN_is_prime_fasttest_ex(r, 1, ctx, trial, NULL),\n                                1))\n            goto err;\n    }\n\n    ret = 1;\nerr:\n    BN_free(r);\n    return ret;\n}", "target": 0}
{"idx": 4759, "func": "int ff_lpc_calc_coefs(LPCContext *s,\n                      const int32_t *samples, int blocksize, int min_order,\n                      int max_order, int precision,\n                      int32_t coefs[][MAX_LPC_ORDER], int *shift,\n                      enum FFLPCType lpc_type, int lpc_passes,\n                      int omethod, int max_shift, int zero_shift)\n{\n    double autoc[MAX_LPC_ORDER+1];\n    double ref[MAX_LPC_ORDER];\n    double lpc[MAX_LPC_ORDER][MAX_LPC_ORDER];\n    int i, j, pass = 0;\n    int opt_order;\n\n    av_assert2(max_order >= MIN_LPC_ORDER && max_order <= MAX_LPC_ORDER &&\n           lpc_type > FF_LPC_TYPE_FIXED);\n\n    /* reinit LPC context if parameters have changed */\n    if (blocksize != s->blocksize || max_order != s->max_order ||\n        lpc_type  != s->lpc_type) {\n        ff_lpc_end(s);\n        ff_lpc_init(s, blocksize, max_order, lpc_type);\n    }\n\n    if(lpc_passes <= 0)\n        lpc_passes = 2;\n\n    if (lpc_type == FF_LPC_TYPE_LEVINSON || (lpc_type == FF_LPC_TYPE_CHOLESKY && lpc_passes > 1)) {\n        s->lpc_apply_welch_window(samples, blocksize, s->windowed_samples);\n\n        s->lpc_compute_autocorr(s->windowed_samples, blocksize, max_order, autoc);\n\n        compute_lpc_coefs(autoc, max_order, &lpc[0][0], MAX_LPC_ORDER, 0, 1);\n\n        for(i=0; i<max_order; i++)\n            ref[i] = fabs(lpc[i][i]);\n\n        pass++;\n    }\n\n    if (lpc_type == FF_LPC_TYPE_CHOLESKY) {\n        LLSModel m[2];\n        LOCAL_ALIGNED(32, double, var, [FFALIGN(MAX_LPC_ORDER+1,4)]);\n        double av_uninit(weight);\n        memset(var, 0, FFALIGN(MAX_LPC_ORDER+1,4)*sizeof(*var));\n\n        for(j=0; j<max_order; j++)\n            m[0].coeff[max_order-1][j] = -lpc[max_order-1][j];\n\n        for(; pass<lpc_passes; pass++){\n            avpriv_init_lls(&m[pass&1], max_order);\n\n            weight=0;\n            for(i=max_order; i<blocksize; i++){\n                for(j=0; j<=max_order; j++)\n                    var[j]= samples[i-j];\n\n                if(pass){\n                    double eval, inv, rinv;\n                    eval= m[pass&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1);\n                    eval= (512>>pass) + fabs(eval - var[0]);\n                    inv = 1/eval;\n                    rinv = sqrt(inv);\n                    for(j=0; j<=max_order; j++)\n                        var[j] *= rinv;\n                    weight += inv;\n                }else\n                    weight++;\n\n                m[pass&1].update_lls(&m[pass&1], var);\n            }\n            avpriv_solve_lls(&m[pass&1], 0.001, 0);\n        }\n\n        for(i=0; i<max_order; i++){\n            for(j=0; j<max_order; j++)\n                lpc[i][j]=-m[(pass-1)&1].coeff[i][j];\n            ref[i]= sqrt(m[(pass-1)&1].variance[i] / weight) * (blocksize - max_order) / 4000;\n        }\n        for(i=max_order-1; i>0; i--)\n            ref[i] = ref[i-1] - ref[i];\n    }\n\n    opt_order = max_order;\n\n    if(omethod == ORDER_METHOD_EST) {\n        opt_order = estimate_best_order(ref, min_order, max_order);\n        i = opt_order-1;\n        quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift);\n    } else {\n        for(i=min_order-1; i<max_order; i++) {\n            quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift);\n        }\n    }\n\n    return opt_order;\n}", "target": 0}
{"idx": 4760, "func": "static void latm_write_frame_header(AVFormatContext *s, PutBitContext *bs)\n{\n    LATMContext *ctx = s->priv_data;\n    AVCodecContext *avctx = s->streams[0]->codec;\n    GetBitContext gb;\n    int header_size;\n\n    /* AudioMuxElement */\n    put_bits(bs, 1, !!ctx->counter);\n\n    if (!ctx->counter) {\n        init_get_bits(&gb, avctx->extradata, avctx->extradata_size * 8);\n\n        /* StreamMuxConfig */\n        put_bits(bs, 1, 0); /* audioMuxVersion */\n        put_bits(bs, 1, 1); /* allStreamsSameTimeFraming */\n        put_bits(bs, 6, 0); /* numSubFrames */\n        put_bits(bs, 4, 0); /* numProgram */\n        put_bits(bs, 3, 0); /* numLayer */\n\n        /* AudioSpecificConfig */\n        if (ctx->object_type == AOT_ALS) {\n            header_size = avctx->extradata_size-(ctx->off + 7) >> 3;\n            avpriv_copy_bits(bs, &avctx->extradata[ctx->off], header_size);\n        } else {\n            avpriv_copy_bits(bs, avctx->extradata, ctx->off + 3);\n\n            if (!ctx->channel_conf) {\n                avpriv_copy_pce_data(bs, &gb);\n            }\n        }\n\n        put_bits(bs, 3, 0); /* frameLengthType */\n        put_bits(bs, 8, 0xff); /* latmBufferFullness */\n\n        put_bits(bs, 1, 0); /* otherDataPresent */\n        put_bits(bs, 1, 0); /* crcCheckPresent */\n    }\n\n    ctx->counter++;\n    ctx->counter %= ctx->mod;\n}", "target": 1}
{"idx": 4761, "func": "int ff_h264_decode_ref_pic_list_reordering(H264Context *h)\n{\n    int list, index, pic_structure, i;\n\n    print_short_term(h);\n    print_long_term(h);\n\n    for (list = 0; list < h->list_count; list++) {\n        for (i = 0; i < h->ref_count[list]; i++)\n            COPY_PICTURE(&h->ref_list[list][i], &h->default_ref_list[list][i]);\n\n        if (get_bits1(&h->gb)) {\n            int pred = h->curr_pic_num;\n\n            for (index = 0; ; index++) {\n                unsigned int reordering_of_pic_nums_idc = get_ue_golomb_31(&h->gb);\n                unsigned int pic_id;\n                int i;\n                Picture *ref = NULL;\n\n                if (reordering_of_pic_nums_idc == 3)\n                    break;\n\n                if (index >= h->ref_count[list]) {\n                    av_log(h->avctx, AV_LOG_ERROR, \"reference count overflow\\n\");\n                    return -1;\n                }\n\n                if (reordering_of_pic_nums_idc < 3) {\n                    if (reordering_of_pic_nums_idc < 2) {\n                        const unsigned int abs_diff_pic_num = get_ue_golomb(&h->gb) + 1;\n                        int frame_num;\n\n                        if (abs_diff_pic_num > h->max_pic_num) {\n                            av_log(h->avctx, AV_LOG_ERROR, \"abs_diff_pic_num overflow\\n\");\n                            return -1;\n                        }\n\n                        if (reordering_of_pic_nums_idc == 0)\n                            pred -= abs_diff_pic_num;\n                        else\n                            pred += abs_diff_pic_num;\n                        pred &= h->max_pic_num - 1;\n\n                        frame_num = pic_num_extract(h, pred, &pic_structure);\n\n                        for (i = h->short_ref_count - 1; i >= 0; i--) {\n                            ref = h->short_ref[i];\n                            assert(ref->reference);\n                            assert(!ref->long_ref);\n                            if (ref->frame_num == frame_num &&\n                                (ref->reference & pic_structure))\n                                break;\n                        }\n                        if (i >= 0)\n                            ref->pic_id = pred;\n                    } else {\n                        int long_idx;\n                        pic_id = get_ue_golomb(&h->gb); //long_term_pic_idx\n\n                        long_idx = pic_num_extract(h, pic_id, &pic_structure);\n\n                        if (long_idx > 31) {\n                            av_log(h->avctx, AV_LOG_ERROR, \"long_term_pic_idx overflow\\n\");\n                            return -1;\n                        }\n                        ref = h->long_ref[long_idx];\n                        assert(!(ref && !ref->reference));\n                        if (ref && (ref->reference & pic_structure)) {\n                            ref->pic_id = pic_id;\n                            assert(ref->long_ref);\n                            i = 0;\n                        } else {\n                            i = -1;\n                        }\n                    }\n\n                    if (i < 0) {\n                        av_log(h->avctx, AV_LOG_ERROR, \"reference picture missing during reorder\\n\");\n                        memset(&h->ref_list[list][index], 0, sizeof(Picture)); //FIXME\n                    } else {\n                        for (i = index; i + 1 < h->ref_count[list]; i++) {\n                            if (ref->long_ref == h->ref_list[list][i].long_ref &&\n                                ref->pic_id   == h->ref_list[list][i].pic_id)\n                                break;\n                        }\n                        for (; i > index; i--) {\n                            COPY_PICTURE(&h->ref_list[list][i], &h->ref_list[list][i - 1]);\n                        }\n                        COPY_PICTURE(&h->ref_list[list][index], ref);\n                        if (FIELD_PICTURE(h)) {\n                            pic_as_field(&h->ref_list[list][index], pic_structure);\n                        }\n                    }\n                } else {\n                    av_log(h->avctx, AV_LOG_ERROR, \"illegal reordering_of_pic_nums_idc\\n\");\n                    return -1;\n                }\n            }\n        }\n    }\n    for (list = 0; list < h->list_count; list++) {\n        for (index = 0; index < h->ref_count[list]; index++) {\n            if (!h->ref_list[list][index].f.buf[0]) {\n                av_log(h->avctx, AV_LOG_ERROR, \"Missing reference picture\\n\");\n                if (h->default_ref_list[list][0].f.buf[0])\n                    COPY_PICTURE(&h->ref_list[list][index], &h->default_ref_list[list][0]);\n                else\n                    return -1;\n            }\n        }\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 4762, "func": "BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w)\n{\n#ifndef BN_LLONG\n    BN_ULONG ret = 0;\n#else\n    BN_ULLONG ret = 0;\n#endif\n    int i;\n\n    if (w == 0)\n        return (BN_ULONG)-1;\n\n#ifndef BN_LLONG\n    /*\n     * If |w| is too long and we don't have BN_ULLONG then we need to fall\n     * back to using BN_div_word\n     */\n    if (w > ((BN_ULONG)1 << BN_BITS4)) {\n        BIGNUM *tmp = BN_dup(a);\n        if (tmp == NULL)\n            return (BN_ULONG)-1;\n\n        ret = BN_div_word(tmp, w);\n        BN_free(tmp);\n\n        return ret;\n    }\n#endif\n\n    bn_check_top(a);\n    w &= BN_MASK2;\n    for (i = a->top - 1; i >= 0; i--) {\n#ifndef BN_LLONG\n        /*\n         * We can assume here that | w <= ((BN_ULONG)1 << BN_BITS4) | and so\n         * | ret < ((BN_ULONG)1 << BN_BITS4) | and therefore the shifts here are\n         * safe and will not overflow\n         */\n        ret = ((ret << BN_BITS4) | ((a->d[i] >> BN_BITS4) & BN_MASK2l)) % w;\n        ret = ((ret << BN_BITS4) | (a->d[i] & BN_MASK2l)) % w;\n#else\n        ret = (BN_ULLONG) (((ret << (BN_ULLONG) BN_BITS2) | a->d[i]) %\n                           (BN_ULLONG) w);\n#endif\n    }\n    return ((BN_ULONG)ret);\n}", "target": 1}
{"idx": 4763, "func": "void *OPENSSL_sk_delete(OPENSSL_STACK *st, int loc)\n{\n    const char *ret;\n\n    if (st == NULL || loc < 0 || loc >= st->num)\n        return NULL;\n\n    ret = st->data[loc];\n    if (loc != st->num - 1)\n         memmove(&st->data[loc], &st->data[loc + 1],\n                 sizeof(st->data[0]) * (st->num - loc - 1));\n    st->num--;\n    return (void *)ret;\n}", "target": 1}
{"idx": 4764, "func": "static int RSA_eay_private_decrypt(int flen, const unsigned char *from,\n\t     unsigned char *to, RSA *rsa, int padding)\n\t{\n\tBIGNUM *f, *ret, *br;\n\tint j,num=0,r= -1;\n\tunsigned char *p;\n\tunsigned char *buf=NULL;\n\tBN_CTX *ctx=NULL;\n\tint local_blinding = 0;\n\tBN_BLINDING *blinding = NULL;\n\n\tif((ctx = BN_CTX_new()) == NULL) goto err;\n\tBN_CTX_start(ctx);\n\tf   = BN_CTX_get(ctx);\n\tbr  = BN_CTX_get(ctx);\n\tret = BN_CTX_get(ctx);\n\tnum = BN_num_bytes(rsa->n);\n\tbuf = OPENSSL_malloc(num);\n\tif(!f || !ret || !buf)\n\t\t{\n\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\t/* This check was for equality but PGP does evil things\n\t * and chops off the top '0' bytes */\n\tif (flen > num)\n\t\t{\n\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);\n\t\tgoto err;\n\t\t}\n\n\t/* make data into a big number */\n\tif (BN_bin2bn(from,(int)flen,f) == NULL) goto err;\n\n\tif (BN_ucmp(f, rsa->n) >= 0)\n\t\t{\n\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);\n\t\tgoto err;\n\t\t}\n\n\tif (!(rsa->flags & RSA_FLAG_NO_BLINDING))\n\t\t{\n\t\tblinding = rsa_get_blinding(rsa, &local_blinding, ctx);\n\t\tif (blinding == NULL)\n\t\t\t{\n\t\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t\n\tif (blinding != NULL)\n\t\tif (!rsa_blinding_convert(blinding, local_blinding, f, br, ctx))\n\t\t\tgoto err;\n\n\t/* do the decrypt */\n\tif ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||\n\t\t((rsa->p != NULL) &&\n\t\t(rsa->q != NULL) &&\n\t\t(rsa->dmp1 != NULL) &&\n\t\t(rsa->dmq1 != NULL) &&\n\t\t(rsa->iqmp != NULL)) )\n\t\t{\n\t\tif (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;\n\t\t}\n\telse\n\t\t{\n\t\tBIGNUM local_d;\n\t\tBIGNUM *d = NULL;\n\t\t\n\t\tif (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))\n\t\t\t{\n\t\t\td = &local_d;\n\t\t\tBN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n\t\t\t}\n\t\telse\n\t\t\td = rsa->d;\n\n\t\tMONT_HELPER(rsa, ctx, n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);\n\t\tif (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,\n\t\t\t\trsa->_method_mod_n))\n\t\t  goto err;\n\t\t}\n\n\tif (blinding)\n\t\tif (!rsa_blinding_invert(blinding, local_blinding, ret, br, ctx))\n\t\t\tgoto err;\n\n\tp=buf;\n\tj=BN_bn2bin(ret,p); /* j is only used with no-padding mode */\n\n\tswitch (padding)\n\t\t{\n\tcase RSA_PKCS1_PADDING:\n\t\tr=RSA_padding_check_PKCS1_type_2(to,num,buf,j,num);\n\t\tbreak;\n#ifndef OPENSSL_NO_SHA\n        case RSA_PKCS1_OAEP_PADDING:\n\t        r=RSA_padding_check_PKCS1_OAEP(to,num,buf,j,num,NULL,0);\n                break;\n#endif\n \tcase RSA_SSLV23_PADDING:\n\t\tr=RSA_padding_check_SSLv23(to,num,buf,j,num);\n\t\tbreak;\n\tcase RSA_NO_PADDING:\n\t\tr=RSA_padding_check_none(to,num,buf,j,num);\n\t\tbreak;\n\tdefault:\n\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);\n\t\tgoto err;\n\t\t}\n\tif (r < 0)\n\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_PADDING_CHECK_FAILED);\n\nerr:\n\tif (ctx != NULL)\n\t\t{\n\t\tBN_CTX_end(ctx);\n\t\tBN_CTX_free(ctx);\n\t\t}\n\tif (buf != NULL)\n\t\t{\n\t\tOPENSSL_cleanse(buf,num);\n\t\tOPENSSL_free(buf);\n\t\t}\n\treturn(r);\n\t}", "target": 0}
{"idx": 4765, "func": "uint8_t* av_packet_get_side_data(AVPacket *pkt, enum AVPacketSideDataType type,\n                                 int *size)\n{\n    int i;\n\n    for (i = 0; i < pkt->side_data_elems; i++) {\n        if (pkt->side_data[i].type == type) {\n            if (size)\n                *size = pkt->side_data[i].size;\n            return pkt->side_data[i].data;\n        }\n    }\n    return NULL;\n}", "target": 1}
{"idx": 4766, "func": "static int parse_object_segment(AVCodecContext *avctx,\n                                  const uint8_t *buf, int buf_size)\n{\n    PGSSubContext *ctx = avctx->priv_data;\n    PGSSubObject *object;\n\n    uint8_t sequence_desc;\n    unsigned int rle_bitmap_len, width, height;\n    int id;\n\n    if (buf_size <= 4)\n        return AVERROR_INVALIDDATA;\n    buf_size -= 4;\n\n    id = bytestream_get_be16(&buf);\n    object = find_object(id, &ctx->objects);\n    if (!object) {\n        if (ctx->objects.count >= MAX_EPOCH_OBJECTS) {\n            av_log(avctx, AV_LOG_ERROR, \"Too many objects in epoch\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        object = &ctx->objects.object[ctx->objects.count++];\n        object->id = id;\n    }\n\n    /* skip object version number */\n    buf += 1;\n\n    /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */\n    sequence_desc = bytestream_get_byte(&buf);\n\n    if (!(sequence_desc & 0x80)) {\n        /* Additional RLE data */\n        if (buf_size > object->rle_remaining_len)\n            return AVERROR_INVALIDDATA;\n\n        memcpy(object->rle + object->rle_data_len, buf, buf_size);\n        object->rle_data_len += buf_size;\n        object->rle_remaining_len -= buf_size;\n\n        return 0;\n    }\n\n    if (buf_size <= 7)\n        return AVERROR_INVALIDDATA;\n    buf_size -= 7;\n\n    /* Decode rle bitmap length, stored size includes width/height data */\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n    /* Get bitmap dimensions from data */\n    width  = bytestream_get_be16(&buf);\n    height = bytestream_get_be16(&buf);\n\n    /* Make sure the bitmap is not too large */\n    if (avctx->width < width || avctx->height < height) {\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions larger than video.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    object->w = width;\n    object->h = height;\n\n    av_fast_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);\n\n    if (!object->rle)\n        return AVERROR(ENOMEM);\n\n    memcpy(object->rle, buf, buf_size);\n    object->rle_data_len = buf_size;\n    object->rle_remaining_len = rle_bitmap_len - buf_size;\n\n    return 0;\n}", "target": 0}
{"idx": 4767, "func": "static int srp_Verify_N_and_g(const BIGNUM *N, const BIGNUM *g)\n{\n    BN_CTX *bn_ctx = BN_CTX_new();\n    BIGNUM *p = BN_new();\n    BIGNUM *r = BN_new();\n    int ret =\n        g != NULL && N != NULL && bn_ctx != NULL && BN_is_odd(N) &&\n        BN_is_prime_ex(N, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) == 1 &&\n        p != NULL && BN_rshift1(p, N) &&\n        /* p = (N-1)/2 */\n        BN_is_prime_ex(p, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) == 1 &&\n        r != NULL &&\n        /* verify g^((N-1)/2) == -1 (mod N) */\n        BN_mod_exp(r, g, p, N, bn_ctx) &&\n        BN_add_word(r, 1) && BN_cmp(r, N) == 0;\n\n    BN_free(r);\n    BN_free(p);\n    BN_CTX_free(bn_ctx);\n    return ret;\n}", "target": 1}
{"idx": 4768, "func": "static int dpcm_decode_frame(AVCodecContext *avctx,\n                             void *data, int *data_size,\n                             AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    DPCMContext *s = avctx->priv_data;\n    int in, out = 0;\n    int predictor[2];\n    int ch = 0;\n    int stereo = s->channels - 1;\n    short *output_samples = data;\n    int shift[2];\n    unsigned char byte;\n    short diff;\n\n    if (!buf_size)\n        return 0;\n\n    // almost every DPCM variant expands one byte of data into two\n    if(*data_size/2 < buf_size)\n        return -1;\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ROQ_DPCM:\n        if (stereo) {\n            predictor[0] = buf[7] << 8;\n            predictor[1] = buf[6] << 8;\n        } else {\n            predictor[0] = AV_RL16(&buf[6]);\n        }\n        SE_16BIT(predictor[0]);\n        SE_16BIT(predictor[1]);\n\n        /* decode the samples */\n        for (in = 8, out = 0; in < buf_size; in++, out++) {\n            predictor[ch] += s->roq_square_array[buf[in]];\n            predictor[ch] = av_clip_int16(predictor[ch]);\n            output_samples[out] = predictor[ch];\n\n            /* toggle channel */\n            ch ^= stereo;\n        }\n        break;\n\n    case CODEC_ID_INTERPLAY_DPCM:\n        in = 6;  /* skip over the stream mask and stream length */\n        predictor[0] = AV_RL16(&buf[in]);\n        in += 2;\n        SE_16BIT(predictor[0])\n        output_samples[out++] = predictor[0];\n        if (stereo) {\n            predictor[1] = AV_RL16(&buf[in]);\n            in += 2;\n            SE_16BIT(predictor[1])\n            output_samples[out++] = predictor[1];\n        }\n\n        while (in < buf_size) {\n            predictor[ch] += interplay_delta_table[buf[in++]];\n            predictor[ch] = av_clip_int16(predictor[ch]);\n            output_samples[out++] = predictor[ch];\n\n            /* toggle channel */\n            ch ^= stereo;\n        }\n\n        break;\n\n    case CODEC_ID_XAN_DPCM:\n        in = 0;\n        shift[0] = shift[1] = 4;\n        predictor[0] = AV_RL16(&buf[in]);\n        in += 2;\n        SE_16BIT(predictor[0]);\n        if (stereo) {\n            predictor[1] = AV_RL16(&buf[in]);\n            in += 2;\n            SE_16BIT(predictor[1]);\n        }\n\n        while (in < buf_size) {\n            byte = buf[in++];\n            diff = (byte & 0xFC) << 8;\n            if ((byte & 0x03) == 3)\n                shift[ch]++;\n            else\n                shift[ch] -= (2 * (byte & 3));\n            /* saturate the shifter to a lower limit of 0 */\n            if (shift[ch] < 0)\n                shift[ch] = 0;\n\n            diff >>= shift[ch];\n            predictor[ch] += diff;\n\n            predictor[ch] = av_clip_int16(predictor[ch]);\n            output_samples[out++] = predictor[ch];\n\n            /* toggle channel */\n            ch ^= stereo;\n        }\n        break;\n    case CODEC_ID_SOL_DPCM:\n        in = 0;\n        if (avctx->codec_tag != 3) {\n            if(*data_size/4 < buf_size)\n                return -1;\n            while (in < buf_size) {\n                int n1, n2;\n                n1 = (buf[in] >> 4) & 0xF;\n                n2 = buf[in++] & 0xF;\n                s->sample[0] += s->sol_table[n1];\n                if (s->sample[0] < 0)   s->sample[0] = 0;\n                if (s->sample[0] > 255) s->sample[0] = 255;\n                output_samples[out++] = (s->sample[0] - 128) << 8;\n                s->sample[stereo] += s->sol_table[n2];\n                if (s->sample[stereo] < 0)   s->sample[stereo] = 0;\n                if (s->sample[stereo] > 255) s->sample[stereo] = 255;\n                output_samples[out++] = (s->sample[stereo] - 128) << 8;\n            }\n        } else {\n            while (in < buf_size) {\n                int n;\n                n = buf[in++];\n                if (n & 0x80) s->sample[ch] -= s->sol_table[n & 0x7F];\n                else s->sample[ch] += s->sol_table[n & 0x7F];\n                s->sample[ch] = av_clip_int16(s->sample[ch]);\n                output_samples[out++] = s->sample[ch];\n                /* toggle channel */\n                ch ^= stereo;\n            }\n        }\n        break;\n    }\n\n    *data_size = out * sizeof(short);\n    return buf_size;\n}", "target": 1}
{"idx": 4769, "func": "int ff_update_duplicate_context(MpegEncContext *dst, MpegEncContext *src)\n{\n    MpegEncContext bak;\n    int i, ret;\n    // FIXME copy only needed parts\n    // START_TIMER\n    backup_duplicate_context(&bak, dst);\n    memcpy(dst, src, sizeof(MpegEncContext));\n    backup_duplicate_context(dst, &bak);\n    for (i = 0; i < 12; i++) {\n        dst->pblocks[i] = &dst->block[i];\n    }\n    if (dst->avctx->codec_tag == AV_RL32(\"VCR2\"))\n        exchange_uv(dst);\n    if (!dst->edge_emu_buffer &&\n        (ret = frame_size_alloc(dst, dst->linesize)) < 0) {\n        av_log(dst->avctx, AV_LOG_ERROR, \"failed to allocate context \"\n               \"scratch buffers.\\n\");\n        return ret;\n    }\n    // STOP_TIMER(\"update_duplicate_context\")\n    // about 10k cycles / 0.01 sec for  1000frames on 1ghz with 2 threads\n    return 0;\n}", "target": 1}
{"idx": 4770, "func": "static void stereo_processing(PSContext *ps, float (*l)[32][2], float (*r)[32][2], int is34)\n{\n    int e, b, k;\n\n    float (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H11;\n    float (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H12;\n    float (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H21;\n    float (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H22;\n    int8_t *opd_hist = ps->opd_hist;\n    int8_t *ipd_hist = ps->ipd_hist;\n    int8_t iid_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n    int8_t icc_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n    int8_t ipd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n    int8_t opd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n    int8_t (*iid_mapped)[PS_MAX_NR_IIDICC] = iid_mapped_buf;\n    int8_t (*icc_mapped)[PS_MAX_NR_IIDICC] = icc_mapped_buf;\n    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;\n    int8_t (*opd_mapped)[PS_MAX_NR_IIDICC] = opd_mapped_buf;\n    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;\n    const float (*H_LUT)[8][4] = (PS_BASELINE || ps->icc_mode < 3) ? HA : HB;\n\n    //Remapping\n    if (ps->num_env_old) {\n        memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));\n        memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));\n        memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));\n        memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));\n        memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));\n        memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));\n        memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));\n        memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));\n    }\n\n    if (is34) {\n        remap34(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);\n        remap34(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);\n        if (ps->enable_ipdopd) {\n            remap34(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n            remap34(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n        }\n        if (!ps->is34bands_old) {\n            map_val_20_to_34(H11[0][0]);\n            map_val_20_to_34(H11[1][0]);\n            map_val_20_to_34(H12[0][0]);\n            map_val_20_to_34(H12[1][0]);\n            map_val_20_to_34(H21[0][0]);\n            map_val_20_to_34(H21[1][0]);\n            map_val_20_to_34(H22[0][0]);\n            map_val_20_to_34(H22[1][0]);\n            ipdopd_reset(ipd_hist, opd_hist);\n        }\n    } else {\n        remap20(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);\n        remap20(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);\n        if (ps->enable_ipdopd) {\n            remap20(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n            remap20(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n        }\n        if (ps->is34bands_old) {\n            map_val_34_to_20(H11[0][0]);\n            map_val_34_to_20(H11[1][0]);\n            map_val_34_to_20(H12[0][0]);\n            map_val_34_to_20(H12[1][0]);\n            map_val_34_to_20(H21[0][0]);\n            map_val_34_to_20(H21[1][0]);\n            map_val_34_to_20(H22[0][0]);\n            map_val_34_to_20(H22[1][0]);\n            ipdopd_reset(ipd_hist, opd_hist);\n        }\n    }\n\n    //Mixing\n    for (e = 0; e < ps->num_env; e++) {\n        for (b = 0; b < NR_PAR_BANDS[is34]; b++) {\n            float h11, h12, h21, h22;\n            h11 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][0];\n            h12 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][1];\n            h21 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][2];\n            h22 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][3];\n            if (!PS_BASELINE && ps->enable_ipdopd && b < ps->nr_ipdopd_par) {\n                //The spec say says to only run this smoother when enable_ipdopd\n                //is set but the reference decoder appears to run it constantly\n                float h11i, h12i, h21i, h22i;\n                float ipd_adj_re, ipd_adj_im;\n                int opd_idx = opd_hist[b] * 8 + opd_mapped[e][b];\n                int ipd_idx = ipd_hist[b] * 8 + ipd_mapped[e][b];\n                float opd_re = pd_re_smooth[opd_idx];\n                float opd_im = pd_im_smooth[opd_idx];\n                float ipd_re = pd_re_smooth[ipd_idx];\n                float ipd_im = pd_im_smooth[ipd_idx];\n                opd_hist[b] = opd_idx & 0x3F;\n                ipd_hist[b] = ipd_idx & 0x3F;\n\n                ipd_adj_re = opd_re*ipd_re + opd_im*ipd_im;\n                ipd_adj_im = opd_im*ipd_re - opd_re*ipd_im;\n                h11i = h11 * opd_im;\n                h11  = h11 * opd_re;\n                h12i = h12 * ipd_adj_im;\n                h12  = h12 * ipd_adj_re;\n                h21i = h21 * opd_im;\n                h21  = h21 * opd_re;\n                h22i = h22 * ipd_adj_im;\n                h22  = h22 * ipd_adj_re;\n                H11[1][e+1][b] = h11i;\n                H12[1][e+1][b] = h12i;\n                H21[1][e+1][b] = h21i;\n                H22[1][e+1][b] = h22i;\n            }\n            H11[0][e+1][b] = h11;\n            H12[0][e+1][b] = h12;\n            H21[0][e+1][b] = h21;\n            H22[0][e+1][b] = h22;\n        }\n        for (k = 0; k < NR_BANDS[is34]; k++) {\n            float h[2][4];\n            float h_step[2][4];\n            int start = ps->border_position[e];\n            int stop  = ps->border_position[e+1];\n            float width = 1.f / (stop - start);\n            b = k_to_i[k];\n            h[0][0] = H11[0][e][b];\n            h[0][1] = H12[0][e][b];\n            h[0][2] = H21[0][e][b];\n            h[0][3] = H22[0][e][b];\n            if (!PS_BASELINE && ps->enable_ipdopd) {\n            //Is this necessary? ps_04_new seems unchanged\n            if ((is34 && k <= 13 && k >= 9) || (!is34 && k <= 1)) {\n                h[1][0] = -H11[1][e][b];\n                h[1][1] = -H12[1][e][b];\n                h[1][2] = -H21[1][e][b];\n                h[1][3] = -H22[1][e][b];\n            } else {\n                h[1][0] = H11[1][e][b];\n                h[1][1] = H12[1][e][b];\n                h[1][2] = H21[1][e][b];\n                h[1][3] = H22[1][e][b];\n            }\n            }\n            //Interpolation\n            h_step[0][0] = (H11[0][e+1][b] - h[0][0]) * width;\n            h_step[0][1] = (H12[0][e+1][b] - h[0][1]) * width;\n            h_step[0][2] = (H21[0][e+1][b] - h[0][2]) * width;\n            h_step[0][3] = (H22[0][e+1][b] - h[0][3]) * width;\n            if (!PS_BASELINE && ps->enable_ipdopd) {\n                h_step[1][0] = (H11[1][e+1][b] - h[1][0]) * width;\n                h_step[1][1] = (H12[1][e+1][b] - h[1][1]) * width;\n                h_step[1][2] = (H21[1][e+1][b] - h[1][2]) * width;\n                h_step[1][3] = (H22[1][e+1][b] - h[1][3]) * width;\n            }\n            ps->dsp.stereo_interpolate[!PS_BASELINE && ps->enable_ipdopd](\n                l[k] + start + 1, r[k] + start + 1,\n                h, h_step, stop - start);\n        }\n    }\n}", "target": 0}
{"idx": 4771, "func": "void *BUF_memdup(const void *data, size_t siz)\n{\n    void *ret;\n\n    if (data == NULL || siz >= INT_MAX)\n        return NULL;\n\n    ret = OPENSSL_malloc(siz);\n    if (ret == NULL) {\n        BUFerr(BUF_F_BUF_MEMDUP, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    return memcpy(ret, data, siz);\n}", "target": 1}
{"idx": 4772, "func": "static inline void codeblock(DiracContext *s, SubBand *b,\n                             GetBitContext *gb, DiracArith *c,\n                             int left, int right, int top, int bottom,\n                             int blockcnt_one, int is_arith)\n{\n    int x, y, zero_block;\n    int qoffset, qfactor;\n    uint8_t *buf;\n\n    /* check for any coded coefficients in this codeblock */\n    if (!blockcnt_one) {\n        if (is_arith)\n            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);\n        else\n            zero_block = get_bits1(gb);\n\n        if (zero_block)\n            return;\n    }\n\n    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {\n        int quant = b->quant;\n        if (is_arith)\n            quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);\n        else\n            quant += dirac_get_se_golomb(gb);\n        if (quant < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid quant\\n\");\n            return;\n        }\n        b->quant = quant;\n    }\n\n    if (b->quant > 115) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Unsupported quant %d\\n\", b->quant);\n        b->quant = 0;\n        return;\n    }\n\n    qfactor = ff_dirac_qscale_tab[b->quant];\n    /* TODO: context pointer? */\n    if (!s->num_refs)\n        qoffset = ff_dirac_qoffset_intra_tab[b->quant] + 2;\n    else\n        qoffset = ff_dirac_qoffset_inter_tab[b->quant] + 2;\n\n    buf = b->ibuf + top * b->stride;\n    if (is_arith) {\n        for (y = top; y < bottom; y++) {\n            for (x = left; x < right; x++) {\n                if (b->pshift) {\n                    coeff_unpack_arith_10(c, qfactor, qoffset, b, (int32_t*)(buf)+x, x, y);\n                } else {\n                    coeff_unpack_arith_8(c, qfactor, qoffset, b, (int16_t*)(buf)+x, x, y);\n                }\n            }\n            buf += b->stride;\n        }\n    } else {\n        for (y = top; y < bottom; y++) {\n            for (x = left; x < right; x++) {\n                int val = coeff_unpack_golomb(gb, qfactor, qoffset);\n                if (b->pshift) {\n                    AV_WN32(&buf[4*x], val);\n                } else {\n                    AV_WN16(&buf[2*x], val);\n                }\n            }\n            buf += b->stride;\n         }\n     }\n}", "target": 1}
{"idx": 4773, "func": "static void configure_handshake_ctx(SSL_CTX *server_ctx, SSL_CTX *server2_ctx,\n                                    SSL_CTX *client_ctx,\n                                    const SSL_TEST_CTX *test_ctx,\n                                    CTX_DATA *server_ctx_data,\n                                    CTX_DATA *server2_ctx_data,\n                                    CTX_DATA *client_ctx_data)\n{\n    unsigned char *ticket_keys;\n    size_t ticket_key_len;\n\n    switch (test_ctx->client_verify_callback) {\n    case SSL_TEST_VERIFY_ACCEPT_ALL:\n        SSL_CTX_set_cert_verify_callback(client_ctx, &verify_accept_cb,\n                                         NULL);\n        break;\n    case SSL_TEST_VERIFY_REJECT_ALL:\n        SSL_CTX_set_cert_verify_callback(client_ctx, &verify_reject_cb,\n                                         NULL);\n        break;\n    default:\n        break;\n    }\n\n    /* link the two contexts for SNI purposes */\n    switch (test_ctx->servername_callback) {\n    case SSL_TEST_SERVERNAME_IGNORE_MISMATCH:\n        SSL_CTX_set_tlsext_servername_callback(server_ctx, servername_ignore_cb);\n        SSL_CTX_set_tlsext_servername_arg(server_ctx, server2_ctx);\n        break;\n    case SSL_TEST_SERVERNAME_REJECT_MISMATCH:\n        SSL_CTX_set_tlsext_servername_callback(server_ctx, servername_reject_cb);\n        SSL_CTX_set_tlsext_servername_arg(server_ctx, server2_ctx);\n        break;\n    default:\n        break;\n    }\n\n    /*\n     * The initial_ctx/session_ctx always handles the encrypt/decrypt of the\n     * session ticket. This ticket_key callback is assigned to the second\n     * session (assigned via SNI), and should never be invoked\n     */\n    if (server2_ctx != NULL)\n        SSL_CTX_set_tlsext_ticket_key_cb(server2_ctx,\n                                         do_not_call_session_ticket_cb);\n\n    if (test_ctx->session_ticket_expected == SSL_TEST_SESSION_TICKET_BROKEN) {\n        SSL_CTX_set_tlsext_ticket_key_cb(server_ctx, broken_session_ticket_cb);\n    }\n    if (test_ctx->server_npn_protocols != NULL) {\n        parse_protos(test_ctx->server_npn_protocols,\n                     &server_ctx_data->npn_protocols,\n                     &server_ctx_data->npn_protocols_len);\n        SSL_CTX_set_next_protos_advertised_cb(server_ctx, server_npn_cb,\n                                              server_ctx_data);\n    }\n    if (test_ctx->server2_npn_protocols != NULL) {\n        parse_protos(test_ctx->server2_npn_protocols,\n                     &server2_ctx_data->npn_protocols,\n                     &server2_ctx_data->npn_protocols_len);\n        OPENSSL_assert(server2_ctx != NULL);\n        SSL_CTX_set_next_protos_advertised_cb(server2_ctx, server_npn_cb,\n                                              server2_ctx_data);\n    }\n    if (test_ctx->client_npn_protocols != NULL) {\n        parse_protos(test_ctx->client_npn_protocols,\n                     &client_ctx_data->npn_protocols,\n                     &client_ctx_data->npn_protocols_len);\n        SSL_CTX_set_next_proto_select_cb(client_ctx, client_npn_cb,\n                                         client_ctx_data);\n    }\n    if (test_ctx->server_alpn_protocols != NULL) {\n        parse_protos(test_ctx->server_alpn_protocols,\n                     &server_ctx_data->alpn_protocols,\n                     &server_ctx_data->alpn_protocols_len);\n        SSL_CTX_set_alpn_select_cb(server_ctx, server_alpn_cb, server_ctx_data);\n    }\n    if (test_ctx->server2_alpn_protocols != NULL) {\n        OPENSSL_assert(server2_ctx != NULL);\n        parse_protos(test_ctx->server2_alpn_protocols,\n                     &server2_ctx_data->alpn_protocols,\n                     &server2_ctx_data->alpn_protocols_len);\n        SSL_CTX_set_alpn_select_cb(server2_ctx, server_alpn_cb, server2_ctx_data);\n    }\n    if (test_ctx->client_alpn_protocols != NULL) {\n        unsigned char *alpn_protos = NULL;\n        size_t alpn_protos_len;\n        parse_protos(test_ctx->client_alpn_protocols,\n                     &alpn_protos, &alpn_protos_len);\n        /* Reversed return value convention... */\n        OPENSSL_assert(SSL_CTX_set_alpn_protos(client_ctx, alpn_protos,\n                                               alpn_protos_len) == 0);\n        OPENSSL_free(alpn_protos);\n    }\n    /*\n     * Use fixed session ticket keys so that we can decrypt a ticket created with\n     * one CTX in another CTX. Don't address server2 for the moment.\n     */\n    ticket_key_len = SSL_CTX_set_tlsext_ticket_keys(server_ctx, NULL, 0);\n    ticket_keys = OPENSSL_zalloc(ticket_key_len);\n    OPENSSL_assert(ticket_keys != NULL);\n    OPENSSL_assert(SSL_CTX_set_tlsext_ticket_keys(server_ctx, ticket_keys,\n                                                  ticket_key_len) == 1);\n    OPENSSL_free(ticket_keys);\n}", "target": 0}
{"idx": 4774, "func": "static av_always_inline void filter_mb_mbaff_edgev(const H264Context *h, uint8_t *pix,\n                                                   int stride,\n                                                   const int16_t bS[7], int bsi,\n                                                   int qp, int a, int b,\n                                                   int intra)\n{\n    const unsigned int index_a = qp + a;\n    const int alpha = alpha_table[index_a];\n    const int beta  = beta_table[qp + b];\n    if (alpha ==0 || beta == 0) return;\n\n    if( bS[0] < 4 || !intra ) {\n        int8_t tc[4];\n        tc[0] = tc0_table[index_a][bS[0*bsi]];\n        tc[1] = tc0_table[index_a][bS[1*bsi]];\n        tc[2] = tc0_table[index_a][bS[2*bsi]];\n        tc[3] = tc0_table[index_a][bS[3*bsi]];\n        h->h264dsp.h264_h_loop_filter_luma_mbaff(pix, stride, alpha, beta, tc);\n    } else {\n        h->h264dsp.h264_h_loop_filter_luma_mbaff_intra(pix, stride, alpha, beta);\n    }\n}", "target": 1}
{"idx": 4775, "func": "static void allocate_buffers(FLACContext *s){\n    int i;\n\n    assert(s->max_blocksize);\n\n    if(s->max_framesize == 0 && s->max_blocksize){\n        s->max_framesize= (s->channels * s->bps * s->max_blocksize + 7)/ 8; //FIXME header overhead\n    }\n\n    for (i = 0; i < s->channels; i++)\n    {\n        s->decoded[i] = av_realloc(s->decoded[i], sizeof(int32_t)*s->max_blocksize);\n    }\n\n    if(s->allocated_bitstream_size < s->max_framesize)\n        s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize);\n}", "target": 0}
{"idx": 4776, "func": "static int scaling_list_data(GetBitContext *gb, AVCodecContext *avctx, ScalingList *sl, HEVCSPS *sps)\n{\n    uint8_t scaling_list_pred_mode_flag;\n    int32_t scaling_list_dc_coef[2][6];\n    int size_id, matrix_id, pos;\n    int i;\n\n    for (size_id = 0; size_id < 4; size_id++)\n        for (matrix_id = 0; matrix_id < 6; matrix_id += ((size_id == 3) ? 3 : 1)) {\n            scaling_list_pred_mode_flag = get_bits1(gb);\n            if (!scaling_list_pred_mode_flag) {\n                unsigned int delta = get_ue_golomb_long(gb);\n                /* Only need to handle non-zero delta. Zero means default,\n                 * which should already be in the arrays. */\n                if (delta) {\n                    // Copy from previous array.\n                    if (matrix_id < delta) {\n                        av_log(avctx, AV_LOG_ERROR,\n                               \"Invalid delta in scaling list data: %d.\\n\", delta);\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    memcpy(sl->sl[size_id][matrix_id],\n                           sl->sl[size_id][matrix_id - delta],\n                           size_id > 0 ? 64 : 16);\n                    if (size_id > 1)\n                        sl->sl_dc[size_id - 2][matrix_id] = sl->sl_dc[size_id - 2][matrix_id - delta];\n                }\n            } else {\n                int next_coef, coef_num;\n                int32_t scaling_list_delta_coef;\n\n                next_coef = 8;\n                coef_num  = FFMIN(64, 1 << (4 + (size_id << 1)));\n                if (size_id > 1) {\n                    scaling_list_dc_coef[size_id - 2][matrix_id] = get_se_golomb(gb) + 8;\n                    next_coef = scaling_list_dc_coef[size_id - 2][matrix_id];\n                    sl->sl_dc[size_id - 2][matrix_id] = next_coef;\n                }\n                for (i = 0; i < coef_num; i++) {\n                    if (size_id == 0)\n                        pos = 4 * ff_hevc_diag_scan4x4_y[i] +\n                                  ff_hevc_diag_scan4x4_x[i];\n                    else\n                        pos = 8 * ff_hevc_diag_scan8x8_y[i] +\n                                  ff_hevc_diag_scan8x8_x[i];\n\n                    scaling_list_delta_coef = get_se_golomb(gb);\n                    next_coef = (next_coef + scaling_list_delta_coef + 256) % 256;\n                    sl->sl[size_id][matrix_id][pos] = next_coef;\n                }\n            }\n        }\n\n    if (sps->chroma_format_idc == 3) {\n        for (i = 0; i < 64; i++) {\n            sl->sl[3][1][i] = sl->sl[2][1][i];\n            sl->sl[3][2][i] = sl->sl[2][2][i];\n            sl->sl[3][4][i] = sl->sl[2][4][i];\n            sl->sl[3][5][i] = sl->sl[2][5][i];\n        }\n        sl->sl_dc[1][1] = sl->sl_dc[0][1];\n        sl->sl_dc[1][2] = sl->sl_dc[0][2];\n        sl->sl_dc[1][4] = sl->sl_dc[0][4];\n        sl->sl_dc[1][5] = sl->sl_dc[0][5];\n    }\n\n\n    return 0;\n}", "target": 0}
{"idx": 4777, "func": "static void fill_buffer(AVIOContext *s)\n{\n    int max_buffer_size = s->max_packet_size ?\n                          s->max_packet_size : IO_BUFFER_SIZE;\n    uint8_t *dst        = s->buf_end - s->buffer + max_buffer_size < s->buffer_size ?\n                          s->buf_end : s->buffer;\n    int len             = s->buffer_size - (dst - s->buffer);\n\n    /* can't fill the buffer without read_packet, just set EOF if appropriate */\n    if (!s->read_packet && s->buf_ptr >= s->buf_end)\n        s->eof_reached = 1;\n\n    /* no need to do anything if EOF already reached */\n    if (s->eof_reached)\n        return;\n\n    if (s->update_checksum && dst == s->buffer) {\n        if (s->buf_end > s->checksum_ptr)\n            s->checksum = s->update_checksum(s->checksum, s->checksum_ptr,\n                                             s->buf_end - s->checksum_ptr);\n        s->checksum_ptr = s->buffer;\n    }\n\n    /* make buffer smaller in case it ended up large after probing */\n    if (s->read_packet && s->orig_buffer_size && s->buffer_size > s->orig_buffer_size) {\n        if (dst == s->buffer && s->buf_ptr != dst) {\n            int ret = ffio_set_buf_size(s, s->orig_buffer_size);\n            if (ret < 0)\n                av_log(s, AV_LOG_WARNING, \"Failed to decrease buffer size\\n\");\n\n            s->checksum_ptr = dst = s->buffer;\n        }\n        av_assert0(len >= s->orig_buffer_size);\n        len = s->orig_buffer_size;\n    }\n\n    if (s->read_packet)\n        len = s->read_packet(s->opaque, dst, len);\n    else\n        len = 0;\n    if (len <= 0) {\n        /* do not modify buffer if EOF reached so that a seek back can\n           be done without rereading data */\n        s->eof_reached = 1;\n        if (len < 0)\n            s->error = len;\n    } else {\n        s->pos += len;\n        s->buf_ptr = dst;\n        s->buf_end = dst + len;\n        s->bytes_read += len;\n    }\n}", "target": 0}
{"idx": 4778, "func": "int av_bitstream_filter_filter(AVBitStreamFilterContext *bsfc,\n                               AVCodecContext *avctx, const char *args,\n                               uint8_t **poutbuf, int *poutbuf_size,\n                               const uint8_t *buf, int buf_size, int keyframe)\n{\n    BSFCompatContext *priv = bsfc->priv_data;\n    AVPacket pkt = { 0 };\n    int ret;\n\n    if (!priv->ctx) {\n        ret = av_bsf_alloc(bsfc->filter, &priv->ctx);\n        if (ret < 0)\n            return ret;\n\n        ret = avcodec_parameters_from_context(priv->ctx->par_in, avctx);\n        if (ret < 0)\n            return ret;\n\n        priv->ctx->time_base_in = avctx->time_base;\n\n        if (bsfc->args && bsfc->filter->priv_class) {\n            const AVOption *opt = av_opt_next(priv->ctx->priv_data, NULL);\n            const char * shorthand[2] = {NULL};\n\n            if (opt)\n                shorthand[0] = opt->name;\n\n            ret = av_opt_set_from_string(priv->ctx->priv_data, bsfc->args, shorthand, \"=\", \":\");\n        }\n\n        ret = av_bsf_init(priv->ctx);\n        if (ret < 0)\n            return ret;\n    }\n\n    pkt.data = buf;\n    pkt.size = buf_size;\n\n    ret = av_bsf_send_packet(priv->ctx, &pkt);\n    if (ret < 0)\n        return ret;\n\n    *poutbuf      = NULL;\n    *poutbuf_size = 0;\n\n    ret = av_bsf_receive_packet(priv->ctx, &pkt);\n    if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)\n        return 0;\n    else if (ret < 0)\n        return ret;\n\n    *poutbuf = av_malloc(pkt.size + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!*poutbuf) {\n        av_packet_unref(&pkt);\n        return AVERROR(ENOMEM);\n    }\n\n    *poutbuf_size = pkt.size;\n    memcpy(*poutbuf, pkt.data, pkt.size);\n\n    av_packet_unref(&pkt);\n\n    /* drain all the remaining packets we cannot return */\n    while (ret >= 0) {\n        ret = av_bsf_receive_packet(priv->ctx, &pkt);\n        av_packet_unref(&pkt);\n    }\n\n    if (!priv->extradata_updated) {\n        /* update extradata in avctx from the output codec parameters */\n        if (priv->ctx->par_out->extradata_size && (!args || !strstr(args, \"private_spspps_buf\"))) {\n            av_freep(&avctx->extradata);\n            avctx->extradata_size = 0;\n            avctx->extradata = av_mallocz(priv->ctx->par_out->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!avctx->extradata)\n                return AVERROR(ENOMEM);\n            memcpy(avctx->extradata, priv->ctx->par_out->extradata, priv->ctx->par_out->extradata_size);\n            avctx->extradata_size = priv->ctx->par_out->extradata_size;\n        }\n\n        priv->extradata_updated = 1;\n    }\n\n    return 1;\n}", "target": 1}
{"idx": 4779, "func": "static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)\n{\n    int i, n, n2;\n    float alpha;\n\n    n  = 1 << ln;\n    n2 = n >> 1;\n\n    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);\n    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);\n\n    for (i = 0; i < n2; i++) {\n        alpha     = 2.0 * M_PI * i / n;\n        mdct->costab[i] = FIX15(cos(alpha));\n        mdct->sintab[i] = FIX15(sin(alpha));\n    }\n\n    return 0;\nfft_alloc_fail:\n    mdct_end(mdct);\n    return AVERROR(ENOMEM);\n}", "target": 1}
{"idx": 4780, "func": "int av_opt_set(void *obj, const char *name, const char *val, int search_flags)\n{\n    int ret = 0;\n    void *dst, *target_obj;\n    const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);\n    if (!o || !target_obj)\n        return AVERROR_OPTION_NOT_FOUND;\n    if (!val && (o->type != AV_OPT_TYPE_STRING &&\n                 o->type != AV_OPT_TYPE_PIXEL_FMT && o->type != AV_OPT_TYPE_SAMPLE_FMT &&\n                 o->type != AV_OPT_TYPE_IMAGE_SIZE && o->type != AV_OPT_TYPE_VIDEO_RATE &&\n                 o->type != AV_OPT_TYPE_DURATION && o->type != AV_OPT_TYPE_COLOR &&\n                 o->type != AV_OPT_TYPE_CHANNEL_LAYOUT))\n        return AVERROR(EINVAL);\n\n    dst = ((uint8_t*)target_obj) + o->offset;\n    switch (o->type) {\n    case AV_OPT_TYPE_STRING:   return set_string(obj, o, val, dst);\n    case AV_OPT_TYPE_BINARY:   return set_string_binary(obj, o, val, dst);\n    case AV_OPT_TYPE_FLAGS:\n    case AV_OPT_TYPE_INT:\n    case AV_OPT_TYPE_INT64:\n    case AV_OPT_TYPE_FLOAT:\n    case AV_OPT_TYPE_DOUBLE:\n    case AV_OPT_TYPE_RATIONAL: return set_string_number(obj, target_obj, o, val, dst);\n    case AV_OPT_TYPE_IMAGE_SIZE:\n        if (!val || !strcmp(val, \"none\")) {\n            *(int *)dst = *((int *)dst + 1) = 0;\n            return 0;\n        }\n        ret = av_parse_video_size(dst, ((int *)dst) + 1, val);\n        if (ret < 0)\n            av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\" as image size\\n\", val);\n        return ret;\n    case AV_OPT_TYPE_VIDEO_RATE:\n        if (!val) {\n            ret = AVERROR(EINVAL);\n        } else {\n            ret = av_parse_video_rate(dst, val);\n        }\n        if (ret < 0)\n            av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\" as video rate\\n\", val);\n        return ret;\n    case AV_OPT_TYPE_PIXEL_FMT:\n        if (!val || !strcmp(val, \"none\")) {\n            ret = AV_PIX_FMT_NONE;\n        } else {\n            ret = av_get_pix_fmt(val);\n            if (ret == AV_PIX_FMT_NONE) {\n                char *tail;\n                ret = strtol(val, &tail, 0);\n                if (*tail || (unsigned)ret >= AV_PIX_FMT_NB) {\n                    av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\" as pixel format\\n\", val);\n                    return AVERROR(EINVAL);\n                }\n            }\n        }\n        *(enum AVPixelFormat *)dst = ret;\n        return 0;\n    case AV_OPT_TYPE_SAMPLE_FMT:\n        if (!val || !strcmp(val, \"none\")) {\n            ret = AV_SAMPLE_FMT_NONE;\n        } else {\n            ret = av_get_sample_fmt(val);\n            if (ret == AV_SAMPLE_FMT_NONE) {\n                char *tail;\n                ret = strtol(val, &tail, 0);\n                if (*tail || (unsigned)ret >= AV_SAMPLE_FMT_NB) {\n                    av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\" as sample format\\n\", val);\n                    return AVERROR(EINVAL);\n                }\n            }\n        }\n        *(enum AVSampleFormat *)dst = ret;\n        return 0;\n    case AV_OPT_TYPE_DURATION:\n        if (!val) {\n            *(int64_t *)dst = 0;\n            return 0;\n        } else {\n            if ((ret = av_parse_time(dst, val, 1)) < 0)\n                av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\" as duration\\n\", val);\n            return ret;\n        }\n        break;\n    case AV_OPT_TYPE_COLOR:\n        if (!val) {\n            return 0;\n        } else {\n            ret = av_parse_color(dst, val, -1, obj);\n            if (ret < 0)\n                av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\" as color\\n\", val);\n            return ret;\n        }\n        break;\n    case AV_OPT_TYPE_CHANNEL_LAYOUT:\n        if (!val || !strcmp(val, \"none\")) {\n            *(int64_t *)dst = 0;\n        } else {\n#if FF_API_GET_CHANNEL_LAYOUT_COMPAT\n            int64_t cl = ff_get_channel_layout(val, 0);\n#else\n            int64_t cl = av_get_channel_layout(val);\n#endif\n            if (!cl) {\n                av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\" as channel layout\\n\", val);\n                ret = AVERROR(EINVAL);\n            }\n            *(int64_t *)dst = cl;\n            return ret;\n        }\n        break;\n    }\n\n    av_log(obj, AV_LOG_ERROR, \"Invalid option type.\\n\");\n    return AVERROR(EINVAL);\n}", "target": 0}
{"idx": 4781, "func": "int ASN1_get_object(unsigned char **pp, long *plength, int *ptag, int *pclass,\n\t     long omax)\n\t{\n\tint i,ret;\n\tlong l;\n\tunsigned char *p= *pp;\n\tint tag,xclass,inf;\n\tlong max=omax;\n\n\tif (!max) goto err;\n\tret=(*p&V_ASN1_CONSTRUCTED);\n\txclass=(*p&V_ASN1_PRIVATE);\n\ti= *p&V_ASN1_PRIMITIVE_TAG;\n\tif (i == V_ASN1_PRIMITIVE_TAG)\n\t\t{\t\t/* high-tag */\n\t\tp++;\n\t\tif (--max == 0) goto err;\n\t\tl=0;\n\t\twhile (*p&0x80)\n\t\t\t{\n\t\t\tl<<=7L;\n\t\t\tl|= *(p++)&0x7f;\n\t\t\tif (--max == 0) goto err;\n\t\t\t}\n\t\tl<<=7L;\n\t\tl|= *(p++)&0x7f;\n\t\ttag=(int)l;\n\t\t}\n\telse\n\t\t{ \n\t\ttag=i;\n\t\tp++;\n\t\tif (--max == 0) goto err;\n\t\t}\n\t*ptag=tag;\n\t*pclass=xclass;\n\tif (!asn1_get_length(&p,&inf,plength,(int)max)) goto err;\n\n#if 0\n\tfprintf(stderr,\"p=%d + *plength=%ld > omax=%ld + *pp=%d  (%d > %d)\\n\", \n\t\t(int)p,*plength,omax,(int)*pp,(int)(p+ *plength),\n\t\t(int)(omax+ *pp));\n\n#endif\n\tif (*plength > (omax - (*pp - p)))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_GET_OBJECT,ASN1_R_TOO_LONG);\n\t\t/* Set this so that even if things are not long enough\n\t\t * the values are set correctly */\n\t\tret|=0x80;\n\t\t}\n\t*pp=p;\n\treturn(ret|inf);\nerr:\n\tASN1err(ASN1_F_ASN1_GET_OBJECT,ASN1_R_HEADER_TOO_LONG);\n\treturn(0x80);\n\t}", "target": 0}
{"idx": 4782, "func": "static ASN1_VALUE *b64_read_asn1(BIO *bio, const ASN1_ITEM *it)\n{\n    BIO *b64;\n    ASN1_VALUE *val;\n\n    if ((b64 = BIO_new(BIO_f_base64())) == NULL) {\n        ASN1err(ASN1_F_B64_READ_ASN1, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    bio = BIO_push(b64, bio);\n    val = ASN1_item_d2i_bio(it, bio, NULL);\n    if (!val)\n        ASN1err(ASN1_F_B64_READ_ASN1, ASN1_R_DECODE_ERROR);\n    (void)BIO_flush(bio);\n    BIO_pop(bio);\n    BIO_free(b64);\n    return val;\n}", "target": 0}
{"idx": 4783, "func": "int gost_do_verify(const unsigned char *dgst, int dgst_len,\n\tDSA_SIG *sig, DSA *dsa)\n\t{\n\tBIGNUM *md, *tmp=NULL;\n\tBIGNUM *q2=NULL;\n\tBIGNUM *u=NULL,*v=NULL,*z1=NULL,*z2=NULL;\n\tBIGNUM *tmp2=NULL,*tmp3=NULL;\n\tint ok;\n\tBN_CTX *ctx = BN_CTX_new();\n\n\tBN_CTX_start(ctx);\n\tif (BN_cmp(sig->s,dsa->q)>=1||\n\t\tBN_cmp(sig->r,dsa->q)>=1)\n\t\t{\n\t\tGOSTerr(GOST_F_GOST_DO_VERIFY,GOST_R_SIGNATURE_PARTS_GREATER_THAN_Q);\n\t\treturn 0;\n\t\t}\n\tmd=hashsum2bn(dgst);\n\t\n\ttmp=BN_CTX_get(ctx);\n\tv=BN_CTX_get(ctx);\n\tq2=BN_CTX_get(ctx);\n\tz1=BN_CTX_get(ctx);\n\tz2=BN_CTX_get(ctx);\n\ttmp2=BN_CTX_get(ctx);\n\ttmp3=BN_CTX_get(ctx);\n\tu = BN_CTX_get(ctx);\n\t\n\tBN_mod(tmp,md,dsa->q,ctx);\n\tif (BN_is_zero(tmp))\n\t\t{\n\t\tBN_one(md);\n\t\t}\n\tBN_copy(q2,dsa->q);\n\tBN_sub_word(q2,2);\n\tBN_mod_exp(v,md,q2,dsa->q,ctx);\n\tBN_mod_mul(z1,sig->s,v,dsa->q,ctx);\n\tBN_sub(tmp,dsa->q,sig->r);\n\tBN_mod_mul(z2,tmp,v,dsa->p,ctx);\n\tBN_mod_exp(tmp,dsa->g,z1,dsa->p,ctx);\n\tBN_mod_exp(tmp2,dsa->pub_key,z2,dsa->p,ctx);\n\tBN_mod_mul(tmp3,tmp,tmp2,dsa->p,ctx);\n\tBN_mod(u,tmp3,dsa->q,ctx);\n\tok= BN_cmp(u,sig->r);\n\t\n\tBN_free(md);\n\tBN_CTX_end(ctx);\n\tBN_CTX_free(ctx);\n\tif (ok!=0)\n\t\t{\n\t\tGOSTerr(GOST_F_GOST_DO_VERIFY,GOST_R_SIGNATURE_MISMATCH);\n\t\t}\t\n\treturn (ok==0);\n\t}", "target": 1}
{"idx": 4784, "func": "static av_cold int peak_init_writer(AVFormatContext *s)\n{\n    WAVMuxContext *wav = s->priv_data;\n    AVCodecContext *enc = s->streams[0]->codec;\n\n    if (enc->codec_id != AV_CODEC_ID_PCM_S8 &&\n        enc->codec_id != AV_CODEC_ID_PCM_S16LE &&\n        enc->codec_id != AV_CODEC_ID_PCM_U8 &&\n        enc->codec_id != AV_CODEC_ID_PCM_U16LE) {\n        av_log(s, AV_LOG_ERROR, \"%s codec not supported for Peak Chunk\\n\",\n               s->streams[0]->codec->codec ? s->streams[0]->codec->codec->name : \"NONE\");\n        return -1;\n    }\n\n    wav->peak_bps = av_get_bits_per_sample(enc->codec_id) / 8;\n\n    if (wav->peak_bps == 1 && wav->peak_format == PEAK_FORMAT_UINT16) {\n        av_log(s, AV_LOG_ERROR,\n               \"Writing 16 bit peak for 8 bit audio does not make sense\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    wav->peak_maxpos = av_mallocz(enc->channels * sizeof(*wav->peak_maxpos));\n    wav->peak_maxneg = av_mallocz(enc->channels * sizeof(*wav->peak_maxneg));\n    wav->peak_output = av_malloc(PEAK_BUFFER_SIZE);\n    if (!wav->peak_maxpos || !wav->peak_maxneg || !wav->peak_output)\n        goto nomem;\n\n    wav->peak_outbuf_size = PEAK_BUFFER_SIZE;\n\n    return 0;\n\nnomem:\n    av_log(s, AV_LOG_ERROR, \"Out of memory\\n\");\n    peak_free_buffers(s);\n    return AVERROR(ENOMEM);\n}", "target": 0}
{"idx": 4785, "func": "static int ui_read(UI *ui, UI_STRING *uis)\n{\n    switch (UI_get_string_type(uis)) {\n    case UIT_PROMPT:\n        {\n            char result[PEM_BUFSIZE + 1];\n            const struct pem_password_cb_data *data =\n                UI_method_get_ex_data(UI_get_method(ui), ui_method_data_index);\n            int maxsize = UI_get_result_maxsize(uis);\n            int len = data->cb(result,\n                               maxsize > PEM_BUFSIZE ? PEM_BUFSIZE : maxsize,\n                               data->rwflag, UI_get0_user_data(ui));\n\n            if (len >= 0)\n                result[len] = '\\0';\n            if (len <= 0)\n                return len;\n            if (UI_set_result_ex(ui, uis, result, len) >= 0)\n                return 1;\n            return 0;\n        }\n    case UIT_VERIFY:\n    case UIT_NONE:\n    case UIT_BOOLEAN:\n    case UIT_INFO:\n    case UIT_ERROR:\n        break;\n    }\n    return 1;\n}", "target": 0}
{"idx": 4786, "func": "static int aic_decode_coeffs(GetBitContext *gb, int16_t *dst,\n                             int band, int slice_width)\n{\n    int has_skips, coeff_type, coeff_bits, skip_type, skip_bits;\n    const int num_coeffs = aic_num_band_coeffs[band];\n    const uint8_t *scan = aic_scan[band];\n    int mb, idx, val;\n\n    has_skips  = get_bits1(gb);\n    coeff_type = get_bits1(gb);\n    coeff_bits = get_bits(gb, 3);\n\n    if (has_skips) {\n        skip_type = get_bits1(gb);\n        skip_bits = get_bits(gb, 3);\n\n        for (mb = 0; mb < slice_width; mb++) {\n            idx = -1;\n            do {\n                GET_CODE(val, skip_type, skip_bits);\n                idx += val + 1;\n                if (idx >= num_coeffs)\n                    break;\n                GET_CODE(val, coeff_type, coeff_bits);\n                val++;\n                if (val >= 0x10000)\n                    return AVERROR_INVALIDDATA;\n                dst[scan[idx]] = val;\n            } while (idx < num_coeffs - 1);\n            dst += num_coeffs;\n        }\n    } else {\n        for (mb = 0; mb < slice_width; mb++) {\n            for (idx = 0; idx < num_coeffs; idx++) {\n                GET_CODE(val, coeff_type, coeff_bits);\n                if (val >= 0x10000)\n                    return AVERROR_INVALIDDATA;\n                dst[scan[idx]] = val;\n            }\n            dst += num_coeffs;\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": 4787, "func": "static int srt_get_duration(uint8_t **buf)\n{\n    int i, duration = 0;\n\n    for (i=0; i<2 && !duration; i++) {\n        int s_hour, s_min, s_sec, s_hsec, e_hour, e_min, e_sec, e_hsec;\n        if (sscanf(*buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\",\n                   &s_hour, &s_min, &s_sec, &s_hsec,\n                   &e_hour, &e_min, &e_sec, &e_hsec) == 8) {\n            s_min  +=   60*s_hour;      e_min  +=   60*e_hour;\n            s_sec  +=   60*s_min;       e_sec  +=   60*e_min;\n            s_hsec += 1000*s_sec;       e_hsec += 1000*e_sec;\n            duration = e_hsec - s_hsec;\n        }\n        *buf += strcspn(*buf, \"\\n\") + 1;\n    }\n    return duration;\n}", "target": 1}
{"idx": 4788, "func": "static double get_volume(CompandContext *s, double in_lin)\n{\n    CompandSegment *cs;\n    double in_log, out_log;\n    int i;\n\n    if (in_lin < s->in_min_lin)\n        return s->out_min_lin;\n\n    in_log = log(in_lin);\n\n    for (i = 1;; i++)\n        if (in_log <= s->segments[i + 1].x)\n            break;\n\n    cs = &s->segments[i];\n    in_log -= cs->x;\n    out_log = cs->y + in_log * (cs->a * in_log + cs->b);\n\n    return exp(out_log);\n}", "target": 1}
{"idx": 4789, "func": "int get_buffer(ByteIOContext *s, unsigned char *buf, int size)\n{\n    int len, size1;\n\n    size1 = size;\n    while (size > 0) {\n        len = s->buf_end - s->buf_ptr;\n        if (len > size)\n            len = size;\n        if (len == 0) {\n            if(size > s->buffer_size && !s->update_checksum){\n                if(s->read_packet)\n                    len = s->read_packet(s->opaque, buf, size);\n                if (len <= 0) {\n                    /* do not modify buffer if EOF reached so that a seek back can\n                    be done without rereading data */\n                    s->eof_reached = 1;\n                    if(len<0)\n                        s->error= len;\n                    break;\n                } else {\n                    s->pos += len;\n                    size -= len;\n                    buf += len;\n                    s->buf_ptr = s->buffer;\n                    s->buf_end = s->buffer/* + len*/;\n                }\n            }else{\n                fill_buffer(s);\n                len = s->buf_end - s->buf_ptr;\n                if (len == 0)\n                    break;\n            }\n        } else {\n            memcpy(buf, s->buf_ptr, len);\n            buf += len;\n            s->buf_ptr += len;\n            size -= len;\n        }\n    }\n    if (size1 == size) {\n        if (url_ferror(s)) return url_ferror(s);\n        if (url_feof(s))   return AVERROR_EOF;\n    }\n    return size1 - size;\n}", "target": 1}
{"idx": 4790, "func": "static void fill_buffer(ByteIOContext *s)\n{\n    int len=0;\n\n    /* no need to do anything if EOF already reached */\n    if (s->eof_reached)\n        return;\n\n    if(s->update_checksum){\n        if(s->buf_end > s->checksum_ptr)\n            s->checksum= s->update_checksum(s->checksum, s->checksum_ptr, s->buf_end - s->checksum_ptr);\n        s->checksum_ptr= s->buffer;\n    }\n\n    if(s->read_packet)\n        len = s->read_packet(s->opaque, s->buffer, s->buffer_size);\n    if (len <= 0) {\n        /* do not modify buffer if EOF reached so that a seek back can\n           be done without rereading data */\n        s->eof_reached = 1;\n        if(len<0)\n            s->error= len;\n    } else {\n        s->pos += len;\n        s->buf_ptr = s->buffer;\n        s->buf_end = s->buffer + len;\n    }\n}", "target": 1}
{"idx": 4791, "func": "void RECORD_LAYER_clear(RECORD_LAYER *rl)\n{\n    unsigned int pipes;\n\n    rl->rstate = SSL_ST_READ_HEADER;\n\n    /*\n     * Do I need to clear read_ahead? As far as I can tell read_ahead did not\n     * previously get reset by SSL_clear...so I'll keep it that way..but is\n     * that right?\n     */\n\n    rl->packet = NULL;\n    rl->packet_length = 0;\n    rl->wnum = 0;\n    memset(rl->alert_fragment, 0, sizeof(rl->alert_fragment));\n    rl->alert_fragment_len = 0;\n    memset(rl->handshake_fragment, 0, sizeof(rl->handshake_fragment));\n    rl->handshake_fragment_len = 0;\n    rl->wpend_tot = 0;\n    rl->wpend_type = 0;\n    rl->wpend_ret = 0;\n    rl->wpend_buf = NULL;\n\n    SSL3_BUFFER_clear(&rl->rbuf);\n    for (pipes = 0; pipes < rl->numwpipes; pipes++)\n        SSL3_BUFFER_clear(&rl->wbuf[pipes]);\n    rl->numwpipes = 0;\n    rl->numrpipes = 0;\n    SSL3_RECORD_clear(rl->rrec, SSL_MAX_PIPELINES);\n\n    RECORD_LAYER_reset_read_sequence(rl);\n    RECORD_LAYER_reset_write_sequence(rl);\n\n    if (rl->d)\n        DTLS_RECORD_LAYER_clear(rl);\n}", "target": 1}
{"idx": 4792, "func": "void *evp_generic_fetch(OPENSSL_CTX *libctx, int operation_id,\n                        const char *algorithm, const char *properties,\n                        void *(*new_method)(int nid, const OSSL_DISPATCH *fns,\n                                            OSSL_PROVIDER *prov),\n                        int (*upref_method)(void *),\n                        void (*free_method)(void *),\n                        int (*nid_method)(void *))\n{\n    OSSL_METHOD_STORE *store = get_default_method_store(libctx);\n    int nid = OBJ_sn2nid(algorithm);\n    void *method = NULL;\n\n    if (store == NULL)\n        return NULL;\n\n    if (nid == NID_undef\n        || !ossl_method_store_cache_get(store, nid, properties, &method)) {\n        OSSL_METHOD_CONSTRUCT_METHOD mcm = {\n            alloc_tmp_method_store,\n            dealloc_tmp_method_store,\n            get_method_from_store,\n            put_method_in_store,\n            construct_method,\n            destruct_method\n        };\n        struct method_data_st mcmdata;\n\n        mcmdata.nid = nid;\n        mcmdata.mcm = &mcm;\n        mcmdata.method_from_dispatch = new_method;\n        mcmdata.destruct_method = free_method;\n        mcmdata.refcnt_up_method = upref_method;\n        mcmdata.destruct_method = free_method;\n        mcmdata.nid_method = nid_method;\n        method = ossl_method_construct(libctx, operation_id, algorithm,\n                                       properties, 0 /* !force_cache */,\n                                       &mcm, &mcmdata);\n        ossl_method_store_cache_set(store, nid, properties, method);\n    } else {\n        upref_method(method);\n    }\n\n    return method;\n}", "target": 0}
{"idx": 4793, "func": "static int instantiate(RAND_DRBG *drbg, DRBG_SELFTEST_DATA *td,\n                       TEST_CTX *t)\n{\n    if (!TEST_true(init(drbg, td, t))\n            || !TEST_true(RAND_DRBG_instantiate(drbg, td->pers, td->perslen)))\n        return 0;\n    return 1;\n}", "target": 0}
{"idx": 4794, "func": "int ff_ffv1_init_slice_contexts(FFV1Context *f)\n{\n    int i;\n\n    f->max_slice_count = f->num_h_slices * f->num_v_slices;\n    av_assert0(f->max_slice_count > 0);\n\n    for (i = 0; i < f->max_slice_count; i++) {\n        int sx          = i % f->num_h_slices;\n        int sy          = i / f->num_h_slices;\n        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n        int sys         = f->avctx->height *  sy      / f->num_v_slices;\n        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n        FFV1Context *fs = av_mallocz(sizeof(*fs));\n\n        if (!fs)\n            goto memfail;\n\n        f->slice_context[i] = fs;\n        memcpy(fs, f, sizeof(*fs));\n        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n\n        fs->slice_width  = sxe - sxs;\n        fs->slice_height = sye - sys;\n        fs->slice_x      = sxs;\n        fs->slice_y      = sys;\n\n        fs->sample_buffer = av_malloc_array((fs->width + 6), 3 * MAX_PLANES *\n                                      sizeof(*fs->sample_buffer));\n        fs->sample_buffer32 = av_malloc_array((fs->width + 6), 3 * MAX_PLANES *\n                                        sizeof(*fs->sample_buffer32));\n        if (!fs->sample_buffer || !fs->sample_buffer32) {\n            av_freep(&fs->sample_buffer);\n            av_freep(&fs->sample_buffer32);\n            av_freep(&f->slice_context[i]);\n            goto memfail;\n        }\n    }\n    return 0;\n\nmemfail:\n    while(--i >= 0) {\n        av_freep(&f->slice_context[i]->sample_buffer);\n        av_freep(&f->slice_context[i]->sample_buffer32);\n        av_freep(&f->slice_context[i]);\n    }\n    return AVERROR(ENOMEM);\n}", "target": 1}
{"idx": 4795, "func": "static inline int get_len(LZOContext *c, int x, int mask)\n{\n    int cnt = x & mask;\n    if (!cnt) {\n        while (!(x = get_byte(c)))\n            cnt += 255;\n        cnt += mask + x;\n    }\n    return cnt;\n}", "target": 1}
{"idx": 4796, "func": "static void apply_tns_filter(float *out, float *in, int order, int direction,\n                             float *tns_coefs, int ltp_used, int w, int filt,\n                             int start_i, int len)\n{\n    int i, j, inc, start = start_i;\n    float tmp[TNS_MAX_ORDER+1];\n    if (direction) {\n        inc = -1;\n        start = (start + len) - 1;\n    } else {\n        inc = 1;\n    }\n    if (!ltp_used) {    /* AR filter */\n        for (i = 0; i < len; i++, start += inc)\n            out[i] = in[start];\n            for (j = 1; j <= FFMIN(i, order); j++)\n                out[i] += tns_coefs[j]*in[start - j*inc];\n    } else {            /* MA filter */\n        for (i = 0; i < len; i++, start += inc) {\n            tmp[0] = out[i] = in[start];\n            for (j = 1; j <= FFMIN(i, order); j++)\n                out[i] += tmp[j]*tns_coefs[j];\n            for (j = order; j > 0; j--)\n                tmp[j] = tmp[j - 1];\n        }\n    }\n}", "target": 1}
{"idx": 4797, "func": "int BN_set_word(BIGNUM *a, BN_ULONG w)\n\t{\n\tbn_check_top(a);\n\tif (bn_expand(a,(int)sizeof(BN_ULONG)*8) == NULL) return(0);\n\ta->neg = 0;\n\ta->d[0] = w;\n\ta->top = (w ? 1 : 0);\n\tbn_check_top(a);\n\treturn(1);\n\t}", "target": 0}
{"idx": 4798, "func": "static inline int get_ue_golomb(GetBitContext *gb)\n{\n    unsigned int buf;\n\n    OPEN_READER(re, gb);\n    UPDATE_CACHE(re, gb);\n    buf = GET_CACHE(re, gb);\n\n    if (buf >= (1 << 27)) {\n        buf >>= 32 - 9;\n        LAST_SKIP_BITS(re, gb, ff_golomb_vlc_len[buf]);\n        CLOSE_READER(re, gb);\n\n        return ff_ue_golomb_vlc_code[buf];\n    } else {\n        int log = 2 * av_log2(buf) - 31;\n        buf >>= log;\n        buf--;\n        LAST_SKIP_BITS(re, gb, 32 - log);\n        CLOSE_READER(re, gb);\n\n        return buf;\n    }\n}", "target": 1}
{"idx": 4799, "func": "static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)\n{\n    int ch, bw_code;\n\n    if (cutoff) {\n        /* calculate bandwidth based on user-specified cutoff frequency */\n        int fbw_coeffs;\n        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);\n        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;\n        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);\n    } else {\n        /* use default bandwidth setting */\n        /* XXX: should compute the bandwidth according to the frame\n           size, so that we avoid annoying high frequency artifacts */\n        bw_code = 50;\n    }\n\n    /* set number of coefficients for each channel */\n    for (ch = 0; ch < s->fbw_channels; ch++) {\n        s->bandwidth_code[ch] = bw_code;\n        s->nb_coefs[ch]       = bw_code * 3 + 73;\n    }\n    if (s->lfe_on)\n        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */\n}", "target": 1}
{"idx": 4800, "func": "static int sox_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    unsigned header_size, comment_size;\n    double sample_rate, sample_rate_frac;\n    AVStream *st;\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n\n    if (avio_rl32(pb) == SOX_TAG) {\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;\n        header_size         = avio_rl32(pb);\n        avio_skip(pb, 8); /* sample count */\n        sample_rate         = av_int2double(avio_rl64(pb));\n        st->codecpar->channels = avio_rl32(pb);\n        comment_size        = avio_rl32(pb);\n    } else {\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S32BE;\n        header_size         = avio_rb32(pb);\n        avio_skip(pb, 8); /* sample count */\n        sample_rate         = av_int2double(avio_rb64(pb));\n        st->codecpar->channels = avio_rb32(pb);\n        comment_size        = avio_rb32(pb);\n    }\n\n    if (comment_size > 0xFFFFFFFFU - SOX_FIXED_HDR - 4U) {\n        av_log(s, AV_LOG_ERROR, \"invalid comment size (%u)\\n\", comment_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (sample_rate <= 0 || sample_rate > INT_MAX) {\n        av_log(s, AV_LOG_ERROR, \"invalid sample rate (%f)\\n\", sample_rate);\n        return AVERROR_INVALIDDATA;\n    }\n\n    sample_rate_frac = sample_rate - floor(sample_rate);\n    if (sample_rate_frac)\n        av_log(s, AV_LOG_WARNING,\n               \"truncating fractional part of sample rate (%f)\\n\",\n               sample_rate_frac);\n\n    if ((header_size + 4) & 7 || header_size < SOX_FIXED_HDR + comment_size\n        || st->codecpar->channels > 65535) /* Reserve top 16 bits */ {\n        av_log(s, AV_LOG_ERROR, \"invalid header\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (comment_size && comment_size < UINT_MAX) {\n        char *comment = av_malloc(comment_size+1);\n        if(!comment)\n            return AVERROR(ENOMEM);\n        if (avio_read(pb, comment, comment_size) != comment_size) {\n            av_freep(&comment);\n            return AVERROR(EIO);\n        }\n        comment[comment_size] = 0;\n\n        av_dict_set(&s->metadata, \"comment\", comment,\n                               AV_DICT_DONT_STRDUP_VAL);\n    }\n\n    avio_skip(pb, header_size - SOX_FIXED_HDR - comment_size);\n\n    st->codecpar->sample_rate           = sample_rate;\n    st->codecpar->bits_per_coded_sample = 32;\n    st->codecpar->bit_rate              = st->codecpar->sample_rate *\n                                          st->codecpar->bits_per_coded_sample *\n                                          st->codecpar->channels;\n    st->codecpar->block_align           = st->codecpar->bits_per_coded_sample *\n                                          st->codecpar->channels / 8;\n\n    avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);\n\n    return 0;\n}", "target": 1}
{"idx": 4801, "func": "static void *dh_dupctx(void *vpdhctx)\n{\n    PROV_DH_CTX *srcctx = (PROV_DH_CTX *)vpdhctx;\n    PROV_DH_CTX *dstctx;\n\n    dstctx = OPENSSL_zalloc(sizeof(*srcctx));\n\n    *dstctx = *srcctx;\n    if (dstctx->dh != NULL && !DH_up_ref(dstctx->dh)) {\n        OPENSSL_free(dstctx);\n        return NULL;\n    }\n\n    if (dstctx->dhpeer != NULL && !DH_up_ref(dstctx->dhpeer)) {\n        DH_free(dstctx->dh);\n        OPENSSL_free(dstctx);\n        return NULL;\n    }\n\n    return dstctx;\n}", "target": 1}
{"idx": 4802, "func": "static void postprocess_chroma(AVFrame *frame, int w, int h, int depth)\n{\n    uint16_t *dstu = (uint16_t *)frame->data[1];\n    uint16_t *dstv = (uint16_t *)frame->data[2];\n    int16_t *srcu  = (int16_t *)frame->data[1];\n    int16_t *srcv  = (int16_t *)frame->data[2];\n    ptrdiff_t strideu = frame->linesize[1] / 2;\n    ptrdiff_t stridev = frame->linesize[2] / 2;\n    const unsigned add = 1 << (depth - 1);\n    const unsigned shift = 16 - depth;\n    int i, j;\n\n    for (j = 0; j < h; j++) {\n        for (i = 0; i < w; i++) {\n            dstu[i] = (add + srcu[i]) << shift;\n            dstv[i] = (add + srcv[i]) << shift;\n        }\n        dstu += strideu;\n        dstv += stridev;\n        srcu += strideu;\n        srcv += stridev;\n    }\n}", "target": 0}
{"idx": 4803, "func": "static int imc_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame_ptr, AVPacket *avpkt)\n{\n    AVFrame *frame     = data;\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    int ret, i;\n\n    IMCContext *q = avctx->priv_data;\n\n    LOCAL_ALIGNED_16(uint16_t, buf16, [IMC_BLOCK_SIZE / 2 + FF_INPUT_BUFFER_PADDING_SIZE/2]);\n\n    if (buf_size < IMC_BLOCK_SIZE * avctx->channels) {\n        av_log(avctx, AV_LOG_ERROR, \"frame too small!\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* get output buffer */\n    frame->nb_samples = COEFFS;\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n\n    for (i = 0; i < avctx->channels; i++) {\n        q->out_samples = (float *)frame->extended_data[i];\n\n        q->bdsp.bswap16_buf(buf16, (const uint16_t *) buf, IMC_BLOCK_SIZE / 2);\n\n        init_get_bits(&q->gb, (const uint8_t*)buf16, IMC_BLOCK_SIZE * 8);\n\n        buf += IMC_BLOCK_SIZE;\n\n        if ((ret = imc_decode_block(avctx, q, i)) < 0)\n            return ret;\n    }\n\n    if (avctx->channels == 2) {\n        q->fdsp.butterflies_float((float *)frame->extended_data[0],\n                                  (float *)frame->extended_data[1], COEFFS);\n    }\n\n    *got_frame_ptr = 1;\n\n    return IMC_BLOCK_SIZE * avctx->channels;\n}", "target": 0}
{"idx": 4804, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *buf)\n{\n    AVFilterContext *ctx = inlink->dst;\n    AVFilterLink *outlink = ctx->outputs[0];\n    BlendContext *b = ctx->priv;\n\n    int ret = 0;\n    int is_bottom = (inlink == ctx->inputs[BOTTOM]);\n    struct FFBufQueue *queue =\n        (is_bottom ? &b->queue_bottom : &b->queue_top);\n    ff_bufqueue_add(ctx, queue, buf);\n\n    while (1) {\n        AVFrame *top_buf, *bottom_buf, *out_buf;\n\n        if (!ff_bufqueue_peek(&b->queue_top, 0) ||\n            !ff_bufqueue_peek(&b->queue_bottom, 0)) break;\n\n        top_buf = ff_bufqueue_get(&b->queue_top);\n        bottom_buf = ff_bufqueue_get(&b->queue_bottom);\n\n        out_buf = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out_buf) {\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out_buf, top_buf);\n\n        b->frame_requested = 0;\n        blend_frame(ctx, top_buf, bottom_buf, out_buf);\n        ret = ff_filter_frame(outlink, out_buf);\n        av_frame_free(&top_buf);\n        av_frame_free(&bottom_buf);\n    }\n    return ret;\n}", "target": 0}
{"idx": 4805, "func": "static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)\n{\n    void **p = ptr;\n    if (min_size < *size)\n        return 0;\n    min_size = FFMAX(17 * min_size / 16 + 32, min_size);\n    av_free(*p);\n    *p = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);\n    if (!*p)\n        min_size = 0;\n    *size = min_size;\n    return 1;\n}", "target": 1}
{"idx": 4806, "func": "static int\nebml_read_element_level_up (MatroskaDemuxContext *matroska)\n{\n    ByteIOContext *pb = matroska->ctx->pb;\n    offset_t pos = url_ftell(pb);\n    int num = 0;\n\n    while (matroska->num_levels > 0) {\n        MatroskaLevel *level = &matroska->levels[matroska->num_levels - 1];\n\n        if (pos >= level->start + level->length) {\n            matroska->num_levels--;\n            num++;\n        } else {\n            break;\n        }\n    }\n\n    return num;\n}", "target": 1}
{"idx": 4807, "func": "static int write_manifest(AVFormatContext *s, int final)\n{\n    DASHContext *c = s->priv_data;\n    AVIOContext *out;\n    char temp_filename[1024];\n    int ret, i;\n    AVDictionaryEntry *title = av_dict_get(s->metadata, \"title\", NULL, 0);\n\n    snprintf(temp_filename, sizeof(temp_filename), \"%s.tmp\", s->filename);\n    ret = s->io_open(s, &out, temp_filename, AVIO_FLAG_WRITE, NULL);\n    if (ret < 0) {\n        av_log(s, AV_LOG_ERROR, \"Unable to open %s for writing\\n\", temp_filename);\n        return ret;\n    }\n    avio_printf(out, \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\");\n    avio_printf(out, \"<MPD xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                \"\\txmlns=\\\"urn:mpeg:dash:schema:mpd:2011\\\"\\n\"\n                \"\\txmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\\n\"\n                \"\\txsi:schemaLocation=\\\"urn:mpeg:DASH:schema:MPD:2011 http://standards.iso.org/ittf/PubliclyAvailableStandards/MPEG-DASH_schema_files/DASH-MPD.xsd\\\"\\n\"\n                \"\\tprofiles=\\\"urn:mpeg:dash:profile:isoff-live:2011\\\"\\n\"\n                \"\\ttype=\\\"%s\\\"\\n\", final ? \"static\" : \"dynamic\");\n    if (final) {\n        avio_printf(out, \"\\tmediaPresentationDuration=\\\"\");\n        write_time(out, c->total_duration);\n        avio_printf(out, \"\\\"\\n\");\n    } else {\n        int64_t update_period = c->last_duration / AV_TIME_BASE;\n        char now_str[100];\n        if (c->use_template && !c->use_timeline)\n            update_period = 500;\n        avio_printf(out, \"\\tminimumUpdatePeriod=\\\"PT%\"PRId64\"S\\\"\\n\", update_period);\n        avio_printf(out, \"\\tsuggestedPresentationDelay=\\\"PT%\"PRId64\"S\\\"\\n\", c->last_duration / AV_TIME_BASE);\n        if (!c->availability_start_time[0] && s->nb_streams > 0 && c->streams[0].nb_segments > 0) {\n            format_date_now(c->availability_start_time, sizeof(c->availability_start_time));\n        }\n        if (c->availability_start_time[0])\n            avio_printf(out, \"\\tavailabilityStartTime=\\\"%s\\\"\\n\", c->availability_start_time);\n        format_date_now(now_str, sizeof(now_str));\n        if (now_str[0])\n            avio_printf(out, \"\\tpublishTime=\\\"%s\\\"\\n\", now_str);\n        if (c->window_size && c->use_template) {\n            avio_printf(out, \"\\ttimeShiftBufferDepth=\\\"\");\n            write_time(out, c->last_duration * c->window_size);\n            avio_printf(out, \"\\\"\\n\");\n        }\n    }\n    avio_printf(out, \"\\tminBufferTime=\\\"\");\n    write_time(out, c->last_duration);\n    avio_printf(out, \"\\\">\\n\");\n    avio_printf(out, \"\\t<ProgramInformation>\\n\");\n    if (title) {\n        char *escaped = xmlescape(title->value);\n        avio_printf(out, \"\\t\\t<Title>%s</Title>\\n\", escaped);\n        av_free(escaped);\n    }\n    avio_printf(out, \"\\t</ProgramInformation>\\n\");\n    if (c->window_size && s->nb_streams > 0 && c->streams[0].nb_segments > 0 && !c->use_template) {\n        OutputStream *os = &c->streams[0];\n        int start_index = FFMAX(os->nb_segments - c->window_size, 0);\n        int64_t start_time = av_rescale_q(os->segments[start_index]->time, s->streams[0]->time_base, AV_TIME_BASE_Q);\n        avio_printf(out, \"\\t<Period start=\\\"\");\n        write_time(out, start_time);\n        avio_printf(out, \"\\\">\\n\");\n    } else {\n        avio_printf(out, \"\\t<Period start=\\\"PT0.0S\\\">\\n\");\n    }\n\n    if (c->has_video) {\n        avio_printf(out, \"\\t\\t<AdaptationSet contentType=\\\"video\\\" segmentAlignment=\\\"true\\\" bitstreamSwitching=\\\"true\\\">\\n\");\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            OutputStream *os = &c->streams[i];\n            if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)\n                continue;\n            avio_printf(out, \"\\t\\t\\t<Representation id=\\\"%d\\\" mimeType=\\\"video/mp4\\\" codecs=\\\"%s\\\"%s width=\\\"%d\\\" height=\\\"%d\\\">\\n\", i, os->codec_str, os->bandwidth_str, st->codec->width, st->codec->height);\n            output_segment_list(&c->streams[i], out, c);\n            avio_printf(out, \"\\t\\t\\t</Representation>\\n\");\n        }\n        avio_printf(out, \"\\t\\t</AdaptationSet>\\n\");\n    }\n    if (c->has_audio) {\n        avio_printf(out, \"\\t\\t<AdaptationSet contentType=\\\"audio\\\" segmentAlignment=\\\"true\\\" bitstreamSwitching=\\\"true\\\">\\n\");\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            OutputStream *os = &c->streams[i];\n            if (st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n                continue;\n            avio_printf(out, \"\\t\\t\\t<Representation id=\\\"%d\\\" mimeType=\\\"audio/mp4\\\" codecs=\\\"%s\\\"%s audioSamplingRate=\\\"%d\\\">\\n\", i, os->codec_str, os->bandwidth_str, st->codec->sample_rate);\n            avio_printf(out, \"\\t\\t\\t\\t<AudioChannelConfiguration schemeIdUri=\\\"urn:mpeg:dash:23003:3:audio_channel_configuration:2011\\\" value=\\\"%d\\\" />\\n\", st->codec->channels);\n            output_segment_list(&c->streams[i], out, c);\n            avio_printf(out, \"\\t\\t\\t</Representation>\\n\");\n        }\n        avio_printf(out, \"\\t\\t</AdaptationSet>\\n\");\n    }\n    avio_printf(out, \"\\t</Period>\\n\");\n    avio_printf(out, \"</MPD>\\n\");\n    avio_flush(out);\n    ff_format_io_close(s, &out);\n    return ff_rename(temp_filename, s->filename);\n}", "target": 0}
{"idx": 4808, "func": "static av_noinline void FUNC(hl_decode_mb_444)(const H264Context *h, H264SliceContext *sl)\n{\n    const int mb_x    = sl->mb_x;\n    const int mb_y    = sl->mb_y;\n    const int mb_xy   = sl->mb_xy;\n    const int mb_type = h->cur_pic.mb_type[mb_xy];\n    uint8_t *dest[3];\n    int linesize;\n    int i, j, p;\n    const int *block_offset = &h->block_offset[0];\n    const int transform_bypass = !SIMPLE && (sl->qscale == 0 && h->ps.sps->transform_bypass);\n    const int plane_count      = (SIMPLE || !CONFIG_GRAY || !(h->flags & AV_CODEC_FLAG_GRAY)) ? 3 : 1;\n\n    for (p = 0; p < plane_count; p++) {\n        dest[p] = h->cur_pic.f->data[p] +\n                  ((mb_x << PIXEL_SHIFT) + mb_y * sl->linesize) * 16;\n        h->vdsp.prefetch(dest[p] + (sl->mb_x & 3) * 4 * sl->linesize + (64 << PIXEL_SHIFT),\n                         sl->linesize, 4);\n    }\n\n    h->list_counts[mb_xy] = sl->list_count;\n\n    if (!SIMPLE && MB_FIELD(sl)) {\n        linesize     = sl->mb_linesize = sl->mb_uvlinesize = sl->linesize * 2;\n        block_offset = &h->block_offset[48];\n        if (mb_y & 1) // FIXME move out of this function?\n            for (p = 0; p < 3; p++)\n                dest[p] -= sl->linesize * 15;\n        if (FRAME_MBAFF(h)) {\n            int list;\n            for (list = 0; list < sl->list_count; list++) {\n                if (!USES_LIST(mb_type, list))\n                    continue;\n                if (IS_16X16(mb_type)) {\n                    int8_t *ref = &sl->ref_cache[list][scan8[0]];\n                    fill_rectangle(ref, 4, 4, 8, (16 + *ref) ^ (sl->mb_y & 1), 1);\n                } else {\n                    for (i = 0; i < 16; i += 4) {\n                        int ref = sl->ref_cache[list][scan8[i]];\n                        if (ref >= 0)\n                            fill_rectangle(&sl->ref_cache[list][scan8[i]], 2, 2,\n                                           8, (16 + ref) ^ (sl->mb_y & 1), 1);\n                    }\n                }\n            }\n        }\n    } else {\n        linesize = sl->mb_linesize = sl->mb_uvlinesize = sl->linesize;\n    }\n\n    if (!SIMPLE && IS_INTRA_PCM(mb_type)) {\n        if (PIXEL_SHIFT) {\n            const int bit_depth = h->ps.sps->bit_depth_luma;\n            GetBitContext gb;\n            init_get_bits(&gb, sl->intra_pcm_ptr, 768 * bit_depth);\n\n            for (p = 0; p < plane_count; p++)\n                for (i = 0; i < 16; i++) {\n                    uint16_t *tmp = (uint16_t *)(dest[p] + i * linesize);\n                    for (j = 0; j < 16; j++)\n                        tmp[j] = get_bits(&gb, bit_depth);\n                }\n        } else {\n            for (p = 0; p < plane_count; p++)\n                for (i = 0; i < 16; i++)\n                    memcpy(dest[p] + i * linesize,\n                           sl->intra_pcm_ptr + p * 256 + i * 16, 16);\n        }\n    } else {\n        if (IS_INTRA(mb_type)) {\n            if (sl->deblocking_filter)\n                xchg_mb_border(h, sl, dest[0], dest[1], dest[2], linesize,\n                               linesize, 1, 1, SIMPLE, PIXEL_SHIFT);\n\n            for (p = 0; p < plane_count; p++)\n                hl_decode_mb_predict_luma(h, sl, mb_type, SIMPLE,\n                                          transform_bypass, PIXEL_SHIFT,\n                                          block_offset, linesize, dest[p], p);\n\n            if (sl->deblocking_filter)\n                xchg_mb_border(h, sl, dest[0], dest[1], dest[2], linesize,\n                               linesize, 0, 1, SIMPLE, PIXEL_SHIFT);\n        } else {\n            FUNC(hl_motion_444)(h, sl, dest[0], dest[1], dest[2],\n                      h->qpel_put, h->h264chroma.put_h264_chroma_pixels_tab,\n                      h->qpel_avg, h->h264chroma.avg_h264_chroma_pixels_tab,\n                      h->h264dsp.weight_h264_pixels_tab,\n                      h->h264dsp.biweight_h264_pixels_tab);\n        }\n\n        for (p = 0; p < plane_count; p++)\n            hl_decode_mb_idct_luma(h, sl, mb_type, SIMPLE, transform_bypass,\n                                   PIXEL_SHIFT, block_offset, linesize,\n                                   dest[p], p);\n    }\n}", "target": 0}
{"idx": 4809, "func": "static int rpl_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    RPLContext *rpl = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream* stream;\n    AVIndexEntry* index_entry;\n    uint32_t ret;\n\n    if (rpl->chunk_part == s->nb_streams) {\n        rpl->chunk_number++;\n        rpl->chunk_part = 0;\n    }\n\n    stream = s->streams[rpl->chunk_part];\n\n    if (rpl->chunk_number >= stream->nb_index_entries)\n        return AVERROR_EOF;\n\n    index_entry = &stream->index_entries[rpl->chunk_number];\n\n    if (rpl->frame_in_part == 0)\n        if (avio_seek(pb, index_entry->pos, SEEK_SET) < 0)\n            return AVERROR(EIO);\n\n    if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n        stream->codec->codec_tag == 124) {\n        // We have to split Escape 124 frames because there are\n        // multiple frames per chunk in Escape 124 samples.\n        uint32_t frame_size;\n\n        avio_skip(pb, 4); /* flags */\n        frame_size = avio_rl32(pb);\n        if (avio_seek(pb, -8, SEEK_CUR) < 0)\n            return AVERROR(EIO);\n\n        ret = av_get_packet(pb, pkt, frame_size);\n        if (ret != frame_size) {\n            av_free_packet(pkt);\n            return AVERROR(EIO);\n        }\n        pkt->duration = 1;\n        pkt->pts = index_entry->timestamp + rpl->frame_in_part;\n        pkt->stream_index = rpl->chunk_part;\n\n        rpl->frame_in_part++;\n        if (rpl->frame_in_part == rpl->frames_per_chunk) {\n            rpl->frame_in_part = 0;\n            rpl->chunk_part++;\n        }\n    } else {\n        ret = av_get_packet(pb, pkt, index_entry->size);\n        if (ret != index_entry->size) {\n            av_free_packet(pkt);\n            return AVERROR(EIO);\n        }\n\n        if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n            // frames_per_chunk should always be one here; the header\n            // parsing will warn if it isn't.\n            pkt->duration = rpl->frames_per_chunk;\n        } else {\n            // All the audio codecs supported in this container\n            // (at least so far) are constant-bitrate.\n            pkt->duration = ret * 8;\n        }\n        pkt->pts = index_entry->timestamp;\n        pkt->stream_index = rpl->chunk_part;\n        rpl->chunk_part++;\n    }\n\n    // None of the Escape formats have keyframes, and the ADPCM\n    // format used doesn't have keyframes.\n    if (rpl->chunk_number == 0 && rpl->frame_in_part == 0)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    return ret;\n}", "target": 1}
{"idx": 4810, "func": "PROXY_DECLARE(apr_status_t) ap_proxy_tunnel_create(proxy_tunnel_rec **ptunnel,\n                                                   request_rec *r,\n                                                   conn_rec *origin)\n{\n    apr_status_t rv;\n    apr_pollfd_t *pfds;\n    conn_rec *c = r->connection;\n    proxy_tunnel_rec *tunnel;\n\n    *ptunnel = NULL;\n\n    tunnel = apr_pcalloc(r->pool, sizeof(*tunnel));\n\n    tunnel->r = r;\n    tunnel->origin = origin;\n    tunnel->bb_i = apr_brigade_create(r->pool,\n                                      c->bucket_alloc);\n    tunnel->bb_o = apr_brigade_create(origin->pool,\n                                      origin->bucket_alloc);\n    \n    tunnel->timeout = -1;\n    rv = apr_pollset_create(&tunnel->pollset, 2, r->pool,\n                            APR_POLLSET_NOCOPY);\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n\n    tunnel->pfds = apr_array_make(r->pool, 2, sizeof(apr_pollfd_t));\n    apr_array_push(tunnel->pfds); /* pfds[0] */\n    apr_array_push(tunnel->pfds); /* pfds[1] */\n\n    pfds = &APR_ARRAY_IDX(tunnel->pfds, 0, apr_pollfd_t);\n    pfds[0].desc.s = ap_get_conn_socket(c);\n    pfds[1].desc.s = ap_get_conn_socket(origin);\n    pfds[0].desc_type = pfds[1].desc_type = APR_POLL_SOCKET;\n    pfds[0].reqevents = pfds[1].reqevents = APR_POLLIN | APR_POLLHUP;\n    pfds[0].p = pfds[1].p = r->pool;\n\n    /* The input/output filter stacks should contain connection filters only */\n    r->output_filters = c->output_filters;\n    r->proto_output_filters = c->output_filters;\n    r->input_filters = c->input_filters;\n    r->proto_input_filters = c->input_filters;\n\n    c->keepalive = AP_CONN_CLOSE;\n    origin->keepalive = AP_CONN_CLOSE;\n\n    *ptunnel = tunnel;\n    return APR_SUCCESS;\n}", "target": 1}
{"idx": 4811, "func": "uintptr_t\nngx_escape_uri(u_char *dst, u_char *src, size_t size, ngx_uint_t type)\n{\n    ngx_uint_t      i, n;\n    uint32_t       *escape;\n    static u_char   hex[] = \"0123456789abcdef\";\n\n                    /* \" \", \"#\", \"%\", \"?\", %00-%1F, %7F-%FF */\n\n    static uint32_t   uri[] = {\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n        0x80000029, /* 1000 0000 0000 0000  0000 0000 0010 1001 */\n\n                    /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    };\n\n                    /* \" \", \"#\", \"%\", \"+\", \"?\", %00-%1F, %7F-%FF */\n\n    static uint32_t   args[] = {\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n        0x80000829, /* 1000 0000 0000 0000  0000 1000 0010 1001 */\n\n                    /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    };\n\n                    /* \" \", \"#\", \"\"\", \"%\", \"'\", %00-%1F, %7F-%FF */\n\n    static uint32_t   html[] = {\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n        0x000000ad, /* 0000 0000 0000 0000  0000 0000 1010 1101 */\n\n                    /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    };\n\n                    /* \" \", \"\"\", \"%\", \"'\", %00-%1F, %7F-%FF */\n\n    static uint32_t   refresh[] = {\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n        0x00000085, /* 0000 0000 0000 0000  0000 0000 1000 0101 */\n\n                    /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    };\n\n                    /* \" \", \"%\", %00-%1F */\n\n    static uint32_t   memcached[] = {\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n        0x00000021, /* 0000 0000 0000 0000  0000 0000 0010 0001 */\n\n                    /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n    };\n\n                    /* mail_auth is the same as memcached */\n\n    static uint32_t  *map[] =\n        { uri, args, html, refresh, memcached, memcached };\n\n\n    escape = map[type];\n\n    if (dst == NULL) {\n\n        /* find the number of the characters to be escaped */\n\n        n = 0;\n\n        for (i = 0; i < size; i++) {\n            if (escape[*src >> 5] & (1 << (*src & 0x1f))) {\n                n++;\n            }\n            src++;\n        }\n\n        return (uintptr_t) n;\n    }\n\n    for (i = 0; i < size; i++) {\n        if (escape[*src >> 5] & (1 << (*src & 0x1f))) {\n            *dst++ = '%';\n            *dst++ = hex[*src >> 4];\n            *dst++ = hex[*src & 0xf];\n            src++;\n\n        } else {\n            *dst++ = *src++;\n        }\n    }\n\n    return (uintptr_t) dst;\n}", "target": 1}
{"idx": 4812, "func": "ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t, ASN1_GENERALIZEDTIME **out)\n\t{\n\tASN1_GENERALIZEDTIME *ret;\n\tchar *str;\n\tint newlen;\n\n\tif (!ASN1_TIME_check(t)) return NULL;\n\n\tif (!out || !*out)\n\t\t{\n\t\tif (!(ret = ASN1_GENERALIZEDTIME_new ()))\n\t\t\treturn NULL;\n\t\tif (out) *out = ret;\n\t\t}\n\telse ret = *out;\n\n\t/* If already GeneralizedTime just copy across */\n\tif (t->type == V_ASN1_GENERALIZEDTIME)\n\t\t{\n\t\tif(!ASN1_STRING_set(ret, t->data, t->length))\n\t\t\treturn NULL;\n\t\treturn ret;\n\t\t}\n\n\t/* grow the string */\n\tif (!ASN1_STRING_set(ret, NULL, t->length + 2))\n\t\treturn NULL;\n\t/* ASN1_STRING_set() allocated 'len + 1' bytes. */\n\tnewlen = t->length + 2 + 1;\n\tstr = (char *)ret->data;\n\t/* Work out the century and prepend */\n\tif (t->data[0] >= '5') BUF_strlcpy(str, \"19\", newlen);\n\telse BUF_strlcpy(str, \"20\", newlen);\n\n\tBUF_strlcat(str, (char *)t->data, newlen);\n\n\treturn ret;\n\t}", "target": 0}
{"idx": 4813, "func": "MSG_PROCESS_RETURN tls_process_new_session_ticket(SSL *s, PACKET *pkt)\n{\n    int al = SSL_AD_DECODE_ERROR;\n    unsigned int ticklen;\n    unsigned long ticket_lifetime_hint, age_add = 0;\n    unsigned int sess_len;\n    RAW_EXTENSION *exts = NULL;\n    PACKET nonce;\n\n    if (!PACKET_get_net_4(pkt, &ticket_lifetime_hint)\n        || (SSL_IS_TLS13(s)\n            && (!PACKET_get_net_4(pkt, &age_add)\n                || !PACKET_get_length_prefixed_1(pkt, &nonce)\n                || !PACKET_memdup(&nonce, &s->session->ext.tick_nonce,\n                                  &s->session->ext.tick_nonce_len)))\n        || !PACKET_get_net_2(pkt, &ticklen)\n        || (!SSL_IS_TLS13(s) && PACKET_remaining(pkt) != ticklen)\n        || (SSL_IS_TLS13(s)\n            && (ticklen == 0 || PACKET_remaining(pkt) < ticklen))) {\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    /*\n     * Server is allowed to change its mind (in <=TLSv1.2) and send an empty\n     * ticket. We already checked this TLSv1.3 case above, so it should never\n     * be 0 here in that instance\n     */\n    if (ticklen == 0)\n        return MSG_PROCESS_CONTINUE_READING;\n\n    /*\n     * Sessions must be immutable once they go into the session cache. Otherwise\n     * we can get multi-thread problems. Therefore we don't \"update\" sessions,\n     * we replace them with a duplicate. In TLSv1.3 we need to do this every\n     * time a NewSessionTicket arrives because those messages arrive\n     * post-handshake and the session may have already gone into the session\n     * cache.\n     */\n    if (SSL_IS_TLS13(s) || s->session->session_id_length > 0) {\n        int i = s->session_ctx->session_cache_mode;\n        SSL_SESSION *new_sess;\n        /*\n         * We reused an existing session, so we need to replace it with a new\n         * one\n         */\n        if (i & SSL_SESS_CACHE_CLIENT) {\n            /*\n             * Remove the old session from the cache. We carry on if this fails\n             */\n            SSL_CTX_remove_session(s->session_ctx, s->session);\n        }\n\n        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        SSL_SESSION_free(s->session);\n        s->session = new_sess;\n    }\n\n    /*\n     * Technically the cast to long here is not guaranteed by the C standard -\n     * but we use it elsewhere, so this should be ok.\n     */\n    s->session->time = (long)time(NULL);\n\n    OPENSSL_free(s->session->ext.tick);\n    s->session->ext.tick = NULL;\n    s->session->ext.ticklen = 0;\n\n    s->session->ext.tick = OPENSSL_malloc(ticklen);\n    if (s->session->ext.tick == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if (!PACKET_copy_bytes(pkt, s->session->ext.tick, ticklen)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    s->session->ext.tick_lifetime_hint = ticket_lifetime_hint;\n    s->session->ext.tick_age_add = age_add;\n    s->session->ext.ticklen = ticklen;\n\n    if (SSL_IS_TLS13(s)) {\n        PACKET extpkt;\n\n        if (!PACKET_as_length_prefixed_2(pkt, &extpkt)\n                || PACKET_remaining(pkt) != 0\n                || !tls_collect_extensions(s, &extpkt,\n                                           SSL_EXT_TLS1_3_NEW_SESSION_TICKET,\n                                           &exts, &al, NULL, 1)\n                || !tls_parse_all_extensions(s,\n                                             SSL_EXT_TLS1_3_NEW_SESSION_TICKET,\n                                             exts, NULL, 0, &al, 1)) {\n            SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, SSL_R_BAD_EXTENSION);\n            goto f_err;\n        }\n    }\n\n    /*\n     * There are two ways to detect a resumed ticket session. One is to set\n     * an appropriate session ID and then the server must return a match in\n     * ServerHello. This allows the normal client session ID matching to work\n     * and we know much earlier that the ticket has been accepted. The\n     * other way is to set zero length session ID when the ticket is\n     * presented and rely on the handshake to determine session resumption.\n     * We choose the former approach because this fits in with assumptions\n     * elsewhere in OpenSSL. The session ID is set to the SHA256 (or SHA1 is\n     * SHA256 is disabled) hash of the ticket.\n     */\n    /*\n     * TODO(size_t): we use sess_len here because EVP_Digest expects an int\n     * but s->session->session_id_length is a size_t\n     */\n    if (!EVP_Digest(s->session->ext.tick, ticklen,\n                    s->session->session_id, &sess_len,\n                    EVP_sha256(), NULL)) {\n        SSLerr(SSL_F_TLS_PROCESS_NEW_SESSION_TICKET, ERR_R_EVP_LIB);\n        goto err;\n    }\n    s->session->session_id_length = sess_len;\n\n    /* This is a standalone message in TLSv1.3, so there is no more to read */\n    if (SSL_IS_TLS13(s)) {\n        OPENSSL_free(exts);\n        ssl_update_cache(s, SSL_SESS_CACHE_CLIENT);\n        return MSG_PROCESS_FINISHED_READING;\n    }\n\n    return MSG_PROCESS_CONTINUE_READING;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    ossl_statem_set_error(s);\n    OPENSSL_free(exts);\n    return MSG_PROCESS_ERROR;\n}", "target": 0}
{"idx": 4814, "func": "static int v4l2_set_parameters(AVFormatContext *s1, AVFormatParameters *ap)\n{\n    struct video_data *s = s1->priv_data;\n    struct v4l2_input input;\n    struct v4l2_standard standard;\n    struct v4l2_streamparm streamparm = { 0 };\n    struct v4l2_fract *tpf = &streamparm.parm.capture.timeperframe;\n    int i, ret;\n    AVRational framerate_q;\n\n    streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n    if (s->framerate &&\n        (ret = av_parse_video_rate(&framerate_q, s->framerate)) < 0) {\n        av_log(s1, AV_LOG_ERROR, \"Could not parse framerate '%s'.\\n\",\n               s->framerate);\n        return ret;\n    }\n\n    /* set tv video input */\n    memset (&input, 0, sizeof (input));\n    input.index = s->channel;\n    if (ioctl(s->fd, VIDIOC_ENUMINPUT, &input) < 0) {\n        av_log(s1, AV_LOG_ERROR, \"The V4L2 driver ioctl enum input failed:\\n\");\n        return AVERROR(EIO);\n    }\n\n    av_log(s1, AV_LOG_DEBUG, \"The V4L2 driver set input_id: %d, input: %s\\n\",\n            s->channel, input.name);\n    if (ioctl(s->fd, VIDIOC_S_INPUT, &input.index) < 0) {\n        av_log(s1, AV_LOG_ERROR,\n               \"The V4L2 driver ioctl set input(%d) failed\\n\",\n                s->channel);\n        return AVERROR(EIO);\n    }\n\n    if (s->standard) {\n        av_log(s1, AV_LOG_DEBUG, \"The V4L2 driver set standard: %s\\n\",\n               s->standard);\n        /* set tv standard */\n        memset (&standard, 0, sizeof (standard));\n        for(i=0;;i++) {\n            standard.index = i;\n            if (ioctl(s->fd, VIDIOC_ENUMSTD, &standard) < 0) {\n                av_log(s1, AV_LOG_ERROR,\n                       \"The V4L2 driver ioctl set standard(%s) failed\\n\",\n                       s->standard);\n                return AVERROR(EIO);\n            }\n\n            if (!av_strcasecmp(standard.name, s->standard)) {\n                break;\n            }\n        }\n\n        av_log(s1, AV_LOG_DEBUG,\n               \"The V4L2 driver set standard: %s, id: %\"PRIu64\"\\n\",\n               s->standard, (uint64_t)standard.id);\n        if (ioctl(s->fd, VIDIOC_S_STD, &standard.id) < 0) {\n            av_log(s1, AV_LOG_ERROR,\n                   \"The V4L2 driver ioctl set standard(%s) failed\\n\",\n                   s->standard);\n            return AVERROR(EIO);\n        }\n    }\n\n    if (framerate_q.num && framerate_q.den) {\n        av_log(s1, AV_LOG_DEBUG, \"Setting time per frame to %d/%d\\n\",\n               framerate_q.den, framerate_q.num);\n        tpf->numerator   = framerate_q.den;\n        tpf->denominator = framerate_q.num;\n\n        if (ioctl(s->fd, VIDIOC_S_PARM, &streamparm) != 0) {\n            av_log(s1, AV_LOG_ERROR,\n                   \"ioctl set time per frame(%d/%d) failed\\n\",\n                   framerate_q.den, framerate_q.num);\n            return AVERROR(EIO);\n        }\n\n        if (framerate_q.num != tpf->denominator ||\n            framerate_q.den != tpf->numerator) {\n            av_log(s1, AV_LOG_INFO,\n                   \"The driver changed the time per frame from \"\n                   \"%d/%d to %d/%d\\n\",\n                   framerate_q.den, framerate_q.num,\n                   tpf->numerator, tpf->denominator);\n        }\n    } else {\n        if (ioctl(s->fd, VIDIOC_G_PARM, &streamparm) != 0) {\n            av_log(s1, AV_LOG_ERROR, \"ioctl(VIDIOC_G_PARM): %s\\n\",\n                   strerror(errno));\n            return AVERROR(errno);\n        }\n    }\n    s1->streams[0]->codec->time_base.den = tpf->denominator;\n    s1->streams[0]->codec->time_base.num = tpf->numerator;\n\n    s->timeout = 100 +\n        av_rescale_q(1, s1->streams[0]->codec->time_base,\n                        (AVRational){1, 1000});\n\n    return 0;\n}", "target": 1}
{"idx": 4815, "func": "int ff_mpv_common_frame_size_change(MpegEncContext *s)\n{\n    int i, err = 0;\n\n    if (s->slice_context_count > 1) {\n        for (i = 0; i < s->slice_context_count; i++) {\n            free_duplicate_context(s->thread_context[i]);\n        }\n        for (i = 1; i < s->slice_context_count; i++) {\n            av_freep(&s->thread_context[i]);\n        }\n    } else\n        free_duplicate_context(s);\n\n    if ((err = free_context_frame(s)) < 0)\n        return err;\n\n    if (s->picture)\n        for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n                s->picture[i].needs_realloc = 1;\n        }\n\n    s->last_picture_ptr         =\n    s->next_picture_ptr         =\n    s->current_picture_ptr      = NULL;\n\n    // init\n    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n        s->mb_height = (s->height + 31) / 32 * 2;\n    else\n        s->mb_height = (s->height + 15) / 16;\n\n    if ((s->width || s->height) &&\n        av_image_check_size(s->width, s->height, 0, s->avctx))\n        return AVERROR_INVALIDDATA;\n\n    if ((err = init_context_frame(s)))\n        goto fail;\n\n    s->thread_context[0]   = s;\n\n    if (s->width && s->height) {\n        int nb_slices = s->slice_context_count;\n        if (nb_slices > 1) {\n            for (i = 1; i < nb_slices; i++) {\n                s->thread_context[i] = av_malloc(sizeof(MpegEncContext));\n                memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n            }\n\n            for (i = 0; i < nb_slices; i++) {\n                if (init_duplicate_context(s->thread_context[i]) < 0)\n                    goto fail;\n                    s->thread_context[i]->start_mb_y =\n                        (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n                    s->thread_context[i]->end_mb_y   =\n                        (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n            }\n        } else {\n            if (init_duplicate_context(s) < 0)\n                goto fail;\n            s->start_mb_y = 0;\n            s->end_mb_y   = s->mb_height;\n        }\n        s->slice_context_count = nb_slices;\n    }\n\n    return 0;\n fail:\n    ff_mpv_common_end(s);\n    return err;\n}", "target": 1}
{"idx": 4816, "func": "int custom_exts_copy_flags(custom_ext_methods *dst,\n                           const custom_ext_methods *src)\n{\n    size_t i;\n    custom_ext_method *methsrc = src->meths;\n\n    for (i = 0; i < src->meths_count; i++, methsrc++) {\n        custom_ext_method *methdst = custom_ext_find(dst, methsrc->role,\n                                                     methsrc->ext_type, NULL);\n\n        if (methdst == NULL)\n            continue;\n\n        methdst->ext_flags = methsrc->ext_flags;\n    }\n\n    return 1;\n}", "target": 1}
{"idx": 4817, "func": "static const char *json_escape_str(char **dst, size_t *dst_size, const char *src,\n                                   void *log_ctx)\n{\n    static const char json_escape[] = {'\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t', 0};\n    static const char json_subst[]  = {'\"', '\\\\',  'b',  'f',  'n',  'r',  't', 0};\n    const char *p;\n    char *q;\n    size_t size = 1;\n\n    // compute the length of the escaped string\n    for (p = src; *p; p++) {\n        ESCAPE_CHECK_SIZE(src, size, SIZE_MAX-6);\n        if (strchr(json_escape, *p))     size += 2; // simple escape\n        else if ((unsigned char)*p < 32) size += 6; // handle non-printable chars\n        else                             size += 1; // char copy\n    }\n    ESCAPE_REALLOC_BUF(dst_size, dst, src, size);\n\n    q = *dst;\n    for (p = src; *p; p++) {\n        char *s = strchr(json_escape, *p);\n        if (s) {\n            *q++ = '\\\\';\n            *q++ = json_subst[s - json_escape];\n        } else if ((unsigned char)*p < 32) {\n            snprintf(q, 7, \"\\\\u00%02x\", *p & 0xff);\n            q += 6;\n        } else {\n            *q++ = *p;\n        }\n    }\n    *q = 0;\n    return *dst;\n}", "target": 0}
{"idx": 4818, "func": "void av_aes_crypt(AVAES *a, uint8_t *dst_, const uint8_t *src_,\n                  int count, uint8_t *iv_, int decrypt)\n{\n    av_aes_block       *dst = (av_aes_block *) dst_;\n    const av_aes_block *src = (const av_aes_block *) src_;\n    av_aes_block        *iv = (av_aes_block *) iv_;\n\n    while (count--) {\n        addkey(&a->state[1], src, &a->round_key[a->rounds]);\n        if (decrypt) {\n            crypt(a, 0, inv_sbox, dec_multbl);\n            if (iv) {\n                addkey(&a->state[0], &a->state[0], iv);\n                *iv = *src;\n            }\n            addkey(dst, &a->state[0], &a->round_key[0]);\n        } else {\n            if (iv)\n                addkey(&a->state[1], &a->state[1], iv);\n            crypt(a, 2, sbox, enc_multbl);\n            addkey(dst, &a->state[0], &a->round_key[0]);\n            if (iv)\n                *iv = *dst;\n        }\n        src++;\n        dst++;\n    }\n}", "target": 0}
{"idx": 4819, "func": "static int sskdf_derive(void *vctx, unsigned char *key, size_t keylen)\n{\n    KDF_SSKDF *ctx = (KDF_SSKDF *)vctx;\n    const EVP_MD *md = ossl_prov_digest_md(&ctx->digest);\n\n    if (ctx->secret == NULL) {\n        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_SECRET);\n        return 0;\n    }\n\n    if (ctx->mac != NULL) {\n        /* H(x) = KMAC or H(x) = HMAC */\n        int ret;\n        const unsigned char *custom = NULL;\n        size_t custom_len = 0;\n        const char *macname;\n        int default_salt_len;\n\n        /*\n         * TODO(3.0) investigate the necessity to have all these controls.\n         * Why does KMAC require a salt length that's shorter than the MD\n         * block size?\n         */\n        macname = EVP_MAC_name(ctx->mac);\n        if (strcmp(macname, OSSL_MAC_NAME_HMAC) == 0) {\n            /* H(x) = HMAC(x, salt, hash) */\n            if (md == NULL) {\n                ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);\n                return 0;\n            }\n            default_salt_len = EVP_MD_block_size(md);\n            if (default_salt_len <= 0)\n                return 0;\n        } else if (strcmp(macname, OSSL_MAC_NAME_KMAC128) == 0\n                   || strcmp(macname, OSSL_MAC_NAME_KMAC256) == 0) {\n            /* H(x) = KMACzzz(x, salt, custom) */\n            custom = kmac_custom_str;\n            custom_len = sizeof(kmac_custom_str);\n            if (strcmp(macname, OSSL_MAC_NAME_KMAC128) == 0)\n                default_salt_len = SSKDF_KMAC128_DEFAULT_SALT_SIZE;\n            else\n                default_salt_len = SSKDF_KMAC256_DEFAULT_SALT_SIZE;\n        } else {\n            ERR_raise(ERR_LIB_PROV, PROV_R_UNSUPPORTED_MAC_TYPE);\n            return 0;\n        }\n        /* If no salt is set then use a default_salt of zeros */\n        if (ctx->salt == NULL || ctx->salt_len <= 0) {\n            ctx->salt = OPENSSL_zalloc(default_salt_len);\n            if (ctx->salt == NULL) {\n                ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n            ctx->salt_len = default_salt_len;\n        }\n        ret = SSKDF_mac_kdm(ctx->mac, md,\n                            custom, custom_len, ctx->out_len,\n                            ctx->salt, ctx->salt_len,\n                            ctx->secret, ctx->secret_len,\n                            ctx->info, ctx->info_len, key, keylen);\n        return ret;\n    } else {\n        /* H(x) = hash */\n        if (md == NULL) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);\n            return 0;\n        }\n        return SSKDF_hash_kdm(md, ctx->secret, ctx->secret_len,\n                              ctx->info, ctx->info_len, 0, key, keylen);\n    }\n}", "target": 1}
{"idx": 4820, "func": "static float quantize_band_cost(struct AACEncContext *s, const float *in,\n                                const float *scaled, int size, int scale_idx,\n                                int cb, const float lambda, const float uplim,\n                                int *bits)\n{\n    const float IQ = ff_aac_pow2sf_tab[200 + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n    const float  Q = ff_aac_pow2sf_tab[200 - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n    const float CLIPPED_ESCAPE = 165140.0f*IQ;\n    int i, j, k;\n    float cost = 0;\n    const int dim = cb < FIRST_PAIR_BT ? 4 : 2;\n    int resbits = 0;\n#ifndef USE_REALLY_FULL_SEARCH\n    const float  Q34 = sqrtf(Q * sqrtf(Q));\n    const int range  = aac_cb_range[cb];\n    const int maxval = aac_cb_maxval[cb];\n    int offs[4];\n#endif /* USE_REALLY_FULL_SEARCH */\n\n    if (!cb) {\n        for (i = 0; i < size; i++)\n            cost += in[i]*in[i];\n        if (bits)\n            *bits = 0;\n        return cost * lambda;\n    }\n#ifndef USE_REALLY_FULL_SEARCH\n    offs[0] = 1;\n    for (i = 1; i < dim; i++)\n        offs[i] = offs[i-1]*range;\n    quantize_bands(s->qcoefs, in, scaled, size, Q34, !IS_CODEBOOK_UNSIGNED(cb), maxval);\n#endif /* USE_REALLY_FULL_SEARCH */\n    for (i = 0; i < size; i += dim) {\n        float mincost;\n        int minidx  = 0;\n        int minbits = 0;\n        const float *vec;\n#ifndef USE_REALLY_FULL_SEARCH\n        int (*quants)[2] = &s->qcoefs[i];\n        mincost = 0.0f;\n        for (j = 0; j < dim; j++)\n            mincost += in[i+j]*in[i+j];\n        minidx = IS_CODEBOOK_UNSIGNED(cb) ? 0 : 40;\n        minbits = ff_aac_spectral_bits[cb-1][minidx];\n        mincost = mincost * lambda + minbits;\n        for (j = 0; j < (1<<dim); j++) {\n            float rd = 0.0f;\n            int curbits;\n            int curidx = IS_CODEBOOK_UNSIGNED(cb) ? 0 : 40;\n            int same   = 0;\n            for (k = 0; k < dim; k++) {\n                if ((j & (1 << k)) && quants[k][0] == quants[k][1]) {\n                    same = 1;\n                    break;\n                }\n            }\n            if (same)\n                continue;\n            for (k = 0; k < dim; k++)\n                curidx += quants[k][!!(j & (1 << k))] * offs[dim - 1 - k];\n            curbits =  ff_aac_spectral_bits[cb-1][curidx];\n            vec     = &ff_aac_codebook_vectors[cb-1][curidx*dim];\n#else\n        mincost = INFINITY;\n        vec = ff_aac_codebook_vectors[cb-1];\n        for (j = 0; j < ff_aac_spectral_sizes[cb-1]; j++, vec += dim) {\n            float rd = 0.0f;\n            int curbits = ff_aac_spectral_bits[cb-1][j];\n#endif /* USE_REALLY_FULL_SEARCH */\n            if (IS_CODEBOOK_UNSIGNED(cb)) {\n                for (k = 0; k < dim; k++) {\n                    float t = fabsf(in[i+k]);\n                    float di;\n                    if (vec[k] == 64.0f) { //FIXME: slow\n                        //do not code with escape sequence small values\n                        if (t < 39.0f*IQ) {\n                            rd = INFINITY;\n                            break;\n                        }\n                        if (t >= CLIPPED_ESCAPE) {\n                            di = t - CLIPPED_ESCAPE;\n                            curbits += 21;\n                        } else {\n                            int c = av_clip(quant(t, Q), 0, 8191);\n                            di = t - c*cbrtf(c)*IQ;\n                            curbits += av_log2(c)*2 - 4 + 1;\n                        }\n                    } else {\n                        di = t - vec[k]*IQ;\n                    }\n                    if (vec[k] != 0.0f)\n                        curbits++;\n                    rd += di*di;\n                }\n            } else {\n                for (k = 0; k < dim; k++) {\n                    float di = in[i+k] - vec[k]*IQ;\n                    rd += di*di;\n                }\n            }\n            rd = rd * lambda + curbits;\n            if (rd < mincost) {\n                mincost = rd;\n                minidx  = j;\n                minbits = curbits;\n            }\n        }\n        cost    += mincost;\n        resbits += minbits;\n        if (cost >= uplim)\n            return uplim;\n    }\n\n    if (bits)\n        *bits = resbits;\n    return cost;\n}", "target": 1}
{"idx": 4821, "func": "static int do_print_item(const TEST_PACKAGE *package)\n{\n#define DATA_BUF_SIZE 256\n    const ASN1_ITEM *i = ASN1_ITEM_ptr(package->asn1_type);\n    ASN1_VALUE *o;\n    int ret;\n\n    OPENSSL_assert(package->encode_expectations_elem_size <= DATA_BUF_SIZE);\n    if ((o = OPENSSL_malloc(DATA_BUF_SIZE)) == NULL)\n        return 0;\n\n    (void)RAND_bytes((unsigned char*)o,\n                     (int)package->encode_expectations_elem_size);\n    ret = ASN1_item_print(bio_err, o, 0, i, NULL);\n    OPENSSL_free(o);\n\n    return ret;\n}", "target": 0}
{"idx": 4822, "func": "void\nngx_http_file_cache_free(ngx_http_cache_t *c, ngx_temp_file_t *tf)\n{\n    ngx_http_file_cache_t       *cache;\n    ngx_http_file_cache_node_t  *fcn;\n\n    if (c->updated) {\n        return;\n    }\n\n    cache = c->file_cache;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->file.log, 0,\n                   \"http file cache free\");\n\n    ngx_shmtx_lock(&cache->shpool->mutex);\n\n    fcn = c->node;\n    fcn->count--;\n\n    if (c->updating) {\n        fcn->updating = 0;\n    }\n\n    if (c->error) {\n        fcn->valid_sec = c->valid_sec;\n        fcn->valid_msec = c->valid_msec;\n        fcn->error = c->error;\n\n    } else if (!fcn->exists && fcn->count == 0) {\n        ngx_queue_remove(&fcn->queue);\n        ngx_rbtree_delete(&cache->sh->rbtree, &fcn->node);\n        ngx_slab_free_locked(cache->shpool, fcn);\n        c->node = NULL;\n    }\n\n    ngx_shmtx_unlock(&cache->shpool->mutex);\n\n    c->updated = 1;\n    c->updating = 0;\n\n    if (c->temp_file) {\n        if (tf && tf->file.fd != NGX_INVALID_FILE) {\n            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->file.log, 0,\n                           \"http file cache incomplete: \\\"%s\\\"\",\n                           tf->file.name.data);\n\n            if (ngx_delete_file(tf->file.name.data) == NGX_FILE_ERROR) {\n                ngx_log_error(NGX_LOG_CRIT, c->file.log, ngx_errno,\n                              ngx_delete_file_n \" \\\"%s\\\" failed\",\n                              tf->file.name.data);\n            }\n        }\n    }\n}", "target": 0}
{"idx": 4823, "func": "OPENSSL_INIT_SETTINGS *OPENSSL_INIT_new(void)\n{\n    OPENSSL_INIT_SETTINGS *ret = malloc(sizeof(*ret));\n\n    if (ret != NULL)\n        memset(ret, 0, sizeof(*ret));\n    return ret;\n}", "target": 0}
{"idx": 4824, "func": "static av_cold int adpcm_encode_init(AVCodecContext *avctx)\n{\n    ADPCMEncodeContext *s = avctx->priv_data;\n    uint8_t *extradata;\n    int i;\n    if (avctx->channels > 2)\n        return -1; /* only stereo or mono =) */\n\n    if (avctx->trellis && (unsigned)avctx->trellis > 16U) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid trellis size\\n\");\n        return -1;\n    }\n\n    if (avctx->trellis) {\n        int frontier  = 1 << avctx->trellis;\n        int max_paths =  frontier * FREEZE_INTERVAL;\n        FF_ALLOC_OR_GOTO(avctx, s->paths,\n                         max_paths * sizeof(*s->paths), error);\n        FF_ALLOC_OR_GOTO(avctx, s->node_buf,\n                         2 * frontier * sizeof(*s->node_buf),  error);\n        FF_ALLOC_OR_GOTO(avctx, s->nodep_buf,\n                         2 * frontier * sizeof(*s->nodep_buf), error);\n        FF_ALLOC_OR_GOTO(avctx, s->trellis_hash,\n                         65536 * sizeof(*s->trellis_hash), error);\n    }\n\n    avctx->bits_per_coded_sample = av_get_bits_per_sample(avctx->codec->id);\n\n    switch (avctx->codec->id) {\n    case CODEC_ID_ADPCM_IMA_WAV:\n        /* each 16 bits sample gives one nibble\n           and we have 4 bytes per channel overhead */\n        avctx->frame_size = (BLKSIZE - 4 * avctx->channels) * 8 /\n                            (4 * avctx->channels) + 1;\n        /* seems frame_size isn't taken into account...\n           have to buffer the samples :-( */\n        avctx->block_align = BLKSIZE;\n        avctx->bits_per_coded_sample = 4;\n        break;\n    case CODEC_ID_ADPCM_IMA_QT:\n        avctx->frame_size  = 64;\n        avctx->block_align = 34 * avctx->channels;\n        break;\n    case CODEC_ID_ADPCM_MS:\n        /* each 16 bits sample gives one nibble\n           and we have 7 bytes per channel overhead */\n        avctx->frame_size = (BLKSIZE - 7 * avctx->channels) * 2 / avctx->channels + 2;\n        avctx->block_align = BLKSIZE;\n        avctx->bits_per_coded_sample = 4;\n        avctx->extradata_size = 32;\n        extradata = avctx->extradata = av_malloc(avctx->extradata_size);\n        if (!extradata)\n            return AVERROR(ENOMEM);\n        bytestream_put_le16(&extradata, avctx->frame_size);\n        bytestream_put_le16(&extradata, 7); /* wNumCoef */\n        for (i = 0; i < 7; i++) {\n            bytestream_put_le16(&extradata, ff_adpcm_AdaptCoeff1[i] * 4);\n            bytestream_put_le16(&extradata, ff_adpcm_AdaptCoeff2[i] * 4);\n        }\n        break;\n    case CODEC_ID_ADPCM_YAMAHA:\n        avctx->frame_size  = BLKSIZE * avctx->channels;\n        avctx->block_align = BLKSIZE;\n        break;\n    case CODEC_ID_ADPCM_SWF:\n        if (avctx->sample_rate != 11025 &&\n            avctx->sample_rate != 22050 &&\n            avctx->sample_rate != 44100) {\n            av_log(avctx, AV_LOG_ERROR, \"Sample rate must be 11025, \"\n                   \"22050 or 44100\\n\");\n            goto error;\n        }\n        avctx->frame_size = 512 * (avctx->sample_rate / 11025);\n        break;\n    default:\n        goto error;\n    }\n\n    avctx->coded_frame = avcodec_alloc_frame();\n    avctx->coded_frame->key_frame= 1;\n\n    return 0;\nerror:\n    av_freep(&s->paths);\n    av_freep(&s->node_buf);\n    av_freep(&s->nodep_buf);\n    av_freep(&s->trellis_hash);\n    return -1;\n}", "target": 1}
{"idx": 4825, "func": "static int ftp_get_line(FTPContext *s, char *line, int line_size)\n{\n    int ch;\n    char *q = line;\n    int ori_block_flag = s->conn_control_block_flag;\n\n    for (;;) {\n        ch = ftp_getc(s);\n        if (ch < 0) {\n            s->conn_control_block_flag = ori_block_flag;\n            return ch;\n        }\n        if (ch == '\\n') {\n            /* process line */\n            if (q > line && q[-1] == '\\r')\n                q--;\n            *q = '\\0';\n\n            s->conn_control_block_flag = ori_block_flag;\n            return 0;\n        } else {\n            s->conn_control_block_flag = 0; /* line need to be finished */\n            if ((q - line) < line_size - 1)\n                *q++ = ch;\n        }\n    }\n}", "target": 1}
{"idx": 4826, "func": "static int normalize_samples(AC3EncodeContext *s)\n{\n    int v = 14 - log2_tab(s, s->windowed_samples, AC3_WINDOW_SIZE);\n    lshift_tab(s->windowed_samples, AC3_WINDOW_SIZE, v);\n    /* +6 to right-shift from 31-bit to 25-bit */\n    return v + 6;\n}", "target": 0}
{"idx": 4827, "func": "void\nngx_http_init_connection(ngx_connection_t *c)\n{\n    ngx_uint_t              i;\n    ngx_event_t            *rev;\n    struct sockaddr_in     *sin;\n    ngx_http_port_t        *port;\n    ngx_http_in_addr_t     *addr;\n    ngx_http_log_ctx_t     *ctx;\n    ngx_http_connection_t  *hc;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6    *sin6;\n    ngx_http_in6_addr_t    *addr6;\n#endif\n\n    hc = ngx_pcalloc(c->pool, sizeof(ngx_http_connection_t));\n    if (hc == NULL) {\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    c->data = hc;\n\n    /* find the server configuration for the address:port */\n\n    port = c->listening->servers;\n\n    if (port->naddrs > 1) {\n\n        /*\n         * there are several addresses on this port and one of them\n         * is an \"*:port\" wildcard so getsockname() in ngx_http_server_addr()\n         * is required to determine a server address\n         */\n\n        if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {\n            ngx_http_close_connection(c);\n            return;\n        }\n\n        switch (c->local_sockaddr->sa_family) {\n\n#if (NGX_HAVE_INET6)\n        case AF_INET6:\n            sin6 = (struct sockaddr_in6 *) c->local_sockaddr;\n\n            addr6 = port->addrs;\n\n            /* the last address is \"*\" */\n\n            for (i = 0; i < port->naddrs - 1; i++) {\n                if (ngx_memcmp(&addr6[i].addr6, &sin6->sin6_addr, 16) == 0) {\n                    break;\n                }\n            }\n\n            hc->addr_conf = &addr6[i].conf;\n\n            break;\n#endif\n\n        default: /* AF_INET */\n            sin = (struct sockaddr_in *) c->local_sockaddr;\n\n            addr = port->addrs;\n\n            /* the last address is \"*\" */\n\n            for (i = 0; i < port->naddrs - 1; i++) {\n                if (addr[i].addr == sin->sin_addr.s_addr) {\n                    break;\n                }\n            }\n\n            hc->addr_conf = &addr[i].conf;\n\n            break;\n        }\n\n    } else {\n\n        switch (c->local_sockaddr->sa_family) {\n\n#if (NGX_HAVE_INET6)\n        case AF_INET6:\n            addr6 = port->addrs;\n            hc->addr_conf = &addr6[0].conf;\n            break;\n#endif\n\n        default: /* AF_INET */\n            addr = port->addrs;\n            hc->addr_conf = &addr[0].conf;\n            break;\n        }\n    }\n\n    /* the default server configuration for the address:port */\n    hc->conf_ctx = hc->addr_conf->default_server->ctx;\n\n    ctx = ngx_palloc(c->pool, sizeof(ngx_http_log_ctx_t));\n    if (ctx == NULL) {\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    ctx->connection = c;\n    ctx->request = NULL;\n    ctx->current_request = NULL;\n\n    c->log->connection = c->number;\n    c->log->handler = ngx_http_log_error;\n    c->log->data = ctx;\n    c->log->action = \"reading client request line\";\n\n    c->log_error = NGX_ERROR_INFO;\n\n    rev = c->read;\n    rev->handler = ngx_http_init_request;\n    c->write->handler = ngx_http_empty_handler;\n\n#if (NGX_HTTP_SSL)\n    {\n    ngx_http_ssl_srv_conf_t  *sscf;\n\n    sscf = ngx_http_get_module_srv_conf(hc->conf_ctx, ngx_http_ssl_module);\n\n    if (sscf->enable || hc->addr_conf->ssl) {\n\n        c->log->action = \"SSL handshaking\";\n\n        if (hc->addr_conf->ssl && sscf->ssl.ctx == NULL) {\n            ngx_log_error(NGX_LOG_ERR, c->log, 0,\n                          \"no \\\"ssl_certificate\\\" is defined \"\n                          \"in server listening on SSL port\");\n            ngx_http_close_connection(c);\n            return;\n        }\n\n        hc->ssl = 1;\n\n        rev->handler = ngx_http_ssl_handshake;\n    }\n    }\n#endif\n\n    if (rev->ready) {\n        /* the deferred accept(), rtsig, aio, iocp */\n\n        if (ngx_use_accept_mutex) {\n            ngx_post_event(rev, &ngx_posted_events);\n            return;\n        }\n\n        rev->handler(rev);\n        return;\n    }\n\n    ngx_add_timer(rev, c->listening->post_accept_timeout);\n\n    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n        ngx_http_close_connection(c);\n        return;\n    }\n}", "target": 0}
{"idx": 4828, "func": "enum AVCodecID ff_get_pcm_codec_id(int bps, int flt, int be, int sflags)\n{\n    if (bps <= 0 || bps > 64)\n        return AV_CODEC_ID_NONE;\n\n    if (flt) {\n        switch (bps) {\n        case 32:\n            return be ? AV_CODEC_ID_PCM_F32BE : AV_CODEC_ID_PCM_F32LE;\n        case 64:\n            return be ? AV_CODEC_ID_PCM_F64BE : AV_CODEC_ID_PCM_F64LE;\n        default:\n            return AV_CODEC_ID_NONE;\n        }\n    } else {\n        bps  += 7;\n        bps >>= 3;\n        if (sflags & (1 << (bps - 1))) {\n            switch (bps) {\n            case 1:\n                return AV_CODEC_ID_PCM_S8;\n            case 2:\n                return be ? AV_CODEC_ID_PCM_S16BE : AV_CODEC_ID_PCM_S16LE;\n            case 3:\n                return be ? AV_CODEC_ID_PCM_S24BE : AV_CODEC_ID_PCM_S24LE;\n            case 4:\n                return be ? AV_CODEC_ID_PCM_S32BE : AV_CODEC_ID_PCM_S32LE;\n            default:\n                return AV_CODEC_ID_NONE;\n            }\n        } else {\n            switch (bps) {\n            case 1:\n                return AV_CODEC_ID_PCM_U8;\n            case 2:\n                return be ? AV_CODEC_ID_PCM_U16BE : AV_CODEC_ID_PCM_U16LE;\n            case 3:\n                return be ? AV_CODEC_ID_PCM_U24BE : AV_CODEC_ID_PCM_U24LE;\n            case 4:\n                return be ? AV_CODEC_ID_PCM_U32BE : AV_CODEC_ID_PCM_U32LE;\n            default:\n                return AV_CODEC_ID_NONE;\n            }\n        }\n    }\n}", "target": 0}
{"idx": 4829, "func": "static void fe_add(fe h, const fe f, const fe g) {\n  unsigned i;\n  for (i = 0; i < 10; i++) {\n    h[i] = f[i] + g[i];\n  }\n}", "target": 1}
{"idx": 4830, "func": "int MAIN(int argc, char **argv)\n\t{\n\tENGINE *e = NULL;\n\tint ret=1;\n\tRSA *rsa=NULL;\n\tint i,num=DEFBITS;\n\tlong l;\n\tEVP_CIPHER *enc=NULL;\n\tunsigned long f4=RSA_F4;\n\tchar *outfile=NULL;\n\tchar *passargout = NULL, *passout = NULL;\n\tchar *engine=NULL;\n\tchar *inrand=NULL;\n\tBIO *out=NULL;\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\tif ((out=BIO_new(BIO_s_file())) == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to create BIO for output\\n\");\n\t\tgoto err;\n\t\t}\n\n\targv++;\n\targc--;\n\tfor (;;)\n\t\t{\n\t\tif (argc <= 0) break;\n\t\tif (strcmp(*argv,\"-out\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-3\") == 0)\n\t\t\tf4=3;\n\t\telse if (strcmp(*argv,\"-F4\") == 0 || strcmp(*argv,\"-f4\") == 0)\n\t\t\tf4=RSA_F4;\n\t\telse if (strcmp(*argv,\"-engine\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tengine= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-rand\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinrand= *(++argv);\n\t\t\t}\n#ifndef NO_DES\n\t\telse if (strcmp(*argv,\"-des\") == 0)\n\t\t\tenc=EVP_des_cbc();\n\t\telse if (strcmp(*argv,\"-des3\") == 0)\n\t\t\tenc=EVP_des_ede3_cbc();\n#endif\n#ifndef NO_IDEA\n\t\telse if (strcmp(*argv,\"-idea\") == 0)\n\t\t\tenc=EVP_idea_cbc();\n#endif\n\t\telse if (strcmp(*argv,\"-passout\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tpassargout= *(++argv);\n\t\t\t}\n\t\telse\n\t\t\tbreak;\n\t\targv++;\n\t\targc--;\n\t\t}\n\tif ((argc >= 1) && ((sscanf(*argv,\"%d\",&num) == 0) || (num < 0)))\n\t\t{\nbad:\n\t\tBIO_printf(bio_err,\"usage: genrsa [args] [numbits]\\n\");\n\t\tBIO_printf(bio_err,\" -des            encrypt the generated key with DES in cbc mode\\n\");\n\t\tBIO_printf(bio_err,\" -des3           encrypt the generated key with DES in ede cbc mode (168 bit key)\\n\");\n#ifndef NO_IDEA\n\t\tBIO_printf(bio_err,\" -idea           encrypt the generated key with IDEA in cbc mode\\n\");\n#endif\n\t\tBIO_printf(bio_err,\" -out file       output the key to 'file\\n\");\n\t\tBIO_printf(bio_err,\" -passout arg    output file pass phrase source\\n\");\n\t\tBIO_printf(bio_err,\" -f4             use F4 (0x10001) for the E value\\n\");\n\t\tBIO_printf(bio_err,\" -3              use 3 for the E value\\n\");\n\t\tBIO_printf(bio_err,\" -engine e       use engine e, possibly a hardware device.\\n\");\n\t\tBIO_printf(bio_err,\" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\n\t\tBIO_printf(bio_err,\"                 load the file (or the files in the directory) into\\n\");\n\t\tBIO_printf(bio_err,\"                 the random number generator\\n\");\n\t\tgoto err;\n\t\t}\n\t\t\n\tERR_load_crypto_strings();\n\n\tif(!app_passwd(bio_err, NULL, passargout, NULL, &passout)) {\n\t\tBIO_printf(bio_err, \"Error getting password\\n\");\n\t\tgoto err;\n\t}\n\n\tif (engine != NULL)\n\t\t{\n\t\tif((e = ENGINE_by_id(engine)) == NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"invalid engine \\\"%s\\\"\\n\",\n\t\t\t\tengine);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif(!ENGINE_set_default(e, ENGINE_METHOD_ALL))\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"can't use that engine\\n\");\n\t\t\tgoto err;\n\t\t\t}\n\t\tBIO_printf(bio_err,\"engine \\\"%s\\\" set.\\n\", engine);\n\t\t/* Free our \"structural\" reference. */\n\t\tENGINE_free(e);\n\t\t}\n\n\tif (outfile == NULL)\n\t\t{\n\t\tBIO_set_fp(out,stdout,BIO_NOCLOSE);\n#ifdef VMS\n\t\t{\n\t\tBIO *tmpbio = BIO_new(BIO_f_linebuffer());\n\t\tout = BIO_push(tmpbio, out);\n\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\tif (BIO_write_filename(out,outfile) <= 0)\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\tif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL\n\t\t&& !RAND_status())\n\t\t{\n\t\tBIO_printf(bio_err,\"warning, not much extra random data, consider using the -rand option\\n\");\n\t\t}\n\tif (inrand != NULL)\n\t\tBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\n\t\t\tapp_RAND_load_files(inrand));\n\n\tBIO_printf(bio_err,\"Generating RSA private key, %d bit long modulus\\n\",\n\t\tnum);\n\trsa=RSA_generate_key(num,f4,genrsa_cb,bio_err);\n\t\t\n\tapp_RAND_write_file(NULL, bio_err);\n\n\tif (rsa == NULL) goto err;\n\t\n\t/* We need to do the following for when the base number size is <\n\t * long, esp windows 3.1 :-(. */\n\tl=0L;\n\tfor (i=0; i<rsa->e->top; i++)\n\t\t{\n#ifndef SIXTY_FOUR_BIT\n\t\tl<<=BN_BITS4;\n\t\tl<<=BN_BITS4;\n#endif\n\t\tl+=rsa->e->d[i];\n\t\t}\n\tBIO_printf(bio_err,\"e is %ld (0x%lX)\\n\",l,l);\n\tif (!PEM_write_bio_RSAPrivateKey(out,rsa,enc,NULL,0,NULL, passout))\n\t\tgoto err;\n\n\tret=0;\nerr:\n\tif (rsa != NULL) RSA_free(rsa);\n\tif (out != NULL) BIO_free_all(out);\n\tif(passout) OPENSSL_free(passout);\n\tif (ret != 0)\n\t\tERR_print_errors(bio_err);\n\tEXIT(ret);\n\t}", "target": 0}
{"idx": 4831, "func": "const X509V3_EXT_METHOD *X509V3_EXT_get_nid(int nid)\n{\n\tX509V3_EXT_METHOD tmp;\n\tconst X509V3_EXT_METHOD *t = &tmp, * const *ret;\n\tint idx;\n\tif(nid < 0) return NULL;\n\ttmp.ext_nid = nid;\n\tret = OBJ_bsearch_ext(&t, standard_exts, STANDARD_EXTENSION_COUNT);\n\tif(ret) return *ret;\n\tif(!ext_list) return NULL;\n\tidx = sk_X509V3_EXT_METHOD_find(ext_list, &tmp);\n\tif(idx == -1) return NULL;\n\treturn sk_X509V3_EXT_METHOD_value(ext_list, idx);\n}", "target": 0}
{"idx": 4832, "func": "DSA_SIG *unpack_cp_signature(const unsigned char *sig, size_t siglen)\n{\n    DSA_SIG *s;\n\n    s = DSA_SIG_new();\n    if (s == NULL) {\n        GOSTerr(GOST_F_UNPACK_CP_SIGNATURE, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    s->s = BN_bin2bn(sig, siglen / 2, NULL);\n    s->r = BN_bin2bn(sig + siglen / 2, siglen / 2, NULL);\n    return s;\n}", "target": 0}
{"idx": 4833, "func": "static int test_kdf_pbkdf2(void)\n{\n    int ret;\n    EVP_KDF_CTX *kctx;\n    unsigned char out[32];\n    const unsigned char expected[sizeof(out)] = {\n        0xae, 0x4d, 0x0c, 0x95, 0xaf, 0x6b, 0x46, 0xd3,\n        0x2d, 0x0a, 0xdf, 0xf9, 0x28, 0xf0, 0x6d, 0xd0,\n        0x2a, 0x30, 0x3f, 0x8e, 0xf3, 0xc2, 0x51, 0xdf,\n        0xd6, 0xe2, 0xd8, 0x5a, 0x95, 0x47, 0x4c, 0x43\n    };\n\n    ret = TEST_ptr(kctx = EVP_KDF_CTX_new_id(EVP_KDF_PBKDF2))\n          && TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PASS, \"password\",\n                                      (size_t)8), 0)\n          && TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT, \"salt\",\n                                      (size_t)4), 0)\n          && TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_ITER, 2), 0)\n          && TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()),\n                         0)\n          && TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)\n          && TEST_mem_eq(out, sizeof(out), expected, sizeof(expected));\n\n    EVP_KDF_CTX_free(kctx);\n    return ret;\n}", "target": 0}
{"idx": 4834, "func": "static void sr_1d97_int(int32_t *p, int i0, int i1)\n{\n    int i;\n\n    if (i1 <= i0 + 1) {\n        if (i0 == 1)\n            p[1] = (p[1] * I_LFTG_K + (1<<16)) >> 17;\n        else\n            p[0] = (p[0] * I_LFTG_X + (1<<16)) >> 17;\n        return;\n    }\n\n    extend97_int(p, i0, i1);\n\n    for (i = i0 / 2 - 1; i < i1 / 2 + 2; i++)\n        p[2 * i]     -= (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n    /* step 4 */\n    for (i = i0 / 2 - 1; i < i1 / 2 + 1; i++)\n        p[2 * i + 1] -= (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n    /*step 5*/\n    for (i = i0 / 2; i < i1 / 2 + 1; i++)\n        p[2 * i]     += (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n    /* step 6 */\n    for (i = i0 / 2; i < i1 / 2; i++)\n        p[2 * i + 1] += (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n}", "target": 1}
{"idx": 4835, "func": "int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)\n{\n    int max, al;\n    int ret = 0;\n    BIGNUM *tmp, *rr;\n\n    bn_check_top(a);\n\n    al = a->top;\n    if (al <= 0) {\n        r->top = 0;\n        r->neg = 0;\n        return 1;\n    }\n\n    BN_CTX_start(ctx);\n    rr = (a != r) ? r : BN_CTX_get(ctx);\n    tmp = BN_CTX_get(ctx);\n    if (!rr || !tmp)\n        goto err;\n\n    max = 2 * al;               /* Non-zero (from above) */\n    if (bn_wexpand(rr, max) == NULL)\n        goto err;\n\n    if (al == 4) {\n#ifndef BN_SQR_COMBA\n        BN_ULONG t[8];\n        bn_sqr_normal(rr->d, a->d, 4, t);\n#else\n        bn_sqr_comba4(rr->d, a->d);\n#endif\n    } else if (al == 8) {\n#ifndef BN_SQR_COMBA\n        BN_ULONG t[16];\n        bn_sqr_normal(rr->d, a->d, 8, t);\n#else\n        bn_sqr_comba8(rr->d, a->d);\n#endif\n    } else {\n#if defined(BN_RECURSION)\n        if (al < BN_SQR_RECURSIVE_SIZE_NORMAL) {\n            BN_ULONG t[BN_SQR_RECURSIVE_SIZE_NORMAL * 2];\n            bn_sqr_normal(rr->d, a->d, al, t);\n        } else {\n            int j, k;\n\n            j = BN_num_bits_word((BN_ULONG)al);\n            j = 1 << (j - 1);\n            k = j + j;\n            if (al == j) {\n                if (bn_wexpand(tmp, k * 2) == NULL)\n                    goto err;\n                bn_sqr_recursive(rr->d, a->d, al, tmp->d);\n            } else {\n                if (bn_wexpand(tmp, max) == NULL)\n                    goto err;\n                bn_sqr_normal(rr->d, a->d, al, tmp->d);\n            }\n        }\n#else\n        if (bn_wexpand(tmp, max) == NULL)\n            goto err;\n        bn_sqr_normal(rr->d, a->d, al, tmp->d);\n#endif\n    }\n\n    rr->neg = 0;\n    /*\n     * If the most-significant half of the top word of 'a' is zero, then the\n     * square of 'a' will max-1 words.\n     */\n    if (a->d[al - 1] == (a->d[al - 1] & BN_MASK2l))\n        rr->top = max - 1;\n    else\n        rr->top = max;\n    if (r != rr && BN_copy(r, rr) == NULL)\n        goto err;\n\n    ret = 1;\n err:\n    bn_check_top(rr);\n    bn_check_top(tmp);\n    BN_CTX_end(ctx);\n    return (ret);\n}", "target": 0}
{"idx": 4836, "func": "int SSL_get_changed_async_fds(SSL *s, OSSL_ASYNC_FD *addfd, size_t *numaddfds,\n                              OSSL_ASYNC_FD *delfd, size_t *numdelfds)\n{\n    ASYNC_WAIT_CTX *ctx = s->waitctx;\n\n    if (ctx == NULL)\n        return 0;\n    return ASYNC_WAIT_CTX_get_changed_fds(ctx, addfd, numaddfds, delfd,\n                                          numdelfds);\n}", "target": 0}
{"idx": 4837, "func": "AP_DECLARE(apr_status_t) ap_rgetline_core(char **s, apr_size_t n,\n                                          apr_size_t *read, request_rec *r,\n                                          int flags, apr_bucket_brigade *bb)\n{\n    apr_status_t rv;\n    apr_bucket *e;\n    apr_size_t bytes_handled = 0, current_alloc = 0;\n    char *pos, *last_char = *s;\n    int do_alloc = (*s == NULL), saw_eos = 0;\n    int fold = flags & AP_GETLINE_FOLD;\n    int crlf = flags & AP_GETLINE_CRLF;\n\n    /*\n     * Initialize last_char as otherwise a random value will be compared\n     * against APR_ASCII_LF at the end of the loop if bb only contains\n     * zero-length buckets.\n     */\n    if (last_char)\n        *last_char = '\\0';\n\n    for (;;) {\n        apr_brigade_cleanup(bb);\n        rv = ap_get_brigade(r->proto_input_filters, bb, AP_MODE_GETLINE,\n                            APR_BLOCK_READ, 0);\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n\n        /* Something horribly wrong happened.  Someone didn't block! \n         * (this also happens at the end of each keepalive connection)\n         */\n        if (APR_BRIGADE_EMPTY(bb)) {\n            return APR_EGENERAL;\n        }\n\n        for (e = APR_BRIGADE_FIRST(bb);\n             e != APR_BRIGADE_SENTINEL(bb);\n             e = APR_BUCKET_NEXT(e))\n        {\n            const char *str;\n            apr_size_t len;\n\n            /* If we see an EOS, don't bother doing anything more. */\n            if (APR_BUCKET_IS_EOS(e)) {\n                saw_eos = 1;\n                break;\n            }\n\n            rv = apr_bucket_read(e, &str, &len, APR_BLOCK_READ);\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            if (len == 0) {\n                /* no use attempting a zero-byte alloc (hurts when\n                 * using --with-efence --enable-pool-debug) or\n                 * doing any of the other logic either\n                 */\n                continue;\n            }\n\n            /* Would this overrun our buffer?  If so, we'll die. */\n            if (n < bytes_handled + len) {\n                *read = bytes_handled;\n                if (*s) {\n                    /* ensure this string is NUL terminated */\n                    if (bytes_handled > 0) {\n                        (*s)[bytes_handled-1] = '\\0';\n                    }\n                    else {\n                        (*s)[0] = '\\0';\n                    }\n                }\n                return APR_ENOSPC;\n            }\n\n            /* Do we have to handle the allocation ourselves? */\n            if (do_alloc) {\n                /* We'll assume the common case where one bucket is enough. */\n                if (!*s) {\n                    current_alloc = len;\n                    *s = apr_palloc(r->pool, current_alloc);\n                }\n                else if (bytes_handled + len > current_alloc) {\n                    /* Increase the buffer size */\n                    apr_size_t new_size = current_alloc * 2;\n                    char *new_buffer;\n\n                    if (bytes_handled + len > new_size) {\n                        new_size = (bytes_handled + len) * 2;\n                    }\n\n                    new_buffer = apr_palloc(r->pool, new_size);\n\n                    /* Copy what we already had. */\n                    memcpy(new_buffer, *s, bytes_handled);\n                    current_alloc = new_size;\n                    *s = new_buffer;\n                }\n            }\n\n            /* Just copy the rest of the data to the end of the old buffer. */\n            pos = *s + bytes_handled;\n            memcpy(pos, str, len);\n            last_char = pos + len - 1;\n\n            /* We've now processed that new data - update accordingly. */\n            bytes_handled += len;\n        }\n\n        /* If we got a full line of input, stop reading */\n        if (last_char && (*last_char == APR_ASCII_LF)) {\n            break;\n        }\n    }\n\n    if (last_char <= *s || last_char[-1] != APR_ASCII_CR) {\n        *last_char = '\\0';\n        bytes_handled = last_char - *s;\n        *read = bytes_handled;\n        return APR_EINVAL;\n    }\n\n    /* Now NUL-terminate the string at the end of the line;\n     * if the last-but-one character is a CR, terminate there */\n    if (last_char > *s && last_char[-1] == APR_ASCII_CR) {\n        last_char--;\n    }\n    *last_char = '\\0';\n    bytes_handled = last_char - *s;\n\n    /* If we're folding, we have more work to do.\n     *\n     * Note that if an EOS was seen, we know we can't have another line.\n     */\n    if (fold && bytes_handled && !saw_eos) {\n        for (;;) {\n            const char *str;\n            apr_size_t len;\n            char c;\n\n            /* Clear the temp brigade for this filter read. */\n            apr_brigade_cleanup(bb);\n\n            /* We only care about the first byte. */\n            rv = ap_get_brigade(r->proto_input_filters, bb, AP_MODE_SPECULATIVE,\n                                APR_BLOCK_READ, 1);\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            if (APR_BRIGADE_EMPTY(bb)) {\n                break;\n            }\n\n            e = APR_BRIGADE_FIRST(bb);\n\n            /* If we see an EOS, don't bother doing anything more. */\n            if (APR_BUCKET_IS_EOS(e)) {\n                break;\n            }\n\n            rv = apr_bucket_read(e, &str, &len, APR_BLOCK_READ);\n            if (rv != APR_SUCCESS) {\n                apr_brigade_cleanup(bb);\n                return rv;\n            }\n\n            /* Found one, so call ourselves again to get the next line.\n             *\n             * FIXME: If the folding line is completely blank, should we\n             * stop folding?  Does that require also looking at the next\n             * char?\n             */\n            /* When we call destroy, the buckets are deleted, so save that\n             * one character we need.  This simplifies our execution paths\n             * at the cost of one character read.\n             */\n            c = *str;\n            if (c == APR_ASCII_BLANK || c == APR_ASCII_TAB) {\n                /* Do we have enough space? We may be full now. */\n                if (bytes_handled >= n) {\n                    *read = n;\n                    /* ensure this string is terminated */\n                    (*s)[n-1] = '\\0';\n                    return APR_ENOSPC;\n                }\n                else {\n                    apr_size_t next_size, next_len;\n                    char *tmp;\n\n                    /* If we're doing the allocations for them, we have to\n                     * give ourselves a NULL and copy it on return.\n                     */\n                    if (do_alloc) {\n                        tmp = NULL;\n                    }\n                    else {\n                        /* We're null terminated. */\n                        tmp = last_char;\n                    }\n\n                    next_size = n - bytes_handled;\n\n                    rv = ap_rgetline_core(&tmp, next_size,\n                                          &next_len, r, 0, bb);\n                    if (rv != APR_SUCCESS) {\n                        return rv;\n                    }\n\n                    if (do_alloc && next_len > 0) {\n                        char *new_buffer;\n                        apr_size_t new_size = bytes_handled + next_len + 1;\n\n                        /* we need to alloc an extra byte for a null */\n                        new_buffer = apr_palloc(r->pool, new_size);\n\n                        /* Copy what we already had. */\n                        memcpy(new_buffer, *s, bytes_handled);\n\n                        /* copy the new line, including the trailing null */\n                        memcpy(new_buffer + bytes_handled, tmp, next_len + 1);\n                        *s = new_buffer;\n                    }\n\n                    last_char += next_len;\n                    bytes_handled += next_len;\n                }\n            }\n            else { /* next character is not tab or space */\n                break;\n            }\n        }\n    }\n    *read = bytes_handled;\n\n    /* PR#43039: We shouldn't accept NULL bytes within the line */\n    if (strlen(*s) < bytes_handled) {\n        return APR_EINVAL;\n    }\n\n    return APR_SUCCESS;\n}", "target": 0}
{"idx": 4838, "func": "static int mov_read_mfra(MOVContext *c, AVIOContext *f)\n{\n    int64_t stream_size = avio_size(f);\n    int64_t original_pos = avio_tell(f);\n    int64_t seek_ret;\n    int32_t mfra_size;\n    int ret = -1;\n    if ((seek_ret = avio_seek(f, stream_size - 4, SEEK_SET)) < 0) {\n        ret = seek_ret;\n        goto fail;\n    }\n    mfra_size = avio_rb32(f);\n    if (mfra_size < 0 || mfra_size > stream_size) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (unreasonable size)\\n\");\n        goto fail;\n    }\n    if ((seek_ret = avio_seek(f, -mfra_size, SEEK_CUR)) < 0) {\n        ret = seek_ret;\n        goto fail;\n    }\n    if (avio_rb32(f) != mfra_size) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (size mismatch)\\n\");\n        goto fail;\n    }\n    if (avio_rb32(f) != MKBETAG('m', 'f', 'r', 'a')) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (tag mismatch)\\n\");\n        goto fail;\n    }\n    av_log(c->fc, AV_LOG_VERBOSE, \"stream has mfra\\n\");\n    do {\n        ret = read_tfra(c, f);\n        if (ret < 0)\n            goto fail;\n    } while (!ret);\n    ret = 0;\nfail:\n    seek_ret = avio_seek(f, original_pos, SEEK_SET);\n    if (seek_ret < 0) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"failed to seek back after looking for mfra\\n\");\n        ret = seek_ret;\n    }\n    return ret;\n}", "target": 0}
{"idx": 4839, "func": "static int extract_header(AVCodecContext *const avctx,\n                          const AVPacket *const avpkt) {\n    const uint8_t *buf;\n    unsigned buf_size;\n    IffContext *s = avctx->priv_data;\n    int palette_size;\n\n    if (avctx->extradata_size < 2) {\n        av_log(avctx, AV_LOG_ERROR, \"not enough extradata\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    palette_size = avctx->extradata_size - AV_RB16(avctx->extradata);\n\n    if (avpkt) {\n        int image_size;\n        if (avpkt->size < 2)\n            return AVERROR_INVALIDDATA;\n        image_size = avpkt->size - AV_RB16(avpkt->data);\n        buf = avpkt->data;\n        buf_size = bytestream_get_be16(&buf);\n        if (buf_size <= 1 || image_size <= 1) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Invalid image size received: %u -> image data offset: %d\\n\",\n                   buf_size, image_size);\n            return AVERROR_INVALIDDATA;\n        }\n    } else {\n        buf = avctx->extradata;\n        buf_size = bytestream_get_be16(&buf);\n        if (buf_size <= 1 || palette_size < 0) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Invalid palette size received: %u -> palette data offset: %d\\n\",\n                   buf_size, palette_size);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (buf_size > 8) {\n        s->compression  = bytestream_get_byte(&buf);\n        s->bpp          = bytestream_get_byte(&buf);\n        s->ham          = bytestream_get_byte(&buf);\n        s->flags        = bytestream_get_byte(&buf);\n        s->transparency = bytestream_get_be16(&buf);\n        s->masking      = bytestream_get_byte(&buf);\n        if (s->masking == MASK_HAS_MASK) {\n            if (s->bpp >= 8) {\n                avctx->pix_fmt = PIX_FMT_RGB32;\n                av_freep(&s->mask_buf);\n                av_freep(&s->mask_palbuf);\n                s->mask_buf = av_malloc((s->planesize * 32) + FF_INPUT_BUFFER_PADDING_SIZE);\n                if (!s->mask_buf)\n                    return AVERROR(ENOMEM);\n                if (s->bpp > 16) {\n                    av_log(avctx, AV_LOG_ERROR, \"bpp %d too large for palette\\n\", s->bpp);\n                    av_freep(&s->mask_buf);\n                    return AVERROR(ENOMEM);\n                }\n                s->mask_palbuf = av_malloc((2 << s->bpp) * sizeof(uint32_t) + FF_INPUT_BUFFER_PADDING_SIZE);\n                if (!s->mask_palbuf) {\n                    av_freep(&s->mask_buf);\n                    return AVERROR(ENOMEM);\n                }\n            }\n            s->bpp++;\n        } else if (s->masking != MASK_NONE && s->masking != MASK_HAS_TRANSPARENT_COLOR) {\n            av_log(avctx, AV_LOG_ERROR, \"Masking not supported\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if (!s->bpp || s->bpp > 32) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid number of bitplanes: %u\\n\", s->bpp);\n            return AVERROR_INVALIDDATA;\n        } else if (s->ham >= 8) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid number of hold bits for HAM: %u\\n\", s->ham);\n            return AVERROR_INVALIDDATA;\n        }\n\n        av_freep(&s->ham_buf);\n        av_freep(&s->ham_palbuf);\n\n        if (s->ham) {\n            int i, count = FFMIN(palette_size / 3, 1 << s->ham);\n            int ham_count;\n            const uint8_t *const palette = avctx->extradata + AV_RB16(avctx->extradata);\n\n            s->ham_buf = av_malloc((s->planesize * 8) + FF_INPUT_BUFFER_PADDING_SIZE);\n            if (!s->ham_buf)\n                return AVERROR(ENOMEM);\n\n            ham_count = 8 * (1 << s->ham);\n            s->ham_palbuf = av_malloc((ham_count << !!(s->masking == MASK_HAS_MASK)) * sizeof (uint32_t) + FF_INPUT_BUFFER_PADDING_SIZE);\n            if (!s->ham_palbuf) {\n                av_freep(&s->ham_buf);\n                return AVERROR(ENOMEM);\n            }\n\n            if (count) { // HAM with color palette attached\n                // prefill with black and palette and set HAM take direct value mask to zero\n                memset(s->ham_palbuf, 0, (1 << s->ham) * 2 * sizeof (uint32_t));\n                for (i=0; i < count; i++) {\n                    s->ham_palbuf[i*2+1] = 0xFF000000 | AV_RL24(palette + i*3);\n                }\n                count = 1 << s->ham;\n            } else { // HAM with grayscale color palette\n                count = 1 << s->ham;\n                for (i=0; i < count; i++) {\n                    s->ham_palbuf[i*2]   = 0xFF000000; // take direct color value from palette\n                    s->ham_palbuf[i*2+1] = 0xFF000000 | av_le2ne32(gray2rgb((i * 255) >> s->ham));\n                }\n            }\n            for (i=0; i < count; i++) {\n                uint32_t tmp = i << (8 - s->ham);\n                tmp |= tmp >> s->ham;\n                s->ham_palbuf[(i+count)*2]     = 0xFF00FFFF; // just modify blue color component\n                s->ham_palbuf[(i+count*2)*2]   = 0xFFFFFF00; // just modify red color component\n                s->ham_palbuf[(i+count*3)*2]   = 0xFFFF00FF; // just modify green color component\n                s->ham_palbuf[(i+count)*2+1]   = 0xFF000000 | tmp << 16;\n                s->ham_palbuf[(i+count*2)*2+1] = 0xFF000000 | tmp;\n                s->ham_palbuf[(i+count*3)*2+1] = 0xFF000000 | tmp << 8;\n            }\n            if (s->masking == MASK_HAS_MASK) {\n                for (i = 0; i < ham_count; i++)\n                    s->ham_palbuf[(1 << s->bpp) + i] = s->ham_palbuf[i] | 0xFF000000;\n            }\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 4840, "func": "static int print_device_sources(AVInputFormat *fmt, AVDictionary *opts)\n{\n    int ret, i;\n    AVDeviceInfoList *device_list = NULL;\n\n    if (!fmt || !fmt->priv_class  || !AV_IS_INPUT_DEVICE(fmt->priv_class->category))\n        return AVERROR(EINVAL);\n\n    printf(\"Audo-detected sources for %s:\\n\", fmt->name);\n    if (!fmt->get_device_list) {\n        ret = AVERROR(ENOSYS);\n        printf(\"Cannot list sources. Not implemented.\\n\");\n        goto fail;\n    }\n\n    if ((ret = avdevice_list_input_sources(fmt, NULL, opts, &device_list)) < 0) {\n        printf(\"Cannot list sources.\\n\");\n        goto fail;\n    }\n\n    for (i = 0; i < device_list->nb_devices; i++) {\n        printf(\"%s %s [%s]\\n\", device_list->default_device == i ? \"*\" : \" \",\n               device_list->devices[i]->device_name, device_list->devices[i]->device_description);\n    }\n\n  fail:\n    avdevice_free_list_devices(&device_list);\n    return ret;\n}", "target": 0}
{"idx": 4841, "func": "BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b)\n{\n    bn_check_top(b);\n\n    if (a == b)\n        return a;\n    if (bn_wexpand(a, b->top) == NULL)\n        return NULL;\n\n    if (b->top > 0)\n        memcpy(a->d, b->d, sizeof(b->d[0]) * b->top);\n\n    if (BN_get_flags(b, BN_FLG_CONSTTIME) != 0)\n        BN_set_flags(a, BN_FLG_CONSTTIME);\n\n    a->top = b->top;\n    a->neg = b->neg;\n    bn_check_top(a);\n    return a;\n}", "target": 0}
{"idx": 4842, "func": "static int mjpega_dump_header(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const char *args,\n                              uint8_t **poutbuf, int *poutbuf_size,\n                              const uint8_t *buf, int buf_size, int keyframe)\n{\n    uint8_t *poutbufp;\n    unsigned dqt = 0, dht = 0, sof0 = 0;\n    int i;\n\n    if (avctx->codec_id != AV_CODEC_ID_MJPEG) {\n        av_log(avctx, AV_LOG_ERROR, \"mjpega bitstream filter only applies to mjpeg codec\\n\");\n        return 0;\n    }\n\n    *poutbuf_size = 0;\n    *poutbuf = av_malloc(buf_size + 44 + FF_INPUT_BUFFER_PADDING_SIZE);\n    poutbufp = *poutbuf;\n    bytestream_put_byte(&poutbufp, 0xff);\n    bytestream_put_byte(&poutbufp, SOI);\n    bytestream_put_byte(&poutbufp, 0xff);\n    bytestream_put_byte(&poutbufp, APP1);\n    bytestream_put_be16(&poutbufp, 42); /* size */\n    bytestream_put_be32(&poutbufp, 0);\n    bytestream_put_buffer(&poutbufp, \"mjpg\", 4);\n    bytestream_put_be32(&poutbufp, buf_size + 44); /* field size */\n    bytestream_put_be32(&poutbufp, buf_size + 44); /* pad field size */\n    bytestream_put_be32(&poutbufp, 0);             /* next ptr */\n\n    for (i = 0; i < buf_size - 1; i++) {\n        if (buf[i] == 0xff) {\n            switch (buf[i + 1]) {\n            case DQT:  dqt  = i + 46; break;\n            case DHT:  dht  = i + 46; break;\n            case SOF0: sof0 = i + 46; break;\n            case SOS:\n                bytestream_put_be32(&poutbufp, dqt); /* quant off */\n                bytestream_put_be32(&poutbufp, dht); /* huff off */\n                bytestream_put_be32(&poutbufp, sof0); /* image off */\n                bytestream_put_be32(&poutbufp, i + 46); /* scan off */\n                bytestream_put_be32(&poutbufp, i + 46 + AV_RB16(buf + i + 2)); /* data off */\n                bytestream_put_buffer(&poutbufp, buf + 2, buf_size - 2); /* skip already written SOI */\n                *poutbuf_size = poutbufp - *poutbuf;\n                return 1;\n            case APP1:\n                if (i + 8 < buf_size && AV_RL32(buf + i + 8) == AV_RL32(\"mjpg\")) {\n                    av_log(avctx, AV_LOG_ERROR, \"bitstream already formatted\\n\");\n                    memcpy(*poutbuf, buf, buf_size);\n                    *poutbuf_size = buf_size;\n                    return 1;\n                }\n            }\n        }\n    }\n    av_freep(poutbuf);\n    av_log(avctx, AV_LOG_ERROR, \"could not find SOS marker in bitstream\\n\");\n    return 0;\n}", "target": 0}
{"idx": 4843, "func": "static void compute_chapters_end(AVFormatContext *s)\n{\n    unsigned int i, j;\n    int64_t max_time = s->duration +\n                       ((s->start_time == AV_NOPTS_VALUE) ? 0 : s->start_time);\n\n    for (i = 0; i < s->nb_chapters; i++)\n        if (s->chapters[i]->end == AV_NOPTS_VALUE) {\n            AVChapter *ch = s->chapters[i];\n            int64_t end = max_time ? av_rescale_q(max_time, AV_TIME_BASE_Q,\n                                                  ch->time_base)\n                                   : INT64_MAX;\n\n            for (j = 0; j < s->nb_chapters; j++) {\n                AVChapter *ch1     = s->chapters[j];\n                int64_t next_start = av_rescale_q(ch1->start, ch1->time_base,\n                                                  ch->time_base);\n                if (j != i && next_start > ch->start && next_start < end)\n                    end = next_start;\n            }\n            ch->end = (end == INT64_MAX) ? ch->start : end;\n        }\n}", "target": 1}
{"idx": 4844, "func": "static int blend_frames(AVFilterContext *ctx, int interpolate)\n{\n    FrameRateContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    double interpolate_scene_score = 0;\n\n    if ((s->flags & FRAMERATE_FLAG_SCD)) {\n        if (s->score >= 0.0)\n            interpolate_scene_score = s->score;\n        else\n            interpolate_scene_score = s->score = get_scene_score(ctx, s->f0, s->f1);\n        ff_dlog(ctx, \"blend_frames() interpolate scene score:%f\\n\", interpolate_scene_score);\n    }\n    // decide if the shot-change detection allows us to blend two frames\n    if (interpolate_scene_score < s->scene_score) {\n        ThreadData td;\n        td.copy_src1 = s->f0;\n        td.copy_src2 = s->f1;\n        td.src2_factor = interpolate;\n        td.src1_factor = s->blend_factor_max - td.src2_factor;\n\n        // get work-space for output frame\n        s->work = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!s->work)\n            return AVERROR(ENOMEM);\n\n        av_frame_copy_props(s->work, s->f0);\n\n        ff_dlog(ctx, \"blend_frames() INTERPOLATE to create work frame\\n\");\n        ctx->internal->execute(ctx, filter_slice, &td, NULL, FFMIN(outlink->h, ff_filter_get_nb_threads(ctx)));\n        return 1;\n    }\n    return 0;\n}", "target": 0}
{"idx": 4845, "func": "static int encode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])\n{\n    int x, y, p, i;\n    const int ring_size = s->avctx->context_model ? 3 : 2;\n    int16_t *sample[4][3];\n    int lbd    = s->bits_per_raw_sample <= 8;\n    int bits   = s->bits_per_raw_sample > 0 ? s->bits_per_raw_sample : 8;\n    int offset = 1 << bits;\n\n    s->run_index = 0;\n\n    memset(s->sample_buffer, 0, ring_size * MAX_PLANES *\n                                (w + 6) * sizeof(*s->sample_buffer));\n\n    for (y = 0; y < h; y++) {\n        for (i = 0; i < ring_size; i++)\n            for (p = 0; p < MAX_PLANES; p++)\n                sample[p][i]= s->sample_buffer + p*ring_size*(w+6) + ((h+i-y)%ring_size)*(w+6) + 3;\n\n        for (x = 0; x < w; x++) {\n            int b, g, r, av_uninit(a);\n            if (lbd) {\n                unsigned v = *((uint32_t*)(src[0] + x*4 + stride[0]*y));\n                b =  v        & 0xFF;\n                g = (v >>  8) & 0xFF;\n                r = (v >> 16) & 0xFF;\n                a =  v >> 24;\n            } else {\n                b = *((uint16_t*)(src[0] + x*2 + stride[0]*y));\n                g = *((uint16_t*)(src[1] + x*2 + stride[1]*y));\n                r = *((uint16_t*)(src[2] + x*2 + stride[2]*y));\n            }\n\n            if (s->slice_coding_mode != 1) {\n                b -= g;\n                r -= g;\n                g += (b + r) >> 2;\n                b += offset;\n                r += offset;\n            }\n\n            sample[0][0][x] = g;\n            sample[1][0][x] = b;\n            sample[2][0][x] = r;\n            sample[3][0][x] = a;\n        }\n        for (p = 0; p < 3 + s->transparency; p++) {\n            int ret;\n            sample[p][0][-1] = sample[p][1][0  ];\n            sample[p][1][ w] = sample[p][1][w-1];\n            if (lbd && s->slice_coding_mode == 0)\n                ret = encode_line(s, w, sample[p], (p + 1) / 2, 9);\n            else\n                ret = encode_line(s, w, sample[p], (p + 1) / 2, bits + (s->slice_coding_mode != 1));\n            if (ret < 0)\n                return ret;\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": 4846, "func": "static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *buf)\n{\n    AVFilterContext *ctx = inlink->dst;\n    AlphaMergeContext *merge = ctx->priv;\n\n    int is_alpha = (inlink == ctx->inputs[1]);\n    struct FFBufQueue *queue =\n        (is_alpha ? &merge->queue_alpha : &merge->queue_main);\n    ff_bufqueue_add(ctx, queue, buf);\n\n    while (1) {\n        AVFilterBufferRef *main_buf, *alpha_buf;\n\n        if (!ff_bufqueue_peek(&merge->queue_main, 0) ||\n            !ff_bufqueue_peek(&merge->queue_alpha, 0)) break;\n\n        main_buf = ff_bufqueue_get(&merge->queue_main);\n        alpha_buf = ff_bufqueue_get(&merge->queue_alpha);\n\n        merge->frame_requested = 0;\n        draw_frame(ctx, main_buf, alpha_buf);\n        ff_filter_frame(ctx->outputs[0], main_buf);\n        avfilter_unref_buffer(alpha_buf);\n    }\n    return 0;\n}", "target": 0}
{"idx": 4847, "func": "int ff_dca_xll_filter_frame(DCAXllDecoder *s, AVFrame *frame)\n{\n    AVCodecContext *avctx = s->avctx;\n    DCAContext *dca = avctx->priv_data;\n    DCAExssAsset *asset = &dca->exss.assets[0];\n    DCAXllChSet *p = &s->chset[0], *c;\n    enum AVMatrixEncoding matrix_encoding = AV_MATRIX_ENCODING_NONE;\n    int i, j, k, ret, shift, nsamples, request_mask;\n    int ch_remap[DCA_SPEAKER_COUNT];\n\n    // Force lossy downmixed output during recovery\n    if (dca->packet & DCA_PACKET_RECOVERY) {\n        for (i = 0, c = s->chset; i < s->nchsets; i++, c++) {\n            if (i < s->nactivechsets)\n                force_lossy_output(s, c);\n\n            if (!c->primary_chset)\n                c->dmix_embedded = 0;\n        }\n\n        s->scalable_lsbs = 0;\n        s->fixed_lsb_width = 0;\n    }\n\n    // Filter frequency bands for active channel sets\n    s->output_mask = 0;\n    for (i = 0, c = s->chset; i < s->nactivechsets; i++, c++) {\n        chs_filter_band_data(s, c, 0);\n\n        if (c->residual_encode != (1 << c->nchannels) - 1\n            && (ret = combine_residual_frame(s, c)) < 0)\n            return ret;\n\n        if (s->scalable_lsbs)\n            chs_assemble_msbs_lsbs(s, c, 0);\n\n        if (c->nfreqbands > 1) {\n            chs_filter_band_data(s, c, 1);\n            chs_assemble_msbs_lsbs(s, c, 1);\n        }\n\n        s->output_mask |= c->ch_mask;\n    }\n\n    // Undo hierarchial downmix and/or apply scaling\n    for (i = 1, c = &s->chset[1]; i < s->nchsets; i++, c++) {\n        if (!is_hier_dmix_chset(c))\n            continue;\n\n        if (i >= s->nactivechsets) {\n            for (j = 0; j < c->nfreqbands; j++)\n                if (c->bands[j].dmix_embedded)\n                    scale_down_mix(s, c, j);\n            break;\n        }\n\n        for (j = 0; j < c->nfreqbands; j++)\n            if (c->bands[j].dmix_embedded)\n                undo_down_mix(s, c, j);\n    }\n\n    // Assemble frequency bands for active channel sets\n    if (s->nfreqbands > 1) {\n        for (i = 0; i < s->nactivechsets; i++)\n            if ((ret = chs_assemble_freq_bands(s, &s->chset[i])) < 0)\n                return ret;\n    }\n\n    // Normalize to regular 5.1 layout if downmixing\n    if (dca->request_channel_layout) {\n        if (s->output_mask & DCA_SPEAKER_MASK_Lss) {\n            s->output_samples[DCA_SPEAKER_Ls] = s->output_samples[DCA_SPEAKER_Lss];\n            s->output_mask = (s->output_mask & ~DCA_SPEAKER_MASK_Lss) | DCA_SPEAKER_MASK_Ls;\n        }\n        if (s->output_mask & DCA_SPEAKER_MASK_Rss) {\n            s->output_samples[DCA_SPEAKER_Rs] = s->output_samples[DCA_SPEAKER_Rss];\n            s->output_mask = (s->output_mask & ~DCA_SPEAKER_MASK_Rss) | DCA_SPEAKER_MASK_Rs;\n        }\n    }\n\n    // Handle downmixing to stereo request\n    if (dca->request_channel_layout == DCA_SPEAKER_LAYOUT_STEREO\n        && DCA_HAS_STEREO(s->output_mask) && p->dmix_embedded\n        && (p->dmix_type == DCA_DMIX_TYPE_LoRo ||\n            p->dmix_type == DCA_DMIX_TYPE_LtRt))\n        request_mask = DCA_SPEAKER_LAYOUT_STEREO;\n    else\n        request_mask = s->output_mask;\n    if (!ff_dca_set_channel_layout(avctx, ch_remap, request_mask))\n        return AVERROR(EINVAL);\n\n    avctx->sample_rate = p->freq << (s->nfreqbands - 1);\n\n    switch (p->storage_bit_res) {\n    case 16:\n        avctx->sample_fmt = AV_SAMPLE_FMT_S16P;\n        shift = 16 - p->pcm_bit_res;\n        break;\n    case 20:\n    case 24:\n        avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n        shift = 24 - p->pcm_bit_res;\n        break;\n    default:\n        return AVERROR(EINVAL);\n    }\n\n    avctx->bits_per_raw_sample = p->storage_bit_res;\n    avctx->profile = FF_PROFILE_DTS_HD_MA;\n    avctx->bit_rate = 0;\n\n    frame->nb_samples = nsamples = s->nframesamples << (s->nfreqbands - 1);\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n\n    // Downmix primary channel set to stereo\n    if (request_mask != s->output_mask) {\n        ff_dca_downmix_to_stereo_fixed(s->dcadsp, s->output_samples,\n                                       p->dmix_coeff, nsamples,\n                                       s->output_mask);\n    }\n\n    for (i = 0; i < avctx->channels; i++) {\n        int32_t *samples = s->output_samples[ch_remap[i]];\n        if (frame->format == AV_SAMPLE_FMT_S16P) {\n            int16_t *plane = (int16_t *)frame->extended_data[i];\n            for (k = 0; k < nsamples; k++)\n                plane[k] = av_clip_int16(samples[k] * (1 << shift));\n        } else {\n            int32_t *plane = (int32_t *)frame->extended_data[i];\n            for (k = 0; k < nsamples; k++)\n                plane[k] = clip23(samples[k] * (1 << shift)) * (1 << 8);\n        }\n    }\n\n    if (!asset->one_to_one_map_ch_to_spkr) {\n        if (asset->representation_type == DCA_REPR_TYPE_LtRt)\n            matrix_encoding = AV_MATRIX_ENCODING_DOLBY;\n        else if (asset->representation_type == DCA_REPR_TYPE_LhRh)\n            matrix_encoding = AV_MATRIX_ENCODING_DOLBYHEADPHONE;\n    } else if (request_mask != s->output_mask && p->dmix_type == DCA_DMIX_TYPE_LtRt) {\n        matrix_encoding = AV_MATRIX_ENCODING_DOLBY;\n    }\n    if ((ret = ff_side_data_update_matrix_encoding(frame, matrix_encoding)) < 0)\n        return ret;\n\n    return 0;\n}", "target": 1}
{"idx": 4848, "func": "static av_always_inline void write_back_motion(H264Context *h, int mb_type){\n    MpegEncContext * const s = &h->s;\n    const int b_stride = h->b_stride;\n    const int b_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride; //try mb2b(8)_xy\n    const int b8_xy= 4*h->mb_xy;\n\n    if(USES_LIST(mb_type, 0)){\n        write_back_motion_list(h, s, b_stride, b_xy, b8_xy, mb_type, 0);\n    }else{\n        fill_rectangle(&s->current_picture.ref_index[0][b8_xy], 2, 2, 2, (uint8_t)LIST_NOT_USED, 1);\n    }\n    if(USES_LIST(mb_type, 1)){\n        write_back_motion_list(h, s, b_stride, b_xy, b8_xy, mb_type, 1);\n    }\n\n    if(h->slice_type_nos == AV_PICTURE_TYPE_B && CABAC){\n        if(IS_8X8(mb_type)){\n            uint8_t *direct_table = &h->direct_table[4*h->mb_xy];\n            direct_table[1] = h->sub_mb_type[1]>>1;\n            direct_table[2] = h->sub_mb_type[2]>>1;\n            direct_table[3] = h->sub_mb_type[3]>>1;\n        }\n    }\n}", "target": 0}
{"idx": 4849, "func": "static BN_ULONG *bn_expand_internal(const BIGNUM *b, int words)\n\t{\n\tBN_ULONG *A,*a = NULL;\n\tconst BN_ULONG *B;\n\tint i;\n\n\tbn_check_top(b);\t\n\tif (BN_get_flags(b,BN_FLG_STATIC_DATA))\n\t\t{\n\t\tBNerr(BN_F_BN_EXPAND_INTERNAL,BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);\n\t\treturn(NULL);\n\t\t}\n\ta=A=(BN_ULONG *)OPENSSL_malloc(sizeof(BN_ULONG)*(words+1));\n\tif (A == NULL)\n\t\t{\n\t\tBNerr(BN_F_BN_EXPAND_INTERNAL,ERR_R_MALLOC_FAILURE);\n\t\treturn(NULL);\n\t\t}\n#if 1\n\tB=b->d;\n\t/* Check if the previous number needs to be copied */\n\tif (B != NULL)\n\t\t{\n\t\tfor (i=b->top>>2; i>0; i--,A+=4,B+=4)\n\t\t\t{\n\t\t\t/*\n\t\t\t * The fact that the loop is unrolled\n\t\t\t * 4-wise is a tribute to Intel. It's\n\t\t\t * the one that doesn't have enough\n\t\t\t * registers to accomodate more data.\n\t\t\t * I'd unroll it 8-wise otherwise:-)\n\t\t\t *\n\t\t\t *\t\t<appro@fy.chalmers.se>\n\t\t\t */\n\t\t\tBN_ULONG a0,a1,a2,a3;\n\t\t\ta0=B[0]; a1=B[1]; a2=B[2]; a3=B[3];\n\t\t\tA[0]=a0; A[1]=a1; A[2]=a2; A[3]=a3;\n\t\t\t}\n\t\tswitch (b->top&3)\n\t\t\t{\n\t\tcase 3:\tA[2]=B[2];\n\t\tcase 2:\tA[1]=B[1];\n\t\tcase 1:\tA[0]=B[0];\n\t\tcase 0: /* workaround for ultrix cc: without 'case 0', the optimizer does\n\t\t         * the switch table by doing a=top&3; a--; goto jump_table[a];\n\t\t         * which fails for top== 0 */\n\t\t\t;\n\t\t\t}\n\t\t}\n\n\t/* Now need to zero any data between b->top and b->max */\n\t/* XXX Why? */\n\n\tA= &(a[b->top]);\n\tfor (i=(words - b->top)>>3; i>0; i--,A+=8)\n\t\t{\n\t\tA[0]=0; A[1]=0; A[2]=0; A[3]=0;\n\t\tA[4]=0; A[5]=0; A[6]=0; A[7]=0;\n\t\t}\n\tfor (i=(words - b->top)&7; i>0; i--,A++)\n\t\tA[0]=0;\n#else\n\tmemset(A,0,sizeof(BN_ULONG)*(words+1));\n\tmemcpy(A,b->d,sizeof(b->d[0])*b->top);\n#endif\n\t\t\n\treturn(a);\n\t}", "target": 1}
{"idx": 4850, "func": "int swr_resample(AVResampleContext *c, short *dst, const short *src, int *consumed, int src_size, int dst_size, int update_ctx){\n    int dst_index, i;\n    int index= c->index;\n    int frac= c->frac;\n    int dst_incr_frac= c->dst_incr % c->src_incr;\n    int dst_incr=      c->dst_incr / c->src_incr;\n    int compensation_distance= c->compensation_distance;\n\n    if(compensation_distance == 0 && c->filter_length == 1 && c->phase_shift==0){\n        int64_t index2= ((int64_t)index)<<32;\n        int64_t incr= (1LL<<32) * c->dst_incr / c->src_incr;\n        dst_size= FFMIN(dst_size, (src_size-1-index) * (int64_t)c->src_incr / c->dst_incr);\n\n        for(dst_index=0; dst_index < dst_size; dst_index++){\n            dst[dst_index] = src[index2>>32];\n            index2 += incr;\n        }\n        index += dst_index * dst_incr;\n        index += (frac + dst_index * (int64_t)dst_incr_frac) / c->src_incr;\n        frac   = (frac + dst_index * (int64_t)dst_incr_frac) % c->src_incr;\n    }else{\n        for(dst_index=0; dst_index < dst_size; dst_index++){\n            FELEM *filter= c->filter_bank + c->filter_length*(index & c->phase_mask);\n            int sample_index= index >> c->phase_shift;\n            FELEM2 val=0;\n\n            if(sample_index < 0){\n                for(i=0; i<c->filter_length; i++)\n                    val += src[FFABS(sample_index + i) % src_size] * filter[i];\n            }else if(sample_index + c->filter_length > src_size){\n                break;\n            }else if(c->linear){\n                FELEM2 v2=0;\n                for(i=0; i<c->filter_length; i++){\n                    val += src[sample_index + i] * (FELEM2)filter[i];\n                    v2  += src[sample_index + i] * (FELEM2)filter[i + c->filter_length];\n                }\n                val+=(v2-val)*(FELEML)frac / c->src_incr;\n            }else{\n                for(i=0; i<c->filter_length; i++){\n                    val += src[sample_index + i] * (FELEM2)filter[i];\n                }\n            }\n\n#ifdef CONFIG_RESAMPLE_AUDIOPHILE_KIDDY_MODE\n            dst[dst_index] = av_clip_int16(lrintf(val));\n#else\n            val = (val + (1<<(FILTER_SHIFT-1)))>>FILTER_SHIFT;\n            dst[dst_index] = (unsigned)(val + 32768) > 65535 ? (val>>31) ^ 32767 : val;\n#endif\n\n            frac += dst_incr_frac;\n            index += dst_incr;\n            if(frac >= c->src_incr){\n                frac -= c->src_incr;\n                index++;\n            }\n\n            if(dst_index + 1 == compensation_distance){\n                compensation_distance= 0;\n                dst_incr_frac= c->ideal_dst_incr % c->src_incr;\n                dst_incr=      c->ideal_dst_incr / c->src_incr;\n            }\n        }\n    }\n    *consumed= FFMAX(index, 0) >> c->phase_shift;\n    if(index>=0) index &= c->phase_mask;\n\n    if(compensation_distance){\n        compensation_distance -= dst_index;\n        assert(compensation_distance > 0);\n    }\n    if(update_ctx){\n        c->frac= frac;\n        c->index= index;\n        c->dst_incr= dst_incr_frac + c->src_incr*dst_incr;\n        c->compensation_distance= compensation_distance;\n    }\n#if 0\n    if(update_ctx && !c->compensation_distance){\n#undef rand\n        av_resample_compensate(c, rand() % (8000*2) - 8000, 8000*2);\nav_log(NULL, AV_LOG_DEBUG, \"%d %d %d\\n\", c->dst_incr, c->ideal_dst_incr, c->compensation_distance);\n    }\n#endif\n\n    return dst_index;\n}", "target": 0}
{"idx": 4851, "func": "static size_t have_handshake_fragment(SSL *s, int type, unsigned char *buf,\n                                      size_t len)\n{\n\n    if ((type == SSL3_RT_HANDSHAKE)\n        && (s->rlayer.d->handshake_fragment_len > 0))\n        /* (partially) satisfy request from storage */\n    {\n        unsigned char *src = s->rlayer.d->handshake_fragment;\n        unsigned char *dst = buf;\n        size_t k, n;\n\n        /* peek == 0 */\n        n = 0;\n        while ((len > 0) && (s->rlayer.d->handshake_fragment_len > 0)) {\n            *dst++ = *src++;\n            len--;\n            s->rlayer.d->handshake_fragment_len--;\n            n++;\n        }\n        /* move any remaining fragment bytes: */\n        for (k = 0; k < s->rlayer.d->handshake_fragment_len; k++)\n            s->rlayer.d->handshake_fragment[k] = *src++;\n        return n;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 4852, "func": "static int open_input_stream(HTTPContext *c, const char *info)\n{\n    char buf[128];\n    char input_filename[1024];\n    AVFormatContext *s;\n    int buf_size, i, ret;\n    int64_t stream_pos;\n\n    /* find file name */\n    if (c->stream->feed) {\n        strcpy(input_filename, c->stream->feed->feed_filename);\n        buf_size = FFM_PACKET_SIZE;\n        /* compute position (absolute time) */\n        if (find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            stream_pos = parse_date(buf, 0);\n            if (stream_pos == INT64_MIN)\n                return -1;\n        } else if (find_info_tag(buf, sizeof(buf), \"buffer\", info)) {\n            int prebuffer = strtol(buf, 0, 10);\n            stream_pos = av_gettime() - prebuffer * (int64_t)1000000;\n        } else\n            stream_pos = av_gettime() - c->stream->prebuffer * (int64_t)1000;\n    } else {\n        strcpy(input_filename, c->stream->feed_filename);\n        buf_size = 0;\n        /* compute position (relative time) */\n        if (find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            stream_pos = parse_date(buf, 1);\n            if (stream_pos == INT64_MIN)\n                return -1;\n        } else\n            stream_pos = 0;\n    }\n    if (input_filename[0] == '\\0')\n        return -1;\n\n#if 0\n    { time_t when = stream_pos / 1000000;\n    http_log(\"Stream pos = %\"PRId64\", time=%s\", stream_pos, ctime(&when));\n    }\n#endif\n\n    /* open stream */\n    if ((ret = av_open_input_file(&s, input_filename, c->stream->ifmt,\n                                  buf_size, c->stream->ap_in)) < 0) {\n        http_log(\"could not open %s: %d\\n\", input_filename, ret);\n        return -1;\n    }\n    s->flags |= AVFMT_FLAG_GENPTS;\n    c->fmt_in = s;\n    av_find_stream_info(c->fmt_in);\n\n    /* open each parser */\n    for(i=0;i<s->nb_streams;i++)\n        open_parser(s, i);\n\n    /* choose stream as clock source (we favorize video stream if\n       present) for packet sending */\n    c->pts_stream_index = 0;\n    for(i=0;i<c->stream->nb_streams;i++) {\n        if (c->pts_stream_index == 0 &&\n            c->stream->streams[i]->codec->codec_type == CODEC_TYPE_VIDEO) {\n            c->pts_stream_index = i;\n        }\n    }\n\n#if 1\n    if (c->fmt_in->iformat->read_seek)\n        av_seek_frame(c->fmt_in, -1, stream_pos, 0);\n#endif\n    /* set the start time (needed for maxtime and RTP packet timing) */\n    c->start_time = cur_time;\n    c->first_pts = AV_NOPTS_VALUE;\n    return 0;\n}", "target": 1}
{"idx": 4853, "func": "void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int tn,\n\t     int n, BN_ULONG *t)\n\t{\n\tint i,j,n2=n*2;\n\tunsigned int c1,c2,neg,zero;\n\tBN_ULONG ln,lo,*p;\n\n# ifdef BN_COUNT\n\tprintf(\" bn_mul_part_recursive %d * %d\\n\",tn+n,tn+n);\n# endif\n\tif (n < 8)\n\t\t{\n\t\ti=tn+n;\n\t\tbn_mul_normal(r,a,i,b,i);\n\t\treturn;\n\t\t}\n\n\t/* r=(a[0]-a[1])*(b[1]-b[0]) */\n\tc1=bn_cmp_words(a,&(a[n]),n);\n\tc2=bn_cmp_words(&(b[n]),b,n);\n\tzero=neg=0;\n\tswitch (c1*3+c2)\n\t\t{\n\tcase -4:\n\t\tbn_sub_words(t,      &(a[n]),a,      n); /* - */\n\t\tbn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */\n\t\tbreak;\n\tcase -3:\n\t\tzero=1;\n\t\t/* break; */\n\tcase -2:\n\t\tbn_sub_words(t,      &(a[n]),a,      n); /* - */\n\t\tbn_sub_words(&(t[n]),&(b[n]),b,      n); /* + */\n\t\tneg=1;\n\t\tbreak;\n\tcase -1:\n\tcase 0:\n\tcase 1:\n\t\tzero=1;\n\t\t/* break; */\n\tcase 2:\n\t\tbn_sub_words(t,      a,      &(a[n]),n); /* + */\n\t\tbn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */\n\t\tneg=1;\n\t\tbreak;\n\tcase 3:\n\t\tzero=1;\n\t\t/* break; */\n\tcase 4:\n\t\tbn_sub_words(t,      a,      &(a[n]),n);\n\t\tbn_sub_words(&(t[n]),&(b[n]),b,      n);\n\t\tbreak;\n\t\t}\n\t\t/* The zero case isn't yet implemented here. The speedup\n\t\t   would probably be negligible. */\n# if 0\n\tif (n == 4)\n\t\t{\n\t\tbn_mul_comba4(&(t[n2]),t,&(t[n]));\n\t\tbn_mul_comba4(r,a,b);\n\t\tbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\n\t\tmemset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));\n\t\t}\n\telse\n# endif\n\tif (n == 8)\n\t\t{\n\t\tbn_mul_comba8(&(t[n2]),t,&(t[n]));\n\t\tbn_mul_comba8(r,a,b);\n\t\tbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\n\t\tmemset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));\n\t\t}\n\telse\n\t\t{\n\t\tp= &(t[n2*2]);\n\t\tbn_mul_recursive(&(t[n2]),t,&(t[n]),n,p);\n\t\tbn_mul_recursive(r,a,b,n,p);\n\t\ti=n/2;\n\t\t/* If there is only a bottom half to the number,\n\t\t * just do it */\n\t\tj=tn-i;\n\t\tif (j == 0)\n\t\t\t{\n\t\t\tbn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),i,p);\n\t\t\tmemset(&(r[n2+i*2]),0,sizeof(BN_ULONG)*(n2-i*2));\n\t\t\t}\n\t\telse if (j > 0) /* eg, n == 16, i == 8 and tn == 11 */\n\t\t\t\t{\n\t\t\t\tbn_mul_part_recursive(&(r[n2]),&(a[n]),&(b[n]),\n\t\t\t\t\tj,i,p);\n\t\t\t\tmemset(&(r[n2+tn*2]),0,\n\t\t\t\t\tsizeof(BN_ULONG)*(n2-tn*2));\n\t\t\t\t}\n\t\telse /* (j < 0) eg, n == 16, i == 8 and tn == 5 */\n\t\t\t{\n\t\t\tmemset(&(r[n2]),0,sizeof(BN_ULONG)*n2);\n\t\t\tif (tn < BN_MUL_RECURSIVE_SIZE_NORMAL)\n\t\t\t\t{\n\t\t\t\tbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\ti/=2;\n\t\t\t\t\tif (i < tn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tbn_mul_part_recursive(&(r[n2]),\n\t\t\t\t\t\t\t&(a[n]),&(b[n]),\n\t\t\t\t\t\t\ttn-i,i,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (i == tn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tbn_mul_recursive(&(r[n2]),\n\t\t\t\t\t\t\t&(a[n]),&(b[n]),\n\t\t\t\t\t\t\ti,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0]), c1 is the sign\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t */\n\n\tc1=(int)(bn_add_words(t,r,&(r[n2]),n2));\n\n\tif (neg) /* if t[32] is negative */\n\t\t{\n\t\tc1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));\n\t\t}\n\telse\n\t\t{\n\t\t/* Might have a carry */\n\t\tc1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0])+(a[0]*b[0])+(a[1]*b[1])\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t * c1 holds the carry bits\n\t */\n\tc1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));\n\tif (c1)\n\t\t{\n\t\tp= &(r[n+n2]);\n\t\tlo= *p;\n\t\tln=(lo+c1)&BN_MASK2;\n\t\t*p=ln;\n\n\t\t/* The overflow will stop before we over write\n\t\t * words we should not overwrite */\n\t\tif (ln < c1)\n\t\t\t{\n\t\t\tdo\t{\n\t\t\t\tp++;\n\t\t\t\tlo= *p;\n\t\t\t\tln=(lo+1)&BN_MASK2;\n\t\t\t\t*p=ln;\n\t\t\t\t} while (ln == 0);\n\t\t\t}\n\t\t}\n\t}", "target": 0}
{"idx": 4854, "func": "static void\nngx_resolver_cleanup_tree(ngx_resolver_t *r, ngx_rbtree_t *tree)\n{\n    ngx_resolver_ctx_t   *ctx, *next;\n    ngx_resolver_node_t  *rn;\n\n    while (tree->root != tree->sentinel) {\n\n        rn = ngx_resolver_node(ngx_rbtree_min(tree->root, tree->sentinel));\n\n        ngx_queue_remove(&rn->queue);\n\n        for (ctx = rn->waiting; ctx; ctx = next) {\n            next = ctx->next;\n\n            if (ctx->event) {\n                ngx_resolver_free(r, ctx->event);\n            }\n\n            ngx_resolver_free(r, ctx);\n        }\n\n        ngx_rbtree_delete(tree, &rn->node);\n\n        ngx_resolver_free_node(r, rn);\n    }\n}", "target": 0}
{"idx": 4855, "func": "static av_always_inline void\nyuv2mono_2_c_template(SwsContext *c, const uint16_t *buf0,\n                      const uint16_t *buf1, const uint16_t *ubuf0,\n                      const uint16_t *ubuf1, const uint16_t *vbuf0,\n                      const uint16_t *vbuf1, const uint16_t *abuf0,\n                      const uint16_t *abuf1, uint8_t *dest, int dstW,\n                      int yalpha, int uvalpha, int y,\n                      enum PixelFormat target)\n{\n    const uint8_t * const d128 = dither_8x8_220[y & 7];\n    uint8_t *g = c->table_gU[128] + c->table_gV[128];\n    int  yalpha1 = 4095 - yalpha;\n    int i;\n\n    for (i = 0; i < dstW - 7; i += 8) {\n        int acc =    g[((buf0[i    ] * yalpha1 + buf1[i    ] * yalpha) >> 19) + d128[0]];\n        acc += acc + g[((buf0[i + 1] * yalpha1 + buf1[i + 1] * yalpha) >> 19) + d128[1]];\n        acc += acc + g[((buf0[i + 2] * yalpha1 + buf1[i + 2] * yalpha) >> 19) + d128[2]];\n        acc += acc + g[((buf0[i + 3] * yalpha1 + buf1[i + 3] * yalpha) >> 19) + d128[3]];\n        acc += acc + g[((buf0[i + 4] * yalpha1 + buf1[i + 4] * yalpha) >> 19) + d128[4]];\n        acc += acc + g[((buf0[i + 5] * yalpha1 + buf1[i + 5] * yalpha) >> 19) + d128[5]];\n        acc += acc + g[((buf0[i + 6] * yalpha1 + buf1[i + 6] * yalpha) >> 19) + d128[6]];\n        acc += acc + g[((buf0[i + 7] * yalpha1 + buf1[i + 7] * yalpha) >> 19) + d128[7]];\n        output_pixel(*dest++, acc);\n    }\n}", "target": 1}
{"idx": 4856, "func": "static av_always_inline void\nyuv2mono_1_c_template(SwsContext *c, const uint16_t *buf0,\n                      const uint16_t *ubuf0, const uint16_t *ubuf1,\n                      const uint16_t *vbuf0, const uint16_t *vbuf1,\n                      const uint16_t *abuf0, uint8_t *dest, int dstW,\n                      int uvalpha, enum PixelFormat dstFormat,\n                      int flags, int y, enum PixelFormat target)\n{\n    const uint8_t * const d128 = dither_8x8_220[y & 7];\n    uint8_t *g = c->table_gU[128] + c->table_gV[128];\n    int i;\n\n    for (i = 0; i < dstW - 7; i += 8) {\n        int acc =    g[(buf0[i    ] >> 7) + d128[0]];\n        acc += acc + g[(buf0[i + 1] >> 7) + d128[1]];\n        acc += acc + g[(buf0[i + 2] >> 7) + d128[2]];\n        acc += acc + g[(buf0[i + 3] >> 7) + d128[3]];\n        acc += acc + g[(buf0[i + 4] >> 7) + d128[4]];\n        acc += acc + g[(buf0[i + 5] >> 7) + d128[5]];\n        acc += acc + g[(buf0[i + 6] >> 7) + d128[6]];\n        acc += acc + g[(buf0[i + 7] >> 7) + d128[7]];\n        output_pixel(*dest++, acc);\n    }\n}", "target": 1}
{"idx": 4857, "func": "static int decode_frame_apng(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PNGDecContext *const s = avctx->priv_data;\n    int ret;\n    AVFrame *p;\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    FFSWAP(ThreadFrame, s->picture, s->last_picture);\n    p = s->picture.f;\n\n    if (!(s->state & PNG_IHDR)) {\n        int side_data_size = 0;\n        uint8_t *side_data = NULL;\n        if (avpkt)\n            side_data = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA, &side_data_size);\n\n        if (side_data_size) {\n            av_freep(&s->extra_data);\n            s->extra_data = av_mallocz(side_data_size + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!s->extra_data)\n                return AVERROR(ENOMEM);\n            s->extra_data_size = side_data_size;\n            memcpy(s->extra_data, side_data, s->extra_data_size);\n        }\n\n        if (!s->extra_data_size)\n            return AVERROR_INVALIDDATA;\n\n        /* only init fields, there is no zlib use in extradata */\n        s->zstream.zalloc = ff_png_zalloc;\n        s->zstream.zfree  = ff_png_zfree;\n\n        bytestream2_init(&s->gb, s->extra_data, s->extra_data_size);\n        if ((ret = decode_frame_common(avctx, s, p, avpkt)) < 0)\n            goto end;\n    }\n\n    /* reset state for a new frame */\n    if ((ret = inflateInit(&s->zstream)) != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"inflateInit returned error %d\\n\", ret);\n        ret = AVERROR_EXTERNAL;\n        goto end;\n    }\n    s->y = 0;\n    s->state &= ~(PNG_IDAT | PNG_ALLIMAGE);\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n    if ((ret = decode_frame_common(avctx, s, p, avpkt)) < 0)\n        goto end;\n\n    if (!(s->state & PNG_ALLIMAGE))\n        av_log(avctx, AV_LOG_WARNING, \"Frame did not contain a complete image\\n\");\n    if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n    if ((ret = av_frame_ref(data, s->picture.f)) < 0)\n        goto end;\n\n    *got_frame = 1;\n    ret = bytestream2_tell(&s->gb);\n\nend:\n    inflateEnd(&s->zstream);\n    return ret;\n}", "target": 1}
{"idx": 4858, "func": "static void\ndopr_outch(\n    char *buffer,\n    size_t *currlen,\n    size_t maxlen,\n    int c)\n{\n    if (*currlen < maxlen)\n        buffer[(*currlen)++] = (char)c;\n    return;\n}", "target": 1}
{"idx": 4859, "func": "static int tiff_unpack_strip(TiffContext *s, uint8_t* dst, int stride, const uint8_t *src, int size, int lines){\n    int c, line, pixels, code;\n    const uint8_t *ssrc = src;\n    int width = ((s->width * s->bpp) + 7) >> 3;\n#if CONFIG_ZLIB\n    uint8_t *zbuf; unsigned long outlen;\n\n    if(s->compr == TIFF_DEFLATE || s->compr == TIFF_ADOBE_DEFLATE){\n        int ret;\n        outlen = width * lines;\n        zbuf = av_malloc(outlen);\n        ret = tiff_uncompress(zbuf, &outlen, src, size);\n        if(ret != Z_OK){\n            av_log(s->avctx, AV_LOG_ERROR, \"Uncompressing failed (%lu of %lu) with error %d\\n\", outlen, (unsigned long)width * lines, ret);\n            av_free(zbuf);\n            return -1;\n        }\n        src = zbuf;\n        for(line = 0; line < lines; line++){\n            memcpy(dst, src, width);\n            dst += stride;\n            src += width;\n        }\n        av_free(zbuf);\n        return 0;\n    }\n#endif\n    if(s->compr == TIFF_LZW){\n        if(ff_lzw_decode_init(s->lzw, 8, src, size, FF_LZW_TIFF) < 0){\n            av_log(s->avctx, AV_LOG_ERROR, \"Error initializing LZW decoder\\n\");\n            return -1;\n        }\n    }\n    if(s->compr == TIFF_CCITT_RLE || s->compr == TIFF_G3 || s->compr == TIFF_G4){\n        int i, ret = 0;\n        uint8_t *src2 = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if(!src2 || (unsigned)size + FF_INPUT_BUFFER_PADDING_SIZE < (unsigned)size){\n            av_log(s->avctx, AV_LOG_ERROR, \"Error allocating temporary buffer\\n\");\n            return -1;\n        }\n        if(s->fax_opts & 2){\n            av_log(s->avctx, AV_LOG_ERROR, \"Uncompressed fax mode is not supported (yet)\\n\");\n            av_free(src2);\n            return -1;\n        }\n        if(!s->fill_order){\n            memcpy(src2, src, size);\n        }else{\n            for(i = 0; i < size; i++)\n                src2[i] = av_reverse[src[i]];\n        }\n        memset(src2+size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n        switch(s->compr){\n        case TIFF_CCITT_RLE:\n        case TIFF_G3:\n        case TIFF_G4:\n            ret = ff_ccitt_unpack(s->avctx, src2, size, dst, lines, stride, s->compr, s->fax_opts);\n            break;\n        }\n        av_free(src2);\n        return ret;\n    }\n    for(line = 0; line < lines; line++){\n        if(src - ssrc > size){\n            av_log(s->avctx, AV_LOG_ERROR, \"Source data overread\\n\");\n            return -1;\n        }\n        switch(s->compr){\n        case TIFF_RAW:\n            if (ssrc + size - src < width)\n                return AVERROR_INVALIDDATA;\n            if (!s->fill_order) {\n                memcpy(dst, src, width);\n            } else {\n                int i;\n                for (i = 0; i < width; i++)\n                    dst[i] = av_reverse[src[i]];\n            }\n            src += width;\n            break;\n        case TIFF_PACKBITS:\n            for(pixels = 0; pixels < width;){\n                code = (int8_t)*src++;\n                if(code >= 0){\n                    code++;\n                    if(pixels + code > width){\n                        av_log(s->avctx, AV_LOG_ERROR, \"Copy went out of bounds\\n\");\n                        return -1;\n                    }\n                    memcpy(dst + pixels, src, code);\n                    src += code;\n                    pixels += code;\n                }else if(code != -128){ // -127..-1\n                    code = (-code) + 1;\n                    if(pixels + code > width){\n                        av_log(s->avctx, AV_LOG_ERROR, \"Run went out of bounds\\n\");\n                        return -1;\n                    }\n                    c = *src++;\n                    memset(dst + pixels, c, code);\n                    pixels += code;\n                }\n            }\n            break;\n        case TIFF_LZW:\n            pixels = ff_lzw_decode(s->lzw, dst, width);\n            if(pixels < width){\n                av_log(s->avctx, AV_LOG_ERROR, \"Decoded only %i bytes of %i\\n\", pixels, width);\n                return -1;\n            }\n            break;\n        }\n        dst += stride;\n    }\n    return 0;\n}", "target": 1}
{"idx": 4860, "func": "static void sh_clearbit(char *ptr, int list, unsigned char *table)\n{\n    int bit;\n\n    OPENSSL_assert(list >= 0 && list < sh.freelist_size);\n    OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0);\n    bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list));\n    OPENSSL_assert(bit > 0 && bit < sh.bittable_size);\n    OPENSSL_assert(TESTBIT(table, bit));\n    CLEARBIT(table, bit);\n}", "target": 1}
{"idx": 4861, "func": "static ngx_http_upstream_rr_peer_t *\nngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp)\n{\n    time_t                        now;\n    uintptr_t                     m;\n    ngx_int_t                     total;\n    ngx_uint_t                    i, n;\n    ngx_http_upstream_rr_peer_t  *peer, *best;\n\n    now = ngx_time();\n\n    best = NULL;\n    total = 0;\n\n    for (i = 0; i < rrp->peers->number; i++) {\n\n        n = i / (8 * sizeof(uintptr_t));\n        m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));\n\n        if (rrp->tried[n] & m) {\n            continue;\n        }\n\n        peer = &rrp->peers->peer[i];\n\n        if (peer->down) {\n            continue;\n        }\n\n        if (peer->max_fails\n            && peer->fails >= peer->max_fails\n            && now - peer->checked <= peer->fail_timeout)\n        {\n            continue;\n        }\n\n        peer->current_weight += peer->effective_weight;\n        total += peer->effective_weight;\n\n        if (peer->effective_weight < peer->weight) {\n            peer->effective_weight++;\n        }\n\n        if (best == NULL || peer->current_weight > best->current_weight) {\n            best = peer;\n        }\n    }\n\n    if (best == NULL) {\n        return NULL;\n    }\n\n    i = best - &rrp->peers->peer[0];\n\n    rrp->current = i;\n\n    n = i / (8 * sizeof(uintptr_t));\n    m = (uintptr_t) 1 << i % (8 * sizeof(uintptr_t));\n\n    rrp->tried[n] |= m;\n\n    best->current_weight -= total;\n    best->checked = now;\n\n    return best;\n}", "target": 0}
{"idx": 4862, "func": "int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b)\n\t{\n\tint i,j;\n\tX509_NAME_ENTRY *na,*nb;\n\n\tif (sk_X509_NAME_ENTRY_num(a->entries)\n\t    != sk_X509_NAME_ENTRY_num(b->entries))\n\t\treturn sk_X509_NAME_ENTRY_num(a->entries)\n\t\t  -sk_X509_NAME_ENTRY_num(b->entries);\n\tfor (i=sk_X509_NAME_ENTRY_num(a->entries)-1; i>=0; i--)\n\t\t{\n\t\tna=sk_X509_NAME_ENTRY_value(a->entries,i);\n\t\tnb=sk_X509_NAME_ENTRY_value(b->entries,i);\n\t\tj=na->value->type-nb->value->type;\n\t\tif (j) return(j);\n\t\tif (na->value->type == V_ASN1_PRINTABLESTRING)\n\t\t\tj=nocase_spacenorm_cmp(na->value, nb->value);\n\t\telse if (na->value->type == V_ASN1_IA5STRING\n\t\t\t&& OBJ_obj2nid(na->object) == NID_pkcs9_emailAddress)\n\t\t\tj=nocase_cmp(na->value, nb->value);\n\t\telse\n\t\t\t{\n\t\t\tj=na->value->length-nb->value->length;\n\t\t\tif (j) return(j);\n\t\t\tj=memcmp(na->value->data,nb->value->data,\n\t\t\t\tna->value->length);\n\t\t\t}\n\t\tif (j) return(j);\n\t\tj=na->set-nb->set;\n\t\tif (j) return(j);\n\t\t}\n\n\t/* We will check the object types after checking the values\n\t * since the values will more often be different than the object\n\t * types. */\n\tfor (i=sk_X509_NAME_ENTRY_num(a->entries)-1; i>=0; i--)\n\t\t{\n\t\tna=sk_X509_NAME_ENTRY_value(a->entries,i);\n\t\tnb=sk_X509_NAME_ENTRY_value(b->entries,i);\n\t\tj=OBJ_cmp(na->object,nb->object);\n\t\tif (j) return(j);\n\t\t}\n\treturn(0);\n\t}", "target": 1}
{"idx": 4863, "func": "int ff_mjpeg_find_marker(MJpegDecodeContext *s,\n                         const uint8_t **buf_ptr, const uint8_t *buf_end,\n                         const uint8_t **unescaped_buf_ptr,\n                         int *unescaped_buf_size)\n{\n    int start_code;\n    start_code = find_marker(buf_ptr, buf_end);\n\n    av_fast_padded_malloc(&s->buffer, &s->buffer_size, buf_end - *buf_ptr);\n    if (!s->buffer)\n        return AVERROR(ENOMEM);\n\n    /* unescape buffer of SOS, use special treatment for JPEG-LS */\n    if (start_code == SOS && !s->ls) {\n        const uint8_t *src = *buf_ptr;\n        uint8_t *dst = s->buffer;\n\n        while (src < buf_end) {\n            uint8_t x = *(src++);\n\n            *(dst++) = x;\n            if (s->avctx->codec_id != CODEC_ID_THP) {\n                if (x == 0xff) {\n                    while (src < buf_end && x == 0xff)\n                        x = *(src++);\n\n                    if (x >= 0xd0 && x <= 0xd7)\n                        *(dst++) = x;\n                    else if (x)\n                        break;\n                }\n            }\n        }\n        *unescaped_buf_ptr  = s->buffer;\n        *unescaped_buf_size = dst - s->buffer;\n\n        av_log(s->avctx, AV_LOG_DEBUG, \"escaping removed %td bytes\\n\",\n               (buf_end - *buf_ptr) - (dst - s->buffer));\n    } else if (start_code == SOS && s->ls) {\n        const uint8_t *src = *buf_ptr;\n        uint8_t *dst  = s->buffer;\n        int bit_count = 0;\n        int t = 0, b = 0;\n        PutBitContext pb;\n\n        s->cur_scan++;\n\n        /* find marker */\n        while (src + t < buf_end) {\n            uint8_t x = src[t++];\n            if (x == 0xff) {\n                while ((src + t < buf_end) && x == 0xff)\n                    x = src[t++];\n                if (x & 0x80) {\n                    t -= 2;\n                    break;\n                }\n            }\n        }\n        bit_count = t * 8;\n        init_put_bits(&pb, dst, t);\n\n        /* unescape bitstream */\n        while (b < t) {\n            uint8_t x = src[b++];\n            put_bits(&pb, 8, x);\n            if (x == 0xFF) {\n                x = src[b++];\n                put_bits(&pb, 7, x);\n                bit_count--;\n            }\n        }\n        flush_put_bits(&pb);\n\n        *unescaped_buf_ptr  = dst;\n        *unescaped_buf_size = (bit_count + 7) >> 3;\n    } else {\n        *unescaped_buf_ptr  = *buf_ptr;\n        *unescaped_buf_size = buf_end - *buf_ptr;\n    }\n\n    return start_code;\n}", "target": 0}
{"idx": 4864, "func": "void ssl_set_client_disabled(SSL *s)\n\t{\n\tCERT *c = s->cert;\n\tc->mask_a = 0;\n\tc->mask_k = 0;\n\t/* Don't allow TLS 1.2 only ciphers if we don't suppport them */\n\tif (!SSL_CLIENT_USE_TLS1_2_CIPHERS(s))\n\t\tc->mask_ssl = SSL_TLSV1_2;\n\telse\n\t\tc->mask_ssl = 0;\n\tssl_set_sig_mask(&c->mask_a, s, SSL_SECOP_SIGALG_MASK);\n\t/* Disable static DH if we don't include any appropriate\n\t * signature algorithms.\n\t */\n\tif (c->mask_a & SSL_aRSA)\n\t\tc->mask_k |= SSL_kDHr|SSL_kECDHr;\n\tif (c->mask_a & SSL_aDSS)\n\t\tc->mask_k |= SSL_kDHd;\n\tif (c->mask_a & SSL_aECDSA)\n\t\tc->mask_k |= SSL_kECDHe;\n#ifndef OPENSSL_NO_KRB5\n\tif (!kssl_tgt_is_available(s->kssl_ctx))\n\t\t{\n\t\tc->mask_a |= SSL_aKRB5;\n\t\tc->mask_k |= SSL_kKRB5;\n\t\t}\n#endif\n#ifndef OPENSSL_NO_PSK\n\t/* with PSK there must be client callback set */\n\tif (!s->psk_client_callback)\n\t\t{\n\t\tc->mask_a |= SSL_aPSK;\n\t\tc->mask_k |= SSL_kPSK;\n\t\t}\n#endif /* OPENSSL_NO_PSK */\n\tc->valid = 1;\n\t}", "target": 0}
{"idx": 4865, "func": "void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    /* let's disallow possible ambiguous cases */\n    if (size > (max_alloc_size-32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    //FIXME this isn't aligned correctly, though it probably isn't needed\n    if(!ptr) return av_malloc(size);\n    diff= ((char*)ptr)[-1];\n    ptr= realloc((char*)ptr - diff, size + diff);\n    if(ptr) ptr = (char*)ptr + diff;\n    return ptr;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size + !size, ALIGN);\n#else\n    return realloc(ptr, size + !size);\n#endif\n}", "target": 1}
{"idx": 4866, "func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n\t{\n\tX509_NAME_ENTRY *ne;\nint i;\n\tint n,lold,l,l1,l2,num,j,type;\n\tconst char *s;\n\tchar *p;\n\tunsigned char *q;\n\tBUF_MEM *b=NULL;\n\tstatic char hex[17]=\"0123456789ABCDEF\";\n\tint gs_doit[4];\n\tchar tmp_buf[80];\n\n\tif (buf == NULL)\n\t\t{\n\t\tif ((b=BUF_MEM_new()) == NULL) goto err;\n\t\tif (!BUF_MEM_grow(b,200)) goto err;\n\t\tb->data[0]='\\0';\n\t\tlen=200;\n\t\t}\n\tif (a == NULL)\n\t    {\n\t    if(b)\n\t\t{\n\t\tbuf=b->data;\n\t\tFree(b);\n\t\t}\n\t    strncpy(buf,\"NO X509_NAME\",len);\n\t    return buf;\n\t    }\n\n\tlen--; /* space for '\\0' */\n\tl=0;\n\tfor (i=0; i<sk_X509_NAME_ENTRY_num(a->entries); i++)\n\t\t{\n\t\tne=sk_X509_NAME_ENTRY_value(a->entries,i);\n\t\tn=OBJ_obj2nid(ne->object);\n\t\tif ((n == NID_undef) || ((s=OBJ_nid2sn(n)) == NULL))\n\t\t\t{\n\t\t\ti2t_ASN1_OBJECT(tmp_buf,sizeof(tmp_buf),ne->object);\n\t\t\ts=tmp_buf;\n\t\t\t}\n\t\tl1=strlen(s);\n\n\t\ttype=ne->value->type;\n\t\tnum=ne->value->length;\n\t\tq=ne->value->data;\n\n\t\tif ((type == V_ASN1_GENERALSTRING) && ((num%4) == 0))\n\t\t\t{\n\t\t\tgs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=0;\n\t\t\tfor (j=0; j<num; j++)\n\t\t\t\tif (q[j] != 0) gs_doit[j&3]=1;\n\n\t\t\tif (gs_doit[0]|gs_doit[1]|gs_doit[2])\n\t\t\t\tgs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=1;\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tgs_doit[0]=gs_doit[1]=gs_doit[2]=0;\n\t\t\t\tgs_doit[3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\tgs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=1;\n\n\t\tfor (l2=j=0; j<num; j++)\n\t\t\t{\n\t\t\tif (!gs_doit[j&3]) continue;\n\t\t\tl2++;\n\t\t\tif ((q[j] < ' ') || (q[j] > '~')) l2+=3;\n\t\t\t}\n\n\t\tlold=l;\n\t\tl+=1+l1+1+l2;\n\t\tif (b != NULL)\n\t\t\t{\n\t\t\tif (!BUF_MEM_grow(b,l+1)) goto err;\n\t\t\tp= &(b->data[lold]);\n\t\t\t}\n\t\telse if (l > len)\n\t\t\t{\n\t\t\tbreak;\n\t\t\t}\n\t\telse\n\t\t\tp= &(buf[lold]);\n\t\t*(p++)='/';\n\t\tmemcpy(p,s,(unsigned int)l1); p+=l1;\n\t\t*(p++)='=';\n\n\t\tq=ne->value->data;\n\n\t\tfor (j=0; j<num; j++)\n\t\t\t{\n\t\t\tif (!gs_doit[j&3]) continue;\n\t\t\tn=q[j];\n\t\t\tif ((n < ' ') || (n > '~'))\n\t\t\t\t{\n\t\t\t\t*(p++)='\\\\';\n\t\t\t\t*(p++)='x';\n\t\t\t\t*(p++)=hex[(n>>4)&0x0f];\n\t\t\t\t*(p++)=hex[n&0x0f];\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t*(p++)=n;\n\t\t\t}\n\t\t*p='\\0';\n\t\t}\n\tif (b != NULL)\n\t\t{\n\t\tp=b->data;\n\t\tFree(b);\n\t\t}\n\telse\n\t\tp=buf;\n\treturn(p);\nerr:\n\tX509err(X509_F_X509_NAME_ONELINE,ERR_R_MALLOC_FAILURE);\n\tif (b != NULL) BUF_MEM_free(b);\n\treturn(NULL);\n\t}", "target": 0}
{"idx": 4867, "func": "uintptr_t\nngx_escape_uri(u_char *dst, u_char *src, size_t size, ngx_uint_t type)\n{\n    ngx_uint_t      n;\n    uint32_t       *escape;\n    static u_char   hex[] = \"0123456789abcdef\";\n\n                    /* \" \", \"#\", \"%\", \"?\", %00-%1F, %7F-%FF */\n\n    static uint32_t   uri[] = {\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n        0x80000029, /* 1000 0000 0000 0000  0000 0000 0010 1001 */\n\n                    /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    };\n\n                    /* \" \", \"#\", \"%\", \"&\", \"+\", \"?\", %00-%1F, %7F-%FF */\n\n    static uint32_t   args[] = {\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n        0x88000869, /* 1000 1000 0000 0000  0000 1000 0110 1001 */\n\n                    /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    };\n\n                    /* not ALPHA, DIGIT, \"-\", \".\", \"_\", \"~\" */\n\n    static uint32_t   uri_component[] = {\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n        0xfc009fff, /* 1111 1100 0000 0000  1001 1111 1111 1111 */\n\n                    /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n        0x78000001, /* 0111 1000 0000 0000  0000 0000 0000 0001 */\n\n                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n        0xb8000001, /* 1011 1000 0000 0000  0000 0000 0000 0001 */\n\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    };\n\n                    /* \" \", \"#\", \"\"\", \"%\", \"'\", %00-%1F, %7F-%FF */\n\n    static uint32_t   html[] = {\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n        0x000000ad, /* 0000 0000 0000 0000  0000 0000 1010 1101 */\n\n                    /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    };\n\n                    /* \" \", \"\"\", \"%\", \"'\", %00-%1F, %7F-%FF */\n\n    static uint32_t   refresh[] = {\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n        0x00000085, /* 0000 0000 0000 0000  0000 0000 1000 0101 */\n\n                    /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n        0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    };\n\n                    /* \" \", \"%\", %00-%1F */\n\n    static uint32_t   memcached[] = {\n        0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n                    /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n        0x00000021, /* 0000 0000 0000 0000  0000 0000 0010 0001 */\n\n                    /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n                    /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n    };\n\n                    /* mail_auth is the same as memcached */\n\n    static uint32_t  *map[] =\n        { uri, args, uri_component, html, refresh, memcached, memcached };\n\n\n    escape = map[type];\n\n    if (dst == NULL) {\n\n        /* find the number of the characters to be escaped */\n\n        n = 0;\n\n        while (size) {\n            if (escape[*src >> 5] & (1 << (*src & 0x1f))) {\n                n++;\n            }\n            src++;\n            size--;\n        }\n\n        return (uintptr_t) n;\n    }\n\n    while (size) {\n        if (escape[*src >> 5] & (1 << (*src & 0x1f))) {\n            *dst++ = '%';\n            *dst++ = hex[*src >> 4];\n            *dst++ = hex[*src & 0xf];\n            src++;\n\n        } else {\n            *dst++ = *src++;\n        }\n        size--;\n    }\n\n    return (uintptr_t) dst;\n}", "target": 1}
{"idx": 4868, "func": "X509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void)\n\t{\n\tX509_VERIFY_PARAM *param;\n\tparam = OPENSSL_malloc(sizeof(X509_VERIFY_PARAM));\n\tmemset(param, 0, sizeof(X509_VERIFY_PARAM));\n\tx509_verify_param_zero(param);\n\treturn param;\n\t}", "target": 1}
{"idx": 4869, "func": "static void dav_do_prop_subreq(dav_propdb *propdb)\n{\n    /* need to escape the uri that's in the resource struct because during\n     * the property walker it's not encoded. */\n    const char *e_uri = ap_escape_uri(propdb->resource->pool,\n                                      propdb->resource->uri);\n\n    /* perform a \"GET\" on the resource's URI (note that the resource\n       may not correspond to the current request!). */\n    propdb->subreq = ap_sub_req_lookup_uri(e_uri, propdb->r, NULL);\n}", "target": 0}
{"idx": 4870, "func": "int dtls1_do_write(SSL *s, int type)\n{\n    int ret;\n    size_t written;\n    size_t curr_mtu;\n    int retry = 1;\n    size_t len, frag_off, mac_size, blocksize, used_len;\n\n    if (!dtls1_query_mtu(s))\n        return -1;\n\n    if (s->d1->mtu < dtls1_min_mtu(s))\n        /* should have something reasonable now */\n        return -1;\n\n    if (s->init_off == 0 && type == SSL3_RT_HANDSHAKE)\n        OPENSSL_assert(s->init_num ==\n                       s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH);\n\n    if (s->write_hash) {\n        if (s->enc_write_ctx\n            && (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx)) &\n                EVP_CIPH_FLAG_AEAD_CIPHER) != 0)\n            mac_size = 0;\n        else\n            mac_size = EVP_MD_CTX_size(s->write_hash);\n    } else\n        mac_size = 0;\n\n    if (s->enc_write_ctx &&\n        (EVP_CIPHER_CTX_mode(s->enc_write_ctx) == EVP_CIPH_CBC_MODE))\n        blocksize = 2 * EVP_CIPHER_CTX_block_size(s->enc_write_ctx);\n    else\n        blocksize = 0;\n\n    frag_off = 0;\n    s->rwstate = SSL_NOTHING;\n\n    /* s->init_num shouldn't ever be < 0...but just in case */\n    while (s->init_num > 0) {\n        if (type == SSL3_RT_HANDSHAKE && s->init_off != 0) {\n            /* We must be writing a fragment other than the first one */\n\n            if (frag_off > 0) {\n                /* This is the first attempt at writing out this fragment */\n\n                if (s->init_off <= DTLS1_HM_HEADER_LENGTH) {\n                    /*\n                     * Each fragment that was already sent must at least have\n                     * contained the message header plus one other byte.\n                     * Therefore |init_off| must have progressed by at least\n                     * |DTLS1_HM_HEADER_LENGTH + 1| bytes. If not something went\n                     * wrong.\n                     */\n                    return -1;\n                }\n\n                /*\n                 * Adjust |init_off| and |init_num| to allow room for a new\n                 * message header for this fragment.\n                 */\n                s->init_off -= DTLS1_HM_HEADER_LENGTH;\n                s->init_num += DTLS1_HM_HEADER_LENGTH;\n            } else {\n                /*\n                 * We must have been called again after a retry so use the\n                 * fragment offset from our last attempt. We do not need\n                 * to adjust |init_off| and |init_num| as above, because\n                 * that should already have been done before the retry.\n                 */\n                frag_off = s->d1->w_msg_hdr.frag_off;\n            }\n        }\n\n        used_len = BIO_wpending(s->wbio) + DTLS1_RT_HEADER_LENGTH\n            + mac_size + blocksize;\n        if (s->d1->mtu > used_len)\n            curr_mtu = s->d1->mtu - used_len;\n        else\n            curr_mtu = 0;\n\n        if (curr_mtu <= DTLS1_HM_HEADER_LENGTH) {\n            /*\n             * grr.. we could get an error if MTU picked was wrong\n             */\n            ret = BIO_flush(s->wbio);\n            if (ret <= 0) {\n                s->rwstate = SSL_WRITING;\n                return ret;\n            }\n            used_len = DTLS1_RT_HEADER_LENGTH + mac_size + blocksize;\n            if (s->d1->mtu > used_len + DTLS1_HM_HEADER_LENGTH) {\n                curr_mtu = s->d1->mtu - used_len;\n            } else {\n                /* Shouldn't happen */\n                return -1;\n            }\n        }\n\n        /*\n         * We just checked that s->init_num > 0 so this cast should be safe\n         */\n        if (((unsigned int)s->init_num) > curr_mtu)\n            len = curr_mtu;\n        else\n            len = s->init_num;\n\n        /*\n         * XDTLS: this function is too long.  split out the CCS part\n         */\n        if (type == SSL3_RT_HANDSHAKE) {\n            if (len < DTLS1_HM_HEADER_LENGTH) {\n                /*\n                 * len is so small that we really can't do anything sensible\n                 * so fail\n                 */\n                return -1;\n            }\n            dtls1_fix_message_header(s, frag_off, len - DTLS1_HM_HEADER_LENGTH);\n\n            dtls1_write_message_header(s,\n                                       (unsigned char *)&s->init_buf->\n                                       data[s->init_off]);\n        }\n\n        ret = dtls1_write_bytes(s, type, &s->init_buf->data[s->init_off], len,\n                                &written);\n        if (ret < 0) {\n            /*\n             * might need to update MTU here, but we don't know which\n             * previous packet caused the failure -- so can't really\n             * retransmit anything.  continue as if everything is fine and\n             * wait for an alert to handle the retransmit\n             */\n            if (retry && BIO_ctrl(SSL_get_wbio(s),\n                                  BIO_CTRL_DGRAM_MTU_EXCEEDED, 0, NULL) > 0) {\n                if (!(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU)) {\n                    if (!dtls1_query_mtu(s))\n                        return -1;\n                    /* Have one more go */\n                    retry = 0;\n                } else\n                    return -1;\n            } else {\n                return (-1);\n            }\n        } else {\n\n            /*\n             * bad if this assert fails, only part of the handshake message\n             * got sent.  but why would this happen?\n             */\n            OPENSSL_assert(len == written);\n\n            if (type == SSL3_RT_HANDSHAKE && !s->d1->retransmitting) {\n                /*\n                 * should not be done for 'Hello Request's, but in that case\n                 * we'll ignore the result anyway\n                 */\n                unsigned char *p =\n                    (unsigned char *)&s->init_buf->data[s->init_off];\n                const struct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;\n                size_t xlen;\n\n                if (frag_off == 0 && s->version != DTLS1_BAD_VER) {\n                    /*\n                     * reconstruct message header is if it is being sent in\n                     * single fragment\n                     */\n                    *p++ = msg_hdr->type;\n                    l2n3(msg_hdr->msg_len, p);\n                    s2n(msg_hdr->seq, p);\n                    l2n3(0, p);\n                    l2n3(msg_hdr->msg_len, p);\n                    p -= DTLS1_HM_HEADER_LENGTH;\n                    xlen = written;\n                } else {\n                    p += DTLS1_HM_HEADER_LENGTH;\n                    xlen = written - DTLS1_HM_HEADER_LENGTH;\n                }\n\n                if (!ssl3_finish_mac(s, p, xlen))\n                    return -1;\n            }\n\n            if (written == s->init_num) {\n                if (s->msg_callback)\n                    s->msg_callback(1, s->version, type, s->init_buf->data,\n                                    (size_t)(s->init_off + s->init_num), s,\n                                    s->msg_callback_arg);\n\n                s->init_off = 0; /* done writing this message */\n                s->init_num = 0;\n\n                return 1;\n            }\n            s->init_off += written;\n            s->init_num -= written;\n            written -= DTLS1_HM_HEADER_LENGTH;\n            frag_off += written;\n\n            /*\n             * We save the fragment offset for the next fragment so we have it\n             * available in case of an IO retry. We don't know the length of the\n             * next fragment yet so just set that to 0 for now. It will be\n             * updated again later.\n             */\n            dtls1_fix_message_header(s, frag_off, 0);\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": 4871, "func": "static void write_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost)\n{\n    AVFormatContext *s = of->ctx;\n    AVStream *st = ost->st;\n    int ret;\n\n    if (!of->header_written) {\n        AVPacket tmp_pkt;\n        /* the muxer is not initialized yet, buffer the packet */\n        if (!av_fifo_space(ost->muxing_queue)) {\n            int new_size = FFMIN(2 * av_fifo_size(ost->muxing_queue),\n                                 ost->max_muxing_queue_size);\n            if (new_size <= av_fifo_size(ost->muxing_queue)) {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Too many packets buffered for output stream %d:%d.\\n\",\n                       ost->file_index, ost->st->index);\n                exit_program(1);\n            }\n            ret = av_fifo_realloc2(ost->muxing_queue, new_size);\n            if (ret < 0)\n                exit_program(1);\n        }\n        av_packet_move_ref(&tmp_pkt, pkt);\n        av_fifo_generic_write(ost->muxing_queue, &tmp_pkt, sizeof(tmp_pkt), NULL);\n        return;\n    }\n\n    /*\n     * Audio encoders may split the packets --  #frames in != #packets out.\n     * But there is no reordering, so we can limit the number of output packets\n     * by simply dropping them here.\n     * Counting encoded video frames needs to be done separately because of\n     * reordering, see do_video_out()\n     */\n    if (!(st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && ost->encoding_needed)) {\n        if (ost->frame_number >= ost->max_frames) {\n            av_packet_unref(pkt);\n            return;\n        }\n        ost->frame_number++;\n    }\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        uint8_t *sd = av_packet_get_side_data(pkt, AV_PKT_DATA_QUALITY_FACTOR,\n                                              NULL);\n        ost->quality = sd ? *(int *)sd : -1;\n\n        if (ost->frame_rate.num) {\n            pkt->duration = av_rescale_q(1, av_inv_q(ost->frame_rate),\n                                         ost->st->time_base);\n        }\n    }\n\n    if (!(s->oformat->flags & AVFMT_NOTIMESTAMPS) &&\n        ost->last_mux_dts != AV_NOPTS_VALUE &&\n        pkt->dts < ost->last_mux_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT)) {\n        av_log(NULL, AV_LOG_WARNING, \"Non-monotonous DTS in output stream \"\n               \"%d:%d; previous: %\"PRId64\", current: %\"PRId64\"; \",\n               ost->file_index, ost->st->index, ost->last_mux_dts, pkt->dts);\n        if (exit_on_error) {\n            av_log(NULL, AV_LOG_FATAL, \"aborting.\\n\");\n            exit_program(1);\n        }\n        av_log(NULL, AV_LOG_WARNING, \"changing to %\"PRId64\". This may result \"\n               \"in incorrect timestamps in the output file.\\n\",\n               ost->last_mux_dts + 1);\n        pkt->dts = ost->last_mux_dts + 1;\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts = FFMAX(pkt->pts, pkt->dts);\n    }\n    ost->last_mux_dts = pkt->dts;\n\n    ost->data_size += pkt->size;\n    ost->packets_written++;\n\n    pkt->stream_index = ost->index;\n    ret = av_interleaved_write_frame(s, pkt);\n    if (ret < 0) {\n        print_error(\"av_interleaved_write_frame()\", ret);\n        exit_program(1);\n    }\n}", "target": 0}
{"idx": 4872, "func": "static void rpza_decode_stream(RpzaContext *s)\n{\n    int width = s->avctx->width;\n    int stride = s->frame->linesize[0] / 2;\n    int row_inc = stride - 4;\n    int chunk_size;\n    uint16_t colorA = 0, colorB;\n    uint16_t color4[4];\n    uint16_t ta, tb;\n    uint16_t *pixels = (uint16_t *)s->frame->data[0];\n\n    int row_ptr = 0;\n    int pixel_ptr = 0;\n    int block_ptr;\n    int pixel_x, pixel_y;\n    int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (bytestream2_peek_byte(&s->gb) != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n               bytestream2_peek_byte(&s->gb));\n\n    /* Get chunk size, ingnoring first byte */\n    chunk_size = bytestream2_get_be32(&s->gb) & 0x00FFFFFF;\n\n    /* If length mismatch use size from MOV file and try to decode anyway */\n    if (chunk_size != bytestream2_get_bytes_left(&s->gb) - 4)\n        av_log(s->avctx, AV_LOG_WARNING, \"MOV chunk size != encoded chunk size\\n\");\n\n    /* Number of 4x4 blocks in frame. */\n    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);\n\n    /* Process chunk data */\n    while (bytestream2_get_bytes_left(&s->gb)) {\n        uint8_t opcode = bytestream2_get_byte(&s->gb); /* Get opcode */\n\n        int n_blocks = (opcode & 0x1f) + 1; /* Extract block counter from opcode */\n\n        /* If opcode MSbit is 0, we need more data to decide what to do */\n        if ((opcode & 0x80) == 0) {\n            colorA = (opcode << 8) | bytestream2_get_byte(&s->gb);\n            opcode = 0;\n            if ((bytestream2_peek_byte(&s->gb) & 0x80) != 0) {\n                /* Must behave as opcode 110xxxxx, using colorA computed\n                 * above. Use fake opcode 0x20 to enter switch block at\n                 * the right place */\n                opcode = 0x20;\n                n_blocks = 1;\n            }\n        }\n\n        n_blocks = FFMIN(n_blocks, total_blocks);\n\n        switch (opcode & 0xe0) {\n\n        /* Skip blocks */\n        case 0x80:\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n            colorA = bytestream2_get_be16(&s->gb);\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n                ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = bytestream2_get_be16(&s->gb);\n        case 0x20:\n            colorB = bytestream2_get_be16(&s->gb);\n\n            /* sort out the colors */\n            color4[0] = colorB;\n            color4[1] = 0;\n            color4[2] = 0;\n            color4[3] = colorA;\n\n            /* red components */\n            ta = (colorA >> 10) & 0x1F;\n            tb = (colorB >> 10) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;\n\n            /* green components */\n            ta = (colorA >> 5) & 0x1F;\n            tb = (colorB >> 5) & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n            if (bytestream2_get_bytes_left(&s->gb) < n_blocks * 4)\n                return;\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    uint8_t index = bytestream2_get_byteu(&s->gb);\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        uint8_t idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n                ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill block with 16 colors */\n        case 0x00:\n            if (bytestream2_get_bytes_left(&s->gb) < 30)\n                return;\n            block_ptr = row_ptr + pixel_ptr;\n            for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x != 0))\n                        colorA = bytestream2_get_be16u(&s->gb);\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                }\n                block_ptr += row_inc;\n            }\n            ADVANCE_BLOCK();\n            break;\n\n        /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 bytestream2_get_bytes_left(&s->gb));\n            return;\n        } /* Opcode switch */\n    }\n}", "target": 1}
{"idx": 4873, "func": "void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)\n{\n    /* see similar ffmpeg.c:grow_array() */\n    int nb, nb_alloc;\n    intptr_t *tab;\n\n    nb = *nb_ptr;\n    tab = *(intptr_t**)tab_ptr;\n    if ((nb & (nb - 1)) == 0) {\n        if (nb == 0)\n            nb_alloc = 1;\n        else\n            nb_alloc = nb * 2;\n        tab = av_realloc(tab, nb_alloc * sizeof(intptr_t));\n        *(intptr_t**)tab_ptr = tab;\n    }\n    tab[nb++] = (intptr_t)elem;\n    *nb_ptr = nb;\n}", "target": 1}
{"idx": 4874, "func": "static inline void skip_bits(GetBitContext *s, int n)\n{\n    OPEN_READER(re, s);\n    LAST_SKIP_BITS(re, s, n);\n    CLOSE_READER(re, s);\n}", "target": 1}
{"idx": 4875, "func": "int audio_resample(ReSampleContext *s, short *output, short *input, int nb_samples)\n{\n    int i, nb_samples1;\n    short *bufin[2];\n    short *bufout[2];\n    short *buftmp2[2], *buftmp3[2];\n    short *output_bak = NULL;\n    int lenout;\n\n    if (s->input_channels == s->output_channels && s->ratio == 1.0 && 0) {\n        /* nothing to do */\n        memcpy(output, input, nb_samples * s->input_channels * sizeof(short));\n        return nb_samples;\n    }\n\n    if (s->sample_fmt[0] != SAMPLE_FMT_S16) {\n        int istride[1] = { s->sample_size[0] };\n        int ostride[1] = { 2 };\n        const void *ibuf[1] = { input };\n        void       *obuf[1];\n        unsigned input_size = nb_samples*s->input_channels*s->sample_size[0];\n\n        if (!s->buffer_size[0] || s->buffer_size[0] < input_size) {\n            av_free(s->buffer[0]);\n            s->buffer_size[0] = input_size;\n            s->buffer[0] = av_malloc(s->buffer_size[0]);\n            if (!s->buffer[0]) {\n                av_log(s, AV_LOG_ERROR, \"Could not allocate buffer\\n\");\n                return 0;\n            }\n        }\n\n        obuf[0] = s->buffer[0];\n\n        if (av_audio_convert(s->convert_ctx[0], obuf, ostride,\n                             ibuf, istride, nb_samples*s->input_channels) < 0) {\n            av_log(s, AV_LOG_ERROR, \"Audio sample format conversion failed\\n\");\n            return 0;\n        }\n\n        input  = s->buffer[0];\n    }\n\n    lenout= 4*nb_samples * s->ratio + 16;\n\n    if (s->sample_fmt[1] != SAMPLE_FMT_S16) {\n        output_bak = output;\n\n        if (!s->buffer_size[1] || s->buffer_size[1] < lenout) {\n            av_free(s->buffer[1]);\n            s->buffer_size[1] = lenout;\n            s->buffer[1] = av_malloc(s->buffer_size[1]);\n            if (!s->buffer[1]) {\n                av_log(s, AV_LOG_ERROR, \"Could not allocate buffer\\n\");\n                return 0;\n            }\n        }\n\n        output = s->buffer[1];\n    }\n\n    /* XXX: move those malloc to resample init code */\n    for(i=0; i<s->filter_channels; i++){\n        bufin[i]= av_malloc( (nb_samples + s->temp_len) * sizeof(short) );\n        memcpy(bufin[i], s->temp[i], s->temp_len * sizeof(short));\n        buftmp2[i] = bufin[i] + s->temp_len;\n    }\n\n    /* make some zoom to avoid round pb */\n    bufout[0]= av_malloc( lenout * sizeof(short) );\n    bufout[1]= av_malloc( lenout * sizeof(short) );\n\n    if (s->input_channels == 2 &&\n        s->output_channels == 1) {\n        buftmp3[0] = output;\n        stereo_to_mono(buftmp2[0], input, nb_samples);\n    } else if (s->output_channels >= 2 && s->input_channels == 1) {\n        buftmp3[0] = bufout[0];\n        memcpy(buftmp2[0], input, nb_samples*sizeof(short));\n    } else if (s->output_channels >= 2) {\n        buftmp3[0] = bufout[0];\n        buftmp3[1] = bufout[1];\n        stereo_split(buftmp2[0], buftmp2[1], input, nb_samples);\n    } else {\n        buftmp3[0] = output;\n        memcpy(buftmp2[0], input, nb_samples*sizeof(short));\n    }\n\n    nb_samples += s->temp_len;\n\n    /* resample each channel */\n    nb_samples1 = 0; /* avoid warning */\n    for(i=0;i<s->filter_channels;i++) {\n        int consumed;\n        int is_last= i+1 == s->filter_channels;\n\n        nb_samples1 = av_resample(s->resample_context, buftmp3[i], bufin[i], &consumed, nb_samples, lenout, is_last);\n        s->temp_len= nb_samples - consumed;\n        s->temp[i]= av_realloc(s->temp[i], s->temp_len*sizeof(short));\n        memcpy(s->temp[i], bufin[i] + consumed, s->temp_len*sizeof(short));\n    }\n\n    if (s->output_channels == 2 && s->input_channels == 1) {\n        mono_to_stereo(output, buftmp3[0], nb_samples1);\n    } else if (s->output_channels == 2) {\n        stereo_mux(output, buftmp3[0], buftmp3[1], nb_samples1);\n    } else if (s->output_channels == 6) {\n        ac3_5p1_mux(output, buftmp3[0], buftmp3[1], nb_samples1);\n    }\n\n    if (s->sample_fmt[1] != SAMPLE_FMT_S16) {\n        int istride[1] = { 2 };\n        int ostride[1] = { s->sample_size[1] };\n        const void *ibuf[1] = { output };\n        void       *obuf[1] = { output_bak };\n\n        if (av_audio_convert(s->convert_ctx[1], obuf, ostride,\n                             ibuf, istride, nb_samples1*s->output_channels) < 0) {\n            av_log(s, AV_LOG_ERROR, \"Audio sample format convertion failed\\n\");\n            return 0;\n        }\n    }\n\n    for(i=0; i<s->filter_channels; i++)\n        av_free(bufin[i]);\n\n    av_free(bufout[0]);\n    av_free(bufout[1]);\n    return nb_samples1;\n}", "target": 1}
{"idx": 4876, "func": "void AES_ige_encrypt(const unsigned char *in, unsigned char *out,\n\t\t\t\t\t const unsigned long length, const AES_KEY *key,\n\t\t\t\t\t unsigned char *ivec, const int enc)\n\t{\n\tunsigned long n;\n        unsigned long len;\n        aes_block_t tmp, tmp2;\n        aes_block_t iv;\n        aes_block_t iv2;\n\n\tOPENSSL_assert(in && out && key && ivec);\n\tOPENSSL_assert((AES_ENCRYPT == enc)||(AES_DECRYPT == enc));\n\tOPENSSL_assert((length%AES_BLOCK_SIZE) == 0);\n\n        len = length / AES_BLOCK_SIZE;\n        load_block(iv, ivec);\n        load_block(iv2, ivec + AES_BLOCK_SIZE);\n\n\tif (AES_ENCRYPT == enc)\n\t\t{\n\t\t/* XXX: Do a separate case for when in != out (strictly should\n\t\t   check for overlap, too) */\n\t\twhile (len)\n\t\t\t{\n                        load_block(tmp, in);\n\t\t\t/*\t\t\thexdump(stdout, \"in\", in, AES_BLOCK_SIZE); */\n\t\t\t/*\t\t\thexdump(stdout, \"iv\", iv, AES_BLOCK_SIZE); */\n                        for(n=0 ; n < N_WORDS; ++n)\n                                tmp2.data[n] = tmp.data[n] ^ iv.data[n];\n\t\t\t/*\t\t\thexdump(stdout, \"in ^ iv\", out, AES_BLOCK_SIZE); */\n\t\t\tAES_encrypt((unsigned char *)tmp2.data, (unsigned char *)tmp2.data, key);\n\t\t\t/*\t\t\thexdump(stdout,\"enc\", out, AES_BLOCK_SIZE); */\n\t\t\t/*\t\t\thexdump(stdout,\"iv2\", iv2, AES_BLOCK_SIZE); */\n\t\t\tfor(n=0 ; n < N_WORDS; ++n)\n                                tmp2.data[n] ^= iv2.data[n];\n                        store_block(out, tmp2);\n\t\t\t/*\t\t\thexdump(stdout,\"out\", out, AES_BLOCK_SIZE); */\n                        iv = tmp2;\n                        iv2 = tmp;\n\t\t\t--len;\n\t\t\tin += AES_BLOCK_SIZE;\n\t\t\tout += AES_BLOCK_SIZE;\n\t\t\t}\n\t\tmemcpy(ivec, iv.data, AES_BLOCK_SIZE);\n\t\tmemcpy(ivec + AES_BLOCK_SIZE, iv2.data, AES_BLOCK_SIZE);\n\t\t}\n\telse\n\t\t{\n\t\twhile (len)\n\t\t\t{\n                        load_block(tmp, in);\n                        tmp2 = tmp;\n\t\t\t/*\t\t\thexdump(stdout, \"in\", in, AES_BLOCK_SIZE); */\n\t\t\t/*\t\t\thexdump(stdout, \"iv2\", iv2, AES_BLOCK_SIZE); */\n\t\t\tfor(n=0 ; n < N_WORDS; ++n)\n                                tmp.data[n] ^= iv2.data[n];\n\t\t\t/*\t\t\thexdump(stdout, \"in ^ iv2\", tmp, AES_BLOCK_SIZE); */\n\t\t\tAES_decrypt((unsigned char *)tmp.data, (unsigned char *)tmp.data, key);\n\t\t\t/*\t\t\thexdump(stdout, \"dec\", out, AES_BLOCK_SIZE); */\n\t\t\t/*\t\t\thexdump(stdout, \"iv\", iv, AES_BLOCK_SIZE); */\n\t\t\tfor(n=0 ; n < N_WORDS; ++n)\n\t\t\t\ttmp.data[n] ^= iv.data[n];\n                        store_block(out, tmp);\n\t\t\t/*\t\t\thexdump(stdout, \"out\", out, AES_BLOCK_SIZE); */\n                        iv = tmp2;\n                        iv2 = tmp;\n\t\t\t--len;\n\t\t\tin += AES_BLOCK_SIZE;\n\t\t\tout += AES_BLOCK_SIZE;\n\t\t\t}\n                memcpy(ivec, iv.data, AES_BLOCK_SIZE);\n\t\tmemcpy(ivec + AES_BLOCK_SIZE, iv2.data, AES_BLOCK_SIZE);\n\t\t}\n\t}", "target": 0}
{"idx": 4877, "func": "static void quantize_and_encode_band(struct AACEncContext *s, PutBitContext *pb,\n                                     const float *in, int size, int scale_idx,\n                                     int cb, const float lambda)\n{\n    const float IQ = ff_aac_pow2sf_tab[200 + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n    const float  Q = ff_aac_pow2sf_tab[200 - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n    const float CLIPPED_ESCAPE = 165140.0f*IQ;\n    const int dim = (cb < FIRST_PAIR_BT) ? 4 : 2;\n    int i, j, k;\n#ifndef USE_REALLY_FULL_SEARCH\n    const float  Q34 = sqrtf(Q * sqrtf(Q));\n    const int range  = aac_cb_range[cb];\n    const int maxval = aac_cb_maxval[cb];\n    int offs[4];\n    float *scaled = s->scoefs;\n#endif /* USE_REALLY_FULL_SEARCH */\n\n//START_TIMER\n    if (!cb)\n        return;\n\n#ifndef USE_REALLY_FULL_SEARCH\n    offs[0] = 1;\n    for (i = 1; i < dim; i++)\n        offs[i] = offs[i-1]*range;\n    abs_pow34_v(scaled, in, size);\n    quantize_bands(s->qcoefs, in, scaled, size, Q34, !IS_CODEBOOK_UNSIGNED(cb), maxval);\n#endif /* USE_REALLY_FULL_SEARCH */\n    for (i = 0; i < size; i += dim) {\n        float mincost;\n        int minidx  = 0;\n        int minbits = 0;\n        const float *vec;\n#ifndef USE_REALLY_FULL_SEARCH\n        int (*quants)[2] = &s->qcoefs[i];\n        mincost = 0.0f;\n        for (j = 0; j < dim; j++)\n            mincost += in[i+j]*in[i+j];\n        minidx = IS_CODEBOOK_UNSIGNED(cb) ? 0 : 40;\n        minbits = ff_aac_spectral_bits[cb-1][minidx];\n        mincost = mincost * lambda + minbits;\n        for (j = 0; j < (1<<dim); j++) {\n            float rd = 0.0f;\n            int curbits;\n            int curidx = IS_CODEBOOK_UNSIGNED(cb) ? 0 : 40;\n            int same   = 0;\n            for (k = 0; k < dim; k++) {\n                if ((j & (1 << k)) && quants[k][0] == quants[k][1]) {\n                    same = 1;\n                    break;\n                }\n            }\n            if (same)\n                continue;\n            for (k = 0; k < dim; k++)\n                curidx += quants[k][!!(j & (1 << k))] * offs[dim - 1 - k];\n            curbits =  ff_aac_spectral_bits[cb-1][curidx];\n            vec     = &ff_aac_codebook_vectors[cb-1][curidx*dim];\n#else\n        vec = ff_aac_codebook_vectors[cb-1];\n        mincost = INFINITY;\n        for (j = 0; j < ff_aac_spectral_sizes[cb-1]; j++, vec += dim) {\n            float rd = 0.0f;\n            int curbits = ff_aac_spectral_bits[cb-1][j];\n            int curidx  = j;\n#endif /* USE_REALLY_FULL_SEARCH */\n            if (IS_CODEBOOK_UNSIGNED(cb)) {\n                for (k = 0; k < dim; k++) {\n                    float t = fabsf(in[i+k]);\n                    float di;\n                    if (vec[k] == 64.0f) { //FIXME: slow\n                        //do not code with escape sequence small values\n                        if (t < 39.0f*IQ) {\n                            rd = INFINITY;\n                            break;\n                        }\n                        if (t >= CLIPPED_ESCAPE) {\n                            di = t - CLIPPED_ESCAPE;\n                            curbits += 21;\n                        } else {\n                            int c = av_clip(quant(t, Q), 0, 8191);\n                            di = t - c*cbrtf(c)*IQ;\n                            curbits += av_log2(c)*2 - 4 + 1;\n                        }\n                    } else {\n                        di = t - vec[k]*IQ;\n                    }\n                    if (vec[k] != 0.0f)\n                        curbits++;\n                    rd += di*di;\n                }\n            } else {\n                for (k = 0; k < dim; k++) {\n                    float di = in[i+k] - vec[k]*IQ;\n                    rd += di*di;\n                }\n            }\n            rd = rd * lambda + curbits;\n            if (rd < mincost) {\n                mincost = rd;\n                minidx  = curidx;\n                minbits = curbits;\n            }\n        }\n        put_bits(pb, ff_aac_spectral_bits[cb-1][minidx], ff_aac_spectral_codes[cb-1][minidx]);\n        if (IS_CODEBOOK_UNSIGNED(cb))\n            for (j = 0; j < dim; j++)\n                if (ff_aac_codebook_vectors[cb-1][minidx*dim+j] != 0.0f)\n                    put_bits(pb, 1, in[i+j] < 0.0f);\n        if (cb == ESC_BT) {\n            for (j = 0; j < 2; j++) {\n                if (ff_aac_codebook_vectors[cb-1][minidx*2+j] == 64.0f) {\n                    int coef = av_clip(quant(fabsf(in[i+j]), Q), 0, 8191);\n                    int len = av_log2(coef);\n\n                    put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2);\n                    put_bits(pb, len, coef & ((1 << len) - 1));\n                }\n            }\n        }\n    }\n//STOP_TIMER(\"quantize_and_encode\")\n}", "target": 0}
{"idx": 4878, "func": "int decrypt_rfc4490_shared_key_2001(EVP_PKEY *priv,GOST_KEY_TRANSPORT *gkt,\n\tunsigned char *key_buf,int key_buf_len) \n\t{\n\tunsigned char wrappedKey[44];\n\tunsigned char sharedKey[32];\n\tgost_ctx ctx;\n\tconst struct gost_cipher_info *param=NULL;\n\tEVP_PKEY *eph_key=NULL;\n\t\n\teph_key = X509_PUBKEY_get(gkt->key_agreement_info->ephem_key);\n\tparam = get_encryption_params(gkt->key_agreement_info->cipher);\n\tgost_init(&ctx,param->sblock);\t\n\tOPENSSL_assert(gkt->key_agreement_info->eph_iv->length==8);\n\tmemcpy(wrappedKey,gkt->key_agreement_info->eph_iv->data,8);\n\tOPENSSL_assert(gkt->key_info->encrypted_key->length==32);\n\tmemcpy(wrappedKey+8,gkt->key_info->encrypted_key->data,32);\n\tOPENSSL_assert(gkt->key_info->imit->length==4);\n\tmemcpy(wrappedKey+40,gkt->key_info->imit->data,4);\t\n\tVKO_compute_key(sharedKey,32,EC_KEY_get0_public_key(EVP_PKEY_get0(eph_key)),\n\t\tEVP_PKEY_get0(priv),wrappedKey);\n\tif (!keyUnwrapCryptoPro(&ctx,sharedKey,wrappedKey,key_buf))\n\t\t{\n\t\tGOSTerr(GOST_F_PKCS7_GOST94CP_KEY_TRANSPORT_DECRYPT,\n\t\t\tGOST_R_ERROR_COMPUTING_SHARED_KEY);\n\t\tgoto err;\n\t\t}\t\n\t\t\t\t\n\tEVP_PKEY_free(eph_key);\n\treturn 32;\n\terr:\n\tEVP_PKEY_free(eph_key);\n\treturn -1;\n\t}", "target": 1}
{"idx": 4879, "func": "static int read_packet(AVFormatContext *s,\n                       AVPacket *pkt)\n{\n    FilmstripDemuxContext *film = s->priv_data;\n    AVStream *st = s->streams[0];\n\n    if (s->pb->eof_reached)\n        return AVERROR(EIO);\n    pkt->dts = avio_tell(s->pb) / (st->codec->width * (st->codec->height + film->leading) * 4);\n    pkt->size = av_get_packet(s->pb, pkt, st->codec->width * st->codec->height * 4);\n    avio_skip(s->pb, st->codec->width * film->leading * 4);\n    if (pkt->size < 0)\n        return pkt->size;\n    pkt->flags |= AV_PKT_FLAG_KEY;\n    return 0;\n}", "target": 1}
{"idx": 4880, "func": "static int mov_probe(AVProbeData *p)\n{\n    int64_t offset;\n    uint32_t tag;\n    int score = 0;\n\n    /* check file header */\n    offset = 0;\n    for (;;) {\n        /* ignore invalid offset */\n        if ((offset + 8) > (unsigned int)p->buf_size)\n            return score;\n        tag = AV_RL32(p->buf + offset + 4);\n        switch(tag) {\n        /* check for obvious tags */\n        case MKTAG('j','P',' ',' '): /* jpeg 2000 signature */\n        case MKTAG('m','o','o','v'):\n        case MKTAG('m','d','a','t'):\n        case MKTAG('p','n','o','t'): /* detect movs with preview pics like ew.mov and april.mov */\n        case MKTAG('u','d','t','a'): /* Packet Video PVAuthor adds this and a lot of more junk */\n        case MKTAG('f','t','y','p'):\n            return AVPROBE_SCORE_MAX;\n        /* those are more common words, so rate then a bit less */\n        case MKTAG('e','d','i','w'): /* xdcam files have reverted first tags */\n        case MKTAG('w','i','d','e'):\n        case MKTAG('f','r','e','e'):\n        case MKTAG('j','u','n','k'):\n        case MKTAG('p','i','c','t'):\n            return AVPROBE_SCORE_MAX - 5;\n        case MKTAG(0x82,0x82,0x7f,0x7d):\n        case MKTAG('s','k','i','p'):\n        case MKTAG('u','u','i','d'):\n        case MKTAG('p','r','f','l'):\n            offset = AV_RB32(p->buf+offset) + offset;\n            /* if we only find those cause probedata is too small at least rate them */\n            score = AVPROBE_SCORE_MAX - 50;\n            break;\n        default:\n            /* unrecognized tag */\n            return score;\n        }\n    }\n}", "target": 0}
{"idx": 4881, "func": "static void x509v3_cache_extensions(X509 *x)\n{\n\tBASIC_CONSTRAINTS *bs;\n\tASN1_BIT_STRING *usage;\n\tASN1_BIT_STRING *ns;\n\tSTACK_OF(ASN1_OBJECT) *extusage;\n\t\n\tint i;\n\tif(x->ex_flags & EXFLAG_SET) return;\n#ifndef NO_SHA\n\tX509_digest(x, EVP_sha1(), x->sha1_hash, NULL);\n#endif\n\t/* Does subject name match issuer ? */\n\tif(!X509_NAME_cmp(X509_get_subject_name(x), X509_get_issuer_name(x)))\n\t\t\t x->ex_flags |= EXFLAG_SS;\n\t/* V1 should mean no extensions ... */\n\tif(!X509_get_version(x)) x->ex_flags |= EXFLAG_V1;\n\t/* Handle basic constraints */\n\tif((bs=X509_get_ext_d2i(x, NID_basic_constraints, NULL, NULL))) {\n\t\tif(bs->ca) x->ex_flags |= EXFLAG_CA;\n\t\tif(bs->pathlen) {\n\t\t\tif((bs->pathlen->type == V_ASN1_NEG_INTEGER)\n\t\t\t\t\t\t|| !bs->ca) {\n\t\t\t\tx->ex_flags |= EXFLAG_INVALID;\n\t\t\t\tx->ex_pathlen = 0;\n\t\t\t} else x->ex_pathlen = ASN1_INTEGER_get(bs->pathlen);\n\t\t} else x->ex_pathlen = -1;\n\t\tBASIC_CONSTRAINTS_free(bs);\n\t\tx->ex_flags |= EXFLAG_BCONS;\n\t}\n\t/* Handle key usage */\n\tif((usage=X509_get_ext_d2i(x, NID_key_usage, NULL, NULL))) {\n\t\tif(usage->length > 0) {\n\t\t\tx->ex_kusage = usage->data[0];\n\t\t\tif(usage->length > 1) \n\t\t\t\tx->ex_kusage |= usage->data[1] << 8;\n\t\t} else x->ex_kusage = 0;\n\t\tx->ex_flags |= EXFLAG_KUSAGE;\n\t\tASN1_BIT_STRING_free(usage);\n\t}\n\tx->ex_xkusage = 0;\n\tif((extusage=X509_get_ext_d2i(x, NID_ext_key_usage, NULL, NULL))) {\n\t\tx->ex_flags |= EXFLAG_XKUSAGE;\n\t\tfor(i = 0; i < sk_ASN1_OBJECT_num(extusage); i++) {\n\t\t\tswitch(OBJ_obj2nid(sk_ASN1_OBJECT_value(extusage,i))) {\n\t\t\t\tcase NID_server_auth:\n\t\t\t\tx->ex_xkusage |= XKU_SSL_SERVER;\n\t\t\t\tbreak;\n\n\t\t\t\tcase NID_client_auth:\n\t\t\t\tx->ex_xkusage |= XKU_SSL_CLIENT;\n\t\t\t\tbreak;\n\n\t\t\t\tcase NID_email_protect:\n\t\t\t\tx->ex_xkusage |= XKU_SMIME;\n\t\t\t\tbreak;\n\n\t\t\t\tcase NID_code_sign:\n\t\t\t\tx->ex_xkusage |= XKU_CODE_SIGN;\n\t\t\t\tbreak;\n\n\t\t\t\tcase NID_ms_sgc:\n\t\t\t\tcase NID_ns_sgc:\n\t\t\t\tx->ex_xkusage |= XKU_SGC;\n\t\t\t}\n\t\t}\n\t\tsk_ASN1_OBJECT_pop_free(extusage, ASN1_OBJECT_free);\n\t}\n\n\tif((ns=X509_get_ext_d2i(x, NID_netscape_cert_type, NULL, NULL))) {\n\t\tif(ns->length > 0) x->ex_nscert = ns->data[0];\n\t\telse x->ex_nscert = 0;\n\t\tx->ex_flags |= EXFLAG_NSCERT;\n\t\tASN1_BIT_STRING_free(ns);\n\t}\n\tx->skid =X509_get_ext_d2i(x, NID_subject_key_identifier, NULL, NULL);\n\tx->akid =X509_get_ext_d2i(x, NID_authority_key_identifier, NULL, NULL);\n\tx->ex_flags |= EXFLAG_SET;\n}", "target": 0}
{"idx": 4882, "func": "tmsize_t\nTIFFRasterScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFRasterScanlineSize\";\n\tuint64 m;\n\tm=TIFFRasterScanlineSize64(tif);\n\treturn _TIFFCastUInt64ToSSize(tif, m, module);\n}", "target": 0}
{"idx": 4883, "func": "SSL *SSL_new(SSL_CTX *ctx)\n{\n    SSL *s;\n\n    if (ctx == NULL) {\n        SSLerr(SSL_F_SSL_NEW, SSL_R_NULL_SSL_CTX);\n        return NULL;\n    }\n    if (ctx->method == NULL) {\n        SSLerr(SSL_F_SSL_NEW, SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);\n        return NULL;\n    }\n\n    s = OPENSSL_zalloc(sizeof(*s));\n    if (s == NULL)\n        goto err;\n\n    s->references = 1;\n    s->lock = CRYPTO_THREAD_lock_new();\n    if (s->lock == NULL) {\n        OPENSSL_free(s);\n        s = NULL;\n        goto err;\n    }\n\n    RECORD_LAYER_init(&s->rlayer, s);\n\n    s->options = ctx->options;\n    s->dane.flags = ctx->dane.flags;\n    s->min_proto_version = ctx->min_proto_version;\n    s->max_proto_version = ctx->max_proto_version;\n    s->mode = ctx->mode;\n    s->max_cert_list = ctx->max_cert_list;\n    s->max_early_data = ctx->max_early_data;\n    s->recv_max_early_data = ctx->recv_max_early_data;\n    s->num_tickets = ctx->num_tickets;\n\n    /* Shallow copy of the ciphersuites stack */\n    s->tls13_ciphersuites = sk_SSL_CIPHER_dup(ctx->tls13_ciphersuites);\n    if (s->tls13_ciphersuites == NULL)\n        goto err;\n\n    /*\n     * Earlier library versions used to copy the pointer to the CERT, not\n     * its contents; only when setting new parameters for the per-SSL\n     * copy, ssl_cert_new would be called (and the direct reference to\n     * the per-SSL_CTX settings would be lost, but those still were\n     * indirectly accessed for various purposes, and for that reason they\n     * used to be known as s->ctx->default_cert). Now we don't look at the\n     * SSL_CTX's CERT after having duplicated it once.\n     */\n    s->cert = ssl_cert_dup(ctx->cert);\n    if (s->cert == NULL)\n        goto err;\n\n    RECORD_LAYER_set_read_ahead(&s->rlayer, ctx->read_ahead);\n    s->msg_callback = ctx->msg_callback;\n    s->msg_callback_arg = ctx->msg_callback_arg;\n    s->verify_mode = ctx->verify_mode;\n    s->not_resumable_session_cb = ctx->not_resumable_session_cb;\n    s->record_padding_cb = ctx->record_padding_cb;\n    s->record_padding_arg = ctx->record_padding_arg;\n    s->block_padding = ctx->block_padding;\n    s->sid_ctx_length = ctx->sid_ctx_length;\n    if (!ossl_assert(s->sid_ctx_length <= sizeof(s->sid_ctx)))\n        goto err;\n    memcpy(&s->sid_ctx, &ctx->sid_ctx, sizeof(s->sid_ctx));\n    s->verify_callback = ctx->default_verify_callback;\n    s->generate_session_id = ctx->generate_session_id;\n\n    s->param = X509_VERIFY_PARAM_new();\n    if (s->param == NULL)\n        goto err;\n    X509_VERIFY_PARAM_inherit(s->param, ctx->param);\n    s->quiet_shutdown = ctx->quiet_shutdown;\n\n    s->ext.max_fragment_len_mode = ctx->ext.max_fragment_len_mode;\n    s->max_send_fragment = ctx->max_send_fragment;\n    s->split_send_fragment = ctx->split_send_fragment;\n    s->max_pipelines = ctx->max_pipelines;\n    if (s->max_pipelines > 1)\n        RECORD_LAYER_set_read_ahead(&s->rlayer, 1);\n    if (ctx->default_read_buf_len > 0)\n        SSL_set_default_read_buffer_len(s, ctx->default_read_buf_len);\n\n    SSL_CTX_up_ref(ctx);\n    s->ctx = ctx;\n    s->ext.debug_cb = 0;\n    s->ext.debug_arg = NULL;\n    s->ext.ticket_expected = 0;\n    s->ext.status_type = ctx->ext.status_type;\n    s->ext.status_expected = 0;\n    s->ext.ocsp.ids = NULL;\n    s->ext.ocsp.exts = NULL;\n    s->ext.ocsp.resp = NULL;\n    s->ext.ocsp.resp_len = 0;\n    SSL_CTX_up_ref(ctx);\n    s->session_ctx = ctx;\n#ifndef OPENSSL_NO_EC\n    if (ctx->ext.ecpointformats) {\n        s->ext.ecpointformats =\n            OPENSSL_memdup(ctx->ext.ecpointformats,\n                           ctx->ext.ecpointformats_len);\n        if (!s->ext.ecpointformats)\n            goto err;\n        s->ext.ecpointformats_len =\n            ctx->ext.ecpointformats_len;\n    }\n    if (ctx->ext.supportedgroups) {\n        s->ext.supportedgroups =\n            OPENSSL_memdup(ctx->ext.supportedgroups,\n                           ctx->ext.supportedgroups_len\n                                * sizeof(*ctx->ext.supportedgroups));\n        if (!s->ext.supportedgroups)\n            goto err;\n        s->ext.supportedgroups_len = ctx->ext.supportedgroups_len;\n    }\n#endif\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    s->ext.npn = NULL;\n#endif\n\n    if (s->ctx->ext.alpn) {\n        s->ext.alpn = OPENSSL_malloc(s->ctx->ext.alpn_len);\n        if (s->ext.alpn == NULL)\n            goto err;\n        memcpy(s->ext.alpn, s->ctx->ext.alpn, s->ctx->ext.alpn_len);\n        s->ext.alpn_len = s->ctx->ext.alpn_len;\n    }\n\n    s->verified_chain = NULL;\n    s->verify_result = X509_V_OK;\n\n    s->default_passwd_callback = ctx->default_passwd_callback;\n    s->default_passwd_callback_userdata = ctx->default_passwd_callback_userdata;\n\n    s->method = ctx->method;\n\n    s->key_update = SSL_KEY_UPDATE_NONE;\n\n    s->allow_early_data_cb = ctx->allow_early_data_cb;\n    s->allow_early_data_cb_data = ctx->allow_early_data_cb_data;\n\n    if (!s->method->ssl_new(s))\n        goto err;\n\n    s->server = (ctx->method->ssl_accept == ssl_undefined_function) ? 0 : 1;\n\n    if (!SSL_clear(s))\n        goto err;\n\n    if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data))\n        goto err;\n\n#ifndef OPENSSL_NO_PSK\n    s->psk_client_callback = ctx->psk_client_callback;\n    s->psk_server_callback = ctx->psk_server_callback;\n#endif\n    s->psk_find_session_cb = ctx->psk_find_session_cb;\n    s->psk_use_session_cb = ctx->psk_use_session_cb;\n\n    s->job = NULL;\n\n#ifndef OPENSSL_NO_CT\n    if (!SSL_set_ct_validation_callback(s, ctx->ct_validation_callback,\n                                        ctx->ct_validation_callback_arg))\n        goto err;\n#endif\n\n    return s;\n err:\n    SSL_free(s);\n    SSLerr(SSL_F_SSL_NEW, ERR_R_MALLOC_FAILURE);\n    return NULL;\n}", "target": 0}
{"idx": 4884, "func": "size_t av_strlcpy(char *dst, const char *src, size_t size)\n{\n    size_t len = 0;\n    while (++len < size && *src)\n        *dst++ = *src++;\n    if (len <= size)\n        *dst = 0;\n    return len + strlen(src) - 1;\n}", "target": 1}
{"idx": 4885, "func": "int ff_h264_execute_ref_pic_marking(H264Context *h, MMCO *mmco, int mmco_count)\n{\n    int i, av_uninit(j);\n    int current_ref_assigned = 0, err = 0;\n    H264Picture *av_uninit(pic);\n\n    if ((h->avctx->debug & FF_DEBUG_MMCO) && mmco_count == 0)\n        av_log(h->avctx, AV_LOG_DEBUG, \"no mmco here\\n\");\n\n    for (i = 0; i < mmco_count; i++) {\n        int av_uninit(structure), av_uninit(frame_num);\n        if (h->avctx->debug & FF_DEBUG_MMCO)\n            av_log(h->avctx, AV_LOG_DEBUG, \"mmco:%d %d %d\\n\", h->mmco[i].opcode,\n                   h->mmco[i].short_pic_num, h->mmco[i].long_arg);\n\n        if (mmco[i].opcode == MMCO_SHORT2UNUSED ||\n            mmco[i].opcode == MMCO_SHORT2LONG) {\n            frame_num = pic_num_extract(h, mmco[i].short_pic_num, &structure);\n            pic       = find_short(h, frame_num, &j);\n            if (!pic) {\n                if (mmco[i].opcode != MMCO_SHORT2LONG ||\n                    !h->long_ref[mmco[i].long_arg]    ||\n                    h->long_ref[mmco[i].long_arg]->frame_num != frame_num) {\n                    av_log(h->avctx, AV_LOG_ERROR, \"mmco: unref short failure\\n\");\n                    err = AVERROR_INVALIDDATA;\n                }\n                continue;\n            }\n        }\n\n        switch (mmco[i].opcode) {\n        case MMCO_SHORT2UNUSED:\n            if (h->avctx->debug & FF_DEBUG_MMCO)\n                av_log(h->avctx, AV_LOG_DEBUG, \"mmco: unref short %d count %d\\n\",\n                       h->mmco[i].short_pic_num, h->short_ref_count);\n            remove_short(h, frame_num, structure ^ PICT_FRAME);\n            break;\n        case MMCO_SHORT2LONG:\n                if (h->long_ref[mmco[i].long_arg] != pic)\n                    remove_long(h, mmco[i].long_arg, 0);\n\n                remove_short_at_index(h, j);\n                h->long_ref[ mmco[i].long_arg ] = pic;\n                if (h->long_ref[mmco[i].long_arg]) {\n                    h->long_ref[mmco[i].long_arg]->long_ref = 1;\n                    h->long_ref_count++;\n                }\n            break;\n        case MMCO_LONG2UNUSED:\n            j   = pic_num_extract(h, mmco[i].long_arg, &structure);\n            pic = h->long_ref[j];\n            if (pic) {\n                remove_long(h, j, structure ^ PICT_FRAME);\n            } else if (h->avctx->debug & FF_DEBUG_MMCO)\n                av_log(h->avctx, AV_LOG_DEBUG, \"mmco: unref long failure\\n\");\n            break;\n        case MMCO_LONG:\n                    // Comment below left from previous code as it is an interresting note.\n                    /* First field in pair is in short term list or\n                     * at a different long term index.\n                     * This is not allowed; see 7.4.3.3, notes 2 and 3.\n                     * Report the problem and keep the pair where it is,\n                     * and mark this field valid.\n                     */\n            if (h->short_ref[0] == h->cur_pic_ptr)\n                remove_short_at_index(h, 0);\n\n            /* make sure the current picture is not already assigned as a long ref */\n            if (h->cur_pic_ptr->long_ref) {\n                for (j = 0; j < FF_ARRAY_ELEMS(h->long_ref); j++) {\n                    if (h->long_ref[j] == h->cur_pic_ptr)\n                        remove_long(h, j, 0);\n                }\n            }\n\n\n            if (h->long_ref[mmco[i].long_arg] != h->cur_pic_ptr) {\n                remove_long(h, mmco[i].long_arg, 0);\n\n                h->long_ref[mmco[i].long_arg]           = h->cur_pic_ptr;\n                h->long_ref[mmco[i].long_arg]->long_ref = 1;\n                h->long_ref_count++;\n            }\n\n            h->cur_pic_ptr->reference |= h->picture_structure;\n            current_ref_assigned = 1;\n            break;\n        case MMCO_SET_MAX_LONG:\n            assert(mmco[i].long_arg <= 16);\n            // just remove the long term which index is greater than new max\n            for (j = mmco[i].long_arg; j < 16; j++) {\n                remove_long(h, j, 0);\n            }\n            break;\n        case MMCO_RESET:\n            while (h->short_ref_count) {\n                remove_short(h, h->short_ref[0]->frame_num, 0);\n            }\n            for (j = 0; j < 16; j++) {\n                remove_long(h, j, 0);\n            }\n            h->frame_num  = h->cur_pic_ptr->frame_num = 0;\n            h->mmco_reset = 1;\n            h->cur_pic_ptr->mmco_reset = 1;\n            break;\n        default: assert(0);\n        }\n    }\n\n    if (!current_ref_assigned) {\n        /* Second field of complementary field pair; the first field of\n         * which is already referenced. If short referenced, it\n         * should be first entry in short_ref. If not, it must exist\n         * in long_ref; trying to put it on the short list here is an\n         * error in the encoded bit stream (ref: 7.4.3.3, NOTE 2 and 3).\n         */\n        if (h->short_ref_count && h->short_ref[0] == h->cur_pic_ptr) {\n            /* Just mark the second field valid */\n            h->cur_pic_ptr->reference = PICT_FRAME;\n        } else if (h->cur_pic_ptr->long_ref) {\n            av_log(h->avctx, AV_LOG_ERROR, \"illegal short term reference \"\n                                           \"assignment for second field \"\n                                           \"in complementary field pair \"\n                                           \"(first field is long term)\\n\");\n            err = AVERROR_INVALIDDATA;\n        } else {\n            pic = remove_short(h, h->cur_pic_ptr->frame_num, 0);\n            if (pic) {\n                av_log(h->avctx, AV_LOG_ERROR, \"illegal short term buffer state detected\\n\");\n                err = AVERROR_INVALIDDATA;\n            }\n\n            if (h->short_ref_count)\n                memmove(&h->short_ref[1], &h->short_ref[0],\n                        h->short_ref_count * sizeof(H264Picture*));\n\n            h->short_ref[0] = h->cur_pic_ptr;\n            h->short_ref_count++;\n            h->cur_pic_ptr->reference |= h->picture_structure;\n        }\n    }\n\n    if (h->long_ref_count + h->short_ref_count -\n        (h->short_ref[0] == h->cur_pic_ptr) > h->ps.sps->ref_frame_count) {\n\n        /* We have too many reference frames, probably due to corrupted\n         * stream. Need to discard one frame. Prevents overrun of the\n         * short_ref and long_ref buffers.\n         */\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"number of reference frames (%d+%d) exceeds max (%d; probably \"\n               \"corrupt input), discarding one\\n\",\n               h->long_ref_count, h->short_ref_count, h->ps.sps->ref_frame_count);\n        err = AVERROR_INVALIDDATA;\n\n        if (h->long_ref_count && !h->short_ref_count) {\n            for (i = 0; i < 16; ++i)\n                if (h->long_ref[i])\n                    break;\n\n            assert(i < 16);\n            remove_long(h, i, 0);\n        } else {\n            pic = h->short_ref[h->short_ref_count - 1];\n            remove_short(h, pic->frame_num, 0);\n        }\n    }\n\n    print_short_term(h);\n    print_long_term(h);\n    return (h->avctx->err_recognition & AV_EF_EXPLODE) ? err : 0;\n}", "target": 0}
{"idx": 4886, "func": "int gost2001_compute_public(EC_KEY *ec) \n\t{\n\tconst EC_GROUP *group = EC_KEY_get0_group(ec);\n\tEC_POINT *pub_key=NULL;\n\tconst BIGNUM *priv_key=NULL;\n\tBN_CTX *ctx=NULL;\n\tint ok=0;\n\n\tif (!group)\n\t\t{\n\t\tGOSTerr(GOST_F_GOST2001_COMPUTE_PUBLIC,GOST_R_KEY_IS_NOT_INITIALIZED);\n\t\treturn 0;\n\t\t}\t\n\tctx=BN_CTX_new();\n\tBN_CTX_start(ctx);\n\tif (!(priv_key=EC_KEY_get0_private_key(ec))) \n\t\t{\n\t\tGOSTerr(GOST_F_GOST2001_COMPUTE_PUBLIC,ERR_R_EC_LIB);\n\t\tgoto err;\n\t\t}\t\n\n\tpub_key = EC_POINT_new(group);\n\tif (!EC_POINT_mul(group,pub_key,priv_key,NULL,NULL,ctx)) \n\t\t{\n\t\tGOSTerr(GOST_F_GOST2001_COMPUTE_PUBLIC,ERR_R_EC_LIB);\n\t\tgoto err;\n\t\t}\t\n\tif (!EC_KEY_set_public_key(ec,pub_key))\n\t\t{\n\t\tGOSTerr(GOST_F_GOST2001_COMPUTE_PUBLIC,ERR_R_EC_LIB);\n\t\tgoto err;\n\t\t}\t\n\tok = 256;\n\terr:\n\tBN_CTX_end(ctx);\n\tEC_POINT_free(pub_key);\n\tBN_CTX_free(ctx);\n\treturn ok;\n\t}", "target": 1}
{"idx": 4887, "func": "static int decode_subframe_fixed(FLACContext *s, int32_t *decoded,\n                                 int pred_order, int bps)\n{\n    const int blocksize = s->blocksize;\n    unsigned av_uninit(a), av_uninit(b), av_uninit(c), av_uninit(d);\n    int i;\n    int ret;\n\n    /* warm up samples */\n    for (i = 0; i < pred_order; i++) {\n        decoded[i] = get_sbits_long(&s->gb, bps);\n    }\n\n    if ((ret = decode_residuals(s, decoded, pred_order)) < 0)\n        return ret;\n\n    if (pred_order > 0)\n        a = decoded[pred_order-1];\n    if (pred_order > 1)\n        b = a - decoded[pred_order-2];\n    if (pred_order > 2)\n        c = b - decoded[pred_order-2] + decoded[pred_order-3];\n    if (pred_order > 3)\n        d = c - decoded[pred_order-2] + 2U*decoded[pred_order-3] - decoded[pred_order-4];\n\n    switch (pred_order) {\n    case 0:\n        break;\n    case 1:\n        for (i = pred_order; i < blocksize; i++)\n            decoded[i] = a += decoded[i];\n        break;\n    case 2:\n        for (i = pred_order; i < blocksize; i++)\n            decoded[i] = a += b += decoded[i];\n        break;\n    case 3:\n        for (i = pred_order; i < blocksize; i++)\n            decoded[i] = a += b += c += decoded[i];\n        break;\n    case 4:\n        for (i = pred_order; i < blocksize; i++)\n            decoded[i] = a += b += c += d += decoded[i];\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_ERROR, \"illegal pred order %d\\n\", pred_order);\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 4888, "func": "int ff_hevc_decode_short_term_rps(HEVCContext *s, ShortTermRPS *rps,\n                                  const HEVCSPS *sps, int is_slice_header)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    uint8_t rps_predict = 0;\n    int delta_poc;\n    int k0 = 0;\n    int k1 = 0;\n    int k  = 0;\n    int i;\n\n    GetBitContext *gb = &lc->gb;\n\n    if (rps != sps->st_rps && sps->nb_st_rps)\n        rps_predict = get_bits1(gb);\n\n    if (rps_predict) {\n        const ShortTermRPS *rps_ridx;\n        int delta_rps;\n        unsigned abs_delta_rps;\n        uint8_t use_delta_flag = 0;\n        uint8_t delta_rps_sign;\n\n        if (is_slice_header) {\n            unsigned int delta_idx = get_ue_golomb_long(gb) + 1;\n            if (delta_idx > sps->nb_st_rps) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Invalid value of delta_idx in slice header RPS: %d > %d.\\n\",\n                       delta_idx, sps->nb_st_rps);\n                return AVERROR_INVALIDDATA;\n            }\n            rps_ridx = &sps->st_rps[sps->nb_st_rps - delta_idx];\n        } else\n            rps_ridx = &sps->st_rps[rps - sps->st_rps - 1];\n\n        delta_rps_sign = get_bits1(gb);\n        abs_delta_rps  = get_ue_golomb_long(gb) + 1;\n        if (abs_delta_rps < 1 || abs_delta_rps > 32768) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Invalid value of abs_delta_rps: %d\\n\",\n                   abs_delta_rps);\n            return AVERROR_INVALIDDATA;\n        }\n        delta_rps      = (1 - (delta_rps_sign << 1)) * abs_delta_rps;\n        for (i = 0; i <= rps_ridx->num_delta_pocs; i++) {\n            int used = rps->used[k] = get_bits1(gb);\n\n            if (!used)\n                use_delta_flag = get_bits1(gb);\n\n            if (used || use_delta_flag) {\n                if (i < rps_ridx->num_delta_pocs)\n                    delta_poc = delta_rps + rps_ridx->delta_poc[i];\n                else\n                    delta_poc = delta_rps;\n                rps->delta_poc[k] = delta_poc;\n                if (delta_poc < 0)\n                    k0++;\n                else\n                    k1++;\n                k++;\n            }\n        }\n\n        rps->num_delta_pocs    = k;\n        rps->num_negative_pics = k0;\n        // sort in increasing order (smallest first)\n        if (rps->num_delta_pocs != 0) {\n            int used, tmp;\n            for (i = 1; i < rps->num_delta_pocs; i++) {\n                delta_poc = rps->delta_poc[i];\n                used      = rps->used[i];\n                for (k = i - 1; k >= 0; k--) {\n                    tmp = rps->delta_poc[k];\n                    if (delta_poc < tmp) {\n                        rps->delta_poc[k + 1] = tmp;\n                        rps->used[k + 1]      = rps->used[k];\n                        rps->delta_poc[k]     = delta_poc;\n                        rps->used[k]          = used;\n                    }\n                }\n            }\n        }\n        if ((rps->num_negative_pics >> 1) != 0) {\n            int used;\n            k = rps->num_negative_pics - 1;\n            // flip the negative values to largest first\n            for (i = 0; i < rps->num_negative_pics >> 1; i++) {\n                delta_poc         = rps->delta_poc[i];\n                used              = rps->used[i];\n                rps->delta_poc[i] = rps->delta_poc[k];\n                rps->used[i]      = rps->used[k];\n                rps->delta_poc[k] = delta_poc;\n                rps->used[k]      = used;\n                k--;\n            }\n        }\n    } else {\n        unsigned int prev, nb_positive_pics;\n        rps->num_negative_pics = get_ue_golomb_long(gb);\n        nb_positive_pics       = get_ue_golomb_long(gb);\n\n        if (rps->num_negative_pics >= MAX_REFS ||\n            nb_positive_pics >= MAX_REFS) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Too many refs in a short term RPS.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        rps->num_delta_pocs = rps->num_negative_pics + nb_positive_pics;\n        if (rps->num_delta_pocs) {\n            prev = 0;\n            for (i = 0; i < rps->num_negative_pics; i++) {\n                delta_poc = get_ue_golomb_long(gb) + 1;\n                prev -= delta_poc;\n                rps->delta_poc[i] = prev;\n                rps->used[i]      = get_bits1(gb);\n            }\n            prev = 0;\n            for (i = 0; i < nb_positive_pics; i++) {\n                delta_poc = get_ue_golomb_long(gb) + 1;\n                prev += delta_poc;\n                rps->delta_poc[rps->num_negative_pics + i] = prev;\n                rps->used[rps->num_negative_pics + i]      = get_bits1(gb);\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": 4889, "func": "int opt_md(const char *name, const EVP_MD **mdp)\n{\n    *mdp = EVP_get_digestbyname(name);\n    if (*mdp != NULL)\n        return 1;\n    BIO_printf(bio_err, \"%s: Unrecognized flag %s\\n\", prog, name);\n    return 0;\n}", "target": 0}
{"idx": 4890, "func": "request_rec *ap_read_request(conn_rec *conn)\n{\n    const char *expect;\n    int access_status;\n    apr_bucket_brigade *tmp_bb;\n    apr_socket_t *csd;\n    apr_interval_time_t cur_timeout;\n    core_server_config *conf;\n    int strict_host_check;\n\n    request_rec *r = ap_create_request(conn);\n\n    conf = ap_get_core_module_config(r->server->module_config);\n    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n\n    ap_run_pre_read_request(r, conn);\n\n    /* Get the request... */\n    if (!read_request_line(r, tmp_bb)) {\n        apr_brigade_cleanup(tmp_bb);\n        switch (r->status) {\n        case HTTP_REQUEST_URI_TOO_LARGE:\n        case HTTP_BAD_REQUEST:\n        case HTTP_VERSION_NOT_SUPPORTED:\n        case HTTP_NOT_IMPLEMENTED:\n            if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00565)\n                              \"request failed: client's request-line exceeds LimitRequestLine (longer than %d)\",\n                              r->server->limit_req_line);\n            }\n            else if (r->method == NULL) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00566)\n                              \"request failed: malformed request line\");\n            }\n            access_status = r->status;\n            goto die_early;\n\n        case HTTP_REQUEST_TIME_OUT:\n            /* Just log, no further action on this connection. */\n            ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, NULL);\n            if (!r->connection->keepalives)\n                ap_run_log_transaction(r);\n            break;\n        }\n        /* Not worth dying with. */\n        conn->keepalive = AP_CONN_CLOSE;\n        apr_pool_destroy(r->pool);\n        goto ignore;\n    }\n    apr_brigade_cleanup(tmp_bb);\n\n    /* We may have been in keep_alive_timeout mode, so toggle back\n     * to the normal timeout mode as we fetch the header lines,\n     * as necessary.\n     */\n    csd = ap_get_conn_socket(conn);\n    apr_socket_timeout_get(csd, &cur_timeout);\n    if (cur_timeout != conn->base_server->timeout) {\n        apr_socket_timeout_set(csd, conn->base_server->timeout);\n        cur_timeout = conn->base_server->timeout;\n    }\n\n    if (!r->assbackwards) {\n        const char *tenc;\n\n        ap_get_mime_headers_core(r, tmp_bb);\n        apr_brigade_cleanup(tmp_bb);\n        if (r->status != HTTP_OK) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00567)\n                          \"request failed: error reading the headers\");\n            access_status = r->status;\n            goto die_early;\n        }\n\n        tenc = apr_table_get(r->headers_in, \"Transfer-Encoding\");\n        if (tenc) {\n            /* http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-23\n             * Section 3.3.3.3: \"If a Transfer-Encoding header field is\n             * present in a request and the chunked transfer coding is not\n             * the final encoding ...; the server MUST respond with the 400\n             * (Bad Request) status code and then close the connection\".\n             */\n            if (!ap_is_chunked(r->pool, tenc)) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02539)\n                              \"client sent unknown Transfer-Encoding \"\n                              \"(%s): %s\", tenc, r->uri);\n                access_status = HTTP_BAD_REQUEST;\n                goto die_early;\n            }\n\n            /* http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-23\n             * Section 3.3.3.3: \"If a message is received with both a\n             * Transfer-Encoding and a Content-Length header field, the\n             * Transfer-Encoding overrides the Content-Length. ... A sender\n             * MUST remove the received Content-Length field\".\n             */\n            apr_table_unset(r->headers_in, \"Content-Length\");\n        }\n    }\n\n    /* update what we think the virtual host is based on the headers we've\n     * now read. may update status.\n     */\n    strict_host_check = (conf->strict_host_check == AP_CORE_CONFIG_ON);\n    access_status = ap_update_vhost_from_headers_ex(r, strict_host_check);\n    if (strict_host_check && access_status != HTTP_OK) { \n         if (r->server == ap_server_conf) { \n             ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10156)\n                           \"Requested hostname '%s' did not match any ServerName/ServerAlias \"\n                           \"in the global server configuration \", r->hostname);\n         } else { \n             ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10157)\n                           \"Requested hostname '%s' did not match any ServerName/ServerAlias \"\n                           \"in the matching virtual host (default vhost for \"\n                           \"current connection is %s:%u)\", \n                           r->hostname, r->server->defn_name, r->server->defn_line_number);\n         }\n         goto die_early;\n    }\n    if (r->status != HTTP_OK) { \n        access_status = r->status;\n        goto die_early;\n    }\n\n    if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1, 1)))\n        || ((r->proto_num == HTTP_VERSION(1, 1))\n            && !apr_table_get(r->headers_in, \"Host\"))) {\n        /*\n         * Client sent us an HTTP/1.1 or later request without telling us the\n         * hostname, either with a full URL or a Host: header. We therefore\n         * need to (as per the 1.1 spec) send an error.  As a special case,\n         * HTTP/1.1 mentions twice (S9, S14.23) that a request MUST contain\n         * a Host: header, and the server MUST respond with 400 if it doesn't.\n         */\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00569)\n                      \"client sent HTTP/1.1 request without hostname \"\n                      \"(see RFC2616 section 14.23): %s\", r->uri);\n        access_status = HTTP_BAD_REQUEST;\n        goto die_early;\n    }\n\n    /* we may have switched to another server */\n    r->per_dir_config = r->server->lookup_defaults;\n    conf = ap_get_core_module_config(r->server->module_config);\n\n    /* Toggle to the Host:-based vhost's timeout mode to fetch the\n     * request body and send the response body, if needed.\n     */\n    if (cur_timeout != r->server->timeout) {\n        apr_socket_timeout_set(csd, r->server->timeout);\n        cur_timeout = r->server->timeout;\n    }\n\n    /*\n     * Add the HTTP_IN filter here to ensure that ap_discard_request_body\n     * called by ap_die and by ap_send_error_response works correctly on\n     * status codes that do not cause the connection to be dropped and\n     * in situations where the connection should be kept alive.\n     */\n    ap_add_input_filter_handle(ap_http_input_filter_handle,\n                               NULL, r, r->connection);\n\n    if ((access_status = ap_run_post_read_request(r))) {\n        goto die;\n    }\n\n    if (((expect = apr_table_get(r->headers_in, \"Expect\")) != NULL)\n        && (expect[0] != '\\0')) {\n        /*\n         * The Expect header field was added to HTTP/1.1 after RFC 2068\n         * as a means to signal when a 100 response is desired and,\n         * unfortunately, to signal a poor man's mandatory extension that\n         * the server must understand or return 417 Expectation Failed.\n         */\n        if (ap_cstr_casecmp(expect, \"100-continue\") == 0) {\n            r->expecting_100 = 1;\n        }\n        else {\n            if (conf->http_expect_strict != AP_HTTP_EXPECT_STRICT_DISABLE) {\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00570)\n                              \"client sent an unrecognized expectation value \"\n                              \"of Expect: %s\", expect);\n                access_status = HTTP_EXPECTATION_FAILED;\n                goto die;\n            }\n            else {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02595)\n                              \"client sent an unrecognized expectation value \"\n                              \"of Expect (not fatal): %s\", expect);\n            }\n        }\n    }\n\n    AP_READ_REQUEST_SUCCESS((uintptr_t)r, (char *)r->method,\n                            (char *)r->uri, (char *)r->server->defn_name,\n                            r->status);\n    return r;\n\ndie_early:\n    /* Input filters are in an undeterminate state, cleanup (including\n     * CORE_IN's socket) such that any further attempt to read is EOF.\n     */\n    {\n        ap_filter_t *f = conn->input_filters;\n        while (f) {\n            ap_filter_reinstate_brigade(f, tmp_bb, NULL);\n            apr_brigade_cleanup(tmp_bb);\n            if (f->frec == ap_core_input_filter_handle) {\n                break;\n            }\n            ap_remove_input_filter(f);\n            f = f->next;\n        }\n        conn->input_filters = r->input_filters = f;\n        conn->keepalive = AP_CONN_CLOSE;\n    }\n\n    /* fallthru ap_die() (non recursive) */\n    r->status = HTTP_OK;\ndie:\n    ap_die(access_status, r);\n\n    /* ap_die() sent the response through the output filters, we must now\n     * end the request with an EOR bucket for stream/pipeline accounting.\n     */\n    tmp_bb = ap_acquire_brigade(conn);\n    APR_BRIGADE_INSERT_TAIL(tmp_bb,\n                            ap_bucket_eor_create(conn->bucket_alloc, r));\n    ap_pass_brigade(conn->output_filters, tmp_bb);\n    ap_release_brigade(conn, tmp_bb);\n\n    /* fallthru */\nignore:\n    r = NULL;\n    AP_READ_REQUEST_FAILURE((uintptr_t)r);\n    return NULL;\n}", "target": 0}
{"idx": 4891, "func": "static double clean_mean(double *values, int count)\n{\n    double mean = 0;\n    int cut = count / 5;\n    int x;\n\n    qsort(values, count, sizeof(double), (void*)cmp);\n\n    for (x = cut; x < count - cut; x++) {\n        mean += values[x];\n    }\n\n    return mean / (count - cut * 2);\n}", "target": 1}
{"idx": 4892, "func": "static void draw_bar(TestSourceContext *test, const uint8_t color[4],\n                     unsigned x, unsigned y, unsigned w, unsigned h,\n                     AVFrame *frame)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n    uint8_t *p, *p0;\n    int plane;\n\n    x = FFMIN(x, test->w - 1);\n    y = FFMIN(y, test->h - 1);\n    w = FFMIN(w, test->w - x);\n    h = FFMIN(h, test->h - y);\n\n    av_assert0(x + w <= test->w);\n    av_assert0(y + h <= test->h);\n\n    for (plane = 0; frame->data[plane]; plane++) {\n        const int c = color[plane];\n        const int linesize = frame->linesize[plane];\n        int i, px, py, pw, ph;\n\n        if (plane == 1 || plane == 2) {\n            px = x >> desc->log2_chroma_w;\n            pw = w >> desc->log2_chroma_w;\n            py = y >> desc->log2_chroma_h;\n            ph = h >> desc->log2_chroma_h;\n        } else {\n            px = x;\n            pw = w;\n            py = y;\n            ph = h;\n        }\n\n        p0 = p = frame->data[plane] + py * linesize + px;\n        memset(p, c, pw);\n        p += linesize;\n        for (i = 1; i < ph; i++, p += linesize)\n            memcpy(p, p0, pw);\n    }\n}", "target": 1}
{"idx": 4893, "func": "static apr_status_t event_register_socket_callback_ex(apr_socket_t **s, \n                                                  apr_pool_t *p, \n                                                  int for_read,\n                                                  ap_mpm_callback_fn_t *cbfn,\n                                                  ap_mpm_callback_fn_t *tofn,\n                                                  void *baton, \n                                                  apr_time_t timeout)\n{\n    apr_status_t rc, final_rc= APR_SUCCESS;\n    int i = 0, nsock;\n    socket_callback_baton_t *scb = apr_pcalloc(p, sizeof(*scb));\n    listener_poll_type *pt = apr_palloc(p, sizeof(*pt));\n    apr_pollfd_t **pfds = NULL;\n\n    while(s[i] != NULL) { \n        i++; \n    }\n    nsock = i;\n\n    pfds = apr_pcalloc(p, (nsock+1) * sizeof(apr_pollfd_t*));\n\n    pt->type = PT_USER;\n    pt->baton = scb;\n\n    scb->cbfunc = cbfn;\n    scb->user_baton = baton;\n    scb->nsock = nsock;\n    scb->pfds = pfds;\n\n    for (i = 0; i<nsock; i++) { \n        pfds[i] = apr_pcalloc(p, sizeof(apr_pollfd_t));\n        pfds[i]->desc_type = APR_POLL_SOCKET;\n        pfds[i]->reqevents = (for_read ? APR_POLLIN : APR_POLLOUT) | APR_POLLERR | APR_POLLHUP;\n        pfds[i]->desc.s = s[i];\n        pfds[i]->p = p;\n        pfds[i]->client_data = pt;\n    }\n\n    if (timeout > 0) { \n        /* XXX:  This cancel timer event count fire before the pollset is updated */\n        scb->cancel_event = event_get_timer_event(timeout + apr_time_now(), tofn, baton, 1, pfds);\n    }\n    for (i = 0; i<nsock; i++) { \n        rc = apr_pollset_add(event_pollset, pfds[i]);\n        if (rc != APR_SUCCESS) final_rc = rc;\n    }\n    return final_rc;\n}", "target": 0}
{"idx": 4894, "func": "AVFilterBufferRef *avfilter_default_get_audio_buffer(AVFilterLink *link, int perms,\n                                                     int nb_samples)\n{\n    AVFilterBufferRef *samplesref = NULL;\n    int linesize[8] = {0};\n    uint8_t *data[8] = {0};\n    int ch, nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);\n\n    /* right now we don't support more than 8 channels */\n    av_assert0(nb_channels <= 8);\n\n    /* Calculate total buffer size, round to multiple of 16 to be SIMD friendly */\n    if (av_samples_alloc(data, linesize,\n                         nb_channels, nb_samples,\n                         av_get_alt_sample_fmt(link->format, link->planar),\n                         16) < 0)\n        return NULL;\n\n    for (ch = 1; link->planar && ch < nb_channels; ch++)\n        linesize[ch] = linesize[0];\n    samplesref =\n        avfilter_get_audio_buffer_ref_from_arrays(data, linesize, perms,\n                                                  nb_samples, link->format,\n                                                  link->channel_layout, link->planar);\n    if (!samplesref) {\n        av_free(data[0]);\n        return NULL;\n    }\n\n    return samplesref;\n}", "target": 0}
{"idx": 4895, "func": "static int handle_packet(MpegTSContext *ts, const uint8_t *packet)\n{\n    AVFormatContext *s = ts->stream;\n    MpegTSFilter *tss;\n    int len, pid, cc, expected_cc, cc_ok, afc, is_start, is_discontinuity,\n        has_adaptation, has_payload;\n    const uint8_t *p, *p_end;\n    int64_t pos;\n\n    pid = AV_RB16(packet + 1) & 0x1fff;\n    if(pid && discard_pid(ts, pid))\n        return 0;\n    is_start = packet[1] & 0x40;\n    tss = ts->pids[pid];\n    if (ts->auto_guess && tss == NULL && is_start) {\n        add_pes_stream(ts, pid, -1);\n        tss = ts->pids[pid];\n    }\n    if (!tss)\n        return 0;\n\n    afc = (packet[3] >> 4) & 3;\n    if (afc == 0) /* reserved value */\n        return 0;\n    has_adaptation = afc & 2;\n    has_payload = afc & 1;\n    is_discontinuity = has_adaptation\n                && packet[4] != 0 /* with length > 0 */\n                && (packet[5] & 0x80); /* and discontinuity indicated */\n\n    /* continuity check (currently not used) */\n    cc = (packet[3] & 0xf);\n    expected_cc = has_payload ? (tss->last_cc + 1) & 0x0f : tss->last_cc;\n    cc_ok = pid == 0x1FFF // null packet PID\n            || is_discontinuity\n            || tss->last_cc < 0\n            || expected_cc == cc;\n\n    tss->last_cc = cc;\n    if (!cc_ok) {\n        av_log(ts, AV_LOG_WARNING, \"Continuity Check Failed\\n\");\n        if(tss->type == MPEGTS_PES) {\n            PESContext *pc = tss->u.pes_filter.opaque;\n            pc->flags |= AV_PKT_FLAG_CORRUPT;\n        }\n    }\n\n    if (!has_payload)\n        return 0;\n    p = packet + 4;\n    if (has_adaptation) {\n        /* skip adapation field */\n        p += p[0] + 1;\n    }\n    /* if past the end of packet, ignore */\n    p_end = packet + TS_PACKET_SIZE;\n    if (p >= p_end)\n        return 0;\n\n    pos = avio_tell(ts->stream->pb);\n    ts->pos47= pos % ts->raw_packet_size;\n\n    if (tss->type == MPEGTS_SECTION) {\n        if (is_start) {\n            /* pointer field present */\n            len = *p++;\n            if (p + len > p_end)\n                return 0;\n            if (len && cc_ok) {\n                /* write remaining section bytes */\n                write_section_data(s, tss,\n                                   p, len, 0);\n                /* check whether filter has been closed */\n                if (!ts->pids[pid])\n                    return 0;\n            }\n            p += len;\n            if (p < p_end) {\n                write_section_data(s, tss,\n                                   p, p_end - p, 1);\n            }\n        } else {\n            if (cc_ok) {\n                write_section_data(s, tss,\n                                   p, p_end - p, 0);\n            }\n        }\n    } else {\n        int ret;\n        // Note: The position here points actually behind the current packet.\n        if ((ret = tss->u.pes_filter.pes_cb(tss, p, p_end - p, is_start,\n                                            pos - ts->raw_packet_size)) < 0)\n            return ret;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 4896, "func": "int ssl3_new(SSL *s)\n{\n    SSL3_STATE *s3;\n\n    if ((s3 = OPENSSL_malloc(sizeof *s3)) == NULL)\n        goto err;\n    memset(s3, 0, sizeof *s3);\n    memset(s3->rrec.seq_num, 0, sizeof(s3->rrec.seq_num));\n    memset(s3->wrec.seq_num, 0, sizeof(s3->wrec.seq_num));\n\n    s->s3 = s3;\n\n#ifndef OPENSSL_NO_SRP\n    SSL_SRP_CTX_init(s);\n#endif\n    s->method->ssl_clear(s);\n    return (1);\n err:\n    return (0);\n}", "target": 1}
{"idx": 4897, "func": "static int dnxhd_decode_header(DNXHDContext *ctx, const uint8_t *buf, int buf_size, int first_field)\n{\n    static const uint8_t header_prefix[] = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n    int i, cid;\n\n    if (buf_size < 0x280)\n        return -1;\n\n    if (memcmp(buf, header_prefix, 5)) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"error in header\\n\");\n        return -1;\n    }\n    if (buf[5] & 2) { /* interlaced */\n        ctx->cur_field = buf[5] & 1;\n        ctx->picture.interlaced_frame = 1;\n        ctx->picture.top_field_first = first_field ^ ctx->cur_field;\n        av_log(ctx->avctx, AV_LOG_DEBUG, \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n    }\n\n    ctx->height = AV_RB16(buf + 0x18);\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n    av_dlog(ctx->avctx, \"width %d, height %d\\n\", ctx->width, ctx->height);\n\n    if (buf[0x21] & 0x40) {\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n        ctx->avctx->bits_per_raw_sample = 10;\n        if (ctx->bit_depth != 10) {\n            ff_dsputil_init(&ctx->dsp, ctx->avctx);\n            ctx->bit_depth = 10;\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n        }\n    } else {\n        ctx->avctx->pix_fmt = AV_PIX_FMT_YUV422P;\n        ctx->avctx->bits_per_raw_sample = 8;\n        if (ctx->bit_depth != 8) {\n            ff_dsputil_init(&ctx->dsp, ctx->avctx);\n            ctx->bit_depth = 8;\n            ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n        }\n    }\n\n    cid = AV_RB32(buf + 0x28);\n    av_dlog(ctx->avctx, \"compression id %d\\n\", cid);\n\n    if (dnxhd_init_vlc(ctx, cid) < 0)\n        return -1;\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size\\n\");\n        return -1;\n    }\n\n    ctx->mb_width = ctx->width>>4;\n    ctx->mb_height = buf[0x16d];\n\n    av_dlog(ctx->avctx, \"mb width %d, mb height %d\\n\", ctx->mb_width, ctx->mb_height);\n\n    if ((ctx->height+15)>>4 == ctx->mb_height && ctx->picture.interlaced_frame)\n        ctx->height <<= 1;\n\n    if (ctx->mb_height > 68 ||\n        (ctx->mb_height<<ctx->picture.interlaced_frame) > (ctx->height+15)>>4) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"mb height too big: %d\\n\", ctx->mb_height);\n        return -1;\n    }\n\n    for (i = 0; i < ctx->mb_height; i++) {\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i<<2));\n        av_dlog(ctx->avctx, \"mb scan index %d\\n\", ctx->mb_scan_index[i]);\n        if (buf_size < ctx->mb_scan_index[i] + 0x280LL) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"invalid mb scan index\\n\");\n            return -1;\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 4898, "func": "static int cinaudio_decode_frame(AVCodecContext *avctx,\n                                 void *data, int *data_size,\n                                 AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    CinAudioContext *cin = avctx->priv_data;\n    const uint8_t *src = buf;\n    int16_t *samples = data;\n    int delta;\n\n    buf_size = FFMIN(buf_size, *data_size/2);\n\n    delta = cin->delta;\n    if (cin->initial_decode_frame) {\n        cin->initial_decode_frame = 0;\n        delta = (int16_t)AV_RL16(src); src += 2;\n        *samples++ = delta;\n        buf_size -= 2;\n    }\n    while (buf_size > 0) {\n        delta += cinaudio_delta16_table[*src++];\n        delta = av_clip_int16(delta);\n        *samples++ = delta;\n        --buf_size;\n    }\n    cin->delta = delta;\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n}", "target": 1}
{"idx": 4899, "func": "const char *DES_options(void)\n{\n    static int init = 1;\n    static char buf[32];\n\n    if (init) {\n        const char *size;\n\n        if (sizeof(DES_LONG) != sizeof(long))\n            size = \"int\";\n        else\n            size = \"long\";\n        sprintf(buf, \"des(%s)\", size);\n        init = 0;\n    }\n    return (buf);\n}", "target": 0}
{"idx": 4900, "func": "static int dnxhd_encode_rdo(AVCodecContext *avctx, DNXHDEncContext *ctx)\n{\n    int lambda, up_step, down_step;\n    int last_lower = INT_MAX, last_higher = 0;\n    int x, y, q;\n\n    for (q = 1; q < avctx->qmax; q++) {\n        ctx->qscale = q;\n        avctx->execute2(avctx, dnxhd_calc_bits_thread, NULL, NULL, ctx->m.mb_height);\n    }\n    up_step = down_step = 2<<LAMBDA_FRAC_BITS;\n    lambda = ctx->lambda;\n\n    for (;;) {\n        int bits = 0;\n        int end = 0;\n        if (lambda == last_higher) {\n            lambda++;\n            end = 1; // need to set final qscales/bits\n        }\n        for (y = 0; y < ctx->m.mb_height; y++) {\n            for (x = 0; x < ctx->m.mb_width; x++) {\n                unsigned min = UINT_MAX;\n                int qscale = 1;\n                int mb = y*ctx->m.mb_width+x;\n                for (q = 1; q < avctx->qmax; q++) {\n                    unsigned score = ctx->mb_rc[q][mb].bits*lambda+(ctx->mb_rc[q][mb].ssd<<LAMBDA_FRAC_BITS);\n                    if (score < min) {\n                        min = score;\n                        qscale = q;\n                    }\n                }\n                bits += ctx->mb_rc[qscale][mb].bits;\n                ctx->mb_qscale[mb] = qscale;\n                ctx->mb_bits[mb] = ctx->mb_rc[qscale][mb].bits;\n            }\n            bits = (bits+31)&~31; // padding\n            if (bits > ctx->frame_bits)\n                break;\n        }\n        //av_dlog(ctx->m.avctx, \"lambda %d, up %u, down %u, bits %d, frame %d\\n\",\n        //        lambda, last_higher, last_lower, bits, ctx->frame_bits);\n        if (end) {\n            if (bits > ctx->frame_bits)\n                return -1;\n            break;\n        }\n        if (bits < ctx->frame_bits) {\n            last_lower = FFMIN(lambda, last_lower);\n            if (last_higher != 0)\n                lambda = (lambda+last_higher)>>1;\n            else\n                lambda -= down_step;\n            down_step *= 5; // XXX tune ?\n            up_step = 1<<LAMBDA_FRAC_BITS;\n            lambda = FFMAX(1, lambda);\n            if (lambda == last_lower)\n                break;\n        } else {\n            last_higher = FFMAX(lambda, last_higher);\n            if (last_lower != INT_MAX)\n                lambda = (lambda+last_lower)>>1;\n            else if ((int64_t)lambda + up_step > INT_MAX)\n                return -1;\n            else\n                lambda += up_step;\n            up_step = FFMIN((int64_t)up_step*5, INT_MAX);\n            down_step = 1<<LAMBDA_FRAC_BITS;\n        }\n    }\n    //av_dlog(ctx->m.avctx, \"out lambda %d\\n\", lambda);\n    ctx->lambda = lambda;\n    return 0;\n}", "target": 1}
{"idx": 4901, "func": "static int mov_write_single_packet(AVFormatContext *s, AVPacket *pkt)\n{\n        MOVMuxContext *mov = s->priv_data;\n        MOVTrack *trk = &mov->tracks[pkt->stream_index];\n        AVCodecParameters *par = trk->par;\n        int64_t frag_duration = 0;\n        int size = pkt->size;\n\n        int ret = check_pkt(s, pkt);\n        if (ret < 0)\n            return ret;\n\n        if (mov->flags & FF_MOV_FLAG_FRAG_DISCONT) {\n            int i;\n            for (i = 0; i < s->nb_streams; i++)\n                mov->tracks[i].frag_discont = 1;\n            mov->flags &= ~FF_MOV_FLAG_FRAG_DISCONT;\n        }\n\n        if (!pkt->size) {\n            if (trk->start_dts == AV_NOPTS_VALUE && trk->frag_discont) {\n                trk->start_dts = pkt->dts;\n                if (pkt->pts != AV_NOPTS_VALUE)\n                    trk->start_cts = pkt->pts - pkt->dts;\n                else\n                    trk->start_cts = 0;\n            }\n\n            if (trk->par->codec_id == AV_CODEC_ID_MP4ALS) {\n                int side_size = 0;\n                uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);\n                if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {\n                    void *newextra = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);\n                    if (!newextra)\n                        return AVERROR(ENOMEM);\n                    av_free(par->extradata);\n                    par->extradata = newextra;\n                    memcpy(par->extradata, side, side_size);\n                    par->extradata_size = side_size;\n                    mov->need_rewrite_extradata = 1;\n                }\n            }\n\n            return 0;             /* Discard 0 sized packets */\n        }\n\n        if (trk->entry && pkt->stream_index < s->nb_streams)\n            frag_duration = av_rescale_q(pkt->dts - trk->cluster[0].dts,\n                                         s->streams[pkt->stream_index]->time_base,\n                                         AV_TIME_BASE_Q);\n        if ((mov->max_fragment_duration &&\n             frag_duration >= mov->max_fragment_duration) ||\n             (mov->max_fragment_size && mov->mdat_size + size >= mov->max_fragment_size) ||\n             (mov->flags & FF_MOV_FLAG_FRAG_KEYFRAME &&\n              par->codec_type == AVMEDIA_TYPE_VIDEO &&\n              trk->entry && pkt->flags & AV_PKT_FLAG_KEY)) {\n            if (frag_duration >= mov->min_fragment_duration) {\n                // Set the duration of this track to line up with the next\n                // sample in this track. This avoids relying on AVPacket\n                // duration, but only helps for this particular track, not\n                // for the other ones that are flushed at the same time.\n                trk->track_duration = pkt->dts - trk->start_dts;\n                if (pkt->pts != AV_NOPTS_VALUE)\n                    trk->end_pts = pkt->pts;\n                else\n                    trk->end_pts = pkt->dts;\n                trk->end_reliable = 1;\n                mov_auto_flush_fragment(s, 0);\n            }\n        }\n\n        return ff_mov_write_packet(s, pkt);\n}", "target": 0}
{"idx": 4902, "func": "static void\nngx_http_upstream_process_request(ngx_http_request_t *r)\n{\n    ngx_temp_file_t      *tf;\n    ngx_event_pipe_t     *p;\n    ngx_http_upstream_t  *u;\n\n    u = r->upstream;\n    p = u->pipe;\n\n    if (u->peer.connection) {\n\n        if (u->store) {\n\n            if (p->upstream_eof || p->upstream_done) {\n\n                tf = u->pipe->temp_file;\n\n                if (u->headers_in.status_n == NGX_HTTP_OK\n                    && (u->headers_in.content_length_n == -1\n                        || (u->headers_in.content_length_n == tf->offset)))\n                {\n                    ngx_http_upstream_store(r, u);\n                    u->store = 0;\n                }\n            }\n        }\n\n#if (NGX_HTTP_CACHE)\n\n        if (u->cacheable) {\n\n            if (p->upstream_done) {\n                ngx_http_file_cache_update(r, u->pipe->temp_file);\n\n            } else if (p->upstream_eof) {\n\n                tf = u->pipe->temp_file;\n\n                if (u->headers_in.content_length_n == -1\n                    || u->headers_in.content_length_n\n                       == tf->offset - (off_t) r->cache->body_start)\n                {\n                    ngx_http_file_cache_update(r, tf);\n\n                } else {\n                    ngx_http_file_cache_free(r->cache, tf);\n                }\n\n            } else if (p->upstream_error) {\n                ngx_http_file_cache_free(r->cache, u->pipe->temp_file);\n            }\n        }\n\n#endif\n\n        if (p->upstream_done || p->upstream_eof || p->upstream_error) {\n            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                           \"http upstream exit: %p\", p->out);\n#if 0\n            ngx_http_busy_unlock(u->conf->busy_lock, &u->busy_lock);\n#endif\n            ngx_http_upstream_finalize_request(r, u, 0);\n            return;\n        }\n    }\n\n    if (p->downstream_error) {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"http upstream downstream error\");\n\n        if (!u->cacheable && !u->store && u->peer.connection) {\n            ngx_http_upstream_finalize_request(r, u, 0);\n        }\n    }\n}", "target": 0}
{"idx": 4903, "func": "void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)\n{\n    if (i < 0 || i >= st->num)\n        return NULL;\n    return (void *)st->data[i];\n}", "target": 0}
{"idx": 4904, "func": "static int extract_extradata(AVStream *st, AVPacket *pkt)\n{\n    AVStreamInternal *i = st->internal;\n    AVPacket *pkt_ref;\n    int ret;\n\n    if (!i->extract_extradata.inited) {\n        ret = extract_extradata_init(st);\n        if (ret < 0)\n            return ret;\n    }\n\n    if (i->extract_extradata.inited && !i->extract_extradata.bsf)\n        return 0;\n\n    pkt_ref = i->extract_extradata.pkt;\n    ret = av_packet_ref(pkt_ref, pkt);\n    if (ret < 0)\n        return ret;\n\n    ret = av_bsf_send_packet(i->extract_extradata.bsf, pkt_ref);\n    if (ret < 0) {\n        av_packet_unref(pkt_ref);\n        return ret;\n    }\n\n    while (ret >= 0 && !i->avctx->extradata) {\n        int extradata_size;\n        uint8_t *extradata;\n\n        ret = av_bsf_receive_packet(i->extract_extradata.bsf, pkt_ref);\n        if (ret < 0) {\n            if (ret != AVERROR(EAGAIN) && ret != AVERROR_EOF)\n                return ret;\n            continue;\n        }\n\n        extradata = av_packet_get_side_data(pkt_ref, AV_PKT_DATA_NEW_EXTRADATA,\n                                            &extradata_size);\n\n        if (extradata) {\n            i->avctx->extradata = av_mallocz(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!i->avctx->extradata) {\n                av_packet_unref(pkt_ref);\n                return AVERROR(ENOMEM);\n            }\n            memcpy(i->avctx->extradata, extradata, extradata_size);\n            i->avctx->extradata_size = extradata_size;\n        }\n        av_packet_unref(pkt_ref);\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 4905, "func": "void *av_fast_realloc(void *ptr, unsigned int *size, unsigned int min_size)\n{\n    if(min_size < *size)\n        return ptr;\n\n    *size= FFMAX(17*min_size/16 + 32, min_size);\n\n    ptr= av_realloc(ptr, *size);\n    if(!ptr) //we could set this to the unmodified min_size but this is safer if the user lost the ptr and uses NULL now\n        *size= 0;\n\n    return ptr;\n}", "target": 1}
{"idx": 4906, "func": "static int ffm_seek(AVFormatContext *s, int stream_index, int64_t wanted_pts, int flags)\n{\n    FFMContext *ffm = s->priv_data;\n    int64_t pos_min, pos_max, pos;\n    int64_t pts_min, pts_max, pts;\n    double pos1;\n\n    av_dlog(s, \"wanted_pts=%0.6f\\n\", wanted_pts / 1000000.0);\n    /* find the position using linear interpolation (better than\n       dichotomy in typical cases) */\n    if (ffm->write_index && ffm->write_index < ffm->file_size) {\n        if (get_dts(s, FFM_PACKET_SIZE) < wanted_pts) {\n            pos_min = FFM_PACKET_SIZE;\n            pos_max = ffm->write_index - FFM_PACKET_SIZE;\n        } else {\n            pos_min = ffm->write_index;\n            pos_max = ffm->file_size - FFM_PACKET_SIZE;\n        }\n    } else {\n        pos_min = FFM_PACKET_SIZE;\n        pos_max = ffm->file_size - FFM_PACKET_SIZE;\n    }\n    while (pos_min <= pos_max) {\n        pts_min = get_dts(s, pos_min);\n        pts_max = get_dts(s, pos_max);\n        if (pts_min > wanted_pts || pts_max < wanted_pts) {\n            pos = pts_min > wanted_pts ? pos_min : pos_max;\n            goto found;\n        }\n        /* linear interpolation */\n        pos1 = (double)(pos_max - pos_min) * (double)(wanted_pts - pts_min) /\n            (double)(pts_max - pts_min);\n        pos = (((int64_t)pos1) / FFM_PACKET_SIZE) * FFM_PACKET_SIZE;\n        if (pos <= pos_min)\n            pos = pos_min;\n        else if (pos >= pos_max)\n            pos = pos_max;\n        pts = get_dts(s, pos);\n        /* check if we are lucky */\n        if (pts == wanted_pts) {\n            goto found;\n        } else if (pts > wanted_pts) {\n            pos_max = pos - FFM_PACKET_SIZE;\n        } else {\n            pos_min = pos + FFM_PACKET_SIZE;\n        }\n    }\n    pos = (flags & AVSEEK_FLAG_BACKWARD) ? pos_min : pos_max;\n\n found:\n    if (ffm_seek1(s, pos) < 0)\n        return -1;\n\n    /* reset read state */\n    ffm->read_state = READ_HEADER;\n    ffm->packet_ptr = ffm->packet;\n    ffm->packet_end = ffm->packet;\n    ffm->first_packet = 1;\n\n    return 0;\n}", "target": 1}
{"idx": 4907, "func": "static void\nngx_resolver_resolve_srv_names(ngx_resolver_ctx_t *ctx, ngx_resolver_node_t *rn)\n{\n    ngx_uint_t                i;\n    ngx_resolver_t           *r;\n    ngx_resolver_ctx_t       *cctx;\n    ngx_resolver_srv_name_t  *srvs;\n\n    r = ctx->resolver;\n\n    ctx->node = NULL;\n    ctx->state = NGX_OK;\n    ctx->valid = rn->valid;\n    ctx->count = rn->nsrvs;\n\n    srvs = ngx_resolver_calloc(r, rn->nsrvs * sizeof(ngx_resolver_srv_name_t));\n    if (srvs == NULL) {\n        goto failed;\n    }\n\n    ctx->srvs = srvs;\n    ctx->nsrvs = rn->nsrvs;\n\n    for (i = 0; i < rn->nsrvs; i++) {\n        srvs[i].name.data = ngx_resolver_alloc(r, rn->u.srvs[i].name.len);\n        if (srvs[i].name.data == NULL) {\n            goto failed;\n        }\n\n        srvs[i].name.len = rn->u.srvs[i].name.len;\n        ngx_memcpy(srvs[i].name.data, rn->u.srvs[i].name.data,\n                   srvs[i].name.len);\n\n        cctx = ngx_resolve_start(r, NULL);\n        if (cctx == NULL) {\n            goto failed;\n        }\n\n        cctx->name = srvs[i].name;\n        cctx->handler = ngx_resolver_srv_names_handler;\n        cctx->data = ctx;\n        cctx->srvs = &srvs[i];\n        cctx->timeout = 0;\n\n        srvs[i].priority = rn->u.srvs[i].priority;\n        srvs[i].weight = rn->u.srvs[i].weight;\n        srvs[i].port = rn->u.srvs[i].port;\n        srvs[i].ctx = cctx;\n\n        if (ngx_resolve_name(cctx) == NGX_ERROR) {\n            srvs[i].ctx = NULL;\n            goto failed;\n        }\n    }\n\n    return;\n\nfailed:\n\n    ctx->state = NGX_ERROR;\n    ctx->valid = ngx_time() + (r->valid ? r->valid : 10);\n\n    ctx->handler(ctx);\n}", "target": 1}
{"idx": 4908, "func": "int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,\n           BN_CTX *ctx)\n{\n    int ret;\n\n    if (BN_is_zero(divisor)) {\n        BNerr(BN_F_BN_DIV, BN_R_DIV_BY_ZERO);\n        return 0;\n    }\n\n    /*\n     * Invalid zero-padding would have particularly bad consequences so don't\n     * just rely on bn_check_top() here (bn_check_top() works only for\n     * BN_DEBUG builds)\n     */\n    if (divisor->d[divisor->top - 1] == 0) {\n        BNerr(BN_F_BN_DIV, BN_R_NOT_INITIALIZED);\n        return 0;\n    }\n\n    ret = bn_div_fixed_top(dv, rm, num, divisor, ctx);\n\n    if (ret) {\n        if (dv != NULL)\n            bn_correct_top(dv);\n        if (rm != NULL)\n            bn_correct_top(rm);\n    }\n\n    return ret;\n}", "target": 0}
{"idx": 4909, "func": "int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,\n\t   BN_CTX *ctx)\n\t{\n\tint norm_shift,i,loop;\n\tBIGNUM *tmp,wnum,*snum,*sdiv,*res;\n\tBN_ULONG *resp,*wnump;\n\tBN_ULONG d0,d1;\n\tint num_n,div_n;\n\tint no_branch=0;\n\n\t/* Invalid zero-padding would have particularly bad consequences\n\t * in the case of 'num', so don't just rely on bn_check_top() for this one\n\t * (bn_check_top() works only for BN_DEBUG builds) */\n\tif (num->top > 0 && num->d[num->top - 1] == 0)\n\t\t{\n\t\tBNerr(BN_F_BN_DIV,BN_R_NOT_INITIALIZED);\n\t\treturn 0;\n\t\t}\n\n\tbn_check_top(num);\n\n\tif ((BN_get_flags(num, BN_FLG_CONSTTIME) != 0) || (BN_get_flags(divisor, BN_FLG_CONSTTIME) != 0))\n\t\t{\n\t\tno_branch=1;\n\t\t}\n\n\tbn_check_top(dv);\n\tbn_check_top(rm);\n\t/* bn_check_top(num); */ /* 'num' has been checked already */\n\tbn_check_top(divisor);\n\n\tif (BN_is_zero(divisor))\n\t\t{\n\t\tBNerr(BN_F_BN_DIV,BN_R_DIV_BY_ZERO);\n\t\treturn(0);\n\t\t}\n\n\tif (!no_branch && BN_ucmp(num,divisor) < 0)\n\t\t{\n\t\tif (rm != NULL)\n\t\t\t{ if (BN_copy(rm,num) == NULL) return(0); }\n\t\tif (dv != NULL) BN_zero(dv);\n\t\treturn(1);\n\t\t}\n\n\tBN_CTX_start(ctx);\n\ttmp=BN_CTX_get(ctx);\n\tsnum=BN_CTX_get(ctx);\n\tsdiv=BN_CTX_get(ctx);\n\tif (dv == NULL)\n\t\tres=BN_CTX_get(ctx);\n\telse\tres=dv;\n\tif (sdiv == NULL || res == NULL || tmp == NULL || snum == NULL)\n\t\tgoto err;\n\n\t/* First we normalise the numbers */\n\tnorm_shift=BN_BITS2-((BN_num_bits(divisor))%BN_BITS2);\n\tif (!(BN_lshift(sdiv,divisor,norm_shift))) goto err;\n\tsdiv->neg=0;\n\tnorm_shift+=BN_BITS2;\n\tif (!(BN_lshift(snum,num,norm_shift))) goto err;\n\tsnum->neg=0;\n\n\tif (no_branch)\n\t\t{\n\t\t/* Since we don't know whether snum is larger than sdiv,\n\t\t * we pad snum with enough zeroes without changing its\n\t\t * value. \n\t\t */\n\t\tif (snum->top <= sdiv->top+1) \n\t\t\t{\n\t\t\tif (bn_wexpand(snum, sdiv->top + 2) == NULL) goto err;\n\t\t\tfor (i = snum->top; i < sdiv->top + 2; i++) snum->d[i] = 0;\n\t\t\tsnum->top = sdiv->top + 2;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif (bn_wexpand(snum, snum->top + 1) == NULL) goto err;\n\t\t\tsnum->d[snum->top] = 0;\n\t\t\tsnum->top ++;\n\t\t\t}\n\t\t}\n\n\tdiv_n=sdiv->top;\n\tnum_n=snum->top;\n\tloop=num_n-div_n;\n\t/* Lets setup a 'window' into snum\n\t * This is the part that corresponds to the current\n\t * 'area' being divided */\n\twnum.neg   = 0;\n\twnum.d     = &(snum->d[loop]);\n\twnum.top   = div_n;\n\t/* only needed when BN_ucmp messes up the values between top and max */\n\twnum.dmax  = snum->dmax - loop; /* so we don't step out of bounds */\n\n\t/* Get the top 2 words of sdiv */\n\t/* div_n=sdiv->top; */\n\td0=sdiv->d[div_n-1];\n\td1=(div_n == 1)?0:sdiv->d[div_n-2];\n\n\t/* pointer to the 'top' of snum */\n\twnump= &(snum->d[num_n-1]);\n\n\t/* Setup to 'res' */\n\tres->neg= (num->neg^divisor->neg);\n\tif (!bn_wexpand(res,(loop+1))) goto err;\n\tres->top=loop-no_branch;\n\tresp= &(res->d[loop-1]);\n\n\t/* space for temp */\n\tif (!bn_wexpand(tmp,(div_n+1))) goto err;\n\n\tif (!no_branch)\n\t\t{\n\t\tif (BN_ucmp(&wnum,sdiv) >= 0)\n\t\t\t{\n\t\t\t/* If BN_DEBUG_RAND is defined BN_ucmp changes (via\n\t\t\t * bn_pollute) the const bignum arguments =>\n\t\t\t * clean the values between top and max again */\n\t\t\tbn_clear_top2max(&wnum);\n\t\t\tbn_sub_words(wnum.d, wnum.d, sdiv->d, div_n);\n\t\t\t*resp=1;\n\t\t\t}\n\t\telse\n\t\t\tres->top--;\n\t\t}\n\n\t/* if res->top == 0 then clear the neg value otherwise decrease\n\t * the resp pointer */\n\tif (res->top == 0)\n\t\tres->neg = 0;\n\telse\n\t\tresp--;\n\n\tfor (i=0; i<loop-1; i++, wnump--, resp--)\n\t\t{\n\t\tBN_ULONG q,l0;\n\t\t/* the first part of the loop uses the top two words of\n\t\t * snum and sdiv to calculate a BN_ULONG q such that\n\t\t * | wnum - sdiv * q | < sdiv */\n#if defined(BN_DIV3W) && !defined(OPENSSL_NO_ASM)\n\t\tBN_ULONG bn_div_3_words(BN_ULONG*,BN_ULONG,BN_ULONG);\n\t\tq=bn_div_3_words(wnump,d1,d0);\n#else\n\t\tBN_ULONG n0,n1,rem=0;\n\n\t\tn0=wnump[0];\n\t\tn1=wnump[-1];\n\t\tif (n0 == d0)\n\t\t\tq=BN_MASK2;\n\t\telse \t\t\t/* n0 < d0 */\n\t\t\t{\n#ifdef BN_LLONG\n\t\t\tBN_ULLONG t2;\n\n#if defined(BN_LLONG) && defined(BN_DIV2W) && !defined(bn_div_words)\n\t\t\tq=(BN_ULONG)(((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0);\n#else\n\t\t\tq=bn_div_words(n0,n1,d0);\n#ifdef BN_DEBUG_LEVITTE\n\t\t\tfprintf(stderr,\"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\\\nX) -> 0x%08X\\n\",\n\t\t\t\tn0, n1, d0, q);\n#endif\n#endif\n\n#ifndef REMAINDER_IS_ALREADY_CALCULATED\n\t\t\t/*\n\t\t\t * rem doesn't have to be BN_ULLONG. The least we\n\t\t\t * know it's less that d0, isn't it?\n\t\t\t */\n\t\t\trem=(n1-q*d0)&BN_MASK2;\n#endif\n\t\t\tt2=(BN_ULLONG)d1*q;\n\n\t\t\tfor (;;)\n\t\t\t\t{\n\t\t\t\tif (t2 <= ((((BN_ULLONG)rem)<<BN_BITS2)|wnump[-2]))\n\t\t\t\t\tbreak;\n\t\t\t\tq--;\n\t\t\t\trem += d0;\n\t\t\t\tif (rem < d0) break; /* don't let rem overflow */\n\t\t\t\tt2 -= d1;\n\t\t\t\t}\n#else /* !BN_LLONG */\n\t\t\tBN_ULONG t2l,t2h;\n\n\t\t\tq=bn_div_words(n0,n1,d0);\n#ifdef BN_DEBUG_LEVITTE\n\t\t\tfprintf(stderr,\"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\\\nX) -> 0x%08X\\n\",\n\t\t\t\tn0, n1, d0, q);\n#endif\n#ifndef REMAINDER_IS_ALREADY_CALCULATED\n\t\t\trem=(n1-q*d0)&BN_MASK2;\n#endif\n\n#if defined(BN_UMULT_LOHI)\n\t\t\tBN_UMULT_LOHI(t2l,t2h,d1,q);\n#elif defined(BN_UMULT_HIGH)\n\t\t\tt2l = d1 * q;\n\t\t\tt2h = BN_UMULT_HIGH(d1,q);\n#else\n\t\t\t{\n\t\t\tBN_ULONG ql, qh;\n\t\t\tt2l=LBITS(d1); t2h=HBITS(d1);\n\t\t\tql =LBITS(q);  qh =HBITS(q);\n\t\t\tmul64(t2l,t2h,ql,qh); /* t2=(BN_ULLONG)d1*q; */\n\t\t\t}\n#endif\n\n\t\t\tfor (;;)\n\t\t\t\t{\n\t\t\t\tif ((t2h < rem) ||\n\t\t\t\t\t((t2h == rem) && (t2l <= wnump[-2])))\n\t\t\t\t\tbreak;\n\t\t\t\tq--;\n\t\t\t\trem += d0;\n\t\t\t\tif (rem < d0) break; /* don't let rem overflow */\n\t\t\t\tif (t2l < d1) t2h--; t2l -= d1;\n\t\t\t\t}\n#endif /* !BN_LLONG */\n\t\t\t}\n#endif /* !BN_DIV3W */\n\n\t\tl0=bn_mul_words(tmp->d,sdiv->d,div_n,q);\n\t\ttmp->d[div_n]=l0;\n\t\twnum.d--;\n\t\t/* ingore top values of the bignums just sub the two \n\t\t * BN_ULONG arrays with bn_sub_words */\n\t\tif (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n+1))\n\t\t\t{\n\t\t\t/* Note: As we have considered only the leading\n\t\t\t * two BN_ULONGs in the calculation of q, sdiv * q\n\t\t\t * might be greater than wnum (but then (q-1) * sdiv\n\t\t\t * is less or equal than wnum)\n\t\t\t */\n\t\t\tq--;\n\t\t\tif (bn_add_words(wnum.d, wnum.d, sdiv->d, div_n))\n\t\t\t\t/* we can't have an overflow here (assuming\n\t\t\t\t * that q != 0, but if q == 0 then tmp is\n\t\t\t\t * zero anyway) */\n\t\t\t\t(*wnump)++;\n\t\t\t}\n\t\t/* store part of the result */\n\t\t*resp = q;\n\t\t}\n\tbn_correct_top(snum);\n\tif (rm != NULL)\n\t\t{\n\t\t/* Keep a copy of the neg flag in num because if rm==num\n\t\t * BN_rshift() will overwrite it.\n\t\t */\n\t\tint neg = num->neg;\n\t\tBN_rshift(rm,snum,norm_shift);\n\t\tif (!BN_is_zero(rm))\n\t\t\trm->neg = neg;\n\t\tbn_check_top(rm);\n\t\t}\n\tif (no_branch)\tbn_correct_top(res);\n\tBN_CTX_end(ctx);\n\treturn(1);\nerr:\n\tbn_check_top(rm);\n\tBN_CTX_end(ctx);\n\treturn(0);\n\t}", "target": 1}
{"idx": 4910, "func": "static uint8_t *ogg_write_vorbiscomment(int offset, int bitexact,\n                                        int *header_len, AVDictionary **m, int framing_bit)\n{\n    const char *vendor = bitexact ? \"ffmpeg\" : LIBAVFORMAT_IDENT;\n    int size;\n    uint8_t *p, *p0;\n\n    ff_metadata_conv(m, ff_vorbiscomment_metadata_conv, NULL);\n\n    size = offset + ff_vorbiscomment_length(*m, vendor) + framing_bit;\n    p = av_mallocz(size);\n    if (!p)\n        return NULL;\n    p0 = p;\n\n    p += offset;\n    ff_vorbiscomment_write(&p, m, vendor);\n    if (framing_bit)\n        bytestream_put_byte(&p, 1);\n\n    *header_len = size;\n    return p0;\n}", "target": 1}
{"idx": 4911, "func": "int BIO_write(BIO *b, const char *in, int inl)\n\t{\n\tint i;\n\tlong (*cb)();\n\n\tif (b == NULL)\n\t\treturn(0);\n\n\tcb=b->callback;\n\tif ((b->method == NULL) || (b->method->bwrite == NULL))\n\t\t{\n\t\tBIOerr(BIO_F_BIO_WRITE,BIO_R_UNSUPPORTED_METHOD);\n\t\treturn(-2);\n\t\t}\n\n\tif ((cb != NULL) &&\n\t\t((i=(int)cb(b,BIO_CB_WRITE,in,inl,0L,1L)) <= 0))\n\t\t\treturn(i);\n\n\tif (!b->init)\n\t\t{\n\t\tBIOerr(BIO_F_BIO_WRITE,BIO_R_UNINITIALIZED);\n\t\treturn(-2);\n\t\t}\n\n\ti=b->method->bwrite(b,in,inl);\n\n\tif (i > 0) b->num_write+=(unsigned long)i;\n\n\t/* This is evil and not thread safe.  If the BIO has been freed,\n\t * we must not call the callback.  The only way to be able to\n\t * determine this is the reference count which is now invalid since\n\t * the memory has been free()ed.\n\t */\n\tif (b->references <= 0) abort();\n\tif (cb != NULL) /* && (b->references >= 1)) */\n\t\ti=(int)cb(b,BIO_CB_WRITE|BIO_CB_RETURN,in,inl,\n\t\t\t0L,(long)i);\n\treturn(i);\n\t}", "target": 1}
{"idx": 4912, "func": "static av_always_inline void mc_dir_part(H264Context *h, Picture *pic,\n                                         int n, int square, int height,\n                                         int delta, int list,\n                                         uint8_t *dest_y, uint8_t *dest_cb,\n                                         uint8_t *dest_cr,\n                                         int src_x_offset, int src_y_offset,\n                                         qpel_mc_func *qpix_op,\n                                         h264_chroma_mc_func chroma_op,\n                                         int pixel_shift, int chroma_idc)\n{\n    const int mx      = h->mv_cache[list][scan8[n]][0] + src_x_offset * 8;\n    int my            = h->mv_cache[list][scan8[n]][1] + src_y_offset * 8;\n    const int luma_xy = (mx & 3) + ((my & 3) << 2);\n    int offset        = ((mx >> 2) << pixel_shift) + (my >> 2) * h->mb_linesize;\n    uint8_t *src_y    = pic->f.data[0] + offset;\n    uint8_t *src_cb, *src_cr;\n    int extra_width  = 0;\n    int extra_height = 0;\n    int emu = 0;\n    const int full_mx    = mx >> 2;\n    const int full_my    = my >> 2;\n    const int pic_width  = 16 * h->mb_width;\n    const int pic_height = 16 * h->mb_height >> MB_FIELD(h);\n    int ysh;\n\n    if (mx & 7)\n        extra_width -= 3;\n    if (my & 7)\n        extra_height -= 3;\n\n    if (full_mx                <          0 - extra_width  ||\n        full_my                <          0 - extra_height ||\n        full_mx + 16 /*FIXME*/ > pic_width  + extra_width  ||\n        full_my + 16 /*FIXME*/ > pic_height + extra_height) {\n        h->vdsp.emulated_edge_mc(h->edge_emu_buffer,\n                                 src_y - (2 << pixel_shift) - 2 * h->mb_linesize,\n                                 h->mb_linesize,\n                                 16 + 5, 16 + 5 /*FIXME*/, full_mx - 2,\n                                 full_my - 2, pic_width, pic_height);\n        src_y = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;\n        emu   = 1;\n    }\n\n    qpix_op[luma_xy](dest_y, src_y, h->mb_linesize); // FIXME try variable height perhaps?\n    if (!square)\n        qpix_op[luma_xy](dest_y + delta, src_y + delta, h->mb_linesize);\n\n    if (CONFIG_GRAY && h->flags & CODEC_FLAG_GRAY)\n        return;\n\n    if (chroma_idc == 3 /* yuv444 */) {\n        src_cb = pic->f.data[1] + offset;\n        if (emu) {\n            h->vdsp.emulated_edge_mc(h->edge_emu_buffer,\n                                     src_cb - (2 << pixel_shift) - 2 * h->mb_linesize,\n                                     h->mb_linesize,\n                                     16 + 5, 16 + 5 /*FIXME*/,\n                                     full_mx - 2, full_my - 2,\n                                     pic_width, pic_height);\n            src_cb = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;\n        }\n        qpix_op[luma_xy](dest_cb, src_cb, h->mb_linesize); // FIXME try variable height perhaps?\n        if (!square)\n            qpix_op[luma_xy](dest_cb + delta, src_cb + delta, h->mb_linesize);\n\n        src_cr = pic->f.data[2] + offset;\n        if (emu) {\n            h->vdsp.emulated_edge_mc(h->edge_emu_buffer,\n                                     src_cr - (2 << pixel_shift) - 2 * h->mb_linesize,\n                                     h->mb_linesize,\n                                     16 + 5, 16 + 5 /*FIXME*/,\n                                     full_mx - 2, full_my - 2,\n                                     pic_width, pic_height);\n            src_cr = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;\n        }\n        qpix_op[luma_xy](dest_cr, src_cr, h->mb_linesize); // FIXME try variable height perhaps?\n        if (!square)\n            qpix_op[luma_xy](dest_cr + delta, src_cr + delta, h->mb_linesize);\n        return;\n    }\n\n    ysh = 3 - (chroma_idc == 2 /* yuv422 */);\n    if (chroma_idc == 1 /* yuv420 */ && MB_FIELD(h)) {\n        // chroma offset when predicting from a field of opposite parity\n        my  += 2 * ((h->mb_y & 1) - (pic->reference - 1));\n        emu |= (my >> 3) < 0 || (my >> 3) + 8 >= (pic_height >> 1);\n    }\n\n    src_cb = pic->f.data[1] + ((mx >> 3) << pixel_shift) +\n             (my >> ysh) * h->mb_uvlinesize;\n    src_cr = pic->f.data[2] + ((mx >> 3) << pixel_shift) +\n             (my >> ysh) * h->mb_uvlinesize;\n\n    if (emu) {\n        h->vdsp.emulated_edge_mc(h->edge_emu_buffer, src_cb, h->mb_uvlinesize,\n                                 9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),\n                                 pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));\n        src_cb = h->edge_emu_buffer;\n    }\n    chroma_op(dest_cb, src_cb, h->mb_uvlinesize,\n              height >> (chroma_idc == 1 /* yuv420 */),\n              mx & 7, (my << (chroma_idc == 2 /* yuv422 */)) & 7);\n\n    if (emu) {\n        h->vdsp.emulated_edge_mc(h->edge_emu_buffer, src_cr, h->mb_uvlinesize,\n                                 9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),\n                                 pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));\n        src_cr = h->edge_emu_buffer;\n    }\n    chroma_op(dest_cr, src_cr, h->mb_uvlinesize, height >> (chroma_idc == 1 /* yuv420 */),\n              mx & 7, (my << (chroma_idc == 2 /* yuv422 */)) & 7);\n}", "target": 1}
{"idx": 4913, "func": "int ssl3_get_server_hello(SSL *s)\n{\n    int ok, al;\n    long n;\n    /*\n     * Hello verify request and/or server hello version may not match so set\n     * first packet if we're negotiating version.\n     */\n    s->first_packet = 1;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SRVR_HELLO_A,\n                                   SSL3_ST_CR_SRVR_HELLO_B, -1, 20000, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    s->first_packet = 0;\n    if (SSL_IS_DTLS(s)) {\n        if (s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST) {\n            if (s->d1->send_cookie == 0) {\n                s->s3->tmp.reuse_message = 1;\n                return 1;\n            } else {            /* already sent a cookie */\n\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);\n                goto f_err;\n            }\n        }\n    }\n\n    if (s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);\n        goto f_err;\n    }\n\n    return tls_process_server_hello(s, (unsigned long)n);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    s->state = SSL_ST_ERR;\n    return (-1);\n}", "target": 0}
{"idx": 4914, "func": "static int wma_decode_superframe(AVCodecContext *avctx, void *data,\n                                 int *got_frame_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    WMACodecContext *s = avctx->priv_data;\n    int nb_frames, bit_offset, i, pos, len, ret;\n    uint8_t *q;\n    int16_t *samples;\n\n    tprintf(avctx, \"***decode_superframe:\\n\");\n\n    if(buf_size==0){\n        s->last_superframe_len = 0;\n        return 0;\n    }\n    if (buf_size < s->block_align)\n        return 0;\n    buf_size = s->block_align;\n\n    init_get_bits(&s->gb, buf, buf_size*8);\n\n    if (s->use_bit_reservoir) {\n        /* read super frame header */\n        skip_bits(&s->gb, 4); /* super frame index */\n        nb_frames = get_bits(&s->gb, 4) - (s->last_superframe_len <= 0);\n    } else {\n        nb_frames = 1;\n    }\n\n    /* get output buffer */\n    s->frame.nb_samples = nb_frames * s->frame_len;\n    if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    samples = (int16_t *)s->frame.data[0];\n\n    if (s->use_bit_reservoir) {\n        bit_offset = get_bits(&s->gb, s->byte_offset_bits + 3);\n\n        if (s->last_superframe_len > 0) {\n            //        printf(\"skip=%d\\n\", s->last_bitoffset);\n            /* add bit_offset bits to last frame */\n            if ((s->last_superframe_len + ((bit_offset + 7) >> 3)) >\n                MAX_CODED_SUPERFRAME_SIZE)\n                goto fail;\n            q = s->last_superframe + s->last_superframe_len;\n            len = bit_offset;\n            while (len > 7) {\n                *q++ = (get_bits)(&s->gb, 8);\n                len -= 8;\n            }\n            if (len > 0) {\n                *q++ = (get_bits)(&s->gb, len) << (8 - len);\n            }\n\n            /* XXX: bit_offset bits into last frame */\n            init_get_bits(&s->gb, s->last_superframe, MAX_CODED_SUPERFRAME_SIZE*8);\n            /* skip unused bits */\n            if (s->last_bitoffset > 0)\n                skip_bits(&s->gb, s->last_bitoffset);\n            /* this frame is stored in the last superframe and in the\n               current one */\n            if (wma_decode_frame(s, samples) < 0)\n                goto fail;\n            samples += s->nb_channels * s->frame_len;\n            nb_frames--;\n        }\n\n        /* read each frame starting from bit_offset */\n        pos = bit_offset + 4 + 4 + s->byte_offset_bits + 3;\n        if (pos >= MAX_CODED_SUPERFRAME_SIZE * 8)\n            return AVERROR_INVALIDDATA;\n        init_get_bits(&s->gb, buf + (pos >> 3), (MAX_CODED_SUPERFRAME_SIZE - (pos >> 3))*8);\n        len = pos & 7;\n        if (len > 0)\n            skip_bits(&s->gb, len);\n\n        s->reset_block_lengths = 1;\n        for(i=0;i<nb_frames;i++) {\n            if (wma_decode_frame(s, samples) < 0)\n                goto fail;\n            samples += s->nb_channels * s->frame_len;\n        }\n\n        /* we copy the end of the frame in the last frame buffer */\n        pos = get_bits_count(&s->gb) + ((bit_offset + 4 + 4 + s->byte_offset_bits + 3) & ~7);\n        s->last_bitoffset = pos & 7;\n        pos >>= 3;\n        len = buf_size - pos;\n        if (len > MAX_CODED_SUPERFRAME_SIZE || len < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"len %d invalid\\n\", len);\n            goto fail;\n        }\n        s->last_superframe_len = len;\n        memcpy(s->last_superframe, buf + pos, len);\n    } else {\n        /* single frame decode */\n        if (wma_decode_frame(s, samples) < 0)\n            goto fail;\n        samples += s->nb_channels * s->frame_len;\n    }\n\n//av_log(NULL, AV_LOG_ERROR, \"%d %d %d %d outbytes:%d eaten:%d\\n\", s->frame_len_bits, s->block_len_bits, s->frame_len, s->block_len,        (int8_t *)samples - (int8_t *)data, s->block_align);\n\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = s->frame;\n\n    return s->block_align;\n fail:\n    /* when error, we reset the bit reservoir */\n    s->last_superframe_len = 0;\n    return -1;\n}", "target": 0}
{"idx": 4915, "func": "static int configure_audio_filters(FilterGraph *fg, AVFilterContext **in_filter,\n                                   AVFilterContext **out_filter)\n{\n    InputStream  *ist = fg->inputs[0]->ist;\n    OutputStream *ost = fg->outputs[0]->ost;\n    AVCodecContext *codec  = ost->st->codec;\n    AVCodecContext *icodec = ist->st->codec;\n    char *sample_fmts, *sample_rates, *channel_layouts;\n    char args[256];\n    int ret;\n\n    avfilter_graph_free(&fg->graph);\n    if (!(fg->graph = avfilter_graph_alloc()))\n        return AVERROR(ENOMEM);\n\n    snprintf(args, sizeof(args), \"time_base=%d/%d:sample_rate=%d:sample_fmt=%s:\"\n             \"channel_layout=0x%\"PRIx64, ist->st->time_base.num,\n             ist->st->time_base.den, icodec->sample_rate,\n             av_get_sample_fmt_name(icodec->sample_fmt), icodec->channel_layout);\n    ret = avfilter_graph_create_filter(&fg->inputs[0]->filter,\n                                       avfilter_get_by_name(\"abuffer\"),\n                                       \"src\", args, NULL, fg->graph);\n    if (ret < 0)\n        return ret;\n\n    ret = avfilter_graph_create_filter(&fg->outputs[0]->filter,\n                                       avfilter_get_by_name(\"abuffersink\"),\n                                       \"out\", NULL, NULL, fg->graph);\n    if (ret < 0)\n        return ret;\n\n    *in_filter  = fg->inputs[0]->filter;\n    *out_filter = fg->outputs[0]->filter;\n\n    if (codec->channels && !codec->channel_layout)\n        codec->channel_layout = av_get_default_channel_layout(codec->channels);\n\n    sample_fmts     = choose_sample_fmts(ost);\n    sample_rates    = choose_sample_rates(ost);\n    channel_layouts = choose_channel_layouts(ost);\n    if (sample_fmts || sample_rates || channel_layouts) {\n        AVFilterContext *format;\n        char args[256];\n        int len = 0;\n\n        if (sample_fmts)\n            len += snprintf(args + len, sizeof(args) - len, \"sample_fmts=%s:\",\n                            sample_fmts);\n        if (sample_rates)\n            len += snprintf(args + len, sizeof(args) - len, \"sample_rates=%s:\",\n                            sample_rates);\n        if (channel_layouts)\n            len += snprintf(args + len, sizeof(args) - len, \"channel_layouts=%s:\",\n                            channel_layouts);\n        args[len - 1] = 0;\n\n        av_freep(&sample_fmts);\n        av_freep(&sample_rates);\n        av_freep(&channel_layouts);\n\n        ret = avfilter_graph_create_filter(&format,\n                                           avfilter_get_by_name(\"aformat\"),\n                                           \"aformat\", args, NULL, fg->graph);\n        if (ret < 0)\n            return ret;\n\n        ret = avfilter_link(format, 0, fg->outputs[0]->filter, 0);\n        if (ret < 0)\n            return ret;\n\n        *out_filter = format;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 4916, "func": "static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,\n                              const uint8_t *data, int data_size)\n{\n    int stream_ptr = 0;\n    unsigned char rle_code;\n    unsigned char extra_byte, odd_pixel;\n    unsigned char stream_byte;\n    int pixel_ptr = 0;\n    int row_dec = pic->linesize[0];\n    int row_ptr = (avctx->height - 1) * row_dec;\n    int frame_size = row_dec * avctx->height;\n    int i;\n\n    while (row_ptr >= 0) {\n        FETCH_NEXT_STREAM_BYTE();\n        rle_code = stream_byte;\n        if (rle_code == 0) {\n            /* fetch the next byte to see how to handle escape code */\n            FETCH_NEXT_STREAM_BYTE();\n            if (stream_byte == 0) {\n                /* line is done, goto the next one */\n                row_ptr -= row_dec;\n                pixel_ptr = 0;\n            } else if (stream_byte == 1) {\n                /* decode is done */\n                return 0;\n            } else if (stream_byte == 2) {\n                /* reposition frame decode coordinates */\n                FETCH_NEXT_STREAM_BYTE();\n                pixel_ptr += stream_byte;\n                FETCH_NEXT_STREAM_BYTE();\n                row_ptr -= stream_byte * row_dec;\n            } else {\n                // copy pixels from encoded stream\n                odd_pixel =  stream_byte & 1;\n                rle_code = (stream_byte + 1) / 2;\n                extra_byte = rle_code & 0x01;\n                if (row_ptr + pixel_ptr + stream_byte > frame_size) {\n                    av_log(avctx, AV_LOG_ERROR, \" MS RLE: frame ptr just went out of bounds (1)\\n\");\n                    return -1;\n                }\n\n                for (i = 0; i < rle_code; i++) {\n                    if (pixel_ptr >= avctx->width)\n                        break;\n                    FETCH_NEXT_STREAM_BYTE();\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n                    pixel_ptr++;\n                    if (i + 1 == rle_code && odd_pixel)\n                        break;\n                    if (pixel_ptr >= avctx->width)\n                        break;\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n                    pixel_ptr++;\n                }\n\n                // if the RLE code is odd, skip a byte in the stream\n                if (extra_byte)\n                    stream_ptr++;\n            }\n        } else {\n            // decode a run of data\n            if (row_ptr + pixel_ptr + stream_byte > frame_size) {\n                av_log(avctx, AV_LOG_ERROR, \" MS RLE: frame ptr just went out of bounds (1)\\n\");\n                return -1;\n            }\n            FETCH_NEXT_STREAM_BYTE();\n            for (i = 0; i < rle_code; i++) {\n                if (pixel_ptr >= avctx->width)\n                    break;\n                if ((i & 1) == 0)\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n                else\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n                pixel_ptr++;\n            }\n        }\n    }\n\n    /* one last sanity check on the way out */\n    if (stream_ptr < data_size) {\n        av_log(avctx, AV_LOG_ERROR, \" MS RLE: ended frame decode with bytes left over (%d < %d)\\n\",\n            stream_ptr, data_size);\n        return -1;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 4917, "func": "static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)\n{\n    void *val;\n\n    if (min_size < *size)\n        return 0;\n    min_size = FFMAX(min_size + min_size / 16 + 32, min_size);\n    av_freep(ptr);\n    val = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);\n    memcpy(ptr, &val, sizeof(val));\n    if (!val)\n        min_size = 0;\n    *size = min_size;\n    return 1;\n}", "target": 0}
{"idx": 4918, "func": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    /* read bytes from input buffer first */\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        if ((!s->willclose || s->chunksize < 0) &&\n            s->filesize >= 0 && s->off >= s->filesize)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}", "target": 1}
{"idx": 4919, "func": "static int dxtory_decode_v2_565(AVCodecContext *avctx, AVFrame *pic,\n                                const uint8_t *src, int src_size, int is_565)\n{\n    GetByteContext gb;\n    GetBitContext  gb2;\n    int nslices, slice, slice_height;\n    uint32_t off, slice_size;\n    uint8_t *dst;\n    int ret;\n\n    ret = load_buffer(avctx, src, src_size, &gb, &nslices, &off);\n    if (ret < 0)\n        return ret;\n\n    slice_height = avctx->height / nslices;\n    avctx->pix_fmt = AV_PIX_FMT_RGB24;\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    dst = pic->data[0];\n    for (slice = 0; slice < nslices; slice++) {\n        slice_size = bytestream2_get_le32(&gb);\n\n        ret = check_slice_size(avctx, src, src_size, slice_size, off);\n        if (ret < 0)\n            return ret;\n\n        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);\n        dx2_decode_slice_565(&gb2, avctx->width, slice_height, dst,\n                             pic->linesize[0], is_565);\n\n        dst += pic->linesize[0] * slice_height;\n        off += slice_size;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 4920, "func": "static int latm_decode_extradata(LATMContext *ctx, uint8_t *buf, int size)\n{\n    MPEG4AudioConfig m4ac;\n\n    ctx->off = avpriv_mpeg4audio_get_config(&m4ac, buf, size * 8, 1);\n    if (ctx->off < 0)\n        return ctx->off;\n\n    if (ctx->object_type == AOT_ALS && (ctx->off & 7)) {\n        // as long as avpriv_mpeg4audio_get_config works correctly this is impossible\n        av_log(ctx, AV_LOG_ERROR, \"BUG: ALS offset is not byte-aligned\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    /* FIXME: are any formats not allowed in LATM? */\n\n    if (m4ac.object_type > AOT_SBR && m4ac.object_type != AOT_ALS) {\n        av_log(ctx, AV_LOG_ERROR, \"Muxing MPEG-4 AOT %d in LATM is not supported\\n\", m4ac.object_type);\n        return AVERROR_INVALIDDATA;\n    }\n    ctx->channel_conf = m4ac.chan_config;\n    ctx->object_type  = m4ac.object_type;\n\n    return 0;\n}", "target": 1}
{"idx": 4921, "func": "static void log_error_core(const char *file, int line, int module_index,\n                           int level,\n                           apr_status_t status, const server_rec *s,\n                           const conn_rec *c,\n                           const request_rec *r, apr_pool_t *pool,\n                           const char *fmt, va_list args)\n{\n    char errstr[MAX_STRING_LEN];\n    apr_file_t *logf = NULL;\n    int level_and_mask = level & APLOG_LEVELMASK;\n    const request_rec *rmain = NULL;\n    core_server_config *sconf = NULL;\n    ap_errorlog_info info;\n    ap_errorlog_provider *errorlog_provider = NULL;\n    void *errorlog_provider_handle = NULL;\n\n    /* do we need to log once-per-req or once-per-conn info? */\n    int log_conn_info = 0, log_req_info = 0;\n    apr_array_header_t **lines = NULL;\n    int done = 0;\n    int line_number = 0;\n\n    if (r) {\n        AP_DEBUG_ASSERT(r->connection != NULL);\n        c = r->connection;\n    }\n\n    if (s == NULL) {\n        /*\n         * If we are doing stderr logging (startup), don't log messages that are\n         * above the default server log level unless it is a startup/shutdown\n         * notice\n         */\n#ifndef DEBUG\n        if ((level_and_mask != APLOG_NOTICE)\n            && (level_and_mask > ap_default_loglevel)) {\n            return;\n        }\n#endif\n\n        logf = stderr_log;\n        if (!logf && ap_server_conf && ap_server_conf->errorlog_provider) {\n            errorlog_provider = ap_server_conf->errorlog_provider;\n            errorlog_provider_handle = ap_server_conf->errorlog_provider_handle;\n        }\n    }\n    else {\n        int configured_level = r ? ap_get_request_module_loglevel(r, module_index)        :\n                               c ? ap_get_conn_server_module_loglevel(c, s, module_index) :\n                                   ap_get_server_module_loglevel(s, module_index);\n        /*\n         * If we are doing normal logging, don't log messages that are\n         * above the module's log level unless it is a startup/shutdown notice\n         */\n        if ((level_and_mask != APLOG_NOTICE)\n            && (level_and_mask > configured_level)) {\n            return;\n        }\n\n        if (s->error_log) {\n            logf = s->error_log;\n        }\n\n        errorlog_provider = s->errorlog_provider;\n        errorlog_provider_handle = s->errorlog_provider_handle;\n\n        /* the faked server_rec from mod_cgid does not have s->module_config */\n        if (s->module_config) {\n            sconf = ap_get_core_module_config(s->module_config);\n            if (c && !c->log_id) {\n                add_log_id(c, NULL);\n                if (sconf->error_log_conn && sconf->error_log_conn->nelts > 0)\n                    log_conn_info = 1;\n            }\n            if (r) {\n                if (r->main)\n                    rmain = r->main;\n                else\n                    rmain = r;\n\n                if (!rmain->log_id) {\n                    /* XXX: do we need separate log ids for subrequests? */\n                    if (sconf->error_log_req && sconf->error_log_req->nelts > 0)\n                        log_req_info = 1;\n                    /*\n                     * XXX: potential optimization: only create log id if %L is\n                     * XXX: actually used\n                     */\n                    add_log_id(c, rmain);\n                }\n            }\n        }\n    }\n\n    if (!logf && !(errorlog_provider && errorlog_provider_handle)) {\n        /* There is no file to send the log message to (or it is\n         * redirected to /dev/null and therefore any formating done below\n         * would be lost anyway) and there is no initialized log provider\n         * available, so we just return here.\n         */\n        return;\n    }\n\n    info.s             = s;\n    info.c             = c;\n    info.pool          = pool;\n    info.file          = NULL;\n    info.line          = 0;\n    info.status        = 0;\n    info.using_provider= (logf == NULL);\n    info.startup       = ((level & APLOG_STARTUP) == APLOG_STARTUP);\n    info.format        = fmt;\n\n    while (!done) {\n        apr_array_header_t *log_format;\n        int len = 0, errstr_start = 0, errstr_end = 0;\n        /* XXX: potential optimization: format common prefixes only once */\n        if (log_conn_info) {\n            /* once-per-connection info */\n            if (line_number == 0) {\n                lines = (apr_array_header_t **)sconf->error_log_conn->elts;\n                info.r = NULL;\n                info.rmain = NULL;\n                info.level = -1;\n                info.module_index = APLOG_NO_MODULE;\n            }\n\n            log_format = lines[line_number++];\n\n            if (line_number == sconf->error_log_conn->nelts) {\n                /* this is the last line of once-per-connection info */\n                line_number = 0;\n                log_conn_info = 0;\n            }\n        }\n        else if (log_req_info) {\n            /* once-per-request info */\n            if (line_number == 0) {\n                lines = (apr_array_header_t **)sconf->error_log_req->elts;\n                info.r = rmain;\n                info.rmain = rmain;\n                info.level = -1;\n                info.module_index = APLOG_NO_MODULE;\n            }\n\n            log_format = lines[line_number++];\n\n            if (line_number == sconf->error_log_req->nelts) {\n                /* this is the last line of once-per-request info */\n                line_number = 0;\n                log_req_info = 0;\n            }\n        }\n        else {\n            /* the actual error message */\n            info.r            = r;\n            info.rmain        = rmain;\n            info.level        = level_and_mask;\n            info.module_index = module_index;\n            info.file         = file;\n            info.line         = line;\n            info.status       = status;\n            log_format = sconf ? sconf->error_log_format : NULL;\n            done = 1;\n        }\n\n        /*\n         * prepare and log one line\n         */\n\n        if (log_format && !info.startup) {\n            len += do_errorlog_format(log_format, &info, errstr + len,\n                                      MAX_STRING_LEN - len,\n                                      &errstr_start, &errstr_end, fmt, args);\n        }\n        else {\n            len += do_errorlog_default(&info, errstr + len, MAX_STRING_LEN - len,\n                                       &errstr_start, &errstr_end, fmt, args);\n        }\n\n        if (!*errstr) {\n            /*\n             * Don't log empty lines. This can happen with once-per-conn/req\n             * info if an item with AP_ERRORLOG_FLAG_REQUIRED is NULL.\n             */\n            continue;\n        }\n\n        if (logf || (errorlog_provider->flags &\n            AP_ERRORLOG_PROVIDER_ADD_EOL_STR)) {\n            /* Truncate for the terminator (as apr_snprintf does) */\n            if (len > MAX_STRING_LEN - sizeof(APR_EOL_STR)) {\n                len = MAX_STRING_LEN - sizeof(APR_EOL_STR);\n            }\n            strcpy(errstr + len, APR_EOL_STR);\n            len += strlen(APR_EOL_STR);\n        }\n\n        if (logf) {\n            write_logline(errstr, len, logf, level_and_mask);\n        }\n        else {\n            errorlog_provider->writer(&info, errorlog_provider_handle,\n                                      errstr, len);\n        }\n\n        if (done) {\n            /*\n             * We don't call the error_log hook for per-request/per-conn\n             * lines, and we only pass the actual log message, not the\n             * prefix and suffix.\n             */\n            errstr[errstr_end] = '\\0';\n            ap_run_error_log(&info, errstr + errstr_start);\n        }\n\n        *errstr = '\\0';\n    }\n}", "target": 1}
{"idx": 4922, "func": "static int decode_type1(GetByteContext *gb, PutByteContext *pb)\n{\n    unsigned opcode = 0, len;\n    int high = 0;\n    int i, pos;\n\n    while (bytestream2_get_bytes_left(gb) > 0) {\n        GetByteContext gbc;\n\n        while (bytestream2_get_bytes_left(gb) > 0) {\n            while (bytestream2_get_bytes_left(gb) > 0) {\n                opcode = bytestream2_get_byte(gb);\n                high = opcode >= 0x20;\n                if (high)\n                    break;\n                if (opcode)\n                    break;\n                opcode = bytestream2_get_byte(gb);\n                if (opcode < 0xF8) {\n                    opcode = opcode + 32;\n                    break;\n                }\n                i = opcode - 0xF8;\n                if (i) {\n                    len = 256;\n                    do {\n                        len *= 2;\n                        --i;\n                    } while (i);\n                } else {\n                    len = 280;\n                }\n                do {\n                    bytestream2_put_le32(pb, bytestream2_get_le32(gb));\n                    bytestream2_put_le32(pb, bytestream2_get_le32(gb));\n                    len -= 8;\n                } while (len && bytestream2_get_bytes_left(gb) > 0);\n            }\n\n            if (!high) {\n                do {\n                    bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                    --opcode;\n                } while (opcode && bytestream2_get_bytes_left(gb) > 0);\n\n                while (bytestream2_get_bytes_left(gb) > 0) {\n                    GetByteContext gbc;\n\n                    opcode = bytestream2_get_byte(gb);\n                    if (opcode >= 0x20)\n                        break;\n                    bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n\n                    pos = -(opcode | 32 * bytestream2_get_byte(gb)) - 1;\n                    bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n                    bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                    bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                    bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                    bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                }\n            }\n            high = 0;\n            if (opcode < 0x40)\n                break;\n            bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n            pos = (-((opcode & 0x1F) | 32 * bytestream2_get_byte(gb)) - 1);\n            bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            len = (opcode >> 5) - 1;\n            do {\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                --len;\n            } while (len && bytestream2_get_bytes_left(&gbc) > 0);\n        }\n        len = opcode & 0x1F;\n        if (!len) {\n            if (!bytestream2_peek_byte(gb)) {\n                do {\n                    bytestream2_skip(gb, 1);\n                    len += 255;\n                } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n            }\n            len += bytestream2_get_byte(gb) + 31;\n        }\n        pos = -bytestream2_get_byte(gb);\n        bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n        bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos - (bytestream2_get_byte(gb) << 8), SEEK_SET);\n        if (bytestream2_tell_p(pb) == bytestream2_tell(&gbc))\n            break;\n        if (len < 5 || bytestream2_tell_p(pb) - bytestream2_tell(&gbc) < 4) {\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            do {\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                --len;\n            } while (len && bytestream2_get_bytes_left(&gbc) > 0);\n        } else {\n            bytestream2_put_le32(pb, bytestream2_get_le32(&gbc));\n            len--;\n            do {\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                len--;\n            } while (len && bytestream2_get_bytes_left(&gbc) > 0);\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 4923, "func": "static int expand_rle_row(SgiState *s, uint8_t *out_buf,\n                          uint8_t *out_end, int pixelstride)\n{\n    unsigned char pixel, count;\n    unsigned char *orig = out_buf;\n\n    while (1) {\n        if (bytestream2_get_bytes_left(&s->g) < 1)\n            return AVERROR_INVALIDDATA;\n        pixel = bytestream2_get_byteu(&s->g);\n        if (!(count = (pixel & 0x7f))) {\n            return (out_buf - orig) / pixelstride;\n        }\n\n        /* Check for buffer overflow. */\n        if(out_buf + pixelstride * (count-1) >= out_end) return -1;\n\n        if (pixel & 0x80) {\n            while (count--) {\n                *out_buf = bytestream2_get_byte(&s->g);\n                out_buf += pixelstride;\n            }\n        } else {\n            pixel = bytestream2_get_byte(&s->g);\n\n            while (count--) {\n                *out_buf = pixel;\n                out_buf += pixelstride;\n            }\n        }\n    }\n}", "target": 0}
{"idx": 4924, "func": "static int set_palette(BethsoftvidContext *ctx)\n{\n    uint32_t *palette = (uint32_t *)ctx->frame.data[1];\n    int a;\n\n    if (bytestream2_get_bytes_left(&ctx->g) < 256*3)\n        return AVERROR_INVALIDDATA;\n\n    for(a = 0; a < 256; a++){\n        palette[a] = bytestream2_get_be24u(&ctx->g) * 4;\n    }\n    ctx->frame.palette_has_changed = 1;\n    return 256*3;\n}", "target": 0}
{"idx": 4925, "func": "static int escape124_decode_frame(AVCodecContext *avctx,\n                                  void *data, int *got_frame,\n                                  AVPacket *avpkt)\n{\n    int buf_size = avpkt->size;\n    Escape124Context *s = avctx->priv_data;\n    AVFrame *frame = data;\n\n    GetBitContext gb;\n    unsigned frame_flags, frame_size;\n    unsigned i;\n\n    unsigned superblock_index, cb_index = 1,\n             superblock_col_index = 0,\n             superblocks_per_row = avctx->width / 8, skip = -1;\n\n    uint16_t* old_frame_data, *new_frame_data;\n    unsigned old_stride, new_stride;\n\n    int ret;\n\n    if ((ret = init_get_bits8(&gb, avpkt->data, avpkt->size)) < 0)\n        return ret;\n\n    // This call also guards the potential depth reads for the\n    // codebook unpacking.\n    if (get_bits_left(&gb) < 64)\n        return -1;\n\n    frame_flags = get_bits_long(&gb, 32);\n    frame_size  = get_bits_long(&gb, 32);\n\n    // Leave last frame unchanged\n    // FIXME: Is this necessary?  I haven't seen it in any real samples\n    if (!(frame_flags & 0x114) || !(frame_flags & 0x7800000)) {\n        if (!s->frame.data[0])\n            return AVERROR_INVALIDDATA;\n\n        av_log(avctx, AV_LOG_DEBUG, \"Skipping frame\\n\");\n\n        *got_frame = 1;\n        if ((ret = av_frame_ref(frame, &s->frame)) < 0)\n            return ret;\n\n        return frame_size;\n    }\n\n    for (i = 0; i < 3; i++) {\n        if (frame_flags & (1 << (17 + i))) {\n            unsigned cb_depth, cb_size;\n            if (i == 2) {\n                // This codebook can be cut off at places other than\n                // powers of 2, leaving some of the entries undefined.\n                cb_size = get_bits_long(&gb, 20);\n                cb_depth = av_log2(cb_size - 1) + 1;\n            } else {\n                cb_depth = get_bits(&gb, 4);\n                if (i == 0) {\n                    // This is the most basic codebook: pow(2,depth) entries\n                    // for a depth-length key\n                    cb_size = 1 << cb_depth;\n                } else {\n                    // This codebook varies per superblock\n                    // FIXME: I don't think this handles integer overflow\n                    // properly\n                    cb_size = s->num_superblocks << cb_depth;\n                }\n            }\n            av_free(s->codebooks[i].blocks);\n            s->codebooks[i] = unpack_codebook(&gb, cb_depth, cb_size);\n            if (!s->codebooks[i].blocks)\n                return -1;\n        }\n    }\n\n    if ((ret = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n        return ret;\n\n    new_frame_data = (uint16_t*)frame->data[0];\n    new_stride = frame->linesize[0] / 2;\n    old_frame_data = (uint16_t*)s->frame.data[0];\n    old_stride = s->frame.linesize[0] / 2;\n\n    for (superblock_index = 0; superblock_index < s->num_superblocks;\n         superblock_index++) {\n        MacroBlock mb;\n        SuperBlock sb;\n        unsigned multi_mask = 0;\n\n        if (skip == -1) {\n            // Note that this call will make us skip the rest of the blocks\n            // if the frame prematurely ends\n            skip = decode_skip_count(&gb);\n        }\n\n        if (skip) {\n            copy_superblock(new_frame_data, new_stride,\n                            old_frame_data, old_stride);\n        } else {\n            copy_superblock(sb.pixels, 8,\n                            old_frame_data, old_stride);\n\n            while (get_bits_left(&gb) >= 1 && !get_bits1(&gb)) {\n                unsigned mask;\n                mb = decode_macroblock(s, &gb, &cb_index, superblock_index);\n                mask = get_bits(&gb, 16);\n                multi_mask |= mask;\n                for (i = 0; i < 16; i++) {\n                    if (mask & mask_matrix[i]) {\n                        insert_mb_into_sb(&sb, mb, i);\n                    }\n                }\n            }\n\n            if (!get_bits1(&gb)) {\n                unsigned inv_mask = get_bits(&gb, 4);\n                for (i = 0; i < 4; i++) {\n                    if (inv_mask & (1 << i)) {\n                        multi_mask ^= 0xF << i*4;\n                    } else {\n                        multi_mask ^= get_bits(&gb, 4) << i*4;\n                    }\n                }\n\n                for (i = 0; i < 16; i++) {\n                    if (multi_mask & mask_matrix[i]) {\n                        mb = decode_macroblock(s, &gb, &cb_index,\n                                               superblock_index);\n                        insert_mb_into_sb(&sb, mb, i);\n                    }\n                }\n            } else if (frame_flags & (1 << 16)) {\n                while (get_bits_left(&gb) >= 1 && !get_bits1(&gb)) {\n                    mb = decode_macroblock(s, &gb, &cb_index, superblock_index);\n                    insert_mb_into_sb(&sb, mb, get_bits(&gb, 4));\n                }\n            }\n\n            copy_superblock(new_frame_data, new_stride, sb.pixels, 8);\n        }\n\n        superblock_col_index++;\n        new_frame_data += 8;\n        if (old_frame_data)\n            old_frame_data += 8;\n        if (superblock_col_index == superblocks_per_row) {\n            new_frame_data += new_stride * 8 - superblocks_per_row * 8;\n            if (old_frame_data)\n                old_frame_data += old_stride * 8 - superblocks_per_row * 8;\n            superblock_col_index = 0;\n        }\n        skip--;\n    }\n\n    av_log(avctx, AV_LOG_DEBUG,\n           \"Escape sizes: %i, %i, %i\\n\",\n           frame_size, buf_size, get_bits_count(&gb) / 8);\n\n    av_frame_unref(&s->frame);\n    if ((ret = av_frame_ref(&s->frame, frame)) < 0)\n        return ret;\n\n    *got_frame = 1;\n\n    return frame_size;\n}", "target": 0}
{"idx": 4926, "func": "static int pmp_header(AVFormatContext *s)\n{\n    PMPContext *pmp = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int tb_num, tb_den;\n    uint32_t index_cnt;\n    int audio_codec_id = AV_CODEC_ID_NONE;\n    int srate, channels;\n    int i;\n    uint64_t pos;\n    int64_t fsize = avio_size(pb);\n\n    AVStream *vst = avformat_new_stream(s, NULL);\n    if (!vst)\n        return AVERROR(ENOMEM);\n    vst->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n    avio_skip(pb, 8);\n    switch (avio_rl32(pb)) {\n    case 0:\n        vst->codec->codec_id = AV_CODEC_ID_MPEG4;\n        break;\n    case 1:\n        vst->codec->codec_id = AV_CODEC_ID_H264;\n        break;\n    default:\n        av_log(s, AV_LOG_ERROR, \"Unsupported video format\\n\");\n        break;\n    }\n    index_cnt = avio_rl32(pb);\n    vst->codec->width  = avio_rl32(pb);\n    vst->codec->height = avio_rl32(pb);\n\n    tb_num = avio_rl32(pb);\n    tb_den = avio_rl32(pb);\n    avpriv_set_pts_info(vst, 32, tb_num, tb_den);\n    vst->nb_frames = index_cnt;\n    vst->duration = index_cnt;\n\n    switch (avio_rl32(pb)) {\n    case 0:\n        audio_codec_id = AV_CODEC_ID_MP3;\n        break;\n    case 1:\n        av_log(s, AV_LOG_ERROR, \"AAC not yet correctly supported\\n\");\n        audio_codec_id = AV_CODEC_ID_AAC;\n        break;\n    default:\n        av_log(s, AV_LOG_ERROR, \"Unsupported audio format\\n\");\n        break;\n    }\n    pmp->num_streams = avio_rl16(pb) + 1;\n    avio_skip(pb, 10);\n    srate = avio_rl32(pb);\n    channels = avio_rl32(pb) + 1;\n    pos = avio_tell(pb) + 4*index_cnt;\n    for (i = 0; i < index_cnt; i++) {\n        uint32_t size = avio_rl32(pb);\n        int flags = size & 1 ? AVINDEX_KEYFRAME : 0;\n        if (url_feof(pb)) {\n            av_log(s, AV_LOG_FATAL, \"Encountered EOF while reading index.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        size >>= 1;\n        if (size < 9 + 4*pmp->num_streams) {\n            av_log(s, AV_LOG_ERROR, \"Packet too small\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        av_add_index_entry(vst, pos, i, size, 0, flags);\n        pos += size;\n        if (fsize > 0 && i == 0 && pos > fsize) {\n            av_log(s, AV_LOG_ERROR, \"File ends before first packet\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    for (i = 1; i < pmp->num_streams; i++) {\n        AVStream *ast = avformat_new_stream(s, NULL);\n        if (!ast)\n            return AVERROR(ENOMEM);\n        ast->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n        ast->codec->codec_id = audio_codec_id;\n        ast->codec->channels = channels;\n        ast->codec->sample_rate = srate;\n        avpriv_set_pts_info(ast, 32, 1, srate);\n    }\n    return 0;\n}", "target": 1}
{"idx": 4927, "func": "static av_always_inline void\nyuv2mono_2_c_template(SwsContext *c, const int16_t *buf[2],\n                      const int16_t *ubuf[2], const int16_t *vbuf[2],\n                      const int16_t *abuf[2], uint8_t *dest, int dstW,\n                      int yalpha, int uvalpha, int y,\n                      enum PixelFormat target)\n{\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1];\n    const uint8_t * const d128 = dither_8x8_220[y & 7];\n    uint8_t *g = c->table_gU[128] + c->table_gV[128];\n    int  yalpha1 = 4095 - yalpha;\n    int i;\n\n    for (i = 0; i < dstW - 7; i += 8) {\n        int acc =    g[((buf0[i    ] * yalpha1 + buf1[i    ] * yalpha) >> 19) + d128[0]];\n        acc += acc + g[((buf0[i + 1] * yalpha1 + buf1[i + 1] * yalpha) >> 19) + d128[1]];\n        acc += acc + g[((buf0[i + 2] * yalpha1 + buf1[i + 2] * yalpha) >> 19) + d128[2]];\n        acc += acc + g[((buf0[i + 3] * yalpha1 + buf1[i + 3] * yalpha) >> 19) + d128[3]];\n        acc += acc + g[((buf0[i + 4] * yalpha1 + buf1[i + 4] * yalpha) >> 19) + d128[4]];\n        acc += acc + g[((buf0[i + 5] * yalpha1 + buf1[i + 5] * yalpha) >> 19) + d128[5]];\n        acc += acc + g[((buf0[i + 6] * yalpha1 + buf1[i + 6] * yalpha) >> 19) + d128[6]];\n        acc += acc + g[((buf0[i + 7] * yalpha1 + buf1[i + 7] * yalpha) >> 19) + d128[7]];\n        output_pixel(*dest++, acc);\n    }\n}", "target": 0}
{"idx": 4928, "func": "static int txd_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                            AVPacket *avpkt) {\n    GetByteContext gb;\n    AVFrame * const p = data;\n    unsigned int version, w, h, d3d_format, depth, stride, flags;\n    unsigned int y, v;\n    uint8_t *ptr;\n    uint32_t *pal;\n    int ret;\n\n    bytestream2_init(&gb, avpkt->data, avpkt->size);\n    version         = bytestream2_get_le32(&gb);\n    bytestream2_skip(&gb, 72);\n    d3d_format      = bytestream2_get_le32(&gb);\n    w               = bytestream2_get_le16(&gb);\n    h               = bytestream2_get_le16(&gb);\n    depth           = bytestream2_get_byte(&gb);\n    bytestream2_skip(&gb, 2);\n    flags           = bytestream2_get_byte(&gb);\n\n    if (version < 8 || version > 9) {\n        av_log(avctx, AV_LOG_ERROR, \"texture data version %i is unsupported\\n\",\n                                                                    version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (depth == 8) {\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    } else if (depth == 16 || depth == 32) {\n        avctx->pix_fmt = AV_PIX_FMT_RGB32;\n    } else {\n        av_log(avctx, AV_LOG_ERROR, \"depth of %i is unsupported\\n\", depth);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    ptr    = p->data[0];\n    stride = p->linesize[0];\n\n    if (depth == 8) {\n        pal = (uint32_t *) p->data[1];\n        for (y = 0; y < 256; y++) {\n            v = bytestream2_get_be32(&gb);\n            pal[y] = (v >> 8) + (v << 24);\n        }\n        if (bytestream2_get_bytes_left(&gb) < w * h)\n            return AVERROR_INVALIDDATA;\n        bytestream2_skip(&gb, 4);\n        for (y=0; y<h; y++) {\n            bytestream2_get_buffer(&gb, ptr, w);\n            ptr += stride;\n        }\n    } else if (depth == 16) {\n        bytestream2_skip(&gb, 4);\n        switch (d3d_format) {\n        case 0:\n            if (!(flags & 1))\n                goto unsupported;\n        case FF_S3TC_DXT1:\n            if (bytestream2_get_bytes_left(&gb) < (w/4) * (h/4) * 8)\n                return AVERROR_INVALIDDATA;\n            ff_decode_dxt1(&gb, ptr, w, h, stride);\n            break;\n        case FF_S3TC_DXT3:\n            if (bytestream2_get_bytes_left(&gb) < (w/4) * (h/4) * 16)\n                return AVERROR_INVALIDDATA;\n            ff_decode_dxt3(&gb, ptr, w, h, stride);\n            break;\n        default:\n            goto unsupported;\n        }\n    } else if (depth == 32) {\n        switch (d3d_format) {\n        case 0x15:\n        case 0x16:\n            if (bytestream2_get_bytes_left(&gb) < h * w * 4)\n                return AVERROR_INVALIDDATA;\n            for (y=0; y<h; y++) {\n                bytestream2_get_buffer(&gb, ptr, w * 4);\n                ptr += stride;\n            }\n            break;\n        default:\n            goto unsupported;\n        }\n    }\n\n    *got_frame = 1;\n\n    return avpkt->size;\n\nunsupported:\n    av_log(avctx, AV_LOG_ERROR, \"unsupported d3d format (%08x)\\n\", d3d_format);\n    return AVERROR_PATCHWELCOME;\n}", "target": 1}
{"idx": 4929, "func": "static void count_frame_bits_fixed(AC3EncodeContext *s)\n{\n    static const int frame_bits_inc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 };\n    int blk;\n    int frame_bits;\n\n    /* assumptions:\n     *   no dynamic range codes\n     *   bit allocation parameters do not change between blocks\n     *   no delta bit allocation\n     *   no skipped data\n     *   no auxilliary data\n     *   no E-AC-3 metadata\n     */\n\n    /* header */\n    frame_bits = 16; /* sync info */\n    if (s->eac3) {\n        /* bitstream info header */\n        frame_bits += 35;\n        frame_bits += 1 + 1 + 1;\n        /* audio frame header */\n        frame_bits += 2;\n        frame_bits += 10;\n        /* exponent strategy */\n        for (blk = 0; blk < AC3_MAX_BLOCKS; blk++)\n            frame_bits += 2 * s->fbw_channels + s->lfe_on;\n        /* converter exponent strategy */\n        frame_bits += s->fbw_channels * 5;\n        /* snr offsets */\n        frame_bits += 10;\n        /* block start info */\n        frame_bits++;\n    } else {\n        frame_bits += 49;\n        frame_bits += frame_bits_inc[s->channel_mode];\n    }\n\n    /* audio blocks */\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n        if (!s->eac3) {\n            /* block switch flags */\n            frame_bits += s->fbw_channels;\n\n            /* dither flags */\n            frame_bits += s->fbw_channels;\n        }\n\n        /* dynamic range */\n        frame_bits++;\n\n        /* spectral extension */\n        if (s->eac3)\n            frame_bits++;\n\n        if (!s->eac3) {\n            /* exponent strategy */\n            frame_bits += 2 * s->fbw_channels;\n            if (s->lfe_on)\n                frame_bits++;\n\n            /* bit allocation params */\n            frame_bits++;\n            if (!blk)\n                frame_bits += 2 + 2 + 2 + 2 + 3;\n        }\n\n        /* converter snr offset */\n        if (s->eac3)\n            frame_bits++;\n\n        if (!s->eac3) {\n            /* delta bit allocation */\n            frame_bits++;\n\n            /* skipped data */\n            frame_bits++;\n        }\n    }\n\n    /* auxiliary data */\n    frame_bits++;\n\n    /* CRC */\n    frame_bits += 1 + 16;\n\n    s->frame_bits_fixed = frame_bits;\n}", "target": 1}
{"idx": 4930, "func": "int BN_set_bit(BIGNUM *a, int n)\n\t{\n\tint i,j,k;\n\n\ti=n/BN_BITS2;\n\tj=n%BN_BITS2;\n\tif (a->top <= i)\n\t\t{\n\t\tif (bn_wexpand(a,i+1) == NULL) return(0);\n\t\tfor(k=a->top; k<i+1; k++)\n\t\t\ta->d[k]=0;\n\t\ta->top=i+1;\n\t\t}\n\n\ta->d[i]|=(((BN_ULONG)1)<<j);\n\treturn(1);\n\t}", "target": 1}
{"idx": 4931, "func": "static av_cold int sonic_decode_init(AVCodecContext *avctx)\n{\n    SonicContext *s = avctx->priv_data;\n    GetBitContext gb;\n    int i;\n\n    s->channels = avctx->channels;\n    s->samplerate = avctx->sample_rate;\n\n    if (!avctx->extradata)\n    {\n        av_log(avctx, AV_LOG_ERROR, \"No mandatory headers present\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    init_get_bits8(&gb, avctx->extradata, avctx->extradata_size);\n\n    s->version = get_bits(&gb, 2);\n    if (s->version >= 2) {\n        s->version       = get_bits(&gb, 8);\n        s->minor_version = get_bits(&gb, 8);\n    }\n    if (s->version != 2)\n    {\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported Sonic version, please report\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->version >= 1)\n    {\n        int sample_rate_index;\n        s->channels = get_bits(&gb, 2);\n        sample_rate_index = get_bits(&gb, 4);\n        if (sample_rate_index >= FF_ARRAY_ELEMS(samplerate_table)) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample_rate_index %d\\n\", sample_rate_index);\n            return AVERROR_INVALIDDATA;\n        }\n        s->samplerate = samplerate_table[sample_rate_index];\n        av_log(avctx, AV_LOG_INFO, \"Sonicv2 chans: %d samprate: %d\\n\",\n            s->channels, s->samplerate);\n    }\n\n    if (s->channels > MAX_CHANNELS || s->channels < 1)\n    {\n        av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo streams are supported by now\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->lossless = get_bits1(&gb);\n    if (!s->lossless)\n        skip_bits(&gb, 3); // XXX FIXME\n    s->decorrelation = get_bits(&gb, 2);\n    if (s->decorrelation != 3 && s->channels != 2) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid decorrelation %d\\n\", s->decorrelation);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->downsampling = get_bits(&gb, 2);\n    if (!s->downsampling) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid downsampling value\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->num_taps = (get_bits(&gb, 5)+1)<<5;\n    if (get_bits1(&gb)) // XXX FIXME\n        av_log(avctx, AV_LOG_INFO, \"Custom quant table\\n\");\n\n    s->block_align = 2048LL*s->samplerate/(44100*s->downsampling);\n    s->frame_size = s->channels*s->block_align*s->downsampling;\n//    avctx->frame_size = s->block_align;\n\n    av_log(avctx, AV_LOG_INFO, \"Sonic: ver: %d.%d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\\n\",\n        s->version, s->minor_version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);\n\n    // generate taps\n    s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant));\n    if (!s->tap_quant)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < s->num_taps; i++)\n        s->tap_quant[i] = ff_sqrt(i+1);\n\n    s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k));\n\n    for (i = 0; i < s->channels; i++)\n    {\n        s->predictor_state[i] = av_calloc(s->num_taps, sizeof(**s->predictor_state));\n        if (!s->predictor_state[i])\n            return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < s->channels; i++)\n    {\n        s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples));\n        if (!s->coded_samples[i])\n            return AVERROR(ENOMEM);\n    }\n    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));\n    if (!s->int_samples)\n        return AVERROR(ENOMEM);\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n    return 0;\n}", "target": 0}
{"idx": 4932, "func": "static int hevc_decode_frame(AVCodecContext *avctx, void *data, int *got_output,\n                             AVPacket *avpkt)\n{\n    int ret;\n    HEVCContext *s = avctx->priv_data;\n\n    if (!avpkt->size) {\n        ret = ff_hevc_output_frame(s, data, 1);\n        if (ret < 0)\n            return ret;\n\n        *got_output = ret;\n        return 0;\n    }\n\n    s->ref = NULL;\n    ret    = decode_nal_units(s, avpkt->data, avpkt->size);\n    if (ret < 0)\n        return ret;\n\n    if (avctx->hwaccel) {\n        if (s->ref && (ret = avctx->hwaccel->end_frame(avctx)) < 0) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"hardware accelerator failed to decode picture\\n\");\n            ff_hevc_unref_frame(s, s->ref, ~0);\n            return ret;\n        }\n    } else {\n        /* verify the SEI checksum */\n        if (avctx->err_recognition & AV_EF_CRCCHECK && s->is_decoded &&\n            s->is_md5) {\n            ret = verify_md5(s, s->ref->frame);\n            if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE) {\n                ff_hevc_unref_frame(s, s->ref, ~0);\n                return ret;\n            }\n        }\n    }\n    s->is_md5 = 0;\n\n    if (s->is_decoded) {\n        av_log(avctx, AV_LOG_DEBUG, \"Decoded frame with POC %d.\\n\", s->poc);\n        s->is_decoded = 0;\n    }\n\n    if (s->output_frame->buf[0]) {\n        av_frame_move_ref(data, s->output_frame);\n        *got_output = 1;\n    }\n\n    return avpkt->size;\n}", "target": 1}
{"idx": 4933, "func": "static int asn1_cb(const char *elem, int len, void *bitstr)\n\t{\n\ttag_exp_arg *arg = bitstr;\n\tint i;\n\tint utype;\n\tint vlen = 0;\n\tconst char *p, *vstart = NULL;\n\n\tint tmp_tag, tmp_class;\n\n\tfor(i = 0, p = elem; i < len; p++, i++)\n\t\t{\n\t\t/* Look for the ':' in name value pairs */\n\t\tif (*p == ':')\n\t\t\t{\n\t\t\tvstart = p + 1;\n\t\t\tvlen = len - (vstart - elem);\n\t\t\tlen = p - elem;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tutype = asn1_str2tag(elem, len);\n\n\tif (utype == -1)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_TAG);\n\t\tERR_add_error_data(2, \"tag=\", elem);\n\t\treturn -1;\n\t\t}\n\n\t/* If this is not a modifier mark end of string and exit */\n\tif (!(utype & ASN1_GEN_FLAG))\n\t\t{\n\t\targ->utype = utype;\n\t\targ->str = vstart;\n\t\t/* If no value and not end of string, error */\n\t\tif (!vstart && elem[len])\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_MISSING_VALUE);\n\t\t\treturn -1;\n\t\t\t}\n\t\treturn 0;\n\t\t}\n\n\tswitch(utype)\n\t\t{\n\n\t\tcase ASN1_GEN_FLAG_IMP:\n\t\t/* Check for illegal multiple IMPLICIT tagging */\n\t\tif (arg->imp_tag != -1)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_NESTED_TAGGING);\n\t\t\treturn -1;\n\t\t\t}\n\t\tif (!parse_tagging(vstart, vlen, &arg->imp_tag, &arg->imp_class))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_EXP:\n\n\t\tif (!parse_tagging(vstart, vlen, &tmp_tag, &tmp_class))\n\t\t\treturn -1;\n\t\tif (!append_exp(arg, tmp_tag, tmp_class, 1, 0, 0))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_SEQWRAP:\n\t\tif (!append_exp(arg, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL, 1, 0, 1))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_BITWRAP:\n\t\tif (!append_exp(arg, V_ASN1_BIT_STRING, V_ASN1_UNIVERSAL, 0, 1, 1))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_OCTWRAP:\n\t\tif (!append_exp(arg, V_ASN1_OCTET_STRING, V_ASN1_UNIVERSAL, 0, 0, 1))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_FORMAT:\n\t\tif (!strncmp(vstart, \"ASCII\", 5))\n\t\t\targ->format = ASN1_GEN_FORMAT_ASCII;\n\t\telse if (!strncmp(vstart, \"UTF8\", 4))\n\t\t\targ->format = ASN1_GEN_FORMAT_UTF8;\n\t\telse if (!strncmp(vstart, \"HEX\", 3))\n\t\t\targ->format = ASN1_GEN_FORMAT_HEX;\n\t\telse if (!strncmp(vstart, \"BITLIST\", 3))\n\t\t\targ->format = ASN1_GEN_FORMAT_BITLIST;\n\t\telse\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKOWN_FORMAT);\n\t\t\treturn -1;\n\t\t\t}\n\t\tbreak;\n\n\t\t}\n\n\treturn 1;\n\n\t}", "target": 0}
{"idx": 4934, "func": "static int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    MOVFragmentIndex* index = NULL;\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    void *tmp;\n\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index) {\n        return AVERROR(ENOMEM);\n    }\n\n    tmp = av_realloc_array(mov->fragment_index_data,\n                           mov->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n    mov->fragment_index_data = tmp;\n    mov->fragment_index_data[mov->fragment_index_count++] = index;\n\n    version = avio_r8(f);\n    avio_rb24(f);\n    index->track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    index->item_count = avio_rb32(f);\n    index->items = av_mallocz_array(\n            index->item_count, sizeof(MOVFragmentIndexItem));\n    if (!index->items) {\n        index->item_count = 0;\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < index->item_count; i++) {\n        int64_t time, offset;\n        if (version == 1) {\n            time   = avio_rb64(f);\n            offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n        index->items[i].time = time;\n        index->items[i].moof_offset = offset;\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}", "target": 0}
{"idx": 4935, "func": "static void refill(CABACContext *c){\n#if CABAC_BITS == 16\n        c->low+= (c->bytestream[0]<<9) + (c->bytestream[1]<<1);\n#else\n        c->low+= c->bytestream[0]<<1;\n#endif\n    c->low -= CABAC_MASK;\n    c->bytestream+= CABAC_BITS/8;\n}", "target": 1}
{"idx": 4936, "func": "BN_ULONG bn_sub_part_words(BN_ULONG *r,\n\tconst BN_ULONG *a, const BN_ULONG *b,\n\tint cl, int dl)\n\t{\n\tBN_ULONG c, t;\n\n\tassert(cl >= 0);\n\tc = bn_sub_words(r, a, b, cl);\n\n\tif (dl == 0)\n\t\treturn c;\n\n\tr += cl;\n\ta += cl;\n\tb += cl;\n\n\tif (dl < 0)\n\t\t{\n\t\tfor (;;)\n\t\t\t{\n\t\t\tt = b[0];\n\t\t\tr[0] = (0-t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=1;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tt = b[1];\n\t\t\tr[1] = (0-t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=1;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tt = b[2];\n\t\t\tr[2] = (0-t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=1;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tt = b[3];\n\t\t\tr[3] = (0-t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=1;\n\t\t\tif (++dl >= 0) break;\n\n\t\t\tb += 4;\n\t\t\tr += 4;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tint save_dl = dl;\n\t\twhile(c)\n\t\t\t{\n\t\t\tt = a[0];\n\t\t\tr[0] = (t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=0;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tt = a[1];\n\t\t\tr[1] = (t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=0;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tt = a[2];\n\t\t\tr[2] = (t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=0;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tt = a[3];\n\t\t\tr[3] = (t-c)&BN_MASK2;\n\t\t\tif (t != 0) c=0;\n\t\t\tif (--dl <= 0) break;\n\n\t\t\tsave_dl = dl;\n\t\t\ta += 4;\n\t\t\tr += 4;\n\t\t\t}\n\t\tif (dl > 0)\n\t\t\t{\n\t\t\tif (save_dl > dl)\n\t\t\t\t{\n\t\t\t\tswitch (save_dl - dl)\n\t\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tr[1] = a[1];\n\t\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tcase 2:\n\t\t\t\t\tr[2] = a[2];\n\t\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tcase 3:\n\t\t\t\t\tr[3] = a[3];\n\t\t\t\t\tif (--dl <= 0) break;\n\t\t\t\t\t}\n\t\t\t\ta += 4;\n\t\t\t\tr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\tif (dl > 0)\n\t\t\t{\n\t\t\tfor(;;)\n\t\t\t\t{\n\t\t\t\tr[0] = a[0];\n\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tr[1] = a[1];\n\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tr[2] = a[2];\n\t\t\t\tif (--dl <= 0) break;\n\t\t\t\tr[3] = a[3];\n\t\t\t\tif (--dl <= 0) break;\n\n\t\t\t\ta += 4;\n\t\t\t\tr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn c;\n\t}", "target": 1}
{"idx": 4937, "func": "int tls13_export_keying_material_early(SSL *s, unsigned char *out, size_t olen,\n                                       const char *label, size_t llen,\n                                       const unsigned char *context,\n                                       size_t contextlen)\n{\n    static const unsigned char exporterlabel[] = \"exporter\";\n    unsigned char exportsecret[EVP_MAX_MD_SIZE];\n    unsigned char hash[EVP_MAX_MD_SIZE], data[EVP_MAX_MD_SIZE];\n    const EVP_MD *md;\n    EVP_MD_CTX *ctx = EVP_MD_CTX_new();\n    unsigned int hashsize, datalen;\n    int ret = 0;\n    const SSL_CIPHER *sslcipher;\n\n    if (ctx == NULL || !ossl_statem_export_early_allowed(s))\n        goto err;\n\n    if (!s->server && s->max_early_data > 0\n            && s->session->ext.max_early_data == 0)\n        sslcipher = SSL_SESSION_get0_cipher(s->psksession);\n    else\n        sslcipher = SSL_SESSION_get0_cipher(s->session);\n\n    md = ssl_md(sslcipher->algorithm2);\n\n    /*\n     * Calculate the hash value and store it in |data|. The reason why\n     * the empty string is used is that the definition of TLS-Exporter\n     * is like so:\n     *\n     * TLS-Exporter(label, context_value, key_length) =\n     *     HKDF-Expand-Label(Derive-Secret(Secret, label, \"\"),\n     *                       \"exporter\", Hash(context_value), key_length)\n     *\n     * Derive-Secret(Secret, Label, Messages) =\n     *       HKDF-Expand-Label(Secret, Label,\n     *                         Transcript-Hash(Messages), Hash.length)\n     *\n     * Here Transcript-Hash is the cipher suite hash algorithm.\n     */\n    if (EVP_DigestInit_ex(ctx, md, NULL) <= 0\n            || EVP_DigestUpdate(ctx, context, contextlen) <= 0\n            || EVP_DigestFinal_ex(ctx, hash, &hashsize) <= 0\n            || EVP_DigestInit_ex(ctx, md, NULL) <= 0\n            || EVP_DigestFinal_ex(ctx, data, &datalen) <= 0\n            || !tls13_hkdf_expand(s, md, s->early_exporter_master_secret,\n                                  (const unsigned char *)label, llen,\n                                  data, datalen, exportsecret, hashsize, 0)\n            || !tls13_hkdf_expand(s, md, exportsecret, exporterlabel,\n                                  sizeof(exporterlabel) - 1, hash, hashsize,\n                                  out, olen, 0))\n        goto err;\n\n    ret = 1;\n err:\n    EVP_MD_CTX_free(ctx);\n    return ret;\n}", "target": 0}
{"idx": 4938, "func": "static apr_status_t send_brigade_nonblocking(apr_socket_t *s,\n                                             apr_bucket_brigade *bb,\n                                             core_output_filter_ctx_t *ctx,\n                                             conn_rec *c)\n{\n    apr_status_t rv = APR_SUCCESS;\n    core_server_config *conf =\n        ap_get_core_module_config(c->base_server->module_config);\n    apr_size_t nvec = 0, nbytes = 0;\n    apr_bucket *bucket, *next;\n    const char *data;\n    apr_size_t length;\n\n    for (bucket = APR_BRIGADE_FIRST(bb);\n         bucket != APR_BRIGADE_SENTINEL(bb);\n         bucket = next) {\n        next = APR_BUCKET_NEXT(bucket);\n\n#if APR_HAS_SENDFILE\n        if (can_sendfile_bucket(bucket)) {\n            if (nvec > 0) {\n                (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 1);\n                rv = writev_nonblocking(s, bb, ctx, nbytes, nvec, c);\n                if (rv != APR_SUCCESS) {\n                    goto cleanup;\n                }\n                nbytes = 0;\n                nvec = 0;\n            }\n            rv = sendfile_nonblocking(s, bucket, ctx, c);\n            if (rv != APR_SUCCESS) {\n                goto cleanup;\n            }\n            continue;\n        }\n#endif /* APR_HAS_SENDFILE */\n\n        if (bucket->length) {\n            /* Non-blocking read first, in case this is a morphing\n             * bucket type. */\n            rv = apr_bucket_read(bucket, &data, &length, APR_NONBLOCK_READ);\n            if (APR_STATUS_IS_EAGAIN(rv)) {\n                /* Read would block; flush any pending data and retry. */\n                if (nvec) {\n                    rv = writev_nonblocking(s, bb, ctx, nbytes, nvec, c);\n                    if (rv != APR_SUCCESS) {\n                        goto cleanup;\n                    }\n                    nbytes = 0;\n                    nvec = 0;\n                }\n                (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 0);\n\n                rv = apr_bucket_read(bucket, &data, &length, APR_BLOCK_READ);\n            }\n            if (rv != APR_SUCCESS) {\n                goto cleanup;\n            }\n\n            /* reading may have split the bucket, so recompute next: */\n            next = APR_BUCKET_NEXT(bucket);\n        }\n\n        if (!bucket->length) {\n            /* Don't delete empty buckets until all the previous ones have been\n             * sent (nvec == 0); this must happen in sequence since metabuckets\n             * like EOR could free the data still pointed to by the iovec. So\n             * unless the latter is empty, let writev_nonblocking() cleanup the\n             * brigade in order.\n             */\n            if (!nvec) {\n                apr_bucket_delete(bucket);\n            }\n            continue;\n        }\n\n        /* Make sure that these new data fit in our iovec. */\n        if (nvec == ctx->nvec) {\n            if (nvec == NVEC_MAX) {\n                (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 1);\n                rv = writev_nonblocking(s, bb, ctx, nbytes, nvec, c);\n                if (rv != APR_SUCCESS) {\n                    goto cleanup;\n                }\n                nbytes = 0;\n                nvec = 0;\n            }\n            else {\n                struct iovec *newvec;\n                apr_size_t newn = nvec * 2;\n                if (newn < NVEC_MIN) {\n                    newn = NVEC_MIN;\n                }\n                else if (newn > NVEC_MAX) {\n                    newn = NVEC_MAX;\n                }\n                newvec = apr_palloc(c->pool, newn * sizeof(struct iovec));\n                if (nvec) {\n                    memcpy(newvec, ctx->vec, nvec * sizeof(struct iovec));\n                }\n                ctx->vec = newvec;\n                ctx->nvec = newn;\n            }\n        }\n        nbytes += length;\n        ctx->vec[nvec].iov_base = (void *)data;\n        ctx->vec[nvec].iov_len = length;\n        nvec++;\n\n        /* Flush above max threshold, unless the brigade still contains in\n         * memory buckets which we want to try writing in the same pass (if\n         * we are at the end of the brigade, the write will happen outside\n         * the loop anyway).\n         */\n        if (nbytes >= conf->flush_max_threshold\n                && next != APR_BRIGADE_SENTINEL(bb)\n                && !is_in_memory_bucket(next)) {\n            (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 1);\n            rv = writev_nonblocking(s, bb, ctx, nbytes, nvec, c);\n            if (rv != APR_SUCCESS) {\n                goto cleanup;\n            }\n            nbytes = 0;\n            nvec = 0;\n        }\n    }\n    if (nvec > 0) {\n        rv = writev_nonblocking(s, bb, ctx, nbytes, nvec, c);\n    }\n\ncleanup:\n    (void)apr_socket_opt_set(s, APR_TCP_NOPUSH, 0);\n    return rv;\n}", "target": 0}
{"idx": 4939, "func": "static void reverse_dc_prediction(Vp3DecodeContext *s,\n                                  int first_fragment,\n                                  int fragment_width,\n                                  int fragment_height)\n{\n\n#define PUL 8\n#define PU 4\n#define PUR 2\n#define PL 1\n\n    int x, y;\n    int i = first_fragment;\n\n    int predicted_dc;\n\n    /* DC values for the left, up-left, up, and up-right fragments */\n    int vl, vul, vu, vur;\n\n    /* indexes for the left, up-left, up, and up-right fragments */\n    int l, ul, u, ur;\n\n    /*\n     * The 6 fields mean:\n     *   0: up-left multiplier\n     *   1: up multiplier\n     *   2: up-right multiplier\n     *   3: left multiplier\n     */\n    static const int predictor_transform[16][4] = {\n        {  0,  0,  0,  0},\n        {  0,  0,  0,128},        // PL\n        {  0,  0,128,  0},        // PUR\n        {  0,  0, 53, 75},        // PUR|PL\n        {  0,128,  0,  0},        // PU\n        {  0, 64,  0, 64},        // PU|PL\n        {  0,128,  0,  0},        // PU|PUR\n        {  0,  0, 53, 75},        // PU|PUR|PL\n        {128,  0,  0,  0},        // PUL\n        {  0,  0,  0,128},        // PUL|PL\n        { 64,  0, 64,  0},        // PUL|PUR\n        {  0,  0, 53, 75},        // PUL|PUR|PL\n        {  0,128,  0,  0},        // PUL|PU\n       {-104,116,  0,116},        // PUL|PU|PL\n        { 24, 80, 24,  0},        // PUL|PU|PUR\n       {-104,116,  0,116}         // PUL|PU|PUR|PL\n    };\n\n    /* This table shows which types of blocks can use other blocks for\n     * prediction. For example, INTRA is the only mode in this table to\n     * have a frame number of 0. That means INTRA blocks can only predict\n     * from other INTRA blocks. There are 2 golden frame coding types;\n     * blocks encoding in these modes can only predict from other blocks\n     * that were encoded with these 1 of these 2 modes. */\n    static const unsigned char compatible_frame[8] = {\n        1,    /* MODE_INTER_NO_MV */\n        0,    /* MODE_INTRA */\n        1,    /* MODE_INTER_PLUS_MV */\n        1,    /* MODE_INTER_LAST_MV */\n        1,    /* MODE_INTER_PRIOR_MV */\n        2,    /* MODE_USING_GOLDEN */\n        2,    /* MODE_GOLDEN_MV */\n        1     /* MODE_INTER_FOUR_MV */\n    };\n    int current_frame_type;\n\n    /* there is a last DC predictor for each of the 3 frame types */\n    short last_dc[3];\n\n    int transform = 0;\n\n    vul = vu = vur = vl = 0;\n    last_dc[0] = last_dc[1] = last_dc[2] = 0;\n\n    /* for each fragment row... */\n    for (y = 0; y < fragment_height; y++) {\n\n        /* for each fragment in a row... */\n        for (x = 0; x < fragment_width; x++, i++) {\n\n            /* reverse prediction if this block was coded */\n            if (s->all_fragments[i].coding_method != MODE_COPY) {\n\n                current_frame_type =\n                    compatible_frame[s->all_fragments[i].coding_method];\n\n                transform= 0;\n                if(x){\n                    l= i-1;\n                    vl = DC_COEFF(l);\n                    if(FRAME_CODED(l) && COMPATIBLE_FRAME(l))\n                        transform |= PL;\n                }\n                if(y){\n                    u= i-fragment_width;\n                    vu = DC_COEFF(u);\n                    if(FRAME_CODED(u) && COMPATIBLE_FRAME(u))\n                        transform |= PU;\n                    if(x){\n                        ul= i-fragment_width-1;\n                        vul = DC_COEFF(ul);\n                        if(FRAME_CODED(ul) && COMPATIBLE_FRAME(ul))\n                            transform |= PUL;\n                    }\n                    if(x + 1 < fragment_width){\n                        ur= i-fragment_width+1;\n                        vur = DC_COEFF(ur);\n                        if(FRAME_CODED(ur) && COMPATIBLE_FRAME(ur))\n                            transform |= PUR;\n                    }\n                }\n\n                if (transform == 0) {\n\n                    /* if there were no fragments to predict from, use last\n                     * DC saved */\n                    predicted_dc = last_dc[current_frame_type];\n                } else {\n\n                    /* apply the appropriate predictor transform */\n                    predicted_dc =\n                        (predictor_transform[transform][0] * vul) +\n                        (predictor_transform[transform][1] * vu) +\n                        (predictor_transform[transform][2] * vur) +\n                        (predictor_transform[transform][3] * vl);\n\n                    predicted_dc /= 128;\n\n                    /* check for outranging on the [ul u l] and\n                     * [ul u ur l] predictors */\n                    if ((transform == 13) || (transform == 15)) {\n                        if (FFABS(predicted_dc - vu) > 128)\n                            predicted_dc = vu;\n                        else if (FFABS(predicted_dc - vl) > 128)\n                            predicted_dc = vl;\n                        else if (FFABS(predicted_dc - vul) > 128)\n                            predicted_dc = vul;\n                    }\n                }\n\n                /* at long last, apply the predictor */\n                if(s->coeffs[i].index){\n                    *s->next_coeff= s->coeffs[i];\n                    s->coeffs[i].index=0;\n                    s->coeffs[i].coeff=0;\n                    s->coeffs[i].next= s->next_coeff++;\n                }\n                s->coeffs[i].coeff += predicted_dc;\n                /* save the DC */\n                last_dc[current_frame_type] = DC_COEFF(i);\n                if(DC_COEFF(i) && !(s->coeff_counts[i]&127)){\n                    s->coeff_counts[i]= 129;\n//                    s->all_fragments[i].next_coeff= s->next_coeff;\n                    s->coeffs[i].next= s->next_coeff;\n                    (s->next_coeff++)->next=NULL;\n                }\n            }\n        }\n    }\n}", "target": 1}
{"idx": 4940, "func": "static AVFilterLink *graph_run_once_find_filter(AVFilterGraph *graph)\n{\n    unsigned i, j;\n    AVFilterContext *f;\n\n    /* TODO: replace scanning the graph with a priority list */\n    for (i = 0; i < graph->nb_filters; i++) {\n        f = graph->filters[i];\n        for (j = 0; j < f->nb_outputs; j++)\n            if (f->outputs[j]->frame_wanted_in)\n                return f->outputs[j];\n    }\n    for (i = 0; i < graph->nb_filters; i++) {\n        f = graph->filters[i];\n        for (j = 0; j < f->nb_outputs; j++)\n            if (f->outputs[j]->frame_wanted_out)\n                return f->outputs[j];\n    }\n    return NULL;\n}", "target": 1}
{"idx": 4941, "func": "static void\ndoapr_outch(\n    char **buffer,\n    size_t *currlen,\n    size_t *maxlen,\n    int c)\n{\n    if (*buffer == NULL) {\n\tif (*maxlen == 0)\n\t    *maxlen = 1024;\n\t*buffer = Malloc(*maxlen);\n    }\n    while (*currlen >= *maxlen) {\n\t*maxlen += 1024;\n\t*buffer = Realloc(*buffer, *maxlen);\n    }\n    /* What to do if *buffer is NULL? */\n    assert(*buffer != NULL);\n\n    (*buffer)[(*currlen)++] = (char)c;\n    return;\n}", "target": 0}
{"idx": 4942, "func": "static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,\n                                 int *got_frame_ptr, AVPacket *avpkt)\n{\n    EightSvxContext *esc = avctx->priv_data;\n    int n, out_data_size;\n    int ch, ret;\n    uint8_t *src;\n\n    /* decode and interleave the first packet */\n    if (!esc->samples && avpkt) {\n        int packet_size = avpkt->size;\n\n        if (packet_size % avctx->channels) {\n            av_log(avctx, AV_LOG_WARNING, \"Packet with odd size, ignoring last byte\\n\");\n            if (packet_size < avctx->channels)\n                return packet_size;\n            packet_size -= packet_size % avctx->channels;\n        }\n        esc->samples_size = !esc->table ?\n            packet_size : avctx->channels + (packet_size-avctx->channels) * 2;\n        if (!(esc->samples = av_malloc(esc->samples_size)))\n            return AVERROR(ENOMEM);\n\n        /* decompress */\n        if (esc->table) {\n            const uint8_t *buf = avpkt->data;\n            uint8_t *dst;\n            int buf_size = avpkt->size;\n            int i, n = esc->samples_size;\n\n            if (buf_size < 2) {\n                av_log(avctx, AV_LOG_ERROR, \"packet size is too small\\n\");\n                return AVERROR(EINVAL);\n            }\n\n            /* the uncompressed starting value is contained in the first byte */\n            dst = esc->samples;\n            for (i = 0; i < avctx->channels; i++) {\n                *(dst++) = buf[0]+128;\n                delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0]+128)&0xFF, esc->table);\n                buf += buf_size / avctx->channels;\n                dst += n / avctx->channels - 1;\n            }\n        } else {\n            raw_decode(esc->samples, avpkt->data, esc->samples_size);\n        }\n    }\n\n    /* get output buffer */\n    av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels));\n    esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - esc->samples_idx)  / avctx->channels;\n    if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = esc->frame;\n\n    out_data_size = esc->frame.nb_samples;\n    for (ch = 0; ch<avctx->channels; ch++) {\n        src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels;\n        memcpy(esc->frame.data[ch], src, out_data_size);\n    }\n    out_data_size *= avctx->channels;\n    esc->samples_idx += out_data_size;\n\n    return esc->table ?\n        (avctx->frame_number == 0)*2 + out_data_size / 2 :\n        out_data_size;\n}", "target": 1}
{"idx": 4943, "func": "int BN_set_word(BIGNUM *a, BN_ULONG w)\n{\n    bn_check_top(a);\n    if (bn_expand(a, (int)sizeof(BN_ULONG) * 8) == NULL)\n        return 0;\n    a->neg = 0;\n    a->d[0] = w;\n    a->top = (w ? 1 : 0);\n    a->flags &= ~BN_FLG_FIXED_TOP;\n    bn_check_top(a);\n    return 1;\n}", "target": 1}
{"idx": 4944, "func": "void BN_CTX_init(BN_CTX *ctx)\n\t{\n\t/* Assume the caller obtained the context via BN_CTX_new() and so is\n\t * trying to reset it for use. Nothing else makes sense, least of all\n\t * binary compatibility from a time when they could declare a static\n\t * variable. */\n\tBN_POOL_reset(&ctx->pool);\n\tBN_STACK_reset(&ctx->stack);\n\tctx->used = 0;\n\tctx->err_stack = 0;\n\tctx->too_many = 0;\n\t}", "target": 0}
{"idx": 4945, "func": "int ff_wmv2_decode_secondary_picture_header(MpegEncContext *s)\n{\n    Wmv2Context *const w = (Wmv2Context *) s;\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        if (w->j_type_bit)\n            w->j_type = get_bits1(&s->gb);\n        else\n            w->j_type = 0; // FIXME check\n\n        if (!w->j_type) {\n            if (w->per_mb_rl_bit)\n                s->per_mb_rl_table = get_bits1(&s->gb);\n            else\n                s->per_mb_rl_table = 0;\n\n            if (!s->per_mb_rl_table) {\n                s->rl_chroma_table_index = decode012(&s->gb);\n                s->rl_table_index        = decode012(&s->gb);\n            }\n\n            s->dc_table_index = get_bits1(&s->gb);\n        }\n        s->inter_intra_pred = 0;\n        s->no_rounding      = 1;\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n            av_log(s->avctx, AV_LOG_DEBUG,\n                   \"qscale:%d rlc:%d rl:%d dc:%d mbrl:%d j_type:%d \\n\",\n                   s->qscale, s->rl_chroma_table_index, s->rl_table_index,\n                   s->dc_table_index, s->per_mb_rl_table, w->j_type);\n        }\n    } else {\n        int cbp_index;\n        w->j_type = 0;\n\n        parse_mb_skip(w);\n        cbp_index = decode012(&s->gb);\n        w->cbp_table_index = wmv2_get_cbp_table_index(s, cbp_index);\n\n        if (w->mspel_bit)\n            s->mspel = get_bits1(&s->gb);\n        else\n            s->mspel = 0; // FIXME check\n\n        if (w->abt_flag) {\n            w->per_mb_abt = get_bits1(&s->gb) ^ 1;\n            if (!w->per_mb_abt)\n                w->abt_type = decode012(&s->gb);\n        }\n\n        if (w->per_mb_rl_bit)\n            s->per_mb_rl_table = get_bits1(&s->gb);\n        else\n            s->per_mb_rl_table = 0;\n\n        if (!s->per_mb_rl_table) {\n            s->rl_table_index        = decode012(&s->gb);\n            s->rl_chroma_table_index = s->rl_table_index;\n        }\n\n        s->dc_table_index   = get_bits1(&s->gb);\n        s->mv_table_index   = get_bits1(&s->gb);\n\n        s->inter_intra_pred = 0; // (s->width * s->height < 320 * 240 && s->bit_rate <= II_BITRATE);\n        s->no_rounding     ^= 1;\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n            av_log(s->avctx, AV_LOG_DEBUG,\n                   \"rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d mspel:%d \"\n                   \"per_mb_abt:%d abt_type:%d cbp:%d ii:%d\\n\",\n                   s->rl_table_index, s->rl_chroma_table_index,\n                   s->dc_table_index, s->mv_table_index,\n                   s->per_mb_rl_table, s->qscale, s->mspel,\n                   w->per_mb_abt, w->abt_type, w->cbp_table_index,\n                   s->inter_intra_pred);\n        }\n    }\n    s->esc3_level_length = 0;\n    s->esc3_run_length   = 0;\n    s->picture_number++; // FIXME ?\n\n    if (w->j_type) {\n        ff_intrax8_decode_picture(&w->x8, &s->current_picture,\n                                  &s->gb, &s->mb_x, &s->mb_y,\n                                  2 * s->qscale, (s->qscale - 1) | 1,\n                                  s->loop_filter, s->low_delay);\n\n        ff_er_add_slice(&w->s.er, 0, 0,\n                        (w->s.mb_x >> 1) - 1, (w->s.mb_y >> 1) - 1,\n                        ER_MB_END);\n        return 1;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 4946, "func": "static int pkey_gost94_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey,int type)\n\t{\n\tstruct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(ctx);\n\tDSA *dsa=NULL;\n\tif (data->sign_param_nid == NID_undef)\n\t\t{\n\t\tif (type== NID_id_GostR3410_94_cc)\n\t\t\t{\n\t\t\tdata->sign_param_nid = NID_id_GostR3410_94_CryptoPro_A_ParamSet;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tGOSTerr(GOST_F_PKEY_GOST94_KEYGEN,\n\t\t\t\tGOST_R_NO_PARAMETERS_SET);\n\t\t\treturn 0;\n\t\t\t}\t\n\t\t}\n\tdsa = DSA_new();\n\tif (!fill_GOST94_params(dsa,data->sign_param_nid))\n\t\t{\n\t\tDSA_free(dsa);\n\t\treturn 0;\n\t\t}\n\tgost_sign_keygen(dsa);\n\tEVP_PKEY_assign(pkey,type,dsa);\n\treturn 1;\n\t}", "target": 1}
{"idx": 4947, "func": "static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)\n{\n    int sum, i, j;\n    int *coeffs = s->coeffs;\n\n    for (i=0; i<pred_order; i++)\n        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);\n\n    for (i=0; i < s->blocksize; i++) {\n        sum = s->lpcqoffset;\n        for (j=0; j<pred_order; j++)\n            sum += coeffs[j] * s->decoded[channel][i-j-1];\n        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);\n    }\n}", "target": 0}
{"idx": 4948, "func": "static inline void tm2_high_chroma(int *data, int stride, int *last, int *CD, int *deltas)\n{\n    int i, j;\n    for (j = 0; j < 2; j++) {\n        for (i = 0; i < 2; i++)  {\n            CD[j]   += deltas[i + j * 2];\n            last[i] += CD[j];\n            data[i]  = last[i];\n        }\n        data += stride;\n    }\n}", "target": 1}
{"idx": 4949, "func": "int ff_interleave_packet_per_dts(AVFormatContext *s, AVPacket *out,\n                                 AVPacket *pkt, int flush)\n{\n    AVPacketList *pktl;\n    int stream_count = 0;\n    int i, ret;\n\n    if (pkt) {\n        if ((ret = ff_interleave_add_packet(s, pkt, interleave_compare_dts)) < 0)\n            return ret;\n    }\n\n    if (s->max_interleave_delta > 0 && s->internal->packet_buffer && !flush) {\n        AVPacket *top_pkt = &s->internal->packet_buffer->pkt;\n        int64_t delta_dts = INT64_MIN;\n        int64_t top_dts = av_rescale_q(top_pkt->dts,\n                                       s->streams[top_pkt->stream_index]->time_base,\n                                       AV_TIME_BASE_Q);\n\n        for (i = 0; i < s->nb_streams; i++) {\n            int64_t last_dts;\n            const AVPacketList *last = s->streams[i]->last_in_packet_buffer;\n\n            if (!last)\n                continue;\n\n            last_dts = av_rescale_q(last->pkt.dts,\n                                    s->streams[i]->time_base,\n                                    AV_TIME_BASE_Q);\n            delta_dts = FFMAX(delta_dts, last_dts - top_dts);\n            stream_count++;\n        }\n\n        if (delta_dts > s->max_interleave_delta) {\n            av_log(s, AV_LOG_DEBUG,\n                   \"Delay between the first packet and last packet in the \"\n                   \"muxing queue is %\"PRId64\" > %\"PRId64\": forcing output\\n\",\n                   delta_dts, s->max_interleave_delta);\n            flush = 1;\n        }\n    } else {\n        for (i = 0; i < s->nb_streams; i++)\n            stream_count += !!s->streams[i]->last_in_packet_buffer;\n    }\n\n\n    if (stream_count && (s->internal->nb_interleaved_streams == stream_count || flush)) {\n        pktl = s->internal->packet_buffer;\n        *out = pktl->pkt;\n\n        s->internal->packet_buffer = pktl->next;\n        if (!s->internal->packet_buffer)\n            s->internal->packet_buffer_end = NULL;\n\n        if (s->streams[out->stream_index]->last_in_packet_buffer == pktl)\n            s->streams[out->stream_index]->last_in_packet_buffer = NULL;\n        av_freep(&pktl);\n        return 1;\n    } else {\n        av_init_packet(out);\n        return 0;\n    }\n}", "target": 1}
{"idx": 4950, "func": "int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame,\n                             int64_t pts, AVRational pixel_aspect)\n{\n    BufferSourceContext *c = buffer_filter->priv;\n    AVFilterBufferRef *buf;\n    int ret;\n\n    if (!buf) {\n        c->eof = 1;\n        return 0;\n    } else if (c->eof)\n        return AVERROR(EINVAL);\n\n    if (!av_fifo_space(c->fifo) &&\n        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +\n                                         sizeof(buf))) < 0)\n        return ret;\n\n    CHECK_PARAM_CHANGE(buffer_filter, c, frame->width, frame->height, frame->format);\n\n    buf = avfilter_get_video_buffer(buffer_filter->outputs[0], AV_PERM_WRITE,\n                                    c->w, c->h);\n    av_image_copy(buf->data, buf->linesize, frame->data, frame->linesize,\n                  c->pix_fmt, c->w, c->h);\n\n    avfilter_copy_frame_props(buf, frame);\n    buf->pts                    = pts;\n    buf->video->pixel_aspect    = pixel_aspect;\n\n    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {\n        avfilter_unref_buffer(buf);\n        return ret;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 4951, "func": "static void get_lag(float *buf, const float *new, LongTermPrediction *ltp)\n{\n    int i, j, lag, max_corr = 0;\n    float max_ratio;\n    for (i = 0; i < 2048; i++) {\n        float corr, s0 = 0.0f, s1 = 0.0f;\n        const int start = FFMAX(0, i - 1024);\n        for (j = start; j < 2048; j++) {\n            const int idx = j - i + 1024;\n            s0 += new[j]*buf[idx];\n            s1 += buf[idx]*buf[idx];\n        }\n        corr = s1 > 0.0f ? s0/sqrt(s1) : 0.0f;\n        if (corr > max_corr) {\n            max_corr = corr;\n            lag = i;\n            max_ratio = corr/(2048-start);\n        }\n    }\n    ltp->lag = FFMAX(av_clip_uintp2(lag, 11), 0);\n    ltp->coef_idx = quant_array_idx(max_ratio, ltp_coef, 8);\n    ltp->coef = ltp_coef[ltp->coef_idx];\n}", "target": 1}
{"idx": 4952, "func": "static int\nrdt_parse_sdp_line (AVFormatContext *s, int st_index,\n                    PayloadContext *rdt, const char *line)\n{\n    AVStream *stream = s->streams[st_index];\n    const char *p = line;\n\n    if (av_strstart(p, \"OpaqueData:buffer;\", &p)) {\n        rdt->mlti_data = rdt_parse_b64buf(&rdt->mlti_data_size, p);\n    } else if (av_strstart(p, \"StartTime:integer;\", &p))\n        stream->first_dts = atoi(p);\n    else if (av_strstart(p, \"ASMRuleBook:string;\", &p)) {\n        int n, first = -1;\n\n        for (n = 0; n < s->nb_streams; n++)\n            if (s->streams[n]->priv_data == stream->priv_data) {\n                int count = s->streams[n]->index + 1;\n                if (first == -1) first = n;\n                if (rdt->nb_rmst < count) {\n                    RMStream **rmst= av_realloc(rdt->rmst, count*sizeof(*rmst));\n                    if (!rmst)\n                        return AVERROR(ENOMEM);\n                    memset(rmst + rdt->nb_rmst, 0,\n                           (count - rdt->nb_rmst) * sizeof(*rmst));\n                    rdt->rmst    = rmst;\n                    rdt->nb_rmst = count;\n                }\n                rdt->rmst[s->streams[n]->index] = ff_rm_alloc_rmstream();\n                rdt_load_mdpr(rdt, s->streams[n], (n - first) * 2);\n\n                if (s->streams[n]->codec->codec_id == CODEC_ID_AAC)\n                    s->streams[n]->codec->frame_size = 1; // FIXME\n           }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 4953, "func": "int BN_num_bits_word(BN_ULONG l)\n\t{\n\tstatic const char bits[256]={\n\t\t0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,\n\t\t5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n\t\t6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n\t\t6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n\t\t7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n\t\t7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n\t\t7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n\t\t7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n\t\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t\t8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n\t\t};\n\n#if defined(SIXTY_FOUR_BIT_LONG)\n\tif (l & 0xffffffff00000000L)\n\t\t{\n\t\tif (l & 0xffff000000000000L)\n\t\t\t{\n\t\t\tif (l & 0xff00000000000000L)\n\t\t\t\t{\n\t\t\t\treturn(bits[(int)(l>>56)]+56);\n\t\t\t\t}\n\t\t\telse\treturn(bits[(int)(l>>48)]+48);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif (l & 0x0000ff0000000000L)\n\t\t\t\t{\n\t\t\t\treturn(bits[(int)(l>>40)]+40);\n\t\t\t\t}\n\t\t\telse\treturn(bits[(int)(l>>32)]+32);\n\t\t\t}\n\t\t}\n\telse\n#else\n#ifdef SIXTY_FOUR_BIT\n\tif (l & 0xffffffff00000000LL)\n\t\t{\n\t\tif (l & 0xffff000000000000LL)\n\t\t\t{\n\t\t\tif (l & 0xff00000000000000LL)\n\t\t\t\t{\n\t\t\t\treturn(bits[(int)(l>>56)]+56);\n\t\t\t\t}\n\t\t\telse\treturn(bits[(int)(l>>48)]+48);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif (l & 0x0000ff0000000000LL)\n\t\t\t\t{\n\t\t\t\treturn(bits[(int)(l>>40)]+40);\n\t\t\t\t}\n\t\t\telse\treturn(bits[(int)(l>>32)]+32);\n\t\t\t}\n\t\t}\n\telse\n#endif\n#endif\n\t\t{\n#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\n\t\tif (l & 0xffff0000L)\n\t\t\t{\n\t\t\tif (l & 0xff000000L)\n\t\t\t\treturn(bits[(int)(l>>24L)]+24);\n\t\t\telse\treturn(bits[(int)(l>>16L)]+16);\n\t\t\t}\n\t\telse\n#endif\n\t\t\t{\n#if defined(SIXTEEN_BIT) || defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\n\t\t\tif (l & 0xff00L)\n\t\t\t\treturn(bits[(int)(l>>8)]+8);\n\t\t\telse\t\n#endif\n\t\t\t\treturn(bits[(int)(l   )]  );\n\t\t\t}\n\t\t}\n\t}", "target": 1}
{"idx": 4954, "func": "static int read_request_line(request_rec *r, apr_bucket_brigade *bb)\n{\n    const char *ll;\n    const char *uri;\n    const char *pro;\n\n    unsigned int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-\"HTTP\" protocol */\n    char http[5];\n    apr_size_t len;\n    int num_blank_lines = DEFAULT_LIMIT_BLANK_LINES;\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    int strict = conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT;\n    int enforce_strict = !(conf->http_conformance & AP_HTTP_CONFORMANCE_LOGONLY);\n\n    /* Read past empty lines until we get a real request line,\n     * a read error, the connection closes (EOF), or we timeout.\n     *\n     * We skip empty lines because browsers have to tack a CRLF on to the end\n     * of POSTs to support old CERN webservers.  But note that we may not\n     * have flushed any previous response completely to the client yet.\n     * We delay the flush as long as possible so that we can improve\n     * performance for clients that are pipelining requests.  If a request\n     * is pipelined then we won't block during the (implicit) read() below.\n     * If the requests aren't pipelined, then the client is still waiting\n     * for the final buffer flush from us, and we will block in the implicit\n     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will\n     * have to block during a read.\n     */\n\n    do {\n        apr_status_t rv;\n\n        /* ensure ap_rgetline allocates memory each time thru the loop\n         * if there are empty lines\n         */\n        r->the_request = NULL;\n        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            r->request_time = apr_time_now();\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the\n             * buffer before finding the end-of-line.  This is only going to\n             * happen if it exceeds the configured limit for a request-line.\n             */\n            if (APR_STATUS_IS_ENOSPC(rv)) {\n                r->status    = HTTP_REQUEST_URI_TOO_LARGE;\n            }\n            else if (APR_STATUS_IS_TIMEUP(rv)) {\n                r->status = HTTP_REQUEST_TIME_OUT;\n            }\n            else if (APR_STATUS_IS_EINVAL(rv)) {\n                r->status = HTTP_BAD_REQUEST;\n            }\n            r->proto_num = HTTP_VERSION(1,0);\n            r->protocol  = apr_pstrdup(r->pool, \"HTTP/1.0\");\n            return 0;\n        }\n    } while ((len <= 0) && (--num_blank_lines >= 0));\n\n    if (APLOGrtrace5(r)) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE5, 0, r,\n                      \"Request received from client: %s\",\n                      ap_escape_logitem(r->pool, r->the_request));\n    }\n\n    r->request_time = apr_time_now();\n    ll = r->the_request;\n    r->method = ap_getword_white(r->pool, &ll);\n\n    uri = ap_getword_white(r->pool, &ll);\n\n    if (!*r->method || !*uri) {\n        r->status    = HTTP_BAD_REQUEST;\n        r->proto_num = HTTP_VERSION(1,0);\n        r->protocol  = apr_pstrdup(r->pool, \"HTTP/1.0\");\n        return 0;\n    }\n\n    /* Provide quick information about the request method as soon as known */\n\n    r->method_number = ap_method_number_of(r->method);\n    if (r->method_number == M_GET && r->method[0] == 'H') {\n        r->header_only = 1;\n    }\n\n    ap_parse_uri(r, uri);\n    if (r->status != HTTP_OK) {\n        return 0;\n    }\n\n    if (ll[0]) {\n        r->assbackwards = 0;\n        pro = ll;\n        len = strlen(ll);\n    } else {\n        r->assbackwards = 1;\n        pro = \"HTTP/0.9\";\n        len = 8;\n        if (conf->http09_enable == AP_HTTP09_DISABLE) {\n                r->status = HTTP_VERSION_NOT_SUPPORTED;\n                r->protocol = apr_pstrmemdup(r->pool, pro, len);\n                /* If we deny 0.9, send error message with 1.x */\n                r->assbackwards = 0;\n                r->proto_num = HTTP_VERSION(0, 9);\n                r->connection->keepalive = AP_CONN_CLOSE;\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02401)\n                              \"HTTP/0.9 denied by server configuration\");\n                return 0;\n        }\n    }\n    r->protocol = apr_pstrmemdup(r->pool, pro, len);\n\n    /* Avoid sscanf in the common case */\n    if (len == 8\n        && pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P'\n        && pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.'\n        && apr_isdigit(pro[7])) {\n        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');\n    }\n    else {\n        if (strict) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02418)\n                          \"Invalid protocol '%s'\", r->protocol);\n            if (enforce_strict) {\n                r->proto_num = HTTP_VERSION(1,0);\n                r->protocol  = apr_pstrdup(r->pool, \"HTTP/1.0\");\n                r->connection->keepalive = AP_CONN_CLOSE;\n                r->status = HTTP_BAD_REQUEST;\n                return 0;\n            }\n        }\n        if (3 == sscanf(r->protocol, \"%4s/%u.%u\", http, &major, &minor)\n            && (strcasecmp(\"http\", http) == 0)\n            && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */\n            r->proto_num = HTTP_VERSION(major, minor);\n        }\n        else {\n            r->proto_num = HTTP_VERSION(1, 0);\n        }\n    }\n\n    if (strict) {\n        int err = 0;\n        if (ap_has_cntrl(r->the_request)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02420)\n                          \"Request line must not contain control characters\");\n            err = HTTP_BAD_REQUEST;\n        }\n        if (r->parsed_uri.fragment) {\n            /* RFC3986 3.5: no fragment */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02421)\n                          \"URI must not contain a fragment\");\n            err = HTTP_BAD_REQUEST;\n        }\n        else if (r->parsed_uri.user || r->parsed_uri.password) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02422)\n                          \"URI must not contain a username/password\");\n            err = HTTP_BAD_REQUEST;\n        }\n        else if (r->method_number == M_INVALID) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02423)\n                          \"Invalid HTTP method string: %s\", r->method);\n            err = HTTP_NOT_IMPLEMENTED;\n        }\n        else if (r->assbackwards == 0 && r->proto_num < HTTP_VERSION(1, 0)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02424)\n                          \"HTTP/0.x does not take a protocol\");\n            err = HTTP_BAD_REQUEST;\n        }\n\n        if (err && enforce_strict) {\n            r->status = err;\n            return 0;\n        }\n    }\n\n    return 1;\n}", "target": 0}
{"idx": 4955, "func": "static int ljpeg_decode_yuv_scan(MJpegDecodeContext *s, int predictor,\n                                 int point_transform)\n{\n    int i, mb_x, mb_y;\n    const int nb_components=s->nb_components;\n    int bits= (s->bits+7)&~7;\n    int resync_mb_y = 0;\n    int resync_mb_x = 0;\n\n    point_transform += bits - s->bits;\n\n    av_assert0(nb_components==1 || nb_components==3);\n\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n            if (s->restart_interval && !s->restart_count){\n                s->restart_count = s->restart_interval;\n                resync_mb_x = mb_x;\n                resync_mb_y = mb_y;\n            }\n\n            if(!mb_x || mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x || s->interlaced){\n                int toprow  = mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x;\n                int leftcol = !mb_x || mb_y == resync_mb_y && mb_x == resync_mb_x;\n                for (i = 0; i < nb_components; i++) {\n                    uint8_t *ptr;\n                    uint16_t *ptr16;\n                    int n, h, v, x, y, c, j, linesize;\n                    n = s->nb_blocks[i];\n                    c = s->comp_index[i];\n                    h = s->h_scount[i];\n                    v = s->v_scount[i];\n                    x = 0;\n                    y = 0;\n                    linesize= s->linesize[c];\n\n                    if(bits>8) linesize /= 2;\n\n                    for(j=0; j<n; j++) {\n                        int pred, dc;\n\n                        dc = mjpeg_decode_dc(s, s->dc_index[i]);\n                        if(dc == 0xFFFF)\n                            return -1;\n                        if(bits<=8){\n                        ptr = s->picture.data[c] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap\n                        if(y==0 && toprow){\n                            if(x==0 && leftcol){\n                                pred= 1 << (bits - 1);\n                            }else{\n                                pred= ptr[-1];\n                            }\n                        }else{\n                            if(x==0 && leftcol){\n                                pred= ptr[-linesize];\n                            }else{\n                                PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n                            }\n                        }\n\n                        if (s->interlaced && s->bottom_field)\n                            ptr += linesize >> 1;\n                        pred &= (-1)<<(8-s->bits);\n                        *ptr= pred + (dc << point_transform);\n                        }else{\n                            ptr16 = s->picture.data[c] + 2*(linesize * (v * mb_y + y)) + 2*(h * mb_x + x); //FIXME optimize this crap\n                            if(y==0 && toprow){\n                                if(x==0 && leftcol){\n                                    pred= 1 << (bits - 1);\n                                }else{\n                                    pred= ptr16[-1];\n                                }\n                            }else{\n                                if(x==0 && leftcol){\n                                    pred= ptr16[-linesize];\n                                }else{\n                                    PREDICT(pred, ptr16[-linesize-1], ptr16[-linesize], ptr16[-1], predictor);\n                                }\n                            }\n\n                            if (s->interlaced && s->bottom_field)\n                                ptr16 += linesize >> 1;\n                            pred &= (-1)<<(16-s->bits);\n                            *ptr16= pred + (dc << point_transform);\n                        }\n                        if (++x == h) {\n                            x = 0;\n                            y++;\n                        }\n                    }\n                }\n            } else {\n                for (i = 0; i < nb_components; i++) {\n                    uint8_t *ptr;\n                    uint16_t *ptr16;\n                    int n, h, v, x, y, c, j, linesize, dc;\n                    n        = s->nb_blocks[i];\n                    c        = s->comp_index[i];\n                    h        = s->h_scount[i];\n                    v        = s->v_scount[i];\n                    x        = 0;\n                    y        = 0;\n                    linesize = s->linesize[c];\n\n                    if(bits>8) linesize /= 2;\n\n                    for (j = 0; j < n; j++) {\n                        int pred;\n\n                        dc = mjpeg_decode_dc(s, s->dc_index[i]);\n                        if(dc == 0xFFFF)\n                            return -1;\n                        if(bits<=8){\n                            ptr = s->picture.data[c] +\n                              (linesize * (v * mb_y + y)) +\n                              (h * mb_x + x); //FIXME optimize this crap\n                            PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n\n                            pred &= (-1)<<(8-s->bits);\n                            *ptr = pred + (dc << point_transform);\n                        }else{\n                            ptr16 = s->picture.data[c] + 2*(linesize * (v * mb_y + y)) + 2*(h * mb_x + x); //FIXME optimize this crap\n                            PREDICT(pred, ptr16[-linesize-1], ptr16[-linesize], ptr16[-1], predictor);\n\n                            pred &= (-1)<<(16-s->bits);\n                            *ptr16= pred + (dc << point_transform);\n                        }\n\n                        if (++x == h) {\n                            x = 0;\n                            y++;\n                        }\n                    }\n                }\n            }\n            if (s->restart_interval && !--s->restart_count) {\n                align_get_bits(&s->gb);\n                skip_bits(&s->gb, 16); /* skip RSTn */\n            }\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": 4956, "func": "static int SRP_user_pwd_set_sv(SRP_user_pwd *vinfo, const char *s,\n                               const char *v)\n{\n    unsigned char tmp[MAX_LEN];\n    int len;\n\n    vinfo->v = NULL;\n    vinfo->s = NULL;\n\n    len = t_fromb64(tmp, sizeof(tmp), v);\n    if (len < 0)\n        return 0;\n    if (NULL == (vinfo->v = BN_bin2bn(tmp, len, NULL)))\n        return 0;\n    len = t_fromb64(tmp, sizeof(tmp), s);\n    if (len < 0)\n        goto err;\n    vinfo->s = BN_bin2bn(tmp, len, NULL);\n    if (vinfo->s == NULL)\n        goto err;\n    return 1;\n err:\n    BN_free(vinfo->v);\n    vinfo->v = NULL;\n    return 0;\n}", "target": 0}
{"idx": 4957, "func": "int BN_rshift1(BIGNUM *r, const BIGNUM *a)\n\t{\n\tBN_ULONG *ap,*rp,t,c;\n\tint i;\n\n\tbn_check_top(r);\n\tbn_check_top(a);\n\n\tif (BN_is_zero(a))\n\t\t{\n\t\tBN_zero(r);\n\t\treturn(1);\n\t\t}\n\tif (a != r)\n\t\t{\n\t\tif (bn_wexpand(r,a->top) == NULL) return(0);\n\t\tr->top=a->top;\n\t\tr->neg=a->neg;\n\t\t}\n\tap=a->d;\n\trp=r->d;\n\tc=0;\n\tfor (i=a->top-1; i>=0; i--)\n\t\t{\n\t\tt=ap[i];\n\t\trp[i]=((t>>1)&BN_MASK2)|c;\n\t\tc=(t&1)?BN_TBIT:0;\n\t\t}\n\tbn_correct_top(r);\n\tbn_check_top(r);\n\treturn(1);\n\t}", "target": 1}
{"idx": 4958, "func": "static void FUNC(hevc_loop_filter_luma)(uint8_t *_pix,\n                                        ptrdiff_t _xstride, ptrdiff_t _ystride,\n                                        int *_beta, int *_tc,\n                                        uint8_t *_no_p, uint8_t *_no_q)\n{\n    int d, j;\n    pixel *pix        = (pixel *)_pix;\n    ptrdiff_t xstride = _xstride / sizeof(pixel);\n    ptrdiff_t ystride = _ystride / sizeof(pixel);\n\n    for (j = 0; j < 2; j++) {\n        const int dp0  = abs(P2  - 2 * P1  + P0);\n        const int dq0  = abs(Q2  - 2 * Q1  + Q0);\n        const int dp3  = abs(TP2 - 2 * TP1 + TP0);\n        const int dq3  = abs(TQ2 - 2 * TQ1 + TQ0);\n        const int d0   = dp0 + dq0;\n        const int d3   = dp3 + dq3;\n        const int beta = _beta[j] << (BIT_DEPTH - 8);\n        const int tc   = _tc[j]   << (BIT_DEPTH - 8);\n        const int no_p = _no_p[j];\n        const int no_q = _no_q[j];\n\n        if (d0 + d3 >= beta) {\n            pix += 4 * ystride;\n            continue;\n        } else {\n            const int beta_3 = beta >> 3;\n            const int beta_2 = beta >> 2;\n            const int tc25   = ((tc * 5 + 1) >> 1);\n\n            if (abs(P3  -  P0) + abs(Q3  -  Q0) < beta_3 && abs(P0  -  Q0) < tc25 &&\n                abs(TP3 - TP0) + abs(TQ3 - TQ0) < beta_3 && abs(TP0 - TQ0) < tc25 &&\n                                      (d0 << 1) < beta_2 &&      (d3 << 1) < beta_2) {\n                // strong filtering\n                const int tc2 = tc << 1;\n                for (d = 0; d < 4; d++) {\n                    const int p3 = P3;\n                    const int p2 = P2;\n                    const int p1 = P1;\n                    const int p0 = P0;\n                    const int q0 = Q0;\n                    const int q1 = Q1;\n                    const int q2 = Q2;\n                    const int q3 = Q3;\n                    if (!no_p) {\n                        P0 = p0 + av_clip(((p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4) >> 3) - p0, -tc2, tc2);\n                        P1 = p1 + av_clip(((p2 + p1 + p0 + q0 + 2) >> 2) - p1, -tc2, tc2);\n                        P2 = p2 + av_clip(((2 * p3 + 3 * p2 + p1 + p0 + q0 + 4) >> 3) - p2, -tc2, tc2);\n                    }\n                    if (!no_q) {\n                        Q0 = q0 + av_clip(((p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4) >> 3) - q0, -tc2, tc2);\n                        Q1 = q1 + av_clip(((p0 + q0 + q1 + q2 + 2) >> 2) - q1, -tc2, tc2);\n                        Q2 = q2 + av_clip(((2 * q3 + 3 * q2 + q1 + q0 + p0 + 4) >> 3) - q2, -tc2, tc2);\n                    }\n                    pix += ystride;\n                }\n            } else { // normal filtering\n                int nd_p = 1;\n                int nd_q = 1;\n                const int tc_2 = tc >> 1;\n                if (dp0 + dp3 < ((beta + (beta >> 1)) >> 3))\n                    nd_p = 2;\n                if (dq0 + dq3 < ((beta + (beta >> 1)) >> 3))\n                    nd_q = 2;\n\n                for (d = 0; d < 4; d++) {\n                    const int p2 = P2;\n                    const int p1 = P1;\n                    const int p0 = P0;\n                    const int q0 = Q0;\n                    const int q1 = Q1;\n                    const int q2 = Q2;\n                    int delta0   = (9 * (q0 - p0) - 3 * (q1 - p1) + 8) >> 4;\n                    if (abs(delta0) < 10 * tc) {\n                        delta0 = av_clip(delta0, -tc, tc);\n                        if (!no_p)\n                            P0 = av_clip_pixel(p0 + delta0);\n                        if (!no_q)\n                            Q0 = av_clip_pixel(q0 - delta0);\n                        if (!no_p && nd_p > 1) {\n                            const int deltap1 = av_clip((((p2 + p0 + 1) >> 1) - p1 + delta0) >> 1, -tc_2, tc_2);\n                            P1 = av_clip_pixel(p1 + deltap1);\n                        }\n                        if (!no_q && nd_q > 1) {\n                            const int deltaq1 = av_clip((((q2 + q0 + 1) >> 1) - q1 - delta0) >> 1, -tc_2, tc_2);\n                            Q1 = av_clip_pixel(q1 + deltaq1);\n                        }\n                    }\n                    pix += ystride;\n                }\n            }\n        }\n    }\n}", "target": 1}
{"idx": 4959, "func": "static ngx_int_t\nngx_http_variable_sent_last_modified(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    u_char  *p;\n\n    if (r->headers_out.last_modified) {\n        v->len = r->headers_out.last_modified->value.len;\n        v->valid = 1;\n        v->no_cacheable = 0;\n        v->not_found = 0;\n        v->data = r->headers_out.last_modified->value.data;\n\n        return NGX_OK;\n    }\n\n    if (r->headers_out.last_modified_time >= 0) {\n        p = ngx_pnalloc(r->pool, sizeof(\"Mon, 28 Sep 1970 06:00:00 GMT\") - 1);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        v->len = ngx_http_time(p, r->headers_out.last_modified_time) - p;\n        v->valid = 1;\n        v->no_cacheable = 0;\n        v->not_found = 0;\n        v->data = p;\n\n        return NGX_OK;\n    }\n\n    v->not_found = 1;\n\n    return NGX_OK;\n}", "target": 0}
{"idx": 4960, "func": "static void build_SYS_str_reasons(void)\n{\n    /* OPENSSL_malloc cannot be used here, use static storage instead */\n    static char strerror_pool[SPACE_SYS_STR_REASONS];\n    char *cur = strerror_pool;\n    size_t cnt = 0;\n    static int init = 1;\n    int i;\n\n    CRYPTO_THREAD_write_lock(err_string_lock);\n    if (!init) {\n        CRYPTO_THREAD_unlock(err_string_lock);\n        return;\n    }\n\n    for (i = 1; i <= NUM_SYS_STR_REASONS; i++) {\n        ERR_STRING_DATA *str = &SYS_str_reasons[i - 1];\n\n        str->error = ERR_PACK(ERR_LIB_SYS, 0, i);\n        if (str->string == NULL) {\n            if (openssl_strerror_r(i, cur, sizeof(strerror_pool) - cnt)) {\n                size_t l = strlen(cur) + 1;\n\n                str->string = cur;\n                cnt += l;\n                if (cnt > sizeof(strerror_pool))\n                    cnt = sizeof(strerror_pool);\n                cur += l;\n            }\n        }\n        if (str->string == NULL)\n            str->string = \"unknown\";\n    }\n\n    /*\n     * Now we still have SYS_str_reasons[NUM_SYS_STR_REASONS] = {0, NULL}, as\n     * required by ERR_load_strings.\n     */\n\n    init = 0;\n\n    CRYPTO_THREAD_unlock(err_string_lock);\n    err_load_strings(SYS_str_reasons);\n}", "target": 1}
{"idx": 4961, "func": "static void jpeg_table_header(MpegEncContext *s)\n{\n    PutBitContext *p = &s->pb;\n    int i, j, size;\n    uint8_t *ptr;\n\n    /* quant matrixes */\n    put_marker(p, DQT);\n#ifdef TWOMATRIXES\n    put_bits(p, 16, 2 + 2 * (1 + 64));\n#else\n    put_bits(p, 16, 2 + 1 * (1 + 64));\n#endif\n    put_bits(p, 4, 0); /* 8 bit precision */\n    put_bits(p, 4, 0); /* table 0 */\n    for(i=0;i<64;i++) {\n        j = s->intra_scantable.permutated[i];\n        put_bits(p, 8, s->intra_matrix[j]);\n    }\n#ifdef TWOMATRIXES\n    put_bits(p, 4, 0); /* 8 bit precision */\n    put_bits(p, 4, 1); /* table 1 */\n    for(i=0;i<64;i++) {\n        j = s->intra_scantable.permutated[i];\n        put_bits(p, 8, s->chroma_intra_matrix[j]);\n    }\n#endif\n\n    /* huffman table */\n    put_marker(p, DHT);\n    flush_put_bits(p);\n    ptr = put_bits_ptr(p);\n    put_bits(p, 16, 0); /* patched later */\n    size = 2;\n    size += put_huffman_table(s, 0, 0, ff_mjpeg_bits_dc_luminance,\n                              ff_mjpeg_val_dc);\n    size += put_huffman_table(s, 0, 1, ff_mjpeg_bits_dc_chrominance,\n                              ff_mjpeg_val_dc);\n\n    size += put_huffman_table(s, 1, 0, ff_mjpeg_bits_ac_luminance,\n                              ff_mjpeg_val_ac_luminance);\n    size += put_huffman_table(s, 1, 1, ff_mjpeg_bits_ac_chrominance,\n                              ff_mjpeg_val_ac_chrominance);\n    AV_WB16(ptr, size);\n}", "target": 1}
{"idx": 4962, "func": "static int push_samples(AVFilterContext *ctx, int nb_samples)\n{\n    AVFilterLink *outlink = ctx->outputs[0];\n    LoopContext *s = ctx->priv;\n    AVFrame *out;\n    int ret, i = 0;\n\n    while (s->loop != 0 && i < nb_samples) {\n        out = ff_get_audio_buffer(outlink, FFMIN(nb_samples, s->nb_samples - s->current_sample));\n        if (!out)\n            return AVERROR(ENOMEM);\n        ret = av_audio_fifo_peek_at(s->fifo, (void **)out->extended_data, out->nb_samples, s->current_sample);\n        if (ret < 0) {\n            av_frame_free(&out);\n            return ret;\n        }\n        out->pts = s->pts;\n        out->nb_samples = ret;\n        s->pts += out->nb_samples;\n        i += out->nb_samples;\n        s->current_sample += out->nb_samples;\n\n        ret = ff_filter_frame(outlink, out);\n        if (ret < 0)\n            return ret;\n\n        if (s->current_sample >= s->nb_samples) {\n            s->current_sample = 0;\n\n            if (s->loop > 0)\n                s->loop--;\n        }\n    }\n\n    return ret;\n}", "target": 0}
{"idx": 4963, "func": "static apr_status_t store_body(cache_handle_t *h, request_rec *r,\n        apr_bucket_brigade *in, apr_bucket_brigade *out)\n{\n    apr_bucket *e;\n    apr_status_t rv = APR_SUCCESS;\n    cache_socache_object_t *sobj =\n            (cache_socache_object_t *) h->cache_obj->vobj;\n    cache_socache_dir_conf *dconf =\n            ap_get_module_config(r->per_dir_config, &cache_socache_module);\n    int seen_eos = 0;\n\n    if (!sobj->offset) {\n        sobj->offset = dconf->readsize;\n    }\n    if (!sobj->timeout && dconf->readtime) {\n        sobj->timeout = apr_time_now() + dconf->readtime;\n    }\n\n    if (!sobj->newbody) {\n        if (sobj->body) {\n            apr_brigade_cleanup(sobj->body);\n        }\n        else {\n            sobj->body = apr_brigade_create(r->pool,\n                    r->connection->bucket_alloc);\n        }\n        sobj->newbody = 1;\n    }\n    if (sobj->offset) {\n        apr_brigade_partition(in, sobj->offset, &e);\n    }\n\n    while (APR_SUCCESS == rv && !APR_BRIGADE_EMPTY(in)) {\n        const char *str;\n        apr_size_t length;\n\n        e = APR_BRIGADE_FIRST(in);\n\n        /* are we done completely? if so, pass any trailing buckets right through */\n        if (sobj->done || !sobj->pool) {\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            continue;\n        }\n\n        /* have we seen eos yet? */\n        if (APR_BUCKET_IS_EOS(e)) {\n            seen_eos = 1;\n            sobj->done = 1;\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            break;\n        }\n\n        /* honour flush buckets, we'll get called again */\n        if (APR_BUCKET_IS_FLUSH(e)) {\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            break;\n        }\n\n        /* metadata buckets are preserved as is */\n        if (APR_BUCKET_IS_METADATA(e)) {\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            continue;\n        }\n\n        /* read the bucket, write to the cache */\n        rv = apr_bucket_read(e, &str, &length, APR_BLOCK_READ);\n        APR_BUCKET_REMOVE(e);\n        APR_BRIGADE_INSERT_TAIL(out, e);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02377)\n                    \"Error when reading bucket for URL %s\",\n                    h->cache_obj->key);\n            /* Remove the intermediate cache file and return non-APR_SUCCESS */\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return rv;\n        }\n\n        /* don't write empty buckets to the cache */\n        if (!length) {\n            continue;\n        }\n\n        sobj->file_size += length;\n        if (sobj->file_size >= sobj->buffer_len - sobj->body_offset) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02378)\n                    \"URL %s failed the buffer size check \"\n                    \"(%\" APR_OFF_T_FMT \">=%\" APR_SIZE_T_FMT \")\",\n                    h->cache_obj->key, sobj->file_size, sobj->buffer_len - sobj->body_offset);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return APR_EGENERAL;\n        }\n\n        rv = apr_bucket_copy(e, &e);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02379)\n                    \"Error when copying bucket for URL %s\",\n                    h->cache_obj->key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return rv;\n        }\n        APR_BRIGADE_INSERT_TAIL(sobj->body, e);\n\n        /* have we reached the limit of how much we're prepared to write in one\n         * go? If so, leave, we'll get called again. This prevents us from trying\n         * to swallow too much data at once, or taking so long to write the data\n         * the client times out.\n         */\n        sobj->offset -= length;\n        if (sobj->offset <= 0) {\n            sobj->offset = 0;\n            break;\n        }\n        if ((dconf->readtime && apr_time_now() > sobj->timeout)) {\n            sobj->timeout = 0;\n            break;\n        }\n\n    }\n\n    /* Was this the final bucket? If yes, perform sanity checks.\n     */\n    if (seen_eos) {\n        const char *cl_header = apr_table_get(r->headers_out, \"Content-Length\");\n\n        if (r->connection->aborted || r->no_cache) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02380)\n                    \"Discarding body for URL %s \"\n                    \"because connection has been aborted.\",\n                    h->cache_obj->key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return APR_EGENERAL;\n        }\n        if (cl_header) {\n            apr_int64_t cl = apr_atoi64(cl_header);\n            if ((errno == 0) && (sobj->file_size != cl)) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02381)\n                        \"URL %s didn't receive complete response, not caching\",\n                        h->cache_obj->key);\n                apr_pool_destroy(sobj->pool);\n                sobj->pool = NULL;\n                return APR_EGENERAL;\n            }\n        }\n\n        /* All checks were fine, we're good to go when the commit comes */\n\n    }\n\n    return APR_SUCCESS;\n}", "target": 1}
{"idx": 4964, "func": "static void ready_residue(vorbis_enc_residue *rc, vorbis_enc_context *venc)\n{\n    int i;\n    assert(rc->type == 2);\n    rc->maxes = av_mallocz(sizeof(float[2]) * rc->classifications);\n    for (i = 0; i < rc->classifications; i++) {\n        int j;\n        vorbis_enc_codebook * cb;\n        for (j = 0; j < 8; j++)\n            if (rc->books[i][j] != -1)\n                break;\n        if (j == 8) // zero\n            continue;\n        cb = &venc->codebooks[rc->books[i][j]];\n        assert(cb->ndimentions >= 2);\n        assert(cb->lookup);\n\n        for (j = 0; j < cb->nentries; j++) {\n            float a;\n            if (!cb->lens[j])\n                continue;\n            a = fabs(cb->dimentions[j * cb->ndimentions]);\n            if (a > rc->maxes[i][0])\n                rc->maxes[i][0] = a;\n            a = fabs(cb->dimentions[j * cb->ndimentions + 1]);\n            if (a > rc->maxes[i][1])\n                rc->maxes[i][1] = a;\n        }\n    }\n    // small bias\n    for (i = 0; i < rc->classifications; i++) {\n        rc->maxes[i][0] += 0.8;\n        rc->maxes[i][1] += 0.8;\n    }\n}", "target": 1}
{"idx": 4965, "func": "static void decode_vui(HEVCContext *s, HEVCSPS *sps)\n{\n    VUI *vui          = &sps->vui;\n    GetBitContext *gb = &s->HEVClc->gb;\n    int sar_present;\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"Decoding VUI\\n\");\n\n    sar_present = get_bits1(gb);\n    if (sar_present) {\n        uint8_t sar_idx = get_bits(gb, 8);\n        if (sar_idx < FF_ARRAY_ELEMS(vui_sar))\n            vui->sar = vui_sar[sar_idx];\n        else if (sar_idx == 255) {\n            vui->sar.num = get_bits(gb, 16);\n            vui->sar.den = get_bits(gb, 16);\n        } else\n            av_log(s->avctx, AV_LOG_WARNING,\n                   \"Unknown SAR index: %u.\\n\", sar_idx);\n    }\n\n    vui->overscan_info_present_flag = get_bits1(gb);\n    if (vui->overscan_info_present_flag)\n        vui->overscan_appropriate_flag = get_bits1(gb);\n\n    vui->video_signal_type_present_flag = get_bits1(gb);\n    if (vui->video_signal_type_present_flag) {\n        vui->video_format                    = get_bits(gb, 3);\n        vui->video_full_range_flag           = get_bits1(gb);\n        vui->colour_description_present_flag = get_bits1(gb);\n        if (vui->video_full_range_flag && sps->pix_fmt == AV_PIX_FMT_YUV420P)\n            sps->pix_fmt = AV_PIX_FMT_YUVJ420P;\n        if (vui->colour_description_present_flag) {\n            vui->colour_primaries        = get_bits(gb, 8);\n            vui->transfer_characteristic = get_bits(gb, 8);\n            vui->matrix_coeffs           = get_bits(gb, 8);\n\n            // Set invalid values to \"unspecified\"\n            if (vui->colour_primaries >= AVCOL_PRI_NB)\n                vui->colour_primaries = AVCOL_PRI_UNSPECIFIED;\n            if (vui->transfer_characteristic >= AVCOL_TRC_NB)\n                vui->transfer_characteristic = AVCOL_TRC_UNSPECIFIED;\n            if (vui->matrix_coeffs >= AVCOL_SPC_NB)\n                vui->matrix_coeffs = AVCOL_SPC_UNSPECIFIED;\n        }\n    }\n\n    vui->chroma_loc_info_present_flag = get_bits1(gb);\n    if (vui->chroma_loc_info_present_flag) {\n        vui->chroma_sample_loc_type_top_field    = get_ue_golomb_long(gb);\n        vui->chroma_sample_loc_type_bottom_field = get_ue_golomb_long(gb);\n    }\n\n    vui->neutra_chroma_indication_flag = get_bits1(gb);\n    vui->field_seq_flag                = get_bits1(gb);\n    vui->frame_field_info_present_flag = get_bits1(gb);\n\n    vui->default_display_window_flag = get_bits1(gb);\n    if (vui->default_display_window_flag) {\n        //TODO: * 2 is only valid for 420\n        vui->def_disp_win.left_offset   = get_ue_golomb_long(gb) * 2;\n        vui->def_disp_win.right_offset  = get_ue_golomb_long(gb) * 2;\n        vui->def_disp_win.top_offset    = get_ue_golomb_long(gb) * 2;\n        vui->def_disp_win.bottom_offset = get_ue_golomb_long(gb) * 2;\n\n        if (s->apply_defdispwin &&\n            s->avctx->flags2 & CODEC_FLAG2_IGNORE_CROP) {\n            av_log(s->avctx, AV_LOG_DEBUG,\n                   \"discarding vui default display window, \"\n                   \"original values are l:%u r:%u t:%u b:%u\\n\",\n                   vui->def_disp_win.left_offset,\n                   vui->def_disp_win.right_offset,\n                   vui->def_disp_win.top_offset,\n                   vui->def_disp_win.bottom_offset);\n\n            vui->def_disp_win.left_offset   =\n            vui->def_disp_win.right_offset  =\n            vui->def_disp_win.top_offset    =\n            vui->def_disp_win.bottom_offset = 0;\n        }\n    }\n\n    vui->vui_timing_info_present_flag = get_bits1(gb);\n\n    if (vui->vui_timing_info_present_flag) {\n        vui->vui_num_units_in_tick               = get_bits_long(gb, 32);\n        vui->vui_time_scale                      = get_bits_long(gb, 32);\n        vui->vui_poc_proportional_to_timing_flag = get_bits1(gb);\n        if (vui->vui_poc_proportional_to_timing_flag)\n            vui->vui_num_ticks_poc_diff_one_minus1 = get_ue_golomb_long(gb);\n        vui->vui_hrd_parameters_present_flag = get_bits1(gb);\n        if (vui->vui_hrd_parameters_present_flag)\n            decode_hrd(s, 1, sps->max_sub_layers);\n    }\n\n    vui->bitstream_restriction_flag = get_bits1(gb);\n    if (vui->bitstream_restriction_flag) {\n        vui->tiles_fixed_structure_flag              = get_bits1(gb);\n        vui->motion_vectors_over_pic_boundaries_flag = get_bits1(gb);\n        vui->restricted_ref_pic_lists_flag           = get_bits1(gb);\n        vui->min_spatial_segmentation_idc            = get_ue_golomb_long(gb);\n        vui->max_bytes_per_pic_denom                 = get_ue_golomb_long(gb);\n        vui->max_bits_per_min_cu_denom               = get_ue_golomb_long(gb);\n        vui->log2_max_mv_length_horizontal           = get_ue_golomb_long(gb);\n        vui->log2_max_mv_length_vertical             = get_ue_golomb_long(gb);\n    }\n}", "target": 0}
{"idx": 4966, "func": "static void mpeg_decode_sequence_extension(Mpeg1Context *s1)\n{\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n    int horiz_size_ext, vert_size_ext;\n    int bit_rate_ext;\n\n    skip_bits(&s->gb, 1); /* profile and level esc*/\n    s->avctx->profile       = get_bits(&s->gb, 3);\n    s->avctx->level         = get_bits(&s->gb, 4);\n    s->progressive_sequence = get_bits1(&s->gb);   /* progressive_sequence */\n    s->chroma_format        = get_bits(&s->gb, 2); /* chroma_format 1=420, 2=422, 3=444 */\n    horiz_size_ext          = get_bits(&s->gb, 2);\n    vert_size_ext           = get_bits(&s->gb, 2);\n    s->width  |= (horiz_size_ext << 12);\n    s->height |= (vert_size_ext  << 12);\n    bit_rate_ext = get_bits(&s->gb, 12);  /* XXX: handle it */\n    s->bit_rate += (bit_rate_ext << 18) * 400;\n    check_marker(&s->gb, \"after bit rate extension\");\n    s->avctx->rc_buffer_size += get_bits(&s->gb, 8) * 1024 * 16 << 10;\n\n    s->low_delay = get_bits1(&s->gb);\n    if (s->flags & CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n\n    s1->frame_rate_ext.num = get_bits(&s->gb, 2) + 1;\n    s1->frame_rate_ext.den = get_bits(&s->gb, 5) + 1;\n\n    av_dlog(s->avctx, \"sequence extension\\n\");\n    s->codec_id = s->avctx->codec_id = AV_CODEC_ID_MPEG2VIDEO;\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(s->avctx, AV_LOG_DEBUG,\n               \"profile: %d, level: %d ps: %d cf:%d vbv buffer: %d, bitrate:%d\\n\",\n               s->avctx->profile, s->avctx->level, s->progressive_sequence, s->chroma_format,\n               s->avctx->rc_buffer_size, s->bit_rate);\n}", "target": 0}
{"idx": 4967, "func": "AVResampleContext *av_resample_init(int out_rate, int in_rate, int filter_size, int phase_shift, int linear, double cutoff){\n    AVResampleContext *c= av_mallocz(sizeof(AVResampleContext));\n    double factor= FFMIN(out_rate * cutoff / in_rate, 1.0);\n    int phase_count= 1<<phase_shift;\n\n    if (!c)\n        return NULL;\n\n    c->phase_shift= phase_shift;\n    c->phase_mask= phase_count-1;\n    c->linear= linear;\n\n    c->filter_length= FFMAX((int)ceil(filter_size/factor), 1);\n    c->filter_bank= av_mallocz(c->filter_length*(phase_count+1)*sizeof(FELEM));\n    if (!c->filter_bank)\n        goto error;\n    if (build_filter(c->filter_bank, factor, c->filter_length, phase_count, 1<<FILTER_SHIFT, WINDOW_TYPE))\n        goto error;\n    memcpy(&c->filter_bank[c->filter_length*phase_count+1], c->filter_bank, (c->filter_length-1)*sizeof(FELEM));\n    c->filter_bank[c->filter_length*phase_count]= c->filter_bank[c->filter_length - 1];\n\n    if(!av_reduce(&c->src_incr, &c->dst_incr, out_rate, in_rate * (int64_t)phase_count, INT32_MAX/2))\n        goto error;\n    c->ideal_dst_incr= c->dst_incr;\n\n    c->index= -phase_count*((c->filter_length-1)/2);\n\n    return c;\nerror:\n    av_free(c->filter_bank);\n    av_free(c);\n    return NULL;\n}", "target": 0}
{"idx": 4968, "func": "int MAIN(int argc, char **argv)\n\t{\n\tENGINE *e = NULL;\n\tDH *dh=NULL;\n\tint ret=1,num=DEFBITS;\n\tint g=2;\n\tchar *outfile=NULL;\n\tchar *inrand=NULL;\n\tchar *engine=NULL;\n\tBIO *out=NULL;\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\targv++;\n\targc--;\n\tfor (;;)\n\t\t{\n\t\tif (argc <= 0) break;\n\t\tif (strcmp(*argv,\"-out\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-2\") == 0)\n\t\t\tg=2;\n\t/*\telse if (strcmp(*argv,\"-3\") == 0)\n\t\t\tg=3; */\n\t\telse if (strcmp(*argv,\"-5\") == 0)\n\t\t\tg=5;\n\t\telse if (strcmp(*argv,\"-engine\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tengine= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-rand\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinrand= *(++argv);\n\t\t\t}\n\t\telse\n\t\t\tbreak;\n\t\targv++;\n\t\targc--;\n\t\t}\n\tif ((argc >= 1) && ((sscanf(*argv,\"%d\",&num) == 0) || (num < 0)))\n\t\t{\nbad:\n\t\tBIO_printf(bio_err,\"usage: gendh [args] [numbits]\\n\");\n\t\tBIO_printf(bio_err,\" -out file - output the key to 'file\\n\");\n\t\tBIO_printf(bio_err,\" -2        - use 2 as the generator value\\n\");\n\t/*\tBIO_printf(bio_err,\" -3        - use 3 as the generator value\\n\"); */\n\t\tBIO_printf(bio_err,\" -5        - use 5 as the generator value\\n\");\n\t\tBIO_printf(bio_err,\" -engine e - use engine e, possibly a hardware device.\\n\");\n\t\tBIO_printf(bio_err,\" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\n\t\tBIO_printf(bio_err,\"           - load the file (or the files in the directory) into\\n\");\n\t\tBIO_printf(bio_err,\"             the random number generator\\n\");\n\t\tgoto end;\n\t\t}\n\t\t\n\tif (engine != NULL)\n\t\t{\n\t\tif((e = ENGINE_by_id(engine)) == NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"invalid engine \\\"%s\\\"\\n\",\n\t\t\t\tengine);\n\t\t\tgoto end;\n\t\t\t}\n\t\tif(!ENGINE_set_default(e, ENGINE_METHOD_ALL))\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"can't use that engine\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tBIO_printf(bio_err,\"engine \\\"%s\\\" set.\\n\", engine);\n\t\t/* Free our \"structural\" reference. */\n\t\tENGINE_free(e);\n\t\t}\n\n\tout=BIO_new(BIO_s_file());\n\tif (out == NULL)\n\t\t{\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (outfile == NULL)\n\t\t{\n\t\tBIO_set_fp(out,stdout,BIO_NOCLOSE);\n#ifdef VMS\n\t\t{\n\t\tBIO *tmpbio = BIO_new(BIO_f_linebuffer());\n\t\tout = BIO_push(tmpbio, out);\n\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\tif (BIO_write_filename(out,outfile) <= 0)\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"warning, not much extra random data, consider using the -rand option\\n\");\n\t\t}\n\tif (inrand != NULL)\n\t\tBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\n\t\t\tapp_RAND_load_files(inrand));\n\n\tBIO_printf(bio_err,\"Generating DH parameters, %d bit long safe prime, generator %d\\n\",num,g);\n\tBIO_printf(bio_err,\"This is going to take a long time\\n\");\n\tdh=DH_generate_parameters(num,g,dh_cb,bio_err);\n\t\t\n\tif (dh == NULL) goto end;\n\n\tapp_RAND_write_file(NULL, bio_err);\n\n\tif (!PEM_write_bio_DHparams(out,dh))\n\t\tgoto end;\n\tret=0;\nend:\n\tif (ret != 0)\n\t\tERR_print_errors(bio_err);\n\tif (out != NULL) BIO_free_all(out);\n\tif (dh != NULL) DH_free(dh);\n\tEXIT(ret);\n\t}", "target": 0}
{"idx": 4969, "func": "OPENSSL_STACK *OPENSSL_sk_new_null(void)\n{\n    return OPENSSL_zalloc(sizeof(OPENSSL_STACK));\n}", "target": 0}
{"idx": 4970, "func": "static tmsize_t\nTIFFReadRawTile1(TIFF* tif, uint32 tile, void* buf, tmsize_t size, const char* module)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n    if (!_TIFFFillStriles( tif ))\n        return ((tmsize_t)(-1));\n\n\tassert((tif->tif_flags&TIFF_NOREADRAW)==0);\n\tif (!isMapped(tif)) {\n\t\ttmsize_t cc;\n\n\t\tif (!SeekOK(tif, td->td_stripoffset[tile])) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Seek error at row %lu, col %lu, tile %lu\",\n\t\t\t    (unsigned long) tif->tif_row,\n\t\t\t    (unsigned long) tif->tif_col,\n\t\t\t    (unsigned long) tile);\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t\tcc = TIFFReadFile(tif, buf, size);\n\t\tif (cc != size) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\"Read error at row %lu, col %lu; got %I64u bytes, expected %I64u\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned __int64) cc,\n\t\t\t\t     (unsigned __int64) size);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\"Read error at row %lu, col %lu; got %llu bytes, expected %llu\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned long long) cc,\n\t\t\t\t     (unsigned long long) size);\n#endif\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t} else {\n\t\ttmsize_t ma,mb;\n\t\ttmsize_t n;\n\t\tma=(tmsize_t)td->td_stripoffset[tile];\n\t\tmb=ma+size;\n\t\tif (((uint64)ma!=td->td_stripoffset[tile])||(ma>tif->tif_size))\n\t\t\tn=0;\n\t\telse if ((mb<ma)||(mb<size)||(mb>tif->tif_size))\n\t\t\tn=tif->tif_size-ma;\n\t\telse\n\t\t\tn=size;\n\t\tif (n!=size) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\"Read error at row %lu, col %lu, tile %lu; got %I64u bytes, expected %I64u\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned long) tile,\n\t\t\t\t     (unsigned __int64) n,\n\t\t\t\t     (unsigned __int64) size);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\"Read error at row %lu, col %lu, tile %lu; got %llu bytes, expected %llu\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned long) tile,\n\t\t\t\t     (unsigned long long) n,\n\t\t\t\t     (unsigned long long) size);\n#endif\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t\t_TIFFmemcpy(buf, tif->tif_base + ma, size);\n\t}\n\treturn (size);\n}", "target": 1}
{"idx": 4971, "func": "static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)\n{\n    if (buf_size < 13)\n        return AVERROR_INVALIDDATA;\n    if (memcmp(buf, \"FLV\", 3))\n        return AVERROR_INVALIDDATA;\n    buf      += 13;\n    buf_size -= 13;\n    while (buf_size >= 11 + 4) {\n        int type = buf[0];\n        int size = AV_RB24(&buf[1]) + 11 + 4;\n        if (size > buf_size)\n            return AVERROR_INVALIDDATA;\n        if (type == 8 || type == 9) {\n            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))\n                return AVERROR_INVALIDDATA;\n            os->extra_packet_sizes[os->nb_extra_packets] = size;\n            os->extra_packets[os->nb_extra_packets] = av_malloc(size);\n            if (!os->extra_packets[os->nb_extra_packets])\n                return AVERROR(ENOMEM);\n            memcpy(os->extra_packets[os->nb_extra_packets], buf, size);\n            os->nb_extra_packets++;\n        } else if (type == 0x12) {\n            if (os->metadata)\n                return AVERROR_INVALIDDATA;\n            os->metadata_size = size - 11 - 4;\n            os->metadata      = av_malloc(os->metadata_size);\n            if (!os->metadata)\n                return AVERROR(ENOMEM);\n            memcpy(os->metadata, buf + 11, os->metadata_size);\n        }\n        buf      += size;\n        buf_size -= size;\n    }\n    if (!os->metadata)\n        return AVERROR_INVALIDDATA;\n    return 0;\n}", "target": 1}
{"idx": 4972, "func": "void asn1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\n{\n    if (tt->flags & ASN1_TFLG_SK_MASK) {\n        STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\n        int i;\n\n        for (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {\n            ASN1_VALUE *vtmp = sk_ASN1_VALUE_value(sk, i);\n\n            ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));\n        }\n        sk_ASN1_VALUE_free(sk);\n        *pval = NULL;\n    } else {\n        ASN1_item_ex_free(pval, ASN1_ITEM_ptr(tt->item));\n    }\n}", "target": 0}
{"idx": 4973, "func": "int PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,\n                  unsigned int *siglen, EVP_PKEY *pkey)\n{\n    unsigned char *m;\n    int i, ret = 0;\n    unsigned int m_len;\n\n    m = OPENSSL_malloc(EVP_PKEY_size(pkey));\n    if (m == NULL) {\n        PEMerr(PEM_F_PEM_SIGNFINAL, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_SignFinal(ctx, m, &m_len, pkey) <= 0)\n        goto err;\n\n    i = EVP_EncodeBlock(sigret, m, m_len);\n    *siglen = i;\n    ret = 1;\n err:\n    /* ctx has been zeroed by EVP_SignFinal() */\n    OPENSSL_free(m);\n    return ret;\n}", "target": 0}
{"idx": 4974, "func": "int ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *band_psd,\n                                int start, int end, int fast_gain, int is_lfe,\n                                int dba_mode, int dba_nsegs, uint8_t *dba_offsets,\n                                uint8_t *dba_lengths, uint8_t *dba_values,\n                                int16_t *mask)\n{\n    int16_t excite[50]; /* excitation */\n    int bin, k;\n    int bndstrt, bndend, begin, end1, tmp;\n    int lowcomp, fastleak, slowleak;\n\n    /* excitation function */\n    bndstrt = bin_to_band_tab[start];\n    bndend = bin_to_band_tab[end-1] + 1;\n\n    if (bndstrt == 0) {\n        lowcomp = 0;\n        lowcomp = calc_lowcomp1(lowcomp, band_psd[0], band_psd[1], 384);\n        excite[0] = band_psd[0] - fast_gain - lowcomp;\n        lowcomp = calc_lowcomp1(lowcomp, band_psd[1], band_psd[2], 384);\n        excite[1] = band_psd[1] - fast_gain - lowcomp;\n        begin = 7;\n        for (bin = 2; bin < 7; bin++) {\n            if (!(is_lfe && bin == 6))\n                lowcomp = calc_lowcomp1(lowcomp, band_psd[bin], band_psd[bin+1], 384);\n            fastleak = band_psd[bin] - fast_gain;\n            slowleak = band_psd[bin] - s->slow_gain;\n            excite[bin] = fastleak - lowcomp;\n            if (!(is_lfe && bin == 6)) {\n                if (band_psd[bin] <= band_psd[bin+1]) {\n                    begin = bin + 1;\n                    break;\n                }\n            }\n        }\n\n        end1=bndend;\n        if (end1 > 22) end1=22;\n\n        for (bin = begin; bin < end1; bin++) {\n            if (!(is_lfe && bin == 6))\n                lowcomp = calc_lowcomp(lowcomp, band_psd[bin], band_psd[bin+1], bin);\n\n            fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);\n            slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);\n            excite[bin] = FFMAX(fastleak - lowcomp, slowleak);\n        }\n        begin = 22;\n    } else {\n        /* coupling channel */\n        begin = bndstrt;\n\n        fastleak = (s->cpl_fast_leak << 8) + 768;\n        slowleak = (s->cpl_slow_leak << 8) + 768;\n    }\n\n    for (bin = begin; bin < bndend; bin++) {\n        fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);\n        slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);\n        excite[bin] = FFMAX(fastleak, slowleak);\n    }\n\n    /* compute masking curve */\n\n    for (bin = bndstrt; bin < bndend; bin++) {\n        tmp = s->db_per_bit - band_psd[bin];\n        if (tmp > 0) {\n            excite[bin] += tmp >> 2;\n        }\n        mask[bin] = FFMAX(ff_ac3_hearing_threshold_tab[bin >> s->sr_shift][s->sr_code], excite[bin]);\n    }\n\n    /* delta bit allocation */\n\n    if (dba_mode == DBA_REUSE || dba_mode == DBA_NEW) {\n        int band, seg, delta;\n        if (dba_nsegs >= 8)\n            return -1;\n        band = 0;\n        for (seg = 0; seg < dba_nsegs; seg++) {\n            band += dba_offsets[seg];\n            if (band >= 50 || dba_lengths[seg] > 50-band)\n                return -1;\n            if (dba_values[seg] >= 4) {\n                delta = (dba_values[seg] - 3) << 7;\n            } else {\n                delta = (dba_values[seg] - 4) << 7;\n            }\n            for (k = 0; k < dba_lengths[seg]; k++) {\n                mask[band] += delta;\n                band++;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"idx": 4975, "func": "static inline void skip_bits(GetBitContext *s, int n){\n //Note gcc seems to optimize this to s->index+=n for the ALT_READER :))\n    OPEN_READER(re, s)\n    UPDATE_CACHE(re, s)\n    LAST_SKIP_BITS(re, s, n)\n    CLOSE_READER(re, s)\n}", "target": 1}
{"idx": 4976, "func": "static void sbr_qmf_synthesis(DSPContext *dsp, FFTContext *mdct,\n                              SBRDSPContext *sbrdsp,\n                              float *out, float X[2][38][64],\n                              float mdct_buf[2][64],\n                              float *v0, int *v_off, const unsigned int div)\n{\n    int i, n;\n    const float *sbr_qmf_window = div ? sbr_qmf_window_ds : sbr_qmf_window_us;\n    const int step = 128 >> div;\n    float *v;\n    for (i = 0; i < 32; i++) {\n        if (*v_off < step) {\n            int saved_samples = (1280 - 128) >> div;\n            memcpy(&v0[SBR_SYNTHESIS_BUF_SIZE - saved_samples], v0, saved_samples * sizeof(float));\n            *v_off = SBR_SYNTHESIS_BUF_SIZE - saved_samples - step;\n        } else {\n            *v_off -= step;\n        }\n        v = v0 + *v_off;\n        if (div) {\n            for (n = 0; n < 32; n++) {\n                X[0][i][   n] = -X[0][i][n];\n                X[0][i][32+n] =  X[1][i][31-n];\n            }\n            mdct->imdct_half(mdct, mdct_buf[0], X[0][i]);\n            sbrdsp->qmf_deint_neg(v, mdct_buf[0]);\n        } else {\n            sbrdsp->neg_odd_64(X[1][i]);\n            mdct->imdct_half(mdct, mdct_buf[0], X[0][i]);\n            mdct->imdct_half(mdct, mdct_buf[1], X[1][i]);\n            sbrdsp->qmf_deint_bfly(v, mdct_buf[1], mdct_buf[0]);\n        }\n        dsp->vector_fmul_add(out, v                , sbr_qmf_window               , zero64, 64 >> div);\n        dsp->vector_fmul_add(out, v + ( 192 >> div), sbr_qmf_window + ( 64 >> div), out   , 64 >> div);\n        dsp->vector_fmul_add(out, v + ( 256 >> div), sbr_qmf_window + (128 >> div), out   , 64 >> div);\n        dsp->vector_fmul_add(out, v + ( 448 >> div), sbr_qmf_window + (192 >> div), out   , 64 >> div);\n        dsp->vector_fmul_add(out, v + ( 512 >> div), sbr_qmf_window + (256 >> div), out   , 64 >> div);\n        dsp->vector_fmul_add(out, v + ( 704 >> div), sbr_qmf_window + (320 >> div), out   , 64 >> div);\n        dsp->vector_fmul_add(out, v + ( 768 >> div), sbr_qmf_window + (384 >> div), out   , 64 >> div);\n        dsp->vector_fmul_add(out, v + ( 960 >> div), sbr_qmf_window + (448 >> div), out   , 64 >> div);\n        dsp->vector_fmul_add(out, v + (1024 >> div), sbr_qmf_window + (512 >> div), out   , 64 >> div);\n        dsp->vector_fmul_add(out, v + (1216 >> div), sbr_qmf_window + (576 >> div), out   , 64 >> div);\n        out += 64 >> div;\n    }\n}", "target": 0}
{"idx": 4977, "func": "static int metadata_parse(FLACContext *s)\n{\n    int i, metadata_last, metadata_type, metadata_size;\n    int initial_pos= get_bits_count(&s->gb);\n\n        skip_bits_long(&s->gb, 32);\n\n        do {\n            metadata_last = get_bits1(&s->gb);\n            metadata_type = get_bits(&s->gb, 7);\n            metadata_size = get_bits_long(&s->gb, 24);\n\n            if (get_bits_count(&s->gb) + 8*metadata_size > s->gb.size_in_bits) {\n                skip_bits_long(&s->gb, initial_pos - get_bits_count(&s->gb));\n                break;\n            }\n\n            if (metadata_size) {\n                switch (metadata_type) {\n                case FLAC_METADATA_TYPE_STREAMINFO:\n                    if (!s->got_streaminfo) {\n                        ff_flac_parse_streaminfo(s->avctx, (FLACStreaminfo *)s,\n                                                 s->gb.buffer+get_bits_count(&s->gb)/8);\n                        allocate_buffers(s);\n                        s->got_streaminfo = 1;\n                    }\n                default:\n                    for (i = 0; i < metadata_size; i++)\n                        skip_bits(&s->gb, 8);\n                }\n            }\n        } while (!metadata_last);\n\n    return 0;\n}", "target": 0}
{"idx": 4978, "func": "static int stream_reqbody_cl(proxy_http_req_t *req)\n{\n    request_rec *r = req->r;\n    int seen_eos = 0, rv = OK;\n    proxy_conn_rec *p_conn = req->backend;\n    apr_bucket_alloc_t *bucket_alloc = req->bucket_alloc;\n    apr_bucket_brigade *header_brigade = req->header_brigade;\n    apr_bucket_brigade *input_brigade = req->input_brigade;\n    apr_bucket *e;\n    apr_off_t bytes;\n    apr_off_t bytes_streamed = 0;\n\n    do {\n        if (APR_BRIGADE_EMPTY(input_brigade)\n                && APR_BRIGADE_EMPTY(header_brigade)) {\n            rv = stream_reqbody_read(req, input_brigade, 1);\n            if (rv != OK) {\n                return rv;\n            }\n        }\n\n        if (!APR_BRIGADE_EMPTY(input_brigade)) {\n            apr_brigade_length(input_brigade, 1, &bytes);\n            bytes_streamed += bytes;\n\n            /* If this brigade contains EOS, either stop or remove it. */\n            if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n                seen_eos = 1;\n\n                /* We can't pass this EOS to the output_filters. */\n                e = APR_BRIGADE_LAST(input_brigade);\n                apr_bucket_delete(e);\n\n                if (apr_table_get(r->subprocess_env, \"proxy-sendextracrlf\")) {\n                    e = apr_bucket_immortal_create(CRLF_ASCII, 2,\n                                                   bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(input_brigade, e);\n                }\n            }\n\n            /* C-L < bytes streamed?!?\n             * We will error out after the body is completely\n             * consumed, but we can't stream more bytes at the\n             * back end since they would in part be interpreted\n             * as another request!  If nothing is sent, then\n             * just send nothing.\n             *\n             * Prevents HTTP Response Splitting.\n             */\n            if (bytes_streamed > req->cl_val) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01086)\n                              \"read more bytes of request body than expected \"\n                              \"(got %\" APR_OFF_T_FMT \", expected \"\n                              \"%\" APR_OFF_T_FMT \")\",\n                              bytes_streamed, req->cl_val);\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n\n        /* If we never sent the header brigade, so go ahead and\n         * take care of that now by prepending it.\n         */\n        APR_BRIGADE_PREPEND(input_brigade, header_brigade);\n\n        /* Flush here on EOS because we won't stream_reqbody_read() again */\n        rv = ap_proxy_pass_brigade(bucket_alloc, r, p_conn, req->origin,\n                                   input_brigade, seen_eos);\n        if (rv != OK) {\n            return rv;\n        }\n    } while (!seen_eos);\n\n    if (bytes_streamed != req->cl_val) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01087)\n                      \"client %s given Content-Length did not match\"\n                      \" number of body bytes read\", r->connection->client_ip);\n        return HTTP_BAD_REQUEST;\n    }\n\n    return OK;\n}", "target": 0}
{"idx": 4979, "func": "int BLAKE2b_Update(BLAKE2B_CTX *c, const void *data, size_t datalen)\n{\n    const uint8_t *in = data;\n    size_t fill;\n\n    /*\n     * Intuitively one would expect intermediate buffer, c->buf, to\n     * store incomplete blocks. But in this case we are interested to\n     * temporarily stash even complete blocks, because last one in the\n     * stream has to be treated in special way, and at this point we\n     * don't know if last block in *this* call is last one \"ever\". This\n     * is the reason for why |datalen| is compared as >, and not >=.\n     */\n    fill = sizeof(c->buf) - c->buflen;\n    if (datalen > fill) {\n        if (c->buflen) {\n            memcpy(c->buf + c->buflen, in, fill); /* Fill buffer */\n            blake2b_compress(c, c->buf, BLAKE2B_BLOCKBYTES);\n            c->buflen = 0;\n            in += fill;\n            datalen -= fill;\n        }\n        if (datalen > BLAKE2B_BLOCKBYTES) {\n            size_t stashlen = datalen % BLAKE2B_BLOCKBYTES;\n            /*\n\t     * If |datalen| is a multiple of the blocksize, stash\n\t     * last complete block, it can be final one...\n             */\n            stashlen = stashlen ? stashlen : BLAKE2B_BLOCKBYTES;\n            datalen -= stashlen;\n            blake2b_compress(c, in, datalen);\n            in += datalen;\n            datalen = stashlen;\n        }\n    }\n\n    assert(datalen <= BLAKE2B_BLOCKBYTES);\n\n    memcpy(c->buf + c->buflen, in, datalen);\n    c->buflen += datalen; /* Be lazy, do not compress */\n\n    return 1;\n}", "target": 0}
{"idx": 4980, "func": "static av_always_inline void filter_mb_row(AVCodecContext *avctx, void *tdata,\n                              int jobnr, int threadnr, int is_vp7)\n{\n    VP8Context *s = avctx->priv_data;\n    VP8ThreadData *td = &s->thread_data[threadnr];\n    int mb_x, mb_y = td->thread_mb_pos >> 16, num_jobs = s->num_jobs;\n    AVFrame *curframe = s->curframe->tf.f;\n    VP8Macroblock *mb;\n    VP8ThreadData *prev_td, *next_td;\n    uint8_t *dst[3] = {\n        curframe->data[0] + 16 * mb_y * s->linesize,\n        curframe->data[1] +  8 * mb_y * s->uvlinesize,\n        curframe->data[2] +  8 * mb_y * s->uvlinesize\n    };\n\n    if (s->mb_layout == 1)\n        mb = s->macroblocks_base + ((s->mb_width + 1) * (mb_y + 1) + 1);\n    else\n        mb = s->macroblocks + (s->mb_height - mb_y - 1) * 2;\n\n    if (mb_y == 0)\n        prev_td = td;\n    else\n        prev_td = &s->thread_data[(jobnr + num_jobs - 1) % num_jobs];\n    if (mb_y == s->mb_height - 1)\n        next_td = td;\n    else\n        next_td = &s->thread_data[(jobnr + 1) % num_jobs];\n\n    for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb++) {\n        VP8FilterStrength *f = &td->filter_strength[mb_x];\n        if (prev_td != td)\n            check_thread_pos(td, prev_td,\n                             (mb_x + 1) + (s->mb_width + 3), mb_y - 1);\n        if (next_td != td)\n            if (next_td != &s->thread_data[0])\n                check_thread_pos(td, next_td, mb_x + 1, mb_y + 1);\n\n        if (num_jobs == 1) {\n            if (s->filter.simple)\n                backup_mb_border(s->top_border[mb_x + 1], dst[0],\n                                 NULL, NULL, s->linesize, 0, 1);\n            else\n                backup_mb_border(s->top_border[mb_x + 1], dst[0],\n                                 dst[1], dst[2], s->linesize, s->uvlinesize, 0);\n        }\n\n        if (s->filter.simple)\n            filter_mb_simple(s, dst[0], f, mb_x, mb_y);\n        else\n            filter_mb(s, dst, f, mb_x, mb_y, is_vp7);\n        dst[0] += 16;\n        dst[1] += 8;\n        dst[2] += 8;\n\n        update_pos(td, mb_y, (s->mb_width + 3) + mb_x);\n    }\n}", "target": 0}
{"idx": 4981, "func": "static int kmvc_decode_inter_8x8(KmvcContext * ctx, int w, int h)\n{\n    BitBuf bb;\n    int res, val;\n    int i, j;\n    int bx, by;\n    int l0x, l1x, l0y, l1y;\n    int mx, my;\n\n    kmvc_init_getbits(bb, &ctx->g);\n\n    for (by = 0; by < h; by += 8)\n        for (bx = 0; bx < w; bx += 8) {\n            kmvc_getbit(bb, &ctx->g, res);\n            if (!res) {\n                kmvc_getbit(bb, &ctx->g, res);\n                if (!res) {     // fill whole 8x8 block\n                    if (!bytestream2_get_bytes_left(&ctx->g)) {\n                        av_log(ctx->avctx, AV_LOG_ERROR, \"Data overrun\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    val = bytestream2_get_byte(&ctx->g);\n                    for (i = 0; i < 64; i++)\n                        BLK(ctx->cur, bx + (i & 0x7), by + (i >> 3)) = val;\n                } else {        // copy block from previous frame\n                    for (i = 0; i < 64; i++)\n                        BLK(ctx->cur, bx + (i & 0x7), by + (i >> 3)) =\n                            BLK(ctx->prev, bx + (i & 0x7), by + (i >> 3));\n                }\n            } else {            // handle four 4x4 subblocks\n                if (!bytestream2_get_bytes_left(&ctx->g)) {\n                    av_log(ctx->avctx, AV_LOG_ERROR, \"Data overrun\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                for (i = 0; i < 4; i++) {\n                    l0x = bx + (i & 1) * 4;\n                    l0y = by + (i & 2) * 2;\n                    kmvc_getbit(bb, &ctx->g, res);\n                    if (!res) {\n                        kmvc_getbit(bb, &ctx->g, res);\n                        if (!res) {     // fill whole 4x4 block\n                            val = bytestream2_get_byte(&ctx->g);\n                            for (j = 0; j < 16; j++)\n                                BLK(ctx->cur, l0x + (j & 3), l0y + (j >> 2)) = val;\n                        } else {        // copy block\n                            val = bytestream2_get_byte(&ctx->g);\n                            mx = (val & 0xF) - 8;\n                            my = (val >> 4) - 8;\n                            if ((l0x+mx) + 320*(l0y+my) < 0 || (l0x+mx) + 320*(l0y+my) > 318*198) {\n                                av_log(ctx->avctx, AV_LOG_ERROR, \"Invalid MV\\n\");\n                                return AVERROR_INVALIDDATA;\n                            }\n                            for (j = 0; j < 16; j++)\n                                BLK(ctx->cur, l0x + (j & 3), l0y + (j >> 2)) =\n                                    BLK(ctx->prev, l0x + (j & 3) + mx, l0y + (j >> 2) + my);\n                        }\n                    } else {    // descend to 2x2 sub-sub-blocks\n                        for (j = 0; j < 4; j++) {\n                            l1x = l0x + (j & 1) * 2;\n                            l1y = l0y + (j & 2);\n                            kmvc_getbit(bb, &ctx->g, res);\n                            if (!res) {\n                                kmvc_getbit(bb, &ctx->g, res);\n                                if (!res) {     // fill whole 2x2 block\n                                    val = bytestream2_get_byte(&ctx->g);\n                                    BLK(ctx->cur, l1x, l1y) = val;\n                                    BLK(ctx->cur, l1x + 1, l1y) = val;\n                                    BLK(ctx->cur, l1x, l1y + 1) = val;\n                                    BLK(ctx->cur, l1x + 1, l1y + 1) = val;\n                                } else {        // copy block\n                                    val = bytestream2_get_byte(&ctx->g);\n                                    mx = (val & 0xF) - 8;\n                                    my = (val >> 4) - 8;\n                                    if ((l1x+mx) + 320*(l1y+my) < 0 || (l1x+mx) + 320*(l1y+my) > 318*198) {\n                                        av_log(ctx->avctx, AV_LOG_ERROR, \"Invalid MV\\n\");\n                                        return AVERROR_INVALIDDATA;\n                                    }\n                                    BLK(ctx->cur, l1x, l1y) = BLK(ctx->prev, l1x + mx, l1y + my);\n                                    BLK(ctx->cur, l1x + 1, l1y) =\n                                        BLK(ctx->prev, l1x + 1 + mx, l1y + my);\n                                    BLK(ctx->cur, l1x, l1y + 1) =\n                                        BLK(ctx->prev, l1x + mx, l1y + 1 + my);\n                                    BLK(ctx->cur, l1x + 1, l1y + 1) =\n                                        BLK(ctx->prev, l1x + 1 + mx, l1y + 1 + my);\n                                }\n                            } else {    // read values for block\n                                BLK(ctx->cur, l1x, l1y) = bytestream2_get_byte(&ctx->g);\n                                BLK(ctx->cur, l1x + 1, l1y) = bytestream2_get_byte(&ctx->g);\n                                BLK(ctx->cur, l1x, l1y + 1) = bytestream2_get_byte(&ctx->g);\n                                BLK(ctx->cur, l1x + 1, l1y + 1) = bytestream2_get_byte(&ctx->g);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n    return 0;\n}", "target": 0}
{"idx": 4982, "func": "int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)\n{\n    int c, bits = 0;\n    int log2_pixels = pixdesc->log2_chroma_w + pixdesc->log2_chroma_h;\n    int steps[4] = {0};\n\n    for (c = 0; c < pixdesc->nb_components; c++) {\n        const AVComponentDescriptor *comp = &pixdesc->comp[c];\n        int s = c == 1 || c == 2 ? 0 : log2_pixels;\n        steps[comp->plane] = (comp->step_minus1 + 1) << s;\n    }\n    for (c = 0; c < 4; c++)\n        bits += steps[c];\n\n    if(!(pixdesc->flags & PIX_FMT_BITSTREAM))\n        bits *= 8;\n\n    return bits >> log2_pixels;\n}", "target": 1}
{"idx": 4983, "func": "int avpicture_layout(const AVPicture* src, enum AVPixelFormat pix_fmt,\n                     int width, int height,\n                     unsigned char *dest, int dest_size)\n{\n    int i, j, nb_planes = 0, linesizes[4];\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\n    int size = avpicture_get_size(pix_fmt, width, height);\n\n    if (size > dest_size || size < 0)\n        return AVERROR(EINVAL);\n\n    for (i = 0; i < desc->nb_components; i++)\n        nb_planes = FFMAX(desc->comp[i].plane, nb_planes);\n\n    nb_planes++;\n\n    av_image_fill_linesizes(linesizes, pix_fmt, width);\n    for (i = 0; i < nb_planes; i++) {\n        int h, shift = (i == 1 || i == 2) ? desc->log2_chroma_h : 0;\n        const unsigned char *s = src->data[i];\n        h = (height + (1 << shift) - 1) >> shift;\n\n        for (j = 0; j < h; j++) {\n            memcpy(dest, s, linesizes[i]);\n            dest += linesizes[i];\n            s += src->linesize[i];\n        }\n    }\n\n    if (desc->flags & AV_PIX_FMT_FLAG_PAL)\n        memcpy((unsigned char *)(((size_t)dest + 3) & ~3),\n               src->data[1], 256 * 4);\n\n    return size;\n}", "target": 1}
{"idx": 4984, "func": "static inline int sym_quant(int c, int e, int levels)\n{\n    int v = ((((levels * c) >> (24 - e)) + 1) >> 1) + (levels >> 1);\n    av_assert2(v >= 0 && v < levels);\n    return v;\n}", "target": 1}
{"idx": 4985, "func": "static void count_coefficients(char *item_str, int *nb_items)\n{\n    char *p;\n\n    if (!item_str)\n        return;\n\n    *nb_items = 1;\n    for (p = item_str; *p && *p != '|'; p++) {\n        if (*p == ' ')\n            (*nb_items)++;\n    }\n}", "target": 0}
{"idx": 4986, "func": "static int check_cert(X509_STORE_CTX *ctx)\n{\n    X509_CRL *crl = NULL, *dcrl = NULL;\n    int ok = 0;\n    int cnum = ctx->error_depth;\n    X509 *x = sk_X509_value(ctx->chain, cnum);\n\n    ctx->current_cert = x;\n    ctx->current_issuer = NULL;\n    ctx->current_crl_score = 0;\n    ctx->current_reasons = 0;\n\n    if (x->ex_flags & EXFLAG_PROXY)\n        return 1;\n\n    while (ctx->current_reasons != CRLDP_ALL_REASONS) {\n        unsigned int last_reasons = ctx->current_reasons;\n\n        /* Try to retrieve relevant CRL */\n        if (ctx->get_crl)\n            ok = ctx->get_crl(ctx, &crl, x);\n        else\n            ok = get_crl_delta(ctx, &crl, &dcrl, x);\n        /*\n         * If error looking up CRL, nothing we can do except notify callback\n         */\n        if (!ok) {\n            ok = verify_cb_crl(ctx, X509_V_ERR_UNABLE_TO_GET_CRL);\n            goto done;\n        }\n        ctx->current_crl = crl;\n        ok = ctx->check_crl(ctx, crl);\n        if (!ok)\n            goto done;\n\n        if (dcrl) {\n            ok = ctx->check_crl(ctx, dcrl);\n            if (!ok)\n                goto done;\n            ok = ctx->cert_crl(ctx, dcrl, x);\n            if (!ok)\n                goto done;\n        } else\n            ok = 1;\n\n        /* Don't look in full CRL if delta reason is removefromCRL */\n        if (ok != 2) {\n            ok = ctx->cert_crl(ctx, crl, x);\n            if (!ok)\n                goto done;\n        }\n\n        X509_CRL_free(crl);\n        X509_CRL_free(dcrl);\n        crl = NULL;\n        dcrl = NULL;\n        /*\n         * If reasons not updated we wont get anywhere by another iteration,\n         * so exit loop.\n         */\n        if (last_reasons == ctx->current_reasons) {\n            ok = verify_cb_crl(ctx, X509_V_ERR_UNABLE_TO_GET_CRL);\n            goto done;\n        }\n    }\n done:\n    X509_CRL_free(crl);\n    X509_CRL_free(dcrl);\n\n    ctx->current_crl = NULL;\n    return ok;\n}", "target": 0}
{"idx": 4987, "func": "int test_mod(BIO *bp, BN_CTX *ctx)\n{\n    BIGNUM *a, *b, *c, *d, *e;\n    int i;\n\n    a = BN_new();\n    b = BN_new();\n    c = BN_new();\n    d = BN_new();\n    e = BN_new();\n\n    BN_bntest_rand(a, 1024, 0, 0);\n    for (i = 0; i < num0; i++) {\n        BN_bntest_rand(b, 450 + i * 10, 0, 0);\n        a->neg = rand_neg();\n        b->neg = rand_neg();\n        BN_mod(c, a, b, ctx);\n        if (bp != NULL) {\n            if (!results) {\n                BN_print(bp, a);\n                BIO_puts(bp, \" % \");\n                BN_print(bp, b);\n                BIO_puts(bp, \" - \");\n            }\n            BN_print(bp, c);\n            BIO_puts(bp, \"\\n\");\n        }\n        BN_div(d, e, a, b, ctx);\n        BN_sub(e, e, c);\n        if (!BN_is_zero(e)) {\n            fprintf(stderr, \"Modulo test failed!\\n\");\n            return 0;\n        }\n    }\n    BN_free(a);\n    BN_free(b);\n    BN_free(c);\n    BN_free(d);\n    BN_free(e);\n    return (1);\n}", "target": 1}
{"idx": 4988, "func": "int tls_construct_finished(SSL *s, const char *sender, int slen)\n{\n    unsigned char *p;\n    int i;\n    unsigned long l;\n\n    p = ssl_handshake_start(s);\n\n    i = s->method->ssl3_enc->final_finish_mac(s,\n                                              sender, slen,\n                                              s->s3->tmp.finish_md);\n    if (i <= 0)\n        return 0;\n    s->s3->tmp.finish_md_len = i;\n    memcpy(p, s->s3->tmp.finish_md, i);\n    l = i;\n\n    /*\n     * Copy the finished so we can use it for renegotiation checks\n     */\n    if (s->type == SSL_ST_CONNECT) {\n        OPENSSL_assert(i <= EVP_MAX_MD_SIZE);\n        memcpy(s->s3->previous_client_finished, s->s3->tmp.finish_md, i);\n        s->s3->previous_client_finished_len = i;\n    } else {\n        OPENSSL_assert(i <= EVP_MAX_MD_SIZE);\n        memcpy(s->s3->previous_server_finished, s->s3->tmp.finish_md, i);\n        s->s3->previous_server_finished_len = i;\n    }\n\n    if (!ssl_set_handshake_header(s, SSL3_MT_FINISHED, l)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_FINISHED, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    return 1;\n}", "target": 0}
{"idx": 4989, "func": "int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,\n                       BN_CTX *ctx)\n{\n    int retn = 0;\n#ifdef MONT_WORD\n    BIGNUM *t;\n\n    BN_CTX_start(ctx);\n    if ((t = BN_CTX_get(ctx)) && BN_copy(t, a)) {\n        retn = bn_from_montgomery_word(ret, t, mont);\n        bn_correct_top(ret);\n        bn_check_top(ret);\n    }\n    BN_CTX_end(ctx);\n#else                           /* !MONT_WORD */\n    BIGNUM *t1, *t2;\n\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (!BN_copy(t1, a))\n        goto err;\n    BN_mask_bits(t1, mont->ri);\n\n    if (!BN_mul(t2, t1, &mont->Ni, ctx))\n        goto err;\n    BN_mask_bits(t2, mont->ri);\n\n    if (!BN_mul(t1, t2, &mont->N, ctx))\n        goto err;\n    if (!BN_add(t2, a, t1))\n        goto err;\n    if (!BN_rshift(ret, t2, mont->ri))\n        goto err;\n\n    if (BN_ucmp(ret, &(mont->N)) >= 0) {\n        if (!BN_usub(ret, ret, &(mont->N)))\n            goto err;\n    }\n    retn = 1;\n    bn_check_top(ret);\n err:\n    BN_CTX_end(ctx);\n#endif                          /* MONT_WORD */\n    return retn;\n}", "target": 0}
{"idx": 4990, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *buf)\n{\n    AVFilterContext *ctx = inlink->dst;\n    AVFilterLink *outlink = ctx->outputs[0];\n    DeflickerContext *s = ctx->priv;\n    AVDictionary **metadata;\n    AVFrame *out, *in;\n    float f;\n    int y;\n\n    if (s->q.available < s->size && !s->eof) {\n        s->luminance[s->available] = s->calc_avgy(ctx, buf);\n        ff_bufqueue_add(ctx, &s->q, buf);\n        s->available++;\n        return 0;\n    }\n\n    in = ff_bufqueue_peek(&s->q, 0);\n\n    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n    if (!out) {\n        av_frame_free(&buf);\n        return AVERROR(ENOMEM);\n    }\n\n    s->get_factor(ctx, &f);\n    s->deflicker(ctx, in->data[0], in->linesize[0], out->data[0], out->linesize[0],\n                 outlink->w, outlink->h, f);\n    for (y = 1; y < s->nb_planes; y++) {\n        av_image_copy_plane(out->data[y], out->linesize[y],\n                            in->data[y], in->linesize[y],\n                            s->planewidth[y] * (1 + (s->depth > 8)), s->planeheight[y]);\n    }\n\n    av_frame_copy_props(out, in);\n    metadata = &out->metadata;\n    if (metadata) {\n        uint8_t value[128];\n\n        snprintf(value, sizeof(value), \"%f\", s->luminance[0]);\n        av_dict_set(metadata, \"lavfi.deflicker.luminance\", value, 0);\n\n        snprintf(value, sizeof(value), \"%f\", s->luminance[0] * f);\n        av_dict_set(metadata, \"lavfi.deflicker.new_luminance\", value, 0);\n\n        snprintf(value, sizeof(value), \"%f\", f - 1.0f);\n        av_dict_set(metadata, \"lavfi.deflicker.relative_change\", value, 0);\n    }\n\n    in = ff_bufqueue_get(&s->q);\n    av_frame_free(&in);\n    memmove(&s->luminance[0], &s->luminance[1], sizeof(*s->luminance) * (s->size - 1));\n    s->luminance[s->available - 1] = s->calc_avgy(ctx, buf);\n    ff_bufqueue_add(ctx, &s->q, buf);\n\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"idx": 4991, "func": "int ff_huff_gen_len_table(uint8_t *dst, const uint64_t *stats, int stats_size, int skip0)\n{\n    HeapElem *h  = av_malloc_array(sizeof(*h), stats_size);\n    int *up      = av_malloc_array(sizeof(*up) * 2, stats_size);\n    uint8_t *len = av_malloc_array(sizeof(*len) * 2, stats_size);\n    uint16_t *map= av_malloc_array(sizeof(*map), stats_size);\n    int offset, i, next;\n    int size = 0;\n    int ret = 0;\n\n    if (!h || !up || !len) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    for (i = 0; i<stats_size; i++) {\n        dst[i] = 255;\n        if (stats[i] || !skip0)\n            map[size++] = i;\n    }\n\n    for (offset = 1; ; offset <<= 1) {\n        for (i=0; i < size; i++) {\n            h[i].name = i;\n            h[i].val = (stats[map[i]] << 14) + offset;\n        }\n        for (i = size / 2 - 1; i >= 0; i--)\n            heap_sift(h, i, size);\n\n        for (next = size; next < size * 2 - 1; next++) {\n            // merge the two smallest entries, and put it back in the heap\n            uint64_t min1v = h[0].val;\n            up[h[0].name] = next;\n            h[0].val = INT64_MAX;\n            heap_sift(h, 0, size);\n            up[h[0].name] = next;\n            h[0].name = next;\n            h[0].val += min1v;\n            heap_sift(h, 0, size);\n        }\n\n        len[2 * size - 2] = 0;\n        for (i = 2 * size - 3; i >= size; i--)\n            len[i] = len[up[i]] + 1;\n        for (i = 0; i < size; i++) {\n            dst[map[i]] = len[up[i]] + 1;\n            if (dst[map[i]] >= 32) break;\n        }\n        if (i==size) break;\n    }\nend:\n    av_free(h);\n    av_free(up);\n    av_free(len);\n    av_free(map);\n    return ret;\n}", "target": 1}
{"idx": 4992, "func": "static void vp6_parse_coeff_huffman(VP56Context *s)\n{\n    VP56Model *model = s->modelp;\n    uint8_t *permute = s->scantable.permutated;\n    VLC *vlc_coeff;\n    int coeff, sign, coeff_idx;\n    int b, cg, idx;\n    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */\n\n    for (b=0; b<6; b++) {\n        int ct = 0;    /* code type */\n        if (b > 3) pt = 1;\n        vlc_coeff = &s->dccv_vlc[pt];\n\n        for (coeff_idx=0; coeff_idx<64; ) {\n            int run = 1;\n            if (coeff_idx<2 && s->nb_null[coeff_idx][pt]) {\n                s->nb_null[coeff_idx][pt]--;\n                if (coeff_idx)\n                    break;\n            } else {\n                if (get_bits_count(&s->gb) >= s->gb.size_in_bits)\n                    return;\n                coeff = get_vlc2(&s->gb, vlc_coeff->table, 9, 3);\n                if (coeff == 0) {\n                    if (coeff_idx) {\n                        int pt = (coeff_idx >= 6);\n                        run += get_vlc2(&s->gb, s->runv_vlc[pt].table, 9, 3);\n                        if (run >= 9)\n                            run += get_bits(&s->gb, 6);\n                    } else\n                        s->nb_null[0][pt] = vp6_get_nb_null(s);\n                    ct = 0;\n                } else if (coeff == 11) {  /* end of block */\n                    if (coeff_idx == 1)    /* first AC coeff ? */\n                        s->nb_null[1][pt] = vp6_get_nb_null(s);\n                    break;\n                } else {\n                    int coeff2 = vp56_coeff_bias[coeff];\n                    if (coeff > 4)\n                        coeff2 += get_bits(&s->gb, coeff <= 9 ? coeff - 4 : 11);\n                    ct = 1 + (coeff2 > 1);\n                    sign = get_bits1(&s->gb);\n                    coeff2 = (coeff2 ^ -sign) + sign;\n                    if (coeff_idx)\n                        coeff2 *= s->dequant_ac;\n                    idx = model->coeff_index_to_pos[coeff_idx];\n                    s->block_coeff[b][permute[idx]] = coeff2;\n                }\n            }\n            coeff_idx+=run;\n            cg = FFMIN(vp6_coeff_groups[coeff_idx], 3);\n            vlc_coeff = &s->ract_vlc[pt][ct][cg];\n        }\n    }\n}", "target": 0}
{"idx": 4993, "func": "void ff_riff_write_info_tag(AVIOContext *pb, const char *tag, const char *str)\n{\n    size_t len = strlen(str);\n    if (len > 0 && len < UINT32_MAX) {\n        len++;\n        ffio_wfourcc(pb, tag);\n        avio_wl32(pb, len);\n        avio_put_str(pb, str);\n        if (len & 1)\n            avio_w8(pb, 0);\n    }\n}", "target": 0}
{"idx": 4994, "func": "static int get_slice_offset(AVCodecContext *avctx, const uint8_t *buf, int n, int slice_count, int buf_size)\n{\n    if (n < slice_count) {\n        if(avctx->slice_count) return avctx->slice_offset[n];\n        else                   return AV_RL32(buf + n*8 - 4) == 1 ? AV_RL32(buf + n*8) :  AV_RB32(buf + n*8);\n    } else\n        return buf_size;\n}", "target": 0}
{"idx": 4995, "func": "void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,\n                        int *duration)\n{\n    int64_t out_pts = AV_NOPTS_VALUE;\n    int removed_samples = 0;\n\n#ifdef DEBUG\n    ff_af_queue_log_state(afq);\n#endif\n\n    /* get output pts from the next frame or generated pts */\n    if (afq->frame_queue) {\n        if (afq->frame_queue->pts != AV_NOPTS_VALUE)\n            out_pts = afq->frame_queue->pts - afq->remaining_delay;\n    } else {\n        if (afq->next_pts != AV_NOPTS_VALUE)\n            out_pts = afq->next_pts - afq->remaining_delay;\n    }\n    if (pts) {\n        if (out_pts != AV_NOPTS_VALUE)\n            *pts = ff_samples_to_time_base(afq->avctx, out_pts);\n        else\n            *pts = AV_NOPTS_VALUE;\n    }\n\n    /* if the delay is larger than the packet duration, we use up delay samples\n       for the output packet and leave all frames in the queue */\n    if (afq->remaining_delay >= nb_samples) {\n        removed_samples      += nb_samples;\n        afq->remaining_delay -= nb_samples;\n    }\n    /* remove frames from the queue until we have enough to cover the\n       requested number of samples or until the queue is empty */\n    while (removed_samples < nb_samples && afq->frame_queue) {\n        removed_samples += afq->frame_queue->duration;\n        delete_next_frame(afq);\n    }\n    afq->remaining_samples -= removed_samples;\n\n    /* if there are no frames left and we have room for more samples, use\n       any remaining delay samples */\n    if (removed_samples < nb_samples && afq->remaining_samples > 0) {\n        int add_samples = FFMIN(afq->remaining_samples,\n                                nb_samples - removed_samples);\n        removed_samples        += add_samples;\n        afq->remaining_samples -= add_samples;\n    }\n    if (removed_samples > nb_samples)\n        av_log(afq->avctx, AV_LOG_WARNING, \"frame_size is too large\\n\");\n    if (duration)\n        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);\n}", "target": 1}
{"idx": 4996, "func": "static int filter_packet(void *log_ctx, AVPacket *pkt,\n                         AVFormatContext *fmt_ctx, AVBitStreamFilterContext *bsf_ctx)\n{\n    AVCodecContext *enc_ctx = fmt_ctx->streams[pkt->stream_index]->codec;\n    int ret;\n\n    while (bsf_ctx) {\n        AVPacket new_pkt = *pkt;\n        ret = av_bitstream_filter_filter(bsf_ctx, enc_ctx, NULL,\n                                             &new_pkt.data, &new_pkt.size,\n                                             pkt->data, pkt->size,\n                                             pkt->flags & AV_PKT_FLAG_KEY);\n        if (ret == 0 && new_pkt.data != pkt->data && new_pkt.destruct) {\n            if ((ret = av_copy_packet(&new_pkt, pkt)) < 0)\n                break;\n            ret = 1;\n        }\n\n        if (ret > 0) {\n            av_free_packet(pkt);\n            new_pkt.buf = av_buffer_create(new_pkt.data, new_pkt.size,\n                                           av_buffer_default_free, NULL, 0);\n            if (!new_pkt.buf)\n                break;\n        }\n        *pkt = new_pkt;\n\n        bsf_ctx = bsf_ctx->next;\n    }\n\n    if (ret < 0) {\n        av_log(log_ctx, AV_LOG_ERROR,\n               \"Failed to filter bitstream with filter %s for stream %d in file '%s' with codec %s\\n\",\n               bsf_ctx->filter->name, pkt->stream_index, fmt_ctx->filename,\n               avcodec_get_name(enc_ctx->codec_id));\n    }\n\n    return ret;\n}", "target": 1}
{"idx": 4997, "func": "static int ftp_type(FTPContext *s)\n{\n    const char *command = \"TYPE I\\r\\n\";\n    const int type_codes[] = {200, 500, 504, 0}; /* 500, 504 are incorrect codes */\n\n    if (ftp_send_command(s, command, type_codes, NULL) != 200)\n        return AVERROR(EIO);\n\n    return 0;\n}", "target": 0}
{"idx": 4998, "func": "int WPACKET_get_length(WPACKET *pkt, size_t *len)\n{\n    /* Internal API, so should not fail */\n    if (!ossl_assert(pkt->subs != NULL && len != NULL))\n        return 0;\n\n    *len = pkt->written - pkt->subs->pwritten;\n\n    return 1;\n}", "target": 1}
{"idx": 4999, "func": "int i2d_ASN1_SET(STACK *a, unsigned char **pp, i2d_of_void *i2d, int ex_tag,\n\t\t int ex_class, int is_set)\n\t{\n\tint ret=0,r;\n\tint i;\n\tunsigned char *p;\n        unsigned char *pStart, *pTempMem;\n        MYBLOB *rgSetBlob;\n        int totSize;\n\n\tif (a == NULL) return(0);\n\tfor (i=sk_num(a)-1; i>=0; i--)\n\t\tret+=i2d(sk_value(a,i),NULL);\n\tr=ASN1_object_size(1,ret,ex_tag);\n\tif (pp == NULL) return(r);\n\n\tp= *pp;\n\tASN1_put_object(&p,1,ret,ex_tag,ex_class);\n\n/* Modified by gp@nsj.co.jp */\n\t/* And then again by Ben */\n\t/* And again by Steve */\n\n\tif(!is_set || (sk_num(a) < 2))\n\t\t{\n\t\tfor (i=0; i<sk_num(a); i++)\n                \ti2d(sk_value(a,i),&p);\n\n\t\t*pp=p;\n\t\treturn(r);\n\t\t}\n\n        pStart  = p; /* Catch the beg of Setblobs*/\n\t\t/* In this array we will store the SET blobs */\n\t\trgSetBlob = (MYBLOB *)OPENSSL_malloc(sk_num(a) * sizeof(MYBLOB));\n\t\tif (rgSetBlob == NULL)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_I2D_ASN1_SET,ERR_R_MALLOC_FAILURE);\n\t\t\treturn(0);\n\t\t\t}\n\n        for (i=0; i<sk_num(a); i++)\n\t        {\n                rgSetBlob[i].pbData = p;  /* catch each set encode blob */\n                i2d(sk_value(a,i),&p);\n                rgSetBlob[i].cbData = p - rgSetBlob[i].pbData; /* Length of this\nSetBlob\n*/\n\t\t}\n        *pp=p;\n        totSize = p - pStart; /* This is the total size of all set blobs */\n\n /* Now we have to sort the blobs. I am using a simple algo.\n    *Sort ptrs *Copy to temp-mem *Copy from temp-mem to user-mem*/\n        qsort( rgSetBlob, sk_num(a), sizeof(MYBLOB), SetBlobCmp);\n\t\tif (!(pTempMem = OPENSSL_malloc(totSize)))\n\t\t\t{\n\t\t\tASN1err(ASN1_F_I2D_ASN1_SET,ERR_R_MALLOC_FAILURE);\n\t\t\treturn(0);\n\t\t\t}\n\n/* Copy to temp mem */\n        p = pTempMem;\n        for(i=0; i<sk_num(a); ++i)\n\t\t{\n                memcpy(p, rgSetBlob[i].pbData, rgSetBlob[i].cbData);\n                p += rgSetBlob[i].cbData;\n\t\t}\n\n/* Copy back to user mem*/\n        memcpy(pStart, pTempMem, totSize);\n        OPENSSL_free(pTempMem);\n        OPENSSL_free(rgSetBlob);\n\n        return(r);\n        }", "target": 1}
{"idx": 5000, "func": "static av_always_inline void filter_common(uint8_t *p, ptrdiff_t stride,\n                                           int is4tap)\n{\n    LOAD_PIXELS\n    int a, f1, f2;\n    const uint8_t *cm = ff_crop_tab + MAX_NEG_CROP;\n\n    a = 3 * (q0 - p0);\n\n    if (is4tap)\n        a += clip_int8(p1 - q1);\n\n    a = clip_int8(a);\n\n    // We deviate from the spec here with c(a+3) >> 3\n    // since that's what libvpx does.\n    f1 = FFMIN(a + 4, 127) >> 3;\n    f2 = FFMIN(a + 3, 127) >> 3;\n\n    // Despite what the spec says, we do need to clamp here to\n    // be bitexact with libvpx.\n    p[-1 * stride] = cm[p0 + f2];\n    p[ 0 * stride] = cm[q0 - f1];\n\n    // only used for _inner on blocks without high edge variance\n    if (!is4tap) {\n        a = (f1 + 1) >> 1;\n        p[-2 * stride] = cm[p1 + a];\n        p[ 1 * stride] = cm[q1 - a];\n    }\n}", "target": 1}
{"idx": 5001, "func": "static int allocate_buffers(ShortenContext *s)\n{\n    int i, chan;\n    int *coeffs;\n    void *tmp_ptr;\n\n    for (chan=0; chan<s->channels; chan++) {\n        if(FFMAX(1, s->nmean) >= UINT_MAX/sizeof(int32_t)){\n            av_log(s->avctx, AV_LOG_ERROR, \"nmean too large\\n\");\n            return -1;\n        }\n        if(s->blocksize + s->nwrap >= UINT_MAX/sizeof(int32_t) || s->blocksize + s->nwrap <= (unsigned)s->nwrap){\n            av_log(s->avctx, AV_LOG_ERROR, \"s->blocksize + s->nwrap too large\\n\");\n            return -1;\n        }\n\n        tmp_ptr = av_realloc(s->offset[chan], sizeof(int32_t)*FFMAX(1, s->nmean));\n        if (!tmp_ptr)\n            return AVERROR(ENOMEM);\n        s->offset[chan] = tmp_ptr;\n\n        tmp_ptr = av_realloc(s->decoded_base[chan], (s->blocksize + s->nwrap) *\n                             sizeof(s->decoded_base[0][0]));\n        if (!tmp_ptr)\n            return AVERROR(ENOMEM);\n        s->decoded_base[chan] = tmp_ptr;\n        for (i=0; i<s->nwrap; i++)\n            s->decoded_base[chan][i] = 0;\n        s->decoded[chan] = s->decoded_base[chan] + s->nwrap;\n    }\n\n    coeffs = av_realloc(s->coeffs, s->nwrap * sizeof(*s->coeffs));\n    if (!coeffs)\n        return AVERROR(ENOMEM);\n    s->coeffs = coeffs;\n\n    return 0;\n}", "target": 0}
{"idx": 5002, "func": "AP_DECLARE(char *) ap_make_full_path(apr_pool_t *a, const char *src1,\n                                  const char *src2)\n{\n    apr_size_t len1, len2;\n    char *path;\n\n    len1 = strlen(src1);\n    len2 = strlen(src2);\n     /* allocate +3 for '/' delimiter, trailing NULL and overallocate\n      * one extra byte to allow the caller to add a trailing '/'\n      */\n    path = (char *)apr_palloc(a, len1 + len2 + 3);\n    if (len1 == 0) {\n        *path = '/';\n        memcpy(path + 1, src2, len2 + 1);\n    }\n    else {\n        char *next;\n        memcpy(path, src1, len1);\n        next = path + len1;\n        if (next[-1] != '/') {\n            *next++ = '/';\n        }\n        memcpy(next, src2, len2 + 1);\n    }\n    return path;\n}", "target": 1}
{"idx": 5003, "func": "static int parse_m3d(AVFilterContext *ctx, FILE *f)\n{\n    LUT3DContext *lut3d = ctx->priv;\n    float scale;\n    int i, j, k, size, in = -1, out = -1;\n    char line[MAX_LINE_SIZE];\n    uint8_t rgb_map[3] = {0, 1, 2};\n\n    while (fgets(line, sizeof(line), f)) {\n        if      (!strncmp(line, \"in\",  2)) in  = strtol(line + 2, NULL, 0);\n        else if (!strncmp(line, \"out\", 3)) out = strtol(line + 3, NULL, 0);\n        else if (!strncmp(line, \"values\", 6)) {\n            const char *p = line + 6;\n#define SET_COLOR(id) do {                  \\\n    while (av_isspace(*p))                  \\\n        p++;                                \\\n    switch (*p) {                           \\\n    case 'r': rgb_map[id] = 0; break;       \\\n    case 'g': rgb_map[id] = 1; break;       \\\n    case 'b': rgb_map[id] = 2; break;       \\\n    }                                       \\\n    while (*p && !av_isspace(*p))           \\\n        p++;                                \\\n} while (0)\n            SET_COLOR(0);\n            SET_COLOR(1);\n            SET_COLOR(2);\n            break;\n        }\n    }\n\n    if (in == -1 || out == -1) {\n        av_log(ctx, AV_LOG_ERROR, \"in and out must be defined\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    for (size = 1; size*size*size < in; size++);\n    lut3d->lutsize = size;\n    scale = 1. / (out - 1);\n\n    for (k = 0; k < size; k++) {\n        for (j = 0; j < size; j++) {\n            for (i = 0; i < size; i++) {\n                struct rgbvec *vec = &lut3d->lut[k][j][i];\n                float val[3];\n\n                NEXT_LINE(0);\n                if (sscanf(line, \"%f %f %f\", val, val + 1, val + 2) != 3)\n                    return AVERROR_INVALIDDATA;\n                vec->r = val[rgb_map[0]] * scale;\n                vec->g = val[rgb_map[1]] * scale;\n                vec->b = val[rgb_map[2]] * scale;\n            }\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": 5004, "func": "static int bind_gost(ENGINE *e, const char *id)\n{\n    int ret = 0;\n    if (id && strcmp(id, engine_gost_id))\n        return 0;\n    if (ameth_GostR3410_2001) {\n        printf(\"GOST engine already loaded\\n\");\n        goto end;\n    }\n\n    if (!ENGINE_set_id(e, engine_gost_id)) {\n        printf(\"ENGINE_set_id failed\\n\");\n        goto end;\n    }\n    if (!ENGINE_set_name(e, engine_gost_name)) {\n        printf(\"ENGINE_set_name failed\\n\");\n        goto end;\n    }\n    if (!ENGINE_set_digests(e, gost_digests)) {\n        printf(\"ENGINE_set_digests failed\\n\");\n        goto end;\n    }\n    if (!ENGINE_set_ciphers(e, gost_ciphers)) {\n        printf(\"ENGINE_set_ciphers failed\\n\");\n        goto end;\n    }\n    if (!ENGINE_set_pkey_meths(e, gost_pkey_meths)) {\n        printf(\"ENGINE_set_pkey_meths failed\\n\");\n        goto end;\n    }\n    if (!ENGINE_set_pkey_asn1_meths(e, gost_pkey_asn1_meths)) {\n        printf(\"ENGINE_set_pkey_asn1_meths failed\\n\");\n        goto end;\n    }\n    /* Control function and commands */\n    if (!ENGINE_set_cmd_defns(e, gost_cmds)) {\n        fprintf(stderr, \"ENGINE_set_cmd_defns failed\\n\");\n        goto end;\n    }\n    if (!ENGINE_set_ctrl_function(e, gost_control_func)) {\n        fprintf(stderr, \"ENGINE_set_ctrl_func failed\\n\");\n        goto end;\n    }\n    if (!ENGINE_set_destroy_function(e, gost_engine_destroy)\n        || !ENGINE_set_init_function(e, gost_engine_init)\n        || !ENGINE_set_finish_function(e, gost_engine_finish)) {\n        goto end;\n    }\n\n    if (!register_ameth_gost\n        (NID_id_GostR3410_2001, &ameth_GostR3410_2001, \"GOST2001\",\n         \"GOST R 34.10-2001\"))\n        goto end;\n    if (!register_ameth_gost(NID_id_Gost28147_89_MAC, &ameth_Gost28147_MAC,\n                             \"GOST-MAC\", \"GOST 28147-89 MAC\"))\n        goto end;\n\n    if (!register_pmeth_gost(NID_id_GostR3410_2001, &pmeth_GostR3410_2001, 0))\n        goto end;\n    if (!register_pmeth_gost(NID_id_Gost28147_89_MAC, &pmeth_Gost28147_MAC, 0))\n        goto end;\n    if (!ENGINE_register_ciphers(e)\n        || !ENGINE_register_digests(e)\n        || !ENGINE_register_pkey_meths(e)\n        /* These two actually should go in LIST_ADD command */\n        || !EVP_add_cipher(&cipher_gost)\n        || !EVP_add_cipher(&cipher_gost_cpacnt)\n        || !EVP_add_digest(&digest_gost)\n        || !EVP_add_digest(&imit_gost_cpa)\n        ) {\n        goto end;\n    }\n\n    ERR_load_GOST_strings();\n    ret = 1;\n end:\n    return ret;\n}", "target": 0}
{"idx": 5005, "func": "static void init_input_filter(FilterGraph *fg, AVFilterInOut *in)\n{\n    InputStream *ist = NULL;\n    enum AVMediaType type = avfilter_pad_get_type(in->filter_ctx->input_pads, in->pad_idx);\n    int i;\n\n    // TODO: support other filter types\n    if (type != AVMEDIA_TYPE_VIDEO && type != AVMEDIA_TYPE_AUDIO) {\n        av_log(NULL, AV_LOG_FATAL, \"Only video and audio filters supported \"\n               \"currently.\\n\");\n        exit_program(1);\n    }\n\n    if (in->name) {\n        AVFormatContext *s;\n        AVStream       *st = NULL;\n        char *p;\n        int file_idx = strtol(in->name, &p, 0);\n\n        if (file_idx < 0 || file_idx >= nb_input_files) {\n            av_log(NULL, AV_LOG_FATAL, \"Invalid file index %d in filtegraph description %s.\\n\",\n                   file_idx, fg->graph_desc);\n            exit_program(1);\n        }\n        s = input_files[file_idx]->ctx;\n\n        for (i = 0; i < s->nb_streams; i++) {\n            if (s->streams[i]->codec->codec_type != type)\n                continue;\n            if (check_stream_specifier(s, s->streams[i], *p == ':' ? p + 1 : p) == 1) {\n                st = s->streams[i];\n                break;\n            }\n        }\n        if (!st) {\n            av_log(NULL, AV_LOG_FATAL, \"Stream specifier '%s' in filtergraph description %s \"\n                   \"matches no streams.\\n\", p, fg->graph_desc);\n            exit_program(1);\n        }\n        ist = input_streams[input_files[file_idx]->ist_index + st->index];\n    } else {\n        /* find the first unused stream of corresponding type */\n        for (i = 0; i < nb_input_streams; i++) {\n            ist = input_streams[i];\n            if (ist->st->codec->codec_type == type && ist->discard)\n                break;\n        }\n        if (i == nb_input_streams) {\n            av_log(NULL, AV_LOG_FATAL, \"Cannot find a matching stream for \"\n                   \"unlabeled input pad %d on filter %s\", in->pad_idx,\n                   in->filter_ctx->name);\n            exit_program(1);\n        }\n    }\n    av_assert0(ist);\n\n    ist->discard         = 0;\n    ist->decoding_needed = 1;\n    ist->st->discard = AVDISCARD_NONE;\n\n    fg->inputs = grow_array(fg->inputs, sizeof(*fg->inputs),\n                            &fg->nb_inputs, fg->nb_inputs + 1);\n    if (!(fg->inputs[fg->nb_inputs - 1] = av_mallocz(sizeof(*fg->inputs[0]))))\n        exit_program(1);\n    fg->inputs[fg->nb_inputs - 1]->ist   = ist;\n    fg->inputs[fg->nb_inputs - 1]->graph = fg;\n\n    ist->filters = grow_array(ist->filters, sizeof(*ist->filters),\n                              &ist->nb_filters, ist->nb_filters + 1);\n    ist->filters[ist->nb_filters - 1] = fg->inputs[fg->nb_inputs - 1];\n}", "target": 0}
{"idx": 5006, "func": "static av_cold void init_cavlc_level_tab(void){\n    int suffix_length, mask;\n    unsigned int i;\n\n    for(suffix_length=0; suffix_length<7; suffix_length++){\n        for(i=0; i<(1<<LEVEL_TAB_BITS); i++){\n            int prefix= LEVEL_TAB_BITS - av_log2(2*i);\n            int level_code= (prefix<<suffix_length) + (i>>(LEVEL_TAB_BITS-prefix-1-suffix_length)) - (1<<suffix_length);\n\n            mask= -(level_code&1);\n            level_code= (((2+level_code)>>1) ^ mask) - mask;\n            if(prefix + 1 + suffix_length <= LEVEL_TAB_BITS){\n                cavlc_level_tab[suffix_length][i][0]= level_code;\n                cavlc_level_tab[suffix_length][i][1]= prefix + 1 + suffix_length;\n            }else if(prefix + 1 <= LEVEL_TAB_BITS){\n                cavlc_level_tab[suffix_length][i][0]= prefix+100;\n                cavlc_level_tab[suffix_length][i][1]= prefix + 1;\n            }else{\n                cavlc_level_tab[suffix_length][i][0]= LEVEL_TAB_BITS+100;\n                cavlc_level_tab[suffix_length][i][1]= LEVEL_TAB_BITS;\n            }\n        }\n    }\n}", "target": 1}
{"idx": 5007, "func": "void ff_vp3_h_loop_filter_c(uint8_t *first_pixel, int stride, int *bounding_values)\n{\n    unsigned char *end;\n    int filter_value;\n\n    for (end= first_pixel + 8*stride; first_pixel != end; first_pixel += stride) {\n        filter_value =\n            (first_pixel[-2] - first_pixel[ 1])\n         +3*(first_pixel[ 0] - first_pixel[-1]);\n        filter_value = bounding_values[(filter_value + 4) >> 3];\n        first_pixel[-1] = av_clip_uint8(first_pixel[-1] + filter_value);\n        first_pixel[ 0] = av_clip_uint8(first_pixel[ 0] - filter_value);\n    }\n}", "target": 1}
{"idx": 5008, "func": "static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,\n                                                uint8_t *dest_y,\n                                                uint8_t *dest_cb,\n                                                uint8_t *dest_cr,\n                                                int field_based,\n                                                int bottom_field,\n                                                int field_select,\n                                                uint8_t **ref_picture,\n                                                h264_chroma_mc_func *pix_op,\n                                                int motion_x, int motion_y,\n                                                int h, int mb_y)\n{\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n    int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, sx, sy, uvsx, uvsy;\n    ptrdiff_t uvlinesize, linesize;\n    const int lowres     = s->avctx->lowres;\n    const int op_index   = FFMIN(lowres-1+s->chroma_x_shift, 3);\n    const int block_s    = 8>>lowres;\n    const int s_mask     = (2 << lowres) - 1;\n    const int h_edge_pos = s->h_edge_pos >> lowres;\n    const int v_edge_pos = s->v_edge_pos >> lowres;\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n    // FIXME obviously not perfect but qpel will not work in lowres anyway\n    if (s->quarter_sample) {\n        motion_x /= 2;\n        motion_y /= 2;\n    }\n\n    if(field_based){\n        motion_y += (bottom_field - field_select)*((1 << lowres)-1);\n    }\n\n    sx = motion_x & s_mask;\n    sy = motion_y & s_mask;\n    src_x = s->mb_x * 2 * block_s + (motion_x >> lowres + 1);\n    src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1);\n\n    if (s->out_format == FMT_H263) {\n        uvsx    = ((motion_x >> 1) & s_mask) | (sx & 1);\n        uvsy    = ((motion_y >> 1) & s_mask) | (sy & 1);\n        uvsrc_x = src_x >> 1;\n        uvsrc_y = src_y >> 1;\n    } else if (s->out_format == FMT_H261) {\n        // even chroma mv's are full pel in H261\n        mx      = motion_x / 4;\n        my      = motion_y / 4;\n        uvsx    = (2 * mx) & s_mask;\n        uvsy    = (2 * my) & s_mask;\n        uvsrc_x = s->mb_x * block_s + (mx >> lowres);\n        uvsrc_y =    mb_y * block_s + (my >> lowres);\n    } else {\n        if(s->chroma_y_shift){\n            mx      = motion_x / 2;\n            my      = motion_y / 2;\n            uvsx    = mx & s_mask;\n            uvsy    = my & s_mask;\n            uvsrc_x = s->mb_x * block_s                 + (mx >> lowres + 1);\n            uvsrc_y =   (mb_y * block_s >> field_based) + (my >> lowres + 1);\n        } else {\n            if(s->chroma_x_shift){\n            //Chroma422\n                mx = motion_x / 2;\n                uvsx = mx & s_mask;\n                uvsy = motion_y & s_mask;\n                uvsrc_y = src_y;\n                uvsrc_x = s->mb_x*block_s               + (mx >> (lowres+1));\n            } else {\n            //Chroma444\n                uvsx = motion_x & s_mask;\n                uvsy = motion_y & s_mask;\n                uvsrc_x = src_x;\n                uvsrc_y = src_y;\n            }\n        }\n    }\n\n    ptr_y  = ref_picture[0] + src_y   * linesize   + src_x;\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    if ((unsigned) src_x > FFMAX( h_edge_pos - (!!sx) - 2 * block_s,       0) || uvsrc_y<0 ||\n        (unsigned) src_y > FFMAX((v_edge_pos >> field_based) - (!!sy) - h, 0)) {\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y,\n                                linesize >> field_based, 17, 17 + field_based,\n                                src_x, src_y << field_based, h_edge_pos,\n                                v_edge_pos);\n        ptr_y = s->edge_emu_buffer;\n        if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n            uint8_t *uvbuf = s->edge_emu_buffer + 18 * s->linesize;\n            s->vdsp.emulated_edge_mc(uvbuf , ptr_cb, uvlinesize >> field_based, 9,\n                                    9 + field_based,\n                                    uvsrc_x, uvsrc_y << field_based,\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n            s->vdsp.emulated_edge_mc(uvbuf + 16, ptr_cr, uvlinesize >> field_based, 9,\n                                    9 + field_based,\n                                    uvsrc_x, uvsrc_y << field_based,\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n            ptr_cb = uvbuf;\n            ptr_cr = uvbuf + 16;\n        }\n    }\n\n    // FIXME use this for field pix too instead of the obnoxious hack which changes picture.f.data\n    if (bottom_field) {\n        dest_y  += s->linesize;\n        dest_cb += s->uvlinesize;\n        dest_cr += s->uvlinesize;\n    }\n\n    if (field_select) {\n        ptr_y   += s->linesize;\n        ptr_cb  += s->uvlinesize;\n        ptr_cr  += s->uvlinesize;\n    }\n\n    sx = (sx << 2) >> lowres;\n    sy = (sy << 2) >> lowres;\n    pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);\n\n    if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n        int hc = s->chroma_y_shift ? (h+1-bottom_field)>>1 : h;\n        uvsx = (uvsx << 2) >> lowres;\n        uvsy = (uvsy << 2) >> lowres;\n        if (hc) {\n            pix_op[op_index](dest_cb, ptr_cb, uvlinesize, hc, uvsx, uvsy);\n            pix_op[op_index](dest_cr, ptr_cr, uvlinesize, hc, uvsx, uvsy);\n        }\n    }\n    // FIXME h261 lowres loop filter\n}", "target": 0}
{"idx": 5009, "func": "static int submit_packet(PerThreadContext *p, AVCodecContext *user_avctx,\n                         AVPacket *avpkt)\n{\n    FrameThreadContext *fctx = p->parent;\n    PerThreadContext *prev_thread = fctx->prev_thread;\n    const AVCodec *codec = p->avctx->codec;\n    int ret;\n\n    if (!avpkt->size && !(codec->capabilities & AV_CODEC_CAP_DELAY))\n        return 0;\n\n    pthread_mutex_lock(&p->mutex);\n\n    ret = update_context_from_user(p->avctx, user_avctx);\n    if (ret) {\n        pthread_mutex_unlock(&p->mutex);\n        return ret;\n    }\n\n    release_delayed_buffers(p);\n\n    if (prev_thread) {\n        int err;\n        if (atomic_load(&prev_thread->state) == STATE_SETTING_UP) {\n            pthread_mutex_lock(&prev_thread->progress_mutex);\n            while (atomic_load(&prev_thread->state) == STATE_SETTING_UP)\n                pthread_cond_wait(&prev_thread->progress_cond, &prev_thread->progress_mutex);\n            pthread_mutex_unlock(&prev_thread->progress_mutex);\n        }\n\n        err = update_context_from_thread(p->avctx, prev_thread->avctx, 0);\n        if (err) {\n            pthread_mutex_unlock(&p->mutex);\n            return err;\n        }\n    }\n\n    av_packet_unref(&p->avpkt);\n    ret = av_packet_ref(&p->avpkt, avpkt);\n    if (ret < 0) {\n        pthread_mutex_unlock(&p->mutex);\n        av_log(p->avctx, AV_LOG_ERROR, \"av_packet_ref() failed in submit_packet()\\n\");\n        return ret;\n    }\n\n    atomic_store(&p->state, STATE_SETTING_UP);\n    pthread_cond_signal(&p->input_cond);\n    pthread_mutex_unlock(&p->mutex);\n\n    /*\n     * If the client doesn't have a thread-safe get_buffer(),\n     * then decoding threads call back to the main thread,\n     * and it calls back to the client here.\n     */\n\n    if (!p->avctx->thread_safe_callbacks && (\n         p->avctx->get_format != avcodec_default_get_format ||\n         p->avctx->get_buffer2 != avcodec_default_get_buffer2)) {\n        while (atomic_load(&p->state) != STATE_SETUP_FINISHED && atomic_load(&p->state) != STATE_INPUT_READY) {\n            int call_done = 1;\n            pthread_mutex_lock(&p->progress_mutex);\n            while (atomic_load(&p->state) == STATE_SETTING_UP)\n                pthread_cond_wait(&p->progress_cond, &p->progress_mutex);\n\n            switch (atomic_load_explicit(&p->state, memory_order_acquire)) {\n            case STATE_GET_BUFFER:\n                p->result = ff_get_buffer(p->avctx, p->requested_frame, p->requested_flags);\n                break;\n            case STATE_GET_FORMAT:\n                p->result_format = ff_get_format(p->avctx, p->available_formats);\n                break;\n            default:\n                call_done = 0;\n                break;\n            }\n            if (call_done) {\n                atomic_store(&p->state, STATE_SETTING_UP);\n                pthread_cond_signal(&p->progress_cond);\n            }\n            pthread_mutex_unlock(&p->progress_mutex);\n        }\n    }\n\n    fctx->prev_thread = p;\n    fctx->next_decoding++;\n\n    return 0;\n}", "target": 0}
{"idx": 5010, "func": "static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,\n                             GetByteContext *gb)\n{\n    unsigned char rle_code;\n    unsigned char extra_byte, odd_pixel;\n    unsigned char stream_byte;\n    unsigned int pixel_ptr = 0;\n    int row_dec = pic->linesize[0];\n    int row_ptr = (avctx->height - 1) * row_dec;\n    int frame_size = FFABS(row_dec) * avctx->height;\n    int i;\n\n    while (row_ptr >= 0) {\n        if (bytestream2_get_bytes_left(gb) <= 0) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"MS RLE: bytestream overrun, %d rows left\\n\",\n                   row_ptr);\n            return AVERROR_INVALIDDATA;\n        }\n        rle_code = stream_byte = bytestream2_get_byteu(gb);\n        if (rle_code == 0) {\n            /* fetch the next byte to see how to handle escape code */\n            stream_byte = bytestream2_get_byte(gb);\n            if (stream_byte == 0) {\n                /* line is done, goto the next one */\n                row_ptr -= row_dec;\n                pixel_ptr = 0;\n            } else if (stream_byte == 1) {\n                /* decode is done */\n                return 0;\n            } else if (stream_byte == 2) {\n                /* reposition frame decode coordinates */\n                stream_byte = bytestream2_get_byte(gb);\n                pixel_ptr += stream_byte;\n                stream_byte = bytestream2_get_byte(gb);\n                row_ptr -= stream_byte * row_dec;\n            } else {\n                // copy pixels from encoded stream\n                odd_pixel =  stream_byte & 1;\n                rle_code = (stream_byte + 1) / 2;\n                extra_byte = rle_code & 0x01;\n                if (row_ptr + pixel_ptr + stream_byte > frame_size ||\n                    bytestream2_get_bytes_left(gb) < rle_code) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                for (i = 0; i < rle_code; i++) {\n                    if (pixel_ptr >= avctx->width)\n                        break;\n                    stream_byte = bytestream2_get_byteu(gb);\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n                    pixel_ptr++;\n                    if (i + 1 == rle_code && odd_pixel)\n                        break;\n                    if (pixel_ptr >= avctx->width)\n                        break;\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n                    pixel_ptr++;\n                }\n\n                // if the RLE code is odd, skip a byte in the stream\n                if (extra_byte)\n                    bytestream2_skip(gb, 1);\n            }\n        } else {\n            // decode a run of data\n            if (row_ptr + pixel_ptr + stream_byte > frame_size) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"MS RLE: frame ptr just went out of bounds (run)\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            stream_byte = bytestream2_get_byte(gb);\n            for (i = 0; i < rle_code; i++) {\n                if (pixel_ptr >= avctx->width)\n                    break;\n                if ((i & 1) == 0)\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n                else\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n                pixel_ptr++;\n            }\n        }\n    }\n\n    /* one last sanity check on the way out */\n    if (bytestream2_get_bytes_left(gb)) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"MS RLE: ended frame decode with %d bytes left over\\n\",\n               bytestream2_get_bytes_left(gb));\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5011, "func": "void ff_mqc_init_context_tables(void)\n{\n    int i;\n    for (i = 0; i < 47; i++) {\n        ff_mqc_qe[2 * i]     =\n        ff_mqc_qe[2 * i + 1] = cx_states[i].qe;\n\n        ff_mqc_nlps[2 * i]     = 2 * cx_states[i].nlps + cx_states[i].sw;\n        ff_mqc_nlps[2 * i + 1] = 2 * cx_states[i].nlps + 1 - cx_states[i].sw;\n        ff_mqc_nmps[2 * i]     = 2 * cx_states[i].nmps;\n        ff_mqc_nmps[2 * i + 1] = 2 * cx_states[i].nmps + 1;\n    }\n}", "target": 0}
{"idx": 5012, "func": "static inline void idct_col(int16_t *blk, const uint8_t *quant)\n{\n    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;\n    int t10, t11, t12, t13;\n    int s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = (int) blk[0 * 8] * quant[0 * 8];\n    s1 = (int) blk[1 * 8] * quant[1 * 8];\n    s2 = (int) blk[2 * 8] * quant[2 * 8];\n    s3 = (int) blk[3 * 8] * quant[3 * 8];\n    s4 = (int) blk[4 * 8] * quant[4 * 8];\n    s5 = (int) blk[5 * 8] * quant[5 * 8];\n    s6 = (int) blk[6 * 8] * quant[6 * 8];\n    s7 = (int) blk[7 * 8] * quant[7 * 8];\n\n    t0  =  (s3 * 19266 + s5 * 12873) >> 15;\n    t1  =  (s5 * 19266 - s3 * 12873) >> 15;\n    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;\n    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;\n    t4  = t0 * 2 + t2;\n    t5  = t1 * 2 + t3;\n    t6  = t2 - t3;\n    t7  = t3 * 2 + t6;\n    t8  = (t6 * 11585) >> 14;\n    t9  = (t7 * 11585) >> 14;\n    tA  = (s2 * 8867 - s6 * 21407) >> 14;\n    tB  = (s6 * 8867 + s2 * 21407) >> 14;\n    tC  = (s0 >> 1) - (s4 >> 1);\n    tD  = (s4 >> 1) * 2 + tC;\n    tE  = tC - (tA >> 1);\n    tF  = tD - (tB >> 1);\n    t10 = tF - t5;\n    t11 = tE - t8;\n    t12 = tE + (tA >> 1) * 2 - t9;\n    t13 = tF + (tB >> 1) * 2 - t4;\n\n    blk[0 * 8] = t13 + t4 * 2;\n    blk[1 * 8] = t12 + t9 * 2;\n    blk[2 * 8] = t11 + t8 * 2;\n    blk[3 * 8] = t10 + t5 * 2;\n    blk[4 * 8] = t10;\n    blk[5 * 8] = t11;\n    blk[6 * 8] = t12;\n    blk[7 * 8] = t13;\n}", "target": 1}
{"idx": 5013, "func": "int ff_h264_decode_sei(H264Context *h){\n    while (get_bits_left(&h->gb) > 16) {\n        int size, type;\n\n        type=0;\n        do{\n            if (get_bits_left(&h->gb) < 8)\n                return AVERROR_INVALIDDATA;\n            type+= show_bits(&h->gb, 8);\n        }while(get_bits(&h->gb, 8) == 255);\n\n        size=0;\n        do{\n            if (get_bits_left(&h->gb) < 8)\n                return AVERROR_INVALIDDATA;\n            size+= show_bits(&h->gb, 8);\n        }while(get_bits(&h->gb, 8) == 255);\n\n        if(h->avctx->debug&FF_DEBUG_STARTCODE)\n            av_log(h->avctx, AV_LOG_DEBUG, \"SEI %d len:%d\\n\", type, size);\n\n        switch(type){\n        case SEI_TYPE_PIC_TIMING: // Picture timing SEI\n            if(decode_picture_timing(h) < 0)\n                return -1;\n            break;\n        case SEI_TYPE_USER_DATA_ITU_T_T35:\n            if(decode_user_data_itu_t_t35(h, size) < 0)\n                return -1;\n            break;\n        case SEI_TYPE_USER_DATA_UNREGISTERED:\n            if(decode_unregistered_user_data(h, size) < 0)\n                return -1;\n            break;\n        case SEI_TYPE_RECOVERY_POINT:\n            if(decode_recovery_point(h) < 0)\n                return -1;\n            break;\n        case SEI_BUFFERING_PERIOD:\n            if(decode_buffering_period(h) < 0)\n                return -1;\n            break;\n        case SEI_TYPE_FRAME_PACKING:\n            if(decode_frame_packing(h, size) < 0)\n                return -1;\n        default:\n            skip_bits(&h->gb, 8*size);\n        }\n\n        //FIXME check bits here\n        align_get_bits(&h->gb);\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5014, "func": "int ossl_method_store_cache_set(OSSL_METHOD_STORE *store, int nid,\n                                const char *prop_query, void *method)\n{\n    QUERY elem, *old, *p = NULL;\n    ALGORITHM *alg;\n    size_t len;\n\n    if (nid <= 0 || store == NULL)\n        return 0;\n    if (prop_query == NULL)\n        return 1;\n\n    ossl_property_write_lock(store);\n    if (store->need_flush)\n        ossl_method_cache_flush_some(store);\n    alg = ossl_method_store_retrieve(store, nid);\n    if (alg == NULL) {\n        ossl_property_unlock(store);\n        return 0;\n    }\n\n    if (method == NULL) {\n        elem.query = prop_query;\n        if (lh_QUERY_delete(alg->cache, &elem) != NULL)\n            store->nelem--;\n        ossl_property_unlock(store);\n        return 1;\n    }\n    p = OPENSSL_malloc(sizeof(*p) + (len = strlen(prop_query)));\n    if (p != NULL) {\n        p->query = p->body;\n        p->method = method;\n        memcpy((char *)p->query, prop_query, len + 1);\n        if ((old = lh_QUERY_insert(alg->cache, p)) != NULL) {\n            OPENSSL_free(old);\n            ossl_property_unlock(store);\n            return 1;\n        }\n        if (!lh_QUERY_error(alg->cache)) {\n            if (++store->nelem >= IMPL_CACHE_FLUSH_THRESHOLD)\n                store->need_flush = 1;\n            ossl_property_unlock(store);\n            return 1;\n        }\n    }\n    ossl_property_unlock(store);\n    OPENSSL_free(p);\n    return 0;\n}", "target": 1}
{"idx": 5015, "func": "static void filter_mb_edgev( H264Context *h, uint8_t *pix, int stride, int16_t bS[4], int qp ) {\n    const int index_a = qp + h->slice_alpha_c0_offset;\n    const int alpha = (alpha_table+52)[index_a];\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n    if (alpha ==0 || beta == 0) return;\n\n    if( bS[0] < 4 ) {\n        int8_t tc[4];\n        tc[0] = (tc0_table+52)[index_a][bS[0]];\n        tc[1] = (tc0_table+52)[index_a][bS[1]];\n        tc[2] = (tc0_table+52)[index_a][bS[2]];\n        tc[3] = (tc0_table+52)[index_a][bS[3]];\n        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);\n    } else {\n        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);\n    }\n}", "target": 1}
{"idx": 5016, "func": "static ngx_int_t\nngx_http_range_multipart_header(ngx_http_request_t *r,\n    ngx_http_range_filter_ctx_t *ctx)\n{\n    off_t               len;\n    size_t              size;\n    ngx_uint_t          i;\n    ngx_http_range_t   *range;\n    ngx_atomic_uint_t   boundary;\n\n    size = sizeof(CRLF \"--\") - 1 + NGX_ATOMIC_T_LEN\n           + sizeof(CRLF \"Content-Type: \") - 1\n           + r->headers_out.content_type.len\n           + sizeof(CRLF \"Content-Range: bytes \") - 1;\n\n    if (r->headers_out.content_type_len == r->headers_out.content_type.len\n        && r->headers_out.charset.len)\n    {\n        size += sizeof(\"; charset=\") - 1 + r->headers_out.charset.len;\n    }\n\n    ctx->boundary_header.data = ngx_pnalloc(r->pool, size);\n    if (ctx->boundary_header.data == NULL) {\n        return NGX_ERROR;\n    }\n\n    boundary = ngx_next_temp_number(0);\n\n    /*\n     * The boundary header of the range:\n     * CRLF\n     * \"--0123456789\" CRLF\n     * \"Content-Type: image/jpeg\" CRLF\n     * \"Content-Range: bytes \"\n     */\n\n    if (r->headers_out.content_type_len == r->headers_out.content_type.len\n        && r->headers_out.charset.len)\n    {\n        ctx->boundary_header.len = ngx_sprintf(ctx->boundary_header.data,\n                                           CRLF \"--%0muA\" CRLF\n                                           \"Content-Type: %V; charset=%V\" CRLF\n                                           \"Content-Range: bytes \",\n                                           boundary,\n                                           &r->headers_out.content_type,\n                                           &r->headers_out.charset)\n                                   - ctx->boundary_header.data;\n\n    } else if (r->headers_out.content_type.len) {\n        ctx->boundary_header.len = ngx_sprintf(ctx->boundary_header.data,\n                                           CRLF \"--%0muA\" CRLF\n                                           \"Content-Type: %V\" CRLF\n                                           \"Content-Range: bytes \",\n                                           boundary,\n                                           &r->headers_out.content_type)\n                                   - ctx->boundary_header.data;\n\n    } else {\n        ctx->boundary_header.len = ngx_sprintf(ctx->boundary_header.data,\n                                           CRLF \"--%0muA\" CRLF\n                                           \"Content-Range: bytes \",\n                                           boundary)\n                                   - ctx->boundary_header.data;\n    }\n\n    r->headers_out.content_type.data =\n        ngx_pnalloc(r->pool,\n                    sizeof(\"Content-Type: multipart/byteranges; boundary=\") - 1\n                    + NGX_ATOMIC_T_LEN);\n\n    if (r->headers_out.content_type.data == NULL) {\n        return NGX_ERROR;\n    }\n\n    r->headers_out.content_type_lowcase = NULL;\n\n    /* \"Content-Type: multipart/byteranges; boundary=0123456789\" */\n\n    r->headers_out.content_type.len =\n                           ngx_sprintf(r->headers_out.content_type.data,\n                                       \"multipart/byteranges; boundary=%0muA\",\n                                       boundary)\n                           - r->headers_out.content_type.data;\n\n    r->headers_out.content_type_len = r->headers_out.content_type.len;\n\n    r->headers_out.charset.len = 0;\n\n    /* the size of the last boundary CRLF \"--0123456789--\" CRLF */\n\n    len = sizeof(CRLF \"--\") - 1 + NGX_ATOMIC_T_LEN + sizeof(\"--\" CRLF) - 1;\n\n    range = ctx->ranges.elts;\n    for (i = 0; i < ctx->ranges.nelts; i++) {\n\n        /* the size of the range: \"SSSS-EEEE/TTTT\" CRLF CRLF */\n\n        range[i].content_range.data =\n                               ngx_pnalloc(r->pool, 3 * NGX_OFF_T_LEN + 2 + 4);\n\n        if (range[i].content_range.data == NULL) {\n            return NGX_ERROR;\n        }\n\n        range[i].content_range.len = ngx_sprintf(range[i].content_range.data,\n                                               \"%O-%O/%O\" CRLF CRLF,\n                                               range[i].start, range[i].end - 1,\n                                               r->headers_out.content_length_n)\n                                     - range[i].content_range.data;\n\n        len += ctx->boundary_header.len + range[i].content_range.len\n                                             + (range[i].end - range[i].start);\n    }\n\n    r->headers_out.content_length_n = len;\n\n    if (r->headers_out.content_length) {\n        r->headers_out.content_length->hash = 0;\n        r->headers_out.content_length = NULL;\n    }\n\n    return ngx_http_next_header_filter(r);\n}", "target": 0}
{"idx": 5017, "func": "static av_always_inline\nvoid vp78_decode_mv_mb_modes(AVCodecContext *avctx, VP8Frame *curframe,\n                                    VP8Frame *prev_frame, int is_vp7)\n{\n    VP8Context *s = avctx->priv_data;\n    int mb_x, mb_y;\n\n    s->mv_min.y = -MARGIN;\n    s->mv_max.y = ((s->mb_height - 1) << 6) + MARGIN;\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        VP8Macroblock *mb = s->macroblocks_base +\n                            ((s->mb_width + 1) * (mb_y + 1) + 1);\n        int mb_xy = mb_y * s->mb_width;\n\n        AV_WN32A(s->intra4x4_pred_mode_left, DC_PRED * 0x01010101);\n\n        s->mv_min.x = -MARGIN;\n        s->mv_max.x = ((s->mb_width - 1) << 6) + MARGIN;\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) {\n            if (mb_y == 0)\n                AV_WN32A((mb - s->mb_width - 1)->intra4x4_pred_mode_top,\n                         DC_PRED * 0x01010101);\n            decode_mb_mode(s, mb, mb_x, mb_y, curframe->seg_map->data + mb_xy,\n                           prev_frame && prev_frame->seg_map ?\n                           prev_frame->seg_map->data + mb_xy : NULL, 1, is_vp7);\n            s->mv_min.x -= 64;\n            s->mv_max.x -= 64;\n        }\n        s->mv_min.y -= 64;\n        s->mv_max.y -= 64;\n    }\n}", "target": 0}
{"idx": 5018, "func": "int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)\n{\n    AVDictionaryEntry *title = av_dict_get(ac[0]->metadata, \"title\", NULL, 0);\n    struct sdp_session_level s = { 0 };\n    int i, j, port, ttl, is_multicast, index = 0;\n    char dst[32], dst_type[5];\n\n    memset(buf, 0, size);\n    s.user = \"-\";\n    s.src_addr = \"127.0.0.1\";    /* FIXME: Properly set this */\n    s.src_type = \"IP4\";\n    s.name = title ? title->value : \"No Name\";\n\n    port = 0;\n    ttl = 0;\n    if (n_files == 1) {\n        port = sdp_get_address(dst, sizeof(dst), &ttl, ac[0]->filename);\n        is_multicast = resolve_destination(dst, sizeof(dst), dst_type,\n                                           sizeof(dst_type));\n        if (!is_multicast)\n            ttl = 0;\n        if (dst[0]) {\n            s.dst_addr = dst;\n            s.dst_type = dst_type;\n            s.ttl = ttl;\n            if (!strcmp(dst_type, \"IP6\")) {\n                s.src_addr = \"::1\";\n                s.src_type = \"IP6\";\n            }\n        }\n    }\n    sdp_write_header(buf, size, &s);\n\n    dst[0] = 0;\n    for (i = 0; i < n_files; i++) {\n        if (n_files != 1) {\n            port = sdp_get_address(dst, sizeof(dst), &ttl, ac[i]->filename);\n            is_multicast = resolve_destination(dst, sizeof(dst), dst_type,\n                                               sizeof(dst_type));\n            if (!is_multicast)\n                ttl = 0;\n        }\n        for (j = 0; j < ac[i]->nb_streams; j++) {\n            ff_sdp_write_media(buf, size, ac[i]->streams[j], index++,\n                               dst[0] ? dst : NULL, dst_type,\n                               (port > 0) ? port + j * 2 : 0,\n                               ttl, ac[i]);\n            if (port <= 0) {\n                av_strlcatf(buf, size,\n                                   \"a=control:streamid=%d\\r\\n\", i + j);\n            }\n            if (ac[i]->pb && ac[i]->pb->av_class) {\n                uint8_t *crypto_suite = NULL, *crypto_params = NULL;\n                av_opt_get(ac[i]->pb, \"srtp_out_suite\",  AV_OPT_SEARCH_CHILDREN,\n                           &crypto_suite);\n                av_opt_get(ac[i]->pb, \"srtp_out_params\", AV_OPT_SEARCH_CHILDREN,\n                           &crypto_params);\n                if (crypto_suite && crypto_suite[0])\n                    av_strlcatf(buf, size,\n                                \"a=crypto:1 %s inline:%s\\r\\n\",\n                                crypto_suite, crypto_params);\n                av_free(crypto_suite);\n                av_free(crypto_params);\n            }\n        }\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5019, "func": "static int filter_packet(void *log_ctx, AVPacket *pkt,\n                         AVFormatContext *fmt_ctx, AVBitStreamFilterContext *bsf_ctx)\n{\n    AVCodecContext *enc_ctx = fmt_ctx->streams[pkt->stream_index]->codec;\n    int ret = 0;\n\n    while (bsf_ctx) {\n        AVPacket new_pkt = *pkt;\n        ret = av_bitstream_filter_filter(bsf_ctx, enc_ctx, NULL,\n                                             &new_pkt.data, &new_pkt.size,\n                                             pkt->data, pkt->size,\n                                             pkt->flags & AV_PKT_FLAG_KEY);\n        if (ret == 0 && new_pkt.data != pkt->data && new_pkt.destruct) {\n            if ((ret = av_copy_packet(&new_pkt, pkt)) < 0)\n                break;\n            ret = 1;\n        }\n\n        if (ret > 0) {\n            av_free_packet(pkt);\n            new_pkt.buf = av_buffer_create(new_pkt.data, new_pkt.size,\n                                           av_buffer_default_free, NULL, 0);\n            if (!new_pkt.buf)\n                break;\n        }\n        *pkt = new_pkt;\n\n        bsf_ctx = bsf_ctx->next;\n    }\n\n    if (ret < 0) {\n        av_log(log_ctx, AV_LOG_ERROR,\n               \"Failed to filter bitstream with filter %s for stream %d in file '%s' with codec %s\\n\",\n               bsf_ctx->filter->name, pkt->stream_index, fmt_ctx->filename,\n               avcodec_get_name(enc_ctx->codec_id));\n    }\n\n    return ret;\n}", "target": 0}
{"idx": 5020, "func": "ECDSA_SIG *ossl_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,\n                               const BIGNUM *in_kinv, const BIGNUM *in_r,\n                               EC_KEY *eckey)\n{\n    int ok = 0, i;\n    BIGNUM *kinv = NULL, *s, *m = NULL, *tmp = NULL;\n    const BIGNUM *order, *ckinv;\n    BN_CTX *ctx = NULL;\n    const EC_GROUP *group;\n    ECDSA_SIG *ret;\n    const BIGNUM *priv_key;\n\n    group = EC_KEY_get0_group(eckey);\n    priv_key = EC_KEY_get0_private_key(eckey);\n\n    if (group == NULL || priv_key == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n\n    if (!EC_KEY_can_sign(eckey)) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);\n        return NULL;\n    }\n\n    ret = ECDSA_SIG_new();\n    if (ret == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    ret->r = BN_new();\n    ret->s = BN_new();\n    if (ret->r == NULL || ret->s == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    s = ret->s;\n\n    if ((ctx = BN_CTX_new()) == NULL ||\n        (tmp = BN_new()) == NULL || (m = BN_new()) == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    order = EC_GROUP_get0_order(group);\n    if (order == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_EC_LIB);\n        goto err;\n    }\n    i = BN_num_bits(order);\n    /*\n     * Need to truncate digest if it is too long: first truncate whole bytes.\n     */\n    if (8 * dgst_len > i)\n        dgst_len = (i + 7) / 8;\n    if (!BN_bin2bn(dgst, dgst_len, m)) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n        goto err;\n    }\n    /* If still too long truncate remaining bits with a shift */\n    if ((8 * dgst_len > i) && !BN_rshift(m, m, 8 - (i & 0x7))) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n        goto err;\n    }\n    do {\n        if (in_kinv == NULL || in_r == NULL) {\n            if (!ecdsa_sign_setup(eckey, ctx, &kinv, &ret->r, dgst, dgst_len)) {\n                ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_ECDSA_LIB);\n                goto err;\n            }\n            ckinv = kinv;\n        } else {\n            ckinv = in_kinv;\n            if (BN_copy(ret->r, in_r) == NULL) {\n                ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        }\n\n        if (!BN_mod_mul(tmp, priv_key, ret->r, order, ctx)) {\n            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n            goto err;\n        }\n        if (!BN_mod_add_quick(s, tmp, m, order)) {\n            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n            goto err;\n        }\n        if (!BN_mod_mul(s, s, ckinv, order, ctx)) {\n            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n            goto err;\n        }\n        if (BN_is_zero(s)) {\n            /*\n             * if kinv and r have been supplied by the caller, don't\n             * generate new kinv and r values\n             */\n            if (in_kinv != NULL && in_r != NULL) {\n                ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, EC_R_NEED_NEW_SETUP_VALUES);\n                goto err;\n            }\n        } else\n            /* s != 0 => we have a valid signature */\n            break;\n    }\n    while (1);\n\n    ok = 1;\n err:\n    if (!ok) {\n        ECDSA_SIG_free(ret);\n        ret = NULL;\n    }\n    BN_CTX_free(ctx);\n    BN_clear_free(m);\n    BN_clear_free(tmp);\n    BN_clear_free(kinv);\n    return ret;\n}", "target": 0}
{"idx": 5021, "func": "static int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\n                           int max)\n{\n    const unsigned char *p = *pp;\n    unsigned long ret = 0;\n    unsigned int i;\n\n    if (max-- < 1)\n        return (0);\n    if (*p == 0x80) {\n        *inf = 1;\n        ret = 0;\n        p++;\n    } else {\n        *inf = 0;\n        i = *p & 0x7f;\n        if (*(p++) & 0x80) {\n            if (max < (int)i)\n                return 0;\n            /* Skip leading zeroes */\n            while (i && *p == 0) {\n                p++;\n                i--;\n            }\n            if (i > sizeof(long))\n                return 0;\n            while (i-- > 0) {\n                ret <<= 8L;\n                ret |= *(p++);\n            }\n        } else\n            ret = i;\n    }\n    if (ret > LONG_MAX)\n        return 0;\n    *pp = p;\n    *rl = (long)ret;\n    return (1);\n}", "target": 0}
{"idx": 5022, "func": "static char *app_get_pass(char *arg, int keepbio)\n{\n    char *tmp, tpass[APP_PASS_LEN];\n    static BIO *pwdbio = NULL;\n    int i;\n\n    if (strncmp(arg, \"pass:\", 5) == 0)\n        return OPENSSL_strdup(arg + 5);\n    if (strncmp(arg, \"env:\", 4) == 0) {\n        tmp = getenv(arg + 4);\n        if (!tmp) {\n            BIO_printf(bio_err, \"Can't read environment variable %s\\n\", arg + 4);\n            return NULL;\n        }\n        return OPENSSL_strdup(tmp);\n    }\n    if (!keepbio || !pwdbio) {\n        if (strncmp(arg, \"file:\", 5) == 0) {\n            pwdbio = BIO_new_file(arg + 5, \"r\");\n            if (!pwdbio) {\n                BIO_printf(bio_err, \"Can't open file %s\\n\", arg + 5);\n                return NULL;\n            }\n#if !defined(_WIN32)\n            /*\n             * Under _WIN32, which covers even Win64 and CE, file\n             * descriptors referenced by BIO_s_fd are not inherited\n             * by child process and therefore below is not an option.\n             * It could have been an option if bss_fd.c was operating\n             * on real Windows descriptors, such as those obtained\n             * with CreateFile.\n             */\n        } else if (strncmp(arg, \"fd:\", 3) == 0) {\n            BIO *btmp;\n            i = atoi(arg + 3);\n            if (i >= 0)\n                pwdbio = BIO_new_fd(i, BIO_NOCLOSE);\n            if ((i < 0) || !pwdbio) {\n                BIO_printf(bio_err, \"Can't access file descriptor %s\\n\", arg + 3);\n                return NULL;\n            }\n            /*\n             * Can't do BIO_gets on an fd BIO so add a buffering BIO\n             */\n            btmp = BIO_new(BIO_f_buffer());\n            pwdbio = BIO_push(btmp, pwdbio);\n#endif\n        } else if (strcmp(arg, \"stdin\") == 0) {\n            pwdbio = dup_bio_in(FORMAT_TEXT);\n            if (!pwdbio) {\n                BIO_printf(bio_err, \"Can't open BIO for stdin\\n\");\n                return NULL;\n            }\n        } else {\n            BIO_printf(bio_err, \"Invalid password argument \\\"%s\\\"\\n\", arg);\n            return NULL;\n        }\n    }\n    i = BIO_gets(pwdbio, tpass, APP_PASS_LEN);\n    if (keepbio != 1) {\n        BIO_free_all(pwdbio);\n        pwdbio = NULL;\n    }\n    if (i <= 0) {\n        BIO_printf(bio_err, \"Error reading password from BIO\\n\");\n        return NULL;\n    }\n    tmp = strchr(tpass, '\\n');\n    if (tmp)\n        *tmp = 0;\n    return OPENSSL_strdup(tpass);\n}", "target": 0}
{"idx": 5023, "func": "void avfilter_copy_buffer_ref_props(AVFilterBufferRef *dst, AVFilterBufferRef *src)\n{\n    // copy common properties\n    dst->pts             = src->pts;\n    dst->pos             = src->pos;\n\n    switch (src->type) {\n    case AVMEDIA_TYPE_VIDEO: *dst->video = *src->video; break;\n    case AVMEDIA_TYPE_AUDIO: *dst->audio = *src->audio; break;\n    default: break;\n    }\n}", "target": 1}
{"idx": 5024, "func": "char *lh_delete(LHASH *lh, char *data)\n\t{\n\tunsigned long hash;\n\tLHASH_NODE *nn,**rn;\n\tchar *ret;\n\n\tlh->error=0;\n\trn=getrn(lh,data,&hash);\n\n\tif (*rn == NULL)\n\t\t{\n\t\tlh->num_no_delete++;\n\t\treturn(NULL);\n\t\t}\n\telse\n\t\t{\n\t\tnn= *rn;\n\t\t*rn=nn->next;\n\t\tret=nn->data;\n\t\tFree((char *)nn);\n\t\tlh->num_delete++;\n\t\t}\n\n\tlh->num_items--;\n\tif ((lh->num_nodes > MIN_NODES) &&\n\t\t(lh->down_load >= (lh->num_items*LH_LOAD_MULT/lh->num_nodes)))\n\t\tcontract(lh);\n\n\treturn(ret);\n\t}", "target": 1}
{"idx": 5025, "func": "static int apc_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n\n    avio_rl32(pb); /* CRYO */\n    avio_rl32(pb); /* _APC */\n    avio_rl32(pb); /* 1.20 */\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    st->codecpar->codec_id = AV_CODEC_ID_ADPCM_IMA_APC;\n\n    avio_rl32(pb); /* number of samples */\n    st->codecpar->sample_rate = avio_rl32(pb);\n\n    /* initial predictor values for adpcm decoder */\n    if (ff_get_extradata(s, st->codecpar, pb, 2 * 4) < 0)\n        return AVERROR(ENOMEM);\n\n    if (avio_rl32(pb)) {\n        st->codecpar->channels       = 2;\n        st->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;\n    } else {\n        st->codecpar->channels       = 1;\n        st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;\n    }\n\n    st->codecpar->bits_per_coded_sample = 4;\n    st->codecpar->bit_rate = (int64_t)st->codecpar->bits_per_coded_sample * st->codecpar->channels\n                          * st->codecpar->sample_rate;\n    st->codecpar->block_align = 1;\n\n    return 0;\n}", "target": 0}
{"idx": 5026, "func": "BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,\n\tconst BIGNUM *e, BIGNUM *m, BN_CTX *ctx,\n\tint (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n\t\t\t  const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),\n\tBN_MONT_CTX *m_ctx)\n{\n\tint    retry_counter = 32;\n\tBN_BLINDING *ret = NULL;\n\n\tif (b == NULL)\n\t\tret = BN_BLINDING_new(NULL, NULL, m);\n\telse\n\t\tret = b;\n\n\tif (ret == NULL)\n\t\tgoto err;\n\n\tif (ret->A  == NULL && (ret->A  = BN_new()) == NULL)\n\t\tgoto err;\n\tif (ret->Ai == NULL && (ret->Ai\t= BN_new()) == NULL)\n\t\tgoto err;\n\n\tif (e != NULL)\n\t\t{\n\t\tif (ret->e != NULL)\n\t\t\tBN_free(ret->e);\n\t\tret->e = BN_dup(e);\n\t\t}\n\tif (ret->e == NULL)\n\t\tgoto err;\n\n\tif (bn_mod_exp != NULL)\n\t\tret->bn_mod_exp = bn_mod_exp;\n\tif (m_ctx != NULL)\n\t\tret->m_ctx = m_ctx;\n\n\tdo {\n\t\tint rv;\n\t\tif (!BN_rand_range(ret->A, ret->mod)) goto err;\n\t\tif (!int_bn_mod_inverse(ret->Ai, ret->A, ret->mod, ctx, &rv))\n\t\t\t{\n\t\t\t/* this should almost never happen for good RSA keys */\n\t\t\tif (rv)\n\t\t\t\t{\n\t\t\t\tif (retry_counter-- == 0)\n\t\t\t\t{\n\t\t\t\t\tBNerr(BN_F_BN_BLINDING_CREATE_PARAM,\n\t\t\t\t\t\tBN_R_TOO_MANY_ITERATIONS);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tgoto err;\n\t\t\t}\n\t\telse\n\t\t\tbreak;\n\t} while (1);\n\n\tif (ret->bn_mod_exp != NULL && ret->m_ctx != NULL)\n\t\t{\n\t\tif (!ret->bn_mod_exp(ret->A, ret->A, ret->e, ret->mod, ctx, ret->m_ctx))\n\t\t\tgoto err;\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mod_exp(ret->A, ret->A, ret->e, ret->mod, ctx))\n\t\t\tgoto err;\n\t\t}\n\n\treturn ret;\nerr:\n\tif (b == NULL && ret != NULL)\n\t\t{\n\t\tBN_BLINDING_free(ret);\n\t\tret = NULL;\n\t\t}\n\n\treturn ret;\n}", "target": 0}
{"idx": 5027, "func": "static int tls12_shared_sigalgs(SSL *s, TLS_SIGALGS *shsig,\n\t\t\t\tconst unsigned char *pref, size_t preflen,\n\t\t\t\tconst unsigned char *allow, size_t allowlen)\n\t{\n\tconst unsigned char *ptmp, *atmp;\n\tsize_t i, j, nmatch = 0;\n\tfor (i = 0, ptmp = pref; i < preflen; i+=2, ptmp+=2)\n\t\t{\n\t\t/* Skip disabled hashes or signature algorithms */\n\t\tif (!tls12_sigalg_allowed(s, SSL_SECOP_SIGALG_SHARED, ptmp))\n\t\t\tcontinue;\n\t\tfor (j = 0, atmp = allow; j < allowlen; j+=2, atmp+=2)\n\t\t\t{\n\t\t\tif (ptmp[0] == atmp[0] && ptmp[1] == atmp[1])\n\t\t\t\t{\n\t\t\t\tnmatch++;\n\t\t\t\tif (shsig)\n\t\t\t\t\t{\n\t\t\t\t\tshsig->rhash = ptmp[0];\n\t\t\t\t\tshsig->rsign = ptmp[1];\n\t\t\t\t\ttls1_lookup_sigalg(&shsig->hash_nid,\n\t\t\t\t\t\t&shsig->sign_nid,\n\t\t\t\t\t\t&shsig->signandhash_nid,\n\t\t\t\t\t\tptmp);\n\t\t\t\t\tshsig++;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn nmatch;\n\t}", "target": 0}
{"idx": 5028, "func": "static int decode_block_progressive(MJpegDecodeContext *s, int16_t *block,\n                                    uint8_t *last_nnz, int ac_index,\n                                    int16_t *quant_matrix,\n                                    int ss, int se, int Al, int *EOBRUN)\n{\n    int code, i, j, level, val, run;\n\n    if (*EOBRUN) {\n        (*EOBRUN)--;\n        return 0;\n    }\n\n    {\n        OPEN_READER(re, &s->gb);\n        for (i = ss; ; i++) {\n            UPDATE_CACHE(re, &s->gb);\n            GET_VLC(code, re, &s->gb, s->vlcs[2][ac_index].table, 9, 2);\n\n            run = ((unsigned) code) >> 4;\n            code &= 0xF;\n            if (code) {\n                i += run;\n                if (code > MIN_CACHE_BITS - 16)\n                    UPDATE_CACHE(re, &s->gb);\n\n                {\n                    int cache = GET_CACHE(re, &s->gb);\n                    int sign  = (~cache) >> 31;\n                    level     = (NEG_USR32(sign ^ cache,code) ^ sign) - sign;\n                }\n\n                LAST_SKIP_BITS(re, &s->gb, code);\n\n                if (i >= se) {\n                    if (i == se) {\n                        j = s->scantable.permutated[se];\n                        block[j] = level * (quant_matrix[j] << Al);\n                        break;\n                    }\n                    av_log(s->avctx, AV_LOG_ERROR, \"error count: %d\\n\", i);\n                    return AVERROR_INVALIDDATA;\n                }\n                j = s->scantable.permutated[i];\n                block[j] = level * (quant_matrix[j] << Al);\n            } else {\n                if (run == 0xF) {// ZRL - skip 15 coefficients\n                    i += 15;\n                    if (i >= se) {\n                        av_log(s->avctx, AV_LOG_ERROR, \"ZRL overflow: %d\\n\", i);\n                        return AVERROR_INVALIDDATA;\n                    }\n                } else {\n                    val = (1 << run);\n                    if (run) {\n                        UPDATE_CACHE(re, &s->gb);\n                        val += NEG_USR32(GET_CACHE(re, &s->gb), run);\n                        LAST_SKIP_BITS(re, &s->gb, run);\n                    }\n                    *EOBRUN = val - 1;\n                    break;\n                }\n            }\n        }\n        CLOSE_READER(re, &s->gb);\n    }\n\n    if (i > *last_nnz)\n        *last_nnz = i;\n\n    return 0;\n}", "target": 0}
{"idx": 5029, "func": "static void mpeg_decode_sequence_extension(Mpeg1Context *s1)\n{\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n    int horiz_size_ext, vert_size_ext;\n    int bit_rate_ext;\n\n    skip_bits(&s->gb, 1); /* profile and level esc*/\n    s->avctx->profile       = get_bits(&s->gb, 3);\n    s->avctx->level         = get_bits(&s->gb, 4);\n    s->progressive_sequence = get_bits1(&s->gb);   /* progressive_sequence */\n    s->chroma_format        = get_bits(&s->gb, 2); /* chroma_format 1=420, 2=422, 3=444 */\n\n    if (!s->chroma_format) {\n        s->chroma_format = 1;\n        av_log(s->avctx, AV_LOG_WARNING, \"Chroma format invalid\\n\");\n    }\n\n    horiz_size_ext          = get_bits(&s->gb, 2);\n    vert_size_ext           = get_bits(&s->gb, 2);\n    s->width  |= (horiz_size_ext << 12);\n    s->height |= (vert_size_ext  << 12);\n    bit_rate_ext = get_bits(&s->gb, 12);  /* XXX: handle it */\n    s->bit_rate += (bit_rate_ext << 18) * 400LL;\n    check_marker(&s->gb, \"after bit rate extension\");\n    s->avctx->rc_buffer_size += get_bits(&s->gb, 8) * 1024 * 16 << 10;\n\n    s->low_delay = get_bits1(&s->gb);\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n\n    s1->frame_rate_ext.num = get_bits(&s->gb, 2) + 1;\n    s1->frame_rate_ext.den = get_bits(&s->gb, 5) + 1;\n\n    ff_dlog(s->avctx, \"sequence extension\\n\");\n    s->codec_id = s->avctx->codec_id = AV_CODEC_ID_MPEG2VIDEO;\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(s->avctx, AV_LOG_DEBUG,\n               \"profile: %d, level: %d ps: %d cf:%d vbv buffer: %d, bitrate:%\"PRId64\"\\n\",\n               s->avctx->profile, s->avctx->level, s->progressive_sequence, s->chroma_format,\n               s->avctx->rc_buffer_size, s->bit_rate);\n}", "target": 0}
{"idx": 5030, "func": "static int mov_write_single_packet(AVFormatContext *s, AVPacket *pkt)\n{\n        MOVMuxContext *mov = s->priv_data;\n        MOVTrack *trk = &mov->tracks[pkt->stream_index];\n        AVCodecParameters *par = trk->par;\n        int64_t frag_duration = 0;\n        int size = pkt->size;\n\n        if (mov->flags & FF_MOV_FLAG_FRAG_DISCONT) {\n            int i;\n            for (i = 0; i < s->nb_streams; i++)\n                mov->tracks[i].frag_discont = 1;\n            mov->flags &= ~FF_MOV_FLAG_FRAG_DISCONT;\n        }\n\n        if (!pkt->size) {\n            if (trk->start_dts == AV_NOPTS_VALUE && trk->frag_discont) {\n                trk->start_dts = pkt->dts;\n                if (pkt->pts != AV_NOPTS_VALUE)\n                    trk->start_cts = pkt->pts - pkt->dts;\n                else\n                    trk->start_cts = 0;\n            }\n\n            if (trk->par->codec_id == AV_CODEC_ID_MP4ALS) {\n                int side_size = 0;\n                uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);\n                if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {\n                    void *newextra = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);\n                    if (!newextra)\n                        return AVERROR(ENOMEM);\n                    av_free(par->extradata);\n                    par->extradata = newextra;\n                    memcpy(par->extradata, side, side_size);\n                    par->extradata_size = side_size;\n                    mov->need_rewrite_extradata = 1;\n                }\n            }\n\n            return 0;             /* Discard 0 sized packets */\n        }\n\n        if (trk->entry && pkt->stream_index < s->nb_streams)\n            frag_duration = av_rescale_q(pkt->dts - trk->cluster[0].dts,\n                                         s->streams[pkt->stream_index]->time_base,\n                                         AV_TIME_BASE_Q);\n        if ((mov->max_fragment_duration &&\n             frag_duration >= mov->max_fragment_duration) ||\n             (mov->max_fragment_size && mov->mdat_size + size >= mov->max_fragment_size) ||\n             (mov->flags & FF_MOV_FLAG_FRAG_KEYFRAME &&\n              par->codec_type == AVMEDIA_TYPE_VIDEO &&\n              trk->entry && pkt->flags & AV_PKT_FLAG_KEY)) {\n            if (frag_duration >= mov->min_fragment_duration) {\n                // Set the duration of this track to line up with the next\n                // sample in this track. This avoids relying on AVPacket\n                // duration, but only helps for this particular track, not\n                // for the other ones that are flushed at the same time.\n                trk->track_duration = pkt->dts - trk->start_dts;\n                if (pkt->pts != AV_NOPTS_VALUE)\n                    trk->end_pts = pkt->pts;\n                else\n                    trk->end_pts = pkt->dts;\n                trk->end_reliable = 1;\n                mov_auto_flush_fragment(s, 0);\n            }\n        }\n\n        return ff_mov_write_packet(s, pkt);\n}", "target": 1}
{"idx": 5031, "func": "static char **lookup_serial(CA_DB *db, ASN1_INTEGER *ser)\n{\n    int i;\n    BIGNUM *bn = NULL;\n    char *itmp, *row[DB_NUMBER], **rrow;\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    bn = ASN1_INTEGER_to_BN(ser, NULL);\n    OPENSSL_assert(bn);         /* FIXME: should report an error at this\n                                 * point and abort */\n    if (BN_is_zero(bn))\n        itmp = OPENSSL_strdup(\"00\");\n    else\n        itmp = BN_bn2hex(bn);\n    row[DB_serial] = itmp;\n    BN_free(bn);\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    OPENSSL_free(itmp);\n    return rrow;\n}", "target": 0}
{"idx": 5032, "func": "static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n            break;\n        c++;\n    }\n    if (x >= 16 || c >= 256) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n        return ret;\n\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n\n    *rval = c & s->cbits;\n\n    return 0;\n}", "target": 0}
{"idx": 5033, "func": "static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    UtvideoContext *c = avctx->priv_data;\n    int i, j;\n    const uint8_t *plane_start[5];\n    int plane_size, max_slice_size = 0, slice_start, slice_end, slice_size;\n    int ret;\n    GetByteContext gb;\n    ThreadFrame frame = { .f = data };\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n        return ret;\n\n    /* parse plane structure to get frame flags and validate slice offsets */\n    bytestream2_init(&gb, buf, buf_size);\n    for (i = 0; i < c->planes; i++) {\n        plane_start[i] = gb.buffer;\n        if (bytestream2_get_bytes_left(&gb) < 256 + 4 * c->slices) {\n            av_log(avctx, AV_LOG_ERROR, \"Insufficient data for a plane\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        bytestream2_skipu(&gb, 256);\n        slice_start = 0;\n        slice_end   = 0;\n        for (j = 0; j < c->slices; j++) {\n            slice_end   = bytestream2_get_le32u(&gb);\n            if (slice_end < 0 || slice_end < slice_start ||\n                bytestream2_get_bytes_left(&gb) < slice_end) {\n                av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            slice_size  = slice_end - slice_start;\n            slice_start = slice_end;\n            max_slice_size = FFMAX(max_slice_size, slice_size);\n        }\n        plane_size = slice_end;\n        bytestream2_skipu(&gb, plane_size);\n    }\n    plane_start[c->planes] = gb.buffer;\n    if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {\n        av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    c->frame_info = bytestream2_get_le32u(&gb);\n    av_log(avctx, AV_LOG_DEBUG, \"frame information flags %\"PRIX32\"\\n\",\n           c->frame_info);\n\n    c->frame_pred = (c->frame_info >> 8) & 3;\n\n    if (c->frame_pred == PRED_GRADIENT) {\n        avpriv_request_sample(avctx, \"Frame with gradient prediction\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_fast_malloc(&c->slice_bits, &c->slice_bits_size,\n                   max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!c->slice_bits) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot allocate temporary buffer\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    switch (c->avctx->pix_fmt) {\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n        for (i = 0; i < c->planes; i++) {\n            ret = decode_plane(c, i, frame.f->data[0] + ff_ut_rgb_order[i],\n                               c->planes, frame.f->linesize[0], avctx->width,\n                               avctx->height, plane_start[i],\n                               c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[0] + ff_ut_rgb_order[i],\n                                   c->planes, frame.f->linesize[0], avctx->width,\n                                   avctx->height, c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[0] + ff_ut_rgb_order[i],\n                                      c->planes, frame.f->linesize[0],\n                                      avctx->width, avctx->height, c->slices,\n                                      0);\n                }\n            }\n        }\n        restore_rgb_planes(frame.f->data[0], c->planes, frame.f->linesize[0],\n                           avctx->width, avctx->height);\n        break;\n    case AV_PIX_FMT_YUV420P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width >> !!i, avctx->height >> !!i,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width >> !!i, avctx->height >> !!i,\n                                   c->slices, !i);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width  >> !!i,\n                                      avctx->height >> !!i,\n                                      c->slices, !i);\n                }\n            }\n        }\n        break;\n    case AV_PIX_FMT_YUV422P:\n        for (i = 0; i < 3; i++) {\n            ret = decode_plane(c, i, frame.f->data[i], 1, frame.f->linesize[i],\n                               avctx->width >> !!i, avctx->height,\n                               plane_start[i], c->frame_pred == PRED_LEFT);\n            if (ret)\n                return ret;\n            if (c->frame_pred == PRED_MEDIAN) {\n                if (!c->interlaced) {\n                    restore_median(frame.f->data[i], 1, frame.f->linesize[i],\n                                   avctx->width >> !!i, avctx->height,\n                                   c->slices, 0);\n                } else {\n                    restore_median_il(frame.f->data[i], 1, frame.f->linesize[i],\n                                      avctx->width >> !!i, avctx->height,\n                                      c->slices, 0);\n                }\n            }\n        }\n        break;\n    }\n\n    frame.f->key_frame = 1;\n    frame.f->pict_type = AV_PICTURE_TYPE_I;\n    frame.f->interlaced_frame = !!c->interlaced;\n\n    *got_frame = 1;\n\n    /* always report that the buffer was completely consumed */\n    return buf_size;\n}", "target": 0}
{"idx": 5034, "func": "static void body(uint32_t ABCD[4], uint32_t X[16])\n{\n    int i av_unused;\n    uint32_t t;\n    uint32_t a = ABCD[3];\n    uint32_t b = ABCD[2];\n    uint32_t c = ABCD[1];\n    uint32_t d = ABCD[0];\n\n#if HAVE_BIGENDIAN\n    for (i = 0; i < 16; i++)\n        X[i] = av_bswap32(X[i]);\n#endif\n\n#if CONFIG_SMALL\n    for (i = 0; i < 64; i++) {\n        CORE(i, a, b, c, d);\n        t = d;\n        d = c;\n        c = b;\n        b = a;\n        a = t;\n    }\n#else\n#define CORE2(i)                                                        \\\n    CORE( i,   a,b,c,d); CORE((i+1),d,a,b,c);                           \\\n    CORE((i+2),c,d,a,b); CORE((i+3),b,c,d,a)\n#define CORE4(i) CORE2(i); CORE2((i+4)); CORE2((i+8)); CORE2((i+12))\n    CORE4(0); CORE4(16); CORE4(32); CORE4(48);\n#endif\n\n    ABCD[0] += d;\n    ABCD[1] += c;\n    ABCD[2] += b;\n    ABCD[3] += a;\n}", "target": 1}
{"idx": 5035, "func": "void ff_rtp_send_jpeg(AVFormatContext *s1, const uint8_t *buf, int size)\n{\n    RTPMuxContext *s = s1->priv_data;\n    const uint8_t *qtables = NULL;\n    int nb_qtables = 0;\n    uint8_t type;\n    uint8_t w, h;\n    uint8_t *p;\n    int off = 0; /* fragment offset of the current JPEG frame */\n    int len;\n    int i;\n\n    s->buf_ptr   = s->buf;\n    s->timestamp = s->cur_timestamp;\n\n    /* convert video pixel dimensions from pixels to blocks */\n    w = s1->streams[0]->codec->width  >> 3;\n    h = s1->streams[0]->codec->height >> 3;\n\n    /* get the pixel format type or fail */\n    if (s1->streams[0]->codec->pix_fmt == AV_PIX_FMT_YUVJ422P ||\n        (s1->streams[0]->codec->color_range == AVCOL_RANGE_JPEG &&\n         s1->streams[0]->codec->pix_fmt == AV_PIX_FMT_YUV422P)) {\n        type = 0;\n    } else if (s1->streams[0]->codec->pix_fmt == AV_PIX_FMT_YUVJ420P ||\n               (s1->streams[0]->codec->color_range == AVCOL_RANGE_JPEG &&\n                s1->streams[0]->codec->pix_fmt == AV_PIX_FMT_YUV420P)) {\n        type = 1;\n    } else {\n        av_log(s1, AV_LOG_ERROR, \"Unsupported pixel format\\n\");\n        return;\n    }\n\n    /* preparse the header for getting some infos */\n    for (i = 0; i < size; i++) {\n        if (buf[i] != 0xff)\n            continue;\n\n        if (buf[i + 1] == DQT) {\n            if (buf[i + 4])\n                av_log(s1, AV_LOG_WARNING,\n                       \"Only 8-bit precision is supported.\\n\");\n\n            /* a quantization table is 64 bytes long */\n            nb_qtables = AV_RB16(&buf[i + 2]) / 65;\n            if (i + 4 + nb_qtables * 65 > size) {\n                av_log(s1, AV_LOG_ERROR, \"Too short JPEG header. Aborted!\\n\");\n                return;\n            }\n\n            qtables = &buf[i + 4];\n        } else if (buf[i + 1] == SOF0) {\n            if (buf[i + 14] != 17 || buf[i + 17] != 17) {\n                av_log(s1, AV_LOG_ERROR,\n                       \"Only 1x1 chroma blocks are supported. Aborted!\\n\");\n                return;\n            }\n        } else if (buf[i + 1] == SOS) {\n            /* SOS is last marker in the header */\n            i += AV_RB16(&buf[i + 2]) + 2;\n            break;\n        }\n    }\n\n    /* skip JPEG header */\n    buf  += i;\n    size -= i;\n\n    for (i = size - 2; i >= 0; i--) {\n        if (buf[i] == 0xff && buf[i + 1] == EOI) {\n            /* Remove the EOI marker */\n            size = i;\n            break;\n        }\n    }\n\n    p = s->buf_ptr;\n    while (size > 0) {\n        int hdr_size = 8;\n\n        if (off == 0 && nb_qtables)\n            hdr_size += 4 + 64 * nb_qtables;\n\n        /* payload max in one packet */\n        len = FFMIN(size, s->max_payload_size - hdr_size);\n\n        /* set main header */\n        bytestream_put_byte(&p, 0);\n        bytestream_put_be24(&p, off);\n        bytestream_put_byte(&p, type);\n        bytestream_put_byte(&p, 255);\n        bytestream_put_byte(&p, w);\n        bytestream_put_byte(&p, h);\n\n        if (off == 0 && nb_qtables) {\n            /* set quantization tables header */\n            bytestream_put_byte(&p, 0);\n            bytestream_put_byte(&p, 0);\n            bytestream_put_be16(&p, 64 * nb_qtables);\n\n            for (i = 0; i < nb_qtables; i++)\n                bytestream_put_buffer(&p, &qtables[65 * i + 1], 64);\n        }\n\n        /* copy payload data */\n        memcpy(p, buf, len);\n\n        /* marker bit is last packet in frame */\n        ff_rtp_send_data(s1, s->buf, len + hdr_size, size == len);\n\n        buf  += len;\n        size -= len;\n        off  += len;\n        p     = s->buf;\n    }\n}", "target": 0}
{"idx": 5036, "func": "static inline int vc1_coded_block_pred(MpegEncContext * s, int n,\n                                       uint8_t **coded_block_ptr)\n{\n    int xy, wrap, pred, a, b, c;\n\n    xy   = s->block_index[n];\n    wrap = s->b8_stride;\n\n    /* B C\n     * A X\n     */\n    a = s->coded_block[xy - 1       ];\n    b = s->coded_block[xy - 1 - wrap];\n    c = s->coded_block[xy     - wrap];\n\n    if (b == c) {\n        pred = a;\n    } else {\n        pred = c;\n    }\n\n    /* store value */\n    *coded_block_ptr = &s->coded_block[xy];\n\n    return pred;\n}", "target": 1}
{"idx": 5037, "func": "void\nPSDataBW(FILE* fd, TIFF* tif, uint32 w, uint32 h)\n{\n\tint breaklen = MAXLINE;\n\tunsigned char* tf_buf;\n\tunsigned char* cp;\n\ttsize_t stripsize = TIFFStripSize(tif);\n\ttstrip_t s;\n\n#if defined( EXP_ASCII85ENCODER )\n\ttsize_t\tascii85_l;\t\t/* Length, in bytes, of ascii85_p[] data */\n\tuint8\t*ascii85_p = 0;\t\t/* Holds ASCII85 encoded data */\n#endif\n\n\t(void) w; (void) h;\n\ttf_buf = (unsigned char *) _TIFFmalloc(stripsize);\n\tif (tf_buf == NULL) {\n\t\tTIFFError(filename, \"No space for scanline buffer\");\n\t\treturn;\n\t}\n\n\t// FIXME\n\tmemset(tf_buf, 0, stripsize);\n\n#if defined( EXP_ASCII85ENCODER )\n\tif ( ascii85 ) {\n\t    /*\n\t     * Allocate a buffer to hold the ASCII85 encoded data.  Note\n\t     * that it is allocated with sufficient room to hold the\n\t     * encoded data (5*stripsize/4) plus the EOD marker (+8)\n\t     * and formatting line breaks.  The line breaks are more\n\t     * than taken care of by using 6*stripsize/4 rather than\n\t     * 5*stripsize/4.\n\t     */\n\n\t    ascii85_p = _TIFFmalloc( (stripsize+(stripsize/2)) + 8 );\n\n\t    if ( !ascii85_p ) {\n\t\t_TIFFfree( tf_buf );\n\n\t\tTIFFError( filename, \"Cannot allocate ASCII85 encoding buffer.\" );\n\t\treturn;\n\t    }\n\t}\n#endif\n\n\tif (ascii85)\n\t\tAscii85Init();\n\n\tfor (s = 0; s < TIFFNumberOfStrips(tif); s++) {\n\t\ttmsize_t cc = TIFFReadEncodedStrip(tif, s, tf_buf, stripsize);\n\t\tif (cc < 0) {\n\t\t\tTIFFError(filename, \"Can't read strip\");\n\t\t\tbreak;\n\t\t}\n\t\tcp = tf_buf;\n\t\tif (photometric == PHOTOMETRIC_MINISWHITE) {\n\t\t\tfor (cp += cc; --cp >= tf_buf;)\n\t\t\t\t*cp = ~*cp;\n\t\t\tcp++;\n\t\t}\n\t\t/*\n\t\t * for 16 bits, the two bytes must be most significant\n\t\t * byte first\n\t\t */\n\t\tif (bitspersample == 16 && !HOST_BIGENDIAN) {\n\t\t\tPS_FlipBytes(cp, cc);\n\t\t}\n\t\tif (ascii85) {\n#if defined( EXP_ASCII85ENCODER )\n\t\t\tif (alpha) {\n\t\t\t\tint adjust, i;\n\t\t\t\tfor (i = 0; i < cc; i+=2) {\n\t\t\t\t\tadjust = 255 - cp[i + 1];\n\t\t\t\t    cp[i / 2] = cp[i] + adjust;\n\t\t\t\t}\n\t\t\t\tcc /= 2;\n\t\t\t}\n\n\t\t\tascii85_l = Ascii85EncodeBlock( ascii85_p, 1, cp, cc );\n\n\t\t\tif ( ascii85_l > 0 )\n\t\t\t    fwrite( ascii85_p, ascii85_l, 1, fd );\n#else\n\t\t\twhile (cc-- > 0)\n\t\t\t\tAscii85Put(*cp++, fd);\n#endif /* EXP_ASCII85_ENCODER */\n\t\t} else {\n\t\t\tunsigned char c;\n\n\t\t\tif (alpha) {\n\t\t\t\tint adjust;\n\t\t\t\twhile (cc-- > 1) {\n\t\t\t\t\tDOBREAK(breaklen, 1, fd);\n\t\t\t\t\t/*\n\t\t\t\t\t * For images with alpha, matte against\n\t\t\t\t\t * a white background; i.e.\n\t\t\t\t\t *    Cback * (1 - Aimage)\n\t\t\t\t\t * where Cback = 1.\n\t\t\t\t\t */\n\t\t\t\t\tadjust = 255 - cp[1];\n\t\t\t\t\tc = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\t\tcp++, cc--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (cc-- > 0) {\n\t\t\t\t\tc = *cp++;\n\t\t\t\t\tDOBREAK(breaklen, 1, fd);\n\t\t\t\t\tPUTHEX(c, fd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( !ascii85 )\n\t{\n\t    if ( level2 || level3)\n\t\tfputs(\">\\n\", fd);\n\t}\n#if !defined( EXP_ASCII85ENCODER )\n\telse\n\t    Ascii85Flush(fd);\n#else\n\tif ( ascii85_p )\n\t    _TIFFfree( ascii85_p );\n#endif\n\n\t_TIFFfree(tf_buf);\n}", "target": 1}
{"idx": 5038, "func": "static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n                       Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,\n                       int width, int height, int bandpos)\n{\n    int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n    int clnpass_cnt = 0;\n    int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;\n    int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;\n\n    av_assert0(width  <= JPEG2000_MAX_CBLKW);\n    av_assert0(height <= JPEG2000_MAX_CBLKH);\n\n    for (y = 0; y < height; y++)\n        memset(t1->data[y], 0, width * sizeof(**t1->data));\n\n    /* If code-block contains no compressed data: nothing to do. */\n    if (!cblk->length)\n        return 0;\n\n    for (y = 0; y < height + 2; y++)\n        memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));\n\n    cblk->data[cblk->length] = 0xff;\n    cblk->data[cblk->length+1] = 0xff;\n    ff_mqc_initdec(&t1->mqc, cblk->data);\n\n    while (passno--) {\n        switch(pass_t) {\n        case 0:\n            decode_sigpass(t1, width, height, bpno + 1, bandpos,\n                           bpass_csty_symbol && (clnpass_cnt >= 4),\n                           vert_causal_ctx_csty_symbol);\n            break;\n        case 1:\n            decode_refpass(t1, width, height, bpno + 1);\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        case 2:\n            decode_clnpass(s, t1, width, height, bpno + 1, bandpos,\n                           codsty->cblk_style & JPEG2000_CBLK_SEGSYM,\n                           vert_causal_ctx_csty_symbol);\n            clnpass_cnt = clnpass_cnt + 1;\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        }\n\n        pass_t++;\n        if (pass_t == 3) {\n            bpno--;\n            pass_t = 0;\n        }\n    }\n    return 0;\n}", "target": 1}
{"idx": 5039, "func": "void ff_interleave_add_packet(AVFormatContext *s, AVPacket *pkt,\n                              int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\n{\n    AVPacketList **next_point, *this_pktl;\n\n    this_pktl      = av_mallocz(sizeof(AVPacketList));\n    this_pktl->pkt = *pkt;\n#if FF_API_DESTRUCT_PACKET\nFF_DISABLE_DEPRECATION_WARNINGS\n    pkt->destruct  = NULL;           // do not free original but only the copy\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n    pkt->buf       = NULL;\n    av_dup_packet(&this_pktl->pkt);  // duplicate the packet if it uses non-alloced memory\n\n    if (s->streams[pkt->stream_index]->last_in_packet_buffer) {\n        next_point = &(s->streams[pkt->stream_index]->last_in_packet_buffer->next);\n    } else\n        next_point = &s->packet_buffer;\n\n    if (*next_point) {\n        if (compare(s, &s->packet_buffer_end->pkt, pkt)) {\n            while (!compare(s, &(*next_point)->pkt, pkt))\n                next_point = &(*next_point)->next;\n            goto next_non_null;\n        } else {\n            next_point = &(s->packet_buffer_end->next);\n        }\n    }\n    assert(!*next_point);\n\n    s->packet_buffer_end = this_pktl;\nnext_non_null:\n\n    this_pktl->next = *next_point;\n\n    s->streams[pkt->stream_index]->last_in_packet_buffer =\n        *next_point                                      = this_pktl;\n}", "target": 0}
{"idx": 5040, "func": "void ff_init_block_index(MpegEncContext *s){ //FIXME maybe rename\n    const int linesize= s->current_picture.linesize[0]; //not s->linesize as this would be wrong for field pics\n    const int uvlinesize= s->current_picture.linesize[1];\n    const int mb_size= 4 - s->avctx->lowres;\n\n    s->block_index[0]= s->b8_stride*(s->mb_y*2    ) - 2 + s->mb_x*2;\n    s->block_index[1]= s->b8_stride*(s->mb_y*2    ) - 1 + s->mb_x*2;\n    s->block_index[2]= s->b8_stride*(s->mb_y*2 + 1) - 2 + s->mb_x*2;\n    s->block_index[3]= s->b8_stride*(s->mb_y*2 + 1) - 1 + s->mb_x*2;\n    s->block_index[4]= s->mb_stride*(s->mb_y + 1)                + s->b8_stride*s->mb_height*2 + s->mb_x - 1;\n    s->block_index[5]= s->mb_stride*(s->mb_y + s->mb_height + 2) + s->b8_stride*s->mb_height*2 + s->mb_x - 1;\n    //block_index is not used by mpeg2, so it is not affected by chroma_format\n\n    s->dest[0] = s->current_picture.data[0] + ((s->mb_x - 1) << mb_size);\n    s->dest[1] = s->current_picture.data[1] + ((s->mb_x - 1) << (mb_size - s->chroma_x_shift));\n    s->dest[2] = s->current_picture.data[2] + ((s->mb_x - 1) << (mb_size - s->chroma_x_shift));\n\n    if(!(s->pict_type==AV_PICTURE_TYPE_B && s->avctx->draw_horiz_band && s->picture_structure==PICT_FRAME))\n    {\n        if(s->picture_structure==PICT_FRAME){\n        s->dest[0] += s->mb_y *   linesize << mb_size;\n        s->dest[1] += s->mb_y * uvlinesize << (mb_size - s->chroma_y_shift);\n        s->dest[2] += s->mb_y * uvlinesize << (mb_size - s->chroma_y_shift);\n        }else{\n            s->dest[0] += (s->mb_y>>1) *   linesize << mb_size;\n            s->dest[1] += (s->mb_y>>1) * uvlinesize << (mb_size - s->chroma_y_shift);\n            s->dest[2] += (s->mb_y>>1) * uvlinesize << (mb_size - s->chroma_y_shift);\n            assert((s->mb_y&1) == (s->picture_structure == PICT_BOTTOM_FIELD));\n        }\n    }\n}", "target": 1}
{"idx": 5041, "func": "static int check_pkt(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVMuxContext *mov = s->priv_data;\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n\n    if (trk->entry) {\n        int64_t duration = pkt->dts - trk->cluster[trk->entry - 1].dts;\n        if (duration < 0 || duration > INT_MAX) {\n            av_log(s, AV_LOG_ERROR, \"Application provided duration: %\"PRId64\" / timestamp: %\"PRId64\" is out of range for mov/mp4 format\\n\",\n                duration, pkt->dts\n            );\n\n            pkt->dts = trk->cluster[trk->entry - 1].dts + 1;\n            pkt->pts = AV_NOPTS_VALUE;\n        }\n    } else if (pkt->dts <= INT_MIN || pkt->dts >= INT_MAX) {\n            av_log(s, AV_LOG_ERROR, \"Application provided initial timestamp: %\"PRId64\" is out of range for mov/mp4 format\\n\",\n                pkt->dts\n            );\n\n            pkt->dts = 0;\n            pkt->pts = AV_NOPTS_VALUE;\n    }\n    if (pkt->duration < 0 || pkt->duration > INT_MAX) {\n        av_log(s, AV_LOG_ERROR, \"Application provided duration: %\"PRId64\" is invalid\\n\", pkt->duration);\n        return AVERROR(EINVAL);\n    }\n    return 0;\n}", "target": 1}
{"idx": 5042, "func": "int X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param,\n\t\t\t\tconst unsigned char *email, size_t emaillen)\n\t{\n\treturn int_x509_param_set1(&param->id->email, &param->id->emaillen,\n\t\t\t\t\temail, emaillen);\n\t}", "target": 0}
{"idx": 5043, "func": "int tls_construct_stoc_status_request(SSL *s, WPACKET *pkt, X509 *x,\n                                     size_t chain, int *al)\n{\n    if (!s->tlsext_status_expected)\n        return 1;\n\n    if (SSL_IS_TLS13(s) && chain != 0)\n        return 1;\n\n    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_status_request)\n            || !WPACKET_start_sub_packet_u16(pkt)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_STOC_STATUS_REQUEST, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /*\n     * In TLSv1.3 we include the certificate status itself. In <= TLSv1.2 we\n     * send back an empty extension, with the certificate status appearing as a\n     * separate message\n     */\n    if ((SSL_IS_TLS13(s) && !tls_construct_cert_status_body(s, pkt))\n            || !WPACKET_close(pkt)) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_STOC_STATUS_REQUEST, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    return 1;\n}", "target": 0}
{"idx": 5044, "func": "void bn_sqr_normal(BN_ULONG *r, const BN_ULONG *a, int n, BN_ULONG *tmp)\n\t{\n\tint i,j,max;\n\tconst BN_ULONG *ap;\n\tBN_ULONG *rp;\n\n\tmax=n*2;\n\tap=a;\n\trp=r;\n\trp[0]=rp[max-1]=0;\n\trp++;\n\tj=n;\n\n\tif (--j > 0)\n\t\t{\n\t\tap++;\n\t\trp[j]=bn_mul_words(rp,ap,j,ap[-1]);\n\t\trp+=2;\n\t\t}\n\n\tfor (i=n-2; i>0; i--)\n\t\t{\n\t\tj--;\n\t\tap++;\n\t\trp[j]=bn_mul_add_words(rp,ap,j,ap[-1]);\n\t\trp+=2;\n\t\t}\n\n\tbn_add_words(r,r,r,max);\n\n\t/* There will not be a carry */\n\n\tbn_sqr_words(tmp,a,n);\n\n\tbn_add_words(r,r,tmp,max);\n\t}", "target": 1}
{"idx": 5045, "func": "static int reconfigure_filter(BufferSourceContext *abuffer, AVFilterContext *filt_ctx)\n{\n    int ret;\n    AVFilterLink * const inlink  = filt_ctx->inputs[0];\n    AVFilterLink * const outlink = filt_ctx->outputs[0];\n\n    inlink->format         = abuffer->sample_format;\n    inlink->channel_layout = abuffer->channel_layout;\n    inlink->planar         = abuffer->packing_format;\n    inlink->sample_rate    = abuffer->sample_rate;\n\n    filt_ctx->filter->uninit(filt_ctx);\n    memset(filt_ctx->priv, 0, filt_ctx->filter->priv_size);\n    if ((ret = filt_ctx->filter->init(filt_ctx, NULL , NULL)) < 0)\n        return ret;\n    if ((ret = inlink->srcpad->config_props(inlink)) < 0)\n        return ret;\n    return outlink->srcpad->config_props(outlink);\n}", "target": 1}
{"idx": 5046, "func": "int X509_TRUST_add(int id, int flags, int (*ck) (X509_TRUST *, X509 *, int),\n                   const char *name, int arg1, void *arg2)\n{\n    int idx;\n    X509_TRUST *trtmp;\n    /*\n     * This is set according to what we change: application can't set it\n     */\n    flags &= ~X509_TRUST_DYNAMIC;\n    /* This will always be set for application modified trust entries */\n    flags |= X509_TRUST_DYNAMIC_NAME;\n    /* Get existing entry if any */\n    idx = X509_TRUST_get_by_id(id);\n    /* Need a new entry */\n    if (idx == -1) {\n        if ((trtmp = OPENSSL_malloc(sizeof(*trtmp))) == NULL) {\n            X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);\n            return 0;\n        }\n        trtmp->flags = X509_TRUST_DYNAMIC;\n    } else\n        trtmp = X509_TRUST_get0(idx);\n\n    /* OPENSSL_free existing name if dynamic */\n    if (trtmp->flags & X509_TRUST_DYNAMIC_NAME)\n        OPENSSL_free(trtmp->name);\n    /* dup supplied name */\n    if ((trtmp->name = OPENSSL_strdup(name)) == NULL) {\n        X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    /* Keep the dynamic flag of existing entry */\n    trtmp->flags &= X509_TRUST_DYNAMIC;\n    /* Set all other flags */\n    trtmp->flags |= flags;\n\n    trtmp->trust = id;\n    trtmp->check_trust = ck;\n    trtmp->arg1 = arg1;\n    trtmp->arg2 = arg2;\n\n    /* If its a new entry manage the dynamic table */\n    if (idx == -1) {\n        if (trtable == NULL\n            && (trtable = sk_X509_TRUST_new(tr_cmp)) == NULL) {\n            X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);\n            goto err;;\n        }\n        if (!sk_X509_TRUST_push(trtable, trtmp)) {\n            X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    }\n    return 1;\n err:\n    if (idx == -1) {\n        OPENSSL_free(trtmp->name);\n        OPENSSL_free(trtmp);\n    }\n    return 0;\n}", "target": 1}
{"idx": 5047, "func": "static apr_status_t send_brigade_blocking(apr_socket_t *s,\n                                          apr_bucket_brigade *bb,\n                                          apr_size_t *bytes_written,\n                                          conn_rec *c)\n{\n    apr_status_t rv;\n\n    rv = APR_SUCCESS;\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        rv = send_brigade_nonblocking(s, bb, bytes_written, c);\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_EAGAIN(rv)) {\n                /* Wait until we can send more data */\n                apr_int32_t nsds;\n                apr_interval_time_t timeout;\n                apr_pollfd_t pollset;\n\n                pollset.p = c->pool;\n                pollset.desc_type = APR_POLL_SOCKET;\n                pollset.reqevents = APR_POLLOUT;\n                pollset.desc.s = s;\n                apr_socket_timeout_get(s, &timeout);\n                do {\n                    rv = apr_poll(&pollset, 1, &nsds, timeout);\n                } while (APR_STATUS_IS_EINTR(rv));\n                if (rv != APR_SUCCESS) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return rv;\n}", "target": 1}
{"idx": 5048, "func": "static void decode_sigpass(Jpeg2000T1Context *t1, int width, int height,\n                           int bpno, int bandno, int bpass_csty_symbol,\n                           int vert_causal_ctx_csty_symbol)\n{\n    int mask = 3 << (bpno - 1), y0, x, y;\n\n    for (y0 = 0; y0 < height; y0 += 4)\n        for (x = 0; x < width; x++)\n            for (y = y0; y < height && y < y0 + 4; y++) {\n                if ((t1->flags[y+1][x+1] & JPEG2000_T1_SIG_NB)\n                && !(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))) {\n                    int flags_mask = -1;\n                    if (vert_causal_ctx_csty_symbol && y == y0 + 3)\n                        flags_mask &= ~(JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE);\n                    if (ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1] & flags_mask, bandno))) {\n                        int xorbit, ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n                        if (bpass_csty_symbol)\n                             t1->data[y][x] = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ctxno) ? -mask : mask;\n                        else\n                             t1->data[y][x] = (ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ctxno) ^ xorbit) ?\n                                               -mask : mask;\n\n                        ff_jpeg2000_set_significance(t1, x, y,\n                                                     t1->data[y][x] < 0);\n                    }\n                    t1->flags[y + 1][x + 1] |= JPEG2000_T1_VIS;\n                }\n            }\n}", "target": 1}
{"idx": 5049, "func": "static int\nmake_setup_request (AVFormatContext *s, const char *host, int port,\n                    int protocol, const char *real_challenge)\n{\n    RTSPState *rt = s->priv_data;\n    int j, i, err;\n    RTSPStream *rtsp_st;\n    AVStream *st;\n    RTSPHeader reply1, *reply = &reply1;\n    char cmd[2048];\n    const char *trans_pref;\n\n    if (rt->server_type == RTSP_SERVER_RDT)\n        trans_pref = \"x-pn-tng\";\n    else\n        trans_pref = \"RTP/AVP\";\n\n    /* for each stream, make the setup request */\n    /* XXX: we assume the same server is used for the control of each\n       RTSP stream */\n\n    for(j = RTSP_RTP_PORT_MIN, i = 0; i < rt->nb_rtsp_streams; ++i) {\n        char transport[2048];\n\n        rtsp_st = rt->rtsp_streams[i];\n\n        /* compute available transports */\n        transport[0] = '\\0';\n\n        /* RTP/UDP */\n        if (protocol == RTSP_PROTOCOL_RTP_UDP) {\n            char buf[256];\n\n            /* first try in specified port range */\n            if (RTSP_RTP_PORT_MIN != 0) {\n                while(j <= RTSP_RTP_PORT_MAX) {\n                    snprintf(buf, sizeof(buf), \"rtp://%s?localport=%d\", host, j);\n                    j += 2; /* we will use two port by rtp stream (rtp and rtcp) */\n                    if (url_open(&rtsp_st->rtp_handle, buf, URL_RDWR) == 0) {\n                        goto rtp_opened;\n                    }\n                }\n            }\n\n/*            then try on any port\n**            if (url_open(&rtsp_st->rtp_handle, \"rtp://\", URL_RDONLY) < 0) {\n**                err = AVERROR_INVALIDDATA;\n**                goto fail;\n**            }\n*/\n\n        rtp_opened:\n            port = rtp_get_local_port(rtsp_st->rtp_handle);\n            if (transport[0] != '\\0')\n                av_strlcat(transport, \",\", sizeof(transport));\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n                     \"%s/UDP;unicast;client_port=%d\",\n                     trans_pref, port);\n            if (rt->server_type == RTSP_SERVER_RTP)\n                av_strlcatf(transport, sizeof(transport), \"-%d\", port + 1);\n        }\n\n        /* RTP/TCP */\n        else if (protocol == RTSP_PROTOCOL_RTP_TCP) {\n            if (transport[0] != '\\0')\n                av_strlcat(transport, \",\", sizeof(transport));\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n                     \"%s/TCP\", trans_pref);\n        }\n\n        else if (protocol == RTSP_PROTOCOL_RTP_UDP_MULTICAST) {\n            if (transport[0] != '\\0')\n                av_strlcat(transport, \",\", sizeof(transport));\n            snprintf(transport + strlen(transport),\n                     sizeof(transport) - strlen(transport) - 1,\n                     \"%s/UDP;multicast\", trans_pref);\n        }\n        if (rt->server_type == RTSP_SERVER_RDT)\n            av_strlcat(transport, \";mode=play\", sizeof(transport));\n        snprintf(cmd, sizeof(cmd),\n                 \"SETUP %s RTSP/1.0\\r\\n\"\n                 \"Transport: %s\\r\\n\",\n                 rtsp_st->control_url, transport);\n        if (i == 0 && rt->server_type == RTSP_SERVER_RDT) {\n            char real_res[41], real_csum[9];\n            ff_rdt_calc_response_and_checksum(real_res, real_csum,\n                                              real_challenge);\n            av_strlcatf(cmd, sizeof(cmd),\n                        \"If-Match: %s\\r\\n\"\n                        \"RealChallenge2: %s, sd=%s\\r\\n\",\n                        rt->session_id, real_res, real_csum);\n        }\n        rtsp_send_cmd(s, cmd, reply, NULL);\n        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {\n            err = 1;\n            goto fail;\n        } else if (reply->status_code != RTSP_STATUS_OK ||\n                   reply->nb_transports != 1) {\n            err = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        /* XXX: same protocol for all streams is required */\n        if (i > 0) {\n            if (reply->transports[0].protocol != rt->protocol) {\n                err = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n        } else {\n            rt->protocol = reply->transports[0].protocol;\n        }\n\n        /* close RTP connection if not choosen */\n        if (reply->transports[0].protocol != RTSP_PROTOCOL_RTP_UDP &&\n            (protocol == RTSP_PROTOCOL_RTP_UDP)) {\n            url_close(rtsp_st->rtp_handle);\n            rtsp_st->rtp_handle = NULL;\n        }\n\n        switch(reply->transports[0].protocol) {\n        case RTSP_PROTOCOL_RTP_TCP:\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n            break;\n\n        case RTSP_PROTOCOL_RTP_UDP:\n            {\n                char url[1024];\n\n                /* XXX: also use address if specified */\n                snprintf(url, sizeof(url), \"rtp://%s:%d\",\n                         host, reply->transports[0].server_port_min);\n                if (rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {\n                    err = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n            }\n            break;\n        case RTSP_PROTOCOL_RTP_UDP_MULTICAST:\n            {\n                char url[1024];\n                struct in_addr in;\n\n                in.s_addr = htonl(reply->transports[0].destination);\n                snprintf(url, sizeof(url), \"rtp://%s:%d?ttl=%d\",\n                         inet_ntoa(in),\n                         reply->transports[0].port_min,\n                         reply->transports[0].ttl);\n                if (url_open(&rtsp_st->rtp_handle, url, URL_RDWR) < 0) {\n                    err = AVERROR_INVALIDDATA;\n                    goto fail;\n                }\n            }\n            break;\n        }\n        /* open the RTP context */\n        st = NULL;\n        if (rtsp_st->stream_index >= 0)\n            st = s->streams[rtsp_st->stream_index];\n        if (!st)\n            s->ctx_flags |= AVFMTCTX_NOHEADER;\n        rtsp_st->rtp_ctx = rtp_parse_open(s, st, rtsp_st->rtp_handle, rtsp_st->sdp_payload_type, &rtsp_st->rtp_payload_data);\n\n        if (!rtsp_st->rtp_ctx) {\n            err = AVERROR(ENOMEM);\n            goto fail;\n        } else {\n            if(rtsp_st->dynamic_handler) {\n                rtsp_st->rtp_ctx->dynamic_protocol_context= rtsp_st->dynamic_protocol_context;\n                rtsp_st->rtp_ctx->parse_packet= rtsp_st->dynamic_handler->parse_packet;\n            }\n        }\n    }\n\n    return 0;\n\nfail:\n    for (i=0; i<rt->nb_rtsp_streams; i++) {\n        if (rt->rtsp_streams[i]->rtp_handle) {\n            url_close(rt->rtsp_streams[i]->rtp_handle);\n            rt->rtsp_streams[i]->rtp_handle = NULL;\n        }\n    }\n    return err;\n}", "target": 0}
{"idx": 5050, "func": "int BIO_accept(int sock, char **addr)\n\t{\n\tint ret=INVALID_SOCKET;\n\tstatic struct sockaddr_in from;\n\tunsigned long l;\n\tunsigned short port;\n\tint len;\n\tchar *p;\n\n\tmemset((char *)&from,0,sizeof(from));\n\tlen=sizeof(from);\n\t/* Note: under VMS with SOCKETSHR the fourth parameter is currently\n\t * of type (int *) whereas under other systems it is (void *) if\n\t * you don't have a cast it will choke the compiler: if you do\n\t * have a cast then you can either go for (int *) or (void *).\n\t */\n\tret=accept(sock,(struct sockaddr *)&from,(void *)&len);\n\tif (ret == INVALID_SOCKET)\n\t\t{\n\t\tif(BIO_sock_should_retry(ret)) return -2;\n\t\tSYSerr(SYS_F_ACCEPT,get_last_socket_error());\n\t\tBIOerr(BIO_F_BIO_ACCEPT,BIO_R_ACCEPT_ERROR);\n\t\tgoto end;\n\t\t}\n\n\tif (addr == NULL) goto end;\n\n\tl=ntohl(from.sin_addr.s_addr);\n\tport=ntohs(from.sin_port);\n\tif (*addr == NULL)\n\t\t{\n\t\tif ((p=OPENSSL_malloc(24)) == NULL)\n\t\t\t{\n\t\t\tBIOerr(BIO_F_BIO_ACCEPT,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto end;\n\t\t\t}\n\t\t*addr=p;\n\t\t}\n\tBIO_snprintf(*addr,24,\"%d.%d.%d.%d:%d\",\n\t\t     (unsigned char)(l>>24L)&0xff,\n\t\t     (unsigned char)(l>>16L)&0xff,\n\t\t     (unsigned char)(l>> 8L)&0xff,\n\t\t     (unsigned char)(l     )&0xff,\n\t\t     port);\nend:\n\treturn(ret);\n\t}", "target": 0}
{"idx": 5051, "func": "static int decode_header_trees(SmackVContext *smk) {\n    GetBitContext gb;\n    int mmap_size, mclr_size, full_size, type_size, ret;\n\n    mmap_size = AV_RL32(smk->avctx->extradata);\n    mclr_size = AV_RL32(smk->avctx->extradata + 4);\n    full_size = AV_RL32(smk->avctx->extradata + 8);\n    type_size = AV_RL32(smk->avctx->extradata + 12);\n\n    ret = init_get_bits8(&gb, smk->avctx->extradata + 16, smk->avctx->extradata_size - 16);\n    if (ret < 0)\n        return ret;\n\n    if(!get_bits1(&gb)) {\n        av_log(smk->avctx, AV_LOG_INFO, \"Skipping MMAP tree\\n\");\n        smk->mmap_tbl = av_malloc(sizeof(int) * 2);\n        if (!smk->mmap_tbl)\n            return AVERROR(ENOMEM);\n        smk->mmap_tbl[0] = 0;\n        smk->mmap_last[0] = smk->mmap_last[1] = smk->mmap_last[2] = 1;\n    } else {\n        ret = smacker_decode_header_tree(smk, &gb, &smk->mmap_tbl, smk->mmap_last, mmap_size);\n        if (ret < 0)\n            return ret;\n    }\n    if(!get_bits1(&gb)) {\n        av_log(smk->avctx, AV_LOG_INFO, \"Skipping MCLR tree\\n\");\n        smk->mclr_tbl = av_malloc(sizeof(int) * 2);\n        if (!smk->mclr_tbl)\n            return AVERROR(ENOMEM);\n        smk->mclr_tbl[0] = 0;\n        smk->mclr_last[0] = smk->mclr_last[1] = smk->mclr_last[2] = 1;\n    } else {\n        ret = smacker_decode_header_tree(smk, &gb, &smk->mclr_tbl, smk->mclr_last, mclr_size);\n        if (ret < 0)\n            return ret;\n    }\n    if(!get_bits1(&gb)) {\n        av_log(smk->avctx, AV_LOG_INFO, \"Skipping FULL tree\\n\");\n        smk->full_tbl = av_malloc(sizeof(int) * 2);\n        if (!smk->full_tbl)\n            return AVERROR(ENOMEM);\n        smk->full_tbl[0] = 0;\n        smk->full_last[0] = smk->full_last[1] = smk->full_last[2] = 1;\n    } else {\n        ret = smacker_decode_header_tree(smk, &gb, &smk->full_tbl, smk->full_last, full_size);\n        if (ret < 0)\n            return ret;\n    }\n    if(!get_bits1(&gb)) {\n        av_log(smk->avctx, AV_LOG_INFO, \"Skipping TYPE tree\\n\");\n        smk->type_tbl = av_malloc(sizeof(int) * 2);\n        if (!smk->type_tbl)\n            return AVERROR(ENOMEM);\n        smk->type_tbl[0] = 0;\n        smk->type_last[0] = smk->type_last[1] = smk->type_last[2] = 1;\n    } else {\n        ret = smacker_decode_header_tree(smk, &gb, &smk->type_tbl, smk->type_last, type_size);\n        if (ret < 0)\n            return ret;\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5052, "func": "int ssl3_do_write(SSL *s, int type)\n\t{\n\tint ret;\n\n\tret=ssl3_write_bytes(s,type,&s->init_buf->data[s->init_off],\n\t                     s->init_num);\n\tif (ret < 0) return(-1);\n\tif (type == SSL3_RT_HANDSHAKE)\n\t\t/* should not be done for 'Hello Request's, but in that case\n\t\t * we'll ignore the result anyway */\n\t\tssl3_finish_mac(s,(unsigned char *)&s->init_buf->data[s->init_off],ret);\n\t\n\tif (ret == s->init_num)\n\t\t{\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(1, s->version, type, s->init_buf->data, (size_t)(s->init_off + s->init_num), s, s->msg_callback_arg);\n\t\treturn(1);\n\t\t}\n\ts->init_off+=ret;\n\ts->init_num-=ret;\n\treturn(0);\n\t}", "target": 1}
{"idx": 5053, "func": "int X509_STORE_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,\n\t     X509_OBJECT *ret)\n\t{\n\tX509_STORE *ctx=vs->ctx;\n\tX509_LOOKUP *lu;\n\tX509_OBJECT stmp,*tmp;\n\tint i,j;\n\n\ttmp=X509_OBJECT_retrieve_by_subject(ctx->objs,type,name);\n\n\tif (tmp == NULL)\n\t\t{\n\t\tfor (i=vs->current_method; i<sk_X509_LOOKUP_num(ctx->get_cert_methods); i++)\n\t\t\t{\n\t\t\tlu=sk_X509_LOOKUP_value(ctx->get_cert_methods,i);\n\t\t\tj=X509_LOOKUP_by_subject(lu,type,name,&stmp);\n\t\t\tif (j < 0)\n\t\t\t\t{\n\t\t\t\tvs->current_method=j;\n\t\t\t\treturn(j);\n\t\t\t\t}\n\t\t\telse if (j)\n\t\t\t\t{\n\t\t\t\ttmp= &stmp;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tvs->current_method=0;\n\t\tif (tmp == NULL)\n\t\t\treturn(0);\n\t\t}\n\n/*\tif (ret->data.ptr != NULL)\n\t\tX509_OBJECT_free_contents(ret); */\n\n\tret->type=tmp->type;\n\tret->data.ptr=tmp->data.ptr;\n\n\tX509_OBJECT_up_ref_count(ret);\n\n\treturn(1);\n\t}", "target": 0}
{"idx": 5054, "func": "static int tiff_unpack_fax(TiffContext *s, uint8_t *dst, int stride,\n                           const uint8_t *src, int size, int width, int lines)\n{\n    int i, ret = 0;\n    int line;\n    uint8_t *src2;\n\n    av_fast_padded_malloc(&s->fax_buffer, &s->fax_buffer_size, size);\n    src2 = s->fax_buffer;\n\n    if (!src2) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Error allocating temporary buffer\\n\");\n        return AVERROR(ENOMEM);\n    }\n\n    if (!s->fill_order) {\n        memcpy(src2, src, size);\n    } else {\n        for (i = 0; i < size; i++)\n            src2[i] = ff_reverse[src[i]];\n    }\n    memset(src2 + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n    ret = ff_ccitt_unpack(s->avctx, src2, size, dst, lines, stride,\n                          s->compr, s->fax_opts);\n    if (s->bpp < 8 && s->avctx->pix_fmt == AV_PIX_FMT_PAL8)\n        for (line = 0; line < lines; line++) {\n            horizontal_fill(s->bpp, dst, 1, dst, 0, width, 0);\n            dst += stride;\n        }\n    return ret;\n}", "target": 0}
{"idx": 5055, "func": "int avio_read(AVIOContext *s, unsigned char *buf, int size)\n{\n    int len, size1;\n\n    size1 = size;\n    while (size > 0) {\n        len = s->buf_end - s->buf_ptr;\n        if (len > size)\n            len = size;\n        if (len == 0 || s->write_flag) {\n            if((s->direct || size > s->buffer_size) && !s->update_checksum){\n                if(s->read_packet)\n                    len = s->read_packet(s->opaque, buf, size);\n                if (len <= 0) {\n                    /* do not modify buffer if EOF reached so that a seek back can\n                    be done without rereading data */\n                    s->eof_reached = 1;\n                    if(len<0)\n                        s->error= len;\n                    break;\n                } else {\n                    s->pos += len;\n                    s->bytes_read += len;\n                    size -= len;\n                    buf += len;\n                    s->buf_ptr = s->buffer;\n                    s->buf_end = s->buffer/* + len*/;\n                }\n            } else {\n                fill_buffer(s);\n                len = s->buf_end - s->buf_ptr;\n                if (len == 0)\n                    break;\n            }\n        } else {\n            memcpy(buf, s->buf_ptr, len);\n            buf += len;\n            s->buf_ptr += len;\n            size -= len;\n        }\n    }\n    if (size1 == size) {\n        if (s->error)      return s->error;\n        if (avio_feof(s))  return AVERROR_EOF;\n    }\n    return size1 - size;\n}", "target": 1}
{"idx": 5056, "func": "static int mpsub_probe(AVProbeData *p)\n{\n    const char *ptr     = p->buf;\n    const char *ptr_end = p->buf + p->buf_size;\n\n    while (ptr < ptr_end) {\n        int inc;\n\n        if (!memcmp(ptr, \"FORMAT=TIME\", 11))\n            return AVPROBE_SCORE_EXTENSION;\n        if (!memcmp(ptr, \"FORMAT=\", 7))\n            return AVPROBE_SCORE_EXTENSION / 3;\n        inc = ff_subtitles_next_line(ptr);\n        if (!inc)\n            break;\n        ptr += inc;\n    }\n    return 0;\n}", "target": 0}
{"idx": 5057, "func": "ngx_int_t\nngx_hash_add_key(ngx_hash_keys_arrays_t *ha, ngx_str_t *key, void *value,\n    ngx_uint_t flags)\n{\n    size_t           len;\n    u_char          *p;\n    ngx_str_t       *name;\n    ngx_uint_t       i, k, n, skip, last;\n    ngx_array_t     *keys, *hwc;\n    ngx_hash_key_t  *hk;\n\n    last = key->len;\n\n    if (flags & NGX_HASH_WILDCARD_KEY) {\n\n        /*\n         * supported wildcards:\n         *     \"*.example.com\", \".example.com\", and \"www.example.*\"\n         */\n\n        n = 0;\n\n        for (i = 0; i < key->len; i++) {\n\n            if (key->data[i] == '*') {\n                if (++n > 1) {\n                    return NGX_DECLINED;\n                }\n            }\n\n            if (key->data[i] == '.' && key->data[i + 1] == '.') {\n                return NGX_DECLINED;\n            }\n\n            if (key->data[i] == '\\0') {\n                return NGX_DECLINED;\n            }\n        }\n\n        if (key->len > 1 && key->data[0] == '.') {\n            skip = 1;\n            goto wildcard;\n        }\n\n        if (key->len > 2) {\n\n            if (key->data[0] == '*' && key->data[1] == '.') {\n                skip = 2;\n                goto wildcard;\n            }\n\n            if (key->data[i - 2] == '.' && key->data[i - 1] == '*') {\n                skip = 0;\n                last -= 2;\n                goto wildcard;\n            }\n        }\n\n        if (n) {\n            return NGX_DECLINED;\n        }\n    }\n\n    /* exact hash */\n\n    k = 0;\n\n    for (i = 0; i < last; i++) {\n        if (!(flags & NGX_HASH_READONLY_KEY)) {\n            key->data[i] = ngx_tolower(key->data[i]);\n        }\n        k = ngx_hash(k, key->data[i]);\n    }\n\n    k %= ha->hsize;\n\n    /* check conflicts in exact hash */\n\n    name = ha->keys_hash[k].elts;\n\n    if (name) {\n        for (i = 0; i < ha->keys_hash[k].nelts; i++) {\n            if (last != name[i].len) {\n                continue;\n            }\n\n            if (ngx_strncmp(key->data, name[i].data, last) == 0) {\n                return NGX_BUSY;\n            }\n        }\n\n    } else {\n        if (ngx_array_init(&ha->keys_hash[k], ha->temp_pool, 4,\n                           sizeof(ngx_str_t))\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    name = ngx_array_push(&ha->keys_hash[k]);\n    if (name == NULL) {\n        return NGX_ERROR;\n    }\n\n    *name = *key;\n\n    hk = ngx_array_push(&ha->keys);\n    if (hk == NULL) {\n        return NGX_ERROR;\n    }\n\n    hk->key = *key;\n    hk->key_hash = ngx_hash_key(key->data, last);\n    hk->value = value;\n\n    return NGX_OK;\n\n\nwildcard:\n\n    /* wildcard hash */\n\n    k = ngx_hash_strlow(&key->data[skip], &key->data[skip], last - skip);\n\n    k %= ha->hsize;\n\n    if (skip == 1) {\n\n        /* check conflicts in exact hash for \".example.com\" */\n\n        name = ha->keys_hash[k].elts;\n\n        if (name) {\n            len = last - skip;\n\n            for (i = 0; i < ha->keys_hash[k].nelts; i++) {\n                if (len != name[i].len) {\n                    continue;\n                }\n\n                if (ngx_strncmp(&key->data[1], name[i].data, len) == 0) {\n                    return NGX_BUSY;\n                }\n            }\n\n        } else {\n            if (ngx_array_init(&ha->keys_hash[k], ha->temp_pool, 4,\n                               sizeof(ngx_str_t))\n                != NGX_OK)\n            {\n                return NGX_ERROR;\n            }\n        }\n\n        name = ngx_array_push(&ha->keys_hash[k]);\n        if (name == NULL) {\n            return NGX_ERROR;\n        }\n\n        name->len = last - 1;\n        name->data = ngx_pnalloc(ha->temp_pool, name->len);\n        if (name->data == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_memcpy(name->data, &key->data[1], name->len);\n    }\n\n\n    if (skip) {\n\n        /*\n         * convert \"*.example.com\" to \"com.example.\\0\"\n         *      and \".example.com\" to \"com.example\\0\"\n         */\n\n        p = ngx_pnalloc(ha->temp_pool, last);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        len = 0;\n        n = 0;\n\n        for (i = last - 1; i; i--) {\n            if (key->data[i] == '.') {\n                ngx_memcpy(&p[n], &key->data[i + 1], len);\n                n += len;\n                p[n++] = '.';\n                len = 0;\n                continue;\n            }\n\n            len++;\n        }\n\n        if (len) {\n            ngx_memcpy(&p[n], &key->data[1], len);\n            n += len;\n        }\n\n        p[n] = '\\0';\n\n        hwc = &ha->dns_wc_head;\n        keys = &ha->dns_wc_head_hash[k];\n\n    } else {\n\n        /* convert \"www.example.*\" to \"www.example\\0\" */\n\n        last++;\n\n        p = ngx_pnalloc(ha->temp_pool, last);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_cpystrn(p, key->data, last);\n\n        hwc = &ha->dns_wc_tail;\n        keys = &ha->dns_wc_tail_hash[k];\n    }\n\n\n    /* check conflicts in wildcard hash */\n\n    name = keys->elts;\n\n    if (name) {\n        len = last - skip;\n\n        for (i = 0; i < keys->nelts; i++) {\n            if (len != name[i].len) {\n                continue;\n            }\n\n            if (ngx_strncmp(key->data + skip, name[i].data, len) == 0) {\n                return NGX_BUSY;\n            }\n        }\n\n    } else {\n        if (ngx_array_init(keys, ha->temp_pool, 4, sizeof(ngx_str_t)) != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    name = ngx_array_push(keys);\n    if (name == NULL) {\n        return NGX_ERROR;\n    }\n\n    name->len = last - skip;\n    name->data = ngx_pnalloc(ha->temp_pool, name->len);\n    if (name->data == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memcpy(name->data, key->data + skip, name->len);\n\n\n    /* add to wildcard hash */\n\n    hk = ngx_array_push(hwc);\n    if (hk == NULL) {\n        return NGX_ERROR;\n    }\n\n    hk->key.len = last - 1;\n    hk->key.data = p;\n    hk->key_hash = 0;\n    hk->value = value;\n\n    return NGX_OK;\n}", "target": 1}
{"idx": 5058, "func": "static void gmc1_motion(MpegEncContext *s,\n                        uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n                        uint8_t **ref_picture)\n{\n    uint8_t *ptr;\n    int offset, src_x, src_y, linesize, uvlinesize;\n    int motion_x, motion_y;\n    int emu=0;\n\n    motion_x= s->sprite_offset[0][0];\n    motion_y= s->sprite_offset[0][1];\n    src_x = s->mb_x * 16 + (motion_x >> (s->sprite_warping_accuracy+1));\n    src_y = s->mb_y * 16 + (motion_y >> (s->sprite_warping_accuracy+1));\n    motion_x<<=(3-s->sprite_warping_accuracy);\n    motion_y<<=(3-s->sprite_warping_accuracy);\n    src_x = av_clip(src_x, -16, s->width);\n    if (src_x == s->width)\n        motion_x =0;\n    src_y = av_clip(src_y, -16, s->height);\n    if (src_y == s->height)\n        motion_y =0;\n\n    linesize = s->linesize;\n    uvlinesize = s->uvlinesize;\n\n    ptr = ref_picture[0] + (src_y * linesize) + src_x;\n\n        if(   (unsigned)src_x >= FFMAX(s->h_edge_pos - 17, 0)\n           || (unsigned)src_y >= FFMAX(s->v_edge_pos - 17, 0)){\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, linesize, 17, 17, src_x, src_y, s->h_edge_pos, s->v_edge_pos);\n            ptr= s->edge_emu_buffer;\n        }\n\n    if((motion_x|motion_y)&7){\n        s->dsp.gmc1(dest_y  , ptr  , linesize, 16, motion_x&15, motion_y&15, 128 - s->no_rounding);\n        s->dsp.gmc1(dest_y+8, ptr+8, linesize, 16, motion_x&15, motion_y&15, 128 - s->no_rounding);\n    }else{\n        int dxy;\n\n        dxy= ((motion_x>>3)&1) | ((motion_y>>2)&2);\n        if (s->no_rounding){\n            s->hdsp.put_no_rnd_pixels_tab[0][dxy](dest_y, ptr, linesize, 16);\n        }else{\n            s->hdsp.put_pixels_tab       [0][dxy](dest_y, ptr, linesize, 16);\n        }\n    }\n\n    if(CONFIG_GRAY && s->flags&CODEC_FLAG_GRAY) return;\n\n    motion_x= s->sprite_offset[1][0];\n    motion_y= s->sprite_offset[1][1];\n    src_x = s->mb_x * 8 + (motion_x >> (s->sprite_warping_accuracy+1));\n    src_y = s->mb_y * 8 + (motion_y >> (s->sprite_warping_accuracy+1));\n    motion_x<<=(3-s->sprite_warping_accuracy);\n    motion_y<<=(3-s->sprite_warping_accuracy);\n    src_x = av_clip(src_x, -8, s->width>>1);\n    if (src_x == s->width>>1)\n        motion_x =0;\n    src_y = av_clip(src_y, -8, s->height>>1);\n    if (src_y == s->height>>1)\n        motion_y =0;\n\n    offset = (src_y * uvlinesize) + src_x;\n    ptr = ref_picture[1] + offset;\n        if(   (unsigned)src_x >= FFMAX((s->h_edge_pos>>1) - 9, 0)\n           || (unsigned)src_y >= FFMAX((s->v_edge_pos>>1) - 9, 0)){\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n            ptr= s->edge_emu_buffer;\n            emu=1;\n        }\n    s->dsp.gmc1(dest_cb, ptr, uvlinesize, 8, motion_x&15, motion_y&15, 128 - s->no_rounding);\n\n    ptr = ref_picture[2] + offset;\n    if(emu){\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, uvlinesize, 9, 9, src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n        ptr= s->edge_emu_buffer;\n    }\n    s->dsp.gmc1(dest_cr, ptr, uvlinesize, 8, motion_x&15, motion_y&15, 128 - s->no_rounding);\n\n    return;\n}", "target": 1}
{"idx": 5059, "func": "size_t BUF_MEM_grow_clean(BUF_MEM *str, size_t len)\n{\n    char *ret;\n    size_t n;\n\n    if (str->length >= len) {\n        memset(&str->data[len], 0, str->length - len);\n        str->length = len;\n        return (len);\n    }\n    if (str->max >= len) {\n        memset(&str->data[str->length], 0, len - str->length);\n        str->length = len;\n        return (len);\n    }\n    /* This limit is sufficient to ensure (len+3)/3*4 < 2**31 */\n    if (len > LIMIT_BEFORE_EXPANSION) {\n        BUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    n = (len + 3) / 3 * 4;\n    if ((str->flags & BUF_MEM_FLAG_SECURE))\n        ret = sec_alloc_realloc(str, n);\n    else\n        ret = OPENSSL_clear_realloc(str->data, str->max, n);\n    if (ret == NULL) {\n        BUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);\n        len = 0;\n    } else {\n        str->data = ret;\n        str->max = n;\n        memset(&str->data[str->length], 0, len - str->length);\n        str->length = len;\n    }\n    return (len);\n}", "target": 1}
{"idx": 5060, "func": "static int tscc2_decode_mb(TSCC2Context *c, int *q, int vlc_set,\n                           uint8_t *dst, int stride, int plane)\n{\n    GetBitContext *gb = &c->gb;\n    int prev_dc, dc, nc, ac, bpos, val;\n    int i, j, k, l;\n\n    if (get_bits1(gb)) {\n        if (get_bits1(gb)) {\n            val = get_bits(gb, 8);\n            for (i = 0; i < 8; i++, dst += stride)\n                memset(dst, val, 16);\n        } else {\n            if (get_bits_left(gb) < 16 * 8 * 8)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < 8; i++) {\n                for (j = 0; j < 16; j++)\n                    dst[j] = get_bits(gb, 8);\n                dst += stride;\n            }\n        }\n        return 0;\n    }\n\n    prev_dc = 0;\n    for (j = 0; j < 2; j++) {\n        for (k = 0; k < 4; k++) {\n            if (!(j | k)) {\n                dc = get_bits(gb, 8);\n            } else {\n                dc = get_vlc2(gb, c->dc_vlc.table, 9, 2);\n                if (dc == -1)\n                    return AVERROR_INVALIDDATA;\n                if (dc == 0x100)\n                    dc = get_bits(gb, 8);\n            }\n            dc          = (dc + prev_dc) & 0xFF;\n            prev_dc     = dc;\n            c->block[0] = dc;\n\n            nc = get_vlc2(gb, c->nc_vlc[vlc_set].table, 9, 1);\n            if (nc == -1)\n                return AVERROR_INVALIDDATA;\n\n            bpos = 1;\n            memset(c->block + 1, 0, 15 * sizeof(*c->block));\n            for (l = 0; l < nc; l++) {\n                ac = get_vlc2(gb, c->ac_vlc[vlc_set].table, 9, 2);\n                if (ac == -1)\n                    return AVERROR_INVALIDDATA;\n                if (ac == 0x1000)\n                    ac = get_bits(gb, 12);\n                bpos += ac & 0xF;\n                if (bpos >= 16)\n                    return AVERROR_INVALIDDATA;\n                val = sign_extend(ac >> 4, 8);\n                c->block[tscc2_zigzag[bpos++]] = val;\n            }\n            tscc2_idct4_put(c->block, q, dst + k * 4, stride);\n        }\n        dst += 4 * stride;\n    }\n    return 0;\n}", "target": 0}
{"idx": 5061, "func": "static void\nhorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tint16 *wp = (int16*) cp0;\n\ttmsize_t wc = cc/2;\n\n\tassert((cc%(2*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] -= wp[0]; wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}", "target": 1}
{"idx": 5062, "func": "static void *ff_realloc_static(void *ptr, unsigned int size)\n{\n    int i;\n    if(!ptr)\n      return av_mallocz_static(size);\n    /* Look for the old ptr */\n    for(i = 0; i < last_static; i++) {\n        if(array_static[i] == ptr) {\n            array_static[i] = av_realloc(array_static[i], size);\n            return array_static[i];\n        }\n    }\n    return NULL;\n\n}", "target": 1}
{"idx": 5063, "func": "static int hds_flush(AVFormatContext *s, OutputStream *os, int final,\n                     int64_t end_ts)\n{\n    HDSContext *c = s->priv_data;\n    int i, ret = 0;\n    char target_filename[1024];\n    int index = s->streams[os->first_stream]->id;\n\n    if (!os->packets_written)\n        return 0;\n\n    avio_flush(os->ctx->pb);\n    os->packets_written = 0;\n    close_file(s, os);\n\n    snprintf(target_filename, sizeof(target_filename),\n             \"%s/stream%dSeg1-Frag%d\", s->filename, index, os->fragment_index);\n    ret = ff_rename(os->temp_filename, target_filename);\n    if (ret < 0)\n        return ret;\n    add_fragment(os, target_filename, os->frag_start_ts, end_ts - os->frag_start_ts);\n\n    if (!final) {\n        ret = init_file(s, os, end_ts);\n        if (ret < 0)\n            return ret;\n    }\n\n    if (c->window_size || (final && c->remove_at_exit)) {\n        int remove = os->nb_fragments - c->window_size - c->extra_window_size;\n        if (final && c->remove_at_exit)\n            remove = os->nb_fragments;\n        if (remove > 0) {\n            for (i = 0; i < remove; i++) {\n                unlink(os->fragments[i]->file);\n                av_free(os->fragments[i]);\n            }\n            os->nb_fragments -= remove;\n            memmove(os->fragments, os->fragments + remove,\n                    os->nb_fragments * sizeof(*os->fragments));\n        }\n    }\n\n    if (ret >= 0)\n        ret = write_abst(s, os, final);\n    return ret;\n}", "target": 0}
{"idx": 5064, "func": "static int start_frame(AVFilterLink *inlink, AVFilterBufferRef *inpicref)\n{\n    AVFilterBufferRef *outpicref = avfilter_ref_buffer(inpicref, ~0);\n    AVFilterContext *ctx = inlink->dst;\n    OverlayContext *over = ctx->priv;\n\n    if (!outpicref)\n        return AVERROR(ENOMEM);\n\n    outpicref->pts = av_rescale_q(outpicref->pts, ctx->inputs[MAIN]->time_base,\n                                  ctx->outputs[0]->time_base);\n\n    if (!over->overpicref || over->overpicref->pts < outpicref->pts) {\n        AVFilterBufferRef *old = over->overpicref;\n        over->overpicref = NULL;\n        ff_request_frame(ctx->inputs[OVERLAY]);\n        if (over->overpicref) {\n            if (old)\n                avfilter_unref_buffer(old);\n        } else\n            over->overpicref = old;\n    }\n\n    return ff_start_frame(inlink->dst->outputs[0], outpicref);\n}", "target": 0}
{"idx": 5065, "func": "static int tb_unreliable(AVCodecContext *c)\n{\n    if (c->time_base.den >= 101L * c->time_base.num ||\n        c->time_base.den <    5L * c->time_base.num ||\n        // c->codec_tag == AV_RL32(\"DIVX\") ||\n        // c->codec_tag == AV_RL32(\"XVID\") ||\n        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n        c->codec_id == AV_CODEC_ID_H264)\n        return 1;\n    return 0;\n}", "target": 1}
{"idx": 5066, "func": "static void decode_tones_amplitude(GetBitContext *gb, Atrac3pChanUnitCtx *ctx,\n                                   int ch_num, int band_has_tones[])\n{\n    int mode, sb, j, i, diff, maxdiff, fi, delta, pred;\n    Atrac3pWaveParam *wsrc, *wref;\n    int refwaves[48];\n    Atrac3pWavesData *dst = ctx->channels[ch_num].tones_info;\n    Atrac3pWavesData *ref = ctx->channels[0].tones_info;\n\n    if (ch_num) {\n        for (sb = 0; sb < ctx->waves_info->num_tone_bands; sb++) {\n            if (!band_has_tones[sb] || !dst[sb].num_wavs)\n                continue;\n            wsrc = &ctx->waves_info->waves[dst[sb].start_index];\n            wref = &ctx->waves_info->waves[ref[sb].start_index];\n            for (j = 0; j < dst[sb].num_wavs; j++) {\n                for (i = 0, fi = 0, maxdiff = 1024; i < ref[sb].num_wavs; i++) {\n                    diff = FFABS(wsrc[j].freq_index - wref[i].freq_index);\n                    if (diff < maxdiff) {\n                        maxdiff = diff;\n                        fi      = i;\n                    }\n                }\n\n                if (maxdiff < 8)\n                    refwaves[dst[sb].start_index + j] = fi + ref[sb].start_index;\n                else if (j < ref[sb].num_wavs)\n                    refwaves[dst[sb].start_index + j] = j + ref[sb].start_index;\n                else\n                    refwaves[dst[sb].start_index + j] = -1;\n            }\n        }\n    }\n\n    mode = get_bits(gb, ch_num + 1);\n\n    switch (mode) {\n    case 0: /** fixed-length coding */\n        for (sb = 0; sb < ctx->waves_info->num_tone_bands; sb++) {\n            if (!band_has_tones[sb] || !dst[sb].num_wavs)\n                continue;\n            if (ctx->waves_info->amplitude_mode)\n                for (i = 0; i < dst[sb].num_wavs; i++)\n                    ctx->waves_info->waves[dst[sb].start_index + i].amp_sf = get_bits(gb, 6);\n            else\n                ctx->waves_info->waves[dst[sb].start_index].amp_sf = get_bits(gb, 6);\n        }\n        break;\n    case 1: /** min + VLC delta */\n        for (sb = 0; sb < ctx->waves_info->num_tone_bands; sb++) {\n            if (!band_has_tones[sb] || !dst[sb].num_wavs)\n                continue;\n            if (ctx->waves_info->amplitude_mode)\n                for (i = 0; i < dst[sb].num_wavs; i++)\n                    ctx->waves_info->waves[dst[sb].start_index + i].amp_sf =\n                        get_vlc2(gb, tone_vlc_tabs[3].table,\n                                 tone_vlc_tabs[3].bits, 1) + 20;\n            else\n                ctx->waves_info->waves[dst[sb].start_index].amp_sf =\n                    get_vlc2(gb, tone_vlc_tabs[4].table,\n                             tone_vlc_tabs[4].bits, 1) + 24;\n        }\n        break;\n    case 2: /** VLC modulo delta to master (slave only) */\n        for (sb = 0; sb < ctx->waves_info->num_tone_bands; sb++) {\n            if (!band_has_tones[sb] || !dst[sb].num_wavs)\n                continue;\n            for (i = 0; i < dst[sb].num_wavs; i++) {\n                delta = get_vlc2(gb, tone_vlc_tabs[5].table,\n                                 tone_vlc_tabs[5].bits, 1);\n                delta = sign_extend(delta, 5);\n                pred  = refwaves[dst[sb].start_index + i] >= 0 ?\n                        ctx->waves_info->waves[refwaves[dst[sb].start_index + i]].amp_sf : 34;\n                ctx->waves_info->waves[dst[sb].start_index + i].amp_sf = (pred + delta) & 0x3F;\n            }\n        }\n        break;\n    case 3: /** clone master (slave only) */\n        for (sb = 0; sb < ctx->waves_info->num_tone_bands; sb++) {\n            if (!band_has_tones[sb])\n                continue;\n            for (i = 0; i < dst[sb].num_wavs; i++)\n                ctx->waves_info->waves[dst[sb].start_index + i].amp_sf =\n                    refwaves[dst[sb].start_index + i] >= 0\n                    ? ctx->waves_info->waves[refwaves[dst[sb].start_index + i]].amp_sf\n                    : 32;\n        }\n        break;\n    }\n}", "target": 0}
{"idx": 5067, "func": "static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,\n                             GetByteContext *gb)\n{\n    unsigned char rle_code;\n    unsigned char extra_byte, odd_pixel;\n    unsigned char stream_byte;\n    unsigned int pixel_ptr = 0;\n    int row_dec = pic->linesize[0];\n    int row_ptr = (avctx->height - 1) * row_dec;\n    int frame_size = row_dec * avctx->height;\n    int i;\n\n    while (row_ptr >= 0) {\n        if (bytestream2_get_bytes_left(gb) <= 0) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"MS RLE: bytestream overrun, %d rows left\\n\",\n                   row_ptr);\n            return AVERROR_INVALIDDATA;\n        }\n        rle_code = stream_byte = bytestream2_get_byteu(gb);\n        if (rle_code == 0) {\n            /* fetch the next byte to see how to handle escape code */\n            stream_byte = bytestream2_get_byte(gb);\n            if (stream_byte == 0) {\n                /* line is done, goto the next one */\n                row_ptr -= row_dec;\n                pixel_ptr = 0;\n            } else if (stream_byte == 1) {\n                /* decode is done */\n                return 0;\n            } else if (stream_byte == 2) {\n                /* reposition frame decode coordinates */\n                stream_byte = bytestream2_get_byte(gb);\n                pixel_ptr += stream_byte;\n                stream_byte = bytestream2_get_byte(gb);\n                row_ptr -= stream_byte * row_dec;\n            } else {\n                // copy pixels from encoded stream\n                odd_pixel =  stream_byte & 1;\n                rle_code = (stream_byte + 1) / 2;\n                extra_byte = rle_code & 0x01;\n                if (row_ptr + pixel_ptr + stream_byte > frame_size ||\n                    bytestream2_get_bytes_left(gb) < rle_code) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n\n                for (i = 0; i < rle_code; i++) {\n                    if (pixel_ptr >= avctx->width)\n                        break;\n                    stream_byte = bytestream2_get_byteu(gb);\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n                    pixel_ptr++;\n                    if (i + 1 == rle_code && odd_pixel)\n                        break;\n                    if (pixel_ptr >= avctx->width)\n                        break;\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n                    pixel_ptr++;\n                }\n\n                // if the RLE code is odd, skip a byte in the stream\n                if (extra_byte)\n                    bytestream2_skip(gb, 1);\n            }\n        } else {\n            // decode a run of data\n            if (row_ptr + pixel_ptr + stream_byte > frame_size) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"MS RLE: frame ptr just went out of bounds (run)\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            stream_byte = bytestream2_get_byte(gb);\n            for (i = 0; i < rle_code; i++) {\n                if (pixel_ptr >= avctx->width)\n                    break;\n                if ((i & 1) == 0)\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n                else\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n                pixel_ptr++;\n            }\n        }\n    }\n\n    /* one last sanity check on the way out */\n    if (bytestream2_get_bytes_left(gb)) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"MS RLE: ended frame decode with %d bytes left over\\n\",\n               bytestream2_get_bytes_left(gb));\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5068, "func": "size_t BUF_MEM_grow(BUF_MEM *str, size_t len)\n{\n    char *ret;\n    size_t n;\n\n    if (str->length >= len) {\n        str->length = len;\n        return len;\n    }\n    if (str->max >= len) {\n        if (str->data != NULL)\n            memset(&str->data[str->length], 0, len - str->length);\n        str->length = len;\n        return len;\n    }\n    /* This limit is sufficient to ensure (len+3)/3*4 < 2**31 */\n    if (len > LIMIT_BEFORE_EXPANSION) {\n        BUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    n = (len + 3) / 3 * 4;\n    if ((str->flags & BUF_MEM_FLAG_SECURE))\n        ret = sec_alloc_realloc(str, n);\n    else\n        ret = OPENSSL_realloc(str->data, n);\n    if (ret == NULL) {\n        BUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);\n        len = 0;\n    } else {\n        str->data = ret;\n        str->max = n;\n        memset(&str->data[str->length], 0, len - str->length);\n        str->length = len;\n    }\n    return len;\n}", "target": 1}
{"idx": 5069, "func": "AP_DECLARE(apr_size_t) ap_escape_errorlog_item(char *dest, const char *source,\n                                               apr_size_t buflen)\n{\n    unsigned char *d, *ep;\n    const unsigned char *s;\n\n    if (!source || !buflen) { /* be safe */\n        return 0;\n    }\n\n    d = (unsigned char *)dest;\n    s = (const unsigned char *)source;\n    ep = d + buflen - 1;\n\n    for (; d < ep && *s; ++s) {\n\n        if (TEST_CHAR(*s, T_ESCAPE_LOGITEM)) {\n            *d++ = '\\\\';\n            if (d >= ep) {\n                --d;\n                break;\n            }\n\n            switch(*s) {\n            case '\\b':\n                *d++ = 'b';\n                break;\n            case '\\n':\n                *d++ = 'n';\n                break;\n            case '\\r':\n                *d++ = 'r';\n                break;\n            case '\\t':\n                *d++ = 't';\n                break;\n            case '\\v':\n                *d++ = 'v';\n                break;\n            case '\\\\':\n                *d++ = *s;\n                break;\n            case '\"': /* no need for this in error log */\n                d[-1] = *s;\n                break;\n            default:\n                if (d >= ep - 2) {\n                    ep = --d; /* break the for loop as well */\n                    break;\n                }\n                c2x(*s, 'x', d);\n                d += 3;\n            }\n        }\n        else {\n            *d++ = *s;\n        }\n    }\n    *d = '\\0';\n\n    return (d - (unsigned char *)dest);\n}", "target": 0}
{"idx": 5070, "func": "static void read_len_table(uint8_t *dst, GetBitContext *gb){\n    int i, val, repeat;\n\n    for(i=0; i<256;){\n        repeat= get_bits(gb, 3);\n        val   = get_bits(gb, 5);\n        if(repeat==0)\n            repeat= get_bits(gb, 8);\n//printf(\"%d %d\\n\", val, repeat);\n        while (repeat--)\n            dst[i++] = val;\n    }\n}", "target": 1}
{"idx": 5071, "func": "static int start_lingering_close_blocking(event_conn_state_t *cs)\n{\n    apr_status_t rv;\n    struct timeout_queue *q;\n    apr_socket_t *csd = cs->pfd.desc.s;\n\n    if (ap_start_lingering_close(cs->c)) {\n        notify_suspend(cs);\n        apr_socket_close(csd);\n        ap_push_pool(worker_queue_info, cs->p);\n        return 0;\n    }\n\n#ifdef AP_DEBUG\n    {\n        rv = apr_socket_timeout_set(csd, 0);\n        AP_DEBUG_ASSERT(rv == APR_SUCCESS);\n    }\n#else\n    apr_socket_timeout_set(csd, 0);\n#endif\n\n    cs->queue_timestamp = apr_time_now();\n    /*\n     * If some module requested a shortened waiting period, only wait for\n     * 2s (SECONDS_TO_LINGER). This is useful for mitigating certain\n     * DoS attacks.\n     */\n    if (apr_table_get(cs->c->notes, \"short-lingering-close\")) {\n        q = short_linger_q;\n        cs->pub.state = CONN_STATE_LINGER_SHORT;\n    }\n    else {\n        q = linger_q;\n        cs->pub.state = CONN_STATE_LINGER_NORMAL;\n    }\n    apr_atomic_inc32(&lingering_count);\n    notify_suspend(cs);\n\n    cs->pfd.reqevents = (\n            cs->pub.sense == CONN_SENSE_WANT_WRITE ? APR_POLLOUT :\n                    APR_POLLIN) | APR_POLLHUP | APR_POLLERR;\n    cs->pub.sense = CONN_SENSE_DEFAULT;\n    apr_thread_mutex_lock(timeout_mutex);\n    TO_QUEUE_APPEND(q, cs);\n    rv = apr_pollset_add(event_pollset, &cs->pfd);\n    apr_thread_mutex_unlock(timeout_mutex);\n    if (rv != APR_SUCCESS && !APR_STATUS_IS_EEXIST(rv)) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(03092)\n                     \"start_lingering_close: apr_pollset_add failure\");\n        apr_thread_mutex_lock(timeout_mutex);\n        TO_QUEUE_REMOVE(q, cs);\n        apr_thread_mutex_unlock(timeout_mutex);\n        apr_socket_close(cs->pfd.desc.s);\n        ap_push_pool(worker_queue_info, cs->p);\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"idx": 5072, "func": "static char *\nngx_http_valid_referers(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_http_referer_conf_t  *rlcf = conf;\n\n    u_char      *p;\n    ngx_str_t   *value, uri;\n    ngx_uint_t   i;\n\n    if (rlcf->keys == NULL) {\n        rlcf->keys = ngx_pcalloc(cf->temp_pool, sizeof(ngx_hash_keys_arrays_t));\n        if (rlcf->keys == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        rlcf->keys->pool = cf->pool;\n        rlcf->keys->temp_pool = cf->pool;\n\n        if (ngx_hash_keys_array_init(rlcf->keys, NGX_HASH_SMALL) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    value = cf->args->elts;\n\n    for (i = 1; i < cf->args->nelts; i++) {\n        if (value[i].len == 0) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"invalid referer \\\"%V\\\"\", &value[i]);\n            return NGX_CONF_ERROR;\n        }\n\n        if (ngx_strcmp(value[i].data, \"none\") == 0) {\n            rlcf->no_referer = 1;\n            continue;\n        }\n\n        if (ngx_strcmp(value[i].data, \"blocked\") == 0) {\n            rlcf->blocked_referer = 1;\n            continue;\n        }\n\n        if (ngx_strcmp(value[i].data, \"server_names\") == 0) {\n            rlcf->server_names = 1;\n            continue;\n        }\n\n        if (value[i].data[0] == '~') {\n            if (ngx_http_add_regex_referer(cf, rlcf, &value[i]) != NGX_OK) {\n                return NGX_CONF_ERROR;\n            }\n\n            continue;\n        }\n\n        ngx_str_null(&uri);\n\n        p = (u_char *) ngx_strchr(value[i].data, '/');\n\n        if (p) {\n            uri.len = (value[i].data + value[i].len) - p;\n            uri.data = p;\n            value[i].len = p - value[i].data;\n        }\n\n        if (ngx_http_add_referer(cf, rlcf->keys, &value[i], &uri) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    return NGX_CONF_OK;\n}", "target": 0}
{"idx": 5073, "func": "int i2d_PKCS7(PKCS7 *a, unsigned char **pp)\n\t{\n\tM_ASN1_I2D_vars(a);\n\n\tif (a->asn1 != NULL)\n\t\t{\n\t\tif (pp == NULL)\n\t\t\treturn((int)a->length);\n\t\tmemcpy(*pp,a->asn1,(int)a->length);\n\t\t*pp+=a->length;\n\t\treturn((int)a->length);\n\t\t}\n\n\tret+=4; /* sequence, BER header plus '0 0' end padding */\n\tM_ASN1_I2D_len(a->type,i2d_ASN1_OBJECT);\n\tif (a->d.ptr != NULL)\n\t\t{\n\t\tret+=4; /* explicit tag [ 0 ] BER plus '0 0' */\n\t\tswitch (OBJ_obj2nid(a->type))\n\t\t\t{\n\t\tcase NID_pkcs7_data:\n\t\t\tM_ASN1_I2D_len(a->d.data,i2d_ASN1_OCTET_STRING);\n\t\t\tbreak;\n\t\tcase NID_pkcs7_signed:\n\t\t\tM_ASN1_I2D_len(a->d.sign,i2d_PKCS7_SIGNED);\n\t\t\tbreak;\n\t\tcase NID_pkcs7_enveloped:\n\t\t\tM_ASN1_I2D_len(a->d.enveloped,i2d_PKCS7_ENVELOPE);\n\t\t\tbreak;\n\t\tcase NID_pkcs7_signedAndEnveloped:\n\t\t\tM_ASN1_I2D_len(a->d.signed_and_enveloped,\n\t\t\t\ti2d_PKCS7_SIGN_ENVELOPE);\n\t\t\tbreak;\n\t\tcase NID_pkcs7_digest:\n\t\t\tM_ASN1_I2D_len(a->d.digest,i2d_PKCS7_DIGEST);\n\t\t\tbreak;\n\t\tcase NID_pkcs7_encrypted:\n\t\t\tM_ASN1_I2D_len(a->d.encrypted,i2d_PKCS7_ENCRYPT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tr=ret;\n\tif (pp == NULL) return(r);\n\tp= *pp;\n\tM_ASN1_I2D_INF_seq_start(V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\n\tM_ASN1_I2D_put(a->type,i2d_ASN1_OBJECT);\n\n\tif (a->d.ptr != NULL)\n\t\t{\n\t\tM_ASN1_I2D_INF_seq_start(0,V_ASN1_CONTEXT_SPECIFIC);\n\t\tswitch (OBJ_obj2nid(a->type))\n\t\t\t{\n\t\tcase NID_pkcs7_data:\n\t\t\tM_ASN1_I2D_put(a->d.data,i2d_ASN1_OCTET_STRING);\n\t\t\tbreak;\n\t\tcase NID_pkcs7_signed:\n\t\t\tM_ASN1_I2D_put(a->d.sign,i2d_PKCS7_SIGNED);\n\t\t\tbreak;\n\t\tcase NID_pkcs7_enveloped:\n\t\t\tM_ASN1_I2D_put(a->d.enveloped,i2d_PKCS7_ENVELOPE);\n\t\t\tbreak;\n\t\tcase NID_pkcs7_signedAndEnveloped:\n\t\t\tM_ASN1_I2D_put(a->d.signed_and_enveloped,\n\t\t\t\ti2d_PKCS7_SIGN_ENVELOPE);\n\t\t\tbreak;\n\t\tcase NID_pkcs7_digest:\n\t\t\tM_ASN1_I2D_put(a->d.digest,i2d_PKCS7_DIGEST);\n\t\t\tbreak;\n\t\tcase NID_pkcs7_encrypted:\n\t\t\tM_ASN1_I2D_put(a->d.encrypted,i2d_PKCS7_ENCRYPT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t\t}\n\t\tM_ASN1_I2D_INF_seq_end();\n\t\t}\n\tM_ASN1_I2D_INF_seq_end();\n\tM_ASN1_I2D_finish();\n\t}", "target": 1}
{"idx": 5074, "func": "static int encode_frame(AVCodecContext *avctx, unsigned char *buf,\n                        int buf_size, void *data)\n{\n    const AVFrame *pic = data;\n    int aligned_width = ((avctx->width + 47) / 48) * 48;\n    int stride = aligned_width * 8 / 3;\n    int h, w;\n    const uint16_t *y = (const uint16_t*)pic->data[0];\n    const uint16_t *u = (const uint16_t*)pic->data[1];\n    const uint16_t *v = (const uint16_t*)pic->data[2];\n    uint8_t *p = buf;\n    uint8_t *pdst = buf;\n\n    if (buf_size < aligned_width * avctx->height * 8 / 3) {\n        av_log(avctx, AV_LOG_ERROR, \"output buffer too small\\n\");\n        return -1;\n    }\n\n#define CLIP(v) av_clip(v, 4, 1019)\n\n#define WRITE_PIXELS(a, b, c)           \\\n    do {                                \\\n        val =   CLIP(*a++);             \\\n        val |= (CLIP(*b++) << 10) |     \\\n               (CLIP(*c++) << 20);      \\\n        bytestream_put_le32(&p, val);   \\\n    } while (0)\n\n    for (h = 0; h < avctx->height; h++) {\n        uint32_t val;\n        for (w = 0; w < avctx->width - 5; w += 6) {\n            WRITE_PIXELS(u, y, v);\n            WRITE_PIXELS(y, u, y);\n            WRITE_PIXELS(v, y, u);\n            WRITE_PIXELS(y, v, y);\n        }\n        if (w < avctx->width - 1) {\n            WRITE_PIXELS(u, y, v);\n\n            val = CLIP(*y++);\n            if (w == avctx->width - 2)\n                bytestream_put_le32(&p, val);\n            if (w < avctx->width - 3) {\n                val |= (CLIP(*u++) << 10) | (CLIP(*y++) << 20);\n                bytestream_put_le32(&p, val);\n\n                val = CLIP(*v++) | (CLIP(*y++) << 10);\n                bytestream_put_le32(&p, val);\n            }\n        }\n\n        pdst += stride;\n        memset(p, 0, pdst - p);\n        p = pdst;\n        y += pic->linesize[0] / 2 - avctx->width;\n        u += pic->linesize[1] / 2 - avctx->width / 2;\n        v += pic->linesize[2] / 2 - avctx->width / 2;\n    }\n\n    return p - buf;\n}", "target": 0}
{"idx": 5075, "func": "static long bio_ctrl(BIO *bio, int cmd, long num, void *ptr)\n\t{\n\tlong ret;\n\tstruct bio_bio_st *b = bio->ptr;\n\t\n\tassert(b != NULL);\n\n\tswitch (cmd)\n\t\t{\n\t/* specific CTRL codes */\n\n\tcase BIO_C_SET_WRITE_BUF_SIZE:\n\t\tif (b->peer)\n\t\t\t{\n\t\t\tBIOerr(BIO_F_BIO_CTRL, BIO_R_IN_USE);\n\t\t\tret = 0;\n\t\t\t}\n\t\telse if (num == 0)\n\t\t\t{\n\t\t\tBIOerr(BIO_F_BIO_CTRL, BIO_R_INVALID_ARGUMENT);\n\t\t\tret = 0;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tsize_t new_size = num;\n\n\t\t\tif (b->size != new_size)\n\t\t\t\t{\n\t\t\t\tif (b->buf) \n\t\t\t\t\t{\n\t\t\t\t\tOPENSSL_free(b->buf);\n\t\t\t\t\tb->buf = NULL;\n\t\t\t\t\t}\n\t\t\t\tb->size = new_size;\n\t\t\t\t}\n\t\t\tret = 1;\n\t\t\t}\n\t\tbreak;\n\n\tcase BIO_C_GET_WRITE_BUF_SIZE:\n\t\tnum = (long) b->size;\n\n\tcase BIO_C_MAKE_BIO_PAIR:\n\t\t{\n\t\tBIO *other_bio = ptr;\n\t\t\n\t\tif (bio_make_pair(bio, other_bio))\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t\t\n\tcase BIO_C_DESTROY_BIO_PAIR:\n\t\t/* Effects both BIOs in the pair -- call just once!\n\t\t * Or let BIO_free(bio1); BIO_free(bio2); do the job. */\n\t\tbio_destroy_pair(bio);\n\t\tret = 1;\n\t\tbreak;\n\n\tcase BIO_C_GET_WRITE_GUARANTEE:\n\t\t/* How many bytes can the caller feed to the next write\n\t\t * without having to keep any? */\n\t\tif (b->peer == NULL || b->closed)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = (long) b->size - b->len;\n\t\tbreak;\n\n\tcase BIO_C_GET_READ_REQUEST:\n\t\t/* If the peer unsuccessfully tried to read, how many bytes\n\t\t * were requested?  (As with BIO_CTRL_PENDING, that number\n\t\t * can usually be treated as boolean.) */\n\t\tret = (long) b->request;\n\t\tbreak;\n\n\tcase BIO_C_RESET_READ_REQUEST:\n\t\t/* Reset request.  (Can be useful after read attempts\n\t\t * at the other side that are meant to be non-blocking,\n\t\t * e.g. when probing SSL_read to see if any data is\n\t\t * available.) */\n\t\tb->request = 0;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase BIO_C_SHUTDOWN_WR:\n\t\t/* similar to shutdown(..., SHUT_WR) */\n\t\tb->closed = 1;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase BIO_C_NREAD0:\n\t\t/* prepare for non-copying read */\n\t\tret = (long) bio_nread0(bio, ptr);\n\t\tbreak;\n\t\t\n\tcase BIO_C_NREAD:\n\t\t/* non-copying read */\n\t\tret = (long) bio_nread(bio, ptr, (size_t) num);\n\t\tbreak;\n\t\t\n\tcase BIO_C_NWRITE0:\n\t\t/* prepare for non-copying write */\n\t\tret = (long) bio_nwrite0(bio, ptr);\n\t\tbreak;\n\n\tcase BIO_C_NWRITE:\n\t\t/* non-copying write */\n\t\tret = (long) bio_nwrite(bio, ptr, (size_t) num);\n\t\tbreak;\n\t\t\n\n\t/* standard CTRL codes follow */\n\n\tcase BIO_CTRL_RESET:\n\t\tif (b->buf != NULL)\n\t\t\t{\n\t\t\tb->len = 0;\n\t\t\tb->offset = 0;\n\t\t\t}\n\t\tret = 0;\n\t\tbreak;\t\t\n\n\tcase BIO_CTRL_GET_CLOSE:\n\t\tret = bio->shutdown;\n\t\tbreak;\n\n\tcase BIO_CTRL_SET_CLOSE:\n\t\tbio->shutdown = (int) num;\n\t\tret = 1;\n\t\tbreak;\n\n\tcase BIO_CTRL_PENDING:\n\t\tif (b->peer != NULL)\n\t\t\t{\n\t\t\tstruct bio_bio_st *peer_b = b->peer->ptr;\n\t\t\t\n\t\t\tret = (long) peer_b->len;\n\t\t\t}\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\n\tcase BIO_CTRL_WPENDING:\n\t\tif (b->buf != NULL)\n\t\t\tret = (long) b->len;\n\t\telse\n\t\t\tret = 0;\n\t\tbreak;\n\n\tcase BIO_CTRL_DUP:\n\t\t/* See BIO_dup_chain for circumstances we have to expect. */\n\t\t{\n\t\tBIO *other_bio = ptr;\n\t\tstruct bio_bio_st *other_b;\n\t\t\n\t\tassert(other_bio != NULL);\n\t\tother_b = other_bio->ptr;\n\t\tassert(other_b != NULL);\n\t\t\n\t\tassert(other_b->buf == NULL); /* other_bio is always fresh */\n\n\t\tother_b->size = b->size;\n\t\t}\n\n\t\tret = 1;\n\t\tbreak;\n\n\tcase BIO_CTRL_FLUSH:\n\t\tret = 1;\n\t\tbreak;\n\n\tcase BIO_CTRL_EOF:\n\t\t{\n\t\tBIO *other_bio = ptr;\n\t\t\n\t\tif (other_bio)\n\t\t\t{\n\t\t\tstruct bio_bio_st *other_b = other_bio->ptr;\n\t\t\t\n\t\t\tassert(other_b != NULL);\n\t\t\tret = other_b->len == 0 && other_b->closed;\n\t\t\t}\n\t\telse\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = 0;\n\t\t}\n\treturn ret;\n\t}", "target": 1}
{"idx": 5076, "func": "static void ctr_XOR(DRBG_CTR_CTX *cctx, const unsigned char *in, size_t inlen)\n{\n    size_t i, n;\n\n    if (in == NULL || inlen == 0)\n        return;\n\n    /*\n     * Any zero padding will have no effect on the result as we\n     * are XORing. So just process however much input we have.\n     */\n    n = inlen < cctx->keylen ? inlen : cctx->keylen;\n    for (i = 0; i < n; i++)\n        cctx->K[i] ^= in[i];\n    if (inlen <= cctx->keylen)\n        return;\n\n    n = inlen - cctx->keylen;\n    if (n > 16) {\n        /* Should never happen */\n        n = 16;\n    }\n    for (i = 0; i < 16; i++)\n        cctx->V[i] ^= in[i + cctx->keylen];\n}", "target": 1}
{"idx": 5077, "func": "static int decode_2(SANMVideoContext *ctx)\n{\n    int cx, cy, ret;\n\n    for (cy = 0; cy < ctx->aligned_height; cy += 8) {\n        for (cx = 0; cx < ctx->aligned_width; cx += 8) {\n            if (ret = codec2subblock(ctx, cx, cy, 8))\n                return ret;\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5078, "func": "int av_write_trailer(AVFormatContext *s)\n{\n    int ret, i;\n\n    for(;;){\n        AVPacket pkt;\n        ret= av_interleave_packet(s, &pkt, NULL, 1);\n        if(ret<0) //FIXME cleanup needed for ret<0 ?\n            goto fail;\n        if(!ret)\n            break;\n\n        ret= s->oformat->write_packet(s, &pkt);\n\n        av_free_packet(&pkt);\n\n        if(ret<0)\n            goto fail;\n        if(url_ferror(s->pb))\n            goto fail;\n    }\n\n    if(s->oformat->write_trailer)\n        ret = s->oformat->write_trailer(s);\nfail:\n    if(ret == 0)\n       ret=url_ferror(s->pb);\n    for(i=0;i<s->nb_streams;i++)\n        av_freep(&s->streams[i]->priv_data);\n    av_freep(&s->priv_data);\n    return ret;\n}", "target": 1}
{"idx": 5079, "func": "static double get_volume(CompandContext *s, double in_lin)\n{\n    CompandSegment *cs;\n    double in_log, out_log;\n    int i;\n\n    if (in_lin < s->in_min_lin)\n        return s->out_min_lin;\n\n    in_log = log(in_lin);\n\n    for (i = 1; i < s->nb_segments; i++)\n        if (in_log <= s->segments[i].x)\n            break;\n\n    cs = &s->segments[i - 1];\n    in_log -= cs->x;\n    out_log = cs->y + in_log * (cs->a * in_log + cs->b);\n\n    return exp(out_log);\n}", "target": 0}
{"idx": 5080, "func": "static void ff_eac3_decode_transform_coeffs_aht_ch(AC3DecodeContext *s, int ch)\n{\n    int bin, blk, gs;\n    int end_bap, gaq_mode;\n    GetBitContext *gbc = &s->gbc;\n    int gaq_gain[AC3_MAX_COEFS];\n\n    gaq_mode = get_bits(gbc, 2);\n    end_bap = (gaq_mode < 2) ? 12 : 17;\n\n    /* if GAQ gain is used, decode gain codes for bins with hebap between\n       8 and end_bap */\n    gs = 0;\n    if (gaq_mode == EAC3_GAQ_12 || gaq_mode == EAC3_GAQ_14) {\n        /* read 1-bit GAQ gain codes */\n        for (bin = s->start_freq[ch]; bin < s->end_freq[ch]; bin++) {\n            if (s->bap[ch][bin] > 7 && s->bap[ch][bin] < end_bap)\n                gaq_gain[gs++] = get_bits1(gbc) << (gaq_mode-1);\n        }\n    } else if (gaq_mode == EAC3_GAQ_124) {\n        /* read 1.67-bit GAQ gain codes (3 codes in 5 bits) */\n        int gc = 2;\n        for (bin = s->start_freq[ch]; bin < s->end_freq[ch]; bin++) {\n            if (s->bap[ch][bin] > 7 && s->bap[ch][bin] < 17) {\n                if (gc++ == 2) {\n                    int group_code = get_bits(gbc, 5);\n                    if (group_code > 26) {\n                        av_log(s->avctx, AV_LOG_WARNING, \"GAQ gain group code out-of-range\\n\");\n                        group_code = 26;\n                    }\n                    gaq_gain[gs++] = ff_ac3_ungroup_3_in_5_bits_tab[group_code][0];\n                    gaq_gain[gs++] = ff_ac3_ungroup_3_in_5_bits_tab[group_code][1];\n                    gaq_gain[gs++] = ff_ac3_ungroup_3_in_5_bits_tab[group_code][2];\n                    gc = 0;\n                }\n            }\n        }\n    }\n\n    gs=0;\n    for (bin = s->start_freq[ch]; bin < s->end_freq[ch]; bin++) {\n        int hebap = s->bap[ch][bin];\n        int bits = ff_eac3_bits_vs_hebap[hebap];\n        if (!hebap) {\n            /* zero-mantissa dithering */\n            for (blk = 0; blk < 6; blk++) {\n                s->pre_mantissa[ch][bin][blk] = (av_lfg_get(&s->dith_state) & 0x7FFFFF) - 0x400000;\n            }\n        } else if (hebap < 8) {\n            /* Vector Quantization */\n            int v = get_bits(gbc, bits);\n            for (blk = 0; blk < 6; blk++) {\n                s->pre_mantissa[ch][bin][blk] = ff_eac3_mantissa_vq[hebap][v][blk] << 8;\n            }\n        } else {\n            /* Gain Adaptive Quantization */\n            int gbits, log_gain;\n            if (gaq_mode != EAC3_GAQ_NO && hebap < end_bap) {\n                log_gain = gaq_gain[gs++];\n            } else {\n                log_gain = 0;\n            }\n            gbits = bits - log_gain;\n\n            for (blk = 0; blk < 6; blk++) {\n                int mant = get_sbits(gbc, gbits);\n                if (log_gain && mant == -(1 << (gbits-1))) {\n                    /* large mantissa */\n                    int b;\n                    int mbits = bits - (2 - log_gain);\n                    mant = get_sbits(gbc, mbits);\n                    mant <<= (23 - (mbits - 1));\n                    /* remap mantissa value to correct for asymmetric quantization */\n                    if (mant >= 0)\n                        b = 1 << (23 - log_gain);\n                    else\n                        b = ff_eac3_gaq_remap_2_4_b[hebap-8][log_gain-1] << 8;\n                    mant += ((ff_eac3_gaq_remap_2_4_a[hebap-8][log_gain-1] * (int64_t)mant) >> 15) + b;\n                } else {\n                    /* small mantissa, no GAQ, or Gk=1 */\n                    mant <<= 24 - bits;\n                    if (!log_gain) {\n                        /* remap mantissa value for no GAQ or Gk=1 */\n                        mant += (ff_eac3_gaq_remap_1[hebap-8] * (int64_t)mant) >> 15;\n                    }\n                }\n                s->pre_mantissa[ch][bin][blk] = mant;\n            }\n        }\n        idct6(s->pre_mantissa[ch][bin]);\n    }\n}", "target": 0}
{"idx": 5081, "func": "static int mpsub_probe(AVProbeData *p)\n{\n    const char *ptr     = p->buf;\n    const char *ptr_end = p->buf + p->buf_size;\n\n    while (ptr < ptr_end) {\n        if (!memcmp(ptr, \"FORMAT=TIME\", 11))\n            return AVPROBE_SCORE_EXTENSION;\n        if (!memcmp(ptr, \"FORMAT=\", 7))\n            return AVPROBE_SCORE_EXTENSION / 3;\n        ptr += strcspn(ptr, \"\\n\") + 1;\n    }\n    return 0;\n}", "target": 1}
{"idx": 5082, "func": "static int file_test_run(STANZA *s)\n{\n    static const FILETEST filetests[] = {\n        {\"Sum\", file_sum},\n        {\"LShift1\", file_lshift1},\n        {\"LShift\", file_lshift},\n        {\"RShift\", file_rshift},\n        {\"Square\", file_square},\n        {\"Product\", file_product},\n        {\"Quotient\", file_quotient},\n        {\"ModMul\", file_modmul},\n        {\"ModExp\", file_modexp},\n        {\"Exp\", file_exp},\n        {\"ModSqrt\", file_modsqrt},\n    };\n    int numtests = OSSL_NELEM(filetests);\n    const FILETEST *tp = filetests;\n\n    for ( ; --numtests >= 0; tp++) {\n        if (findattr(s, tp->name) != NULL)\n            return tp->func(s);\n    }\n    fprintf(stderr, \"Unknown test at %d\\n\", s->start);\n    return 0;\n}", "target": 0}
{"idx": 5083, "func": "int64_t parse_date(const char *datestr, int duration)\n{\n    const char *p;\n    int64_t t;\n    struct tm dt;\n    int i;\n    static const char * const date_fmt[] = {\n        \"%Y-%m-%d\",\n        \"%Y%m%d\",\n    };\n    static const char * const time_fmt[] = {\n        \"%H:%M:%S\",\n        \"%H%M%S\",\n    };\n    const char *q;\n    int is_utc, len;\n    char lastch;\n    int negative = 0;\n\n#undef time\n    time_t now = time(0);\n\n    len = strlen(datestr);\n    if (len > 0)\n        lastch = datestr[len - 1];\n    else\n        lastch = '\\0';\n    is_utc = (lastch == 'z' || lastch == 'Z');\n\n    memset(&dt, 0, sizeof(dt));\n\n    p = datestr;\n    q = NULL;\n    if (!duration) {\n        if (!strncasecmp(datestr, \"now\", len))\n            return (int64_t) now * 1000000;\n\n        /* parse the year-month-day part */\n        for (i = 0; i < FF_ARRAY_ELEMS(date_fmt); i++) {\n            q = small_strptime(p, date_fmt[i], &dt);\n            if (q) {\n                break;\n            }\n        }\n\n        /* if the year-month-day part is missing, then take the\n         * current year-month-day time */\n        if (!q) {\n            if (is_utc) {\n                dt = *gmtime(&now);\n            } else {\n                dt = *localtime(&now);\n            }\n            dt.tm_hour = dt.tm_min = dt.tm_sec = 0;\n        } else {\n            p = q;\n        }\n\n        if (*p == 'T' || *p == 't' || *p == ' ')\n            p++;\n\n        /* parse the hour-minute-second part */\n        for (i = 0; i < FF_ARRAY_ELEMS(time_fmt); i++) {\n            q = small_strptime(p, time_fmt[i], &dt);\n            if (q) {\n                break;\n            }\n        }\n    } else {\n        /* parse datestr as a duration */\n        if (p[0] == '-') {\n            negative = 1;\n            ++p;\n        }\n        /* parse datestr as HH:MM:SS */\n        q = small_strptime(p, time_fmt[0], &dt);\n        if (!q) {\n            /* parse datestr as S+ */\n            dt.tm_sec = strtol(p, (char **)&q, 10);\n            if (q == p)\n                /* the parsing didn't succeed */\n                return INT64_MIN;\n            dt.tm_min = 0;\n            dt.tm_hour = 0;\n        }\n    }\n\n    /* Now we have all the fields that we can get */\n    if (!q) {\n        return INT64_MIN;\n    }\n\n    if (duration) {\n        t = dt.tm_hour * 3600 + dt.tm_min * 60 + dt.tm_sec;\n    } else {\n        dt.tm_isdst = -1;       /* unknown */\n        if (is_utc) {\n            t = mktimegm(&dt);\n        } else {\n            t = mktime(&dt);\n        }\n    }\n\n    t *= 1000000;\n\n    /* parse the .m... part */\n    if (*q == '.') {\n        int val, n;\n        q++;\n        for (val = 0, n = 100000; n >= 1; n /= 10, q++) {\n            if (!isdigit(*q))\n                break;\n            val += n * (*q - '0');\n        }\n        t += val;\n    }\n    return negative ? -t : t;\n}", "target": 0}
{"idx": 5084, "func": "static void show_format(AVFormatContext *fmt_ctx)\n{\n    char val_str[128];\n    int64_t size = fmt_ctx->pb ? avio_size(fmt_ctx->pb) : -1;\n\n    probe_object_header(\"format\");\n    probe_str(\"filename\",         fmt_ctx->filename);\n    probe_int(\"nb_streams\",       fmt_ctx->nb_streams);\n    probe_str(\"format_name\",      fmt_ctx->iformat->name);\n    probe_str(\"format_long_name\", fmt_ctx->iformat->long_name);\n    probe_str(\"start_time\",\n                       time_value_string(val_str, sizeof(val_str),\n                                         fmt_ctx->start_time, &AV_TIME_BASE_Q));\n    probe_str(\"duration\",\n                       time_value_string(val_str, sizeof(val_str),\n                                         fmt_ctx->duration, &AV_TIME_BASE_Q));\n    probe_str(\"size\",\n                       size >= 0 ? value_string(val_str, sizeof(val_str),\n                                                size, unit_byte_str)\n                                  : \"unknown\");\n    probe_str(\"bit_rate\",\n                       value_string(val_str, sizeof(val_str),\n                                    fmt_ctx->bit_rate, unit_bit_per_second_str));\n\n    probe_dict(fmt_ctx->metadata, \"tags\");\n\n    probe_object_footer(\"format\");\n}", "target": 0}
{"idx": 5085, "func": "static int jacosub_probe(AVProbeData *p)\n{\n    const char *ptr     = p->buf;\n    const char *ptr_end = p->buf + p->buf_size;\n\n    if (AV_RB24(ptr) == 0xEFBBBF)\n        ptr += 3; /* skip UTF-8 BOM */\n\n    while (ptr < ptr_end) {\n        while (jss_whitespace(*ptr))\n            ptr++;\n        if (*ptr != '#' && *ptr != '\\n') {\n            if (timed_line(ptr))\n                return AVPROBE_SCORE_EXTENSION + 1;\n            return 0;\n        }\n        ptr += ff_subtitles_next_line(ptr);\n    }\n    return 0;\n}", "target": 0}
{"idx": 5086, "func": "static int RSA_eay_private_encrypt(int flen, const unsigned char *from,\n\t     unsigned char *to, RSA *rsa, int padding)\n\t{\n\tBIGNUM *f, *ret, *res;\n\tint i,j,k,num=0,r= -1;\n\tunsigned char *buf=NULL;\n\tBN_CTX *ctx=NULL;\n\tint local_blinding = 0;\n\t/* Used only if the blinding structure is shared. A non-NULL unblind\n\t * instructs rsa_blinding_convert() and rsa_blinding_invert() to store\n\t * the unblinding factor outside the blinding structure. */\n\tBIGNUM *unblind = NULL;\n\tBN_BLINDING *blinding = NULL;\n\n#ifdef OPENSSL_FIPS\n\tif(FIPS_selftest_failed())\n\t\t{\n\t\tFIPSerr(FIPS_F_RSA_EAY_PRIVATE_ENCRYPT,FIPS_R_FIPS_SELFTEST_FAILED);\n\t\tgoto err;\n\t\t}\n\n\tif (FIPS_module_mode() && !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)\n\t\t&& (BN_num_bits(rsa->n) < OPENSSL_RSA_FIPS_MIN_MODULUS_BITS))\n\t\t{\n\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT, RSA_R_KEY_SIZE_TOO_SMALL);\n\t\treturn -1;\n\t\t}\n#endif\n\n\tif ((ctx=BN_CTX_new()) == NULL) goto err;\n\tBN_CTX_start(ctx);\n\tf   = BN_CTX_get(ctx);\n\tret = BN_CTX_get(ctx);\n\tnum = BN_num_bytes(rsa->n);\n\tbuf = OPENSSL_malloc(num);\n\tif(!f || !ret || !buf)\n\t\t{\n\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tswitch (padding)\n\t\t{\n\tcase RSA_PKCS1_PADDING:\n\t\ti=RSA_padding_add_PKCS1_type_1(buf,num,from,flen);\n\t\tbreak;\n\tcase RSA_X931_PADDING:\n\t\ti=RSA_padding_add_X931(buf,num,from,flen);\n\t\tbreak;\n\tcase RSA_NO_PADDING:\n\t\ti=RSA_padding_add_none(buf,num,from,flen);\n\t\tbreak;\n\tcase RSA_SSLV23_PADDING:\n\tdefault:\n\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);\n\t\tgoto err;\n\t\t}\n\tif (i <= 0) goto err;\n\n\tif (BN_bin2bn(buf,num,f) == NULL) goto err;\n\t\n\tif (BN_ucmp(f, rsa->n) >= 0)\n\t\t{\t\n\t\t/* usually the padding functions would catch this */\n\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);\n\t\tgoto err;\n\t\t}\n\n\tif (!(rsa->flags & RSA_FLAG_NO_BLINDING))\n\t\t{\n\t\tblinding = rsa_get_blinding(rsa, &local_blinding, ctx);\n\t\tif (blinding == NULL)\n\t\t\t{\n\t\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT, ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t\n\tif (blinding != NULL)\n\t\t{\n\t\tif (!local_blinding && ((unblind = BN_CTX_get(ctx)) == NULL))\n\t\t\t{\n\t\t\tRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!rsa_blinding_convert(blinding, f, unblind, ctx))\n\t\t\tgoto err;\n\t\t}\n\n\tif ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||\n\t\t((rsa->p != NULL) &&\n\t\t(rsa->q != NULL) &&\n\t\t(rsa->dmp1 != NULL) &&\n\t\t(rsa->dmq1 != NULL) &&\n\t\t(rsa->iqmp != NULL)) )\n\t\t{ \n\t\tif (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;\n\t\t}\n\telse\n\t\t{\n\t\tBIGNUM local_d;\n\t\tBIGNUM *d = NULL;\n\t\t\n\t\tif (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))\n\t\t\t{\n\t\t\tBN_init(&local_d);\n\t\t\td = &local_d;\n\t\t\tBN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n\t\t\t}\n\t\telse\n\t\t\td= rsa->d;\n\n\t\tif (rsa->flags & RSA_FLAG_CACHE_PUBLIC)\n\t\t\tif(!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))\n\t\t\t\tgoto err;\n\n\t\tif (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,\n\t\t\t\trsa->_method_mod_n)) goto err;\n\t\t}\n\n\tif (blinding)\n\t\tif (!rsa_blinding_invert(blinding, ret, unblind, ctx))\n\t\t\tgoto err;\n\n\tif (padding == RSA_X931_PADDING)\n\t\t{\n\t\tBN_sub(f, rsa->n, ret);\n\t\tif (BN_cmp(ret, f))\n\t\t\tres = f;\n\t\telse\n\t\t\tres = ret;\n\t\t}\n\telse\n\t\tres = ret;\n\n\t/* put in leading 0 bytes if the number is less than the\n\t * length of the modulus */\n\tj=BN_num_bytes(res);\n\ti=BN_bn2bin(res,&(to[num-j]));\n\tfor (k=0; k<(num-i); k++)\n\t\tto[k]=0;\n\n\tr=num;\nerr:\n\tif (ctx != NULL)\n\t\t{\n\t\tBN_CTX_end(ctx);\n\t\tBN_CTX_free(ctx);\n\t\t}\n\tif (buf != NULL)\n\t\t{\n\t\tOPENSSL_cleanse(buf,num);\n\t\tOPENSSL_free(buf);\n\t\t}\n\treturn(r);\n\t}", "target": 0}
{"idx": 5087, "func": "static int avi_sync(AVFormatContext *s, int exit_early)\n{\n    AVIContext *avi = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int n;\n    unsigned int d[8];\n    unsigned int size;\n    int64_t i, sync;\n\nstart_sync:\n    memset(d, -1, sizeof(d));\n    for (i = sync = avio_tell(pb); !avio_feof(pb); i++) {\n        int j;\n\n        for (j = 0; j < 7; j++)\n            d[j] = d[j + 1];\n        d[7] = avio_r8(pb);\n\n        size = d[4] + (d[5] << 8) + (d[6] << 16) + (d[7] << 24);\n\n        n = get_stream_idx(d + 2);\n        ff_tlog(s, \"%X %X %X %X %X %X %X %X %\"PRId64\" %u %d\\n\",\n                d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], i, size, n);\n        if (i*(avi->io_fsize>0) + (uint64_t)size > avi->fsize || d[0] > 127)\n            continue;\n\n        // parse ix##\n        if ((d[0] == 'i' && d[1] == 'x' && n < s->nb_streams) ||\n            // parse JUNK\n            (d[0] == 'J' && d[1] == 'U' && d[2] == 'N' && d[3] == 'K') ||\n            (d[0] == 'i' && d[1] == 'd' && d[2] == 'x' && d[3] == '1') ||\n            (d[0] == 'i' && d[1] == 'n' && d[2] == 'd' && d[3] == 'x')) {\n            avio_skip(pb, size);\n            goto start_sync;\n        }\n\n        // parse stray LIST\n        if (d[0] == 'L' && d[1] == 'I' && d[2] == 'S' && d[3] == 'T') {\n            avio_skip(pb, 4);\n            goto start_sync;\n        }\n\n        n = get_stream_idx(d);\n\n        if (!((i - avi->last_pkt_pos) & 1) &&\n            get_stream_idx(d + 1) < s->nb_streams)\n            continue;\n\n        // detect ##ix chunk and skip\n        if (d[2] == 'i' && d[3] == 'x' && n < s->nb_streams) {\n            avio_skip(pb, size);\n            goto start_sync;\n        }\n\n        if (avi->dv_demux && n != 0)\n            continue;\n\n        // parse ##dc/##wb\n        if (n < s->nb_streams) {\n            AVStream *st;\n            AVIStream *ast;\n            st  = s->streams[n];\n            ast = st->priv_data;\n\n            if (!ast) {\n                av_log(s, AV_LOG_WARNING, \"Skipping foreign stream %d packet\\n\", n);\n                continue;\n            }\n\n            if (s->nb_streams >= 2) {\n                AVStream *st1   = s->streams[1];\n                AVIStream *ast1 = st1->priv_data;\n                // workaround for broken small-file-bug402.avi\n                if (   d[2] == 'w' && d[3] == 'b'\n                   && n == 0\n                   && st ->codecpar->codec_type == AVMEDIA_TYPE_VIDEO\n                   && st1->codecpar->codec_type == AVMEDIA_TYPE_AUDIO\n                   && ast->prefix == 'd'*256+'c'\n                   && (d[2]*256+d[3] == ast1->prefix || !ast1->prefix_count)\n                  ) {\n                    n   = 1;\n                    st  = st1;\n                    ast = ast1;\n                    av_log(s, AV_LOG_WARNING,\n                           \"Invalid stream + prefix combination, assuming audio.\\n\");\n                }\n            }\n\n            if (!avi->dv_demux &&\n                ((st->discard >= AVDISCARD_DEFAULT && size == 0) /* ||\n                 // FIXME: needs a little reordering\n                 (st->discard >= AVDISCARD_NONKEY &&\n                 !(pkt->flags & AV_PKT_FLAG_KEY)) */\n                || st->discard >= AVDISCARD_ALL)) {\n                if (!exit_early) {\n                    ast->frame_offset += get_duration(ast, size);\n                    avio_skip(pb, size);\n                    goto start_sync;\n                }\n            }\n\n            if (d[2] == 'p' && d[3] == 'c' && size <= 4 * 256 + 4) {\n                int k    = avio_r8(pb);\n                int last = (k + avio_r8(pb) - 1) & 0xFF;\n\n                avio_rl16(pb); // flags\n\n                // b + (g << 8) + (r << 16);\n                for (; k <= last; k++)\n                    ast->pal[k] = 0xFFU<<24 | avio_rb32(pb)>>8;\n\n                ast->has_pal = 1;\n                goto start_sync;\n            } else if (((ast->prefix_count < 5 || sync + 9 > i) &&\n                        d[2] < 128 && d[3] < 128) ||\n                       d[2] * 256 + d[3] == ast->prefix /* ||\n                       (d[2] == 'd' && d[3] == 'c') ||\n                       (d[2] == 'w' && d[3] == 'b') */) {\n                if (exit_early)\n                    return 0;\n                if (d[2] * 256 + d[3] == ast->prefix)\n                    ast->prefix_count++;\n                else {\n                    ast->prefix       = d[2] * 256 + d[3];\n                    ast->prefix_count = 0;\n                }\n\n                avi->stream_index = n;\n                ast->packet_size  = size + 8;\n                ast->remaining    = size;\n\n                if (size) {\n                    uint64_t pos = avio_tell(pb) - 8;\n                    if (!st->index_entries || !st->nb_index_entries ||\n                        st->index_entries[st->nb_index_entries - 1].pos < pos) {\n                        av_add_index_entry(st, pos, ast->frame_offset, size,\n                                           0, AVINDEX_KEYFRAME);\n                    }\n                }\n                return 0;\n            }\n        }\n    }\n\n    if (pb->error)\n        return pb->error;\n    return AVERROR_EOF;\n}", "target": 1}
{"idx": 5088, "func": "int tls1_get_server_supplemental_data(SSL *s)\n\t{\n\tint al = 0;\n\tint ok;\n\tlong n;\n\tconst unsigned char *p, *d;\n\tunsigned short supp_data_entry_type = 0;\n\tunsigned long supp_data_entry_len = 0;\n\tunsigned long supp_data_len = 0;\n\tsize_t i;\n\tint cb_retval = 0;\n\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_CR_SUPPLEMENTAL_DATA_A,\n\t\tSSL3_ST_CR_SUPPLEMENTAL_DATA_B,\n\t\tSSL3_MT_SUPPLEMENTAL_DATA,\n\t\t/* use default limit */\n\t\tTLSEXT_MAXLEN_supplemental_data,\n\t\t&ok);\n\n\tif (!ok) return((int)n);\n\n\tp = (unsigned char *)s->init_msg;\n\td = p;\n\t/* The message cannot be empty */\n\tif (n < 3)\n\t\t{\n\t\tal = SSL_AD_DECODE_ERROR;\n\t\tSSLerr(SSL_F_TLS1_GET_SERVER_SUPPLEMENTAL_DATA,SSL_R_LENGTH_MISMATCH);\n\t\tgoto f_err;\n\t\t}\n\tn2l3(p, supp_data_len);\n\twhile (p<d+supp_data_len)\n\t\t{\n\t\tn2s(p, supp_data_entry_type);\n\t\tn2s(p, supp_data_entry_len);\n\t\t//if there is a callback for this supp data type, send it\n\t\tfor (i=0; i < s->ctx->cli_supp_data_records_count; i++)\n\t\t\t{\n\t\t\tif (s->ctx->cli_supp_data_records[i].supp_data_type == supp_data_entry_type && s->ctx->cli_supp_data_records[i].fn1)\n\t\t\t\t{\n\t\t\t\tcb_retval = s->ctx->cli_supp_data_records[i].fn1(s, supp_data_entry_type, p, supp_data_entry_len, &al, s->ctx->cli_supp_data_records[i].arg);\n\t\t\t\tif (cb_retval == 0)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_TLS1_GET_SERVER_SUPPLEMENTAL_DATA, ERR_R_SSL_LIB);\n\t\t\t\t\tgoto f_err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tp+=supp_data_entry_len;\n\t\t}\n\treturn 1;\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\treturn -1;\n\t}", "target": 0}
{"idx": 5089, "func": "int BN_bn2bin(const BIGNUM *a, unsigned char *to)\n\t{\n\tint n,i;\n\tBN_ULONG l;\n\n\tn=i=BN_num_bytes(a);\n\twhile (i-- > 0)\n\t\t{\n\t\tl=a->d[i/BN_BYTES];\n\t\t*(to++)=(unsigned char)(l>>(8*(i%BN_BYTES)))&0xff;\n\t\t}\n\treturn(n);\n\t}", "target": 1}
{"idx": 5090, "func": "static int64_t get_pts(const char **buf, int *duration,\n                       int32_t *x1, int32_t *y1, int32_t *x2, int32_t *y2)\n{\n    int i;\n\n    for (i=0; i<2; i++) {\n        int hh1, mm1, ss1, ms1;\n        int hh2, mm2, ss2, ms2;\n        if (sscanf(*buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\"\n                   \"%*[ ]X1:%u X2:%u Y1:%u Y2:%u\",\n                   &hh1, &mm1, &ss1, &ms1,\n                   &hh2, &mm2, &ss2, &ms2,\n                   x1, x2, y1, y2) >= 8) {\n            int64_t start = (hh1*3600LL + mm1*60LL + ss1) * 1000LL + ms1;\n            int64_t end   = (hh2*3600LL + mm2*60LL + ss2) * 1000LL + ms2;\n            *duration = end - start;\n            *buf += strcspn(*buf, \"\\n\") + 1;\n            return start;\n        }\n        *buf += strcspn(*buf, \"\\n\") + 1;\n    }\n    return AV_NOPTS_VALUE;\n}", "target": 0}
{"idx": 5091, "func": "void rand_fork(void)\n{\n    rand_fork_count++;\n}", "target": 1}
{"idx": 5092, "func": "static int decode_hybrid(const uint8_t *sptr, const uint8_t *sptr_end, uint8_t *dptr, int dx, int dy,\n                         int h, int w, int stride, const uint32_t *pal)\n{\n    int x, y;\n    const uint8_t *orig_src = sptr;\n\n    for (y = dx + h; y > dx; y--) {\n        uint8_t *dst = dptr + (y * stride) + dy * 3;\n        for (x = 0; x < w; x++) {\n            if (sptr >= sptr_end)\n                return AVERROR_INVALIDDATA;\n            if (*sptr & 0x80) {\n                /* 15-bit color */\n                unsigned c = AV_RB16(sptr) & ~0x8000;\n                unsigned b =  c        & 0x1F;\n                unsigned g = (c >>  5) & 0x1F;\n                unsigned r =  c >> 10;\n                /* 000aaabb -> aaabbaaa  */\n                *dst++ = (b << 3) | (b >> 2);\n                *dst++ = (g << 3) | (g >> 2);\n                *dst++ = (r << 3) | (r >> 2);\n                sptr += 2;\n            } else {\n                /* palette index */\n                uint32_t c = pal[*sptr++];\n                bytestream_put_le24(&dst, c);\n            }\n        }\n    }\n    return sptr - orig_src;\n}", "target": 0}
{"idx": 5093, "func": "char *av_strdup(const char *s)\n{\n    char *ptr= NULL;\n    if(s){\n        int len = strlen(s) + 1;\n        ptr = av_malloc(len);\n        if (ptr)\n            memcpy(ptr, s, len);\n    }\n    return ptr;\n}", "target": 1}
{"idx": 5094, "func": "static int decode_hextile(VmncContext *c, uint8_t* dst, GetByteContext *gb,\n                          int w, int h, int stride)\n{\n    int i, j, k;\n    int bg = 0, fg = 0, rects, color, flags, xy, wh;\n    const int bpp = c->bpp2;\n    uint8_t *dst2;\n    int bw = 16, bh = 16;\n\n    for (j = 0; j < h; j += 16) {\n        dst2 = dst;\n        bw   = 16;\n        if (j + 16 > h)\n            bh = h - j;\n        for (i = 0; i < w; i += 16, dst2 += 16 * bpp) {\n            if (bytestream2_get_bytes_left(gb) <= 0) {\n                av_log(c->avctx, AV_LOG_ERROR, \"Premature end of data!\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            if (i + 16 > w)\n                bw = w - i;\n            flags = bytestream2_get_byte(gb);\n            if (flags & HT_RAW) {\n                if (bytestream2_get_bytes_left(gb) < bw * bh * bpp) {\n                    av_log(c->avctx, AV_LOG_ERROR, \"Premature end of data!\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                paint_raw(dst2, bw, bh, gb, bpp, c->bigendian, stride);\n            } else {\n                if (flags & HT_BKG)\n                    bg = vmnc_get_pixel(gb, bpp, c->bigendian);\n                if (flags & HT_FG)\n                    fg = vmnc_get_pixel(gb, bpp, c->bigendian);\n                rects = 0;\n                if (flags & HT_SUB)\n                    rects = bytestream2_get_byte(gb);\n                color = !!(flags & HT_CLR);\n\n                paint_rect(dst2, 0, 0, bw, bh, bg, bpp, stride);\n\n                if (bytestream2_get_bytes_left(gb) < rects * (color * bpp + 2)) {\n                    av_log(c->avctx, AV_LOG_ERROR, \"Premature end of data!\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                for (k = 0; k < rects; k++) {\n                    int rect_x, rect_y, rect_w, rect_h;\n                    if (color)\n                        fg = vmnc_get_pixel(gb, bpp, c->bigendian);\n                    xy = bytestream2_get_byte(gb);\n                    wh = bytestream2_get_byte(gb);\n\n                    rect_x = xy >> 4;\n                    rect_y = xy & 0xF;\n                    rect_w = (wh >> 4) + 1;\n                    rect_h = (wh & 0xF) + 1;\n\n                    if (rect_x + rect_w > bw || rect_y + rect_h > bh) {\n                        av_log(c->avctx, AV_LOG_ERROR, \"Invalid subrect\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    paint_rect(dst2, rect_x, rect_y,\n                               rect_w, rect_h, fg, bpp, stride);\n                }\n            }\n        }\n        dst += stride * 16;\n    }\n    return 0;\n}", "target": 0}
{"idx": 5095, "func": "AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb)\n{\n    char *last_field = NULL;\n    apr_size_t last_len = 0;\n    apr_size_t alloc_len = 0;\n    char *field;\n    char *value;\n    apr_size_t len;\n    int fields_read = 0;\n    char *tmp_field;\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n\n    /*\n     * Read header lines until we get the empty separator line, a read error,\n     * the connection closes (EOF), reach the server limit, or we timeout.\n     */\n    while(1) {\n        apr_status_t rv;\n\n        field = NULL;\n        rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2,\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_TIMEUP(rv)) {\n                r->status = HTTP_REQUEST_TIME_OUT;\n            }\n            else {\n                r->status = HTTP_BAD_REQUEST;\n            }\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the buffer before\n             * finding the end-of-line.  This is only going to happen if it\n             * exceeds the configured limit for a field size.\n             */\n            if (rv == APR_ENOSPC) {\n                apr_table_setn(r->notes, \"error-notes\",\n                               \"Size of a request header field \"\n                               \"exceeds server limit.\");\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00561)\n                              \"Request header exceeds LimitRequestFieldSize%s\"\n                              \"%.*s\",\n                              (field && *field) ? \": \" : \"\",\n                              (field) ? field_name_len(field) : 0,\n                              (field) ? field : \"\");\n            }\n            return;\n        }\n\n        if (strict && strpbrk(field, \"\\n\\v\\f\\r\")) {\n            r->status = HTTP_BAD_REQUEST;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03451)\n                          \"Request header line presented bad whitespace \"\n                          \"(disallowed by StrictWhitespace)\");\n            return;\n        }\n        else {\n            /* Ensure no unusual whitespace is present in the resulting\n             * header field input line, even in unsafe mode, by replacing\n             * bad whitespace with SP before collapsing whitespace\n             */\n            char *ll = field;\n            while ((ll = strpbrk(ll, \"\\n\\v\\f\\r\")))\n                *(ll++) = ' ';\n        }\n\n        /* For all header values, and all obs-fold lines, the presence of\n         * additional whitespace is a no-op, so collapse trailing whitespace\n         * to save buffer allocation and optimize copy operations.\n         * Do not remove the last single whitespace under any condition.\n         */\n        while (len > 1 && (field[len-1] == '\\t' || field[len-1] == ' ')) {\n            field[--len] = '\\0';\n        } \n\n        if (*field == '\\t' || *field == ' ') {\n\n            /* Append any newly-read obs-fold line onto the preceding\n             * last_field line we are processing\n             */\n            apr_size_t fold_len;\n\n            if (last_field == NULL) {\n                r->status = HTTP_BAD_REQUEST;\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03442)\n                              \"Line folding encountered before first\"\n                              \" header line\");\n                return;\n            }\n\n            if (field[1] == '\\0') {\n                r->status = HTTP_BAD_REQUEST;\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03443)\n                              \"Empty folded line encountered\");\n                return;\n            }\n\n            /* Leading whitespace on an obs-fold line can be\n             * similarly discarded */\n            while (field[1] == '\\t' || field[1] == ' ') {\n                ++field; --len;\n            }\n\n            /* This line is a continuation of the preceding line(s),\n             * so append it to the line that we've set aside.\n             * Note: this uses a power-of-two allocator to avoid\n             * doing O(n) allocs and using O(n^2) space for\n             * continuations that span many many lines.\n             */\n            fold_len = last_len + len + 1; /* trailing null */\n\n            if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {\n                r->status = HTTP_BAD_REQUEST;\n                /* report what we have accumulated so far before the\n                 * overflow (last_field) as the field with the problem\n                 */\n                apr_table_setn(r->notes, \"error-notes\",\n                               \"Size of a request header field \"\n                               \"exceeds server limit.\");\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00562)\n                              \"Request header exceeds LimitRequestFieldSize \"\n                              \"after folding: %.*s\",\n                              field_name_len(last_field), last_field);\n                return;\n            }\n\n            if (fold_len > alloc_len) {\n                char *fold_buf;\n                alloc_len += alloc_len;\n                if (fold_len > alloc_len) {\n                    alloc_len = fold_len;\n                }\n                fold_buf = (char *)apr_palloc(r->pool, alloc_len);\n                memcpy(fold_buf, last_field, last_len);\n                last_field = fold_buf;\n            }\n            memcpy(last_field + last_len, field, len +1); /* +1 for nul */\n            /* Replace obs-fold w/ SP per RFC 7230 3.2.4 */\n            last_field[last_len] = ' ';\n            last_len += len;\n\n            /* We've appended this obs-fold line to last_len, proceed to\n             * read the next input line\n             */\n            continue;\n        }\n        else if (last_field != NULL) {\n\n            /* Process the previous last_field header line with all obs-folded\n             * segments already concatinated (this is not operating on the\n             * most recently read input line).\n             */\n\n            if (r->server->limit_req_fields\n                    && (++fields_read > r->server->limit_req_fields)) {\n                r->status = HTTP_BAD_REQUEST;\n                apr_table_setn(r->notes, \"error-notes\",\n                               \"The number of request header fields \"\n                               \"exceeds this server's limit.\");\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00563)\n                              \"Number of request headers exceeds \"\n                              \"LimitRequestFields\");\n                return;\n            }\n\n            if (!strict)\n            {\n                /* Not Strict ('Unsafe' mode), using the legacy parser */\n\n                if (!(value = strchr(last_field, ':'))) { /* Find ':' or */\n                    r->status = HTTP_BAD_REQUEST;   /* abort bad request */\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00564)\n                                  \"Request header field is missing ':' \"\n                                  \"separator: %.*s\", (int)LOG_NAME_MAX_LEN,\n                                  last_field);\n                    return;\n                }\n\n                /* last character of field-name */\n                tmp_field = value - (value > last_field ? 1 : 0);\n\n                *value++ = '\\0'; /* NUL-terminate at colon */\n\n                if (strict && strpbrk(last_field, \" \\t\")) {\n                    r->status = HTTP_BAD_REQUEST;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03452)\n                                  \"Request header field name with whitespace \"\n                                  \"(disallowed by StrictWhitespace)\");\n                    return;\n                }\n\n                while (*value == ' ' || *value == '\\t') {\n                     ++value;            /* Skip to start of value   */\n                }\n\n                /* Strip LWS after field-name: */\n                while (tmp_field > last_field\n                           && (*tmp_field == ' ' || *tmp_field == '\\t')) {\n                    *(tmp_field--) = '\\0';\n                }\n\n                if (tmp_field == last_field) {\n                    r->status = HTTP_BAD_REQUEST;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03453)\n                                  \"Request header field name was empty\");\n                    return;\n                }\n            }\n            else /* Using strict RFC7230 parsing */\n            {\n                /* Ensure valid token chars before ':' per RFC 7230 3.2.4 */\n                value = (char *)ap_scan_http_token(last_field);\n                if ((value == last_field) || *value != ':') {\n                    r->status = HTTP_BAD_REQUEST;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02426)\n                                  \"Request header field name is malformed: \"\n                                  \"%.*s\", (int)LOG_NAME_MAX_LEN, last_field);\n                    return;\n                }\n\n                *value++ = '\\0'; /* NUL-terminate last_field name at ':' */\n\n                while (*value == ' ' || *value == '\\t') {\n                    ++value;     /* Skip LWS of value */\n                }\n\n                /* Find invalid, non-HT ctrl char, or the trailing NULL */\n                tmp_field = (char *)ap_scan_http_field_content(value);\n\n                /* Reject value for all garbage input (CTRLs excluding HT)\n                 * e.g. only VCHAR / SP / HT / obs-text are allowed per\n                 * RFC7230 3.2.6 - leave all more explicit rule enforcement\n                 * for specific header handler logic later in the cycle\n                 */\n                if (*tmp_field != '\\0') {\n                    r->status = HTTP_BAD_REQUEST;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02427)\n                                  \"Request header value is malformed: \"\n                                  \"%.*s\", (int)LOG_NAME_MAX_LEN, value);\n                    return;\n                }\n            }\n\n            apr_table_addn(r->headers_in, last_field, value);\n\n            /* This last_field header is now stored in headers_in,\n             * resume processing of the current input line.\n             */\n        }\n\n        /* Found the terminating empty end-of-headers line, stop. */\n        if (len == 0) {\n            break;\n        }\n\n        /* Keep track of this new header line so that we can extend it across\n         * any obs-fold or parse it on the next loop iteration. We referenced\n         * our previously allocated buffer in r->headers_in,\n         * so allocate a fresh buffer if required.\n         */\n        alloc_len = 0;\n        last_field = field;\n        last_len = len;\n    }\n\n    /* Combine multiple message-header fields with the same\n     * field-name, following RFC 2616, 4.2.\n     */\n    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);\n\n    /* enforce LimitRequestFieldSize for merged headers */\n    apr_table_do(table_do_fn_check_lengths, r, r->headers_in, NULL);\n}", "target": 0}
{"idx": 5096, "func": "int BLAKE2s_Update(BLAKE2S_CTX *c, const void *data, size_t datalen)\n{\n    const uint8_t *in = data;\n    size_t fill;\n\n    while(datalen > 0) {\n        fill = sizeof(c->buf) - c->buflen;\n        /* Must be >, not >=, so that last block can be hashed differently */\n        if(datalen > fill) {\n            memcpy(c->buf + c->buflen, in, fill); /* Fill buffer */\n            blake2s_increment_counter(c, BLAKE2S_BLOCKBYTES);\n            blake2s_compress(c, c->buf); /* Compress */\n            c->buflen = 0;\n            in += fill;\n            datalen -= fill;\n        } else { /* datalen <= fill */\n            memcpy(c->buf + c->buflen, in, datalen);\n            c->buflen += datalen; /* Be lazy, do not compress */\n            return 1;\n        }\n    }\n\n    return 1;\n}", "target": 0}
{"idx": 5097, "func": "static unsigned int\nfixup_vorbis_headers(AVFormatContext * as, struct oggvorbis_private *priv,\n                     uint8_t **buf)\n{\n    int i,offset, len, buf_len;\n    unsigned char *ptr;\n\n    len = priv->len[0] + priv->len[1] + priv->len[2];\n    buf_len = len + len/255 + 64;\n    ptr = *buf = av_realloc(NULL, buf_len);\n    memset(*buf, '\\0', buf_len);\n\n    ptr[0] = 2;\n    offset = 1;\n    offset += av_xiphlacing(&ptr[offset], priv->len[0]);\n    offset += av_xiphlacing(&ptr[offset], priv->len[1]);\n    for (i = 0; i < 3; i++) {\n        memcpy(&ptr[offset], priv->packet[i], priv->len[i]);\n        offset += priv->len[i];\n        av_freep(&priv->packet[i]);\n    }\n    *buf = av_realloc(*buf, offset + FF_INPUT_BUFFER_PADDING_SIZE);\n    return offset;\n}", "target": 1}
{"idx": 5098, "func": "CERT *ssl_cert_new(void)\n\t{\n\tCERT *ret;\n\n\tret=(CERT *)OPENSSL_malloc(sizeof(CERT));\n\tif (ret == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_CERT_NEW,ERR_R_MALLOC_FAILURE);\n\t\treturn(NULL);\n\t\t}\n\tmemset(ret,0,sizeof(CERT));\n\n\tret->key= &(ret->pkeys[SSL_PKEY_RSA_ENC]);\n\tret->references=1;\n\tssl_cert_set_default_md(ret);\n\treturn(ret);\n\t}", "target": 1}
{"idx": 5099, "func": "SSL_CIPHER *ssl3_choose_cipher(SSL *s, STACK_OF(SSL_CIPHER) *clnt,\n\t     STACK_OF(SSL_CIPHER) *srvr)\n\t{\n\tSSL_CIPHER *c,*ret=NULL;\n\tSTACK_OF(SSL_CIPHER) *prio, *allow;\n\tint i,ii,ok;\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_EC)\n\tunsigned int j;\n\tint ec_ok, ec_nid;\n\tunsigned char ec_search1 = 0, ec_search2 = 0;\n#endif\n\tCERT *cert;\n\tunsigned long alg_k,alg_a,mask_k,mask_a,emask_k,emask_a;\n\n\t/* Let's see which ciphers we can support */\n\tcert=s->cert;\n\n#if 0\n\t/* Do not set the compare functions, because this may lead to a\n\t * reordering by \"id\". We want to keep the original ordering.\n\t * We may pay a price in performance during sk_SSL_CIPHER_find(),\n\t * but would have to pay with the price of sk_SSL_CIPHER_dup().\n\t */\n\tsk_SSL_CIPHER_set_cmp_func(srvr, ssl_cipher_ptr_id_cmp);\n\tsk_SSL_CIPHER_set_cmp_func(clnt, ssl_cipher_ptr_id_cmp);\n#endif\n\n#ifdef CIPHER_DEBUG\n\tprintf(\"Server has %d from %p:\\n\", sk_SSL_CIPHER_num(srvr), (void *)srvr);\n\tfor(i=0 ; i < sk_SSL_CIPHER_num(srvr) ; ++i)\n\t\t{\n\t\tc=sk_SSL_CIPHER_value(srvr,i);\n\t\tprintf(\"%p:%s\\n\",(void *)c,c->name);\n\t\t}\n\tprintf(\"Client sent %d from %p:\\n\", sk_SSL_CIPHER_num(clnt), (void *)clnt);\n\tfor(i=0 ; i < sk_SSL_CIPHER_num(clnt) ; ++i)\n\t    {\n\t    c=sk_SSL_CIPHER_value(clnt,i);\n\t    printf(\"%p:%s\\n\",(void *)c,c->name);\n\t    }\n#endif\n\n\tif (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE)\n\t\t{\n\t\tprio = srvr;\n\t\tallow = clnt;\n\t\t}\n\telse\n\t\t{\n\t\tprio = clnt;\n\t\tallow = srvr;\n\t\t}\n\n\tfor (i=0; i<sk_SSL_CIPHER_num(prio); i++)\n\t\t{\n\t\tc=sk_SSL_CIPHER_value(prio,i);\n\n\t\t/* Skip TLS v1.2 only ciphersuites if lower than v1.2 */\n\t\tif ((c->algorithm_ssl & SSL_TLSV1_2) && \n\t\t\t(TLS1_get_version(s) < TLS1_2_VERSION))\n\t\t\tcontinue;\n\n\t\tssl_set_cert_masks(cert,c);\n\t\tmask_k = cert->mask_k;\n\t\tmask_a = cert->mask_a;\n\t\temask_k = cert->export_mask_k;\n\t\temask_a = cert->export_mask_a;\n#ifndef OPENSSL_NO_SRP\n\t\tmask_k=cert->mask_k | s->srp_ctx.srp_Mask;\n\t\temask_k=cert->export_mask_k | s->srp_ctx.srp_Mask;\n#endif\n\t\t\t\n#ifdef KSSL_DEBUG\n/*\t\tprintf(\"ssl3_choose_cipher %d alg= %lx\\n\", i,c->algorithms);*/\n#endif    /* KSSL_DEBUG */\n\n\t\talg_k=c->algorithm_mkey;\n\t\talg_a=c->algorithm_auth;\n\n#ifndef OPENSSL_NO_KRB5\n\t\tif (alg_k & SSL_kKRB5)\n\t\t\t{\n\t\t\tif ( !kssl_keytab_is_available(s->kssl_ctx) )\n\t\t\t    continue;\n\t\t\t}\n#endif /* OPENSSL_NO_KRB5 */\n#ifndef OPENSSL_NO_PSK\n\t\t/* with PSK there must be server callback set */\n\t\tif ((alg_k & SSL_kPSK) && s->psk_server_callback == NULL)\n\t\t\tcontinue;\n#endif /* OPENSSL_NO_PSK */\n\n\t\tif (SSL_C_IS_EXPORT(c))\n\t\t\t{\n\t\t\tok = (alg_k & emask_k) && (alg_a & emask_a);\n#ifdef CIPHER_DEBUG\n\t\t\tprintf(\"%d:[%08lX:%08lX:%08lX:%08lX]%p:%s (export)\\n\",ok,alg_k,alg_a,emask_k,emask_a,\n\t\t\t       (void *)c,c->name);\n#endif\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tok = (alg_k & mask_k) && (alg_a & mask_a);\n#ifdef CIPHER_DEBUG\n\t\t\tprintf(\"%d:[%08lX:%08lX:%08lX:%08lX]%p:%s\\n\",ok,alg_k,alg_a,mask_k,mask_a,(void *)c,\n\t\t\t       c->name);\n#endif\n\t\t\t}\n\n#ifndef OPENSSL_NO_TLSEXT\n#ifndef OPENSSL_NO_EC\n\t\tif (\n\t\t\t/* if we are considering an ECC cipher suite that uses our certificate */\n\t\t\t(alg_a & SSL_aECDSA || alg_a & SSL_aECDH)\n\t\t\t/* and we have an ECC certificate */\n\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].x509 != NULL)\n\t\t\t/* and the client specified a Supported Point Formats extension */\n\t\t\t&& ((s->session->tlsext_ecpointformatlist_length > 0) && (s->session->tlsext_ecpointformatlist != NULL))\n\t\t\t/* and our certificate's point is compressed */\n\t\t\t&& (\n\t\t\t\t(s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info->key != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info->key->public_key != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info->key->public_key->data != NULL)\n\t\t\t\t&& (\n\t\t\t\t\t(*(s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info->key->public_key->data) == POINT_CONVERSION_COMPRESSED)\n\t\t\t\t\t|| (*(s->cert->pkeys[SSL_PKEY_ECC].x509->cert_info->key->public_key->data) == POINT_CONVERSION_COMPRESSED + 1)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t)\n\t\t\t{\n\t\t\tec_ok = 0;\n\t\t\t/* if our certificate's curve is over a field type that the client does not support\n\t\t\t * then do not allow this cipher suite to be negotiated */\n\t\t\tif (\n\t\t\t\t(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth != NULL)\n\t\t\t\t&& (EC_METHOD_get_field_type(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth) == NID_X9_62_prime_field)\n\t\t\t)\n\t\t\t\t{\n\t\t\t\tfor (j = 0; j < s->session->tlsext_ecpointformatlist_length; j++)\n\t\t\t\t\t{\n\t\t\t\t\tif (s->session->tlsext_ecpointformatlist[j] == TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_ok = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if (EC_METHOD_get_field_type(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth) == NID_X9_62_characteristic_two_field)\n\t\t\t\t{\n\t\t\t\tfor (j = 0; j < s->session->tlsext_ecpointformatlist_length; j++)\n\t\t\t\t\t{\n\t\t\t\t\tif (s->session->tlsext_ecpointformatlist[j] == TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_ok = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tok = ok && ec_ok;\n\t\t\t}\n\t\tif (\n\t\t\t/* if we are considering an ECC cipher suite that uses our certificate */\n\t\t\t(alg_a & SSL_aECDSA || alg_a & SSL_aECDH)\n\t\t\t/* and we have an ECC certificate */\n\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].x509 != NULL)\n\t\t\t/* and the client specified an EllipticCurves extension */\n\t\t\t&& ((s->session->tlsext_ellipticcurvelist_length > 0) && (s->session->tlsext_ellipticcurvelist != NULL))\n\t\t)\n\t\t\t{\n\t\t\tec_ok = 0;\n\t\t\tif (\n\t\t\t\t(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec != NULL)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group != NULL)\n\t\t\t)\n\t\t\t\t{\n\t\t\t\tec_nid = EC_GROUP_get_curve_name(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group);\n\t\t\t\tif ((ec_nid == 0)\n\t\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth != NULL)\n\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\tif (EC_METHOD_get_field_type(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth) == NID_X9_62_prime_field)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_search1 = 0xFF;\n\t\t\t\t\t\tec_search2 = 0x01;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (EC_METHOD_get_field_type(s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec->group->meth) == NID_X9_62_characteristic_two_field)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_search1 = 0xFF;\n\t\t\t\t\t\tec_search2 = 0x02;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tec_search1 = 0x00;\n\t\t\t\t\tec_search2 = tls1_ec_nid2curve_id(ec_nid);\n\t\t\t\t\t}\n\t\t\t\tif ((ec_search1 != 0) || (ec_search2 != 0))\n\t\t\t\t\t{\n\t\t\t\t\tfor (j = 0; j < s->session->tlsext_ellipticcurvelist_length / 2; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif ((s->session->tlsext_ellipticcurvelist[2*j] == ec_search1) && (s->session->tlsext_ellipticcurvelist[2*j+1] == ec_search2))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tec_ok = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tok = ok && ec_ok;\n\t\t\t}\n\t\tif (\n\t\t\t/* if we are considering an ECC cipher suite that uses an ephemeral EC key */\n\t\t\t(alg_k & SSL_kEECDH)\n\t\t\t/* and we have an ephemeral EC key */\n\t\t\t&& (s->cert->ecdh_tmp != NULL)\n\t\t\t/* and the client specified an EllipticCurves extension */\n\t\t\t&& ((s->session->tlsext_ellipticcurvelist_length > 0) && (s->session->tlsext_ellipticcurvelist != NULL))\n\t\t)\n\t\t\t{\n\t\t\tec_ok = 0;\n\t\t\tif (s->cert->ecdh_tmp->group != NULL)\n\t\t\t\t{\n\t\t\t\tec_nid = EC_GROUP_get_curve_name(s->cert->ecdh_tmp->group);\n\t\t\t\tif ((ec_nid == 0)\n\t\t\t\t\t&& (s->cert->ecdh_tmp->group->meth != NULL)\n\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\tif (EC_METHOD_get_field_type(s->cert->ecdh_tmp->group->meth) == NID_X9_62_prime_field)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_search1 = 0xFF;\n\t\t\t\t\t\tec_search2 = 0x01;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (EC_METHOD_get_field_type(s->cert->ecdh_tmp->group->meth) == NID_X9_62_characteristic_two_field)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tec_search1 = 0xFF;\n\t\t\t\t\t\tec_search2 = 0x02;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tec_search1 = 0x00;\n\t\t\t\t\tec_search2 = tls1_ec_nid2curve_id(ec_nid);\n\t\t\t\t\t}\n\t\t\t\tif ((ec_search1 != 0) || (ec_search2 != 0))\n\t\t\t\t\t{\n\t\t\t\t\tfor (j = 0; j < s->session->tlsext_ellipticcurvelist_length / 2; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif ((s->session->tlsext_ellipticcurvelist[2*j] == ec_search1) && (s->session->tlsext_ellipticcurvelist[2*j+1] == ec_search2))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tec_ok = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tok = ok && ec_ok;\n\t\t\t}\n#endif /* OPENSSL_NO_EC */\n#endif /* OPENSSL_NO_TLSEXT */\n\n\t\tif (!ok) continue;\n\t\tii=sk_SSL_CIPHER_find(allow,c);\n\t\tif (ii >= 0)\n\t\t\t{\n\t\t\tret=sk_SSL_CIPHER_value(allow,ii);\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\treturn(ret);\n\t}", "target": 0}
{"idx": 5100, "func": "static int ape_tag_read_field(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    uint8_t key[1024], *value;\n    uint32_t size, flags;\n    int i, c;\n\n    size = avio_rl32(pb);  /* field size */\n    flags = avio_rl32(pb); /* field flags */\n    for (i = 0; i < sizeof(key) - 1; i++) {\n        c = avio_r8(pb);\n        if (c < 0x20 || c > 0x7E)\n            break;\n        else\n            key[i] = c;\n    }\n    key[i] = 0;\n    if (c != 0) {\n        av_log(s, AV_LOG_WARNING, \"Invalid APE tag key '%s'.\\n\", key);\n        return -1;\n    }\n    if (size > INT32_MAX - FF_INPUT_BUFFER_PADDING_SIZE) {\n        av_log(s, AV_LOG_ERROR, \"APE tag size too large.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (flags & APE_TAG_FLAG_IS_BINARY) {\n        uint8_t filename[1024];\n        enum AVCodecID id;\n        int ret;\n        AVStream *st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        ret = avio_get_str(pb, size, filename, sizeof(filename));\n        if (ret < 0)\n            return ret;\n        if (size <= ret) {\n            av_log(s, AV_LOG_WARNING, \"Skipping binary tag '%s'.\\n\", key);\n            return 0;\n        }\n        size -= ret;\n\n        av_dict_set(&st->metadata, key, filename, 0);\n\n        if ((id = ff_guess_image2_codec(filename)) != AV_CODEC_ID_NONE) {\n            AVPacket pkt;\n            int ret;\n\n            ret = av_get_packet(s->pb, &pkt, size);\n            if (ret < 0) {\n                av_log(s, AV_LOG_ERROR, \"Error reading cover art.\\n\");\n                return ret;\n            }\n\n            st->disposition      |= AV_DISPOSITION_ATTACHED_PIC;\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n            st->codec->codec_id   = id;\n\n            st->attached_pic              = pkt;\n            st->attached_pic.stream_index = st->index;\n            st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n        } else {\n            if (ff_get_extradata(st->codec, s->pb, size) < 0)\n                return AVERROR(ENOMEM);\n            st->codec->codec_type = AVMEDIA_TYPE_ATTACHMENT;\n        }\n    } else {\n        value = av_malloc(size+1);\n        if (!value)\n            return AVERROR(ENOMEM);\n        c = avio_read(pb, value, size);\n        if (c < 0) {\n            av_free(value);\n            return c;\n        }\n        value[c] = 0;\n        av_dict_set(&s->metadata, key, value, AV_DICT_DONT_STRDUP_VAL);\n    }\n    return 0;\n}", "target": 0}
{"idx": 5101, "func": "static apr_status_t store_body(cache_handle_t *h, request_rec *r,\n        apr_bucket_brigade *in, apr_bucket_brigade *out)\n{\n    apr_bucket *e;\n    apr_status_t rv = APR_SUCCESS;\n    cache_socache_object_t *sobj =\n            (cache_socache_object_t *) h->cache_obj->vobj;\n    cache_socache_dir_conf *dconf =\n            ap_get_module_config(r->per_dir_config, &cache_socache_module);\n    int seen_eos = 0;\n\n    if (!sobj->offset) {\n        sobj->offset = dconf->readsize;\n    }\n    if (!sobj->timeout && dconf->readtime) {\n        sobj->timeout = apr_time_now() + dconf->readtime;\n    }\n\n    if (!sobj->newbody) {\n        sobj->body_length = 0;\n        sobj->newbody = 1;\n    }\n    if (sobj->offset) {\n        apr_brigade_partition(in, sobj->offset, &e);\n    }\n\n    while (APR_SUCCESS == rv && !APR_BRIGADE_EMPTY(in)) {\n        const char *str;\n        apr_size_t length;\n\n        e = APR_BRIGADE_FIRST(in);\n\n        /* are we done completely? if so, pass any trailing buckets right through */\n        if (sobj->done || !sobj->pool) {\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            continue;\n        }\n\n        /* have we seen eos yet? */\n        if (APR_BUCKET_IS_EOS(e)) {\n            seen_eos = 1;\n            sobj->done = 1;\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            break;\n        }\n\n        /* honour flush buckets, we'll get called again */\n        if (APR_BUCKET_IS_FLUSH(e)) {\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            break;\n        }\n\n        /* metadata buckets are preserved as is */\n        if (APR_BUCKET_IS_METADATA(e)) {\n            APR_BUCKET_REMOVE(e);\n            APR_BRIGADE_INSERT_TAIL(out, e);\n            continue;\n        }\n\n        /* read the bucket, write to the cache */\n        rv = apr_bucket_read(e, &str, &length, APR_BLOCK_READ);\n        APR_BUCKET_REMOVE(e);\n        APR_BRIGADE_INSERT_TAIL(out, e);\n        if (rv != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02377)\n                    \"Error when reading bucket for URL %s\",\n                    h->cache_obj->key);\n            /* Remove the intermediate cache file and return non-APR_SUCCESS */\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return rv;\n        }\n\n        /* don't write empty buckets to the cache */\n        if (!length) {\n            continue;\n        }\n\n        sobj->body_length += length;\n        if (sobj->body_length >= sobj->buffer_len - sobj->body_offset) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02378)\n                    \"URL %s failed the buffer size check \"\n                    \"(%\" APR_OFF_T_FMT \">=%\" APR_SIZE_T_FMT \")\",\n                    h->cache_obj->key, sobj->body_length,\n                    sobj->buffer_len - sobj->body_offset);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return APR_EGENERAL;\n        }\n        memcpy(sobj->buffer + sobj->body_offset + sobj->body_length - length,\n               str, length);\n\n        /* have we reached the limit of how much we're prepared to write in one\n         * go? If so, leave, we'll get called again. This prevents us from trying\n         * to swallow too much data at once, or taking so long to write the data\n         * the client times out.\n         */\n        sobj->offset -= length;\n        if (sobj->offset <= 0) {\n            sobj->offset = 0;\n            break;\n        }\n        if ((dconf->readtime && apr_time_now() > sobj->timeout)) {\n            sobj->timeout = 0;\n            break;\n        }\n\n    }\n\n    /* Was this the final bucket? If yes, perform sanity checks.\n     */\n    if (seen_eos) {\n        const char *cl_header = apr_table_get(r->headers_out, \"Content-Length\");\n\n        if (r->connection->aborted || r->no_cache) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02380)\n                    \"Discarding body for URL %s \"\n                    \"because connection has been aborted.\",\n                    h->cache_obj->key);\n            apr_pool_destroy(sobj->pool);\n            sobj->pool = NULL;\n            return APR_EGENERAL;\n        }\n        if (cl_header) {\n            apr_off_t cl;\n            char *cl_endp;\n            if (apr_strtoff(&cl, cl_header, &cl_endp, 10) != APR_SUCCESS\n                    || *cl_endp != '\\0' || cl != sobj->body_length) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02381)\n                        \"URL %s didn't receive complete response, not caching\",\n                        h->cache_obj->key);\n                apr_pool_destroy(sobj->pool);\n                sobj->pool = NULL;\n                return APR_EGENERAL;\n            }\n        }\n\n        /* All checks were fine, we're good to go when the commit comes */\n\n    }\n\n    return APR_SUCCESS;\n}", "target": 0}
{"idx": 5102, "func": "const char *RAND_file_name(char *buf, size_t size)\n{\n    char *s = NULL;\n    size_t len;\n    int use_randfile = 1;\n\n#if defined(_WIN32) && defined(CP_UTF8)\n    DWORD envlen;\n    WCHAR *var;\n\n    /* Look up various environment variables. */\n    if ((envlen = GetEnvironmentVariableW(var = L\"RANDFILE\", NULL, 0)) == 0) {\n        use_randfile = 0;\n        if ((envlen = GetEnvironmentVariableW(var = L\"HOME\", NULL, 0)) == 0\n                && (envlen = GetEnvironmentVariableW(var = L\"USERPROFILE\",\n                                                  NULL, 0)) == 0)\n            envlen = GetEnvironmentVariableW(var = L\"SYSTEMROOT\", NULL, 0);\n    }\n\n    /* If we got a value, allocate space to hold it and then get it. */\n    if (envlen != 0) {\n        int sz;\n        WCHAR *val = _alloca(envlen * sizeof(WCHAR));\n\n        if (GetEnvironmentVariableW(var, val, envlen) < envlen\n                && (sz = WideCharToMultiByte(CP_UTF8, 0, val, -1, NULL, 0,\n                                             NULL, NULL)) != 0) {\n            s = _alloca(sz);\n            if (WideCharToMultiByte(CP_UTF8, 0, val, -1, s, sz,\n                                    NULL, NULL) == 0)\n                s = NULL;\n        }\n    }\n#else\n    if ((s = ossl_safe_getenv(\"RANDFILE\")) == NULL || *s == '\\0') {\n        use_randfile = 0;\n        s = ossl_safe_getenv(\"HOME\");\n    }\n#endif\n\n#ifdef DEFAULT_HOME\n    if (!use_randfile && s == NULL)\n        s = DEFAULT_HOME;\n#endif\n    if (s == NULL || *s == '\\0')\n        return NULL;\n\n    len = strlen(s);\n    if (use_randfile) {\n        if (len + 1 >= size)\n            return NULL;\n        strcpy(buf, s);\n    } else {\n        if (len + 1 + strlen(RFILE) + 1 >= size)\n            return NULL;\n        strcpy(buf, s);\n#ifndef OPENSSL_SYS_VMS\n        strcat(buf, \"/\");\n#endif\n        strcat(buf, RFILE);\n    }\n\n    return buf;\n}", "target": 0}
{"idx": 5103, "func": "static int get_audio_buffer(AVFrame *frame, int align)\n{\n    int channels;\n    int planar   = av_sample_fmt_is_planar(frame->format);\n    int planes;\n    int ret, i;\n\n    if (!frame->channels)\n        frame->channels = av_get_channel_layout_nb_channels(frame->channel_layout);\n\n    channels = frame->channels;\n    planes = planar ? channels : 1;\n\n    CHECK_CHANNELS_CONSISTENCY(frame);\n    if (!frame->linesize[0]) {\n        ret = av_samples_get_buffer_size(&frame->linesize[0], channels,\n                                         frame->nb_samples, frame->format,\n                                         align);\n        if (ret < 0)\n            return ret;\n    }\n\n    if (planes > AV_NUM_DATA_POINTERS) {\n        frame->extended_data = av_mallocz(planes *\n                                          sizeof(*frame->extended_data));\n        frame->extended_buf  = av_mallocz((planes - AV_NUM_DATA_POINTERS) *\n                                          sizeof(*frame->extended_buf));\n        if (!frame->extended_data || !frame->extended_buf) {\n            av_freep(&frame->extended_data);\n            av_freep(&frame->extended_buf);\n            return AVERROR(ENOMEM);\n        }\n        frame->nb_extended_buf = planes - AV_NUM_DATA_POINTERS;\n    } else\n        frame->extended_data = frame->data;\n\n    for (i = 0; i < FFMIN(planes, AV_NUM_DATA_POINTERS); i++) {\n        frame->buf[i] = av_buffer_alloc(frame->linesize[0]);\n        if (!frame->buf[i]) {\n            av_frame_unref(frame);\n            return AVERROR(ENOMEM);\n        }\n        frame->extended_data[i] = frame->data[i] = frame->buf[i]->data;\n    }\n    for (i = 0; i < planes - AV_NUM_DATA_POINTERS; i++) {\n        frame->extended_buf[i] = av_buffer_alloc(frame->linesize[0]);\n        if (!frame->extended_buf[i]) {\n            av_frame_unref(frame);\n            return AVERROR(ENOMEM);\n        }\n        frame->extended_data[i + AV_NUM_DATA_POINTERS] = frame->extended_buf[i]->data;\n    }\n    return 0;\n\n}", "target": 1}
{"idx": 5104, "func": "static void compute_default_clut(uint8_t *clut, AVSubtitleRect *rect, int w, int h)\n{\n    uint8_t list[256] = {0};\n    uint8_t list_inv[256];\n    int counttab[256] = {0};\n    int count, i, x, y;\n    ptrdiff_t stride = rect->linesize[0];\n#define V(x,y) rect->data[0][(x) + (y)*stride]\n    for (y = 0; y<h; y++) {\n        for (x = 0; x<w; x++) {\n            int v = V(x,y) + 1;\n            int vl = x     ? V(x-1,y) + 1 : 0;\n            int vr = x+1<w ? V(x+1,y) + 1 : 0;\n            int vt = y     ? V(x,y-1) + 1 : 0;\n            int vb = y+1<h ? V(x,y+1) + 1 : 0;\n            counttab[v-1] += !!((v!=vl) + (v!=vr) + (v!=vt) + (v!=vb));\n        }\n    }\n#define L(x,y) list[d[(x) + (y)*stride]]\n\n    for (i = 0; i<256; i++) {\n        int scoretab[256] = {0};\n        int bestscore = 0;\n        int bestv = 0;\n        for (y = 0; y<h; y++) {\n            for (x = 0; x<w; x++) {\n                uint8_t *d = &rect->data[0][x + y*stride];\n                int v = *d;\n                int l_m = list[v];\n                int l_l = x     ? L(-1, 0) : 1;\n                int l_r = x+1<w ? L( 1, 0) : 1;\n                int l_t = y     ? L( 0,-1) : 1;\n                int l_b = y+1<h ? L( 0, 1) : 1;\n                if (l_m)\n                    continue;\n                scoretab[v] += l_l + l_r + l_t + l_b;\n            }\n        }\n        for (x = 0; x < 256; x++) {\n            if (scoretab[x]) {\n                int score = 1024LL*scoretab[x] / counttab[x];\n                if (score > bestscore) {\n                    bestscore = score;\n                    bestv = x;\n                }\n            }\n        }\n        if (!bestscore)\n            break;\n        list    [ bestv ] = 1;\n        list_inv[     i ] = bestv;\n    }\n\n    count = FFMAX(i - 1, 1);\n    for (i--; i>=0; i--) {\n        int v = i*255/count;\n        AV_WN32(clut + 4*list_inv[i], RGBA(v/2,v,v/2,v));\n    }\n}", "target": 0}
{"idx": 5105, "func": "static void vp8_decode_flush_impl(AVCodecContext *avctx,\n                                  int prefer_delayed_free, int can_direct_free, int free_mem)\n{\n    VP8Context *s = avctx->priv_data;\n    int i;\n\n    if (!avctx->is_copy) {\n        for (i = 0; i < 5; i++)\n            if (s->frames[i].data[0])\n                vp8_release_frame(s, &s->frames[i], prefer_delayed_free, can_direct_free);\n    }\n    memset(s->framep, 0, sizeof(s->framep));\n\n    if (free_mem) {\n        free_buffers(s);\n        s->maps_are_invalid = 1;\n    }\n}", "target": 0}
{"idx": 5106, "func": "static av_always_inline void\nyuv2gray16_2_c_template(SwsContext *c, const int16_t *buf[2],\n                        const int16_t *ubuf[2], const int16_t *vbuf[2],\n                        const int16_t *abuf[2], uint8_t *dest, int dstW,\n                        int yalpha, int uvalpha, int y,\n                        enum PixelFormat target)\n{\n    int  yalpha1 = 4095 - yalpha;\n    int i;\n    const int16_t *buf0 = buf[0], *buf1 = buf[1];\n\n    for (i = 0; i < (dstW >> 1); i++) {\n        const int i2 = 2 * i;\n        int Y1 = (buf0[i2  ] * yalpha1 + buf1[i2  ] * yalpha) >> 11;\n        int Y2 = (buf0[i2+1] * yalpha1 + buf1[i2+1] * yalpha) >> 11;\n\n        output_pixel(&dest[2 * i2 + 0], Y1);\n        output_pixel(&dest[2 * i2 + 2], Y2);\n    }\n}", "target": 0}
{"idx": 5107, "func": "static int parse_playlist(HLSContext *c, const char *url,\n                          struct variant *var, AVIOContext *in)\n{\n    int ret = 0, duration = 0, is_segment = 0, is_variant = 0, bandwidth = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[1024];\n    const char *ptr;\n    int close_in = 0;\n\n    if (!in) {\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers dont like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n        ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                         c->interrupt_callback, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n    }\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (var) {\n        free_segment_list(var);\n        var->finished = 0;\n    }\n    while (!url_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            struct variant_info info = {{0}};\n            is_variant = 1;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &info);\n            bandwidth = atoi(info.bandwidth);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            if (!var) {\n                var = new_variant(c, 0, url, NULL);\n                if (!var) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n            }\n            var->target_duration = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            if (!var) {\n                var = new_variant(c, 0, url, NULL);\n                if (!var) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n            }\n            var->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (var)\n                var->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atoi(ptr);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, bandwidth, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n                bandwidth  = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!var) {\n                    var = new_variant(c, 0, url, NULL);\n                    if (!var) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = var->start_seq_no + var->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n                ff_make_absolute_url(seg->key, sizeof(seg->key), url, key);\n                ff_make_absolute_url(seg->url, sizeof(seg->url), url, line);\n                dynarray_add(&var->segments, &var->n_segments, seg);\n                is_segment = 0;\n            }\n        }\n    }\n    if (var)\n        var->last_load_time = av_gettime();\n\nfail:\n    if (close_in)\n        avio_close(in);\n    return ret;\n}", "target": 0}
{"idx": 5108, "func": "static av_cold int qdm2_decode_init(AVCodecContext *avctx)\n{\n    QDM2Context *s = avctx->priv_data;\n    uint8_t *extradata;\n    int extradata_size;\n    int tmp_val, tmp, size;\n\n    /* extradata parsing\n\n    Structure:\n    wave {\n        frma (QDM2)\n        QDCA\n        QDCP\n    }\n\n    32  size (including this field)\n    32  tag (=frma)\n    32  type (=QDM2 or QDMC)\n\n    32  size (including this field, in bytes)\n    32  tag (=QDCA) // maybe mandatory parameters\n    32  unknown (=1)\n    32  channels (=2)\n    32  samplerate (=44100)\n    32  bitrate (=96000)\n    32  block size (=4096)\n    32  frame size (=256) (for one channel)\n    32  packet size (=1300)\n\n    32  size (including this field, in bytes)\n    32  tag (=QDCP) // maybe some tuneable parameters\n    32  float1 (=1.0)\n    32  zero ?\n    32  float2 (=1.0)\n    32  float3 (=1.0)\n    32  unknown (27)\n    32  unknown (8)\n    32  zero ?\n    */\n\n    if (!avctx->extradata || (avctx->extradata_size < 48)) {\n        av_log(avctx, AV_LOG_ERROR, \"extradata missing or truncated\\n\");\n        return -1;\n    }\n\n    extradata = avctx->extradata;\n    extradata_size = avctx->extradata_size;\n\n    while (extradata_size > 7) {\n        if (!memcmp(extradata, \"frmaQDM\", 7))\n            break;\n        extradata++;\n        extradata_size--;\n    }\n\n    if (extradata_size < 12) {\n        av_log(avctx, AV_LOG_ERROR, \"not enough extradata (%i)\\n\",\n               extradata_size);\n        return -1;\n    }\n\n    if (memcmp(extradata, \"frmaQDM\", 7)) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid headers, QDM? not found\\n\");\n        return -1;\n    }\n\n    if (extradata[7] == 'C') {\n//        s->is_qdmc = 1;\n        av_log(avctx, AV_LOG_ERROR, \"stream is QDMC version 1, which is not supported\\n\");\n        return -1;\n    }\n\n    extradata += 8;\n    extradata_size -= 8;\n\n    size = AV_RB32(extradata);\n\n    if(size > extradata_size){\n        av_log(avctx, AV_LOG_ERROR, \"extradata size too small, %i < %i\\n\",\n               extradata_size, size);\n        return -1;\n    }\n\n    extradata += 4;\n    av_log(avctx, AV_LOG_DEBUG, \"size: %d\\n\", size);\n    if (AV_RB32(extradata) != MKBETAG('Q','D','C','A')) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid extradata, expecting QDCA\\n\");\n        return -1;\n    }\n\n    extradata += 8;\n\n    avctx->channels = s->nb_channels = s->channels = AV_RB32(extradata);\n    extradata += 4;\n    if (s->channels > MPA_MAX_CHANNELS)\n        return AVERROR_INVALIDDATA;\n\n    avctx->sample_rate = AV_RB32(extradata);\n    extradata += 4;\n\n    avctx->bit_rate = AV_RB32(extradata);\n    extradata += 4;\n\n    s->group_size = AV_RB32(extradata);\n    extradata += 4;\n\n    s->fft_size = AV_RB32(extradata);\n    extradata += 4;\n\n    s->checksum_size = AV_RB32(extradata);\n\n    s->fft_order = av_log2(s->fft_size) + 1;\n    s->fft_frame_size = 2 * s->fft_size; // complex has two floats\n\n    // something like max decodable tones\n    s->group_order = av_log2(s->group_size) + 1;\n    s->frame_size = s->group_size / 16; // 16 iterations per super block\n    if (s->frame_size > FF_ARRAY_ELEMS(s->output_buffer) / 2)\n        return AVERROR_INVALIDDATA;\n\n    s->sub_sampling = s->fft_order - 7;\n    s->frequency_range = 255 / (1 << (2 - s->sub_sampling));\n\n    switch ((s->sub_sampling * 2 + s->channels - 1)) {\n        case 0: tmp = 40; break;\n        case 1: tmp = 48; break;\n        case 2: tmp = 56; break;\n        case 3: tmp = 72; break;\n        case 4: tmp = 80; break;\n        case 5: tmp = 100;break;\n        default: tmp=s->sub_sampling; break;\n    }\n    tmp_val = 0;\n    if ((tmp * 1000) < avctx->bit_rate)  tmp_val = 1;\n    if ((tmp * 1440) < avctx->bit_rate)  tmp_val = 2;\n    if ((tmp * 1760) < avctx->bit_rate)  tmp_val = 3;\n    if ((tmp * 2240) < avctx->bit_rate)  tmp_val = 4;\n    s->cm_table_select = tmp_val;\n\n    if (s->sub_sampling == 0)\n        tmp = 7999;\n    else\n        tmp = ((-(s->sub_sampling -1)) & 8000) + 20000;\n    /*\n    0: 7999 -> 0\n    1: 20000 -> 2\n    2: 28000 -> 2\n    */\n    if (tmp < 8000)\n        s->coeff_per_sb_select = 0;\n    else if (tmp <= 16000)\n        s->coeff_per_sb_select = 1;\n    else\n        s->coeff_per_sb_select = 2;\n\n    // Fail on unknown fft order\n    if ((s->fft_order < 7) || (s->fft_order > 9)) {\n        av_log(avctx, AV_LOG_ERROR, \"Unknown FFT order (%d), contact the developers!\\n\", s->fft_order);\n        return -1;\n    }\n\n    ff_rdft_init(&s->rdft_ctx, s->fft_order, IDFT_C2R);\n    ff_mpadsp_init(&s->mpadsp);\n\n    qdm2_init(s);\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n//    dump_context(s);\n    return 0;\n}", "target": 0}
{"idx": 5109, "func": "static int mpc7_decode_frame(AVCodecContext * avctx, void *data,\n                             int *got_frame_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    MPCContext *c = avctx->priv_data;\n    GetBitContext gb;\n    uint8_t *bits;\n    int i, ch;\n    int mb = -1;\n    Band *bands = c->bands;\n    int off, ret;\n    int bits_used, bits_avail;\n\n    memset(bands, 0, sizeof(*bands) * (c->maxbands + 1));\n    if(buf_size <= 4){\n        av_log(avctx, AV_LOG_ERROR, \"Too small buffer passed (%i bytes)\\n\", buf_size);\n        return AVERROR(EINVAL);\n    }\n\n    /* get output buffer */\n    c->frame.nb_samples = buf[1] ? c->lastframelen : MPC_FRAME_SIZE;\n    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n\n    bits = av_malloc(((buf_size - 1) & ~3) + FF_INPUT_BUFFER_PADDING_SIZE);\n    if (!bits)\n        return AVERROR(ENOMEM);\n    c->dsp.bswap_buf((uint32_t*)bits, (const uint32_t*)(buf + 4), (buf_size - 4) >> 2);\n    init_get_bits(&gb, bits, (buf_size - 4)* 8);\n    skip_bits_long(&gb, buf[0]);\n\n    /* read subband indexes */\n    for(i = 0; i <= c->maxbands; i++){\n        for(ch = 0; ch < 2; ch++){\n            int t = 4;\n            if(i) t = get_vlc2(&gb, hdr_vlc.table, MPC7_HDR_BITS, 1) - 5;\n            if(t == 4) bands[i].res[ch] = get_bits(&gb, 4);\n            else bands[i].res[ch] = bands[i-1].res[ch] + t;\n        }\n\n        if(bands[i].res[0] || bands[i].res[1]){\n            mb = i;\n            if(c->MSS) bands[i].msf = get_bits1(&gb);\n        }\n    }\n    /* get scale indexes coding method */\n    for(i = 0; i <= mb; i++)\n        for(ch = 0; ch < 2; ch++)\n            if(bands[i].res[ch]) bands[i].scfi[ch] = get_vlc2(&gb, scfi_vlc.table, MPC7_SCFI_BITS, 1);\n    /* get scale indexes */\n    for(i = 0; i <= mb; i++){\n        for(ch = 0; ch < 2; ch++){\n            if(bands[i].res[ch]){\n                bands[i].scf_idx[ch][2] = c->oldDSCF[ch][i];\n                bands[i].scf_idx[ch][0] = get_scale_idx(&gb, bands[i].scf_idx[ch][2]);\n                switch(bands[i].scfi[ch]){\n                case 0:\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n                    break;\n                case 1:\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1];\n                    break;\n                case 2:\n                    bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n                    break;\n                case 3:\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n                    break;\n                }\n                c->oldDSCF[ch][i] = bands[i].scf_idx[ch][2];\n            }\n        }\n    }\n    /* get quantizers */\n    memset(c->Q, 0, sizeof(c->Q));\n    off = 0;\n    for(i = 0; i < BANDS; i++, off += SAMPLES_PER_BAND)\n        for(ch = 0; ch < 2; ch++)\n            idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off);\n\n    ff_mpc_dequantize_and_synth(c, mb, c->frame.data[0], 2);\n\n    av_free(bits);\n\n    bits_used = get_bits_count(&gb);\n    bits_avail = (buf_size - 4) * 8;\n    if(!buf[1] && ((bits_avail < bits_used) || (bits_used + 32 <= bits_avail))){\n        av_log(NULL,0, \"Error decoding frame: used %i of %i bits\\n\", bits_used, bits_avail);\n        return -1;\n    }\n    if(c->frames_to_skip){\n        c->frames_to_skip--;\n        *got_frame_ptr = 0;\n        return buf_size;\n    }\n\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = c->frame;\n\n    return buf_size;\n}", "target": 0}
{"idx": 5110, "func": "static av_cold int cinepak_encode_init(AVCodecContext *avctx)\n{\n    CinepakEncContext *s = avctx->priv_data;\n    int x, mb_count, strip_buf_size, frame_buf_size;\n\n    if (avctx->width & 3 || avctx->height & 3) {\n        av_log(avctx, AV_LOG_ERROR, \"width and height must be multiples of four (got %ix%i)\\n\",\n                avctx->width, avctx->height);\n        return AVERROR(EINVAL);\n    }\n\n    if (!(s->last_frame = av_frame_alloc()))\n        return AVERROR(ENOMEM);\n    if (!(s->best_frame = av_frame_alloc()))\n        goto enomem;\n    if (!(s->scratch_frame = av_frame_alloc()))\n        goto enomem;\n    if (avctx->pix_fmt == AV_PIX_FMT_RGB24)\n        if (!(s->input_frame = av_frame_alloc()))\n            goto enomem;\n\n    if (!(s->codebook_input = av_malloc(sizeof(int) * (avctx->pix_fmt == AV_PIX_FMT_RGB24 ? 6 : 4) * (avctx->width * avctx->height) >> 2)))\n        goto enomem;\n\n    if (!(s->codebook_closest = av_malloc(sizeof(int) * (avctx->width * avctx->height) >> 2)))\n        goto enomem;\n\n    for(x = 0; x < (avctx->pix_fmt == AV_PIX_FMT_RGB24 ? 4 : 3); x++)\n        if(!(s->pict_bufs[x] = av_malloc((avctx->pix_fmt == AV_PIX_FMT_RGB24 ? 6 : 4) * (avctx->width * avctx->height) >> 2)))\n            goto enomem;\n\n    mb_count = avctx->width * avctx->height / MB_AREA;\n\n    //the largest possible chunk is 0x31 with all MBs encoded in V4 mode\n    //and full codebooks being replaced in INTER mode,\n    // which is 34 bits per MB\n    //and 2*256 extra flag bits per strip\n    strip_buf_size = STRIP_HEADER_SIZE + 3 * CHUNK_HEADER_SIZE + 2 * VECTOR_MAX * CODEBOOK_MAX + 4 * (mb_count + (mb_count + 15) / 16) + (2 * CODEBOOK_MAX)/8;\n\n    frame_buf_size = CVID_HEADER_SIZE + MAX_STRIPS * strip_buf_size;\n\n    if (!(s->strip_buf = av_malloc(strip_buf_size)))\n        goto enomem;\n\n    if (!(s->frame_buf = av_malloc(frame_buf_size)))\n        goto enomem;\n\n    if (!(s->mb = av_malloc(mb_count*sizeof(mb_info))))\n        goto enomem;\n\n#ifdef CINEPAKENC_DEBUG\n    if (!(s->best_mb = av_malloc(mb_count*sizeof(mb_info))))\n        goto enomem;\n#endif\n\n    av_lfg_init(&s->randctx, 1);\n    s->avctx = avctx;\n    s->w = avctx->width;\n    s->h = avctx->height;\n    s->frame_buf_size = frame_buf_size;\n    s->curframe = 0;\n    s->keyint = avctx->keyint_min;\n    s->pix_fmt = avctx->pix_fmt;\n\n    //set up AVFrames\n    s->last_frame->data[0]        = s->pict_bufs[0];\n    s->last_frame->linesize[0]    = s->w;\n    s->best_frame->data[0]        = s->pict_bufs[1];\n    s->best_frame->linesize[0]    = s->w;\n    s->scratch_frame->data[0]     = s->pict_bufs[2];\n    s->scratch_frame->linesize[0] = s->w;\n\n    if (s->pix_fmt == AV_PIX_FMT_RGB24) {\n        s->last_frame->data[1]        = s->last_frame->data[0] + s->w * s->h;\n        s->last_frame->data[2]        = s->last_frame->data[1] + ((s->w * s->h) >> 2);\n        s->last_frame->linesize[1]    = s->last_frame->linesize[2] = s->w >> 1;\n\n        s->best_frame->data[1]        = s->best_frame->data[0] + s->w * s->h;\n        s->best_frame->data[2]        = s->best_frame->data[1] + ((s->w * s->h) >> 2);\n        s->best_frame->linesize[1]    = s->best_frame->linesize[2] = s->w >> 1;\n\n        s->scratch_frame->data[1]     = s->scratch_frame->data[0] + s->w * s->h;\n        s->scratch_frame->data[2]     = s->scratch_frame->data[1] + ((s->w * s->h) >> 2);\n        s->scratch_frame->linesize[1] = s->scratch_frame->linesize[2] = s->w >> 1;\n\n        s->input_frame->data[0]       = s->pict_bufs[3];\n        s->input_frame->linesize[0]   = s->w;\n        s->input_frame->data[1]       = s->input_frame->data[0] + s->w * s->h;\n        s->input_frame->data[2]       = s->input_frame->data[1] + ((s->w * s->h) >> 2);\n        s->input_frame->linesize[1]   = s->input_frame->linesize[2] = s->w >> 1;\n    }\n\n    s->min_strips = MIN_STRIPS;\n    s->max_strips = MAX_STRIPS;\n\n#ifdef CINEPAKENC_DEBUG\n    s->num_v1_mode = s->num_v4_mode = s->num_mc_mode = s->num_v1_encs = s->num_v4_encs = s->num_skips = 0;\n#endif\n\n    return 0;\n\nenomem:\n    av_frame_free(&s->last_frame);\n    av_frame_free(&s->best_frame);\n    av_frame_free(&s->scratch_frame);\n    if (avctx->pix_fmt == AV_PIX_FMT_RGB24)\n        av_frame_free(&s->input_frame);\n    av_freep(&s->codebook_input);\n    av_freep(&s->codebook_closest);\n    av_freep(&s->strip_buf);\n    av_freep(&s->frame_buf);\n    av_freep(&s->mb);\n#ifdef CINEPAKENC_DEBUG\n    av_freep(&s->best_mb);\n#endif\n\n    for(x = 0; x < (avctx->pix_fmt == AV_PIX_FMT_RGB24 ? 4 : 3); x++)\n        av_freep(&s->pict_bufs[x]);\n\n    return AVERROR(ENOMEM);\n}", "target": 0}
{"idx": 5111, "func": "static av_always_inline void rgb16_32ToUV_half_c_template(int16_t *dstU,\n                                                          int16_t *dstV,\n                                                          const uint8_t *src,\n                                                          int width,\n                                                          enum AVPixelFormat origin,\n                                                          int shr, int shg,\n                                                          int shb, int shp,\n                                                          int maskr, int maskg,\n                                                          int maskb, int rsh,\n                                                          int gsh, int bsh, int S,\n                                                          int32_t *rgb2yuv)\n{\n    const int ru       = rgb2yuv[RU_IDX] << rsh, gu = rgb2yuv[GU_IDX] << gsh, bu = rgb2yuv[BU_IDX] << bsh,\n              rv       = rgb2yuv[RV_IDX] << rsh, gv = rgb2yuv[GV_IDX] << gsh, bv = rgb2yuv[BV_IDX] << bsh,\n              maskgx   = ~(maskr | maskb);\n    const unsigned rnd = (256U<<(S)) + (1<<(S-6));\n    int i;\n\n    maskr |= maskr << 1;\n    maskb |= maskb << 1;\n    maskg |= maskg << 1;\n    for (i = 0; i < width; i++) {\n        int px0 = input_pixel(2 * i + 0) >> shp;\n        int px1 = input_pixel(2 * i + 1) >> shp;\n        int b, r, g = (px0 & maskgx) + (px1 & maskgx);\n        int rb = px0 + px1 - g;\n\n        b = (rb & maskb) >> shb;\n        if (shp ||\n            origin == AV_PIX_FMT_BGR565LE || origin == AV_PIX_FMT_BGR565BE ||\n            origin == AV_PIX_FMT_RGB565LE || origin == AV_PIX_FMT_RGB565BE) {\n            g >>= shg;\n        } else {\n            g = (g & maskg) >> shg;\n        }\n        r = (rb & maskr) >> shr;\n\n        dstU[i] = (ru * r + gu * g + bu * b + (unsigned)rnd) >> ((S)-6+1);\n        dstV[i] = (rv * r + gv * g + bv * b + (unsigned)rnd) >> ((S)-6+1);\n    }\n}", "target": 1}
{"idx": 5112, "func": "static int init_pass2(MpegEncContext *s)\n{\n    RateControlContext *rcc = &s->rc_context;\n    AVCodecContext *a       = s->avctx;\n    int i, toobig;\n    double fps             = get_fps(s->avctx);\n    double complexity[5]   = { 0 }; // approximate bits at quant=1\n    uint64_t const_bits[5] = { 0 }; // quantizer independent bits\n    uint64_t all_const_bits;\n    uint64_t all_available_bits = (uint64_t)(s->bit_rate *\n                                             (double)rcc->num_entries / fps);\n    double rate_factor          = 0;\n    double step;\n    const int filter_size = (int)(a->qblur * 4) | 1;\n    double expected_bits = 0; // init to silence gcc warning\n    double *qscale, *blurred_qscale, qscale_sum;\n\n    /* find complexity & const_bits & decide the pict_types */\n    for (i = 0; i < rcc->num_entries; i++) {\n        RateControlEntry *rce = &rcc->entry[i];\n\n        rce->new_pict_type                = rce->pict_type;\n        rcc->i_cplx_sum[rce->pict_type]  += rce->i_tex_bits * rce->qscale;\n        rcc->p_cplx_sum[rce->pict_type]  += rce->p_tex_bits * rce->qscale;\n        rcc->mv_bits_sum[rce->pict_type] += rce->mv_bits;\n        rcc->frame_count[rce->pict_type]++;\n\n        complexity[rce->new_pict_type] += (rce->i_tex_bits + rce->p_tex_bits) *\n                                          (double)rce->qscale;\n        const_bits[rce->new_pict_type] += rce->mv_bits + rce->misc_bits;\n    }\n\n    all_const_bits = const_bits[AV_PICTURE_TYPE_I] +\n                     const_bits[AV_PICTURE_TYPE_P] +\n                     const_bits[AV_PICTURE_TYPE_B];\n\n    if (all_available_bits < all_const_bits) {\n        av_log(s->avctx, AV_LOG_ERROR, \"requested bitrate is too low\\n\");\n        return -1;\n    }\n\n    qscale         = av_malloc_array(rcc->num_entries, sizeof(double));\n    blurred_qscale = av_malloc_array(rcc->num_entries, sizeof(double));\n    toobig = 0;\n\n    for (step = 256 * 256; step > 0.0000001; step *= 0.5) {\n        expected_bits = 0;\n        rate_factor  += step;\n\n        rcc->buffer_index = s->avctx->rc_buffer_size / 2;\n\n        /* find qscale */\n        for (i = 0; i < rcc->num_entries; i++) {\n            RateControlEntry *rce = &rcc->entry[i];\n\n            qscale[i] = get_qscale(s, &rcc->entry[i], rate_factor, i);\n            rcc->last_qscale_for[rce->pict_type] = qscale[i];\n        }\n        assert(filter_size % 2 == 1);\n\n        /* fixed I/B QP relative to P mode */\n        for (i = FFMAX(0, rcc->num_entries - 300); i < rcc->num_entries; i++) {\n            RateControlEntry *rce = &rcc->entry[i];\n\n            qscale[i] = get_diff_limited_q(s, rce, qscale[i]);\n        }\n\n        for (i = rcc->num_entries - 1; i >= 0; i--) {\n            RateControlEntry *rce = &rcc->entry[i];\n\n            qscale[i] = get_diff_limited_q(s, rce, qscale[i]);\n        }\n\n        /* smooth curve */\n        for (i = 0; i < rcc->num_entries; i++) {\n            RateControlEntry *rce = &rcc->entry[i];\n            const int pict_type   = rce->new_pict_type;\n            int j;\n            double q = 0.0, sum = 0.0;\n\n            for (j = 0; j < filter_size; j++) {\n                int index    = i + j - filter_size / 2;\n                double d     = index - i;\n                double coeff = a->qblur == 0 ? 1.0 : exp(-d * d / (a->qblur * a->qblur));\n\n                if (index < 0 || index >= rcc->num_entries)\n                    continue;\n                if (pict_type != rcc->entry[index].new_pict_type)\n                    continue;\n                q   += qscale[index] * coeff;\n                sum += coeff;\n            }\n            blurred_qscale[i] = q / sum;\n        }\n\n        /* find expected bits */\n        for (i = 0; i < rcc->num_entries; i++) {\n            RateControlEntry *rce = &rcc->entry[i];\n            double bits;\n\n            rce->new_qscale = modify_qscale(s, rce, blurred_qscale[i], i);\n\n            bits  = qp2bits(rce, rce->new_qscale) + rce->mv_bits + rce->misc_bits;\n            bits += 8 * ff_vbv_update(s, bits);\n\n            rce->expected_bits = expected_bits;\n            expected_bits     += bits;\n        }\n\n        av_dlog(s->avctx,\n                \"expected_bits: %f all_available_bits: %d rate_factor: %f\\n\",\n                expected_bits, (int)all_available_bits, rate_factor);\n        if (expected_bits > all_available_bits) {\n            rate_factor -= step;\n            ++toobig;\n        }\n    }\n    av_free(qscale);\n    av_free(blurred_qscale);\n\n    /* check bitrate calculations and print info */\n    qscale_sum = 0.0;\n    for (i = 0; i < rcc->num_entries; i++) {\n        av_dlog(s, \"[lavc rc] entry[%d].new_qscale = %.3f  qp = %.3f\\n\",\n                i,\n                rcc->entry[i].new_qscale,\n                rcc->entry[i].new_qscale / FF_QP2LAMBDA);\n        qscale_sum += av_clip(rcc->entry[i].new_qscale / FF_QP2LAMBDA,\n                              s->avctx->qmin, s->avctx->qmax);\n    }\n    assert(toobig <= 40);\n    av_log(s->avctx, AV_LOG_DEBUG,\n           \"[lavc rc] requested bitrate: %d bps  expected bitrate: %d bps\\n\",\n           s->bit_rate,\n           (int)(expected_bits / ((double)all_available_bits / s->bit_rate)));\n    av_log(s->avctx, AV_LOG_DEBUG,\n           \"[lavc rc] estimated target average qp: %.3f\\n\",\n           (float)qscale_sum / rcc->num_entries);\n    if (toobig == 0) {\n        av_log(s->avctx, AV_LOG_INFO,\n               \"[lavc rc] Using all of requested bitrate is not \"\n               \"necessary for this video with these parameters.\\n\");\n    } else if (toobig == 40) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"[lavc rc] Error: bitrate too low for this video \"\n               \"with these parameters.\\n\");\n        return -1;\n    } else if (fabs(expected_bits / all_available_bits - 1.0) > 0.01) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"[lavc rc] Error: 2pass curve failed to converge\\n\");\n        return -1;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5113, "func": "int test_gf2m_mod_inv(BIO *bp,BN_CTX *ctx)\n\t{\n\tBIGNUM *a,*b[2],*c,*d;\n\tint i, j, ret = 0;\n\tint p0[] = {163,7,6,3,0,-1};\n\tint p1[] = {193,15,0,-1};\n\n\ta=BN_new();\n\tb[0]=BN_new();\n\tb[1]=BN_new();\n\tc=BN_new();\n\td=BN_new();\n\n\tBN_GF2m_arr2poly(p0, b[0]);\n\tBN_GF2m_arr2poly(p1, b[1]);\n\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(a, 512, 0, 0); \n\t\tfor (j=0; j < 2; j++)\n\t\t\t{\n\t\t\tBN_GF2m_mod_inv(c, a, b[j], ctx);\n\t\t\tBN_GF2m_mod_mul(d, a, c, b[j], ctx);\n#if 0 /* make test uses ouput in bc but bc can't handle GF(2^m) arithmetic */\n\t\t\tif (bp != NULL)\n\t\t\t\t{\n\t\t\t\tif (!results)\n\t\t\t\t\t{\n\t\t\t\t\tBN_print(bp,a);\n\t\t\t\t\tBIO_puts(bp, \" * \");\n\t\t\t\t\tBN_print(bp,c);\n\t\t\t\t\tBIO_puts(bp,\" - 1 % \");\n\t\t\t\t\tBN_print(bp,b[j]);\n\t\t\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t/* Test that ((1/a)*a) = 1. */\n\t\t\tif(!BN_is_one(d))\n\t\t\t\t{\n\t\t\t\tfprintf(stderr,\"GF(2^m) modular inversion test failed!\\n\");\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tret = 1;\n  err:\n\tBN_free(a);\n\tBN_free(b[0]);\n\tBN_free(b[1]);\n\tBN_free(c);\n\tBN_free(d);\n\treturn ret;\n\t}", "target": 1}
{"idx": 5114, "func": "static ngx_int_t\nngx_http_alloc_large_header_buffer(ngx_http_request_t *r,\n    ngx_uint_t request_line)\n{\n    u_char                    *old, *new;\n    ngx_buf_t                 *b;\n    ngx_http_connection_t     *hc;\n    ngx_http_core_srv_conf_t  *cscf;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http alloc large header buffer\");\n\n    if (request_line && r->state == 0) {\n\n        /* the client fills up the buffer with \"\\r\\n\" */\n\n        r->header_in->pos = r->header_in->start;\n        r->header_in->last = r->header_in->start;\n\n        return NGX_OK;\n    }\n\n    old = request_line ? r->request_start : r->header_name_start;\n\n    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n\n    if (r->state != 0\n        && (size_t) (r->header_in->pos - old)\n                                     >= cscf->large_client_header_buffers.size)\n    {\n        return NGX_DECLINED;\n    }\n\n    hc = r->http_connection;\n\n    if (hc->nfree) {\n        b = hc->free[--hc->nfree];\n\n        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"http large header free: %p %uz\",\n                       b->pos, b->end - b->last);\n\n    } else if (hc->nbusy < cscf->large_client_header_buffers.num) {\n\n        if (hc->busy == NULL) {\n            hc->busy = ngx_palloc(r->connection->pool,\n                  cscf->large_client_header_buffers.num * sizeof(ngx_buf_t *));\n            if (hc->busy == NULL) {\n                return NGX_ERROR;\n            }\n        }\n\n        b = ngx_create_temp_buf(r->connection->pool,\n                                cscf->large_client_header_buffers.size);\n        if (b == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"http large header alloc: %p %uz\",\n                       b->pos, b->end - b->last);\n\n    } else {\n        return NGX_DECLINED;\n    }\n\n    hc->busy[hc->nbusy++] = b;\n\n    if (r->state == 0) {\n        /*\n         * r->state == 0 means that a header line was parsed successfully\n         * and we do not need to copy incomplete header line and\n         * to relocate the parser header pointers\n         */\n\n        r->header_in = b;\n\n        return NGX_OK;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http large header copy: %uz\", r->header_in->pos - old);\n\n    new = b->start;\n\n    ngx_memcpy(new, old, r->header_in->pos - old);\n\n    b->pos = new + (r->header_in->pos - old);\n    b->last = new + (r->header_in->pos - old);\n\n    if (request_line) {\n        r->request_start = new;\n\n        if (r->request_end) {\n            r->request_end = new + (r->request_end - old);\n        }\n\n        r->method_end = new + (r->method_end - old);\n\n        r->uri_start = new + (r->uri_start - old);\n        r->uri_end = new + (r->uri_end - old);\n\n        if (r->schema_start) {\n            r->schema_start = new + (r->schema_start - old);\n            r->schema_end = new + (r->schema_end - old);\n        }\n\n        if (r->host_start) {\n            r->host_start = new + (r->host_start - old);\n            if (r->host_end) {\n                r->host_end = new + (r->host_end - old);\n            }\n        }\n\n        if (r->port_start) {\n            r->port_start = new + (r->port_start - old);\n            r->port_end = new + (r->port_end - old);\n        }\n\n        if (r->uri_ext) {\n            r->uri_ext = new + (r->uri_ext - old);\n        }\n\n        if (r->args_start) {\n            r->args_start = new + (r->args_start - old);\n        }\n\n        if (r->http_protocol.data) {\n            r->http_protocol.data = new + (r->http_protocol.data - old);\n        }\n\n    } else {\n        r->header_name_start = new;\n        r->header_name_end = new + (r->header_name_end - old);\n        r->header_start = new + (r->header_start - old);\n        r->header_end = new + (r->header_end - old);\n    }\n\n    r->header_in = b;\n\n    return NGX_OK;\n}", "target": 1}
{"idx": 5115, "func": "int ff_mov_lang_to_iso639(unsigned code, char *to)\n{\n    int i;\n    /* is it the mangled iso code? */\n    /* see http://www.geocities.com/xhelmboyx/quicktime/formats/mp4-layout.txt */\n    if (code > 138) {\n        for (i = 2; i >= 0; i--) {\n            to[i] = 0x60 + (code & 0x1f);\n            code >>= 5;\n        }\n        return 1;\n    }\n    /* old fashion apple lang code */\n    if (code >= FF_ARRAY_ELEMS(mov_mdhd_language_map))\n        return 0;\n    if (!mov_mdhd_language_map[code])\n        return 0;\n    strncpy(to, mov_mdhd_language_map[code], 4);\n    return 1;\n}", "target": 0}
{"idx": 5116, "func": "int BLAKE2s_Update(BLAKE2S_CTX *c, const void *data, size_t datalen)\n{\n    const uint8_t *in = data;\n    size_t fill;\n\n    /*\n     * Intuitively one would expect intermediate buffer, c->buf, to\n     * store incomplete blocks. But in this case we are interested to\n     * temporarily stash even complete blocks, because last one in the\n     * stream has to be treated in special way, and at this point we\n     * don't know if last block in *this* call is last one \"ever\". This\n     * is the reason for why |datalen| is compared as >, and not >=.\n     */\n    fill = sizeof(c->buf) - c->buflen;\n    if (datalen > fill) {\n        if (c->buflen) {\n            memcpy(c->buf + c->buflen, in, fill); /* Fill buffer */\n            blake2s_compress(c, c->buf, BLAKE2S_BLOCKBYTES);\n            c->buflen = 0;\n            in += fill;\n            datalen -= fill;\n        }\n        if (datalen > BLAKE2S_BLOCKBYTES)  {\n            size_t stashlen = datalen % BLAKE2S_BLOCKBYTES;\n            /*\n\t     * If |datalen| is a multiple of the blocksize, stash\n\t     * last complete block, it can be final one...\n             */\n            stashlen = stashlen ? stashlen : BLAKE2S_BLOCKBYTES;\n            datalen -= stashlen;\n            blake2s_compress(c, in, datalen);\n            in += datalen;\n            datalen = stashlen;\n        }\n    }\n\n    assert(datalen <= BLAKE2S_BLOCKBYTES);\n\n    memcpy(c->buf + c->buflen, in, datalen);\n    c->buflen += datalen; /* Be lazy, do not compress */\n\n    return 1;\n}", "target": 0}
{"idx": 5117, "func": "static void rv34_output_i16x16(RV34DecContext *r, int8_t *intra_types, int cbp)\n{\n    LOCAL_ALIGNED_16(DCTELEM, block16, [16]);\n    MpegEncContext *s    = &r->s;\n    GetBitContext  *gb   = &s->gb;\n    int             q_dc = rv34_qscale_tab[ r->luma_dc_quant_i[s->qscale] ],\n                    q_ac = rv34_qscale_tab[s->qscale];\n    uint8_t        *dst  = s->dest[0];\n    DCTELEM        *ptr  = s->block[0];\n    int i, j, itype, has_ac;\n\n    memset(block16, 0, 16 * sizeof(*block16));\n\n    has_ac = rv34_decode_block(block16, gb, r->cur_vlcs, 3, 0, q_dc, q_dc, q_ac);\n    if(has_ac)\n        r->rdsp.rv34_inv_transform(block16);\n    else\n        r->rdsp.rv34_inv_transform_dc(block16);\n\n    itype = ittrans16[intra_types[0]];\n    itype = adjust_pred16(itype, r->avail_cache[6-4], r->avail_cache[6-1]);\n    r->h.pred16x16[itype](dst, s->linesize);\n\n    for(j = 0; j < 4; j++){\n        for(i = 0; i < 4; i++, cbp >>= 1){\n            int dc = block16[i + j*4];\n\n            if(cbp & 1){\n                has_ac = rv34_decode_block(ptr, gb, r->cur_vlcs, r->luma_vlc, 0, q_ac, q_ac, q_ac);\n            }else\n                has_ac = 0;\n\n            if(has_ac){\n                ptr[0] = dc;\n                r->rdsp.rv34_idct_add(dst+4*i, s->linesize, ptr);\n            }else\n                r->rdsp.rv34_idct_dc_add(dst+4*i, s->linesize, dc);\n        }\n\n        dst += 4*s->linesize;\n    }\n\n    itype = ittrans16[intra_types[0]];\n    if(itype == PLANE_PRED8x8) itype = DC_PRED8x8;\n    itype = adjust_pred16(itype, r->avail_cache[6-4], r->avail_cache[6-1]);\n\n    q_dc = rv34_qscale_tab[rv34_chroma_quant[1][s->qscale]];\n    q_ac = rv34_qscale_tab[rv34_chroma_quant[0][s->qscale]];\n\n    for(j = 1; j < 3; j++){\n        dst = s->dest[j];\n        r->h.pred8x8[itype](dst, s->uvlinesize);\n        for(i = 0; i < 4; i++, cbp >>= 1){\n            uint8_t *pdst;\n            if(!(cbp & 1)) continue;\n            pdst   = dst + (i&1)*4 + (i&2)*2*s->uvlinesize;\n\n            rv34_process_block(r, pdst, s->uvlinesize,\n                               r->chroma_vlc, 1, q_dc, q_ac);\n        }\n    }\n}", "target": 1}
{"idx": 5118, "func": "int tls_construct_client_certificate(SSL *s, WPACKET *pkt)\n{\n    if (SSL_IS_TLS13(s)) {\n        if (s->pha_context == NULL) {\n            /* no context available, add 0-length context */\n            if (!WPACKET_put_bytes_u8(pkt, 0)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_CONSTRUCT_CLIENT_CERTIFICATE, ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n        } else if (!WPACKET_sub_memcpy_u8(pkt, s->pha_context, s->pha_context_len)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_CONSTRUCT_CLIENT_CERTIFICATE, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n    if (!ssl3_output_cert_chain(s, pkt,\n                                (s->s3->tmp.cert_req == 2) ? NULL\n                                                           : s->cert->key)) {\n        /* SSLfatal() already called */\n        return 0;\n    }\n\n    if (SSL_IS_TLS13(s)\n            && SSL_IS_FIRST_HANDSHAKE(s)\n            && (!s->method->ssl3_enc->change_cipher_state(s,\n                    SSL3_CC_HANDSHAKE | SSL3_CHANGE_CIPHER_CLIENT_WRITE))) {\n        /*\n         * This is a fatal error, which leaves enc_write_ctx in an inconsistent\n         * state and thus ssl3_send_alert may crash.\n         */\n        SSLfatal(s, SSL_AD_NO_ALERT, SSL_F_TLS_CONSTRUCT_CLIENT_CERTIFICATE,\n                 SSL_R_CANNOT_CHANGE_CIPHER);\n        return 0;\n    }\n\n    return 1;\n}", "target": 0}
{"idx": 5119, "func": "static int add_shorts_metadata(const uint8_t **buf, int count, const char *name,\n                               const char *sep, TiffContext *s)\n{\n    char *ap;\n    int i;\n    int *sp = av_malloc(count * sizeof(int));\n    if (!sp)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < count; i++)\n        sp[i] = tget_short(buf, s->le);\n    ap = shorts2str(sp, count, sep);\n    av_freep(&sp);\n    if (!ap)\n        return AVERROR(ENOMEM);\n    av_dict_set(&s->picture.metadata, name, ap, AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}", "target": 1}
{"idx": 5120, "func": "static void x509_verify_param_zero(X509_VERIFY_PARAM *param)\n\t{\n\tX509_VERIFY_PARAM_ID *paramid;\n\tif (!param)\n\t\treturn;\n\tparam->name = NULL;\n\tparam->purpose = 0;\n\tparam->trust = 0;\n\t/*param->inh_flags = X509_VP_FLAG_DEFAULT;*/\n\tparam->inh_flags = 0;\n\tparam->flags = 0;\n\tparam->depth = -1;\n\tif (param->policies)\n\t\t{\n\t\tsk_ASN1_OBJECT_pop_free(param->policies, ASN1_OBJECT_free);\n\t\tparam->policies = NULL;\n\t\t}\n\tparamid = param->id;\n\tif (paramid->host)\n\t\t{\n\t\tOPENSSL_free(paramid->host);\n\t\tparamid->host = NULL;\n\t\tparamid->hostlen = 0;\n\t\t}\n\tif (paramid->email)\n\t\t{\n\t\tOPENSSL_free(paramid->email);\n\t\tparamid->email = NULL;\n\t\tparamid->emaillen = 0;\n\t\t}\n\tif (paramid->ip)\n\t\t{\n\t\tOPENSSL_free(paramid->ip);\n\t\tparamid->ip = NULL;\n\t\tparamid->iplen = 0;\n\t\t}\n\n\t}", "target": 0}
{"idx": 5121, "func": "AP_DECLARE(int) ap_getline(char *s, int n, request_rec *r, int flags)\n{\n    char *tmp_s = s;\n    apr_status_t rv;\n    apr_size_t len;\n    apr_bucket_brigade *tmp_bb;\n\n    if (n < 1) {\n        /* Can't work since we always NUL terminate */\n        return -1;\n    }\n\n    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    rv = ap_rgetline(&tmp_s, n, &len, r, flags, tmp_bb);\n    apr_brigade_destroy(tmp_bb);\n\n    /* Map the out-of-space condition to the old API. */\n    if (rv == APR_ENOSPC) {\n        return n;\n    }\n\n    /* Anything else is just bad. */\n    if (rv != APR_SUCCESS) {\n        return -1;\n    }\n\n    return (int)len;\n}", "target": 0}
{"idx": 5122, "func": "static uint64_t calc_rice_params(RiceContext *rc, int pmin, int pmax,\n                                 int32_t *data, int n, int pred_order)\n{\n    int i;\n    uint64_t bits[MAX_PARTITION_ORDER+1];\n    int opt_porder;\n    RiceContext tmp_rc;\n    uint64_t sums[MAX_PARTITION_ORDER + 1][MAX_PARTITIONS] = { { 0 } };\n\n    assert(pmin >= 0 && pmin <= MAX_PARTITION_ORDER);\n    assert(pmax >= 0 && pmax <= MAX_PARTITION_ORDER);\n    assert(pmin <= pmax);\n\n    tmp_rc.coding_mode = rc->coding_mode;\n\n    for (i = 0; i < n; i++)\n        rc->udata[i] = (2 * data[i]) ^ (data[i] >> 31);\n\n    calc_sums(pmin, pmax, rc->udata, n, pred_order, sums);\n\n    opt_porder = pmin;\n    bits[pmin] = UINT32_MAX;\n    for (i = pmin; i <= pmax; i++) {\n        bits[i] = calc_optimal_rice_params(&tmp_rc, i, sums[i], n, pred_order);\n        if (bits[i] <= bits[opt_porder]) {\n            opt_porder = i;\n            *rc = tmp_rc;\n        }\n    }\n\n    return bits[opt_porder];\n}", "target": 0}
{"idx": 5123, "func": "static int read_frame_internal(AVFormatContext *s, AVPacket *pkt)\n{\n    int ret = 0, i, got_packet = 0;\n\n    av_init_packet(pkt);\n\n    while (!got_packet && !s->parse_queue) {\n        AVStream *st;\n        AVPacket cur_pkt;\n\n        /* read next packet */\n        ret = av_read_packet(s, &cur_pkt);\n        if (ret < 0) {\n            if (ret == AVERROR(EAGAIN))\n                return ret;\n            /* flush the parsers */\n            for(i = 0; i < s->nb_streams; i++) {\n                st = s->streams[i];\n                if (st->parser && st->need_parsing)\n                    parse_packet(s, NULL, st->index);\n            }\n            /* all remaining packets are now in parse_queue =>\n             * really terminate parsing */\n            break;\n        }\n        ret = 0;\n        st  = s->streams[cur_pkt.stream_index];\n\n        if (cur_pkt.pts != AV_NOPTS_VALUE &&\n            cur_pkt.dts != AV_NOPTS_VALUE &&\n            cur_pkt.pts < cur_pkt.dts) {\n            av_log(s, AV_LOG_WARNING, \"Invalid timestamps stream=%d, pts=%\"PRId64\", dts=%\"PRId64\", size=%d\\n\",\n                   cur_pkt.stream_index,\n                   cur_pkt.pts,\n                   cur_pkt.dts,\n                   cur_pkt.size);\n        }\n        if (s->debug & FF_FDEBUG_TS)\n            av_log(s, AV_LOG_DEBUG, \"av_read_packet stream=%d, pts=%\"PRId64\", dts=%\"PRId64\", size=%d, duration=%d, flags=%d\\n\",\n                   cur_pkt.stream_index,\n                   cur_pkt.pts,\n                   cur_pkt.dts,\n                   cur_pkt.size,\n                   cur_pkt.duration,\n                   cur_pkt.flags);\n\n        if (st->need_parsing && !st->parser && !(s->flags & AVFMT_FLAG_NOPARSE)) {\n            st->parser = av_parser_init(st->codec->codec_id);\n            if (!st->parser) {\n                /* no parser available: just output the raw packets */\n                st->need_parsing = AVSTREAM_PARSE_NONE;\n            } else if(st->need_parsing == AVSTREAM_PARSE_HEADERS) {\n                st->parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;\n            } else if(st->need_parsing == AVSTREAM_PARSE_FULL_ONCE) {\n                st->parser->flags |= PARSER_FLAG_ONCE;\n            }\n        }\n\n        if (!st->need_parsing || !st->parser) {\n            /* no parsing needed: we just output the packet as is */\n            *pkt = cur_pkt;\n            compute_pkt_fields(s, st, NULL, pkt);\n            if ((s->iformat->flags & AVFMT_GENERIC_INDEX) &&\n                (pkt->flags & AV_PKT_FLAG_KEY) && pkt->dts != AV_NOPTS_VALUE) {\n                ff_reduce_index(s, st->index);\n                av_add_index_entry(st, pkt->pos, pkt->dts, 0, 0, AVINDEX_KEYFRAME);\n            }\n            got_packet = 1;\n        } else if (st->discard < AVDISCARD_ALL) {\n            if ((ret = parse_packet(s, &cur_pkt, cur_pkt.stream_index)) < 0)\n                return ret;\n        } else {\n            /* free packet */\n            av_free_packet(&cur_pkt);\n        }\n    }\n\n    if (!got_packet && s->parse_queue)\n        ret = read_from_packet_buffer(&s->parse_queue, &s->parse_queue_end, pkt);\n\n    if(s->debug & FF_FDEBUG_TS)\n        av_log(s, AV_LOG_DEBUG, \"read_frame_internal stream=%d, pts=%\"PRId64\", dts=%\"PRId64\", size=%d, duration=%d, flags=%d\\n\",\n            pkt->stream_index,\n            pkt->pts,\n            pkt->dts,\n            pkt->size,\n            pkt->duration,\n            pkt->flags);\n\n    return ret;\n}", "target": 0}
{"idx": 5124, "func": "static void wmv2_idct_row(short * b)\n{\n    int s1, s2;\n    int a0, a1, a2, a3, a4, a5, a6, a7;\n\n    /* step 1 */\n    a1 = W1 * b[1] + W7 * b[7];\n    a7 = W7 * b[1] - W1 * b[7];\n    a5 = W5 * b[5] + W3 * b[3];\n    a3 = W3 * b[5] - W5 * b[3];\n    a2 = W2 * b[2] + W6 * b[6];\n    a6 = W6 * b[2] - W2 * b[6];\n    a0 = W0 * b[0] + W0 * b[4];\n    a4 = W0 * b[0] - W0 * b[4];\n\n    /* step 2 */\n    s1 = (int)(181U * (a1 - a5 + a7 - a3) + 128) >> 8; // 1, 3, 5, 7\n    s2 = (int)(181U * (a1 - a5 - a7 + a3) + 128) >> 8;\n\n    /* step 3 */\n    b[0] = (a0 + a2 + a1 + a5 + (1 << 7)) >> 8;\n    b[1] = (a4 + a6 + s1      + (1 << 7)) >> 8;\n    b[2] = (a4 - a6 + s2      + (1 << 7)) >> 8;\n    b[3] = (a0 - a2 + a7 + a3 + (1 << 7)) >> 8;\n    b[4] = (a0 - a2 - a7 - a3 + (1 << 7)) >> 8;\n    b[5] = (a4 - a6 - s2      + (1 << 7)) >> 8;\n    b[6] = (a4 + a6 - s1      + (1 << 7)) >> 8;\n    b[7] = (a0 + a2 - a1 - a5 + (1 << 7)) >> 8;\n}", "target": 0}
{"idx": 5125, "func": "static int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = 0;\n    for (i=0; i<7; i++) {\n        if (v1[i] > v2[i]) {\n            /* v1 is larger... but by how much? */\n            if (v1[i] != v2[i] + 1)\n                return 128;\n            while (++i <= 6) {\n                if (v1[i] != 0x00 || v2[i] != 0xff)\n                    return 128; /* too much */\n            }\n            /* We checked all the way to the penultimate byte,\n             * so despite higher bytes changing we actually\n             * know that it only changed from (e.g.)\n             *       ... (xx)  ff ff ff ??\n             * to   ... (xx+1) 00 00 00 ??\n             * so we add a 'bias' of 256 for the carry that\n             * happened, and will eventually return\n             * 256 + v1[7] - v2[7]. */\n            ret = 256;\n            break;\n        } else if (v2[i] > v1[i]) {\n            /* v2 is larger... but by how much? */\n            if (v2[i] != v1[i] + 1)\n                return -128;\n            while (++i <= 6) {\n                if (v2[i] != 0x00 || v1[i] != 0xff)\n                    return -128; /* too much */\n            }\n            /* Similar to the case above, we know it changed\n             * from    ... (xx)  00 00 00 ??\n             * to     ... (xx-1) ff ff ff ??\n             * so we add a 'bias' of -256 for the borrow,\n             * to return -256 + v1[7] - v2[7]. */\n            ret = -256;\n        }\n    }\n\n    ret += (int)v1[7] - (int)v2[7];\n\n    if (ret > 128)\n        return 128;\n    else if (ret < -128)\n        return -128;\n    else\n        return ret;\n}", "target": 0}
{"idx": 5126, "func": "ngx_int_t\nngx_http_core_try_files_phase(ngx_http_request_t *r,\n    ngx_http_phase_handler_t *ph)\n{\n    size_t                        len, root, alias, reserve, allocated;\n    u_char                       *p, *name;\n    ngx_str_t                     path, args;\n    ngx_uint_t                    test_dir;\n    ngx_http_try_file_t          *tf;\n    ngx_open_file_info_t          of;\n    ngx_http_script_code_pt       code;\n    ngx_http_script_engine_t      e;\n    ngx_http_core_loc_conf_t     *clcf;\n    ngx_http_script_len_code_pt   lcode;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"try files phase: %ui\", r->phase_handler);\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf->try_files == NULL) {\n        r->phase_handler++;\n        return NGX_AGAIN;\n    }\n\n    allocated = 0;\n    root = 0;\n    name = NULL;\n    /* suppress MSVC warning */\n    path.data = NULL;\n\n    tf = clcf->try_files;\n\n    alias = clcf->alias;\n\n    for ( ;; ) {\n\n        if (tf->lengths) {\n            ngx_memzero(&e, sizeof(ngx_http_script_engine_t));\n\n            e.ip = tf->lengths->elts;\n            e.request = r;\n\n            /* 1 is for terminating '\\0' as in static names */\n            len = 1;\n\n            while (*(uintptr_t *) e.ip) {\n                lcode = *(ngx_http_script_len_code_pt *) e.ip;\n                len += lcode(&e);\n            }\n\n        } else {\n            len = tf->name.len;\n        }\n\n        if (!alias) {\n            reserve = len > r->uri.len ? len - r->uri.len : 0;\n\n        } else if (alias == NGX_MAX_SIZE_T_VALUE) {\n            reserve = len;\n\n        } else {\n            reserve = len > r->uri.len - alias ? len - (r->uri.len - alias) : 0;\n        }\n\n        if (reserve > allocated || !allocated) {\n\n            /* 16 bytes are preallocation */\n            allocated = reserve + 16;\n\n            if (ngx_http_map_uri_to_path(r, &path, &root, allocated) == NULL) {\n                ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n                return NGX_OK;\n            }\n\n            name = path.data + root;\n        }\n\n        if (tf->values == NULL) {\n\n            /* tf->name.len includes the terminating '\\0' */\n\n            ngx_memcpy(name, tf->name.data, tf->name.len);\n\n            path.len = (name + tf->name.len - 1) - path.data;\n\n        } else {\n            e.ip = tf->values->elts;\n            e.pos = name;\n            e.flushed = 1;\n\n            while (*(uintptr_t *) e.ip) {\n                code = *(ngx_http_script_code_pt *) e.ip;\n                code((ngx_http_script_engine_t *) &e);\n            }\n\n            path.len = e.pos - path.data;\n\n            *e.pos = '\\0';\n\n            if (alias && alias != NGX_MAX_SIZE_T_VALUE\n                && ngx_strncmp(name, r->uri.data, alias) == 0)\n            {\n                ngx_memmove(name, name + alias, len - alias);\n                path.len -= alias;\n            }\n        }\n\n        test_dir = tf->test_dir;\n\n        tf++;\n\n        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"trying to use %s: \\\"%s\\\" \\\"%s\\\"\",\n                       test_dir ? \"dir\" : \"file\", name, path.data);\n\n        if (tf->lengths == NULL && tf->name.len == 0) {\n\n            if (tf->code) {\n                ngx_http_finalize_request(r, tf->code);\n                return NGX_OK;\n            }\n\n            path.len -= root;\n            path.data += root;\n\n            if (path.data[0] == '@') {\n                (void) ngx_http_named_location(r, &path);\n\n            } else {\n                ngx_http_split_args(r, &path, &args);\n\n                (void) ngx_http_internal_redirect(r, &path, &args);\n            }\n\n            ngx_http_finalize_request(r, NGX_DONE);\n            return NGX_OK;\n        }\n\n        ngx_memzero(&of, sizeof(ngx_open_file_info_t));\n\n        of.read_ahead = clcf->read_ahead;\n        of.directio = clcf->directio;\n        of.valid = clcf->open_file_cache_valid;\n        of.min_uses = clcf->open_file_cache_min_uses;\n        of.test_only = 1;\n        of.errors = clcf->open_file_cache_errors;\n        of.events = clcf->open_file_cache_events;\n\n        if (ngx_http_set_disable_symlinks(r, clcf, &path, &of) != NGX_OK) {\n            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return NGX_OK;\n        }\n\n        if (ngx_open_cached_file(clcf->open_file_cache, &path, &of, r->pool)\n            != NGX_OK)\n        {\n            if (of.err == 0) {\n                ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n                return NGX_OK;\n            }\n\n            if (of.err != NGX_ENOENT\n                && of.err != NGX_ENOTDIR\n                && of.err != NGX_ENAMETOOLONG)\n            {\n                ngx_log_error(NGX_LOG_CRIT, r->connection->log, of.err,\n                              \"%s \\\"%s\\\" failed\", of.failed, path.data);\n            }\n\n            continue;\n        }\n\n        if (of.is_dir != test_dir) {\n            continue;\n        }\n\n        path.len -= root;\n        path.data += root;\n\n        if (!alias) {\n            r->uri = path;\n\n        } else if (alias == NGX_MAX_SIZE_T_VALUE) {\n            if (!test_dir) {\n                r->uri = path;\n                r->add_uri_to_alias = 1;\n            }\n\n        } else {\n            name = r->uri.data;\n\n            r->uri.len = alias + path.len;\n            r->uri.data = ngx_pnalloc(r->pool, r->uri.len);\n            if (r->uri.data == NULL) {\n                r->uri.len = 0;\n                ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n                return NGX_OK;\n            }\n\n            p = ngx_copy(r->uri.data, name, alias);\n            ngx_memcpy(p, path.data, path.len);\n        }\n\n        ngx_http_set_exten(r);\n\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"try file uri: \\\"%V\\\"\", &r->uri);\n\n        r->phase_handler++;\n        return NGX_AGAIN;\n    }\n\n    /* not reached */\n}", "target": 0}
{"idx": 5127, "func": "static int resample(ResampleContext *c, int16_t *dst, const int16_t *src,\n                    int *consumed, int src_size, int dst_size, int update_ctx)\n{\n    int dst_index, i;\n    int index         = c->index;\n    int frac          = c->frac;\n    int dst_incr_frac = c->dst_incr % c->src_incr;\n    int dst_incr      = c->dst_incr / c->src_incr;\n    int compensation_distance = c->compensation_distance;\n\n    if (!dst != !src)\n        return AVERROR(EINVAL);\n\n    if (compensation_distance == 0 && c->filter_length == 1 &&\n        c->phase_shift == 0) {\n        int64_t index2 = ((int64_t)index) << 32;\n        int64_t incr   = (1LL << 32) * c->dst_incr / c->src_incr;\n        dst_size       = FFMIN(dst_size,\n                               (src_size-1-index) * (int64_t)c->src_incr /\n                               c->dst_incr);\n\n        if (dst) {\n            for(dst_index = 0; dst_index < dst_size; dst_index++) {\n                dst[dst_index] = src[index2 >> 32];\n                index2 += incr;\n            }\n        } else {\n            dst_index = dst_size;\n        }\n        index += dst_index * dst_incr;\n        index += (frac + dst_index * (int64_t)dst_incr_frac) / c->src_incr;\n        frac   = (frac + dst_index * (int64_t)dst_incr_frac) % c->src_incr;\n    } else {\n        for (dst_index = 0; dst_index < dst_size; dst_index++) {\n            FELEM *filter = c->filter_bank +\n                            c->filter_length * (index & c->phase_mask);\n            int sample_index = index >> c->phase_shift;\n\n            if (!dst && (sample_index + c->filter_length > src_size ||\n                         -sample_index >= src_size))\n                break;\n\n            if (dst) {\n                FELEM2 val = 0;\n\n                if (sample_index < 0) {\n                    for (i = 0; i < c->filter_length; i++)\n                        val += src[FFABS(sample_index + i) % src_size] *\n                               (FELEM2)filter[i];\n                } else if (sample_index + c->filter_length > src_size) {\n                    break;\n                } else if (c->linear) {\n                    FELEM2 v2 = 0;\n                    for (i = 0; i < c->filter_length; i++) {\n                        val += src[abs(sample_index + i)] * (FELEM2)filter[i];\n                        v2  += src[abs(sample_index + i)] * (FELEM2)filter[i + c->filter_length];\n                    }\n                    val += (v2 - val) * (FELEML)frac / c->src_incr;\n                } else {\n                    for (i = 0; i < c->filter_length; i++)\n                        val += src[sample_index + i] * (FELEM2)filter[i];\n                }\n\n#ifdef CONFIG_RESAMPLE_FLT\n                dst[dst_index] = av_clip_int16(lrintf(val));\n#else\n                val = (val + (1<<(FILTER_SHIFT-1)))>>FILTER_SHIFT;\n                dst[dst_index] = av_clip_int16(val);\n#endif\n            }\n\n            frac  += dst_incr_frac;\n            index += dst_incr;\n            if (frac >= c->src_incr) {\n                frac -= c->src_incr;\n                index++;\n            }\n            if (dst_index + 1 == compensation_distance) {\n                compensation_distance = 0;\n                dst_incr_frac = c->ideal_dst_incr % c->src_incr;\n                dst_incr      = c->ideal_dst_incr / c->src_incr;\n            }\n        }\n    }\n    if (consumed)\n        *consumed = FFMAX(index, 0) >> c->phase_shift;\n\n    if (update_ctx) {\n        if (index >= 0)\n            index &= c->phase_mask;\n\n        if (compensation_distance) {\n            compensation_distance -= dst_index;\n            if (compensation_distance <= 0)\n                return AVERROR_BUG;\n        }\n        c->frac     = frac;\n        c->index    = index;\n        c->dst_incr = dst_incr_frac + c->src_incr*dst_incr;\n        c->compensation_distance = compensation_distance;\n    }\n\n    return dst_index;\n}", "target": 1}
{"idx": 5128, "func": "int help_main(int argc, char **argv)\n{\n    FUNCTION *fp;\n    int i, nl;\n    FUNC_TYPE tp;\n    char *prog;\n    HELPLIST_CHOICE o;\n\n    prog = opt_init(argc, argv, help_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        default:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            return 1;\n        case OPT_HELP:\n            opt_help(help_options);\n            return 0;\n        }\n    }\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (argc != 0) {\n        BIO_printf(bio_err, \"Usage: %s\\n\", prog);\n        return 1;\n    }\n\n    BIO_printf(bio_err, \"\\nStandard commands\");\n    i = 0;\n    tp = FT_none;\n    for (fp = functions; fp->name != NULL; fp++) {\n        nl = 0;\n        if (((i++) % COLUMNS) == 0) {\n            BIO_printf(bio_err, \"\\n\");\n            nl = 1;\n        }\n        if (fp->type != tp) {\n            tp = fp->type;\n            if (!nl)\n                BIO_printf(bio_err, \"\\n\");\n            if (tp == FT_md) {\n                i = 1;\n                BIO_printf(bio_err,\n                           \"\\nMessage Digest commands (see the `dgst' command for more details)\\n\");\n            } else if (tp == FT_cipher) {\n                i = 1;\n                BIO_printf(bio_err,\n                           \"\\nCipher commands (see the `enc' command for more details)\\n\");\n            }\n        }\n        BIO_printf(bio_err, FORMAT, fp->name);\n    }\n    BIO_printf(bio_err, \"\\n\\n\");\n    return 0;\n}", "target": 1}
{"idx": 5129, "func": "int engine_unlocked_init(ENGINE *e)\n{\n    int to_return = 1;\n\n    if ((e->funct_ref == 0) && e->init)\n        /*\n         * This is the first functional reference and the engine requires\n         * initialisation so we do it now.\n         */\n        to_return = e->init(e);\n    if (to_return) {\n        /*\n         * OK, we return a functional reference which is also a structural\n         * reference.\n         */\n        e->struct_ref++;\n        e->funct_ref++;\n        engine_ref_debug(e, 0, 1);\n        engine_ref_debug(e, 1, 1);\n    }\n    return to_return;\n}", "target": 1}
{"idx": 5130, "func": "static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n                                      int buf_size, AVSubtitle *sub)\n{\n    DVBSubContext *ctx = avctx->priv_data;\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n\n    DVBSubRegion *region;\n    DVBSubRegionDisplay *display;\n    AVSubtitleRect *rect;\n    DVBSubCLUT *clut;\n    uint32_t *clut_table;\n    int i;\n    int offset_x=0, offset_y=0;\n\n    sub->rects = NULL;\n    sub->start_display_time = 0;\n    sub->end_display_time = ctx->time_out * 1000;\n    sub->format = 0;\n\n    if (display_def) {\n        offset_x = display_def->x;\n        offset_y = display_def->y;\n    }\n\n    sub->num_rects = ctx->display_list_size;\n\n    if (sub->num_rects > 0) {\n        sub->rects = av_mallocz(sizeof(*sub->rects) * sub->num_rects);\n        if (!sub->rects)\n            return AVERROR(ENOMEM);\n        for (i = 0; i < sub->num_rects; i++) {\n            sub->rects[i] = av_mallocz(sizeof(*sub->rects[i]));\n            if (!sub->rects[i]) {\n                return AVERROR(ENOMEM);\n            }\n        }\n    }\n\n    i = 0;\n\n    for (display = ctx->display_list; display; display = display->next) {\n        region = get_region(ctx, display->region_id);\n        rect = sub->rects[i];\n\n        if (!region)\n            continue;\n\n        rect->x = display->x_pos + offset_x;\n        rect->y = display->y_pos + offset_y;\n        rect->w = region->width;\n        rect->h = region->height;\n        rect->nb_colors = 16;\n        rect->type      = SUBTITLE_BITMAP;\n        rect->linesize[0] = region->width;\n\n        clut = get_clut(ctx, region->clut);\n\n        if (!clut)\n            clut = &default_clut;\n\n        switch (region->depth) {\n        case 2:\n            clut_table = clut->clut4;\n            break;\n        case 8:\n            clut_table = clut->clut256;\n            break;\n        case 4:\n        default:\n            clut_table = clut->clut16;\n            break;\n        }\n\n        rect->data[1] = av_mallocz(AVPALETTE_SIZE);\n        if (!rect->data[1]) {\n            av_free(sub->rects);\n            return AVERROR(ENOMEM);\n        }\n        memcpy(rect->data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n        rect->data[0] = av_malloc(region->buf_size);\n        if (!rect->data[0]) {\n            av_free(rect->data[1]);\n            av_free(sub->rects);\n            return AVERROR(ENOMEM);\n        }\n        memcpy(rect->data[0], region->pbuf, region->buf_size);\n\n#if FF_API_AVPICTURE\nFF_DISABLE_DEPRECATION_WARNINGS\n{\n        int j;\n        for (j = 0; j < 4; j++) {\n            rect->pict.data[j] = rect->data[j];\n            rect->pict.linesize[j] = rect->linesize[j];\n        }\n}\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n        i++;\n    }\n\n    sub->num_rects = i;\n\n#ifdef DEBUG\n    save_display_set(ctx);\n#endif\n\n    return 1;\n}", "target": 0}
{"idx": 5131, "func": "static void\nngx_resolver_srv_names_handler(ngx_resolver_ctx_t *cctx)\n{\n    ngx_uint_t                i;\n    ngx_addr_t               *addrs;\n    ngx_resolver_t           *r;\n    ngx_sockaddr_t           *sockaddr;\n    ngx_resolver_ctx_t       *ctx;\n    ngx_resolver_srv_name_t  *srv;\n\n    r = cctx->resolver;\n    ctx = cctx->data;\n    srv = cctx->srvs;\n\n    ctx->count--;\n    ctx->async |= cctx->async;\n\n    srv->ctx = NULL;\n    srv->state = cctx->state;\n\n    if (cctx->naddrs) {\n\n        ctx->valid = ngx_min(ctx->valid, cctx->valid);\n\n        addrs = ngx_resolver_calloc(r, cctx->naddrs * sizeof(ngx_addr_t));\n        if (addrs == NULL) {\n            ngx_resolve_name_done(cctx);\n\n            ctx->state = NGX_ERROR;\n            ctx->valid = ngx_time() + (r->valid ? r->valid : 10);\n\n            ctx->handler(ctx);\n            return;\n        }\n\n        sockaddr = ngx_resolver_alloc(r, cctx->naddrs * sizeof(ngx_sockaddr_t));\n        if (sockaddr == NULL) {\n            ngx_resolver_free(r, addrs);\n            ngx_resolve_name_done(cctx);\n\n            ctx->state = NGX_ERROR;\n            ctx->valid = ngx_time() + (r->valid ? r->valid : 10);\n\n            ctx->handler(ctx);\n            return;\n        }\n\n        for (i = 0; i < cctx->naddrs; i++) {\n            addrs[i].sockaddr = &sockaddr[i].sockaddr;\n            addrs[i].socklen = cctx->addrs[i].socklen;\n\n            ngx_memcpy(&sockaddr[i], cctx->addrs[i].sockaddr,\n                       addrs[i].socklen);\n\n            ngx_inet_set_port(addrs[i].sockaddr, srv->port);\n        }\n\n        srv->addrs = addrs;\n        srv->naddrs = cctx->naddrs;\n    }\n\n    ngx_resolve_name_done(cctx);\n\n    if (ctx->count == 0) {\n        ngx_resolver_report_srv(r, ctx);\n    }\n}", "target": 1}
{"idx": 5132, "func": "static MpegTSService *mpegts_add_service(MpegTSWrite *ts, int sid,\n                                         const char *provider_name,\n                                         const char *name)\n{\n    MpegTSService *service;\n\n    service = av_mallocz(sizeof(MpegTSService));\n    if (!service)\n        return NULL;\n    service->pmt.pid       = ts->pmt_start_pid + ts->nb_services;\n    service->sid           = sid;\n    service->pcr_pid       = 0x1fff;\n    service->provider_name = av_strdup(provider_name);\n    service->name          = av_strdup(name);\n    if (!service->provider_name || !service->name) {\n        free(service->provider_name);\n        free(service->name);\n        free(service);\n        return NULL;\n    }\n    dynarray_add(&ts->services, &ts->nb_services, service);\n    return service;\n}", "target": 0}
{"idx": 5133, "func": "static int hls_read_seek(AVFormatContext *s, int stream_index,\n                               int64_t timestamp, int flags)\n{\n    HLSContext *c = s->priv_data;\n    struct playlist *seek_pls = NULL;\n    int i, seq_no;\n    int64_t seek_timestamp;\n\n    if ((flags & AVSEEK_FLAG_BYTE) || !c->variants[0]->playlists[0]->finished)\n        return AVERROR(ENOSYS);\n\n    seek_timestamp = av_rescale_rnd(timestamp, AV_TIME_BASE,\n                                    s->streams[stream_index]->time_base.den,\n                                    flags & AVSEEK_FLAG_BACKWARD ?\n                                    AV_ROUND_DOWN : AV_ROUND_UP);\n\n    if (s->duration < seek_timestamp)\n        return AVERROR(EIO);\n\n    /* find the playlist with the specified stream */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        if (stream_index >= pls->stream_offset &&\n            stream_index - pls->stream_offset < pls->ctx->nb_streams) {\n            seek_pls = pls;\n            break;\n        }\n    }\n    /* check if the timestamp is valid for the playlist with the\n     * specified stream index */\n    if (!seek_pls || !find_timestamp_in_playlist(c, seek_pls, seek_timestamp, &seq_no))\n        return AVERROR(EIO);\n\n    /* set segment now so we do not need to search again below */\n    seek_pls->cur_seq_no = seq_no;\n    seek_pls->seek_stream_index = stream_index - seek_pls->stream_offset;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        /* Reset reading */\n        struct playlist *pls = c->playlists[i];\n        if (pls->input) {\n            ffurl_close(pls->input);\n            pls->input = NULL;\n        }\n        av_free_packet(&pls->pkt);\n        reset_packet(&pls->pkt);\n        pls->pb.eof_reached = 0;\n        /* Clear any buffered data */\n        pls->pb.buf_end = pls->pb.buf_ptr = pls->pb.buffer;\n        /* Reset the pos, to let the mpegts demuxer know we've seeked. */\n        pls->pb.pos = 0;\n\n        pls->seek_timestamp = seek_timestamp;\n        pls->seek_flags = flags;\n\n        if (pls != seek_pls) {\n            /* set closest segment seq_no for playlists not handled above */\n            find_timestamp_in_playlist(c, pls, seek_timestamp, &pls->cur_seq_no);\n            /* seek the playlist to the given position without taking\n             * keyframes into account since this playlist does not have the\n             * specified stream where we should look for the keyframes */\n            pls->seek_stream_index = -1;\n            pls->seek_flags |= AVSEEK_FLAG_ANY;\n        }\n    }\n\n    c->cur_timestamp = seek_timestamp;\n\n    return 0;\n}", "target": 0}
{"idx": 5134, "func": "static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic,\n                                const uint8_t *src, int src_size)\n{\n    GetByteContext gb;\n    GetBitContext  gb2;\n    int nslices, slice, slice_height, ref_slice_height;\n    int cur_y, next_y;\n    uint32_t off, slice_size;\n    uint8_t *Y, *U, *V;\n    int ret;\n\n    bytestream2_init(&gb, src, src_size);\n    nslices = bytestream2_get_le16(&gb);\n    off = FFALIGN(nslices * 4 + 2, 16);\n    if (src_size < off) {\n        av_log(avctx, AV_LOG_ERROR, \"no slice data\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!nslices || avctx->height % nslices) {\n        avpriv_request_sample(avctx, \"%d slices for %dx%d\", nslices,\n                              avctx->width, avctx->height);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    ref_slice_height = avctx->height / nslices;\n    if ((avctx->width & 1) || (avctx->height & 1)) {\n        avpriv_request_sample(avctx, \"Frame dimensions %dx%d\",\n                              avctx->width, avctx->height);\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    Y = pic->data[0];\n    U = pic->data[1];\n    V = pic->data[2];\n\n    cur_y  = 0;\n    next_y = ref_slice_height;\n    for (slice = 0; slice < nslices; slice++) {\n        slice_size   = bytestream2_get_le32(&gb);\n        slice_height = (next_y & ~1) - (cur_y & ~1);\n        if (slice_size > src_size - off) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"invalid slice size %\"PRIu32\" (only %\"PRIu32\" bytes left)\\n\",\n                   slice_size, src_size - off);\n            return AVERROR_INVALIDDATA;\n        }\n        if (slice_size <= 16) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid slice size %\"PRIu32\"\\n\", slice_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (AV_RL32(src + off) != slice_size - 16) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Slice sizes mismatch: got %\"PRIu32\" instead of %\"PRIu32\"\\n\",\n                   AV_RL32(src + off), slice_size - 16);\n        }\n        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);\n        dx2_decode_slice_420(&gb2, avctx->width, slice_height, Y, U, V,\n                             pic->linesize[0], pic->linesize[1],\n                             pic->linesize[2]);\n\n        Y += pic->linesize[0] *  slice_height;\n        U += pic->linesize[1] * (slice_height >> 1);\n        V += pic->linesize[2] * (slice_height >> 1);\n        off += slice_size;\n        cur_y   = next_y;\n        next_y += ref_slice_height;\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5135, "func": "static ngx_int_t\nngx_http_find_virtual_server(ngx_http_request_t *r, u_char *host, size_t len)\n{\n    u_char                    *server;\n    ngx_uint_t                 hash;\n    ngx_http_core_loc_conf_t  *clcf;\n    ngx_http_core_srv_conf_t  *cscf;\n    u_char                     buf[32];\n\n    if (r->virtual_names == NULL) {\n        return NGX_DECLINED;\n    }\n\n    if (len <= 32) {\n        server = buf;\n\n    } else {\n        server = ngx_pnalloc(r->pool, len);\n        if (server == NULL) {\n            return NGX_ERROR;\n        }\n    }\n\n    hash = ngx_hash_strlow(server, host, len);\n\n    cscf = ngx_hash_find_combined(&r->virtual_names->names, hash, server, len);\n\n    if (cscf) {\n        goto found;\n    }\n\n#if (NGX_PCRE)\n\n    if (r->virtual_names->nregex) {\n        size_t                   ncaptures;\n        ngx_int_t                n;\n        ngx_uint_t               i;\n        ngx_str_t                name;\n        ngx_http_server_name_t  *sn;\n\n        name.len = len;\n        name.data = server;\n\n        ncaptures = 0;\n\n        sn = r->virtual_names->regex;\n\n        for (i = 0; i < r->virtual_names->nregex; i++) {\n\n            if (sn[i].captures && r->captures == NULL) {\n\n                ncaptures = (NGX_HTTP_MAX_CAPTURES + 1) * 3;\n\n                r->captures = ngx_palloc(r->pool, ncaptures * sizeof(int));\n                if (r->captures == NULL) {\n                    return NGX_ERROR;\n                }\n\n                if (server == buf) {\n                    server = ngx_pnalloc(r->pool, len);\n                    if (server == NULL) {\n                        return NGX_ERROR;\n                    }\n\n                    ngx_memcpy(server, buf, len);\n                    name.data = server;\n                }\n            }\n\n            n = ngx_regex_exec(sn[i].regex, &name, r->captures, ncaptures);\n\n            if (n == NGX_REGEX_NO_MATCHED) {\n                continue;\n            }\n\n            if (n < 0) {\n                ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n                              ngx_regex_exec_n\n                              \" failed: %d on \\\"%V\\\" using \\\"%V\\\"\",\n                              n, &name, &sn[i].name);\n                return NGX_ERROR;\n            }\n\n            /* match */\n\n            cscf = sn[i].core_srv_conf;\n\n            r->ncaptures = ncaptures;\n            r->captures_data = server;\n\n            goto found;\n        }\n    }\n\n#endif\n\n    return NGX_OK;\n\nfound:\n\n    r->srv_conf = cscf->ctx->srv_conf;\n    r->loc_conf = cscf->ctx->loc_conf;\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n    r->connection->log->file = clcf->error_log->file;\n\n    if (!(r->connection->log->log_level & NGX_LOG_DEBUG_CONNECTION)) {\n        r->connection->log->log_level = clcf->error_log->log_level;\n    }\n\n    return NGX_OK;\n}", "target": 1}
{"idx": 5136, "func": "static int get_line (char *s, int n)\n{\n    char *cp;\n\n    if (!fgets(s, n, stdin))\n\treturn (0);\n    cp = strchr(s, '\\n');\n    if (cp)\n\t*cp = '\\0';\n    return (1);\n}", "target": 1}
{"idx": 5137, "func": "static void encode_cblk(Jpeg2000EncoderContext *s, Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk, Jpeg2000Tile *tile,\n                        int width, int height, int bandpos, int lev)\n{\n    int pass_t = 2, passno, x, y, max=0, nmsedec, bpno;\n    int64_t wmsedec = 0;\n\n    memset(t1->flags, 0, t1->stride * (height + 2) * sizeof(*t1->flags));\n\n    for (y = 0; y < height; y++){\n        for (x = 0; x < width; x++){\n            if (t1->data[(y) * t1->stride + x] < 0){\n                t1->flags[(y+1) * t1->stride + x+1] |= JPEG2000_T1_SGN;\n                t1->data[(y) * t1->stride + x] = -t1->data[(y) * t1->stride + x];\n            }\n            max = FFMAX(max, t1->data[(y) * t1->stride + x]);\n        }\n    }\n\n    if (max == 0){\n        cblk->nonzerobits = 0;\n        bpno = 0;\n    } else{\n        cblk->nonzerobits = av_log2(max) + 1 - NMSEDEC_FRACBITS;\n        bpno = cblk->nonzerobits - 1;\n    }\n\n    ff_mqc_initenc(&t1->mqc, cblk->data);\n\n    for (passno = 0; bpno >= 0; passno++){\n        nmsedec=0;\n\n        switch(pass_t){\n            case 0: encode_sigpass(t1, width, height, bandpos, &nmsedec, bpno);\n                    break;\n            case 1: encode_refpass(t1, width, height, &nmsedec, bpno);\n                    break;\n            case 2: encode_clnpass(t1, width, height, bandpos, &nmsedec, bpno);\n                    break;\n        }\n\n        cblk->passes[passno].rate = ff_mqc_flush_to(&t1->mqc, cblk->passes[passno].flushed, &cblk->passes[passno].flushed_len);\n        wmsedec += (int64_t)nmsedec << (2*bpno);\n        cblk->passes[passno].disto = wmsedec;\n\n        if (++pass_t == 3){\n            pass_t = 0;\n            bpno--;\n        }\n    }\n    cblk->npasses = passno;\n    cblk->ninclpasses = passno;\n\n    cblk->passes[passno-1].rate = ff_mqc_flush_to(&t1->mqc, cblk->passes[passno-1].flushed, &cblk->passes[passno-1].flushed_len);\n}", "target": 0}
{"idx": 5138, "func": "static unsigned int BN_STACK_pop(BN_STACK *st)\n\t{\n\treturn st->indexes[--(st->depth)];\n\t}", "target": 1}
{"idx": 5139, "func": "static int thp_read_header(AVFormatContext *s)\n{\n    ThpDemuxContext *thp = s->priv_data;\n    AVStream *st;\n    AVIOContext *pb = s->pb;\n    int64_t fsize= avio_size(pb);\n    int i;\n\n    /* Read the file header.  */\n                           avio_rb32(pb); /* Skip Magic.  */\n    thp->version         = avio_rb32(pb);\n\n                           avio_rb32(pb); /* Max buf size.  */\n                           avio_rb32(pb); /* Max samples.  */\n\n    thp->fps             = av_d2q(av_int2float(avio_rb32(pb)), INT_MAX);\n    thp->framecnt        = avio_rb32(pb);\n    thp->first_framesz   = avio_rb32(pb);\n    pb->maxsize          = avio_rb32(pb);\n    if(fsize>0 && (!pb->maxsize || fsize < pb->maxsize))\n        pb->maxsize= fsize;\n\n    thp->compoff         = avio_rb32(pb);\n                           avio_rb32(pb); /* offsetDataOffset.  */\n    thp->first_frame     = avio_rb32(pb);\n    thp->last_frame      = avio_rb32(pb);\n\n    thp->next_framesz    = thp->first_framesz;\n    thp->next_frame      = thp->first_frame;\n\n    /* Read the component structure.  */\n    avio_seek (pb, thp->compoff, SEEK_SET);\n    thp->compcount       = avio_rb32(pb);\n\n    /* Read the list of component types.  */\n    avio_read(pb, thp->components, 16);\n\n    for (i = 0; i < thp->compcount; i++) {\n        if (thp->components[i] == 0) {\n            if (thp->vst)\n                break;\n\n            /* Video component.  */\n            st = avformat_new_stream(s, NULL);\n            if (!st)\n                return AVERROR(ENOMEM);\n\n            /* The denominator and numerator are switched because 1/fps\n               is required.  */\n            avpriv_set_pts_info(st, 64, thp->fps.den, thp->fps.num);\n            st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            st->codecpar->codec_id = AV_CODEC_ID_THP;\n            st->codecpar->codec_tag = 0;  /* no fourcc */\n            st->codecpar->width = avio_rb32(pb);\n            st->codecpar->height = avio_rb32(pb);\n            st->codecpar->sample_rate = av_q2d(thp->fps);\n            st->nb_frames =\n            st->duration = thp->framecnt;\n            thp->vst = st;\n            thp->video_stream_index = st->index;\n\n            if (thp->version == 0x11000)\n                avio_rb32(pb); /* Unknown.  */\n        } else if (thp->components[i] == 1) {\n            if (thp->has_audio != 0)\n                break;\n\n            /* Audio component.  */\n            st = avformat_new_stream(s, NULL);\n            if (!st)\n                return AVERROR(ENOMEM);\n\n            st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n            st->codecpar->codec_id = AV_CODEC_ID_ADPCM_THP;\n            st->codecpar->codec_tag = 0;  /* no fourcc */\n            st->codecpar->channels    = avio_rb32(pb); /* numChannels.  */\n            st->codecpar->sample_rate = avio_rb32(pb); /* Frequency.  */\n            st->duration           = avio_rb32(pb);\n\n            avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);\n\n            thp->audio_stream_index = st->index;\n            thp->has_audio = 1;\n        }\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5140, "func": "static int read_ts(const char *s, int64_t *start, int *duration)\n{\n    int64_t end;\n    int hh1, mm1, ss1, ms1;\n    int hh2, mm2, ss2, ms2;\n\n    if (sscanf(s, \"%u:%u:%u.%u,%u:%u:%u.%u\",\n               &hh1, &mm1, &ss1, &ms1, &hh2, &mm2, &ss2, &ms2) == 8) {\n        end    = (hh2*3600LL + mm2*60LL + ss2) * 100LL + ms2;\n        *start = (hh1*3600LL + mm1*60LL + ss1) * 100LL + ms1;\n        *duration = end - *start;\n        return 0;\n    }\n    return -1;\n}", "target": 0}
{"idx": 5141, "func": "static void\nJPEGFixupTagsSubsampling(TIFF* tif)\n{\n\t/*\n\t * Some JPEG-in-TIFF produces do not emit the YCBCRSUBSAMPLING values in\n\t * the TIFF tags, but still use non-default (2,2) values within the jpeg\n\t * data stream itself.  In order for TIFF applications to work properly\n\t * - for instance to get the strip buffer size right - it is imperative\n\t * that the subsampling be available before we start reading the image\n\t * data normally.  This function will attempt to analyze the first strip in\n\t * order to get the sampling values from the jpeg data stream.\n\t *\n\t * Note that JPEGPreDeocode() will produce a fairly loud warning when the\n\t * discovered sampling does not match the default sampling (2,2) or whatever\n\t * was actually in the tiff tags.\n\t *\n\t * See the bug in bugzilla for details:\n\t *\n\t * http://bugzilla.remotesensing.org/show_bug.cgi?id=168\n\t *\n\t * Frank Warmerdam, July 2002\n\t * Joris Van Damme, May 2007\n\t */\n\tstatic const char module[] = \"JPEGFixupTagsSubsampling\";\n\tstruct JPEGFixupTagsSubsamplingData m;\n        uint64 fileoffset = TIFFGetStrileOffset(tif, 0);\n\n        if( fileoffset == 0 )\n        {\n            /* Do not even try to check if the first strip/tile does not\n               yet exist, as occurs when GDAL has created a new NULL file\n               for instance. */\n            return;\n        }\n\n\tm.tif=tif;\n\tm.buffersize=2048;\n\tm.buffer=_TIFFmalloc(m.buffersize);\n\tif (m.buffer==NULL)\n\t{\n\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t    \"Unable to allocate memory for auto-correcting of subsampling values; auto-correcting skipped\");\n\t\treturn;\n\t}\n\tm.buffercurrentbyte=NULL;\n\tm.bufferbytesleft=0;\n\tm.fileoffset=fileoffset;\n\tm.filepositioned=0;\n\tm.filebytesleft=TIFFGetStrileByteCount(tif, 0);\n\tif (!JPEGFixupTagsSubsamplingSec(&m))\n\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t    \"Unable to auto-correct subsampling values, likely corrupt JPEG compressed data in first strip/tile; auto-correcting skipped\");\n\t_TIFFfree(m.buffer);\n}", "target": 0}
{"idx": 5142, "func": "static inline void codeblock(DiracContext *s, SubBand *b,\n                             GetBitContext *gb, DiracArith *c,\n                             int left, int right, int top, int bottom,\n                             int blockcnt_one, int is_arith)\n{\n    int x, y, zero_block;\n    int qoffset, qfactor;\n    uint8_t *buf;\n\n    /* check for any coded coefficients in this codeblock */\n    if (!blockcnt_one) {\n        if (is_arith)\n            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);\n        else\n            zero_block = get_bits1(gb);\n\n        if (zero_block)\n            return;\n    }\n\n    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {\n        int quant = b->quant;\n        if (is_arith)\n            quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);\n        else\n            quant += dirac_get_se_golomb(gb);\n        if (quant < 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid quant\\n\");\n            return;\n        }\n        b->quant = quant;\n    }\n\n    if (b->quant > DIRAC_MAX_QUANT_INDEX) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Unsupported quant %d\\n\", b->quant);\n        b->quant = 0;\n        return;\n    }\n\n    qfactor = ff_dirac_qscale_tab[b->quant];\n    /* TODO: context pointer? */\n    if (!s->num_refs)\n        qoffset = ff_dirac_qoffset_intra_tab[b->quant] + 2;\n    else\n        qoffset = ff_dirac_qoffset_inter_tab[b->quant] + 2;\n\n    buf = b->ibuf + top * b->stride;\n    if (is_arith) {\n        for (y = top; y < bottom; y++) {\n            for (x = left; x < right; x++) {\n                if (b->pshift) {\n                    coeff_unpack_arith_10(c, qfactor, qoffset, b, (int32_t*)(buf)+x, x, y);\n                } else {\n                    coeff_unpack_arith_8(c, qfactor, qoffset, b, (int16_t*)(buf)+x, x, y);\n                }\n            }\n            buf += b->stride;\n        }\n    } else {\n        for (y = top; y < bottom; y++) {\n            for (x = left; x < right; x++) {\n                int val = coeff_unpack_golomb(gb, qfactor, qoffset);\n                if (b->pshift) {\n                    AV_WN32(&buf[4*x], val);\n                } else {\n                    AV_WN16(&buf[2*x], val);\n                }\n            }\n            buf += b->stride;\n         }\n     }\n}", "target": 0}
{"idx": 5143, "func": "static void encode_window_bands_info(AACEncContext *s, SingleChannelElement *sce,\n                                     int win, int group_len, const float lambda)\n{\n    BandCodingPath path[120][12];\n    int w, swb, cb, start, size;\n    int i, j;\n    const int max_sfb  = sce->ics.max_sfb;\n    const int run_bits = sce->ics.num_windows == 1 ? 5 : 3;\n    const int run_esc  = (1 << run_bits) - 1;\n    int idx, ppos, count;\n    int stackrun[120], stackcb[120], stack_len;\n    float next_minrd = INFINITY;\n    int next_mincb = 0;\n\n    abs_pow34_v(s->scoefs, sce->coeffs, 1024);\n    start = win*128;\n    for (cb = 0; cb < 12; cb++) {\n        path[0][cb].cost     = 0.0f;\n        path[0][cb].prev_idx = -1;\n        path[0][cb].run      = 0;\n    }\n    for (swb = 0; swb < max_sfb; swb++) {\n        size = sce->ics.swb_sizes[swb];\n        if (sce->zeroes[win*16 + swb]) {\n            for (cb = 0; cb < 12; cb++) {\n                path[swb+1][cb].prev_idx = cb;\n                path[swb+1][cb].cost     = path[swb][cb].cost;\n                path[swb+1][cb].run      = path[swb][cb].run + 1;\n            }\n        } else {\n            float minrd = next_minrd;\n            int mincb = next_mincb;\n            next_minrd = INFINITY;\n            next_mincb = 0;\n            for (cb = 0; cb < 12; cb++) {\n                float cost_stay_here, cost_get_here;\n                float rd = 0.0f;\n                for (w = 0; w < group_len; w++) {\n                    FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(win+w)*16+swb];\n                    rd += quantize_band_cost(s, sce->coeffs + start + w*128,\n                                             s->scoefs + start + w*128, size,\n                                             sce->sf_idx[(win+w)*16+swb], cb,\n                                             lambda / band->threshold, INFINITY, NULL);\n                }\n                cost_stay_here = path[swb][cb].cost + rd;\n                cost_get_here  = minrd              + rd + run_bits + 4;\n                if (   run_value_bits[sce->ics.num_windows == 8][path[swb][cb].run]\n                    != run_value_bits[sce->ics.num_windows == 8][path[swb][cb].run+1])\n                    cost_stay_here += run_bits;\n                if (cost_get_here < cost_stay_here) {\n                    path[swb+1][cb].prev_idx = mincb;\n                    path[swb+1][cb].cost     = cost_get_here;\n                    path[swb+1][cb].run      = 1;\n                } else {\n                    path[swb+1][cb].prev_idx = cb;\n                    path[swb+1][cb].cost     = cost_stay_here;\n                    path[swb+1][cb].run      = path[swb][cb].run + 1;\n                }\n                if (path[swb+1][cb].cost < next_minrd) {\n                    next_minrd = path[swb+1][cb].cost;\n                    next_mincb = cb;\n                }\n            }\n        }\n        start += sce->ics.swb_sizes[swb];\n    }\n\n    //convert resulting path from backward-linked list\n    stack_len = 0;\n    idx       = 0;\n    for (cb = 1; cb < 12; cb++)\n        if (path[max_sfb][cb].cost < path[max_sfb][idx].cost)\n            idx = cb;\n    ppos = max_sfb;\n    while (ppos > 0) {\n        cb = idx;\n        stackrun[stack_len] = path[ppos][cb].run;\n        stackcb [stack_len] = cb;\n        idx = path[ppos-path[ppos][cb].run+1][cb].prev_idx;\n        ppos -= path[ppos][cb].run;\n        stack_len++;\n    }\n    //perform actual band info encoding\n    start = 0;\n    for (i = stack_len - 1; i >= 0; i--) {\n        put_bits(&s->pb, 4, stackcb[i]);\n        count = stackrun[i];\n        memset(sce->zeroes + win*16 + start, !stackcb[i], count);\n        //XXX: memset when band_type is also uint8_t\n        for (j = 0; j < count; j++) {\n            sce->band_type[win*16 + start] =  stackcb[i];\n            start++;\n        }\n        while (count >= run_esc) {\n            put_bits(&s->pb, run_bits, run_esc);\n            count -= run_esc;\n        }\n        put_bits(&s->pb, run_bits, count);\n    }\n}", "target": 1}
{"idx": 5144, "func": "int av_thread_message_queue_alloc(AVThreadMessageQueue **mq,\n                                  unsigned nelem,\n                                  unsigned elsize)\n{\n#if HAVE_THREADS\n    AVThreadMessageQueue *rmq;\n    int ret = 0;\n\n    if (nelem > INT_MAX / elsize)\n        return AVERROR(EINVAL);\n    if (!(rmq = av_mallocz(sizeof(*rmq))))\n        return AVERROR(ENOMEM);\n    if ((ret = pthread_mutex_init(&rmq->lock, NULL))) {\n        av_free(rmq);\n        return AVERROR(ret);\n    }\n    if ((ret = pthread_cond_init(&rmq->cond_recv, NULL))) {\n        pthread_mutex_destroy(&rmq->lock);\n        av_free(rmq);\n        return AVERROR(ret);\n    }\n    if ((ret = pthread_cond_init(&rmq->cond_send, NULL))) {\n        pthread_cond_destroy(&rmq->cond_recv);\n        pthread_mutex_destroy(&rmq->lock);\n        av_free(rmq);\n        return AVERROR(ret);\n    }\n    if (!(rmq->fifo = av_fifo_alloc(elsize * nelem))) {\n        pthread_cond_destroy(&rmq->cond_send);\n        pthread_cond_destroy(&rmq->cond_recv);\n        pthread_mutex_destroy(&rmq->lock);\n        av_free(rmq);\n        return AVERROR(ret);\n    }\n    rmq->elsize = elsize;\n    *mq = rmq;\n    return 0;\n#else\n    *mq = NULL;\n    return AVERROR(ENOSYS);\n#endif /* HAVE_THREADS */\n}", "target": 0}
{"idx": 5145, "func": "void ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher)\n\t{\n\tCERT_PKEY *cpk;\n\tint rsa_enc,rsa_tmp,rsa_sign,dh_tmp,dh_rsa,dh_dsa,dsa_sign;\n\tint rsa_enc_export,dh_rsa_export,dh_dsa_export;\n\tint rsa_tmp_export,dh_tmp_export,kl;\n\tunsigned long mask_k,mask_a,emask_k,emask_a;\n\tint have_ecc_cert, ecdh_ok, ecdsa_ok, ecc_pkey_size;\n#ifndef OPENSSL_NO_ECDH\n\tint have_ecdh_tmp;\n#endif\n\tX509 *x = NULL;\n\tEVP_PKEY *ecc_pkey = NULL;\n\tint signature_nid = 0, pk_nid = 0, md_nid = 0;\n\n\tif (c == NULL) return;\n\n\tkl=SSL_C_EXPORT_PKEYLENGTH(cipher);\n\n#ifndef OPENSSL_NO_RSA\n\trsa_tmp=(c->rsa_tmp != NULL || c->rsa_tmp_cb != NULL);\n\trsa_tmp_export=(c->rsa_tmp_cb != NULL ||\n\t\t(rsa_tmp && RSA_size(c->rsa_tmp)*8 <= kl));\n#else\n\trsa_tmp=rsa_tmp_export=0;\n#endif\n#ifndef OPENSSL_NO_DH\n\tdh_tmp=(c->dh_tmp != NULL || c->dh_tmp_cb != NULL);\n\tdh_tmp_export=(c->dh_tmp_cb != NULL ||\n\t\t(dh_tmp && DH_size(c->dh_tmp)*8 <= kl));\n#else\n\tdh_tmp=dh_tmp_export=0;\n#endif\n\n#ifndef OPENSSL_NO_ECDH\n\thave_ecdh_tmp=(c->ecdh_tmp || c->ecdh_tmp_cb || c->ecdh_tmp_auto);\n#endif\n\tcpk= &(c->pkeys[SSL_PKEY_RSA_ENC]);\n\trsa_enc= cpk->valid_flags & CERT_PKEY_VALID;\n\trsa_enc_export=(rsa_enc && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\n\tcpk= &(c->pkeys[SSL_PKEY_RSA_SIGN]);\n\trsa_sign= cpk->valid_flags & CERT_PKEY_SIGN;\n\tcpk= &(c->pkeys[SSL_PKEY_DSA_SIGN]);\n\tdsa_sign= cpk->valid_flags & CERT_PKEY_SIGN;\n\tcpk= &(c->pkeys[SSL_PKEY_DH_RSA]);\n\tdh_rsa=  cpk->valid_flags & CERT_PKEY_VALID;\n\tdh_rsa_export=(dh_rsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\n\tcpk= &(c->pkeys[SSL_PKEY_DH_DSA]);\n/* FIX THIS EAY EAY EAY */\n\tdh_dsa=  cpk->valid_flags & CERT_PKEY_VALID;\n\tdh_dsa_export=(dh_dsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\n\tcpk= &(c->pkeys[SSL_PKEY_ECC]);\n\thave_ecc_cert= cpk->valid_flags & CERT_PKEY_VALID;\n\tmask_k=0;\n\tmask_a=0;\n\temask_k=0;\n\temask_a=0;\n\n\t\n\n#ifdef CIPHER_DEBUG\n\tprintf(\"rt=%d rte=%d dht=%d ecdht=%d re=%d ree=%d rs=%d ds=%d dhr=%d dhd=%d\\n\",\n\t        rsa_tmp,rsa_tmp_export,dh_tmp,have_ecdh_tmp,\n\t\trsa_enc,rsa_enc_export,rsa_sign,dsa_sign,dh_rsa,dh_dsa);\n#endif\n\t\n\tcpk = &(c->pkeys[SSL_PKEY_GOST01]);\n\tif (cpk->x509 != NULL && cpk->privatekey !=NULL) {\n\t\tmask_k |= SSL_kGOST;\n\t\tmask_a |= SSL_aGOST01;\n\t}\n\tcpk = &(c->pkeys[SSL_PKEY_GOST94]);\n\tif (cpk->x509 != NULL && cpk->privatekey !=NULL) {\n\t\tmask_k |= SSL_kGOST;\n\t\tmask_a |= SSL_aGOST94;\n\t}\n\n\tif (rsa_enc || (rsa_tmp && rsa_sign))\n\t\tmask_k|=SSL_kRSA;\n\tif (rsa_enc_export || (rsa_tmp_export && (rsa_sign || rsa_enc)))\n\t\temask_k|=SSL_kRSA;\n\n#if 0\n\t/* The match needs to be both kEDH and aRSA or aDSA, so don't worry */\n\tif (\t(dh_tmp || dh_rsa || dh_dsa) &&\n\t\t(rsa_enc || rsa_sign || dsa_sign))\n\t\tmask_k|=SSL_kEDH;\n\tif ((dh_tmp_export || dh_rsa_export || dh_dsa_export) &&\n\t\t(rsa_enc || rsa_sign || dsa_sign))\n\t\temask_k|=SSL_kEDH;\n#endif\n\n\tif (dh_tmp_export)\n\t\temask_k|=SSL_kEDH;\n\n\tif (dh_tmp)\n\t\tmask_k|=SSL_kEDH;\n\n\tif (dh_rsa) mask_k|=SSL_kDHr;\n\tif (dh_rsa_export) emask_k|=SSL_kDHr;\n\n\tif (dh_dsa) mask_k|=SSL_kDHd;\n\tif (dh_dsa_export) emask_k|=SSL_kDHd;\n\n\tif (emask_k & (SSL_kDHr|SSL_kDHd))\n\t\tmask_a |= SSL_aDH;\n\n\tif (rsa_enc || rsa_sign)\n\t\t{\n\t\tmask_a|=SSL_aRSA;\n\t\temask_a|=SSL_aRSA;\n\t\t}\n\n\tif (dsa_sign)\n\t\t{\n\t\tmask_a|=SSL_aDSS;\n\t\temask_a|=SSL_aDSS;\n\t\t}\n\n\tmask_a|=SSL_aNULL;\n\temask_a|=SSL_aNULL;\n\n#ifndef OPENSSL_NO_KRB5\n\tmask_k|=SSL_kKRB5;\n\tmask_a|=SSL_aKRB5;\n\temask_k|=SSL_kKRB5;\n\temask_a|=SSL_aKRB5;\n#endif\n\n\t/* An ECC certificate may be usable for ECDH and/or\n\t * ECDSA cipher suites depending on the key usage extension.\n\t */\n\tif (have_ecc_cert)\n\t\t{\n\t\tcpk = &c->pkeys[SSL_PKEY_ECC];\n\t\tx = cpk->x509;\n\t\t/* This call populates extension flags (ex_flags) */\n\t\tX509_check_purpose(x, -1, 0);\n\t\tecdh_ok = (x->ex_flags & EXFLAG_KUSAGE) ?\n\t\t    (x->ex_kusage & X509v3_KU_KEY_AGREEMENT) : 1;\n\t\tecdsa_ok = (x->ex_flags & EXFLAG_KUSAGE) ?\n\t\t    (x->ex_kusage & X509v3_KU_DIGITAL_SIGNATURE) : 1;\n\t\tif (!(cpk->valid_flags & CERT_PKEY_SIGN))\n\t\t\tecdsa_ok = 0;\n\t\tecc_pkey = X509_get_pubkey(x);\n\t\tecc_pkey_size = (ecc_pkey != NULL) ?\n\t\t    EVP_PKEY_bits(ecc_pkey) : 0;\n\t\tEVP_PKEY_free(ecc_pkey);\n\t\tif ((x->sig_alg) && (x->sig_alg->algorithm))\n\t\t\t{\n\t\t\tsignature_nid = OBJ_obj2nid(x->sig_alg->algorithm);\n\t\t\tOBJ_find_sigid_algs(signature_nid, &md_nid, &pk_nid);\n\t\t\t}\n#ifndef OPENSSL_NO_ECDH\n\t\tif (ecdh_ok)\n\t\t\t{\n\n\t\t\tif (pk_nid == NID_rsaEncryption || pk_nid == NID_rsa)\n\t\t\t\t{\n\t\t\t\tmask_k|=SSL_kECDHr;\n\t\t\t\tmask_a|=SSL_aECDH;\n\t\t\t\tif (ecc_pkey_size <= 163)\n\t\t\t\t\t{\n\t\t\t\t\temask_k|=SSL_kECDHr;\n\t\t\t\t\temask_a|=SSL_aECDH;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif (pk_nid == NID_X9_62_id_ecPublicKey)\n\t\t\t\t{\n\t\t\t\tmask_k|=SSL_kECDHe;\n\t\t\t\tmask_a|=SSL_aECDH;\n\t\t\t\tif (ecc_pkey_size <= 163)\n\t\t\t\t\t{\n\t\t\t\t\temask_k|=SSL_kECDHe;\n\t\t\t\t\temask_a|=SSL_aECDH;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tif (ecdsa_ok)\n\t\t\t{\n\t\t\tmask_a|=SSL_aECDSA;\n\t\t\temask_a|=SSL_aECDSA;\n\t\t\t}\n#endif\n\t\t}\n\n#ifndef OPENSSL_NO_ECDH\n\tif (have_ecdh_tmp)\n\t\t{\n\t\tmask_k|=SSL_kEECDH;\n\t\temask_k|=SSL_kEECDH;\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_PSK\n\tmask_k |= SSL_kPSK;\n\tmask_a |= SSL_aPSK;\n\temask_k |= SSL_kPSK;\n\temask_a |= SSL_aPSK;\n#endif\n\n\tc->mask_k=mask_k;\n\tc->mask_a=mask_a;\n\tc->export_mask_k=emask_k;\n\tc->export_mask_a=emask_a;\n\tc->valid=1;\n\t}", "target": 0}
{"idx": 5146, "func": "static void ap_set_version(apr_pool_t *pconf)\n{\n    if (ap_server_tokens == SrvTk_PRODUCT_ONLY) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT);\n    }\n    else if (ap_server_tokens == SrvTk_MINIMAL) {\n        ap_add_version_component(pconf, AP_SERVER_BASEVERSION);\n    }\n    else if (ap_server_tokens == SrvTk_MINOR) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT \"/\" AP_SERVER_MINORREVISION);\n    }\n    else if (ap_server_tokens == SrvTk_MAJOR) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT \"/\" AP_SERVER_MAJORVERSION);\n    }\n    else {\n        ap_add_version_component(pconf, AP_SERVER_BASEVERSION \" (\" PLATFORM \")\");\n    }\n\n    /*\n     * Lock the server_version string if we're not displaying\n     * the full set of tokens\n     */\n    if (ap_server_tokens != SrvTk_FULL) {\n        version_locked++;\n    }\n}", "target": 1}
{"idx": 5147, "func": "int opt_cipher(const char *name, const EVP_CIPHER **cipherp)\n{\n    *cipherp = EVP_get_cipherbyname(name);\n    if (*cipherp != NULL)\n        return 1;\n    BIO_printf(bio_err, \"%s: Unrecognized flag %s\\n\", prog, name);\n    return 0;\n}", "target": 0}
{"idx": 5148, "func": "static void load_module(const char *filename)\n{\n    void *dll;\n    void (*init_func)(void);\n    dll = dlopen(filename, RTLD_NOW);\n    if (!dll) {\n        fprintf(stderr, \"Could not load module '%s' - %s\\n\",\n                filename, dlerror());\n        return;\n    }\n\n    init_func = dlsym(dll, \"ffserver_module_init\");\n    if (!init_func) {\n        fprintf(stderr,\n                \"%s: init function 'ffserver_module_init()' not found\\n\",\n                filename);\n        dlclose(dll);\n        return;\n    }\n\n    init_func();\n}", "target": 0}
{"idx": 5149, "func": "static void init_dequant4_coeff_table(H264Context *h)\n{\n    int i, j, q, x;\n    const int max_qp = 51 + 6 * (h->sps.bit_depth_luma - 8);\n    for (i = 0; i < 6; i++) {\n        h->dequant4_coeff[i] = h->dequant4_buffer[i];\n        for (j = 0; j < i; j++)\n            if (!memcmp(h->pps.scaling_matrix4[j], h->pps.scaling_matrix4[i],\n                        16 * sizeof(uint8_t))) {\n                h->dequant4_coeff[i] = h->dequant4_buffer[j];\n                break;\n            }\n        if (j < i)\n            continue;\n\n        for (q = 0; q < max_qp + 1; q++) {\n            int shift = ff_h264_quant_div6[q] + 2;\n            int idx   = ff_h264_quant_rem6[q];\n            for (x = 0; x < 16; x++)\n                h->dequant4_coeff[i][q][(x >> 2) | ((x << 2) & 0xF)] =\n                    ((uint32_t)ff_h264_dequant4_coeff_init[idx][(x & 1) + ((x >> 2) & 1)] *\n                     h->pps.scaling_matrix4[i][x]) << shift;\n        }\n    }\n}", "target": 1}
{"idx": 5150, "func": "static void smptebars_fill_picture(AVFilterContext *ctx, AVFrame *picref)\n{\n    TestSourceContext *test = ctx->priv;\n    int r_w, r_h, w_h, p_w, p_h, i, tmp, x = 0;\n    const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(picref->format);\n\n    r_w = FFALIGN((test->w + 6) / 7, 1 << pixdesc->log2_chroma_w);\n    r_h = FFALIGN(test->h * 2 / 3, 1 << pixdesc->log2_chroma_h);\n    w_h = FFALIGN(test->h * 3 / 4 - r_h,  1 << pixdesc->log2_chroma_h);\n    p_w = FFALIGN(r_w * 5 / 4, 1 << pixdesc->log2_chroma_w);\n    p_h = test->h - w_h - r_h;\n\n    for (i = 0; i < 7; i++) {\n        draw_bar(test, rainbow[i], x, 0,   r_w, r_h, picref);\n        draw_bar(test, wobnair[i], x, r_h, r_w, w_h, picref);\n        x += r_w;\n    }\n    x = 0;\n    draw_bar(test, i_pixel, x, r_h + w_h, p_w, p_h, picref);\n    x += p_w;\n    draw_bar(test, white, x, r_h + w_h, p_w, p_h, picref);\n    x += p_w;\n    draw_bar(test, q_pixel, x, r_h + w_h, p_w, p_h, picref);\n    x += p_w;\n    tmp = FFALIGN(5 * r_w - x,  1 << pixdesc->log2_chroma_w);\n    draw_bar(test, black, x, r_h + w_h, tmp, p_h, picref);\n    x += tmp;\n    tmp = FFALIGN(r_w / 3,  1 << pixdesc->log2_chroma_w);\n    draw_bar(test, neg4ire, x, r_h + w_h, tmp, p_h, picref);\n    x += tmp;\n    draw_bar(test, black, x, r_h + w_h, tmp, p_h, picref);\n    x += tmp;\n    draw_bar(test, pos4ire, x, r_h + w_h, tmp, p_h, picref);\n    x += tmp;\n    draw_bar(test, black, x, r_h + w_h, test->w - x, p_h, picref);\n}", "target": 0}
{"idx": 5151, "func": "static av_always_inline void\nyuv2mono_2_c_template(SwsContext *c, const int16_t *buf[2],\n                      const int16_t *ubuf[2], const int16_t *vbuf[2],\n                      const int16_t *abuf[2], uint8_t *dest, int dstW,\n                      int yalpha, int uvalpha, int y,\n                      enum PixelFormat target)\n{\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1];\n    const uint8_t * const d128 = dither_8x8_220[y & 7];\n    int  yalpha1 = 4096 - yalpha;\n    int i;\n\n    for (i = 0; i < dstW; i += 8) {\n        int Y, acc = 0;\n\n        Y = (buf0[i + 0] * yalpha1 + buf1[i + 0] * yalpha) >> 19;\n        accumulate_bit(acc, Y + d128[0]);\n        Y = (buf0[i + 1] * yalpha1 + buf1[i + 1] * yalpha) >> 19;\n        accumulate_bit(acc, Y + d128[1]);\n        Y = (buf0[i + 2] * yalpha1 + buf1[i + 2] * yalpha) >> 19;\n        accumulate_bit(acc, Y + d128[2]);\n        Y = (buf0[i + 3] * yalpha1 + buf1[i + 3] * yalpha) >> 19;\n        accumulate_bit(acc, Y + d128[3]);\n        Y = (buf0[i + 4] * yalpha1 + buf1[i + 4] * yalpha) >> 19;\n        accumulate_bit(acc, Y + d128[4]);\n        Y = (buf0[i + 5] * yalpha1 + buf1[i + 5] * yalpha) >> 19;\n        accumulate_bit(acc, Y + d128[5]);\n        Y = (buf0[i + 6] * yalpha1 + buf1[i + 6] * yalpha) >> 19;\n        accumulate_bit(acc, Y + d128[6]);\n        Y = (buf0[i + 7] * yalpha1 + buf1[i + 7] * yalpha) >> 19;\n        accumulate_bit(acc, Y + d128[7]);\n\n        output_pixel(*dest++, acc);\n    }\n}", "target": 0}
{"idx": 5152, "func": "int ssl3_send_server_done(SSL *s)\n\t{\n\tunsigned char *p;\n\n\tif (s->state == SSL3_ST_SW_SRVR_DONE_A)\n\t\t{\n\t\tp=(unsigned char *)s->init_buf->data;\n\n\t\t/* do the header */\n\t\t*(p++)=SSL3_MT_SERVER_DONE;\n\t\t*(p++)=0;\n\t\t*(p++)=0;\n\t\t*(p++)=0;\n\n\t\ts->state=SSL3_ST_SW_SRVR_DONE_B;\n\t\t/* number of bytes to write */\n\t\ts->init_num=4;\n\t\ts->init_off=0;\n\t\t}\n\n\t/* SSL3_ST_SW_SRVR_DONE_B */\n\treturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\n\t}", "target": 1}
{"idx": 5153, "func": "static int http_read_stream(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int err, new_location;\n\n    if (!s->hd)\n        return AVERROR_EOF;\n\n    if (s->end_chunked_post && !s->end_header) {\n        err = http_read_header(h, &new_location);\n        if (err < 0)\n            return err;\n    }\n\n    if (s->chunksize >= 0) {\n        if (!s->chunksize) {\n            char line[32];\n\n            for (;;) {\n                do {\n                    if ((err = http_get_line(s, line, sizeof(line))) < 0)\n                        return err;\n                } while (!*line);    /* skip CR LF from last chunk */\n\n                s->chunksize = strtoll(line, NULL, 16);\n\n                av_log(NULL, AV_LOG_TRACE, \"Chunked encoding data size: %\"PRId64\"'\\n\",\n                        s->chunksize);\n                if (s->chunksize < 0)\n                    return AVERROR_INVALIDDATA;\n                else if (!s->chunksize)\n                    return 0;\n                break;\n            }\n        }\n        size = FFMIN(size, s->chunksize);\n    }\n#if CONFIG_ZLIB\n    if (s->compressed)\n        return http_buf_read_compressed(h, buf, size);\n#endif /* CONFIG_ZLIB */\n    return http_buf_read(h, buf, size);\n}", "target": 0}
{"idx": 5154, "func": "static int old_codec47(SANMVideoContext *ctx, int top,\n                       int left, int width, int height)\n{\n    int i, j, seq, compr, new_rot, tbl_pos, skip;\n    int stride     = ctx->pitch;\n    uint8_t *dst   = ((uint8_t*)ctx->frm0) + left + top * stride;\n    uint8_t *prev1 = (uint8_t*)ctx->frm1;\n    uint8_t *prev2 = (uint8_t*)ctx->frm2;\n    uint32_t decoded_size;\n\n    tbl_pos = bytestream2_tell(&ctx->gb);\n    seq     = bytestream2_get_le16(&ctx->gb);\n    compr   = bytestream2_get_byte(&ctx->gb);\n    new_rot = bytestream2_get_byte(&ctx->gb);\n    skip    = bytestream2_get_byte(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 9);\n    decoded_size = bytestream2_get_le32(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 8);\n\n    if (decoded_size > height * stride - left - top * stride) {\n        decoded_size = height * stride - left - top * stride;\n        av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n    }\n\n    if (skip & 1)\n        bytestream2_skip(&ctx->gb, 0x8080);\n    if (!seq) {\n        ctx->prev_seq = -1;\n        memset(prev1, 0, ctx->height * stride);\n        memset(prev2, 0, ctx->height * stride);\n    }\n    av_dlog(ctx->avctx, \"compression %d\\n\", compr);\n    switch (compr) {\n    case 0:\n        if (bytestream2_get_bytes_left(&ctx->gb) < width * height)\n            return AVERROR_INVALIDDATA;\n        for (j = 0; j < height; j++) {\n            bytestream2_get_bufferu(&ctx->gb, dst, width);\n            dst += stride;\n        }\n        break;\n    case 1:\n        if (bytestream2_get_bytes_left(&ctx->gb) < ((width + 1) >> 1) * ((height + 1) >> 1))\n            return AVERROR_INVALIDDATA;\n        for (j = 0; j < height; j += 2) {\n            for (i = 0; i < width; i += 2) {\n                dst[i] = dst[i + 1] =\n                dst[stride + i] = dst[stride + i + 1] = bytestream2_get_byteu(&ctx->gb);\n            }\n            dst += stride * 2;\n        }\n        break;\n    case 2:\n        if (seq == ctx->prev_seq + 1) {\n            for (j = 0; j < height; j += 8) {\n                for (i = 0; i < width; i += 8) {\n                    if (process_block(ctx, dst + i, prev1 + i, prev2 + i, stride,\n                                      tbl_pos + 8, 8))\n                        return AVERROR_INVALIDDATA;\n                }\n                dst   += stride * 8;\n                prev1 += stride * 8;\n                prev2 += stride * 8;\n            }\n        }\n        break;\n    case 3:\n        memcpy(ctx->frm0, ctx->frm2, ctx->pitch * ctx->height);\n        break;\n    case 4:\n        memcpy(ctx->frm0, ctx->frm1, ctx->pitch * ctx->height);\n        break;\n    case 5:\n        if (rle_decode(ctx, dst, decoded_size))\n            return AVERROR_INVALIDDATA;\n        break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"subcodec 47 compression %d not implemented\\n\", compr);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (seq == ctx->prev_seq + 1)\n        ctx->rotate_code = new_rot;\n    else\n        ctx->rotate_code = 0;\n    ctx->prev_seq = seq;\n\n    return 0;\n}", "target": 1}
{"idx": 5155, "func": "static int decorrelate(TAKDecContext *s, int c1, int c2, int length)\n{\n    GetBitContext *gb = &s->gb;\n    int32_t *p1       = s->decoded[c1] + 1;\n    int32_t *p2       = s->decoded[c2] + 1;\n    int i;\n    int dshift, dfactor;\n\n    switch (s->dmode) {\n    case 1: /* left/side */\n        for (i = 0; i < length; i++) {\n            int32_t a = p1[i];\n            int32_t b = p2[i];\n            p2[i]     = a + b;\n        }\n        break;\n    case 2: /* side/right */\n        for (i = 0; i < length; i++) {\n            int32_t a = p1[i];\n            int32_t b = p2[i];\n            p1[i]     = b - a;\n        }\n        break;\n    case 3: /* side/mid */\n        for (i = 0; i < length; i++) {\n            int32_t a = p1[i];\n            int32_t b = p2[i];\n            a        -= b >> 1;\n            p1[i]     = a;\n            p2[i]     = a + b;\n        }\n        break;\n    case 4: /* side/left with scale factor */\n        FFSWAP(int32_t*, p1, p2);\n    case 5: /* side/right with scale factor */\n        dshift  = get_bits_esc4(gb);\n        dfactor = get_sbits(gb, 10);\n        for (i = 0; i < length; i++) {\n            int32_t a = p1[i];\n            int32_t b = p2[i];\n            b         = dfactor * (b >> dshift) + 128 >> 8 << dshift;\n            p1[i]     = b - a;\n        }\n        break;\n    case 6:\n        FFSWAP(int32_t*, p1, p2);\n    case 7: {\n        int length2, order_half, filter_order, dval1, dval2;\n        int tmp, x, code_size;\n\n        if (length < 256)\n            return AVERROR_INVALIDDATA;\n\n        dshift       = get_bits_esc4(gb);\n        filter_order = 8 << get_bits1(gb);\n        dval1        = get_bits1(gb);\n        dval2        = get_bits1(gb);\n\n        for (i = 0; i < filter_order; i++) {\n            if (!(i & 3))\n                code_size = 14 - get_bits(gb, 3);\n            s->filter[i] = get_sbits(gb, code_size);\n        }\n\n        order_half = filter_order / 2;\n        length2    = length - (filter_order - 1);\n\n        /* decorrelate beginning samples */\n        if (dval1) {\n            for (i = 0; i < order_half; i++) {\n                int32_t a = p1[i];\n                int32_t b = p2[i];\n                p1[i]     = a + b;\n            }\n        }\n\n        /* decorrelate ending samples */\n        if (dval2) {\n            for (i = length2 + order_half; i < length; i++) {\n                int32_t a = p1[i];\n                int32_t b = p2[i];\n                p1[i]     = a + b;\n            }\n        }\n\n\n        for (i = 0; i < filter_order; i++)\n            s->residues[i] = *p2++ >> dshift;\n\n        p1 += order_half;\n        x = FF_ARRAY_ELEMS(s->residues) - filter_order;\n        for (; length2 > 0; length2 -= tmp) {\n            tmp = FFMIN(length2, x);\n\n            for (i = 0; i < tmp; i++)\n                s->residues[filter_order + i] = *p2++ >> dshift;\n\n            for (i = 0; i < tmp; i++) {\n                int v = 1 << 9;\n\n                if (filter_order == 16) {\n                    v += s->adsp.scalarproduct_int16(&s->residues[i], s->filter,\n                                                     filter_order);\n                } else {\n                    v += s->residues[i + 7] * s->filter[7] +\n                         s->residues[i + 6] * s->filter[6] +\n                         s->residues[i + 5] * s->filter[5] +\n                         s->residues[i + 4] * s->filter[4] +\n                         s->residues[i + 3] * s->filter[3] +\n                         s->residues[i + 2] * s->filter[2] +\n                         s->residues[i + 1] * s->filter[1] +\n                         s->residues[i    ] * s->filter[0];\n                }\n\n                v = (av_clip_intp2(v >> 10, 13) << dshift) - *p1;\n                *p1++ = v;\n            }\n\n            memcpy(s->residues, &s->residues[tmp], 2 * filter_order);\n        }\n\n        emms_c();\n        break;\n    }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5156, "func": "static int decode_video(InputStream *ist, AVPacket *pkt, int *got_output, int eof)\n{\n    AVFrame *decoded_frame, *f;\n    int i, ret = 0, err = 0, resample_changed;\n    int64_t best_effort_timestamp;\n    int64_t dts = AV_NOPTS_VALUE;\n    AVRational *frame_sample_aspect;\n    AVPacket avpkt;\n\n    // With fate-indeo3-2, we're getting 0-sized packets before EOF for some\n    // reason. This seems like a semi-critical bug. Don't trigger EOF, and\n    // skip the packet.\n    if (!eof && pkt && pkt->size == 0)\n        return 0;\n\n    if (!ist->decoded_frame && !(ist->decoded_frame = av_frame_alloc()))\n        return AVERROR(ENOMEM);\n    if (!ist->filter_frame && !(ist->filter_frame = av_frame_alloc()))\n        return AVERROR(ENOMEM);\n    decoded_frame = ist->decoded_frame;\n    if (ist->dts != AV_NOPTS_VALUE)\n        dts = av_rescale_q(ist->dts, AV_TIME_BASE_Q, ist->st->time_base);\n    if (pkt) {\n        avpkt = *pkt;\n        avpkt.dts = dts; // ffmpeg.c probably shouldn't do this\n    }\n\n    // The old code used to set dts on the drain packet, which does not work\n    // with the new API anymore.\n    if (eof) {\n        void *new = av_realloc_array(ist->dts_buffer, ist->nb_dts_buffer + 1, sizeof(ist->dts_buffer[0]));\n        if (!new)\n            return AVERROR(ENOMEM);\n        ist->dts_buffer = new;\n        ist->dts_buffer[ist->nb_dts_buffer++] = dts;\n    }\n\n    update_benchmark(NULL);\n    ret = decode(ist->dec_ctx, decoded_frame, got_output, pkt ? &avpkt : NULL);\n    update_benchmark(\"decode_video %d.%d\", ist->file_index, ist->st->index);\n\n    // The following line may be required in some cases where there is no parser\n    // or the parser does not has_b_frames correctly\n    if (ist->st->codecpar->video_delay < ist->dec_ctx->has_b_frames) {\n        if (ist->dec_ctx->codec_id == AV_CODEC_ID_H264) {\n            ist->st->codecpar->video_delay = ist->dec_ctx->has_b_frames;\n        } else\n            av_log(ist->dec_ctx, AV_LOG_WARNING,\n                   \"video_delay is larger in decoder than demuxer %d > %d.\\n\"\n                   \"If you want to help, upload a sample \"\n                   \"of this file to ftp://upload.ffmpeg.org/incoming/ \"\n                   \"and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\",\n                   ist->dec_ctx->has_b_frames,\n                   ist->st->codecpar->video_delay);\n    }\n\n    if (ret != AVERROR_EOF)\n        check_decode_result(ist, got_output, ret);\n\n    if (*got_output && ret >= 0) {\n        if (ist->dec_ctx->width  != decoded_frame->width ||\n            ist->dec_ctx->height != decoded_frame->height ||\n            ist->dec_ctx->pix_fmt != decoded_frame->format) {\n            av_log(NULL, AV_LOG_DEBUG, \"Frame parameters mismatch context %d,%d,%d != %d,%d,%d\\n\",\n                decoded_frame->width,\n                decoded_frame->height,\n                decoded_frame->format,\n                ist->dec_ctx->width,\n                ist->dec_ctx->height,\n                ist->dec_ctx->pix_fmt);\n        }\n    }\n\n    if (!*got_output || ret < 0)\n        return ret;\n\n    if(ist->top_field_first>=0)\n        decoded_frame->top_field_first = ist->top_field_first;\n\n    ist->frames_decoded++;\n\n    if (ist->hwaccel_retrieve_data && decoded_frame->format == ist->hwaccel_pix_fmt) {\n        err = ist->hwaccel_retrieve_data(ist->dec_ctx, decoded_frame);\n        if (err < 0)\n            goto fail;\n    }\n    ist->hwaccel_retrieved_pix_fmt = decoded_frame->format;\n\n    best_effort_timestamp= av_frame_get_best_effort_timestamp(decoded_frame);\n\n    if (eof && best_effort_timestamp == AV_NOPTS_VALUE && ist->nb_dts_buffer > 0) {\n        best_effort_timestamp = ist->dts_buffer[0];\n\n        for (i = 0; i < ist->nb_dts_buffer - 1; i++)\n            ist->dts_buffer[i] = ist->dts_buffer[i + 1];\n        ist->nb_dts_buffer--;\n    }\n\n    if(best_effort_timestamp != AV_NOPTS_VALUE) {\n        int64_t ts = av_rescale_q(decoded_frame->pts = best_effort_timestamp, ist->st->time_base, AV_TIME_BASE_Q);\n\n        if (ts != AV_NOPTS_VALUE)\n            ist->next_pts = ist->pts = ts;\n    }\n\n    if (debug_ts) {\n        av_log(NULL, AV_LOG_INFO, \"decoder -> ist_index:%d type:video \"\n               \"frame_pts:%s frame_pts_time:%s best_effort_ts:%\"PRId64\" best_effort_ts_time:%s keyframe:%d frame_type:%d time_base:%d/%d\\n\",\n               ist->st->index, av_ts2str(decoded_frame->pts),\n               av_ts2timestr(decoded_frame->pts, &ist->st->time_base),\n               best_effort_timestamp,\n               av_ts2timestr(best_effort_timestamp, &ist->st->time_base),\n               decoded_frame->key_frame, decoded_frame->pict_type,\n               ist->st->time_base.num, ist->st->time_base.den);\n    }\n\n    if (ist->st->sample_aspect_ratio.num)\n        decoded_frame->sample_aspect_ratio = ist->st->sample_aspect_ratio;\n\n    resample_changed = ist->resample_width   != decoded_frame->width  ||\n                       ist->resample_height  != decoded_frame->height ||\n                       ist->resample_pix_fmt != decoded_frame->format;\n    if (resample_changed) {\n        av_log(NULL, AV_LOG_INFO,\n               \"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n               ist->file_index, ist->st->index,\n               ist->resample_width,  ist->resample_height,  av_get_pix_fmt_name(ist->resample_pix_fmt),\n               decoded_frame->width, decoded_frame->height, av_get_pix_fmt_name(decoded_frame->format));\n\n        ist->resample_width   = decoded_frame->width;\n        ist->resample_height  = decoded_frame->height;\n        ist->resample_pix_fmt = decoded_frame->format;\n\n        for (i = 0; i < nb_filtergraphs; i++) {\n            if (ist_in_filtergraph(filtergraphs[i], ist) && ist->reinit_filters &&\n                configure_filtergraph(filtergraphs[i]) < 0) {\n                av_log(NULL, AV_LOG_FATAL, \"Error reinitializing filters!\\n\");\n                exit_program(1);\n            }\n        }\n    }\n\n    frame_sample_aspect= av_opt_ptr(avcodec_get_frame_class(), decoded_frame, \"sample_aspect_ratio\");\n    for (i = 0; i < ist->nb_filters; i++) {\n        if (!frame_sample_aspect->num)\n            *frame_sample_aspect = ist->st->sample_aspect_ratio;\n\n        if (i < ist->nb_filters - 1) {\n            f = ist->filter_frame;\n            err = av_frame_ref(f, decoded_frame);\n            if (err < 0)\n                break;\n        } else\n            f = decoded_frame;\n        err = av_buffersrc_add_frame_flags(ist->filters[i]->filter, f, AV_BUFFERSRC_FLAG_PUSH);\n        if (err == AVERROR_EOF) {\n            err = 0; /* ignore */\n        } else if (err < 0) {\n            av_log(NULL, AV_LOG_FATAL,\n                   \"Failed to inject frame into filter network: %s\\n\", av_err2str(err));\n            exit_program(1);\n        }\n    }\n\nfail:\n    av_frame_unref(ist->filter_frame);\n    av_frame_unref(decoded_frame);\n    return err < 0 ? err : ret;\n}", "target": 0}
{"idx": 5157, "func": "int X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *dest,\n\t\t\t\t\t\tconst X509_VERIFY_PARAM *src)\n\t{\n\tunsigned long inh_flags;\n\tint to_default, to_overwrite;\n\tX509_VERIFY_PARAM_ID *id;\n\tif (!src)\n\t\treturn 1;\n\tid = src->id;\n\tinh_flags = dest->inh_flags | src->inh_flags;\n\n\tif (inh_flags & X509_VP_FLAG_ONCE)\n\t\tdest->inh_flags = 0;\n\n\tif (inh_flags & X509_VP_FLAG_LOCKED)\n\t\treturn 1;\n\n\tif (inh_flags & X509_VP_FLAG_DEFAULT)\n\t\tto_default = 1;\n\telse\n\t\tto_default = 0;\n\n\tif (inh_flags & X509_VP_FLAG_OVERWRITE)\n\t\tto_overwrite = 1;\n\telse\n\t\tto_overwrite = 0;\n\n\tx509_verify_param_copy(purpose, 0);\n\tx509_verify_param_copy(trust, 0);\n\tx509_verify_param_copy(depth, -1);\n\n\t/* If overwrite or check time not set, copy across */\n\n\tif (to_overwrite || !(dest->flags & X509_V_FLAG_USE_CHECK_TIME))\n\t\t{\n\t\tdest->check_time = src->check_time;\n\t\tdest->flags &= ~X509_V_FLAG_USE_CHECK_TIME;\n\t\t/* Don't need to copy flag: that is done below */\n\t\t}\n\n\tif (inh_flags & X509_VP_FLAG_RESET_FLAGS)\n\t\tdest->flags = 0;\n\n\tdest->flags |= src->flags;\n\n\tif (test_x509_verify_param_copy(policies, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_policies(dest, src->policies))\n\t\t\treturn 0;\n\t\t}\n\n\tif (test_x509_verify_param_copy_id(host, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_host(dest, id->host, id->hostlen))\n\t\t\treturn 0;\n\t\t}\n\n\tif (test_x509_verify_param_copy_id(email, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_email(dest, id->email, id->emaillen))\n\t\t\treturn 0;\n\t\t}\n\n\tif (test_x509_verify_param_copy_id(ip, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_ip(dest, id->ip, id->iplen))\n\t\t\treturn 0;\n\t\t}\n\n\treturn 1;\n\t}", "target": 0}
{"idx": 5158, "func": "static int x9_62_test_internal(int nid, const char *r_in, const char *s_in)\n{\n    int ret = 0;\n    const char message[] = \"abc\";\n    unsigned char digest[20];\n    unsigned int dgst_len = 0;\n    EVP_MD_CTX *md_ctx;\n    EC_KEY *key = NULL;\n    ECDSA_SIG *signature = NULL;\n    BIGNUM *r = NULL, *s = NULL;\n    BIGNUM *kinv = NULL, *rp = NULL;\n    const BIGNUM *sig_r, *sig_s;\n\n    if (!TEST_ptr(md_ctx = EVP_MD_CTX_new()))\n        goto x962_int_err;\n\n    /* get the message digest */\n    if (!TEST_true(EVP_DigestInit(md_ctx, EVP_sha1()))\n        || !TEST_true(EVP_DigestUpdate(md_ctx, (const void *)message, 3))\n        || !TEST_true(EVP_DigestFinal(md_ctx, digest, &dgst_len)))\n        goto x962_int_err;\n\n    TEST_info(\"testing %s\", OBJ_nid2sn(nid));\n\n    /* create the key */\n    if (!TEST_ptr(key = EC_KEY_new_by_curve_name(nid)))\n        goto x962_int_err;\n    use_fake = 1;\n    if (!TEST_true(EC_KEY_generate_key(key)))\n        goto x962_int_err;\n\n    /* create the signature */\n    use_fake = 1;\n    /* Use ECDSA_sign_setup to avoid use of ECDSA nonces */\n    if (!TEST_true(ECDSA_sign_setup(key, NULL, &kinv, &rp)))\n        goto x962_int_err;\n    if (!TEST_ptr(signature = ECDSA_do_sign_ex(digest, 20, kinv, rp, key)))\n        goto x962_int_err;\n\n    /* compare the created signature with the expected signature */\n    if (!TEST_ptr(r = BN_new()) || !TEST_ptr(s = BN_new()))\n        goto x962_int_err;\n    if (!TEST_true(BN_dec2bn(&r, r_in)) || !TEST_true(BN_dec2bn(&s, s_in)))\n        goto x962_int_err;\n    ECDSA_SIG_get0(signature, &sig_r, &sig_s);\n    if (!TEST_BN_eq(sig_r, r)\n            || !TEST_BN_eq(sig_s, s))\n        goto x962_int_err;\n\n    /* verify the signature */\n    if (!TEST_int_eq(ECDSA_do_verify(digest, 20, signature, key), 1))\n        goto x962_int_err;\n\n    ret = 1;\n\n x962_int_err:\n    EC_KEY_free(key);\n    ECDSA_SIG_free(signature);\n    BN_free(r);\n    BN_free(s);\n    EVP_MD_CTX_free(md_ctx);\n    BN_clear_free(kinv);\n    BN_clear_free(rp);\n    return ret;\n}", "target": 0}
{"idx": 5159, "func": "static void start_connect(struct connection * c)\n{\n    apr_status_t rv;\n\n    if (!(started < requests))\n    return;\n\n    c->read = 0;\n    c->bread = 0;\n    c->keepalive = 0;\n    c->cbx = 0;\n    c->gotheader = 0;\n    c->rwrite = 0;\n    if (c->ctx)\n        apr_pool_destroy(c->ctx);\n    apr_pool_create(&c->ctx, cntxt);\n\n    if ((rv = apr_socket_create(&c->aprsock, destsa->family,\n                SOCK_STREAM, 0, c->ctx)) != APR_SUCCESS) {\n    apr_err(\"socket\", rv);\n    }\n    if ((rv = apr_socket_opt_set(c->aprsock, APR_SO_NONBLOCK, 1))\n         != APR_SUCCESS) {\n        apr_err(\"socket nonblock\", rv);\n    }\n\n    if (windowsize != 0) {\n        rv = apr_socket_opt_set(c->aprsock, APR_SO_SNDBUF, \n                                windowsize);\n        if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {\n            apr_err(\"socket send buffer\", rv);\n        }\n        rv = apr_socket_opt_set(c->aprsock, APR_SO_RCVBUF, \n                                windowsize);\n        if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {\n            apr_err(\"socket receive buffer\", rv);\n        }\n    }\n\n    c->start = apr_time_now();\n#ifdef USE_SSL\n    if (is_ssl) {\n        BIO *bio;\n        apr_os_sock_t fd;\n\n        if ((c->ssl = SSL_new(ssl_ctx)) == NULL) {\n            BIO_printf(bio_err, \"SSL_new failed.\\n\");\n            ERR_print_errors(bio_err);\n            exit(1);\n        }\n        ssl_rand_seed();\n        apr_os_sock_get(&fd, c->aprsock);\n        bio = BIO_new_socket(fd, BIO_NOCLOSE);\n        SSL_set_bio(c->ssl, bio, bio);\n        SSL_set_connect_state(c->ssl);\n        if (verbosity >= 4) {\n            BIO_set_callback(bio, ssl_print_cb);\n            BIO_set_callback_arg(bio, (void *)bio_err);\n        }\n    } else {\n        c->ssl = NULL;\n    }\n#endif\n    if ((rv = apr_socket_connect(c->aprsock, destsa)) != APR_SUCCESS) {\n        if (APR_STATUS_IS_EINPROGRESS(rv)) {\n            apr_pollfd_t new_pollfd;\n            c->state = STATE_CONNECTING;\n            c->rwrite = 0;\n            new_pollfd.desc_type = APR_POLL_SOCKET;\n            new_pollfd.reqevents = APR_POLLOUT;\n            new_pollfd.desc.s = c->aprsock;\n            new_pollfd.client_data = c;\n            apr_pollset_add(readbits, &new_pollfd);\n            return;\n        }\n        else {\n            apr_pollfd_t remove_pollfd;\n            remove_pollfd.desc_type = APR_POLL_SOCKET;\n            remove_pollfd.desc.s = c->aprsock;\n            apr_pollset_remove(readbits, &remove_pollfd);\n            apr_socket_close(c->aprsock);\n            err_conn++;\n            if (bad++ > 10) {\n                fprintf(stderr,\n                   \"\\nTest aborted after 10 failures\\n\\n\");\n                apr_err(\"apr_socket_connect()\", rv);\n            }\n            c->state = STATE_UNCONNECTED;\n            start_connect(c);\n            return;\n        }\n    }\n\n    /* connected first time */\n    c->state = STATE_CONNECTED;\n    started++;\n#ifdef USE_SSL\n    if (c->ssl) {\n        ssl_proceed_handshake(c);\n    } else\n#endif\n    {\n        write_request(c);\n    }\n}", "target": 1}
{"idx": 5160, "func": "static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)\n{\n    int ich, i;\n    int order        = s->mclms_order;\n    int num_channels = s->num_channels;\n\n    for (ich = 0; ich < num_channels; ich++) {\n        pred[ich] = 0;\n        if (!s->is_channel_coded[ich])\n            continue;\n        for (i = 0; i < order * num_channels; i++)\n            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *\n                         s->mclms_coeffs[i + order * num_channels * ich];\n        for (i = 0; i < ich; i++)\n            pred[ich] += s->channel_residues[i][icoef] *\n                         s->mclms_coeffs_cur[i + num_channels * ich];\n        pred[ich] += 1 << s->mclms_scaling - 1;\n        pred[ich] >>= s->mclms_scaling;\n        s->channel_residues[ich][icoef] += pred[ich];\n    }\n}", "target": 1}
{"idx": 5161, "func": "SSL_SESSION *SSL_SESSION_new(void)\n{\n    SSL_SESSION *ss;\n\n    if (!OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS, NULL))\n        return NULL;\n\n    ss = OPENSSL_zalloc(sizeof(*ss));\n    if (ss == NULL) {\n        SSLerr(SSL_F_SSL_SESSION_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ss->verify_result = 1;      /* avoid 0 (= X509_V_OK) just in case */\n    ss->references = 1;\n    ss->timeout = 60 * 5 + 4;   /* 5 minute timeout by default */\n    ss->time = (unsigned long)time(NULL);\n    ss->lock = CRYPTO_THREAD_lock_new();\n    if (ss->lock == NULL) {\n        SSLerr(SSL_F_SSL_SESSION_NEW, ERR_R_MALLOC_FAILURE);\n        OPENSSL_free(ss);\n        return NULL;\n    }\n\n    if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data)) {\n        CRYPTO_THREAD_lock_free(ss->lock);\n        OPENSSL_free(ss);\n        return NULL;\n    }\n    return ss;\n}", "target": 0}
{"idx": 5162, "func": "int ff_ass_add_rect(AVSubtitle *sub, const char *dialog,\n                    int ts_start, int ts_end, int raw)\n{\n    int len = 0, dlen, duration = ts_end - ts_start;\n    char s_start[16], s_end[16], header[48] = {0};\n    AVSubtitleRect **rects;\n\n    if (!raw) {\n        ts_to_string(s_start, sizeof(s_start), ts_start);\n        ts_to_string(s_end,   sizeof(s_end),   ts_end  );\n        len = snprintf(header, sizeof(header), \"Dialogue: 0,%s,%s,\",\n                       s_start, s_end);\n    }\n\n    dlen = strcspn(dialog, \"\\n\");\n    dlen += dialog[dlen] == '\\n';\n\n    rects = av_realloc(sub->rects, (sub->num_rects+1) * sizeof(*sub->rects));\n    if (!rects)\n        return AVERROR(ENOMEM);\n    sub->rects = rects;\n    sub->end_display_time = FFMAX(sub->end_display_time, 10 * duration);\n    rects[sub->num_rects]       = av_mallocz(sizeof(*rects[0]));\n    rects[sub->num_rects]->type = SUBTITLE_ASS;\n    rects[sub->num_rects]->ass  = av_malloc(len + dlen + 1);\n    strcpy (rects[sub->num_rects]->ass      , header);\n    av_strlcpy(rects[sub->num_rects]->ass + len, dialog, dlen + 1);\n    sub->num_rects++;\n    return dlen;\n}", "target": 0}
{"idx": 5163, "func": "int do_dtls1_write(SSL *s, int type, const unsigned char *buf, unsigned int len, int create_empty_fragment)\n\t{\n\tunsigned char *p,*pseq;\n\tint i,mac_size,clear=0;\n\tint prefix_len = 0;\n\tSSL3_RECORD *wr;\n\tSSL3_BUFFER *wb;\n\tSSL_SESSION *sess;\n\tint bs;\n\n\t/* first check if there is a SSL3_BUFFER still being written\n\t * out.  This will happen with non blocking IO */\n\tif (s->s3->wbuf.left != 0)\n\t\t{\n\t\tOPENSSL_assert(0); /* XDTLS:  want to see if we ever get here */\n\t\treturn(ssl3_write_pending(s,type,buf,len));\n\t\t}\n\n\t/* If we have an alert to send, lets send it */\n\tif (s->s3->alert_dispatch)\n\t\t{\n\t\ti=s->method->ssl_dispatch_alert(s);\n\t\tif (i <= 0)\n\t\t\treturn(i);\n\t\t/* if it went, fall through and send more stuff */\n\t\t}\n\n\tif (len == 0 && !create_empty_fragment)\n\t\treturn 0;\n\n\twr= &(s->s3->wrec);\n\twb= &(s->s3->wbuf);\n\tsess=s->session;\n\n\tif (\t(sess == NULL) ||\n\t\t(s->enc_write_ctx == NULL) ||\n\t\t(EVP_MD_CTX_md(s->write_hash) == NULL))\n\t\tclear=1;\n\n\tif (clear)\n\t\tmac_size=0;\n\telse\n\t\tmac_size=EVP_MD_CTX_size(s->write_hash);\n\n\t/* DTLS implements explicit IV, so no need for empty fragments */\n#if 0\n\t/* 'create_empty_fragment' is true only when this function calls itself */\n\tif (!clear && !create_empty_fragment && !s->s3->empty_fragment_done\n\t\t&& SSL_version(s) != DTLS1_VERSION)\n\t\t{\n\t\t/* countermeasure against known-IV weakness in CBC ciphersuites\n\t\t * (see http://www.openssl.org/~bodo/tls-cbc.txt) \n\t\t */\n\n\t\tif (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA)\n\t\t\t{\n\t\t\t/* recursive function call with 'create_empty_fragment' set;\n\t\t\t * this prepares and buffers the data for an empty fragment\n\t\t\t * (these 'prefix_len' bytes are sent out later\n\t\t\t * together with the actual payload) */\n\t\t\tprefix_len = s->method->do_ssl_write(s, type, buf, 0, 1);\n\t\t\tif (prefix_len <= 0)\n\t\t\t\tgoto err;\n\n\t\t\tif (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE)\n\t\t\t\t{\n\t\t\t\t/* insufficient space */\n\t\t\t\tSSLerr(SSL_F_DO_DTLS1_WRITE, ERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\ts->s3->empty_fragment_done = 1;\n\t\t}\n#endif\n\n\tp = wb->buf + prefix_len;\n\n\t/* write the header */\n\n\t*(p++)=type&0xff;\n\twr->type=type;\n\n\t*(p++)=(s->version>>8);\n\t*(p++)=s->version&0xff;\n\n\t/* field where we are to write out packet epoch, seq num and len */\n\tpseq=p; \n\tp+=10;\n\n\t/* lets setup the record stuff. */\n\n\t/* Make space for the explicit IV in case of CBC.\n\t * (this is a bit of a boundary violation, but what the heck).\n\t */\n\tif ( s->enc_write_ctx && \n\t\t(EVP_CIPHER_mode( s->enc_write_ctx->cipher ) & EVP_CIPH_CBC_MODE))\n\t\tbs = EVP_CIPHER_block_size(s->enc_write_ctx->cipher);\n\telse\n\t\tbs = 0;\n\n\twr->data=p + bs;  /* make room for IV in case of CBC */\n\twr->length=(int)len;\n\twr->input=(unsigned char *)buf;\n\n\t/* we now 'read' from wr->input, wr->length bytes into\n\t * wr->data */\n\n\t/* first we compress */\n\tif (s->compress != NULL)\n\t\t{\n\t\tif (!ssl3_do_compress(s))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_DO_DTLS1_WRITE,SSL_R_COMPRESSION_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy(wr->data,wr->input,wr->length);\n\t\twr->input=wr->data;\n\t\t}\n\n\t/* we should still have the output to wr->data and the input\n\t * from wr->input.  Length should be wr->length.\n\t * wr->data still points in the wb->buf */\n\n\tif (mac_size != 0)\n\t\t{\n\t\ts->method->ssl3_enc->mac(s,&(p[wr->length + bs]),1);\n\t\twr->length+=mac_size;\n\t\t}\n\n\t/* this is true regardless of mac size */\n\twr->input=p;\n\twr->data=p;\n\n\n\t/* ssl3_enc can only have an error on read */\n\tif (bs)\t/* bs != 0 in case of CBC */\n\t\t{\n\t\tRAND_pseudo_bytes(p,bs);\n\t\t/* master IV and last CBC residue stand for\n\t\t * the rest of randomness */\n\t\twr->length += bs;\n\t\t}\n\n\ts->method->ssl3_enc->enc(s,1);\n\n\t/* record length after mac and block padding */\n/*\tif (type == SSL3_RT_APPLICATION_DATA ||\n\t(type == SSL3_RT_ALERT && ! SSL_in_init(s))) */\n\t\n\t/* there's only one epoch between handshake and app data */\n\t\n\ts2n(s->d1->w_epoch, pseq);\n\n\t/* XDTLS: ?? */\n/*\telse\n\ts2n(s->d1->handshake_epoch, pseq); */\n\n\tmemcpy(pseq, &(s->s3->write_sequence[2]), 6);\n\tpseq+=6;\n\ts2n(wr->length,pseq);\n\n\t/* we should now have\n\t * wr->data pointing to the encrypted data, which is\n\t * wr->length long */\n\twr->type=type; /* not needed but helps for debugging */\n\twr->length+=DTLS1_RT_HEADER_LENGTH;\n\n#if 0  /* this is now done at the message layer */\n\t/* buffer the record, making it easy to handle retransmits */\n\tif ( type == SSL3_RT_HANDSHAKE || type == SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\tdtls1_buffer_record(s, wr->data, wr->length, \n\t\t\t*((PQ_64BIT *)&(s->s3->write_sequence[0])));\n#endif\n\n\tssl3_record_sequence_update(&(s->s3->write_sequence[0]));\n\n\tif (create_empty_fragment)\n\t\t{\n\t\t/* we are in a recursive call;\n\t\t * just return the length, don't write out anything here\n\t\t */\n\t\treturn wr->length;\n\t\t}\n\n\t/* now let's set up wb */\n\twb->left = prefix_len + wr->length;\n\twb->offset = 0;\n\n\t/* memorize arguments so that ssl3_write_pending can detect bad write retries later */\n\ts->s3->wpend_tot=len;\n\ts->s3->wpend_buf=buf;\n\ts->s3->wpend_type=type;\n\ts->s3->wpend_ret=len;\n\n\t/* we now just need to write the buffer */\n\treturn ssl3_write_pending(s,type,buf,len);\nerr:\n\treturn -1;\n\t}", "target": 0}
{"idx": 5164, "func": "int i2d_X509_NAME(X509_NAME *a, unsigned char **pp)\n\t{\n\tint ret;\n\n\tif (a == NULL) return(0);\n\tif (a->modified)\n\t\t{\n\t\tret=i2d_X509_NAME_entries(a);\n\t\tif (ret < 0) return(ret);\n\t\t}\n\n\tret=a->bytes->length;\n\tif (pp != NULL)\n\t\t{\n\t\tmemcpy(*pp,a->bytes->data,ret);\n\t\t*pp+=ret;\n\t\t}\n\treturn(ret);\n\t}", "target": 1}
{"idx": 5165, "func": "int attribute_align_arg avcodec_encode_audio(AVCodecContext *avctx, uint8_t *buf, int buf_size,\n                         const short *samples)\n{\n    if(buf_size < FF_MIN_BUFFER_SIZE && 0){\n        av_log(avctx, AV_LOG_ERROR, \"buffer smaller than minimum size\\n\");\n        return -1;\n    }\n    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || samples){\n        int ret = avctx->codec->encode(avctx, buf, buf_size, samples);\n        avctx->frame_number++;\n        return ret;\n    }else\n        return 0;\n}", "target": 1}
{"idx": 5166, "func": "void FUNC(ff_emulated_edge_mc)(uint8_t *buf, const uint8_t *src,\n                                      ptrdiff_t linesize,\n                                      int block_w, int block_h,\n                                      int src_x, int src_y, int w, int h)\n{\n    int x, y;\n    int start_y, start_x, end_y, end_x;\n\n    if (!w || !h)\n        return;\n\n    if (src_y >= h) {\n        src -= src_y * linesize;\n        src += (h - 1) * linesize;\n        src_y = h - 1;\n    } else if (src_y <= -block_h) {\n        src -= src_y * linesize;\n        src += (1 - block_h) * linesize;\n        src_y = 1 - block_h;\n    }\n    if (src_x >= w) {\n        src  += (w - 1 - src_x) * sizeof(pixel);\n        src_x = w - 1;\n    } else if (src_x <= -block_w) {\n        src  += (1 - block_w - src_x) * sizeof(pixel);\n        src_x = 1 - block_w;\n    }\n\n    start_y = FFMAX(0, -src_y);\n    start_x = FFMAX(0, -src_x);\n    end_y = FFMIN(block_h, h-src_y);\n    end_x = FFMIN(block_w, w-src_x);\n    av_assert2(start_y < end_y && block_h);\n    av_assert2(start_x < end_x && block_w);\n\n    w    = end_x - start_x;\n    src += start_y * linesize + start_x * sizeof(pixel);\n    buf += start_x * sizeof(pixel);\n\n    // top\n    for (y = 0; y < start_y; y++) {\n        memcpy(buf, src, w * sizeof(pixel));\n        buf += linesize;\n    }\n\n    // copy existing part\n    for (; y < end_y; y++) {\n        memcpy(buf, src, w * sizeof(pixel));\n        src += linesize;\n        buf += linesize;\n    }\n\n    // bottom\n    src -= linesize;\n    for (; y < block_h; y++) {\n        memcpy(buf, src, w * sizeof(pixel));\n        buf += linesize;\n    }\n\n    buf -= block_h * linesize + start_x * sizeof(pixel);\n    while (block_h--) {\n        pixel *bufp = (pixel *) buf;\n\n        // left\n        for(x = 0; x < start_x; x++) {\n            bufp[x] = bufp[start_x];\n        }\n\n        // right\n        for (x = end_x; x < block_w; x++) {\n            bufp[x] = bufp[end_x - 1];\n        }\n        buf += linesize;\n    }\n}", "target": 0}
{"idx": 5167, "func": "int opt_default(const char *opt, const char *arg)\n{\n    const AVOption *oc, *of, *os, *oswr = NULL;\n    char opt_stripped[128];\n    const char *p;\n    const AVClass *cc = avcodec_get_class(), *fc = avformat_get_class(), *sc, *swr_class;\n\n    if (!(p = strchr(opt, ':')))\n        p = opt + strlen(opt);\n    av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));\n\n    if ((oc = av_opt_find(&cc, opt_stripped, NULL, 0,\n                         AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) ||\n        ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&\n         (oc = av_opt_find(&cc, opt + 1, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ))))\n        av_dict_set(&codec_opts, opt, arg, FLAGS(oc));\n    if ((of = av_opt_find(&fc, opt, NULL, 0,\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)))\n        av_dict_set(&format_opts, opt, arg, FLAGS(of));\n#if CONFIG_SWSCALE\n    sc = sws_get_class();\n    if ((os = av_opt_find(&sc, opt, NULL, 0,\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n        // XXX we only support sws_flags, not arbitrary sws options\n        int ret = av_opt_set(sws_opts, opt, arg, 0);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n            return ret;\n        }\n    }\n#endif\n    swr_class = swr_get_class();\n    if (!oc && !of && !os && (oswr = av_opt_find(&swr_class, opt, NULL, 0,\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n        int ret = av_opt_set(swr_opts, opt, arg, 0);\n        if (ret < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n            return ret;\n        }\n    }\n\n    if (oc || of || os || oswr)\n        return 0;\n    av_log(NULL, AV_LOG_ERROR, \"Unrecognized option '%s'\\n\", opt);\n    return AVERROR_OPTION_NOT_FOUND;\n}", "target": 0}
{"idx": 5168, "func": "static int tak_read_header(AVFormatContext *s)\n{\n    TAKDemuxContext *tc = s->priv_data;\n    AVIOContext *pb     = s->pb;\n    GetBitContext gb;\n    AVStream *st;\n    uint8_t *buffer = NULL;\n    int ret;\n\n    st = avformat_new_stream(s, 0);\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    st->codecpar->codec_id   = AV_CODEC_ID_TAK;\n    st->need_parsing         = AVSTREAM_PARSE_FULL_RAW;\n\n    tc->mlast_frame = 0;\n    if (avio_rl32(pb) != MKTAG('t', 'B', 'a', 'K')) {\n        avio_seek(pb, -4, SEEK_CUR);\n        return 0;\n    }\n\n    while (!avio_feof(pb)) {\n        enum TAKMetaDataType type;\n        int size;\n\n        type = avio_r8(pb) & 0x7f;\n        size = avio_rl24(pb);\n\n        switch (type) {\n        case TAK_METADATA_STREAMINFO:\n        case TAK_METADATA_LAST_FRAME:\n        case TAK_METADATA_ENCODER:\n            if (size <= 3)\n                return AVERROR_INVALIDDATA;\n\n            buffer = av_malloc(size - 3 + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!buffer)\n                return AVERROR(ENOMEM);\n            memset(buffer + size - 3, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n            ffio_init_checksum(pb, tak_check_crc, 0xCE04B7U);\n            if (avio_read(pb, buffer, size - 3) != size - 3) {\n                av_freep(&buffer);\n                return AVERROR(EIO);\n            }\n            if (ffio_get_checksum(s->pb) != avio_rb24(pb)) {\n                av_log(s, AV_LOG_ERROR, \"%d metadata block CRC error.\\n\", type);\n                if (s->error_recognition & AV_EF_EXPLODE) {\n                    av_freep(&buffer);\n                    return AVERROR_INVALIDDATA;\n                }\n            }\n\n            break;\n        case TAK_METADATA_MD5: {\n            uint8_t md5[16];\n            int i;\n\n            if (size != 19)\n                return AVERROR_INVALIDDATA;\n            ffio_init_checksum(pb, tak_check_crc, 0xCE04B7U);\n            avio_read(pb, md5, 16);\n            if (ffio_get_checksum(s->pb) != avio_rb24(pb)) {\n                av_log(s, AV_LOG_ERROR, \"MD5 metadata block CRC error.\\n\");\n                if (s->error_recognition & AV_EF_EXPLODE)\n                    return AVERROR_INVALIDDATA;\n            }\n\n            av_log(s, AV_LOG_VERBOSE, \"MD5=\");\n            for (i = 0; i < 16; i++)\n                av_log(s, AV_LOG_VERBOSE, \"%02x\", md5[i]);\n            av_log(s, AV_LOG_VERBOSE, \"\\n\");\n            break;\n        }\n        case TAK_METADATA_END: {\n            int64_t curpos = avio_tell(pb);\n\n            if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n                ff_ape_parse_tag(s);\n                avio_seek(pb, curpos, SEEK_SET);\n            }\n\n            tc->data_end += curpos;\n            return 0;\n        }\n        default:\n            ret = avio_skip(pb, size);\n            if (ret < 0)\n                return ret;\n        }\n\n        if (type == TAK_METADATA_STREAMINFO) {\n            TAKStreamInfo ti;\n\n            ret = avpriv_tak_parse_streaminfo(&ti, buffer, size -3);\n            if (ret < 0)\n                return AVERROR_INVALIDDATA;\n            if (ti.samples > 0)\n                st->duration = ti.samples;\n            st->codecpar->bits_per_coded_sample = ti.bps;\n            if (ti.ch_layout)\n                st->codecpar->channel_layout = ti.ch_layout;\n            st->codecpar->sample_rate           = ti.sample_rate;\n            st->codecpar->channels              = ti.channels;\n            st->start_time                   = 0;\n            avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);\n            st->codecpar->extradata             = buffer;\n            st->codecpar->extradata_size        = size - 3;\n            buffer                           = NULL;\n        } else if (type == TAK_METADATA_LAST_FRAME) {\n            if (size != 11)\n                return AVERROR_INVALIDDATA;\n            init_get_bits8(&gb, buffer, size - 3);\n            tc->mlast_frame = 1;\n            tc->data_end    = get_bits64(&gb, TAK_LAST_FRAME_POS_BITS) +\n                              get_bits(&gb, TAK_LAST_FRAME_SIZE_BITS);\n            av_freep(&buffer);\n        } else if (type == TAK_METADATA_ENCODER) {\n            init_get_bits8(&gb, buffer, size - 3);\n            av_log(s, AV_LOG_VERBOSE, \"encoder version: %0X\\n\",\n                   get_bits_long(&gb, TAK_ENCODER_VERSION_BITS));\n            av_freep(&buffer);\n        }\n    }\n\n    return AVERROR_EOF;\n}", "target": 0}
{"idx": 5169, "func": "static av_always_inline int vp8_simple_limit(uint8_t *p, ptrdiff_t stride, int flim)\n{\n    LOAD_PIXELS\n    return 2*FFABS(p0-q0) + (FFABS(p1-q1) >> 1) <= flim;\n}", "target": 0}
{"idx": 5170, "func": "int ff_ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band, IVITile *tile)\n{\n    int         mbn, blk, num_blocks, num_coeffs, blk_size, scan_pos, run, val,\n                pos, is_intra, mc_type, mv_x, mv_y, col_mask;\n    uint8_t     col_flags[8];\n    int32_t     prev_dc, trvec[64];\n    uint32_t    cbp, sym, lo, hi, quant, buf_offs, q;\n    IVIMbInfo   *mb;\n    RVMapDesc   *rvmap = band->rv_map;\n    void (*mc_with_delta_func)(int16_t *buf, const int16_t *ref_buf, uint32_t pitch, int mc_type);\n    void (*mc_no_delta_func)  (int16_t *buf, const int16_t *ref_buf, uint32_t pitch, int mc_type);\n    const uint8_t   *base_tab, *scale_tab;\n\n    prev_dc = 0; /* init intra prediction for the DC coefficient */\n\n    blk_size   = band->blk_size;\n    col_mask   = blk_size - 1; /* column mask for tracking non-zero coeffs */\n    num_blocks = (band->mb_size != blk_size) ? 4 : 1; /* number of blocks per mb */\n    num_coeffs = blk_size * blk_size;\n    if (blk_size == 8) {\n        mc_with_delta_func = ff_ivi_mc_8x8_delta;\n        mc_no_delta_func   = ff_ivi_mc_8x8_no_delta;\n    } else {\n        mc_with_delta_func = ff_ivi_mc_4x4_delta;\n        mc_no_delta_func   = ff_ivi_mc_4x4_no_delta;\n    }\n\n    for (mbn = 0, mb = tile->mbs; mbn < tile->num_MBs; mb++, mbn++) {\n        is_intra = !mb->type;\n        cbp      = mb->cbp;\n        buf_offs = mb->buf_offs;\n\n        quant = av_clip(band->glob_quant + mb->q_delta, 0, 23);\n\n        base_tab  = is_intra ? band->intra_base  : band->inter_base;\n        scale_tab = is_intra ? band->intra_scale : band->inter_scale;\n\n        if (!is_intra) {\n            mv_x = mb->mv_x;\n            mv_y = mb->mv_y;\n            if (!band->is_halfpel) {\n                mc_type = 0; /* we have only fullpel vectors */\n            } else {\n                mc_type = ((mv_y & 1) << 1) | (mv_x & 1);\n                mv_x >>= 1;\n                mv_y >>= 1; /* convert halfpel vectors into fullpel ones */\n            }\n        }\n\n        for (blk = 0; blk < num_blocks; blk++) {\n            /* adjust block position in the buffer according to its number */\n            if (blk & 1) {\n                buf_offs += blk_size;\n            } else if (blk == 2) {\n                buf_offs -= blk_size;\n                buf_offs += blk_size * band->pitch;\n            }\n\n            if (cbp & 1) { /* block coded ? */\n                scan_pos = -1;\n                memset(trvec, 0, num_coeffs*sizeof(trvec[0])); /* zero transform vector */\n                memset(col_flags, 0, sizeof(col_flags));      /* zero column flags */\n\n                while (scan_pos <= num_coeffs) {\n                    sym = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);\n                    if (sym == rvmap->eob_sym)\n                        break; /* End of block */\n\n                    if (sym == rvmap->esc_sym) { /* Escape - run/val explicitly coded using 3 vlc codes */\n                        run = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1) + 1;\n                        lo  = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);\n                        hi  = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);\n                        val = IVI_TOSIGNED((hi << 6) | lo); /* merge them and convert into signed val */\n                    } else {\n                        run = rvmap->runtab[sym];\n                        val = rvmap->valtab[sym];\n                    }\n\n                    /* de-zigzag and dequantize */\n                    scan_pos += run;\n                    if (scan_pos >= num_coeffs)\n                        break;\n                    pos = band->scan[scan_pos];\n\n                    if (IVI_DEBUG && !val)\n                        av_log(NULL, AV_LOG_ERROR, \"Val = 0 encountered!\\n\");\n\n                    q = (base_tab[pos] * scale_tab[quant]) >> 8;\n                    if (q > 1)\n                        val = val * q + FFSIGN(val) * ((q >> 1) - (q & 1));\n                    trvec[pos] = val;\n                    col_flags[pos & col_mask] |= !!val; /* track columns containing non-zero coeffs */\n                }// while\n\n                if (scan_pos >= num_coeffs && sym != rvmap->eob_sym)\n                    return -1; /* corrupt block data */\n\n                /* undoing DC coeff prediction for intra-blocks */\n                if (is_intra && band->is_2d_trans) {\n                    prev_dc      += trvec[0];\n                    trvec[0]      = prev_dc;\n                    col_flags[0] |= !!prev_dc;\n                }\n\n                /* apply inverse transform */\n                band->inv_transform(trvec, band->buf + buf_offs,\n                                    band->pitch, col_flags);\n\n                /* apply motion compensation */\n                if (!is_intra)\n                    mc_with_delta_func(band->buf + buf_offs,\n                                       band->ref_buf + buf_offs + mv_y * band->pitch + mv_x,\n                                       band->pitch, mc_type);\n            } else {\n                /* block not coded */\n                /* for intra blocks apply the dc slant transform */\n                /* for inter - perform the motion compensation without delta */\n                if (is_intra && band->dc_transform) {\n                    band->dc_transform(&prev_dc, band->buf + buf_offs,\n                                       band->pitch, blk_size);\n                } else\n                    mc_no_delta_func(band->buf + buf_offs,\n                                     band->ref_buf + buf_offs + mv_y * band->pitch + mv_x,\n                                     band->pitch, mc_type);\n            }\n\n            cbp >>= 1;\n        }// for blk\n    }// for mbn\n\n    align_get_bits(gb);\n\n    return 0;\n}", "target": 1}
{"idx": 5171, "func": "static POLICYQUALINFO *notice_section(X509V3_CTX *ctx,\n\t\t\t\t\tSTACK_OF(CONF_VALUE) *unot, int ia5org)\n{\n\tint i, ret;\n\tCONF_VALUE *cnf;\n\tUSERNOTICE *not;\n\tPOLICYQUALINFO *qual;\n\tif(!(qual = POLICYQUALINFO_new())) goto merr;\n\tqual->pqualid = OBJ_nid2obj(NID_id_qt_unotice);\n\tif(!(not = USERNOTICE_new())) goto merr;\n\tqual->d.usernotice = not;\n\tfor(i = 0; i < sk_CONF_VALUE_num(unot); i++) {\n\t\tcnf = sk_CONF_VALUE_value(unot, i);\n\t\tif(!strcmp(cnf->name, \"explicitText\")) {\n\t\t\tnot->exptext = M_ASN1_VISIBLESTRING_new();\n\t\t\tif(!ASN1_STRING_set(not->exptext, cnf->value,\n\t\t\t\t\t\t strlen(cnf->value))) goto merr;\n\t\t} else if(!strcmp(cnf->name, \"organization\")) {\n\t\t\tNOTICEREF *nref;\n\t\t\tif(!not->noticeref) {\n\t\t\t\tif(!(nref = NOTICEREF_new())) goto merr;\n\t\t\t\tnot->noticeref = nref;\n\t\t\t} else nref = not->noticeref;\n\t\t\tif(ia5org) nref->organization->type = V_ASN1_IA5STRING;\n\t\t\telse nref->organization->type = V_ASN1_VISIBLESTRING;\n\t\t\tif(!ASN1_STRING_set(nref->organization, cnf->value,\n\t\t\t\t\t\t strlen(cnf->value))) goto merr;\n\t\t} else if(!strcmp(cnf->name, \"noticeNumbers\")) {\n\t\t\tNOTICEREF *nref;\n\t\t\tSTACK_OF(CONF_VALUE) *nos;\n\t\t\tif(!not->noticeref) {\n\t\t\t\tif(!(nref = NOTICEREF_new())) goto merr;\n\t\t\t\tnot->noticeref = nref;\n\t\t\t} else nref = not->noticeref;\n\t\t\tnos = X509V3_parse_list(cnf->value);\n\t\t\tif(!nos || !sk_CONF_VALUE_num(nos)) {\n\t\t\t\tX509V3err(X509V3_F_NOTICE_SECTION,X509V3_R_INVALID_NUMBERS);\n\t\t\t\tX509V3_conf_err(cnf);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tret = nref_nos(nref->noticenos, nos);\n\t\t\tsk_CONF_VALUE_pop_free(nos, X509V3_conf_free);\n\t\t\tif (!ret)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\tX509V3err(X509V3_F_NOTICE_SECTION,X509V3_R_INVALID_OPTION);\n\t\t\tX509V3_conf_err(cnf);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif(not->noticeref && \n\t      (!not->noticeref->noticenos || !not->noticeref->organization)) {\n\t\t\tX509V3err(X509V3_F_NOTICE_SECTION,X509V3_R_NEED_ORGANIZATION_AND_NUMBERS);\n\t\t\tgoto err;\n\t}\n\n\treturn qual;\n\n\tmerr:\n\tX509V3err(X509V3_F_NOTICE_SECTION,ERR_R_MALLOC_FAILURE);\n\n\terr:\n\tPOLICYQUALINFO_free(qual);\n\treturn NULL;\n}", "target": 0}
{"idx": 5172, "func": "static void vc1_inv_trans_4x4_c(uint8_t *dest, int linesize, DCTELEM *block)\n{\n    int i;\n    register int t1,t2,t3,t4;\n    DCTELEM *src, *dst;\n\n    src = block;\n    dst = block;\n    for(i = 0; i < 4; i++){\n        t1 = 17 * (src[0] + src[2]) + 4;\n        t2 = 17 * (src[0] - src[2]) + 4;\n        t3 = 22 * src[1] + 10 * src[3];\n        t4 = 22 * src[3] - 10 * src[1];\n\n        dst[0] = (t1 + t3) >> 3;\n        dst[1] = (t2 - t4) >> 3;\n        dst[2] = (t2 + t4) >> 3;\n        dst[3] = (t1 - t3) >> 3;\n\n        src += 8;\n        dst += 8;\n    }\n\n    src = block;\n    for(i = 0; i < 4; i++){\n        t1 = 17 * (src[ 0] + src[16]) + 64;\n        t2 = 17 * (src[ 0] - src[16]) + 64;\n        t3 = 22 * src[ 8] + 10 * src[24];\n        t4 = 22 * src[24] - 10 * src[ 8];\n\n        dest[0*linesize] = av_clip_uint8(dest[0*linesize] + ((t1 + t3) >> 7));\n        dest[1*linesize] = av_clip_uint8(dest[1*linesize] + ((t2 - t4) >> 7));\n        dest[2*linesize] = av_clip_uint8(dest[2*linesize] + ((t2 + t4) >> 7));\n        dest[3*linesize] = av_clip_uint8(dest[3*linesize] + ((t1 - t3) >> 7));\n\n        src ++;\n        dest++;\n    }\n}", "target": 0}
{"idx": 5173, "func": "static int BN_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont)\n\t{\n\tBIGNUM *n;\n\tBN_ULONG *ap,*np,*rp,n0,v,*nrp;\n\tint al,nl,max,i,x,ri;\n\n\tn= &(mont->N);\n\t/* mont->ri is the size of mont->N in bits (rounded up\n\t   to the word size) */\n\tal=ri=mont->ri/BN_BITS2;\n\n\tnl=n->top;\n\tif ((al == 0) || (nl == 0)) { ret->top=0; return(1); }\n\n\tmax=(nl+al+1); /* allow for overflow (no?) XXX */\n\tif (bn_wexpand(r,max) == NULL) return(0);\n\n\tr->neg^=n->neg;\n\tnp=n->d;\n\trp=r->d;\n\tnrp= &(r->d[nl]);\n\n\t/* clear the top words of T */\n#if 1\n\tfor (i=r->top; i<max; i++) /* memset? XXX */\n\t\tr->d[i]=0;\n#else\n\tmemset(&(r->d[r->top]),0,(max-r->top)*sizeof(BN_ULONG)); \n#endif\n\n\tr->top=max;\n\tn0=mont->n0[0];\n\n#ifdef BN_COUNT\n\tfprintf(stderr,\"word BN_from_montgomery_word %d * %d\\n\",nl,nl);\n#endif\n\tfor (i=0; i<nl; i++)\n\t\t{\n#ifdef __TANDEM\n                {\n                   long long t1;\n                   long long t2;\n                   long long t3;\n                   t1 = rp[0] * (n0 & 0177777);\n                   t2 = 037777600000l;\n                   t2 = n0 & t2;\n                   t3 = rp[0] & 0177777;\n                   t2 = (t3 * t2) & BN_MASK2;\n                   t1 = t1 + t2;\n                   v=bn_mul_add_words(rp,np,nl,(BN_ULONG) t1);\n                }\n#else\n\t\tv=bn_mul_add_words(rp,np,nl,(rp[0]*n0)&BN_MASK2);\n#endif\n\t\tnrp++;\n\t\trp++;\n\t\tif (((nrp[-1]+=v)&BN_MASK2) >= v)\n\t\t\tcontinue;\n\t\telse\n\t\t\t{\n\t\t\tif (((++nrp[0])&BN_MASK2) != 0) continue;\n\t\t\tif (((++nrp[1])&BN_MASK2) != 0) continue;\n\t\t\tfor (x=2; (((++nrp[x])&BN_MASK2) == 0); x++) ;\n\t\t\t}\n\t\t}\n\tbn_correct_top(r);\n\n\t/* mont->ri will be a multiple of the word size and below code\n\t * is kind of BN_rshift(ret,r,mont->ri) equivalent */\n\tif (r->top < ri)\n\t\t{\n\t\tret->top=0;\n\t\treturn(1);\n\t\t}\n\tal=r->top-ri;\n\n#define BRANCH_FREE 1\n#if BRANCH_FREE\n\tif (bn_wexpand(ret,ri) == NULL) return(0);\n\tx=0-(((al-ri)>>(sizeof(al)*8-1))&1);\n\tret->top=x=(ri&~x)|(al&x);\t/* min(ri,al) */\n\tret->neg=r->neg;\n\n\trp=ret->d;\n\tap=&(r->d[ri]);\n\tnrp=ap;\n\n\t/* This 'if' denotes violation of 2*M<r^(n-1) boundary condition\n\t * formulated by C.D.Walter in \"Montgomery exponentiation needs\n\t * no final subtractions.\" Incurred branch can disclose only\n\t * information about modulus length, which is not really secret. */\n\tif ((mont->N.d[ri-1]>>(BN_BITS2-2))!=0)\n\t\t{\n\t\tsize_t m1,m2;\n\n\t\tv=bn_sub_words(rp,ap,mont->N.d,ri);\n\t\t/* if (al==ri && !v) || al>ri)\tnrp=rp; */\n\t\t/* in other words if subtraction result is real, then\n\t\t * trick unconditional memcpy below to make \"refresh\"\n\t\t * instead of real copy. */\n\t\tm1=0-(size_t)(((al-ri)>>(sizeof(al)*8-1))&1);\t/* al<ri */\n\t\tm2=0-(size_t)(((ri-al)>>(sizeof(al)*8-1))&1);\t/* al>ri */\n\t\tm1=~(m1|m2);\t\t/* (al==ri) */\n\t\tm1&=~(0-(size_t)v);\t/* (al==ri && !v) */\n\t\tm1|=m2;\t\t\t/* (al==ri && !v) || al>ri */\n\t\tnrp=(BN_ULONG *)(((size_t)rp&m1)|((size_t)ap&~m1));\n\t\t}\n\n\tfor (i=0,ri-=4; i<ri; i+=4)\n\t\t{\n\t\tBN_ULONG t1,t2,t3,t4;\n\t\t\n\t\tt1=nrp[i+0];\n\t\tt2=nrp[i+1];\n\t\tt3=nrp[i+2];\tap[i+0]=0;\n\t\tt4=nrp[i+3];\tap[i+1]=0;\n\t\trp[i+0]=t1;\tap[i+2]=0;\n\t\trp[i+1]=t2;\tap[i+3]=0;\n\t\trp[i+2]=t3;\n\t\trp[i+3]=t4;\n\t\t}\n\tfor (ri+=4; i<ri; i++)\n\t\trp[i]=nrp[i], ap[i]=0;\n#else\n\tif (bn_wexpand(ret,al) == NULL) return(0);\n\tret->top=al;\n\tret->neg=r->neg;\n\n\trp=ret->d;\n\tap=&(r->d[ri]);\n\tal-=4;\n\tfor (i=0; i<al; i+=4)\n\t\t{\n\t\tBN_ULONG t1,t2,t3,t4;\n\t\t\n\t\tt1=ap[i+0];\n\t\tt2=ap[i+1];\n\t\tt3=ap[i+2];\n\t\tt4=ap[i+3];\n\t\trp[i+0]=t1;\n\t\trp[i+1]=t2;\n\t\trp[i+2]=t3;\n\t\trp[i+3]=t4;\n\t\t}\n\tal+=4;\n\tfor (; i<al; i++)\n\t\trp[i]=ap[i];\n\n\tif (BN_ucmp(ret, &(mont->N)) >= 0)\n\t\t{\n\t\tif (!BN_usub(ret,ret,&(mont->N))) return(0);\n\t\t}\n#endif\n\tbn_check_top(ret);\n\n\treturn(1);\n\t}", "target": 0}
{"idx": 5174, "func": "static void blend_frame(AVFilterContext *ctx,\n                        AVFrame *top_buf,\n                        AVFrame *bottom_buf,\n                        AVFrame *dst_buf)\n{\n    BlendContext *b = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    FilterParams *param;\n    int plane;\n\n    for (plane = 0; plane < b->nb_planes; plane++) {\n        int hsub = plane == 1 || plane == 2 ? b->hsub : 0;\n        int vsub = plane == 1 || plane == 2 ? b->vsub : 0;\n        int outw = dst_buf->width  >> hsub;\n        int outh = dst_buf->height >> vsub;\n        uint8_t *dst    = dst_buf->data[plane];\n        uint8_t *top    = top_buf->data[plane];\n        uint8_t *bottom = bottom_buf->data[plane];\n\n        param = &b->params[plane];\n        param->values[VAR_N]  = inlink->frame_count;\n        param->values[VAR_T]  = dst_buf->pts == AV_NOPTS_VALUE ? NAN : dst_buf->pts * av_q2d(inlink->time_base);\n        param->values[VAR_W]  = outw;\n        param->values[VAR_H]  = outh;\n        param->values[VAR_SW] = outw / dst_buf->width;\n        param->values[VAR_SH] = outh / dst_buf->height;\n        param->blend(top, top_buf->linesize[plane],\n                     bottom, bottom_buf->linesize[plane],\n                     dst, dst_buf->linesize[plane], outw, outh, param);\n    }\n}", "target": 0}
{"idx": 5175, "func": "void RAND_DRBG_free(DRBG_CTX *dctx)\n{\n    if (dctx == NULL)\n        return;\n\n    ctr_uninstantiate(dctx);\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DRBG, dctx, &dctx->ex_data);\n\n    /* Don't free up default DRBG */\n    if (dctx == RAND_DRBG_get_default()) {\n        memset(dctx, 0, sizeof(DRBG_CTX));\n        dctx->nid = 0;\n        dctx->status = DRBG_STATUS_UNINITIALISED;\n    } else {\n        OPENSSL_cleanse(&dctx->ctr, sizeof(dctx->ctr));\n        OPENSSL_free(dctx);\n    }\n}", "target": 1}
{"idx": 5176, "func": "static int test_ssl_corrupt(int testidx)\n{\n    static unsigned char junk[16000] = { 0 };\n    SSL_CTX *sctx = NULL, *cctx = NULL;\n    SSL *server = NULL, *client = NULL;\n    BIO *c_to_s_fbio;\n    int testresult = 0;\n    STACK_OF(SSL_CIPHER) *ciphers;\n    const SSL_CIPHER *currcipher;\n\n    docorrupt = 0;\n\n    TEST_info(\"Starting #%d, %s\", testidx, cipher_list[testidx]);\n\n    if (!TEST_true(create_ssl_ctx_pair(TLS_server_method(), TLS_client_method(),\n                                       TLS1_VERSION, TLS_MAX_VERSION,\n                                       &sctx, &cctx, cert, privkey)))\n        return 0;\n\n    if (!TEST_true(SSL_CTX_set_cipher_list(cctx, cipher_list[testidx]))\n            || !TEST_true(SSL_CTX_set_ciphersuites(cctx, \"\"))\n            || !TEST_ptr(ciphers = SSL_CTX_get_ciphers(cctx))\n            || !TEST_int_eq(sk_SSL_CIPHER_num(ciphers), 1)\n            || !TEST_ptr(currcipher = sk_SSL_CIPHER_value(ciphers, 0)))\n        goto end;\n\n    /*\n     * No ciphers we are using are TLSv1.3 compatible so we should not attempt\n     * to negotiate TLSv1.3\n     */\n    if (!TEST_true(SSL_CTX_set_max_proto_version(cctx, TLS1_2_VERSION)))\n        goto end;\n\n    if (!TEST_ptr(c_to_s_fbio = BIO_new(bio_f_tls_corrupt_filter())))\n        goto end;\n\n    /* BIO is freed by create_ssl_connection on error */\n    if (!TEST_true(create_ssl_objects(sctx, cctx, &server, &client, NULL,\n                                      c_to_s_fbio)))\n        goto end;\n\n    if (!TEST_true(create_ssl_connection(server, client, SSL_ERROR_NONE)))\n        goto end;\n\n    docorrupt = 1;\n\n    if (!TEST_int_ge(SSL_write(client, junk, sizeof(junk)), 0))\n        goto end;\n\n    if (!TEST_int_lt(SSL_read(server, junk, sizeof(junk)), 0))\n        goto end;\n\n    if (!TEST_int_eq(ERR_GET_REASON(ERR_peek_error()),\n                     SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC))\n        goto end;\n\n    testresult = 1;\n end:\n    SSL_free(server);\n    SSL_free(client);\n    SSL_CTX_free(sctx);\n    SSL_CTX_free(cctx);\n    return testresult;\n}", "target": 0}
{"idx": 5177, "func": "static int decode_block(BinkAudioContext *s, short *out, int use_dct)\n{\n    int ch, i, j, k;\n    float q, quant[25];\n    int width, coeff;\n    GetBitContext *gb = &s->gb;\n\n    if (use_dct)\n        skip_bits(gb, 2);\n\n    for (ch = 0; ch < s->channels; ch++) {\n        FFTSample *coeffs = s->coeffs_ptr[ch];\n        if (s->version_b) {\n            if (get_bits_left(gb) < 64)\n                return AVERROR_INVALIDDATA;\n            coeffs[0] = av_int2flt(get_bits(gb, 32)) * s->root;\n            coeffs[1] = av_int2flt(get_bits(gb, 32)) * s->root;\n        } else {\n            if (get_bits_left(gb) < 58)\n                return AVERROR_INVALIDDATA;\n            coeffs[0] = get_float(gb) * s->root;\n            coeffs[1] = get_float(gb) * s->root;\n        }\n\n        if (get_bits_left(gb) < s->num_bands * 8)\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < s->num_bands; i++) {\n            /* constant is result of 0.066399999/log10(M_E) */\n            int value = get_bits(gb, 8);\n            quant[i] = expf(FFMIN(value, 95) * 0.15289164787221953823f) * s->root;\n        }\n\n        k = 0;\n        q = quant[0];\n\n        // parse coefficients\n        i = 2;\n        while (i < s->frame_len) {\n            if (s->version_b) {\n                j = i + 16;\n            } else {\n                int v;\n                GET_BITS_SAFE(v, 1);\n                if (v) {\n                    GET_BITS_SAFE(v, 4);\n                    j = i + rle_length_tab[v] * 8;\n                } else {\n                    j = i + 8;\n                }\n            }\n\n            j = FFMIN(j, s->frame_len);\n\n            GET_BITS_SAFE(width, 4);\n            if (width == 0) {\n                memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n                i = j;\n                while (s->bands[k] < i)\n                    q = quant[k++];\n            } else {\n                while (i < j) {\n                    if (s->bands[k] == i)\n                        q = quant[k++];\n                    GET_BITS_SAFE(coeff, width);\n                    if (coeff) {\n                        int v;\n                        GET_BITS_SAFE(v, 1);\n                        if (v)\n                            coeffs[i] = -q * coeff;\n                        else\n                            coeffs[i] =  q * coeff;\n                    } else {\n                        coeffs[i] = 0.0f;\n                    }\n                    i++;\n                }\n            }\n        }\n\n        if (CONFIG_BINKAUDIO_DCT_DECODER && use_dct) {\n            coeffs[0] /= 0.5;\n            s->trans.dct.dct_calc(&s->trans.dct,  coeffs);\n            s->dsp.vector_fmul_scalar(coeffs, coeffs, s->frame_len / 2, s->frame_len);\n        }\n        else if (CONFIG_BINKAUDIO_RDFT_DECODER)\n            s->trans.rdft.rdft_calc(&s->trans.rdft, coeffs);\n    }\n\n    s->fmt_conv.float_to_int16_interleave(out, (const float **)s->coeffs_ptr,\n                                          s->frame_len, s->channels);\n\n    if (!s->first) {\n        int count = s->overlap_len * s->channels;\n        int shift = av_log2(count);\n        for (i = 0; i < count; i++) {\n            out[i] = (s->previous[i] * (count - i) + out[i] * i) >> shift;\n        }\n    }\n\n    memcpy(s->previous, out + s->block_size,\n           s->overlap_len * s->channels * sizeof(*out));\n\n    s->first = 0;\n\n    return 0;\n}", "target": 0}
{"idx": 5178, "func": "static inline unsigned int get_bits(GetBitContext *s, int n)\n{\n    register int tmp;\n    OPEN_READER(re, s);\n    av_assert2(n>0 && n<=25);\n    UPDATE_CACHE(re, s);\n    tmp = SHOW_UBITS(re, s, n);\n    LAST_SKIP_BITS(re, s, n);\n    CLOSE_READER(re, s);\n    return tmp;\n}", "target": 1}
{"idx": 5179, "func": "int BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\n{\n    int max, min, dif;\n    const BN_ULONG *ap, *bp;\n    BN_ULONG *rp, carry, t1, t2;\n    const BIGNUM *tmp;\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    if (a->top < b->top) {\n        tmp = a;\n        a = b;\n        b = tmp;\n    }\n    max = a->top;\n    min = b->top;\n    dif = max - min;\n\n    if (bn_wexpand(r, max + 1) == NULL)\n        return 0;\n\n    r->top = max;\n\n    ap = a->d;\n    bp = b->d;\n    rp = r->d;\n\n    carry = bn_add_words(rp, ap, bp, min);\n    rp += min;\n    ap += min;\n    bp += min;\n\n    if (carry) {\n        while (dif) {\n            dif--;\n            t1 = *(ap++);\n            t2 = (t1 + 1) & BN_MASK2;\n            *(rp++) = t2;\n            if (t2) {\n                carry = 0;\n                break;\n            }\n        }\n        if (carry) {\n            /* carry != 0 => dif == 0 */\n            *rp = 1;\n            r->top++;\n        }\n    }\n    if (dif && rp != ap)\n        while (dif--)\n            /* copy remaining words if ap != rp */\n            *(rp++) = *(ap++);\n    r->neg = 0;\n    bn_check_top(r);\n    return 1;\n}", "target": 0}
{"idx": 5180, "func": "static int plot_cqt(AVFilterContext *ctx)\n{\n    AVFilterLink *outlink = ctx->outputs[0];\n    ShowCQTContext *s = ctx->priv;\n    int ret = 0;\n\n    memcpy(s->fft_result, s->fft_data, s->fft_len * sizeof(*s->fft_data));\n    av_fft_permute(s->fft_ctx, s->fft_result);\n    av_fft_calc(s->fft_ctx, s->fft_result);\n    s->fft_result[s->fft_len] = s->fft_result[0];\n    s->cqt_calc(s->cqt_result, s->fft_result, s->coeffs, s->cqt_len, s->fft_len);\n    process_cqt(s);\n    if (s->sono_h)\n        s->update_sono(s->sono_frame, s->c_buf, s->sono_idx);\n    if (!s->sono_count) {\n        AVFrame *out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out)\n            return AVERROR(ENOMEM);\n        if (s->bar_h)\n            s->draw_bar(out, s->h_buf, s->rcp_h_buf, s->c_buf, s->bar_h);\n        if (s->axis_h)\n            s->draw_axis(out, s->axis_frame, s->c_buf, s->bar_h);\n        if (s->sono_h)\n            s->draw_sono(out, s->sono_frame, s->bar_h + s->axis_h, s->sono_idx);\n        out->pts = s->frame_count;\n        ret = ff_filter_frame(outlink, out);\n        s->frame_count++;\n    }\n    s->sono_count = (s->sono_count + 1) % s->count;\n    if (s->sono_h)\n        s->sono_idx = (s->sono_idx + s->sono_h - 1) % s->sono_h;\n    return ret;\n}", "target": 0}
{"idx": 5181, "func": "static void fill_buffer(AVIOContext *s)\n{\n    int max_buffer_size = s->max_packet_size ?\n                          s->max_packet_size : IO_BUFFER_SIZE;\n    uint8_t *dst        = s->buf_end - s->buffer + max_buffer_size < s->buffer_size ?\n                          s->buf_end : s->buffer;\n    int len             = s->buffer_size - (dst - s->buffer);\n\n    /* can't fill the buffer without read_packet, just set EOF if appropriate */\n    if (!s->read_packet && s->buf_ptr >= s->buf_end)\n        s->eof_reached = 1;\n\n    /* no need to do anything if EOF already reached */\n    if (s->eof_reached)\n        return;\n\n    if (s->update_checksum && dst == s->buffer) {\n        if (s->buf_end > s->checksum_ptr)\n            s->checksum = s->update_checksum(s->checksum, s->checksum_ptr,\n                                             s->buf_end - s->checksum_ptr);\n        s->checksum_ptr = s->buffer;\n    }\n\n    /* make buffer smaller in case it ended up large after probing */\n    if (s->read_packet && s->orig_buffer_size && s->buffer_size > s->orig_buffer_size) {\n        if (dst == s->buffer && s->buf_ptr != dst) {\n            int ret = ffio_set_buf_size(s, s->orig_buffer_size);\n            if (ret < 0)\n                av_log(s, AV_LOG_WARNING, \"Failed to decrease buffer size\\n\");\n\n            s->checksum_ptr = dst = s->buffer;\n        }\n        av_assert0(len >= s->orig_buffer_size);\n        len = s->orig_buffer_size;\n    }\n\n    len = read_packet_wrapper(s, dst, len);\n    if (len == AVERROR_EOF) {\n        /* do not modify buffer if EOF reached so that a seek back can\n           be done without rereading data */\n        s->eof_reached = 1;\n    } else if (len < 0) {\n        s->eof_reached = 1;\n        s->error= len;\n    } else {\n        s->pos += len;\n        s->buf_ptr = dst;\n        s->buf_end = dst + len;\n        s->bytes_read += len;\n    }\n}", "target": 0}
{"idx": 5182, "func": "static av_always_inline void decode_bgr_1(HYuvContext *s, int count,\n                                          int decorrelate, int alpha)\n{\n    int i;\n    OPEN_READER(re, &s->gb);\n\n    for (i = 0; i < count && BITS_LEFT(re, &s->gb) > 0; i++) {\n        unsigned int index;\n        int code, n;\n\n        UPDATE_CACHE(re, &s->gb);\n        index = SHOW_UBITS(re, &s->gb, VLC_BITS);\n        n     = s->vlc[4].table[index][1];\n\n        if (n>0) {\n            code  = s->vlc[4].table[index][0];\n            *(uint32_t *) &s->temp[0][4 * i] = s->pix_bgr_map[code];\n            LAST_SKIP_BITS(re, &s->gb, n);\n        } else {\n            int nb_bits;\n            if (decorrelate) {\n                VLC_INTERN(s->temp[0][4 * i + G], s->vlc[1].table,\n                           &s->gb, re, VLC_BITS, 3);\n\n                UPDATE_CACHE(re, &s->gb);\n                index = SHOW_UBITS(re, &s->gb, VLC_BITS);\n                VLC_INTERN(code, s->vlc[0].table, &s->gb, re, VLC_BITS, 3);\n                s->temp[0][4 * i + B] = code + s->temp[0][4 * i + G];\n\n                UPDATE_CACHE(re, &s->gb);\n                index = SHOW_UBITS(re, &s->gb, VLC_BITS);\n                VLC_INTERN(code, s->vlc[2].table, &s->gb, re, VLC_BITS, 3);\n                s->temp[0][4 * i + R] = code + s->temp[0][4 * i + G];\n            } else {\n                VLC_INTERN(s->temp[0][4 * i + B], s->vlc[0].table,\n                           &s->gb, re, VLC_BITS, 3);\n\n                UPDATE_CACHE(re, &s->gb);\n                index = SHOW_UBITS(re, &s->gb, VLC_BITS);\n                VLC_INTERN(s->temp[0][4 * i + G], s->vlc[1].table,\n                           &s->gb, re, VLC_BITS, 3);\n\n                UPDATE_CACHE(re, &s->gb);\n                index = SHOW_UBITS(re, &s->gb, VLC_BITS);\n                VLC_INTERN(s->temp[0][4 * i + R], s->vlc[2].table,\n                           &s->gb, re, VLC_BITS, 3);\n            }\n            if (alpha) {\n                UPDATE_CACHE(re, &s->gb);\n                index = SHOW_UBITS(re, &s->gb, VLC_BITS);\n                VLC_INTERN(s->temp[0][4 * i + A], s->vlc[2].table,\n                           &s->gb, re, VLC_BITS, 3);\n            } else\n                s->temp[0][4 * i + A] = 0;\n        }\n    }\n    CLOSE_READER(re, &s->gb);\n}", "target": 0}
{"idx": 5183, "func": "static inline void flush_put_bits(PutBitContext *s)\n{\n#ifndef BITSTREAM_WRITER_LE\n    if (s->bit_left < 32)\n        s->bit_buf <<= s->bit_left;\n#endif\n    while (s->bit_left < 32) {\n        av_assert0(s->buf_ptr < s->buf_end);\n#ifdef BITSTREAM_WRITER_LE\n        *s->buf_ptr++ = s->bit_buf;\n        s->bit_buf  >>= 8;\n#else\n        *s->buf_ptr++ = s->bit_buf >> 24;\n        s->bit_buf  <<= 8;\n#endif\n        s->bit_left  += 8;\n    }\n    s->bit_left = 32;\n    s->bit_buf  = 0;\n}", "target": 1}
{"idx": 5184, "func": "static int readContigTilesIntoBuffer (TIFF* in, uint8* buf, \n                                      uint32 imagelength, \n                                      uint32 imagewidth, \n                                      uint32 tw, uint32 tl,\n                                      tsample_t spp, uint16 bps)\n  {\n  int status = 1;\n  tsample_t sample = 0;\n  tsample_t count = spp; \n  uint32 row, col, trow;\n  uint32 nrow, ncol;\n  uint32 dst_rowsize, shift_width;\n  uint32 bytes_per_sample, bytes_per_pixel;\n  uint32 trailing_bits, prev_trailing_bits;\n  uint32 tile_rowsize  = TIFFTileRowSize(in);\n  uint32 src_offset, dst_offset;\n  uint32 row_offset, col_offset;\n  uint8 *bufp = (uint8*) buf;\n  unsigned char *src = NULL;\n  unsigned char *dst = NULL;\n  tsize_t tbytes = 0, tile_buffsize = 0;\n  tsize_t tilesize = TIFFTileSize(in);\n  unsigned char *tilebuf = NULL;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n\n  tile_buffsize = tilesize;\n  if (tilesize == 0 || tile_rowsize == 0)\n  {\n     TIFFError(\"readContigTilesIntoBuffer\", \"Tile size or tile rowsize is zero\");\n     exit(-1);\n  }\n\n  if (tilesize < (tsize_t)(tl * tile_rowsize))\n    {\n#ifdef DEBUG2\n    TIFFError(\"readContigTilesIntoBuffer\",\n\t      \"Tilesize %lu is too small, using alternate calculation %u\",\n              tilesize, tl * tile_rowsize);\n#endif\n    tile_buffsize = tl * tile_rowsize;\n    if (tl != (tile_buffsize / tile_rowsize))\n    {\n    \tTIFFError(\"readContigTilesIntoBuffer\", \"Integer overflow when calculating buffer size.\");\n        exit(-1);\n    }\n    }\n\n  /* Add 3 padding bytes for extractContigSamplesShifted32bits */\n  if( (size_t) tile_buffsize > 0xFFFFFFFFU - 3U )\n  {\n      TIFFError(\"readContigTilesIntoBuffer\", \"Integer overflow when calculating buffer size.\");\n      exit(-1);\n  }\n  tilebuf = _TIFFmalloc(tile_buffsize + 3);\n  if (tilebuf == 0)\n    return 0;\n  tilebuf[tile_buffsize] = 0;\n  tilebuf[tile_buffsize+1] = 0;\n  tilebuf[tile_buffsize+2] = 0;\n\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  \n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);\n      if (tbytes < tilesize  && !ignore)\n        {\n\tTIFFError(TIFFFileName(in),\n\t\t  \"Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu\",\n\t\t  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,\n                  (unsigned long)tilesize);\n\t\t  status = 0;\n                  _TIFFfree(tilebuf);\n\t\t  return status;\n\t}\n      \n      row_offset = row * dst_rowsize;\n      col_offset = ((col * bps * spp) + 7)/ 8;\n      bufp = buf + row_offset + col_offset;\n\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      /* Each tile scanline will start on a byte boundary but it\n       * has to be merged into the scanline for the entire\n       * image buffer and the previous segment may not have\n       * ended on a byte boundary\n       */\n      /* Optimization for common bit depths, all samples */\n      if (((bps % 8) == 0) && (count == spp))\n        {\n\tfor (trow = 0; trow < nrow; trow++)\n          {\n\t  src_offset = trow * tile_rowsize;\n\t  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);\n          bufp += (imagewidth * bps * spp) / 8;\n\t  }\n        }\n      else\n        {\n\t/* Bit depths not a multiple of 8 and/or extract fewer than spp samples */\n        prev_trailing_bits = trailing_bits = 0;\n        trailing_bits = (ncol * bps * spp) % 8;\n\n\t/*\tfor (trow = 0; tl < nrow; trow++) */\n\tfor (trow = 0; trow < nrow; trow++)\n          {\n\t  src_offset = trow * tile_rowsize;\n          src = tilebuf + src_offset;\n\t  dst_offset = (row + trow) * dst_rowsize;\n          dst = buf + dst_offset + col_offset;\n          switch (shift_width)\n            {\n            case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,\n                                                   spp, bps, count, 0, ncol))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t\t\trow, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            case 1: if (bps == 1)\n                      { \n                      if (extractContigSamplesShifted8bits (src, dst, ncol,\n                                                            sample, spp,\n                                                            bps, count,\n                                                            0, ncol,\n                                                            prev_trailing_bits))\n                        {\n\t\t        TIFFError(\"readContigTilesIntoBuffer\",\n                                  \"Unable to extract row %d from tile %lu\", \n\t\t\t\t  row, (unsigned long)TIFFCurrentTile(in));\n\t\t        return 1;\n\t\t        }\n\t\t      break;\n\t\t      }\n                    else\n                      if (extractContigSamplesShifted16bits (src, dst, ncol,\n                                                             sample, spp,\n                                                             bps, count,\n                                                             0, ncol,\n                                                             prev_trailing_bits))\n                        {\n\t\t        TIFFError(\"readContigTilesIntoBuffer\",\n                                  \"Unable to extract row %d from tile %lu\", \n\t\t\t  \t  row, (unsigned long)TIFFCurrentTile(in));\n\t\t        return 1;\n\t\t        }\n\t            break;\n            case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,\n                                                           sample, spp,\n                                                           bps, count,\n                                                           0, ncol,\n                                                           prev_trailing_bits))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t  \t        row, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            case 3:\n            case 4:\n            case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,\n                                                           sample, spp,\n                                                           bps, count,\n                                                           0, ncol,\n                                                           prev_trailing_bits))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t\t        row, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            default: TIFFError(\"readContigTilesIntoBuffer\", \"Unsupported bit depth %d\", bps);\n\t\t     return 1;\n\t    }\n          }\n        prev_trailing_bits += trailing_bits;\n        /* if (prev_trailing_bits > 7) */\n\t/*   prev_trailing_bits-= 8; */\n\t}\n      }\n    }\n\n  _TIFFfree(tilebuf);\n  return status;\n  }", "target": 1}
{"idx": 5185, "func": "static int sh_init(size_t size, int minsize)\n{\n    int i, ret;\n    size_t pgsize;\n    size_t aligned;\n\n    memset(&sh, 0, sizeof sh);\n\n    /* make sure size and minsize are powers of 2 */\n    OPENSSL_assert(size > 0);\n    OPENSSL_assert((size & (size - 1)) == 0);\n    OPENSSL_assert(minsize > 0);\n    OPENSSL_assert((minsize & (minsize - 1)) == 0);\n    if (size <= 0 || (size & (size - 1)) != 0)\n        goto err;\n    if (minsize <= 0 || (minsize & (minsize - 1)) != 0)\n        goto err;\n\n    sh.arena_size = size;\n    sh.minsize = minsize;\n    sh.bittable_size = (sh.arena_size / sh.minsize) * 2;\n\n    sh.freelist_size = -1;\n    for (i = sh.bittable_size; i; i >>= 1)\n        sh.freelist_size++;\n\n    sh.freelist = OPENSSL_zalloc(sh.freelist_size * sizeof (char *));\n    OPENSSL_assert(sh.freelist != NULL);\n    if (sh.freelist == NULL)\n        goto err;\n\n    sh.bittable = OPENSSL_zalloc(sh.bittable_size >> 3);\n    OPENSSL_assert(sh.bittable != NULL);\n    if (sh.bittable == NULL)\n        goto err;\n\n    sh.bitmalloc = OPENSSL_zalloc(sh.bittable_size >> 3);\n    OPENSSL_assert(sh.bitmalloc != NULL);\n    if (sh.bitmalloc == NULL)\n        goto err;\n\n    /* Allocate space for heap, and two extra pages as guards */\n#if defined(_SC_PAGE_SIZE) || defined (_SC_PAGESIZE)\n    {\n# if defined(_SC_PAGE_SIZE)\n        long tmppgsize = sysconf(_SC_PAGE_SIZE);\n# else\n        long tmppgsize = sysconf(_SC_PAGESIZE);\n# endif\n        if (tmppgsize < 1)\n            pgsize = PAGE_SIZE;\n        else\n            pgsize = (size_t)tmppgsize;\n    }\n#else\n    pgsize = PAGE_SIZE;\n#endif\n    sh.map_size = pgsize + sh.arena_size + pgsize;\n    if (1) {\n#ifdef MAP_ANON\n        sh.map_result = mmap(NULL, sh.map_size,\n                             PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);\n    } else {\n#endif\n        int fd;\n\n        sh.map_result = MAP_FAILED;\n        if ((fd = open(\"/dev/zero\", O_RDWR)) >= 0) {\n            sh.map_result = mmap(NULL, sh.map_size,\n                                 PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);\n            close(fd);\n        }\n    }\n    OPENSSL_assert(sh.map_result != MAP_FAILED);\n    if (sh.map_result == MAP_FAILED)\n        goto err;\n    sh.arena = (char *)(sh.map_result + pgsize);\n    sh_setbit(sh.arena, 0, sh.bittable);\n    sh_add_to_list(&sh.freelist[0], sh.arena);\n\n    /* Now try to add guard pages and lock into memory. */\n    ret = 1;\n\n    /* Starting guard is already aligned from mmap. */\n    if (mprotect(sh.map_result, pgsize, PROT_NONE) < 0)\n        ret = 2;\n\n    /* Ending guard page - need to round up to page boundary */\n    aligned = (pgsize + sh.arena_size + (pgsize - 1)) & ~(pgsize - 1);\n    if (mprotect(sh.map_result + aligned, pgsize, PROT_NONE) < 0)\n        ret = 2;\n\n    if (mlock(sh.arena, sh.arena_size) < 0)\n        ret = 2;\n#ifdef MADV_DONTDUMP\n    if (madvise(sh.arena, sh.arena_size, MADV_DONTDUMP) < 0)\n        ret = 2;\n#endif\n\n    return ret;\n\n err:\n    sh_done();\n    return 0;\n}", "target": 0}
{"idx": 5186, "func": "static inline void update_rice(APERice *rice, int x)\n{\n    int lim = rice->k ? (1 << (rice->k + 4)) : 0;\n    rice->ksum += ((x + 1) / 2) - ((rice->ksum + 16) >> 5);\n\n    if (rice->ksum < lim)\n        rice->k--;\n    else if (rice->ksum >= (1 << (rice->k + 5)))\n        rice->k++;\n}", "target": 0}
{"idx": 5187, "func": "static ngx_chain_t *\nngx_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *cl)\n{\n    size_t         total, size;\n    u_char        *prev;\n    ngx_uint_t     n;\n    struct iovec  *iov;\n\n    iov = NULL;\n    prev = NULL;\n    total = 0;\n    n = 0;\n\n    for ( /* void */ ; cl; cl = cl->next) {\n\n        if (ngx_buf_special(cl->buf)) {\n            continue;\n        }\n\n        size = cl->buf->last - cl->buf->pos;\n\n        if (prev == cl->buf->pos) {\n            iov->iov_len += size;\n\n        } else {\n            if (n == vec->nalloc) {\n                break;\n            }\n\n            iov = &vec->iovs[n++];\n\n            iov->iov_base = (void *) cl->buf->pos;\n            iov->iov_len = size;\n        }\n\n        prev = cl->buf->pos + size;\n        total += size;\n    }\n\n    vec->count = n;\n    vec->size = total;\n\n    return cl;\n}", "target": 0}
{"idx": 5188, "func": "int ssl3_client_hello(SSL *s)\n\t{\n\tunsigned char *buf;\n\tunsigned char *p,*d;\n\tint i;\n\tunsigned long Time,l;\n#ifndef OPENSSL_NO_COMP\n\tint j;\n\tSSL_COMP *comp;\n#endif\n\n\tbuf=(unsigned char *)s->init_buf->data;\n\tif (s->state == SSL3_ST_CW_CLNT_HELLO_A)\n\t\t{\n\t\tSSL_SESSION *sess = s->session;\n\t\tif ((sess == NULL) ||\n\t\t\t(sess->ssl_version != s->version) ||\n#ifdef OPENSSL_NO_TLSEXT\n\t\t\t!sess->session_id_length ||\n#else\n\t\t\t(!sess->session_id_length && !sess->tlsext_tick) ||\n#endif\n\t\t\t(sess->not_resumable))\n\t\t\t{\n\t\t\tif (!ssl_get_new_session(s,0))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t/* else use the pre-loaded session */\n\n\t\tp=s->s3->client_random;\n\n\t\t/* for DTLS if client_random is initialized, reuse it, we are\n\t\t * required to use same upon reply to HelloVerify */\n\t\tif (SSL_IS_DTLS(s))\n\t\t\t{\n\t\t\tsize_t idx;\n\t\t\ti = 1;\n\t\t\tfor (idx=0; idx < sizeof(s->s3->client_random); idx++)\n\t\t\t\t{\n\t\t\t\tif (p[idx])\n\t\t\t\t\t{\n\t\t\t\t\ti = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\telse \n\t\t\ti = 1;\n\n\t\tif (i)\n\t\t\t{\n\t\t\tTime=(unsigned long)time(NULL);\t/* Time */\n\t\t\tl2n(Time,p);\n\t\t\tRAND_pseudo_bytes(p,sizeof(s->s3->client_random)-4);\n\t\t\t}\n\n\t\t/* Do the message type and length last */\n\t\td=p= ssl_handshake_start(s);\n\n\t\t/* version indicates the negotiated version: for example from\n\t\t * an SSLv2/v3 compatible client hello). The client_version\n\t\t * field is the maximum version we permit and it is also\n\t\t * used in RSA encrypted premaster secrets. Some servers can\n\t\t * choke if we initially report a higher version then\n\t\t * renegotiate to a lower one in the premaster secret. This\n\t\t * didn't happen with TLS 1.0 as most servers supported it\n\t\t * but it can with TLS 1.1 or later if the server only supports\n\t\t * 1.0.\n\t\t *\n\t\t * Possible scenario with previous logic:\n\t\t * \t1. Client hello indicates TLS 1.2\n\t\t * \t2. Server hello says TLS 1.0\n\t\t *\t3. RSA encrypted premaster secret uses 1.2.\n\t\t * \t4. Handhaked proceeds using TLS 1.0.\n\t\t *\t5. Server sends hello request to renegotiate.\n\t\t *\t6. Client hello indicates TLS v1.0 as we now\n\t\t *\t   know that is maximum server supports.\n\t\t *\t7. Server chokes on RSA encrypted premaster secret\n\t\t *\t   containing version 1.0.\n\t\t *\n\t\t * For interoperability it should be OK to always use the\n\t\t * maximum version we support in client hello and then rely\n\t\t * on the checking of version to ensure the servers isn't\n\t\t * being inconsistent: for example initially negotiating with\n\t\t * TLS 1.0 and renegotiating with TLS 1.2. We do this by using\n\t\t * client_version in client hello and not resetting it to\n\t\t * the negotiated version.\n\t\t */\n#if 0\n\t\t*(p++)=s->version>>8;\n\t\t*(p++)=s->version&0xff;\n\t\ts->client_version=s->version;\n#else\n\t\t*(p++)=s->client_version>>8;\n\t\t*(p++)=s->client_version&0xff;\n#endif\n\n\t\t/* Random stuff */\n\t\tmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\n\t\tp+=SSL3_RANDOM_SIZE;\n\n\t\t/* Session ID */\n\t\tif (s->new_session)\n\t\t\ti=0;\n\t\telse\n\t\t\ti=s->session->session_id_length;\n\t\t*(p++)=i;\n\t\tif (i != 0)\n\t\t\t{\n\t\t\tif (i > (int)sizeof(s->session->session_id))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tmemcpy(p,s->session->session_id,i);\n\t\t\tp+=i;\n\t\t\t}\n\t\t\n\t\t/* cookie stuff for DTLS */\n\t\tif (SSL_IS_DTLS(s))\n\t\t\t{\n\t\t\tif ( s->d1->cookie_len > sizeof(s->d1->cookie))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t*(p++) = s->d1->cookie_len;\n\t\t\tmemcpy(p, s->d1->cookie, s->d1->cookie_len);\n\t\t\tp += s->d1->cookie_len;\n\t\t\t}\n\t\t\n\t\t/* Ciphers supported */\n\t\ti=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]),0);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);\n\t\t\tgoto err;\n\t\t\t}\n#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH\n\t\t\t/* Some servers hang if client hello > 256 bytes\n\t\t\t * as hack workaround chop number of supported ciphers\n\t\t\t * to keep it well below this if we use TLS v1.2\n\t\t\t */\n\t\t\tif (TLS1_get_version(s) >= TLS1_2_VERSION\n\t\t\t\t&& i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)\n\t\t\t\ti = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;\n#endif\n\t\ts2n(i,p);\n\t\tp+=i;\n\n\t\t/* COMPRESSION */\n#ifdef OPENSSL_NO_COMP\n\t\t*(p++)=1;\n#else\n\n\t\tif ((s->options & SSL_OP_NO_COMPRESSION)\n\t\t\t\t\t|| !s->ctx->comp_methods)\n\t\t\tj=0;\n\t\telse\n\t\t\tj=sk_SSL_COMP_num(s->ctx->comp_methods);\n\t\t*(p++)=1+j;\n\t\tfor (i=0; i<j; i++)\n\t\t\t{\n\t\t\tcomp=sk_SSL_COMP_value(s->ctx->comp_methods,i);\n\t\t\t*(p++)=comp->id;\n\t\t\t}\n#endif\n\t\t*(p++)=0; /* Add the NULL method */\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\t/* TLS extensions*/\n\t\tif (ssl_prepare_clienthello_tlsext(s) <= 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CLIENT_HELLO,SSL_R_CLIENTHELLO_TLSEXT);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif ((p = ssl_add_clienthello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n#endif\n\t\t\n\t\tl= p-d;\n\t\tssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l);\n\t\ts->state=SSL3_ST_CW_CLNT_HELLO_B;\n\t\t}\n\n\t/* SSL3_ST_CW_CLNT_HELLO_B */\n\treturn ssl_do_write(s);\nerr:\n\treturn(-1);\n\t}", "target": 0}
{"idx": 5189, "func": "void swr_compensate(struct SwrContext *s, int sample_delta, int compensation_distance){\n    ResampleContext *c= s->resample;\n//    sample_delta += (c->ideal_dst_incr - c->dst_incr)*(int64_t)c->compensation_distance / c->ideal_dst_incr;\n    c->compensation_distance= compensation_distance;\n    c->dst_incr = c->ideal_dst_incr - c->ideal_dst_incr * (int64_t)sample_delta / compensation_distance;\n}", "target": 1}
{"idx": 5190, "func": "static av_always_inline void\nyuv2rgb48_2_c_template(SwsContext *c, const uint16_t *buf0,\n                       const uint16_t *buf1, const uint16_t *ubuf0,\n                       const uint16_t *ubuf1, const uint16_t *vbuf0,\n                       const uint16_t *vbuf1, const uint16_t *abuf0,\n                       const uint16_t *abuf1, uint8_t *dest, int dstW,\n                       int yalpha, int uvalpha, int y,\n                       enum PixelFormat target)\n{\n    int  yalpha1 = 4095 - yalpha;\n    int uvalpha1 = 4095 - uvalpha;\n    int i;\n\n    for (i = 0; i < (dstW >> 1); i++) {\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n        const uint8_t *r = (const uint8_t *) c->table_rV[V],\n                      *g = (const uint8_t *)(c->table_gU[U] + c->table_gV[V]),\n                      *b = (const uint8_t *) c->table_bU[U];\n\n        dest[ 0] = dest[ 1] = r_b[Y1];\n        dest[ 2] = dest[ 3] =   g[Y1];\n        dest[ 4] = dest[ 5] = b_r[Y1];\n        dest[ 6] = dest[ 7] = r_b[Y2];\n        dest[ 8] = dest[ 9] =   g[Y2];\n        dest[10] = dest[11] = b_r[Y2];\n        dest += 12;\n    }\n}", "target": 1}
{"idx": 5191, "func": "static int add_metadata(int count, int type,\n                        const char *name, const char *sep, TiffContext *s)\n{\n    switch(type) {\n    case TIFF_DOUBLE: return add_doubles_metadata(count, name, sep, s);\n    case TIFF_SHORT : return add_shorts_metadata(count, name, sep, s);\n    default         : return AVERROR_INVALIDDATA;\n    };\n}", "target": 0}
{"idx": 5192, "func": "int ff_rtsp_open_transport_ctx(AVFormatContext *s, RTSPStream *rtsp_st)\n{\n    RTSPState *rt = s->priv_data;\n    AVStream *st = NULL;\n    int reordering_queue_size = rt->reordering_queue_size;\n    if (reordering_queue_size < 0) {\n        if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP || !s->max_delay)\n            reordering_queue_size = 0;\n        else\n            reordering_queue_size = RTP_REORDER_QUEUE_DEFAULT_SIZE;\n    }\n\n    /* open the RTP context */\n    if (rtsp_st->stream_index >= 0)\n        st = s->streams[rtsp_st->stream_index];\n    if (!st)\n        s->ctx_flags |= AVFMTCTX_NOHEADER;\n\n    if (CONFIG_RTSP_MUXER && s->oformat) {\n        int ret = ff_rtp_chain_mux_open((AVFormatContext **)&rtsp_st->transport_priv,\n                                        s, st, rtsp_st->rtp_handle,\n                                        RTSP_TCP_MAX_PACKET_SIZE,\n                                        rtsp_st->stream_index);\n        /* Ownership of rtp_handle is passed to the rtp mux context */\n        rtsp_st->rtp_handle = NULL;\n        if (ret < 0)\n            return ret;\n        st->time_base = ((AVFormatContext*)rtsp_st->transport_priv)->streams[0]->time_base;\n    } else if (rt->transport == RTSP_TRANSPORT_RAW) {\n        return 0; // Don't need to open any parser here\n    } else if (CONFIG_RTPDEC && rt->transport == RTSP_TRANSPORT_RDT)\n        rtsp_st->transport_priv = ff_rdt_parse_open(s, st->index,\n                                            rtsp_st->dynamic_protocol_context,\n                                            rtsp_st->dynamic_handler);\n    else if (CONFIG_RTPDEC)\n        rtsp_st->transport_priv = ff_rtp_parse_open(s, st,\n                                         rtsp_st->sdp_payload_type,\n                                         reordering_queue_size);\n\n    if (!rtsp_st->transport_priv) {\n         return AVERROR(ENOMEM);\n    } else if (CONFIG_RTPDEC && rt->transport == RTSP_TRANSPORT_RTP) {\n        if (rtsp_st->dynamic_handler) {\n            ff_rtp_parse_set_dynamic_protocol(rtsp_st->transport_priv,\n                                              rtsp_st->dynamic_protocol_context,\n                                              rtsp_st->dynamic_handler);\n        }\n        if (rtsp_st->crypto_suite[0])\n            ff_rtp_parse_set_crypto(rtsp_st->transport_priv,\n                                    rtsp_st->crypto_suite,\n                                    rtsp_st->crypto_params);\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5193, "func": "static int ftp_current_dir(FTPContext *s)\n{\n    char *res = NULL, *start = NULL, *end = NULL;\n    int i;\n    const char *command = \"PWD\\r\\n\";\n    const int pwd_codes[] = {257, 0};\n\n    if (ftp_send_command(s, command, pwd_codes, &res) != 257 || !res)\n        goto fail;\n\n    for (i = 0; res[i]; ++i) {\n        if (res[i] == '\"') {\n            if (!start) {\n                start = res + i + 1;\n                continue;\n            }\n            end = res + i;\n            break;\n        }\n    }\n\n    if (!end)\n        goto fail;\n\n    if (end > res && end[-1] == '/') {\n        end[-1] = '\\0';\n    } else\n        *end = '\\0';\n    av_strlcpy(s->path, start, sizeof(s->path));\n\n    av_free(res);\n    return 0;\n\n  fail:\n    av_free(res);\n    return AVERROR(EIO);\n}", "target": 0}
{"idx": 5194, "func": "static uint64_t sniff_channel_order(uint8_t (*layout_map)[3], int tags)\n{\n    int i, n, total_non_cc_elements;\n    struct elem_to_channel e2c_vec[MAX_ELEM_ID] = {{ 0 }};\n    int num_front_channels, num_side_channels, num_back_channels;\n    uint64_t layout;\n\n    i = 0;\n    num_front_channels =\n        count_paired_channels(layout_map, tags, AAC_CHANNEL_FRONT, &i);\n    if (num_front_channels < 0)\n        return 0;\n    num_side_channels =\n        count_paired_channels(layout_map, tags, AAC_CHANNEL_SIDE, &i);\n    if (num_side_channels < 0)\n        return 0;\n    num_back_channels =\n        count_paired_channels(layout_map, tags, AAC_CHANNEL_BACK, &i);\n    if (num_back_channels < 0)\n        return 0;\n\n    i = 0;\n    if (num_front_channels & 1) {\n        e2c_vec[i] = (struct elem_to_channel) {\n            .av_position = AV_CH_FRONT_CENTER, .syn_ele = TYPE_SCE,\n            .elem_id = layout_map[i][1], .aac_position = AAC_CHANNEL_FRONT };\n        i++;\n        num_front_channels--;\n    }\n    if (num_front_channels >= 4) {\n        i += assign_pair(e2c_vec, layout_map, i, tags,\n                         AV_CH_FRONT_LEFT_OF_CENTER,\n                         AV_CH_FRONT_RIGHT_OF_CENTER,\n                         AAC_CHANNEL_FRONT);\n        num_front_channels -= 2;\n    }\n    if (num_front_channels >= 2) {\n        i += assign_pair(e2c_vec, layout_map, i, tags,\n                         AV_CH_FRONT_LEFT,\n                         AV_CH_FRONT_RIGHT,\n                         AAC_CHANNEL_FRONT);\n        num_front_channels -= 2;\n    }\n    while (num_front_channels >= 2) {\n        i += assign_pair(e2c_vec, layout_map, i, tags,\n                         UINT64_MAX,\n                         UINT64_MAX,\n                         AAC_CHANNEL_FRONT);\n        num_front_channels -= 2;\n    }\n\n    if (num_side_channels >= 2) {\n        i += assign_pair(e2c_vec, layout_map, i, tags,\n                         AV_CH_SIDE_LEFT,\n                         AV_CH_SIDE_RIGHT,\n                         AAC_CHANNEL_FRONT);\n        num_side_channels -= 2;\n    }\n    while (num_side_channels >= 2) {\n        i += assign_pair(e2c_vec, layout_map, i, tags,\n                         UINT64_MAX,\n                         UINT64_MAX,\n                         AAC_CHANNEL_SIDE);\n        num_side_channels -= 2;\n    }\n\n    while (num_back_channels >= 4) {\n        i += assign_pair(e2c_vec, layout_map, i, tags,\n                         UINT64_MAX,\n                         UINT64_MAX,\n                         AAC_CHANNEL_BACK);\n        num_back_channels -= 2;\n    }\n    if (num_back_channels >= 2) {\n        i += assign_pair(e2c_vec, layout_map, i, tags,\n                         AV_CH_BACK_LEFT,\n                         AV_CH_BACK_RIGHT,\n                         AAC_CHANNEL_BACK);\n        num_back_channels -= 2;\n    }\n    if (num_back_channels) {\n        e2c_vec[i] = (struct elem_to_channel) {\n          .av_position = AV_CH_BACK_CENTER, .syn_ele = TYPE_SCE,\n          .elem_id = layout_map[i][1], .aac_position = AAC_CHANNEL_BACK };\n        i++;\n        num_back_channels--;\n    }\n\n    if (i < tags && layout_map[i][2] == AAC_CHANNEL_LFE) {\n        e2c_vec[i] = (struct elem_to_channel) {\n          .av_position = AV_CH_LOW_FREQUENCY, .syn_ele = TYPE_LFE,\n          .elem_id = layout_map[i][1], .aac_position = AAC_CHANNEL_LFE };\n        i++;\n    }\n    while (i < tags && layout_map[i][2] == AAC_CHANNEL_LFE) {\n        e2c_vec[i] = (struct elem_to_channel) {\n          .av_position = UINT64_MAX, .syn_ele = TYPE_LFE,\n          .elem_id = layout_map[i][1], .aac_position = AAC_CHANNEL_LFE };\n        i++;\n    }\n\n    // Must choose a stable sort\n    total_non_cc_elements = n = i;\n    do {\n        int next_n = 0;\n        for (i = 1; i < n; i++) {\n            if (e2c_vec[i-1].av_position > e2c_vec[i].av_position) {\n                FFSWAP(struct elem_to_channel, e2c_vec[i-1], e2c_vec[i]);\n                next_n = i;\n            }\n        }\n        n = next_n;\n    } while (n > 0);\n\n    layout = 0;\n    for (i = 0; i < total_non_cc_elements; i++) {\n        layout_map[i][0] = e2c_vec[i].syn_ele;\n        layout_map[i][1] = e2c_vec[i].elem_id;\n        layout_map[i][2] = e2c_vec[i].aac_position;\n        if (e2c_vec[i].av_position != UINT64_MAX) {\n            layout |= e2c_vec[i].av_position;\n        }\n    }\n\n    return layout;\n}", "target": 1}
{"idx": 5195, "func": "static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr,\n                        int nb_jobs)\n{\n    TransContext *s = ctx->priv;\n    ThreadData *td = arg;\n    AVFrame *out = td->out;\n    AVFrame *in = td->in;\n    int plane;\n\n    for (plane = 0; plane < s->planes; plane++) {\n        int hsub    = plane == 1 || plane == 2 ? s->hsub : 0;\n        int vsub    = plane == 1 || plane == 2 ? s->vsub : 0;\n        int pixstep = s->pixsteps[plane];\n        int inh     = AV_CEIL_RSHIFT(in->height, vsub);\n        int outw    = AV_CEIL_RSHIFT(out->width,  hsub);\n        int outh    = AV_CEIL_RSHIFT(out->height, vsub);\n        int start   = (outh *  jobnr   ) / nb_jobs;\n        int end     = (outh * (jobnr+1)) / nb_jobs;\n        uint8_t *dst, *src;\n        int dstlinesize, srclinesize;\n        int x, y;\n\n        dstlinesize = out->linesize[plane];\n        dst         = out->data[plane] + start * dstlinesize;\n        src         = in->data[plane];\n        srclinesize = in->linesize[plane];\n\n        if (s->dir & 1) {\n            src         += in->linesize[plane] * (inh - 1);\n            srclinesize *= -1;\n        }\n\n        if (s->dir & 2) {\n            dst          = out->data[plane] + dstlinesize * (outh - start - 1);\n            dstlinesize *= -1;\n        }\n\n        for (y = start; y < end - 7; y += 8) {\n            for (x = 0; x < outw - 7; x += 8) {\n                s->transpose_8x8(src + x * srclinesize + y * pixstep,\n                                 srclinesize,\n                                 dst + (y - start) * dstlinesize + x * pixstep,\n                                 dstlinesize);\n            }\n            if (outw - x > 0 && end - y > 0)\n                s->transpose_block(src + x * srclinesize + y * pixstep,\n                                   srclinesize,\n                                   dst + (y - start) * dstlinesize + x * pixstep,\n                                   dstlinesize, outw - x, end - y);\n        }\n\n        if (end - y > 0)\n            s->transpose_block(src + 0 * srclinesize + y * pixstep,\n                               srclinesize,\n                               dst + (y - start) * dstlinesize + 0 * pixstep,\n                               dstlinesize, outw, end - y);\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5196, "func": "static int dxv_decompress_dxt5(AVCodecContext *avctx)\n{\n    DXVContext *ctx = avctx->priv_data;\n    GetByteContext *gbc = &ctx->gbc;\n    uint32_t value, op;\n    int idx, prev, state = 0;\n    int pos = 4;\n    int run = 0;\n    int probe, check;\n\n    /* Copy the first four elements */\n    AV_WL32(ctx->tex_data +  0, bytestream2_get_le32(gbc));\n    AV_WL32(ctx->tex_data +  4, bytestream2_get_le32(gbc));\n    AV_WL32(ctx->tex_data +  8, bytestream2_get_le32(gbc));\n    AV_WL32(ctx->tex_data + 12, bytestream2_get_le32(gbc));\n\n    /* Process input until the whole texture has been filled */\n    while (pos + 2 <= ctx->tex_size / 4) {\n        if (run) {\n            run--;\n\n            prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n            pos++;\n            prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n            pos++;\n        } else {\n            if (state == 0) {\n                value = bytestream2_get_le32(gbc);\n                state = 16;\n            }\n            op = value & 0x3;\n            value >>= 2;\n            state--;\n\n            switch (op) {\n            case 0:\n                /* Long copy */\n                check = bytestream2_get_byte(gbc) + 1;\n                if (check == 256) {\n                    do {\n                        probe = bytestream2_get_le16(gbc);\n                        check += probe;\n                    } while (probe == 0xFFFF);\n                }\n                while (check && pos + 4 <= ctx->tex_size / 4) {\n                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n                    AV_WL32(ctx->tex_data + 4 * pos, prev);\n                    pos++;\n\n                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n                    AV_WL32(ctx->tex_data + 4 * pos, prev);\n                    pos++;\n\n                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n                    AV_WL32(ctx->tex_data + 4 * pos, prev);\n                    pos++;\n\n                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n                    AV_WL32(ctx->tex_data + 4 * pos, prev);\n                    pos++;\n\n                    check--;\n                }\n\n                /* Restart (or exit) the loop */\n                continue;\n                break;\n            case 1:\n                /* Load new run value */\n                run = bytestream2_get_byte(gbc);\n                if (run == 255) {\n                    do {\n                        probe = bytestream2_get_le16(gbc);\n                        run += probe;\n                    } while (probe == 0xFFFF);\n                }\n\n                /* Copy two dwords from previous data */\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n                pos++;\n\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n                pos++;\n                break;\n            case 2:\n                /* Copy two dwords from a previous index */\n                idx = 8 + bytestream2_get_le16(gbc);\n                if (idx > pos || (unsigned int)(pos - idx) + 2 > ctx->tex_size / 4)\n                    return AVERROR_INVALIDDATA;\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n                pos++;\n\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n                pos++;\n                break;\n            case 3:\n                /* Copy two dwords from input */\n                prev = bytestream2_get_le32(gbc);\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n                pos++;\n\n                prev = bytestream2_get_le32(gbc);\n                AV_WL32(ctx->tex_data + 4 * pos, prev);\n                pos++;\n                break;\n            }\n        }\n\n        CHECKPOINT(4);\n        if (pos + 2 > ctx->tex_size / 4)\n            return AVERROR_INVALIDDATA;\n\n        /* Copy two elements from a previous offset or from the input buffer */\n        if (op) {\n            if (idx > pos || (unsigned int)(pos - idx) + 2 > ctx->tex_size / 4)\n                return AVERROR_INVALIDDATA;\n            prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n            pos++;\n\n            prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n            pos++;\n        } else {\n            CHECKPOINT(4);\n\n            if (op && (idx > pos || (unsigned int)(pos - idx) + 2 > ctx->tex_size / 4))\n                return AVERROR_INVALIDDATA;\n            if (op)\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n            else\n                prev = bytestream2_get_le32(gbc);\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n            pos++;\n\n            CHECKPOINT(4);\n\n            if (op)\n                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));\n            else\n                prev = bytestream2_get_le32(gbc);\n            AV_WL32(ctx->tex_data + 4 * pos, prev);\n            pos++;\n        }\n    }\n\n    return 0;\n}", "target": 0}
{"idx": 5197, "func": "int sm2_decrypt(const EC_KEY *key,\n                const EVP_MD *digest,\n                const uint8_t *ciphertext,\n                size_t ciphertext_len, uint8_t *ptext_buf, size_t *ptext_len)\n{\n    int rc = 0;\n    int i;\n    BN_CTX *ctx = NULL;\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    EC_POINT *C1 = NULL;\n    struct SM2_Ciphertext_st *sm2_ctext = NULL;\n    BIGNUM *x2 = NULL;\n    BIGNUM *y2 = NULL;\n    uint8_t *x2y2 = NULL;\n    uint8_t *computed_C3 = NULL;\n    const size_t field_size = ec_field_size(group);\n    const int hash_size = EVP_MD_size(digest);\n    uint8_t *msg_mask = NULL;\n    const uint8_t *C2 = NULL;\n    const uint8_t *C3 = NULL;\n    int msg_len = 0;\n    EVP_MD_CTX *hash = NULL;\n\n    if (field_size == 0 || hash_size <= 0)\n       goto done;\n\n    memset(ptext_buf, 0xFF, *ptext_len);\n\n    sm2_ctext = d2i_SM2_Ciphertext(NULL, &ciphertext, ciphertext_len);\n\n    if (sm2_ctext == NULL) {\n        SM2err(SM2_F_SM2_DECRYPT, SM2_R_ASN1_ERROR);\n        goto done;\n    }\n\n    if (sm2_ctext->C3->length != hash_size) {\n        SM2err(SM2_F_SM2_DECRYPT, SM2_R_INVALID_ENCODING);\n        goto done;\n    }\n\n    C2 = sm2_ctext->C2->data;\n    C3 = sm2_ctext->C3->data;\n    msg_len = sm2_ctext->C2->length;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL) {\n        SM2err(SM2_F_SM2_DECRYPT, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    BN_CTX_start(ctx);\n    x2 = BN_CTX_get(ctx);\n    y2 = BN_CTX_get(ctx);\n\n    if (y2 == NULL) {\n        SM2err(SM2_F_SM2_DECRYPT, ERR_R_BN_LIB);\n        goto done;\n    }\n\n    msg_mask = OPENSSL_zalloc(msg_len);\n    x2y2 = OPENSSL_zalloc(2 * field_size);\n    computed_C3 = OPENSSL_zalloc(hash_size);\n\n    if (msg_mask == NULL || x2y2 == NULL || computed_C3 == NULL) {\n        SM2err(SM2_F_SM2_DECRYPT, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    C1 = EC_POINT_new(group);\n    if (C1 == NULL) {\n        SM2err(SM2_F_SM2_DECRYPT, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    if (!EC_POINT_set_affine_coordinates_GFp(group, C1, sm2_ctext->C1x,\n                                            sm2_ctext->C1y, ctx)\n            || !EC_POINT_mul(group, C1, NULL, C1, EC_KEY_get0_private_key(key),\n                             ctx)\n            || !EC_POINT_get_affine_coordinates_GFp(group, C1, x2, y2, ctx)) {\n        SM2err(SM2_F_SM2_DECRYPT, ERR_R_EC_LIB);\n        goto done;\n    }\n\n    if (BN_bn2binpad(x2, x2y2, field_size) < 0\n            || BN_bn2binpad(y2, x2y2 + field_size, field_size) < 0\n            || !ECDH_KDF_X9_62(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,\n                               digest)) {\n        SM2err(SM2_F_SM2_DECRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    for (i = 0; i != msg_len; ++i)\n        ptext_buf[i] = C2[i] ^ msg_mask[i];\n\n    hash = EVP_MD_CTX_new();\n    if (hash == NULL) {\n        SM2err(SM2_F_SM2_DECRYPT, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    if (!EVP_DigestInit(hash, digest)\n            || !EVP_DigestUpdate(hash, x2y2, field_size)\n            || !EVP_DigestUpdate(hash, ptext_buf, msg_len)\n            || !EVP_DigestUpdate(hash, x2y2 + field_size, field_size)\n            || !EVP_DigestFinal(hash, computed_C3, NULL)) {\n        SM2err(SM2_F_SM2_DECRYPT, ERR_R_EVP_LIB);\n        goto done;\n    }\n\n    if (CRYPTO_memcmp(computed_C3, C3, hash_size) != 0) {\n        SM2err(SM2_F_SM2_DECRYPT, SM2_R_INVALID_DIGEST);\n        goto done;\n    }\n\n    rc = 1;\n    *ptext_len = msg_len;\n\n done:\n    if (rc == 0)\n        memset(ptext_buf, 0, *ptext_len);\n\n    OPENSSL_free(msg_mask);\n    OPENSSL_free(x2y2);\n    OPENSSL_free(computed_C3);\n    EC_POINT_free(C1);\n    BN_CTX_free(ctx);\n    SM2_Ciphertext_free(sm2_ctext);\n    EVP_MD_CTX_free(hash);\n\n    return rc;\n}", "target": 0}
{"idx": 5198, "func": "static av_always_inline void\nyuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n                     const int16_t *abuf[2], uint8_t *dest, int dstW,\n                     int yalpha, int uvalpha, int y,\n                     enum PixelFormat target, int hasAlpha)\n{\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n                  *abuf0 = abuf[0], *abuf1 = abuf[1];\n    int  yalpha1 = 4095 - yalpha;\n    int uvalpha1 = 4095 - uvalpha;\n    int i;\n\n    for (i = 0; i < (dstW >> 1); i++) {\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n        int A1, A2;\n        const void *r =  c->table_rV[V],\n                   *g = (c->table_gU[U] + c->table_gV[V]),\n                   *b =  c->table_bU[U];\n\n        if (hasAlpha) {\n            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;\n            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;\n        }\n\n        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n                      r, g, b, y, target, hasAlpha);\n    }\n}", "target": 0}
{"idx": 5199, "func": "static int asf_read_picture(AVFormatContext *s, int len)\n{\n    AVPacket pkt          = { 0 };\n    const CodecMime *mime = ff_id3v2_mime_tags;\n    enum  AVCodecID id    = AV_CODEC_ID_NONE;\n    char mimetype[64];\n    uint8_t  *desc = NULL;\n    AVStream   *st = NULL;\n    int ret, type, picsize, desc_len;\n\n    /* type + picsize + mime + desc */\n    if (len < 1 + 4 + 2 + 2) {\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture size: %d.\\n\", len);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* picture type */\n    type = avio_r8(s->pb);\n    len--;\n    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type: %d.\\n\", type);\n        type = 0;\n    }\n\n    /* picture data size */\n    picsize = avio_rl32(s->pb);\n    len    -= 4;\n\n    /* picture MIME type */\n    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));\n    while (mime->id != AV_CODEC_ID_NONE) {\n        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {\n            id = mime->id;\n            break;\n        }\n        mime++;\n    }\n    if (id == AV_CODEC_ID_NONE) {\n        av_log(s, AV_LOG_ERROR, \"Unknown attached picture mimetype: %s.\\n\",\n               mimetype);\n        return 0;\n    }\n\n    if (picsize >= len) {\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture data size: %d >= %d.\\n\",\n               picsize, len);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* picture description */\n    desc_len = (len - picsize) * 2 + 1;\n    desc     = av_malloc(desc_len);\n    if (!desc)\n        return AVERROR(ENOMEM);\n    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);\n\n    ret = av_get_packet(s->pb, &pkt, picsize);\n    if (ret < 0)\n        goto fail;\n\n    st  = avformat_new_stream(s, NULL);\n    if (!st) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n    st->codec->codec_type         = AVMEDIA_TYPE_VIDEO;\n    st->codec->codec_id           = id;\n    st->attached_pic              = pkt;\n    st->attached_pic.stream_index = st->index;\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n    if (*desc)\n        av_dict_set(&st->metadata, \"title\", desc, AV_DICT_DONT_STRDUP_VAL);\n    else\n        av_freep(&desc);\n\n    av_dict_set(&st->metadata, \"comment\", ff_id3v2_picture_types[type], 0);\n\n    return 0;\n\nfail:\n    av_freep(&desc);\n    av_free_packet(&pkt);\n    return ret;\n}", "target": 1}
{"idx": 5200, "func": "ngx_int_t\nngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n    ngx_http_upstream_srv_conf_t *us)\n{\n    ngx_url_t                      u;\n    ngx_uint_t                     i, j, n;\n    ngx_http_upstream_server_t    *server;\n    ngx_http_upstream_rr_peers_t  *peers, *backup;\n\n    us->peer.init = ngx_http_upstream_init_round_robin_peer;\n\n    if (us->servers) {\n        server = us->servers->elts;\n\n        n = 0;\n\n        for (i = 0; i < us->servers->nelts; i++) {\n            if (server[i].backup) {\n                continue;\n            }\n\n            n += server[i].naddrs;\n        }\n\n        if (n == 0) {\n            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                          \"no servers in upstream \\\"%V\\\" in %s:%ui\",\n                          &us->host, us->file_name, us->line);\n            return NGX_ERROR;\n        }\n\n        peers = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peers_t)\n                              + sizeof(ngx_http_upstream_rr_peer_t) * (n - 1));\n        if (peers == NULL) {\n            return NGX_ERROR;\n        }\n\n        peers->single = (n == 1);\n        peers->number = n;\n        peers->name = &us->host;\n\n        n = 0;\n\n        for (i = 0; i < us->servers->nelts; i++) {\n            for (j = 0; j < server[i].naddrs; j++) {\n                if (server[i].backup) {\n                    continue;\n                }\n\n                peers->peer[n].sockaddr = server[i].addrs[j].sockaddr;\n                peers->peer[n].socklen = server[i].addrs[j].socklen;\n                peers->peer[n].name = server[i].addrs[j].name;\n                peers->peer[n].max_fails = server[i].max_fails;\n                peers->peer[n].fail_timeout = server[i].fail_timeout;\n                peers->peer[n].down = server[i].down;\n                peers->peer[n].weight = server[i].down ? 0 : server[i].weight;\n                peers->peer[n].effective_weight = peers->peer[n].weight;\n                peers->peer[n].current_weight = 0;\n                n++;\n            }\n        }\n\n        us->peer.data = peers;\n\n        ngx_sort(&peers->peer[0], (size_t) n,\n                 sizeof(ngx_http_upstream_rr_peer_t),\n                 ngx_http_upstream_cmp_servers);\n\n        /* backup servers */\n\n        n = 0;\n\n        for (i = 0; i < us->servers->nelts; i++) {\n            if (!server[i].backup) {\n                continue;\n            }\n\n            n += server[i].naddrs;\n        }\n\n        if (n == 0) {\n            return NGX_OK;\n        }\n\n        backup = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peers_t)\n                              + sizeof(ngx_http_upstream_rr_peer_t) * (n - 1));\n        if (backup == NULL) {\n            return NGX_ERROR;\n        }\n\n        peers->single = 0;\n        backup->single = 0;\n        backup->number = n;\n        backup->name = &us->host;\n\n        n = 0;\n\n        for (i = 0; i < us->servers->nelts; i++) {\n            for (j = 0; j < server[i].naddrs; j++) {\n                if (!server[i].backup) {\n                    continue;\n                }\n\n                backup->peer[n].sockaddr = server[i].addrs[j].sockaddr;\n                backup->peer[n].socklen = server[i].addrs[j].socklen;\n                backup->peer[n].name = server[i].addrs[j].name;\n                backup->peer[n].weight = server[i].weight;\n                backup->peer[n].effective_weight = server[i].weight;\n                backup->peer[n].current_weight = 0;\n                backup->peer[n].max_fails = server[i].max_fails;\n                backup->peer[n].fail_timeout = server[i].fail_timeout;\n                backup->peer[n].down = server[i].down;\n                n++;\n            }\n        }\n\n        peers->next = backup;\n\n        ngx_sort(&backup->peer[0], (size_t) n,\n                 sizeof(ngx_http_upstream_rr_peer_t),\n                 ngx_http_upstream_cmp_servers);\n\n        return NGX_OK;\n    }\n\n\n    /* an upstream implicitly defined by proxy_pass, etc. */\n\n    if (us->port == 0 && us->default_port == 0) {\n        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                      \"no port in upstream \\\"%V\\\" in %s:%ui\",\n                      &us->host, us->file_name, us->line);\n        return NGX_ERROR;\n    }\n\n    ngx_memzero(&u, sizeof(ngx_url_t));\n\n    u.host = us->host;\n    u.port = (in_port_t) (us->port ? us->port : us->default_port);\n\n    if (ngx_inet_resolve_host(cf->pool, &u) != NGX_OK) {\n        if (u.err) {\n            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                          \"%s in upstream \\\"%V\\\" in %s:%ui\",\n                          u.err, &us->host, us->file_name, us->line);\n        }\n\n        return NGX_ERROR;\n    }\n\n    n = u.naddrs;\n\n    peers = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peers_t)\n                              + sizeof(ngx_http_upstream_rr_peer_t) * (n - 1));\n    if (peers == NULL) {\n        return NGX_ERROR;\n    }\n\n    peers->single = (n == 1);\n    peers->number = n;\n    peers->name = &us->host;\n\n    for (i = 0; i < u.naddrs; i++) {\n        peers->peer[i].sockaddr = u.addrs[i].sockaddr;\n        peers->peer[i].socklen = u.addrs[i].socklen;\n        peers->peer[i].name = u.addrs[i].name;\n        peers->peer[i].weight = 1;\n        peers->peer[i].effective_weight = 1;\n        peers->peer[i].current_weight = 0;\n        peers->peer[i].max_fails = 1;\n        peers->peer[i].fail_timeout = 10;\n    }\n\n    us->peer.data = peers;\n\n    /* implicitly defined upstream has no backup servers */\n\n    return NGX_OK;\n}", "target": 0}
{"idx": 5201, "func": "static inline int rv34_decode_block(DCTELEM *dst, GetBitContext *gb, RV34VLC *rvlc, int fc, int sc, int q_dc, int q_ac1, int q_ac2)\n{\n    int code, pattern, has_ac = 1;\n\n    code = get_vlc2(gb, rvlc->first_pattern[fc].table, 9, 2);\n\n    pattern = code & 0x7;\n\n    code >>= 3;\n\n    if (modulo_three_table[code] & 0x3F) {\n        decode_subblock3(dst, code, 0, gb, &rvlc->coefficient, q_dc, q_ac1, q_ac2);\n    } else {\n        decode_subblock1(dst, code, gb, &rvlc->coefficient, q_dc);\n        if (!pattern)\n            return 0;\n        has_ac = 0;\n    }\n\n    if(pattern & 4){\n        code = get_vlc2(gb, rvlc->second_pattern[sc].table, 9, 2);\n        decode_subblock(dst + 2, code, 0, gb, &rvlc->coefficient, q_ac2);\n    }\n    if(pattern & 2){ // Looks like coefficients 1 and 2 are swapped for this block\n        code = get_vlc2(gb, rvlc->second_pattern[sc].table, 9, 2);\n        decode_subblock(dst + 8*2, code, 1, gb, &rvlc->coefficient, q_ac2);\n    }\n    if(pattern & 1){\n        code = get_vlc2(gb, rvlc->third_pattern[sc].table, 9, 2);\n        decode_subblock(dst + 8*2+2, code, 0, gb, &rvlc->coefficient, q_ac2);\n    }\n    return has_ac || pattern;\n}", "target": 0}
{"idx": 5202, "func": "static int crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score,\n\t\t\t\tunsigned int *preasons)\n\t{\n\tint i;\n\tif (crl->idp_flags & IDP_ONLYATTR)\n\t\treturn 0;\n\tif (x->ex_flags & EXFLAG_CA)\n\t\t{\n\t\tif (crl->idp_flags & IDP_ONLYUSER)\n\t\t\treturn 0;\n\t\t}\n\telse\n\t\t{\n\t\tif (crl->idp_flags & IDP_ONLYCA)\n\t\t\treturn 0;\n\t\t}\n\t*preasons = crl->idp_reasons;\n\tfor (i = 0; i < sk_DIST_POINT_num(x->crldp); i++)\n\t\t{\n\t\tDIST_POINT *dp = sk_DIST_POINT_value(x->crldp, i);\n\t\tif (crldp_check_crlissuer(dp, crl, crl_score))\n\t\t\t{\n\t\t\tif (!crl->idp ||\n\t\t\t     idp_check_dp(dp->distpoint, crl->idp->distpoint))\n\t\t\t\t{\n\t\t\t\t*preasons &= dp->dp_reasons;\n\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif ((!crl->idp || !crl->idp->distpoint) && (crl_score & CRL_SCORE_ISSUER_NAME))\n\t\treturn 1;\n\treturn 0;\n\t}", "target": 0}
{"idx": 5203, "func": "static inline int decode_picture_parameter_set(H264Context *h, int bit_length){\n    MpegEncContext * const s = &h->s;\n    unsigned int tmp, pps_id= get_ue_golomb(&s->gb);\n    PPS *pps;\n\n    pps = alloc_parameter_set(h, (void **)h->pps_buffers, pps_id, MAX_PPS_COUNT, sizeof(PPS), \"pps\");\n    if(pps == NULL)\n        return -1;\n\n    tmp= get_ue_golomb(&s->gb);\n    if(tmp>=MAX_SPS_COUNT || h->sps_buffers[tmp] == NULL){\n        av_log(h->s.avctx, AV_LOG_ERROR, \"sps_id out of range\\n\");\n        return -1;\n    }\n    pps->sps_id= tmp;\n\n    pps->cabac= get_bits1(&s->gb);\n    pps->pic_order_present= get_bits1(&s->gb);\n    pps->slice_group_count= get_ue_golomb(&s->gb) + 1;\n    if(pps->slice_group_count > 1 ){\n        pps->mb_slice_group_map_type= get_ue_golomb(&s->gb);\n        av_log(h->s.avctx, AV_LOG_ERROR, \"FMO not supported\\n\");\n        switch(pps->mb_slice_group_map_type){\n        case 0:\n#if 0\n|   for( i = 0; i <= num_slice_groups_minus1; i++ ) |   |        |\n|    run_length[ i ]                                |1  |ue(v)   |\n#endif\n            break;\n        case 2:\n#if 0\n|   for( i = 0; i < num_slice_groups_minus1; i++ )  |   |        |\n|{                                                  |   |        |\n|    top_left_mb[ i ]                               |1  |ue(v)   |\n|    bottom_right_mb[ i ]                           |1  |ue(v)   |\n|   }                                               |   |        |\n#endif\n            break;\n        case 3:\n        case 4:\n        case 5:\n#if 0\n|   slice_group_change_direction_flag               |1  |u(1)    |\n|   slice_group_change_rate_minus1                  |1  |ue(v)   |\n#endif\n            break;\n        case 6:\n#if 0\n|   slice_group_id_cnt_minus1                       |1  |ue(v)   |\n|   for( i = 0; i <= slice_group_id_cnt_minus1; i++ |   |        |\n|)                                                  |   |        |\n|    slice_group_id[ i ]                            |1  |u(v)    |\n#endif\n            break;\n        }\n    }\n    pps->ref_count[0]= get_ue_golomb(&s->gb) + 1;\n    pps->ref_count[1]= get_ue_golomb(&s->gb) + 1;\n    if(pps->ref_count[0]-1 > 32-1 || pps->ref_count[1]-1 > 32-1){\n        av_log(h->s.avctx, AV_LOG_ERROR, \"reference overflow (pps)\\n\");\n        pps->ref_count[0]= pps->ref_count[1]= 1;\n        return -1;\n    }\n\n    pps->weighted_pred= get_bits1(&s->gb);\n    pps->weighted_bipred_idc= get_bits(&s->gb, 2);\n    pps->init_qp= get_se_golomb(&s->gb) + 26;\n    pps->init_qs= get_se_golomb(&s->gb) + 26;\n    pps->chroma_qp_index_offset[0]= get_se_golomb(&s->gb);\n    pps->deblocking_filter_parameters_present= get_bits1(&s->gb);\n    pps->constrained_intra_pred= get_bits1(&s->gb);\n    pps->redundant_pic_cnt_present = get_bits1(&s->gb);\n\n    pps->transform_8x8_mode= 0;\n    h->dequant_coeff_pps= -1; //contents of sps/pps can change even if id doesn't, so reinit\n    memcpy(pps->scaling_matrix4, h->sps_buffers[pps->sps_id]->scaling_matrix4, sizeof(pps->scaling_matrix4));\n    memcpy(pps->scaling_matrix8, h->sps_buffers[pps->sps_id]->scaling_matrix8, sizeof(pps->scaling_matrix8));\n\n    if(get_bits_count(&s->gb) < bit_length){\n        pps->transform_8x8_mode= get_bits1(&s->gb);\n        decode_scaling_matrices(h, h->sps_buffers[pps->sps_id], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8);\n        pps->chroma_qp_index_offset[1]= get_se_golomb(&s->gb); //second_chroma_qp_index_offset\n    } else {\n        pps->chroma_qp_index_offset[1]= pps->chroma_qp_index_offset[0];\n    }\n\n    build_qp_table(pps, 0, pps->chroma_qp_index_offset[0]);\n    build_qp_table(pps, 1, pps->chroma_qp_index_offset[1]);\n    if(pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])\n        h->pps.chroma_qp_diff= 1;\n\n    if(s->avctx->debug&FF_DEBUG_PICT_INFO){\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"pps:%u sps:%u %s slice_groups:%d ref:%d/%d %s qp:%d/%d/%d/%d %s %s %s %s\\n\",\n               pps_id, pps->sps_id,\n               pps->cabac ? \"CABAC\" : \"CAVLC\",\n               pps->slice_group_count,\n               pps->ref_count[0], pps->ref_count[1],\n               pps->weighted_pred ? \"weighted\" : \"\",\n               pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1],\n               pps->deblocking_filter_parameters_present ? \"LPAR\" : \"\",\n               pps->constrained_intra_pred ? \"CONSTR\" : \"\",\n               pps->redundant_pic_cnt_present ? \"REDU\" : \"\",\n               pps->transform_8x8_mode ? \"8x8DCT\" : \"\"\n               );\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5204, "func": "static int test_client_hello(int currtest)\n{\n    SSL_CTX *ctx;\n    SSL *con = NULL;\n    BIO *rbio;\n    BIO *wbio;\n    long len;\n    unsigned char *data;\n    PACKET pkt = {0}, pkt2 = {0}, pkt3 = {0};\n    char *dummytick = \"Hello World!\";\n    unsigned int type = 0;\n    int testresult = 0;\n    size_t msglen;\n    BIO *sessbio = NULL;\n    SSL_SESSION *sess = NULL;\n\n#ifdef OPENSSL_NO_TLS1_3\n    if (currtest == TEST_ADD_PADDING_AND_PSK)\n        return 1;\n#endif\n\n    /*\n     * For each test set up an SSL_CTX and SSL and see what ClientHello gets\n     * produced when we try to connect\n     */\n    ctx = SSL_CTX_new(TLS_method());\n    if (!TEST_ptr(ctx))\n        goto end;\n\n    switch(currtest) {\n    case TEST_SET_SESSION_TICK_DATA_VER_NEG:\n#if !defined(OPENSSL_NO_TLS1_3) && defined(OPENSSL_NO_TLS1_2)\n        /* TLSv1.3 is enabled and TLSv1.2 is disabled so can't do this test */\n        return 1;\n#else\n        /* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\n        if (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))\n            goto end;\n#endif\n        break;\n\n    case TEST_ADD_PADDING_AND_PSK:\n        /*\n         * In this case we're doing TLSv1.3 and we're sending a PSK so the\n         * ClientHello is already going to be quite long. To avoid getting one\n         * that is too long for this test we use a restricted ciphersuite list\n         */\n        if (!TEST_true(SSL_CTX_set_cipher_list(ctx, \"\")))\n            goto end;\n         /* Fall through */\n    case TEST_ADD_PADDING:\n    case TEST_PADDING_NOT_NEEDED:\n        SSL_CTX_set_options(ctx, SSL_OP_TLSEXT_PADDING);\n        /* Make sure we get a consistent size across TLS versions */\n        SSL_CTX_clear_options(ctx, SSL_OP_ENABLE_MIDDLEBOX_COMPAT);\n        /*\n         * Add some dummy ALPN protocols so that the ClientHello is at least\n         * F5_WORKAROUND_MIN_MSG_LEN bytes long - meaning padding will be\n         * needed.\n         */\n        if (currtest == TEST_ADD_PADDING) {\n             if (!TEST_false(SSL_CTX_set_alpn_protos(ctx,\n                                    (unsigned char *)alpn_prots,\n                                    sizeof(alpn_prots) - 1)))\n                goto end;\n        /*\n         * Otherwise we need to make sure we have a small enough message to\n         * not need padding.\n         */\n        } else if (!TEST_true(SSL_CTX_set_cipher_list(ctx,\n                              \"AES128-SHA\"))\n                   || !TEST_true(SSL_CTX_set_ciphersuites(ctx,\n                                 \"TLS_AES_128_GCM_SHA256\"))) {\n            goto end;\n        }\n        break;\n\n    default:\n        goto end;\n    }\n\n    con = SSL_new(ctx);\n    if (!TEST_ptr(con))\n        goto end;\n\n    if (currtest == TEST_ADD_PADDING_AND_PSK) {\n        sessbio = BIO_new_file(sessionfile, \"r\");\n        if (!TEST_ptr(sessbio)) {\n            TEST_info(\"Unable to open session.pem\");\n            goto end;\n        }\n        sess = PEM_read_bio_SSL_SESSION(sessbio, NULL, NULL, NULL);\n        if (!TEST_ptr(sess)) {\n            TEST_info(\"Unable to load SSL_SESSION\");\n            goto end;\n        }\n        /*\n         * We reset the creation time so that we don't discard the session as\n         * too old.\n         */\n        if (!TEST_true(SSL_SESSION_set_time(sess, (long)time(NULL)))\n                || !TEST_true(SSL_set_session(con, sess)))\n            goto end;\n    }\n\n    rbio = BIO_new(BIO_s_mem());\n    wbio = BIO_new(BIO_s_mem());\n    if (!TEST_ptr(rbio)|| !TEST_ptr(wbio)) {\n        BIO_free(rbio);\n        BIO_free(wbio);\n        goto end;\n    }\n\n    SSL_set_bio(con, rbio, wbio);\n    SSL_set_connect_state(con);\n\n    if (currtest == TEST_SET_SESSION_TICK_DATA_VER_NEG) {\n        if (!TEST_true(SSL_set_session_ticket_ext(con, dummytick,\n                                                  strlen(dummytick))))\n            goto end;\n    }\n\n    if (!TEST_int_le(SSL_connect(con), 0)) {\n        /* This shouldn't succeed because we don't have a server! */\n        goto end;\n    }\n\n    len = BIO_get_mem_data(wbio, (char **)&data);\n    if (!TEST_true(PACKET_buf_init(&pkt, data, len))\n               /* Skip the record header */\n            || !PACKET_forward(&pkt, SSL3_RT_HEADER_LENGTH))\n        goto end;\n\n    msglen = PACKET_remaining(&pkt);\n\n    /* Skip the handshake message header */\n    if (!TEST_true(PACKET_forward(&pkt, SSL3_HM_HEADER_LENGTH))\n               /* Skip client version and random */\n            || !TEST_true(PACKET_forward(&pkt, CLIENT_VERSION_LEN\n                                               + SSL3_RANDOM_SIZE))\n               /* Skip session id */\n            || !TEST_true(PACKET_get_length_prefixed_1(&pkt, &pkt2))\n               /* Skip ciphers */\n            || !TEST_true(PACKET_get_length_prefixed_2(&pkt, &pkt2))\n               /* Skip compression */\n            || !TEST_true(PACKET_get_length_prefixed_1(&pkt, &pkt2))\n               /* Extensions len */\n            || !TEST_true(PACKET_as_length_prefixed_2(&pkt, &pkt2)))\n        goto end;\n\n    /* Loop through all extensions */\n    while (PACKET_remaining(&pkt2)) {\n\n        if (!TEST_true(PACKET_get_net_2(&pkt2, &type))\n                || !TEST_true(PACKET_get_length_prefixed_2(&pkt2, &pkt3)))\n            goto end;\n\n        if (type == TLSEXT_TYPE_session_ticket) {\n            if (currtest == TEST_SET_SESSION_TICK_DATA_VER_NEG) {\n                if (TEST_true(PACKET_equal(&pkt3, dummytick,\n                                           strlen(dummytick)))) {\n                    /* Ticket data is as we expected */\n                    testresult = 1;\n                }\n                goto end;\n            }\n        }\n        if (type == TLSEXT_TYPE_padding) {\n            if (!TEST_false(currtest == TEST_PADDING_NOT_NEEDED))\n                goto end;\n            else if (TEST_true(currtest == TEST_ADD_PADDING\n                    || currtest == TEST_ADD_PADDING_AND_PSK))\n                testresult = TEST_true(msglen == F5_WORKAROUND_MAX_MSG_LEN);\n        }\n    }\n\n    if (currtest == TEST_PADDING_NOT_NEEDED)\n        testresult = 1;\n\nend:\n    SSL_free(con);\n    SSL_CTX_free(ctx);\n    SSL_SESSION_free(sess);\n    BIO_free(sessbio);\n\n    return testresult;\n}", "target": 0}
{"idx": 5205, "func": "static int\nLogLuvDecodeTile(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\ttmsize_t rowlen = TIFFTileRowSize(tif);\n\n        if (rowlen == 0)\n                return 0;\n\n\tassert(cc%rowlen == 0);\n\twhile (cc && (*tif->tif_decoderow)(tif, bp, rowlen, s)) {\n\t\tbp += rowlen;\n\t\tcc -= rowlen;\n\t}\n\treturn (cc == 0);\n}", "target": 1}
{"idx": 5206, "func": "static int test_rand_range(int n)\n{\n    const unsigned int range = rand_range_cases[n].range;\n    const unsigned int iterations = rand_range_cases[n].iterations;\n    const double critical = rand_range_cases[n].critical;\n    const double expected = iterations / (double)range;\n    double sum = 0;\n    BIGNUM *rng = NULL, *val = NULL;\n    size_t *counts;\n    unsigned int i, v;\n    int res = 0;\n\n    if (!TEST_ptr(counts = OPENSSL_zalloc(sizeof(*counts) * range))\n        || !TEST_ptr(rng = BN_new())\n        || !TEST_ptr(val = BN_new())\n        || !TEST_true(BN_set_word(rng, range)))\n        goto err;\n    for (i = 0; i < iterations; i++) {\n        if (!TEST_true(BN_rand_range(val, rng))\n            || !TEST_uint_lt(v = (unsigned int)BN_get_word(val), range))\n            goto err;\n        counts[v]++;\n    }\n\n    TEST_note(\"range %u  iterations %u  critical %.4f\", range, iterations,\n              critical);\n    if (range < 20) {\n        TEST_note(\"frequencies (expected %.2f)\", expected);\n        for (i = 0; i < range; i++)\n            TEST_note(\"    %2u  %6zu\", i, counts[i]);\n    }\n    for (i = 0; i < range; i++) {\n        const double delta = counts[i] - expected;\n        sum += delta * delta;\n    }\n    sum /= expected;\n    TEST_note(\"test statistic %.4f\", sum);\n\n    if (TEST_double_lt(sum, critical))\n        res = 1;\nerr:\n    BN_free(rng);\n    BN_free(val);\n    OPENSSL_free(counts);\n    return res;\n}", "target": 1}
{"idx": 5207, "func": "void ff_aac_search_for_tns(AACEncContext *s, SingleChannelElement *sce)\n{\n    TemporalNoiseShaping *tns = &sce->tns;\n    int w, g, order, sfb_start, sfb_len, coef_start, shift[MAX_LPC_ORDER], count = 0;\n    const int is8 = sce->ics.window_sequence[0] == EIGHT_SHORT_SEQUENCE;\n    const int tns_max_order = is8 ? 7 : s->profile == FF_PROFILE_AAC_LOW ? 12 : TNS_MAX_ORDER;\n    const float freq_mult = mpeg4audio_sample_rates[s->samplerate_index]/(1024.0f/sce->ics.num_windows)/2.0f;\n    float max_coef = 0.0f;\n\n    sce->tns.present = 0;\n    return;\n\n    for (coef_start = 0; coef_start < 1024; coef_start++)\n        max_coef = FFMAX(max_coef, sce->pcoeffs[coef_start]);\n\n    for (w = 0; w < sce->ics.num_windows; w++) {\n        int filters = 1, start = 0, coef_len = 0;\n        int32_t conv_coeff[1024] = {0};\n        int32_t coefs_t[MAX_LPC_ORDER][MAX_LPC_ORDER] = {{0}};\n\n        /* Determine start sfb + coef - excludes anything below threshold */\n        for (g = 0;  g < sce->ics.num_swb; g++) {\n            if (start*freq_mult > TNS_LOW_LIMIT) {\n                sfb_start = w*16+g;\n                sfb_len   = (w+1)*16 + g - sfb_start;\n                coef_start = sce->ics.swb_offset[sfb_start];\n                coef_len  = sce->ics.swb_offset[sfb_start + sfb_len] - coef_start;\n                break;\n            }\n            start += sce->ics.swb_sizes[g];\n        }\n\n        if (coef_len <= 0)\n            continue;\n\n        conv_to_int32(conv_coeff, &sce->pcoeffs[coef_start], coef_len, max_coef);\n\n        /* LPC */\n        order = ff_lpc_calc_coefs(&s->lpc, conv_coeff, coef_len,\n                                  TNS_MIN_PRED_ORDER, tns_max_order,\n                                  32, coefs_t, shift,\n                                  FF_LPC_TYPE_LEVINSON, 10,\n                                  ORDER_METHOD_EST, MAX_LPC_SHIFT, 0) - 1;\n\n        /* Works surprisingly well, remember to tweak MAX_LPC_SHIFT if you want to play around with this */\n        if (shift[order] > 3) {\n            int direction = 0;\n            float tns_coefs_raw[TNS_MAX_ORDER];\n            tns->n_filt[w] = filters++;\n            conv_to_float(tns_coefs_raw, coefs_t[order], order);\n            for (g = 0; g < tns->n_filt[w]; g++) {\n                process_tns_coeffs(tns, tns_coefs_raw, order, w, g);\n                apply_tns_filter(&sce->coeffs[coef_start], sce->pcoeffs, order, direction, tns->coef[w][g],\n                                 sce->ics.ltp.present, w, g, coef_start, coef_len);\n                tns->order[w][g]     = order;\n                tns->length[w][g]    = sfb_len;\n                tns->direction[w][g] = direction;\n            }\n            count++;\n        }\n    }\n\n    sce->tns.present = !!count;\n}", "target": 1}
{"idx": 5208, "func": "int ff_mjpeg_decode_sos(MJpegDecodeContext *s, const uint8_t *mb_bitmask,\n                        const AVFrame *reference)\n{\n    int len, nb_components, i, h, v, predictor, point_transform;\n    int index, id;\n    const int block_size = s->lossless ? 1 : 8;\n    int ilv, prev_shift;\n\n    /* XXX: verify len field validity */\n    len = get_bits(&s->gb, 16);\n    nb_components = get_bits(&s->gb, 8);\n    if (nb_components == 0 || nb_components > MAX_COMPONENTS) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"decode_sos: nb_components (%d) unsupported\\n\", nb_components);\n        return -1;\n    }\n    if (len != 6 + 2 * nb_components) {\n        av_log(s->avctx, AV_LOG_ERROR, \"decode_sos: invalid len (%d)\\n\", len);\n        return -1;\n    }\n    for (i = 0; i < nb_components; i++) {\n        id = get_bits(&s->gb, 8) - 1;\n        av_log(s->avctx, AV_LOG_DEBUG, \"component: %d\\n\", id);\n        /* find component index */\n        for (index = 0; index < s->nb_components; index++)\n            if (id == s->component_id[index])\n                break;\n        if (index == s->nb_components) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"decode_sos: index(%d) out of components\\n\", index);\n            return -1;\n        }\n        /* Metasoft MJPEG codec has Cb and Cr swapped */\n        if (s->avctx->codec_tag == MKTAG('M', 'T', 'S', 'J')\n            && nb_components == 3 && s->nb_components == 3 && i)\n            index = 3 - i;\n\n        if(nb_components == 3 && s->nb_components == 3 && s->avctx->pix_fmt == PIX_FMT_GBR24P)\n            index = (i+2)%3;\n\n        s->comp_index[i] = index;\n\n        s->nb_blocks[i] = s->h_count[index] * s->v_count[index];\n        s->h_scount[i]  = s->h_count[index];\n        s->v_scount[i]  = s->v_count[index];\n\n        s->dc_index[i] = get_bits(&s->gb, 4);\n        s->ac_index[i] = get_bits(&s->gb, 4);\n\n        if (s->dc_index[i] <  0 || s->ac_index[i] < 0 ||\n            s->dc_index[i] >= 4 || s->ac_index[i] >= 4)\n            goto out_of_range;\n        if (!s->vlcs[0][s->dc_index[i]].table || !(s->progressive ? s->vlcs[2][s->ac_index[0]].table : s->vlcs[1][s->ac_index[i]].table))\n            goto out_of_range;\n    }\n\n    predictor = get_bits(&s->gb, 8);       /* JPEG Ss / lossless JPEG predictor /JPEG-LS NEAR */\n    ilv = get_bits(&s->gb, 8);             /* JPEG Se / JPEG-LS ILV */\n    if(s->avctx->codec_tag != AV_RL32(\"CJPG\")){\n        prev_shift      = get_bits(&s->gb, 4); /* Ah */\n        point_transform = get_bits(&s->gb, 4); /* Al */\n    }else\n        prev_shift = point_transform = 0;\n\n    for (i = 0; i < nb_components; i++)\n        s->last_dc[i] = 1024;\n\n    if (nb_components > 1) {\n        /* interleaved stream */\n        s->mb_width  = (s->width  + s->h_max * block_size - 1) / (s->h_max * block_size);\n        s->mb_height = (s->height + s->v_max * block_size - 1) / (s->v_max * block_size);\n    } else if (!s->ls) { /* skip this for JPEG-LS */\n        h = s->h_max / s->h_scount[0];\n        v = s->v_max / s->v_scount[0];\n        s->mb_width     = (s->width  + h * block_size - 1) / (h * block_size);\n        s->mb_height    = (s->height + v * block_size - 1) / (v * block_size);\n        s->nb_blocks[0] = 1;\n        s->h_scount[0]  = 1;\n        s->v_scount[0]  = 1;\n    }\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(s->avctx, AV_LOG_DEBUG, \"%s %s p:%d >>:%d ilv:%d bits:%d skip:%d %s comp:%d\\n\",\n               s->lossless ? \"lossless\" : \"sequential DCT\", s->rgb ? \"RGB\" : \"\",\n               predictor, point_transform, ilv, s->bits, s->mjpb_skiptosod,\n               s->pegasus_rct ? \"PRCT\" : (s->rct ? \"RCT\" : \"\"), nb_components);\n\n\n    /* mjpeg-b can have padding bytes between sos and image data, skip them */\n    for (i = s->mjpb_skiptosod; i > 0; i--)\n        skip_bits(&s->gb, 8);\n\n    if (s->lossless) {\n        av_assert0(s->picture_ptr == &s->picture);\n        if (CONFIG_JPEGLS_DECODER && s->ls) {\n//            for () {\n//            reset_ls_coding_parameters(s, 0);\n\n            if (ff_jpegls_decode_picture(s, predictor, point_transform, ilv) < 0)\n                return -1;\n        } else {\n            if (s->rgb) {\n                if (ljpeg_decode_rgb_scan(s, nb_components, predictor, point_transform) < 0)\n                    return -1;\n            } else {\n                if (ljpeg_decode_yuv_scan(s, predictor, point_transform) < 0)\n                    return -1;\n            }\n        }\n    } else {\n        if (s->progressive && predictor) {\n            av_assert0(s->picture_ptr == &s->picture);\n            if (mjpeg_decode_scan_progressive_ac(s, predictor, ilv, prev_shift,\n                                                 point_transform) < 0)\n                return -1;\n        } else {\n            if (mjpeg_decode_scan(s, nb_components, prev_shift, point_transform,\n                                  mb_bitmask, reference) < 0)\n                return -1;\n        }\n    }\n    emms_c();\n    return 0;\n out_of_range:\n    av_log(s->avctx, AV_LOG_ERROR, \"decode_sos: ac/dc index out of range\\n\");\n    return -1;\n}", "target": 1}
{"idx": 5209, "func": "static int test_exp_mod_zero()\n{\n    BIGNUM *a = NULL, *p = NULL, *m = NULL;\n    BIGNUM *r = NULL;\n    BN_ULONG one_word = 1;\n    BN_CTX *ctx = BN_CTX_new();\n    int ret = 1, failed = 0;\n\n    m = BN_new();\n    if (!m)\n        goto err;\n    BN_one(m);\n\n    a = BN_new();\n    if (!a)\n        goto err;\n    BN_one(a);\n\n    p = BN_new();\n    if (!p)\n        goto err;\n    BN_zero(p);\n\n    r = BN_new();\n    if (!r)\n        goto err;\n\n    if (!BN_rand(a, 1024, 0, 0))\n        goto err;\n\n    if (!BN_mod_exp(r, a, p, m, ctx))\n        goto err;\n\n    if (!a_is_zero_mod_one(\"BN_mod_exp\", r, a))\n        failed = 1;\n\n    if (!BN_mod_exp_recp(r, a, p, m, ctx))\n        goto err;\n\n    if (!a_is_zero_mod_one(\"BN_mod_exp_recp\", r, a))\n        failed = 1;\n\n    if (!BN_mod_exp_simple(r, a, p, m, ctx))\n        goto err;\n\n    if (!a_is_zero_mod_one(\"BN_mod_exp_simple\", r, a))\n        failed = 1;\n\n    if (!BN_mod_exp_mont(r, a, p, m, ctx, NULL))\n        goto err;\n\n    if (!a_is_zero_mod_one(\"BN_mod_exp_mont\", r, a))\n        failed = 1;\n\n    if (!BN_mod_exp_mont_consttime(r, a, p, m, ctx, NULL)) {\n        goto err;\n    }\n\n    if (!a_is_zero_mod_one(\"BN_mod_exp_mont_consttime\", r, a))\n        failed = 1;\n\n    /*\n     * A different codepath exists for single word multiplication\n     * in non-constant-time only.\n     */\n    if (!BN_mod_exp_mont_word(r, one_word, p, m, ctx, NULL))\n        goto err;\n\n    if (!BN_is_zero(r)) {\n        fprintf(stderr, \"BN_mod_exp_mont_word failed:\\n\");\n        fprintf(stderr, \"1 ** 0 mod 1 = r (should be 0)\\n\");\n        fprintf(stderr, \"r = \");\n        BN_print_fp(stderr, r);\n        fprintf(stderr, \"\\n\");\n        return 0;\n    }\n\n    ret = failed;\n\n err:\n    BN_free(r);\n    BN_free(a);\n    BN_free(p);\n    BN_free(m);\n    BN_CTX_free(ctx);\n\n    return ret;\n}", "target": 0}
{"idx": 5210, "func": "int asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,\n                     const ASN1_ITEM *it)\n{\n    ASN1_ENCODING *enc;\n    enc = asn1_get_enc_ptr(pval, it);\n    if (!enc || enc->modified)\n        return 0;\n    if (out) {\n        memcpy(*out, enc->enc, enc->len);\n        *out += enc->len;\n    }\n    if (len)\n        *len = enc->len;\n    return 1;\n}", "target": 1}
{"idx": 5211, "func": "int ctr_instantiate(RAND_DRBG *drbg,\n                    const unsigned char *ent, size_t entlen,\n                    const unsigned char *nonce, size_t noncelen,\n                    const unsigned char *pers, size_t perslen)\n{\n    RAND_DRBG_CTR *ctr = &drbg->ctr;\n\n    memset(ctr->K, 0, sizeof(ctr->K));\n    memset(ctr->V, 0, sizeof(ctr->V));\n    AES_set_encrypt_key(ctr->K, drbg->strength, &ctr->ks);\n    ctr_update(drbg, ent, entlen, pers, perslen, nonce, noncelen);\n    return 1;\n}", "target": 0}
{"idx": 5212, "func": "static void frame_thread_free(AVCodecContext *avctx, int thread_count)\n{\n    FrameThreadContext *fctx = avctx->thread_opaque;\n    AVCodec *codec = avctx->codec;\n    int i;\n\n    park_frame_worker_threads(fctx, thread_count);\n\n    if (fctx->prev_thread && fctx->prev_thread != fctx->threads)\n        update_context_from_thread(fctx->threads->avctx, fctx->prev_thread->avctx, 0);\n\n    fctx->die = 1;\n\n    for (i = 0; i < thread_count; i++) {\n        PerThreadContext *p = &fctx->threads[i];\n\n        pthread_mutex_lock(&p->mutex);\n        pthread_cond_signal(&p->input_cond);\n        pthread_mutex_unlock(&p->mutex);\n\n        pthread_join(p->thread, NULL);\n\n        if (codec->close)\n            codec->close(p->avctx);\n\n        avctx->codec = NULL;\n\n        release_delayed_buffers(p);\n    }\n\n    for (i = 0; i < thread_count; i++) {\n        PerThreadContext *p = &fctx->threads[i];\n\n        avcodec_default_free_buffers(p->avctx);\n\n        pthread_mutex_destroy(&p->mutex);\n        pthread_mutex_destroy(&p->progress_mutex);\n        pthread_cond_destroy(&p->input_cond);\n        pthread_cond_destroy(&p->progress_cond);\n        pthread_cond_destroy(&p->output_cond);\n        av_freep(&p->avpkt.data);\n\n        if (i)\n            av_freep(&p->avctx->priv_data);\n\n        av_freep(&p->avctx);\n    }\n\n    av_freep(&fctx->threads);\n    pthread_mutex_destroy(&fctx->buffer_mutex);\n    av_freep(&avctx->thread_opaque);\n}", "target": 0}
{"idx": 5213, "func": "static int mxf_edit_unit_absolute_offset(MXFContext *mxf, MXFIndexTable *index_table, int64_t edit_unit, int64_t *edit_unit_out, int64_t *offset_out, int nag)\n{\n    int i;\n    int offset_temp = 0;\n\n    for (i = 0; i < index_table->nb_segments; i++) {\n        MXFIndexTableSegment *s = index_table->segments[i];\n\n        edit_unit = FFMAX(edit_unit, s->index_start_position);  /* clamp if trying to seek before start */\n\n        if (edit_unit < s->index_start_position + s->index_duration) {\n            int64_t index = edit_unit - s->index_start_position;\n\n            if (s->edit_unit_byte_count)\n                offset_temp += s->edit_unit_byte_count * index;\n            else if (s->nb_index_entries) {\n                if (s->nb_index_entries == 2 * s->index_duration + 1)\n                    index *= 2;     /* Avid index */\n\n                if (index < 0 || index > s->nb_index_entries) {\n                    av_log(mxf->fc, AV_LOG_ERROR, \"IndexSID %i segment at %\"PRId64\" IndexEntryArray too small\\n\",\n                           index_table->index_sid, s->index_start_position);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                offset_temp = s->stream_offset_entries[index];\n            } else {\n                av_log(mxf->fc, AV_LOG_ERROR, \"IndexSID %i segment at %\"PRId64\" missing EditUnitByteCount and IndexEntryArray\\n\",\n                       index_table->index_sid, s->index_start_position);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (edit_unit_out)\n                *edit_unit_out = edit_unit;\n\n            return mxf_absolute_bodysid_offset(mxf, index_table->body_sid, offset_temp, offset_out);\n        } else {\n            /* EditUnitByteCount == 0 for VBR indexes, which is fine since they use explicit StreamOffsets */\n            offset_temp += s->edit_unit_byte_count * s->index_duration;\n        }\n    }\n\n    if (nag)\n        av_log(mxf->fc, AV_LOG_ERROR, \"failed to map EditUnit %\"PRId64\" in IndexSID %i to an offset\\n\", edit_unit, index_table->index_sid);\n\n    return AVERROR_INVALIDDATA;\n}", "target": 1}
{"idx": 5214, "func": "int tls_psk_do_binder(SSL *s, const EVP_MD *md, const unsigned char *msgstart,\n                      size_t binderoffset, const unsigned char *binderin,\n                      unsigned char *binderout, SSL_SESSION *sess, int sign,\n                      int external)\n{\n    EVP_PKEY *mackey = NULL;\n    EVP_MD_CTX *mctx = NULL;\n    unsigned char hash[EVP_MAX_MD_SIZE], binderkey[EVP_MAX_MD_SIZE];\n    unsigned char finishedkey[EVP_MAX_MD_SIZE], tmpbinder[EVP_MAX_MD_SIZE];\n    unsigned char *early_secret;\n    static const unsigned char resumption_label[] = \"res binder\";\n    static const unsigned char external_label[] = \"ext binder\";\n    const unsigned char *label;\n    size_t bindersize, labelsize, hashsize;\n    int hashsizei = EVP_MD_size(md);\n    int ret = -1;\n    int usepskfored = 0;\n\n    /* Ensure cast to size_t is safe */\n    if (!ossl_assert(hashsizei >= 0)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    hashsize = (size_t)hashsizei;\n\n    if (external\n            && s->early_data_state == SSL_EARLY_DATA_CONNECTING\n            && s->session->ext.max_early_data == 0\n            && sess->ext.max_early_data > 0)\n        usepskfored = 1;\n\n    if (external) {\n        label = external_label;\n        labelsize = sizeof(external_label) - 1;\n    } else {\n        label = resumption_label;\n        labelsize = sizeof(resumption_label) - 1;\n    }\n\n    /*\n     * Generate the early_secret. On the server side we've selected a PSK to\n     * resume with (internal or external) so we always do this. On the client\n     * side we do this for a non-external (i.e. resumption) PSK or external PSK\n     * that will be used for early_data so that it is in place for sending early\n     * data. For client side external PSK not being used for early_data we\n     * generate it but store it away for later use.\n     */\n    if (s->server || !external || usepskfored)\n        early_secret = (unsigned char *)s->early_secret;\n    else\n        early_secret = (unsigned char *)sess->early_secret;\n\n    if (!tls13_generate_secret(s, md, NULL, sess->master_key,\n                               sess->master_key_length, early_secret)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    /*\n     * Create the handshake hash for the binder key...the messages so far are\n     * empty!\n     */\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL\n            || EVP_DigestInit_ex(mctx, md, NULL) <= 0\n            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /* Generate the binder key */\n    if (!tls13_hkdf_expand(s, md, early_secret, label, labelsize, hash,\n                           hashsize, binderkey, hashsize, 1)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    /* Generate the finished key */\n    if (!tls13_derive_finishedkey(s, md, binderkey, finishedkey, hashsize)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    if (EVP_DigestInit_ex(mctx, md, NULL) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /*\n     * Get a hash of the ClientHello up to the start of the binders. If we are\n     * following a HelloRetryRequest then this includes the hash of the first\n     * ClientHello and the HelloRetryRequest itself.\n     */\n    if (s->hello_retry_request == SSL_HRR_PENDING) {\n        size_t hdatalen;\n        long hdatalen_l;\n        void *hdata;\n\n        hdatalen = hdatalen_l =\n            BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n        if (hdatalen_l <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                     SSL_R_BAD_HANDSHAKE_LENGTH);\n            goto err;\n        }\n\n        /*\n         * For servers the handshake buffer data will include the second\n         * ClientHello - which we don't want - so we need to take that bit off.\n         */\n        if (s->server) {\n            PACKET hashprefix, msg;\n\n            /* Find how many bytes are left after the first two messages */\n            if (!PACKET_buf_init(&hashprefix, hdata, hdatalen)\n                    || !PACKET_forward(&hashprefix, 1)\n                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)\n                    || !PACKET_forward(&hashprefix, 1)\n                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                         ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            hdatalen -= PACKET_remaining(&hashprefix);\n        }\n\n        if (EVP_DigestUpdate(mctx, hdata, hdatalen) <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    if (EVP_DigestUpdate(mctx, msgstart, binderoffset) <= 0\n            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    mackey = EVP_PKEY_new_raw_private_key(EVP_PKEY_HMAC, NULL, finishedkey,\n                                          hashsize);\n    if (mackey == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (!sign)\n        binderout = tmpbinder;\n\n    bindersize = hashsize;\n    if (EVP_DigestSignInit(mctx, NULL, md, NULL, mackey) <= 0\n            || EVP_DigestSignUpdate(mctx, hash, hashsize) <= 0\n            || EVP_DigestSignFinal(mctx, binderout, &bindersize) <= 0\n            || bindersize != hashsize) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (sign) {\n        ret = 1;\n    } else {\n        /* HMAC keys can't do EVP_DigestVerify* - use CRYPTO_memcmp instead */\n        ret = (CRYPTO_memcmp(binderin, binderout, hashsize) == 0);\n        if (!ret)\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PSK_DO_BINDER,\n                     SSL_R_BINDER_DOES_NOT_VERIFY);\n    }\n\n err:\n    OPENSSL_cleanse(binderkey, sizeof(binderkey));\n    OPENSSL_cleanse(finishedkey, sizeof(finishedkey));\n    EVP_PKEY_free(mackey);\n    EVP_MD_CTX_free(mctx);\n\n    return ret;\n}", "target": 0}
{"idx": 5215, "func": "static int internal_verify(X509_STORE_CTX *ctx)\n{\n    int ok = 0, n;\n    X509 *xs, *xi;\n    EVP_PKEY *pkey = NULL;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n\n    cb = ctx->verify_cb;\n\n    n = sk_X509_num(ctx->chain) - 1;\n    ctx->error_depth = n;\n    xi = sk_X509_value(ctx->chain, n);\n\n    /*\n     * With DANE-verified bare public key TA signatures, it remains only to\n     * check the timestamps of the top certificate.  We report the issuer as\n     * NULL, since all we have is a bare key.\n     */\n    if (ctx->bare_ta_signed) {\n        xs = xi;\n        xi = NULL;\n        goto check_cert;\n    }\n\n    if (ctx->check_issued(ctx, xi, xi))\n        xs = xi;\n    else {\n        if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {\n            xs = xi;\n            goto check_cert;\n        }\n        if (n <= 0) {\n            ctx->error = X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;\n            ctx->current_cert = xi;\n            ok = cb(0, ctx);\n            goto end;\n        } else {\n            n--;\n            ctx->error_depth = n;\n            xs = sk_X509_value(ctx->chain, n);\n        }\n    }\n\n    /*\n     * Do not clear ctx->error=0, it must be \"sticky\", only the user's callback\n     * is allowed to reset errors (at its own peril).\n     */\n    while (n >= 0) {\n        ctx->error_depth = n;\n\n        /*\n         * Skip signature check for self signed certificates unless\n         * explicitly asked for. It doesn't add any security and just wastes\n         * time.\n         */\n        if (xs != xi || (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE)) {\n            if ((pkey = X509_get0_pubkey(xi)) == NULL) {\n                ctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n                ctx->current_cert = xi;\n                ok = (*cb) (0, ctx);\n                if (!ok)\n                    goto end;\n            } else if (X509_verify(xs, pkey) <= 0) {\n                ctx->error = X509_V_ERR_CERT_SIGNATURE_FAILURE;\n                ctx->current_cert = xs;\n                ok = (*cb) (0, ctx);\n                if (!ok)\n                    goto end;\n            }\n        }\n\n check_cert:\n        ok = x509_check_cert_time(ctx, xs, 0);\n        if (!ok)\n            goto end;\n\n        /* The last error (if any) is still in the error value */\n        ctx->current_issuer = xi;\n        ctx->current_cert = xs;\n        ok = (*cb) (1, ctx);\n        if (!ok)\n            goto end;\n\n        n--;\n        if (n >= 0) {\n            xi = xs;\n            xs = sk_X509_value(ctx->chain, n);\n        }\n    }\n    ok = 1;\n end:\n    return ok;\n}", "target": 0}
{"idx": 5216, "func": "static int\nTIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSampleformatArray\";\n\tvoid* conv;\n\tuint32 i;\n\tint ok;\n\tconv = _TIFFmalloc(count*sizeof(double));\n\tif (conv == NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Out of memory\");\n\t\treturn (0);\n\t}\n\n\tswitch (tif->tif_dir.td_sampleformat)\n\t{\n\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\tif (tif->tif_dir.td_bitspersample<=32)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((float*)conv)[i] = _TIFFClampDoubleToFloat(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagFloatArray(tif,ndir,dir,tag,count,(float*)conv);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tok = TIFFWriteDirectoryTagDoubleArray(tif,ndir,dir,tag,count,value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_INT:\n\t\t\tif (tif->tif_dir.td_bitspersample<=8)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((int8*)conv)[i] = TIFFClampDoubleToInt8(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagSbyteArray(tif,ndir,dir,tag,count,(int8*)conv);\n\t\t\t}\n\t\t\telse if (tif->tif_dir.td_bitspersample<=16)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((int16*)conv)[i] = TIFFClampDoubleToInt16(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((int32*)conv)[i] = TIFFClampDoubleToInt32(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagSlongArray(tif,ndir,dir,tag,count,(int32*)conv);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_UINT:\n\t\t\tif (tif->tif_dir.td_bitspersample<=8)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((uint8*)conv)[i] = TIFFClampDoubleToUInt8(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagByteArray(tif,ndir,dir,tag,count,(uint8*)conv);\n\t\t\t}\n\t\t\telse if (tif->tif_dir.td_bitspersample<=16)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((uint16*)conv)[i] = TIFFClampDoubleToUInt16(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagShortArray(tif,ndir,dir,tag,count,(uint16*)conv);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((uint32*)conv)[i] = TIFFClampDoubleToUInt32(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagLongArray(tif,ndir,dir,tag,count,(uint32*)conv);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tok = 0;\n\t}\n\n\t_TIFFfree(conv);\n\treturn (ok);\n}", "target": 1}
{"idx": 5217, "func": "static void lsp2lpc(int16_t *lpc)\n{\n    int f1[LPC_ORDER / 2 + 1];\n    int f2[LPC_ORDER / 2 + 1];\n    int i, j;\n\n    /* Calculate negative cosine */\n    for (j = 0; j < LPC_ORDER; j++) {\n        int index     = lpc[j] >> 7;\n        int offset    = lpc[j] & 0x7f;\n        int temp1     = cos_tab[index] << 16;\n        int temp2     = (cos_tab[index + 1] - cos_tab[index]) *\n                          ((offset << 8) + 0x80) << 1;\n\n        lpc[j] = -(av_sat_dadd32(1 << 15, temp1 + temp2) >> 16);\n    }\n\n    /*\n     * Compute sum and difference polynomial coefficients\n     * (bitexact alternative to lsp2poly() in lsp.c)\n     */\n    /* Initialize with values in Q28 */\n    f1[0] = 1 << 28;\n    f1[1] = (lpc[0] << 14) + (lpc[2] << 14);\n    f1[2] = lpc[0] * lpc[2] + (2 << 28);\n\n    f2[0] = 1 << 28;\n    f2[1] = (lpc[1] << 14) + (lpc[3] << 14);\n    f2[2] = lpc[1] * lpc[3] + (2 << 28);\n\n    /*\n     * Calculate and scale the coefficients by 1/2 in\n     * each iteration for a final scaling factor of Q25\n     */\n    for (i = 2; i < LPC_ORDER / 2; i++) {\n        f1[i + 1] = f1[i - 1] + MULL2(f1[i], lpc[2 * i]);\n        f2[i + 1] = f2[i - 1] + MULL2(f2[i], lpc[2 * i + 1]);\n\n        for (j = i; j >= 2; j--) {\n            f1[j] = MULL2(f1[j - 1], lpc[2 * i]) +\n                    (f1[j] >> 1) + (f1[j - 2] >> 1);\n            f2[j] = MULL2(f2[j - 1], lpc[2 * i + 1]) +\n                    (f2[j] >> 1) + (f2[j - 2] >> 1);\n        }\n\n        f1[0] >>= 1;\n        f2[0] >>= 1;\n        f1[1] = ((lpc[2 * i]     << 16 >> i) + f1[1]) >> 1;\n        f2[1] = ((lpc[2 * i + 1] << 16 >> i) + f2[1]) >> 1;\n    }\n\n    /* Convert polynomial coefficients to LPC coefficients */\n    for (i = 0; i < LPC_ORDER / 2; i++) {\n        int64_t ff1 = f1[i + 1] + f1[i];\n        int64_t ff2 = f2[i + 1] - f2[i];\n\n        lpc[i] = av_clipl_int32(((ff1 + ff2) << 3) + (1 << 15)) >> 16;\n        lpc[LPC_ORDER - i - 1] = av_clipl_int32(((ff1 - ff2) << 3) +\n                                                (1 << 15)) >> 16;\n    }\n}", "target": 1}
{"idx": 5218, "func": "static void vc1_inv_trans_4x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n{\n    int i;\n    int dc = block[0];\n    dc = (17 * dc +  4) >> 3;\n    dc = (17 * dc + 64) >> 7;\n    for(i = 0; i < 4; i++){\n        dest[0] = av_clip_uint8(dest[0] + dc);\n        dest[1] = av_clip_uint8(dest[1] + dc);\n        dest[2] = av_clip_uint8(dest[2] + dc);\n        dest[3] = av_clip_uint8(dest[3] + dc);\n        dest += linesize;\n    }\n}", "target": 0}
{"idx": 5219, "func": "int av_strcasecmp(const char *a, const char *b)\n{\n    uint8_t c1, c2;\n    do {\n        c1 = av_tolower(*a++);\n        c2 = av_tolower(*b++);\n    } while (c1 && c1 == c2);\n    return c1 - c2;\n}", "target": 1}
{"idx": 5220, "func": "static int mpc7_decode_frame(AVCodecContext * avctx, void *data,\n                             int *got_frame_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    MPCContext *c = avctx->priv_data;\n    GetBitContext gb;\n    uint8_t *bits;\n    int i, ch;\n    int mb = -1;\n    Band *bands = c->bands;\n    int off, ret;\n    int bits_used, bits_avail;\n\n    memset(bands, 0, sizeof(*bands) * (c->maxbands + 1));\n    if(buf_size <= 4){\n        av_log(avctx, AV_LOG_ERROR, \"Too small buffer passed (%i bytes)\\n\", buf_size);\n        return AVERROR(EINVAL);\n    }\n\n    /* get output buffer */\n    c->frame.nb_samples = buf[1] ? c->lastframelen : MPC_FRAME_SIZE;\n    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n\n    bits = av_malloc(((buf_size - 1) & ~3) + FF_INPUT_BUFFER_PADDING_SIZE);\n    c->dsp.bswap_buf((uint32_t*)bits, (const uint32_t*)(buf + 4), (buf_size - 4) >> 2);\n    init_get_bits(&gb, bits, (buf_size - 4)* 8);\n    skip_bits_long(&gb, buf[0]);\n\n    /* read subband indexes */\n    for(i = 0; i <= c->maxbands; i++){\n        for(ch = 0; ch < 2; ch++){\n            int t = 4;\n            if(i) t = get_vlc2(&gb, hdr_vlc.table, MPC7_HDR_BITS, 1) - 5;\n            if(t == 4) bands[i].res[ch] = get_bits(&gb, 4);\n            else bands[i].res[ch] = bands[i-1].res[ch] + t;\n        }\n\n        if(bands[i].res[0] || bands[i].res[1]){\n            mb = i;\n            if(c->MSS) bands[i].msf = get_bits1(&gb);\n        }\n    }\n    /* get scale indexes coding method */\n    for(i = 0; i <= mb; i++)\n        for(ch = 0; ch < 2; ch++)\n            if(bands[i].res[ch]) bands[i].scfi[ch] = get_vlc2(&gb, scfi_vlc.table, MPC7_SCFI_BITS, 1);\n    /* get scale indexes */\n    for(i = 0; i <= mb; i++){\n        for(ch = 0; ch < 2; ch++){\n            if(bands[i].res[ch]){\n                bands[i].scf_idx[ch][2] = c->oldDSCF[ch][i];\n                bands[i].scf_idx[ch][0] = get_scale_idx(&gb, bands[i].scf_idx[ch][2]);\n                switch(bands[i].scfi[ch]){\n                case 0:\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n                    break;\n                case 1:\n                    bands[i].scf_idx[ch][1] = get_scale_idx(&gb, bands[i].scf_idx[ch][0]);\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1];\n                    break;\n                case 2:\n                    bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n                    break;\n                case 3:\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n                    break;\n                }\n                c->oldDSCF[ch][i] = bands[i].scf_idx[ch][2];\n            }\n        }\n    }\n    /* get quantizers */\n    memset(c->Q, 0, sizeof(c->Q));\n    off = 0;\n    for(i = 0; i < BANDS; i++, off += SAMPLES_PER_BAND)\n        for(ch = 0; ch < 2; ch++)\n            idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off);\n\n    ff_mpc_dequantize_and_synth(c, mb, c->frame.data[0], 2);\n\n    av_free(bits);\n\n    bits_used = get_bits_count(&gb);\n    bits_avail = (buf_size - 4) * 8;\n    if(!buf[1] && ((bits_avail < bits_used) || (bits_used + 32 <= bits_avail))){\n        av_log(NULL,0, \"Error decoding frame: used %i of %i bits\\n\", bits_used, bits_avail);\n        return -1;\n    }\n    if(c->frames_to_skip){\n        c->frames_to_skip--;\n        *got_frame_ptr = 0;\n        return buf_size;\n    }\n\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = c->frame;\n\n    return buf_size;\n}", "target": 1}
{"idx": 5221, "func": "int swr_convert_frame(SwrContext *s,\n                      AVFrame *out, const AVFrame *in)\n{\n    int ret, setup = 0;\n\n    if (!swr_is_initialized(s)) {\n        if ((ret = swr_config_frame(s, out, in)) < 0)\n            return ret;\n        if ((ret = swr_init(s)) < 0)\n            return ret;\n        setup = 1;\n    } else {\n        // return as is or reconfigure for input changes?\n        if ((ret = config_changed(s, out, in)))\n            return ret;\n    }\n\n    if (out) {\n        if (!out->linesize[0]) {\n            out->nb_samples = swr_get_delay(s, s->out_sample_rate) + 3;\n            if (in) {\n                out->nb_samples += in->nb_samples*(int64_t)s->out_sample_rate / s->in_sample_rate;\n            }\n            if ((ret = av_frame_get_buffer(out, 0)) < 0) {\n                if (setup)\n                    swr_close(s);\n                return ret;\n            }\n        } else {\n            if (!out->nb_samples)\n                out->nb_samples = available_samples(out);\n        }\n    }\n\n    return convert_frame(s, out, in);\n}", "target": 0}
{"idx": 5222, "func": "static int rv10_decode_packet(AVCodecContext *avctx,\n                             const uint8_t *buf, int buf_size, int buf_size2)\n{\n    MpegEncContext *s = avctx->priv_data;\n    int mb_count, mb_pos, left, start_mb_x, active_bits_size;\n\n    active_bits_size = buf_size * 8;\n    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);\n    if(s->codec_id ==CODEC_ID_RV10)\n        mb_count = rv10_decode_picture_header(s);\n    else\n        mb_count = rv20_decode_picture_header(s);\n    if (mb_count < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"HEADER ERROR\\n\");\n        return -1;\n    }\n\n    if (s->mb_x >= s->mb_width ||\n        s->mb_y >= s->mb_height) {\n        av_log(s->avctx, AV_LOG_ERROR, \"POS ERROR %d %d\\n\", s->mb_x, s->mb_y);\n        return -1;\n    }\n    mb_pos = s->mb_y * s->mb_width + s->mb_x;\n    left = s->mb_width * s->mb_height - mb_pos;\n    if (mb_count > left) {\n        av_log(s->avctx, AV_LOG_ERROR, \"COUNT ERROR\\n\");\n        return -1;\n    }\n\n    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr==NULL) {\n        if(s->current_picture_ptr){ //FIXME write parser so we always have complete frames?\n            ff_er_frame_end(s);\n            ff_MPV_frame_end(s);\n            s->mb_x= s->mb_y = s->resync_mb_x = s->resync_mb_y= 0;\n        }\n        if(ff_MPV_frame_start(s, avctx) < 0)\n            return -1;\n        ff_er_frame_start(s);\n    } else {\n        if (s->current_picture_ptr->f.pict_type != s->pict_type) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n            return -1;\n        }\n    }\n\n    av_dlog(avctx, \"qscale=%d\\n\", s->qscale);\n\n    /* default quantization values */\n    if(s->codec_id== CODEC_ID_RV10){\n        if(s->mb_y==0) s->first_slice_line=1;\n    }else{\n        s->first_slice_line=1;\n        s->resync_mb_x= s->mb_x;\n    }\n    start_mb_x= s->mb_x;\n    s->resync_mb_y= s->mb_y;\n    if(s->h263_aic){\n        s->y_dc_scale_table=\n        s->c_dc_scale_table= ff_aic_dc_scale_table;\n    }else{\n        s->y_dc_scale_table=\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n    }\n\n    if(s->modified_quant)\n        s->chroma_qscale_table= ff_h263_chroma_qscale_table;\n\n    ff_set_qscale(s, s->qscale);\n\n    s->rv10_first_dc_coded[0] = 0;\n    s->rv10_first_dc_coded[1] = 0;\n    s->rv10_first_dc_coded[2] = 0;\n    s->block_wrap[0]=\n    s->block_wrap[1]=\n    s->block_wrap[2]=\n    s->block_wrap[3]= s->b8_stride;\n    s->block_wrap[4]=\n    s->block_wrap[5]= s->mb_stride;\n    ff_init_block_index(s);\n    /* decode each macroblock */\n\n    for(s->mb_num_left= mb_count; s->mb_num_left>0; s->mb_num_left--) {\n        int ret;\n        ff_update_block_index(s);\n        av_dlog(avctx, \"**mb x=%d y=%d\\n\", s->mb_x, s->mb_y);\n\n        s->mv_dir = MV_DIR_FORWARD;\n        s->mv_type = MV_TYPE_16X16;\n        ret=ff_h263_decode_mb(s, s->block);\n\n        // Repeat the slice end check from ff_h263_decode_mb with our active\n        // bitstream size\n        if (ret != SLICE_ERROR) {\n            int v = show_bits(&s->gb, 16);\n\n            if (get_bits_count(&s->gb) + 16 > active_bits_size)\n                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;\n\n            if (!v)\n                ret = SLICE_END;\n        }\n        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&\n            8 * buf_size2 >= get_bits_count(&s->gb)) {\n            active_bits_size = buf_size2 * 8;\n            av_log(avctx, AV_LOG_DEBUG, \"update size from %d to %d\\n\",\n                   8 * buf_size, active_bits_size);\n            ret= SLICE_OK;\n        }\n\n        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"ERROR at MB %d %d\\n\", s->mb_x, s->mb_y);\n            return -1;\n        }\n        if(s->pict_type != AV_PICTURE_TYPE_B)\n            ff_h263_update_motion_val(s);\n        ff_MPV_decode_mb(s, s->block);\n        if(s->loop_filter)\n            ff_h263_loop_filter(s);\n\n        if (++s->mb_x == s->mb_width) {\n            s->mb_x = 0;\n            s->mb_y++;\n            ff_init_block_index(s);\n        }\n        if(s->mb_x == s->resync_mb_x)\n            s->first_slice_line=0;\n        if(ret == SLICE_END) break;\n    }\n\n    ff_er_add_slice(s, start_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END);\n\n    return active_bits_size;\n}", "target": 0}
{"idx": 5223, "func": "static ngx_int_t\nngx_http_find_virtual_server(ngx_http_request_t *r, u_char *host, size_t len)\n{\n    ngx_http_core_loc_conf_t  *clcf;\n    ngx_http_core_srv_conf_t  *cscf;\n\n    if (r->virtual_names == NULL) {\n        return NGX_DECLINED;\n    }\n\n    cscf = ngx_hash_find_combined(&r->virtual_names->names,\n                                  ngx_hash_key(host, len), host, len);\n\n    if (cscf) {\n        goto found;\n    }\n\n#if (NGX_PCRE)\n\n    if (r->virtual_names->nregex) {\n        size_t                   ncaptures;\n        ngx_int_t                n;\n        ngx_uint_t               i;\n        ngx_str_t                name;\n        ngx_http_server_name_t  *sn;\n\n        name.len = len;\n        name.data = host;\n\n        ncaptures = 0;\n\n        sn = r->virtual_names->regex;\n\n        for (i = 0; i < r->virtual_names->nregex; i++) {\n\n            if (sn[i].captures && r->captures == NULL) {\n\n                ncaptures = (NGX_HTTP_MAX_CAPTURES + 1) * 3;\n\n                r->captures = ngx_palloc(r->pool, ncaptures * sizeof(int));\n                if (r->captures == NULL) {\n                    return NGX_ERROR;\n                }\n            }\n\n            n = ngx_regex_exec(sn[i].regex, &name, r->captures, ncaptures);\n\n            if (n == NGX_REGEX_NO_MATCHED) {\n                continue;\n            }\n\n            if (n < 0) {\n                ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n                              ngx_regex_exec_n\n                              \" failed: %d on \\\"%V\\\" using \\\"%V\\\"\",\n                              n, &name, &sn[i].name);\n                return NGX_ERROR;\n            }\n\n            /* match */\n\n            cscf = sn[i].core_srv_conf;\n\n            r->ncaptures = ncaptures;\n            r->captures_data = host;\n\n            goto found;\n        }\n    }\n\n#endif\n\n    return NGX_OK;\n\nfound:\n\n    r->srv_conf = cscf->ctx->srv_conf;\n    r->loc_conf = cscf->ctx->loc_conf;\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n    r->connection->log->file = clcf->error_log->file;\n\n    if (!(r->connection->log->log_level & NGX_LOG_DEBUG_CONNECTION)) {\n        r->connection->log->log_level = clcf->error_log->log_level;\n    }\n\n    return NGX_OK;\n}", "target": 0}
{"idx": 5224, "func": "static int on2avc_decode_band_scales(On2AVCContext *c, GetBitContext *gb)\n{\n    int w, w2, b, scale, first = 1;\n    int band_off = 0;\n\n    for (w = 0; w < c->num_windows; w++) {\n        if (!c->grouping[w]) {\n            memcpy(c->band_scales + band_off,\n                   c->band_scales + band_off - c->num_bands,\n                   c->num_bands * sizeof(*c->band_scales));\n            band_off += c->num_bands;\n            continue;\n        }\n        for (b = 0; b < c->num_bands; b++) {\n            if (!c->band_type[band_off]) {\n                int all_zero = 1;\n                for (w2 = w + 1; w2 < c->num_windows; w2++) {\n                    if (c->grouping[w2])\n                        break;\n                    if (c->band_type[w2 * c->num_bands + b]) {\n                        all_zero = 0;\n                        break;\n                    }\n                }\n                if (all_zero) {\n                    c->band_scales[band_off++] = 0;\n                    continue;\n                }\n            }\n            if (first) {\n                scale = get_bits(gb, 7);\n                first = 0;\n            } else {\n                scale += get_vlc2(gb, c->scale_diff.table, 9, 3) - 60;\n            }\n            if (scale < 0 || scale > 128) {\n                av_log(c->avctx, AV_LOG_ERROR, \"Invalid scale value %d\\n\",\n                       scale);\n                return AVERROR_INVALIDDATA;\n            }\n            c->band_scales[band_off++] = c->scale_tab[scale];\n        }\n    }\n\n    return 0;\n}", "target": 1}
{"idx": 5225, "func": "AP_DECLARE(const char *) ap_scan_http_field_content(const char *ptr)\n{\n    for ( ; *ptr && !TEST_CHAR(*ptr, T_HTTP_CTRLS); ++ptr) ;\n\n    return ptr;\n}", "target": 0}
{"idx": 5226, "func": "static void rv34_pred_4x4_block(RV34DecContext *r, uint8_t *dst, int stride, int itype, int up, int left, int down, int right)\n{\n    uint8_t *prev = dst - stride + 4;\n    uint32_t topleft;\n\n    if(!up && !left)\n        itype = DC_128_PRED;\n    else if(!up){\n        if(itype == VERT_PRED) itype = HOR_PRED;\n        if(itype == DC_PRED)   itype = LEFT_DC_PRED;\n    }else if(!left){\n        if(itype == HOR_PRED)  itype = VERT_PRED;\n        if(itype == DC_PRED)   itype = TOP_DC_PRED;\n        if(itype == DIAG_DOWN_LEFT_PRED) itype = DIAG_DOWN_LEFT_PRED_RV40_NODOWN;\n    }\n    if(!down){\n        if(itype == DIAG_DOWN_LEFT_PRED) itype = DIAG_DOWN_LEFT_PRED_RV40_NODOWN;\n        if(itype == HOR_UP_PRED) itype = HOR_UP_PRED_RV40_NODOWN;\n        if(itype == VERT_LEFT_PRED) itype = VERT_LEFT_PRED_RV40_NODOWN;\n    }\n    if(!right && up){\n        topleft = dst[-stride + 3] * 0x01010101;\n        prev = (uint8_t*)&topleft;\n    }\n    r->h.pred4x4[itype](dst, prev, stride);\n}", "target": 1}
{"idx": 5227, "func": "void PEM_proc_type(char *buf, int type)\n\t{\n\tconst char *str;\n\n\tif (type == PEM_TYPE_ENCRYPTED)\n\t\tstr=\"ENCRYPTED\";\n\telse if (type == PEM_TYPE_MIC_CLEAR)\n\t\tstr=\"MIC-CLEAR\";\n\telse if (type == PEM_TYPE_MIC_ONLY)\n\t\tstr=\"MIC-ONLY\";\n\telse\n\t\tstr=\"BAD-TYPE\";\n\t\t\n\tBUF_strlcat(buf,\"Proc-Type: 4,\",PEM_BUFSIZE);\n\tBUF_strlcat(buf,str,PEM_BUFSIZE);\n\tBUF_strlcat(buf,\"\\n\",PEM_BUFSIZE);\n\t}", "target": 0}
{"idx": 5228, "func": "static int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n    HLSContext *c = v->parent->priv_data;\n    int ret, i;\n    int just_opened = 0;\n\nrestart:\n    if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n        struct segment *seg;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = 0; i < v->n_main_streams; i++) {\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n                    v->needed = 1;\n                    break;\n                }\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n        reload_interval = default_reload_interval(v);\n\nreload:\n        if (!v->finished &&\n            av_gettime_relative() - v->last_load_time >= reload_interval) {\n            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        seg = current_segment(v);\n\n        /* load/update Media Initialization Section, if any */\n        ret = update_init_section(v, seg);\n        if (ret)\n            return ret;\n\n        ret = open_input(c, v, seg);\n        if (ret < 0) {\n            if (ff_check_interrupt(c->interrupt_callback))\n                return AVERROR_EXIT;\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            v->cur_seq_no += 1;\n            goto reload;\n        }\n        just_opened = 1;\n    }\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n        /* Push init section out first before first actual segment */\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n        memcpy(buf, v->init_sec_buf, copy_size);\n        v->init_sec_buf_read_offset += copy_size;\n        return copy_size;\n    }\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ff_format_io_close(v->parent, &v->input);\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}", "target": 1}
{"idx": 5229, "func": "int EVP_PKEY_id(const EVP_PKEY *pkey)\n{\n    return pkey->type;\n}", "target": 1}
{"idx": 5230, "func": "static inline void backup_mb_border(H264Context *h, uint8_t *src_y, uint8_t *src_cb, uint8_t *src_cr, int linesize, int uvlinesize, int simple){\n    MpegEncContext * const s = &h->s;\n    int top_idx = 1;\n\n    src_y  -=   linesize;\n    src_cb -= uvlinesize;\n    src_cr -= uvlinesize;\n\n    if(!simple && FRAME_MBAFF){\n        if(s->mb_y&1){\n            if(!MB_MBAFF){\n                *(uint64_t*)(h->top_borders[0][s->mb_x]+ 0)= *(uint64_t*)(src_y +  15*linesize);\n                *(uint64_t*)(h->top_borders[0][s->mb_x]+ 8)= *(uint64_t*)(src_y +8+15*linesize);\n                if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n                    *(uint64_t*)(h->top_borders[0][s->mb_x]+16)= *(uint64_t*)(src_cb+7*uvlinesize);\n                    *(uint64_t*)(h->top_borders[0][s->mb_x]+24)= *(uint64_t*)(src_cr+7*uvlinesize);\n                }\n            }\n        }else if(MB_MBAFF){\n            top_idx = 0;\n        }else\n            return;\n    }\n\n    // There are two lines saved, the line above the the top macroblock of a pair,\n    // and the line above the bottom macroblock\n\n    *(uint64_t*)(h->top_borders[top_idx][s->mb_x]+0)= *(uint64_t*)(src_y +  16*linesize);\n    *(uint64_t*)(h->top_borders[top_idx][s->mb_x]+8)= *(uint64_t*)(src_y +8+16*linesize);\n\n    if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n        *(uint64_t*)(h->top_borders[top_idx][s->mb_x]+16)= *(uint64_t*)(src_cb+8*uvlinesize);\n        *(uint64_t*)(h->top_borders[top_idx][s->mb_x]+24)= *(uint64_t*)(src_cr+8*uvlinesize);\n    }\n}", "target": 0}
{"idx": 5231, "func": "static void new_video_stream(AVFormatContext *oc, int file_idx)\n{\n    AVStream *st;\n    AVOutputStream *ost;\n    AVCodecContext *video_enc;\n    enum CodecID codec_id = CODEC_ID_NONE;\n    AVCodec *codec= NULL;\n\n    st = av_new_stream(oc, oc->nb_streams < nb_streamid_map ? streamid_map[oc->nb_streams] : 0);\n    if (!st) {\n        fprintf(stderr, \"Could not alloc stream\\n\");\n        ffmpeg_exit(1);\n    }\n    ost = new_output_stream(oc, file_idx);\n\n    output_codecs = grow_array(output_codecs, sizeof(*output_codecs), &nb_output_codecs, nb_output_codecs + 1);\n    if(!video_stream_copy){\n        if (video_codec_name) {\n            codec_id = find_codec_or_die(video_codec_name, AVMEDIA_TYPE_VIDEO, 1,\n                                         avcodec_opts[AVMEDIA_TYPE_VIDEO]->strict_std_compliance);\n            codec = avcodec_find_encoder_by_name(video_codec_name);\n            output_codecs[nb_output_codecs-1] = codec;\n        } else {\n            codec_id = av_guess_codec(oc->oformat, NULL, oc->filename, NULL, AVMEDIA_TYPE_VIDEO);\n            codec = avcodec_find_encoder(codec_id);\n        }\n    }\n\n    avcodec_get_context_defaults3(st->codec, codec);\n    ost->bitstream_filters = video_bitstream_filters;\n    video_bitstream_filters= NULL;\n\n    avcodec_thread_init(st->codec, thread_count);\n\n    video_enc = st->codec;\n\n    if(video_codec_tag)\n        video_enc->codec_tag= video_codec_tag;\n\n    if(   (video_global_header&1)\n       || (video_global_header==0 && (oc->oformat->flags & AVFMT_GLOBALHEADER))){\n        video_enc->flags |= CODEC_FLAG_GLOBAL_HEADER;\n        avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags|= CODEC_FLAG_GLOBAL_HEADER;\n    }\n    if(video_global_header&2){\n        video_enc->flags2 |= CODEC_FLAG2_LOCAL_HEADER;\n        avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags2|= CODEC_FLAG2_LOCAL_HEADER;\n    }\n\n    if (video_stream_copy) {\n        st->stream_copy = 1;\n        video_enc->codec_type = AVMEDIA_TYPE_VIDEO;\n        video_enc->sample_aspect_ratio =\n        st->sample_aspect_ratio = av_d2q(frame_aspect_ratio*frame_height/frame_width, 255);\n    } else {\n        const char *p;\n        int i;\n        AVRational fps= frame_rate.num ? frame_rate : (AVRational){25,1};\n\n        video_enc->codec_id = codec_id;\n        set_context_opts(video_enc, avcodec_opts[AVMEDIA_TYPE_VIDEO], AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM, codec);\n\n        if (codec && codec->supported_framerates && !force_fps)\n            fps = codec->supported_framerates[av_find_nearest_q_idx(fps, codec->supported_framerates)];\n        video_enc->time_base.den = fps.num;\n        video_enc->time_base.num = fps.den;\n\n        video_enc->width = frame_width;\n        video_enc->height = frame_height;\n        video_enc->sample_aspect_ratio = av_d2q(frame_aspect_ratio*video_enc->height/video_enc->width, 255);\n        video_enc->pix_fmt = frame_pix_fmt;\n        st->sample_aspect_ratio = video_enc->sample_aspect_ratio;\n\n        choose_pixel_fmt(st, codec);\n\n        if (intra_only)\n            video_enc->gop_size = 0;\n        if (video_qscale || same_quality) {\n            video_enc->flags |= CODEC_FLAG_QSCALE;\n            video_enc->global_quality=\n                st->quality = FF_QP2LAMBDA * video_qscale;\n        }\n\n        if(intra_matrix)\n            video_enc->intra_matrix = intra_matrix;\n        if(inter_matrix)\n            video_enc->inter_matrix = inter_matrix;\n\n        p= video_rc_override_string;\n        for(i=0; p; i++){\n            int start, end, q;\n            int e=sscanf(p, \"%d,%d,%d\", &start, &end, &q);\n            if(e!=3){\n                fprintf(stderr, \"error parsing rc_override\\n\");\n                ffmpeg_exit(1);\n            }\n            video_enc->rc_override=\n                av_realloc(video_enc->rc_override,\n                           sizeof(RcOverride)*(i+1));\n            video_enc->rc_override[i].start_frame= start;\n            video_enc->rc_override[i].end_frame  = end;\n            if(q>0){\n                video_enc->rc_override[i].qscale= q;\n                video_enc->rc_override[i].quality_factor= 1.0;\n            }\n            else{\n                video_enc->rc_override[i].qscale= 0;\n                video_enc->rc_override[i].quality_factor= -q/100.0;\n            }\n            p= strchr(p, '/');\n            if(p) p++;\n        }\n        video_enc->rc_override_count=i;\n        if (!video_enc->rc_initial_buffer_occupancy)\n            video_enc->rc_initial_buffer_occupancy = video_enc->rc_buffer_size*3/4;\n        video_enc->me_threshold= me_threshold;\n        video_enc->intra_dc_precision= intra_dc_precision - 8;\n\n        if (do_psnr)\n            video_enc->flags|= CODEC_FLAG_PSNR;\n\n        /* two pass mode */\n        if (do_pass) {\n            if (do_pass == 1) {\n                video_enc->flags |= CODEC_FLAG_PASS1;\n            } else {\n                video_enc->flags |= CODEC_FLAG_PASS2;\n            }\n        }\n\n        if (forced_key_frames)\n            parse_forced_key_frames(forced_key_frames, ost, video_enc);\n    }\n    if (video_language) {\n        av_metadata_set2(&st->metadata, \"language\", video_language, 0);\n        av_freep(&video_language);\n    }\n\n    /* reset some key parameters */\n    video_disable = 0;\n    av_freep(&video_codec_name);\n    av_freep(&forced_key_frames);\n    video_stream_copy = 0;\n    frame_pix_fmt = PIX_FMT_NONE;\n}", "target": 0}
{"idx": 5232, "func": "static apr_status_t writev_nonblocking(apr_socket_t *s,\n                                       apr_bucket_brigade *bb,\n                                       core_output_filter_ctx_t *ctx,\n                                       apr_size_t bytes_to_write,\n                                       apr_size_t nvec,\n                                       conn_rec *c)\n{\n    apr_status_t rv;\n    struct iovec *vec = ctx->vec;\n    apr_size_t bytes_written = 0;\n    apr_size_t i, offset = 0;\n\n    do {\n        apr_size_t n = 0;\n        rv = apr_socket_sendv(s, vec + offset, nvec - offset, &n);\n        bytes_written += n;\n\n        for (i = offset; i < nvec; ) {\n            apr_bucket *bucket = APR_BRIGADE_FIRST(bb);\n            if (!bucket->length) {\n                apr_bucket_delete(bucket);\n            }\n            else if (n >= vec[i].iov_len) {\n                apr_bucket_delete(bucket);\n                n -= vec[i++].iov_len;\n                offset++;\n            }\n            else {\n                if (n) {\n                    apr_bucket_split(bucket, n);\n                    apr_bucket_delete(bucket);\n                    vec[i].iov_len -= n;\n                    vec[i].iov_base = (char *) vec[i].iov_base + n;\n                }\n                break;\n            }\n        }\n    } while (rv == APR_SUCCESS && bytes_written < bytes_to_write);\n\n    if ((ap__logio_add_bytes_out != NULL) && (bytes_written > 0)) {\n        ap__logio_add_bytes_out(c, bytes_written);\n    }\n    ctx->bytes_written += bytes_written;\n\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, rv, c,\n                  \"writev_nonblocking: %\"APR_SIZE_T_FMT\"/%\"APR_SIZE_T_FMT,\n                  bytes_written, bytes_to_write);\n    return rv;\n}", "target": 0}
{"idx": 5233, "func": "static int dirac_header(AVFormatContext *s, int idx)\n{\n    struct ogg *ogg = s->priv_data;\n    struct ogg_stream *os = ogg->streams + idx;\n    AVStream *st = s->streams[idx];\n    dirac_source_params source;\n    GetBitContext gb;\n\n    // already parsed the header\n    if (st->codec->codec_id == AV_CODEC_ID_DIRAC)\n        return 0;\n\n    init_get_bits(&gb, os->buf + os->pstart + 13, (os->psize - 13) * 8);\n    if (avpriv_dirac_parse_sequence_header(st->codec, &gb, &source) < 0)\n        return -1;\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codec->codec_id = AV_CODEC_ID_DIRAC;\n    // dirac in ogg always stores timestamps as though the video were interlaced\n    avpriv_set_pts_info(st, 64, st->codec->framerate.den, 2*st->codec->framerate.num);\n    return 1;\n}", "target": 1}
{"idx": 5234, "func": "static size_t i2c_ibuf(const unsigned char *b, size_t blen, int neg,\n                       unsigned char **pp)\n{\n    int pad = 0;\n    size_t ret, i;\n    unsigned char *p, pb = 0;\n    const unsigned char *n;\n\n    if (b == NULL || blen == 0)\n        ret = 1;\n    else {\n        ret = blen;\n        i = b[0];\n        if (ret == 1 && i == 0)\n            neg = 0;\n        if (!neg && (i > 127)) {\n            pad = 1;\n            pb = 0;\n        } else if (neg) {\n            if (i > 128) {\n                pad = 1;\n                pb = 0xFF;\n            } else if (i == 128) {\n                /*\n                 * Special case: if any other bytes non zero we pad:\n                 * otherwise we don't.\n                 */\n                for (i = 1; i < blen; i++)\n                    if (b[i]) {\n                        pad = 1;\n                        pb = 0xFF;\n                        break;\n                    }\n            }\n        }\n        ret += pad;\n    }\n    if (pp == NULL)\n        return ret;\n    p = *pp;\n\n    if (pad)\n        *(p++) = pb;\n    if (b == NULL || blen == 0)\n        *p = 0;\n    else if (!neg)\n        memcpy(p, b, blen);\n    else {\n        /* Begin at the end of the encoding */\n        n = b + blen - 1;\n        p += blen - 1;\n        i = blen;\n        /* Copy zeros to destination as long as source is zero */\n        while (!*n && i > 1) {\n            *(p--) = 0;\n            n--;\n            i--;\n        }\n        /* Complement and increment next octet */\n        *(p--) = ((*(n--)) ^ 0xff) + 1;\n        i--;\n        /* Complement any octets left */\n        for (; i > 0; i--)\n            *(p--) = *(n--) ^ 0xff;\n    }\n\n    *pp += ret;\n    return ret;\n}", "target": 0}
{"idx": 5235, "func": "static int tm2_read_deltas(TM2Context *ctx, int stream_id)\n{\n    int d, mb;\n    int i, v;\n\n    d  = get_bits(&ctx->gb, 9);\n    mb = get_bits(&ctx->gb, 5);\n\n    av_assert2(mb < 32);\n    if ((d < 1) || (d > TM2_DELTAS) || (mb < 1)) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"Incorrect delta table: %i deltas x %i bits\\n\", d, mb);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < d; i++) {\n        v = get_bits_long(&ctx->gb, mb);\n        if (v & (1 << (mb - 1)))\n            ctx->deltas[stream_id][i] = v - (1 << mb);\n        else\n            ctx->deltas[stream_id][i] = v;\n    }\n    for (; i < TM2_DELTAS; i++)\n        ctx->deltas[stream_id][i] = 0;\n\n    return 0;\n}", "target": 1}
{"idx": 5236, "func": "static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)\n{\n    AVFrame *src = &srcp->f;\n    int i;\n    int ret = av_frame_ref(dst, src);\n    if (ret < 0)\n        return ret;\n\n    if (!srcp->crop)\n        return 0;\n\n    for (i = 0; i < 3; i++) {\n        int hshift = (i > 0) ? h->chroma_x_shift : 0;\n        int vshift = (i > 0) ? h->chroma_y_shift : 0;\n        int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +\n            (srcp->crop_top  >> vshift) * dst->linesize[i];\n        dst->data[i] += off;\n    }\n    return 0;\n}", "target": 0}
{"idx": 5237, "func": "void av_fast_malloc(void *ptr, unsigned int *size, FF_INTERNALC_MEM_TYPE min_size)\n{\n    void **p = ptr;\n    if (min_size < *size)\n        return;\n    min_size= FFMAX(17*min_size/16 + 32, min_size);\n    av_free(*p);\n    *p = av_malloc(min_size);\n    if (!*p) min_size = 0;\n    *size= min_size;\n}", "target": 1}
{"idx": 5238, "func": "static int webm_dash_manifest_cues(AVFormatContext *s)\n{\n    MatroskaDemuxContext *matroska = s->priv_data;\n    EbmlList *seekhead_list = &matroska->seekhead;\n    MatroskaSeekhead *seekhead = seekhead_list->elem;\n    char *buf;\n    int64_t cues_start = -1, cues_end = -1, before_pos, bandwidth;\n    int i;\n\n    // determine cues start and end positions\n    for (i = 0; i < seekhead_list->nb_elem; i++)\n        if (seekhead[i].id == MATROSKA_ID_CUES)\n            break;\n\n    if (i >= seekhead_list->nb_elem) return -1;\n\n    before_pos = avio_tell(matroska->ctx->pb);\n    cues_start = seekhead[i].pos + matroska->segment_start;\n    if (avio_seek(matroska->ctx->pb, cues_start, SEEK_SET) == cues_start) {\n        // cues_end is computed as cues_start + cues_length + length of the\n        // Cues element ID + EBML length of the Cues element. cues_end is\n        // inclusive and the above sum is reduced by 1.\n        uint64_t cues_length = 0, cues_id = 0, bytes_read = 0;\n        bytes_read += ebml_read_num(matroska, matroska->ctx->pb, 4, &cues_id);\n        bytes_read += ebml_read_length(matroska, matroska->ctx->pb, &cues_length);\n        cues_end = cues_start + cues_length + bytes_read - 1;\n    }\n    avio_seek(matroska->ctx->pb, before_pos, SEEK_SET);\n    if (cues_start == -1 || cues_end == -1) return -1;\n\n    // parse the cues\n    matroska_parse_cues(matroska);\n\n    // cues start\n    av_dict_set_int(&s->streams[0]->metadata, CUES_START, cues_start, 0);\n\n    // cues end\n    av_dict_set_int(&s->streams[0]->metadata, CUES_END, cues_end, 0);\n\n    // bandwidth\n    bandwidth = webm_dash_manifest_compute_bandwidth(s, cues_start);\n    if (bandwidth < 0) return -1;\n    av_dict_set_int(&s->streams[0]->metadata, BANDWIDTH, bandwidth, 0);\n\n    // check if all clusters start with key frames\n    av_dict_set_int(&s->streams[0]->metadata, CLUSTER_KEYFRAME, webm_clusters_start_with_keyframe(s), 0);\n\n    // store cue point timestamps as a comma separated list for checking subsegment alignment in\n    // the muxer. assumes that each timestamp cannot be more than 20 characters long.\n    buf = av_malloc_array(s->streams[0]->nb_index_entries, 20 * sizeof(char));\n    if (!buf) return -1;\n    strcpy(buf, \"\");\n    for (i = 0; i < s->streams[0]->nb_index_entries; i++) {\n        snprintf(buf, (i + 1) * 20 * sizeof(char),\n                 \"%s%\" PRId64, buf, s->streams[0]->index_entries[i].timestamp);\n        if (i != s->streams[0]->nb_index_entries - 1)\n            strncat(buf, \",\", sizeof(char));\n    }\n    av_dict_set(&s->streams[0]->metadata, CUE_TIMESTAMPS, buf, 0);\n    av_free(buf);\n\n    return 0;\n}", "target": 1}
{"idx": 5239, "func": "static void skip_input(DBEContext *s, int nb_words)\n{\n    s->input      += nb_words * s->word_bytes;\n    s->input_size -= nb_words;\n}", "target": 1}
{"idx": 5240, "func": "static int copy_region_enc(uint8_t *sptr, uint8_t *dptr, int dx, int dy,\n                           int h, int w, int stride, uint8_t *pfptr)\n{\n    int i, j;\n    uint8_t *nsptr;\n    uint8_t *npfptr;\n    int diff = 0;\n\n    for (i = dx + h; i > dx; i--) {\n        nsptr  = sptr  + i * stride + dy * 3;\n        npfptr = pfptr + i * stride + dy * 3;\n        for (j = 0; j < w * 3; j++) {\n            diff    |= npfptr[j] ^ nsptr[j];\n            dptr[j]  = nsptr[j];\n        }\n        dptr += w * 3;\n    }\n    if (diff)\n        return 1;\n    return 0;\n}", "target": 1}
{"idx": 5241, "func": "int ASN1_get_object(const unsigned char **pp, long *plength, int *ptag,\n                    int *pclass, long omax)\n{\n    int i, ret;\n    long l;\n    const unsigned char *p = *pp;\n    int tag, xclass, inf;\n    long max = omax;\n\n    if (!max)\n        goto err;\n    ret = (*p & V_ASN1_CONSTRUCTED);\n    xclass = (*p & V_ASN1_PRIVATE);\n    i = *p & V_ASN1_PRIMITIVE_TAG;\n    if (i == V_ASN1_PRIMITIVE_TAG) { /* high-tag */\n        p++;\n        if (--max == 0)\n            goto err;\n        l = 0;\n        while (*p & 0x80) {\n            l <<= 7L;\n            l |= *(p++) & 0x7f;\n            if (--max == 0)\n                goto err;\n            if (l > (INT_MAX >> 7L))\n                goto err;\n        }\n        l <<= 7L;\n        l |= *(p++) & 0x7f;\n        tag = (int)l;\n        if (--max == 0)\n            goto err;\n    } else {\n        tag = i;\n        p++;\n        if (--max == 0)\n            goto err;\n    }\n    *ptag = tag;\n    *pclass = xclass;\n    if (!asn1_get_length(&p, &inf, plength, max))\n        goto err;\n\n    if (inf && !(ret & V_ASN1_CONSTRUCTED))\n        goto err;\n\n    if (*plength > (omax - (p - *pp))) {\n        ASN1err(ASN1_F_ASN1_GET_OBJECT, ASN1_R_TOO_LONG);\n        /*\n         * Set this so that even if things are not long enough the values are\n         * set correctly\n         */\n        ret |= 0x80;\n    }\n    *pp = p;\n    return (ret | inf);\n err:\n    ASN1err(ASN1_F_ASN1_GET_OBJECT, ASN1_R_HEADER_TOO_LONG);\n    return (0x80);\n}", "target": 0}
{"idx": 5242, "func": "int ASN1_object_size(int constructed, int length, int tag)\n\t{\n\tint ret;\n\n\tret=length;\n\tret++;\n\tif (tag >= 31)\n\t\t{\n\t\twhile (tag > 0)\n\t\t\t{\n\t\t\ttag>>=7;\n\t\t\tret++;\n\t\t\t}\n\t\t}\n\tif ((length == 0) && (constructed == 2))\n\t\tret+=2;\n\tret++;\n\tif (length > 127)\n\t\t{\n\t\twhile (length > 0)\n\t\t\t{\n\t\t\tlength>>=8;\n\t\t\tret++;\n\t\t\t}\n\t\t}\n\treturn(ret);\n\t}", "target": 1}
{"idx": 5243, "func": "static const AVOption *av_set_number(void *obj, const char *name, double num, int den, int64_t intnum){\n    const AVOption *o= av_find_opt(obj, name, NULL, 0, 0);\n    void *dst;\n    if(!o || o->offset<=0)\n        return NULL;\n\n    if(o->max*den < num*intnum || o->min*den > num*intnum) {\n        av_log(NULL, AV_LOG_ERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name);\n        return NULL;\n    }\n\n    dst= ((uint8_t*)obj) + o->offset;\n\n    switch(o->type){\n    case FF_OPT_TYPE_FLAGS:\n    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;\n    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;\n    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;\n    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;\n    case FF_OPT_TYPE_RATIONAL:\n        if((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};\n        else                *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);\n        break;\n    default:\n        return NULL;\n    }\n    return o;\n}", "target": 1}
{"idx": 5244, "func": "int rsa_multip_calc_product(RSA *rsa)\n{\n    RSA_PRIME_INFO *pinfo;\n    BIGNUM *p1 = NULL, *p2 = NULL;\n    BN_CTX *ctx = NULL;\n    int i, rv = 0, ex_primes;\n\n    if ((ex_primes = sk_RSA_PRIME_INFO_num(rsa->prime_infos)) <= 0) {\n        /* invalid */\n        goto err;\n    }\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n\n    /* calculate pinfo->pp = p * q for first 'extra' prime */\n    p1 = rsa->p;\n    p2 = rsa->q;\n\n    for (i = 0; i < ex_primes; i++) {\n        pinfo = sk_RSA_PRIME_INFO_value(rsa->prime_infos, i);\n        if (pinfo->pp == NULL) {\n            pinfo->pp = BN_secure_new();\n            if (pinfo->pp == NULL)\n                goto err;\n        }\n        if (!BN_mul(pinfo->pp, p1, p2, ctx))\n            goto err;\n        /* save previous one */\n        p1 = pinfo->pp;\n        p2 = pinfo->r;\n    }\n\n    rv = 1;\n err:\n    BN_CTX_free(ctx);\n    return rv;\n}", "target": 1}
{"idx": 5245, "func": "static void FUNC(transquant_bypass4x4)(uint8_t *_dst, int16_t *coeffs,\n                                       ptrdiff_t stride)\n{\n    int x, y;\n    pixel *dst = (pixel *)_dst;\n\n    stride /= sizeof(pixel);\n\n    for (y = 0; y < 4; y++) {\n        for (x = 0; x < 4; x++) {\n            dst[x] += *coeffs;\n            coeffs++;\n        }\n        dst += stride;\n    }\n}", "target": 1}
{"idx": 5246, "func": "AP_DECLARE(apr_status_t) ap_filter_setaside_brigade(ap_filter_t *f,\n        apr_bucket_brigade *bb)\n{\n    int loglevel = ap_get_conn_module_loglevel(f->c, APLOG_MODULE_INDEX);\n\n    if (loglevel >= APLOG_TRACE6) {\n        ap_log_cerror(\n            APLOG_MARK, APLOG_TRACE6, 0, f->c,\n            \"setaside %s brigade to %s brigade in '%s' output filter\",\n            (APR_BRIGADE_EMPTY(bb) ? \"empty\" : \"full\"),\n            (!f->bb || APR_BRIGADE_EMPTY(f->bb) ? \"empty\" : \"full\"), f->frec->name);\n    }\n\n    if (!APR_BRIGADE_EMPTY(bb)) {\n        /*\n         * Set aside the brigade bb within f->bb.\n         */\n        ap_filter_prepare_brigade(f, NULL);\n\n        /* decide what pool we setaside to, request pool or deferred pool? */\n        if (f->r) {\n            apr_bucket *e;\n            for (e = APR_BRIGADE_FIRST(bb); e != APR_BRIGADE_SENTINEL(bb); e =\n                    APR_BUCKET_NEXT(e)) {\n                if (APR_BUCKET_IS_TRANSIENT(e)) {\n                    int rv = apr_bucket_setaside(e, f->r->pool);\n                    if (rv != APR_SUCCESS) {\n                        return rv;\n                    }\n                }\n            }\n            APR_BRIGADE_CONCAT(f->bb, bb);\n        }\n        else {\n            if (!f->deferred_pool) {\n                apr_pool_create(&f->deferred_pool, f->c->pool);\n                apr_pool_tag(f->deferred_pool, \"deferred_pool\");\n            }\n            return ap_save_brigade(f, &f->bb, &bb, f->deferred_pool);\n        }\n\n    }\n    else if (f->deferred_pool) {\n        /*\n         * There are no more requests in the pipeline. We can just clear the\n         * pool.\n         */\n        apr_brigade_cleanup(f->bb);\n        apr_pool_clear(f->deferred_pool);\n    }\n    return APR_SUCCESS;\n}", "target": 0}
{"idx": 5247, "func": "static ngx_int_t\nngx_event_pipe_write_to_downstream(ngx_event_pipe_t *p)\n{\n    u_char            *prev;\n    size_t             bsize;\n    ngx_int_t          rc;\n    ngx_uint_t         flush, flushed, prev_last_shadow;\n    ngx_chain_t       *out, **ll, *cl;\n    ngx_connection_t  *downstream;\n\n    downstream = p->downstream;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0,\n                   \"pipe write downstream: %d\", downstream->write->ready);\n\n    flushed = 0;\n\n    for ( ;; ) {\n        if (p->downstream_error) {\n            return ngx_event_pipe_drain_chains(p);\n        }\n\n        if (p->upstream_eof || p->upstream_error || p->upstream_done) {\n\n            /* pass the p->out and p->in chains to the output filter */\n\n            for (cl = p->busy; cl; cl = cl->next) {\n                cl->buf->recycled = 0;\n            }\n\n            if (p->out) {\n                ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p->log, 0,\n                               \"pipe write downstream flush out\");\n\n                for (cl = p->out; cl; cl = cl->next) {\n                    cl->buf->recycled = 0;\n                }\n\n                rc = p->output_filter(p->output_ctx, p->out);\n\n                if (rc == NGX_ERROR) {\n                    p->downstream_error = 1;\n                    return ngx_event_pipe_drain_chains(p);\n                }\n\n                p->out = NULL;\n            }\n\n            if (p->in) {\n                ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p->log, 0,\n                               \"pipe write downstream flush in\");\n\n                for (cl = p->in; cl; cl = cl->next) {\n                    cl->buf->recycled = 0;\n                }\n\n                rc = p->output_filter(p->output_ctx, p->in);\n\n                if (rc == NGX_ERROR) {\n                    p->downstream_error = 1;\n                    return ngx_event_pipe_drain_chains(p);\n                }\n\n                p->in = NULL;\n            }\n\n            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p->log, 0,\n                           \"pipe write downstream done\");\n\n            /* TODO: free unused bufs */\n\n            p->downstream_done = 1;\n            break;\n        }\n\n        if (downstream->data != p->output_ctx\n            || !downstream->write->ready\n            || downstream->write->delayed)\n        {\n            break;\n        }\n\n        /* bsize is the size of the busy recycled bufs */\n\n        prev = NULL;\n        bsize = 0;\n\n        for (cl = p->busy; cl; cl = cl->next) {\n\n            if (cl->buf->recycled) {\n                if (prev == cl->buf->start) {\n                    continue;\n                }\n\n                bsize += cl->buf->end - cl->buf->start;\n                prev = cl->buf->start;\n            }\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p->log, 0,\n                       \"pipe write busy: %uz\", bsize);\n\n        out = NULL;\n\n        if (bsize >= (size_t) p->busy_size) {\n            flush = 1;\n            goto flush;\n        }\n\n        flush = 0;\n        ll = NULL;\n        prev_last_shadow = 1;\n\n        for ( ;; ) {\n            if (p->out) {\n                cl = p->out;\n\n                if (cl->buf->recycled) {\n                    ngx_log_error(NGX_LOG_ALERT, p->log, 0,\n                                  \"recycled buffer in pipe out chain\");\n                }\n\n                p->out = p->out->next;\n\n            } else if (!p->cacheable && p->in) {\n                cl = p->in;\n\n                ngx_log_debug3(NGX_LOG_DEBUG_EVENT, p->log, 0,\n                               \"pipe write buf ls:%d %p %z\",\n                               cl->buf->last_shadow,\n                               cl->buf->pos,\n                               cl->buf->last - cl->buf->pos);\n\n                if (cl->buf->recycled && prev_last_shadow) {\n                    if (bsize + cl->buf->end - cl->buf->start > p->busy_size) {\n                        flush = 1;\n                        break;\n                    }\n\n                    bsize += cl->buf->end - cl->buf->start;\n                }\n\n                prev_last_shadow = cl->buf->last_shadow;\n\n                p->in = p->in->next;\n\n            } else {\n                break;\n            }\n\n            cl->next = NULL;\n\n            if (out) {\n                *ll = cl;\n            } else {\n                out = cl;\n            }\n            ll = &cl->next;\n        }\n\n    flush:\n\n        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, p->log, 0,\n                       \"pipe write: out:%p, f:%d\", out, flush);\n\n        if (out == NULL) {\n\n            if (!flush) {\n                break;\n            }\n\n            /* a workaround for AIO */\n            if (flushed++ > 10) {\n                return NGX_BUSY;\n            }\n        }\n\n        rc = p->output_filter(p->output_ctx, out);\n\n        ngx_chain_update_chains(p->pool, &p->free, &p->busy, &out, p->tag);\n\n        if (rc == NGX_ERROR) {\n            p->downstream_error = 1;\n            return ngx_event_pipe_drain_chains(p);\n        }\n\n        for (cl = p->free; cl; cl = cl->next) {\n\n            if (cl->buf->temp_file) {\n                if (p->cacheable || !p->cyclic_temp_file) {\n                    continue;\n                }\n\n                /* reset p->temp_offset if all bufs had been sent */\n\n                if (cl->buf->file_last == p->temp_file->offset) {\n                    p->temp_file->offset = 0;\n                }\n            }\n\n            /* TODO: free buf if p->free_bufs && upstream done */\n\n            /* add the free shadow raw buf to p->free_raw_bufs */\n\n            if (cl->buf->last_shadow) {\n                if (ngx_event_pipe_add_free_buf(p, cl->buf->shadow) != NGX_OK) {\n                    return NGX_ABORT;\n                }\n\n                cl->buf->last_shadow = 0;\n            }\n\n            cl->buf->shadow = NULL;\n        }\n    }\n\n    return NGX_OK;\n}", "target": 0}
{"idx": 5248, "func": "int SMIME_crlf_copy(BIO *in, BIO *out, int flags)\n{\n\tchar eol;\n\tint len;\n\tchar linebuf[MAX_SMLEN];\n\tif(flags & PKCS7_BINARY) {\n\t\twhile((len = BIO_read(in, linebuf, MAX_SMLEN)) > 0)\n\t\t\t\t\t\tBIO_write(out, linebuf, len);\n\t\treturn 1;\n\t}\n\tif(flags & PKCS7_TEXT)\n\t\tBIO_printf(out, \"Content-Type: text/plain\\r\\n\\r\\n\");\n\twhile ((len = BIO_gets(in, linebuf, MAX_SMLEN)) > 0) {\n\t\teol = strip_eol(linebuf, &len);\n\t\tif (len)\n\t\t\tBIO_write(out, linebuf, len);\n\t\tif(eol) BIO_write(out, \"\\r\\n\", 2);\n\t}\n\treturn 1;\n}", "target": 0}
{"idx": 5249, "func": "BN_ULONG bn_add_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n        {\n\tBN_ULONG c,l,t;\n\n\tassert(n >= 0);\n\tif (n <= 0) return((BN_ULONG)0);\n\n\tc=0;\n\tfor (;;)\n\t\t{\n\t\tt=a[0];\n\t\tt=(t+c)&BN_MASK2;\n\t\tc=(t < c);\n\t\tl=(t+b[0])&BN_MASK2;\n\t\tc+=(l < t);\n\t\tr[0]=l;\n\t\tif (--n <= 0) break;\n\n\t\tt=a[1];\n\t\tt=(t+c)&BN_MASK2;\n\t\tc=(t < c);\n\t\tl=(t+b[1])&BN_MASK2;\n\t\tc+=(l < t);\n\t\tr[1]=l;\n\t\tif (--n <= 0) break;\n\n\t\tt=a[2];\n\t\tt=(t+c)&BN_MASK2;\n\t\tc=(t < c);\n\t\tl=(t+b[2])&BN_MASK2;\n\t\tc+=(l < t);\n\t\tr[2]=l;\n\t\tif (--n <= 0) break;\n\n\t\tt=a[3];\n\t\tt=(t+c)&BN_MASK2;\n\t\tc=(t < c);\n\t\tl=(t+b[3])&BN_MASK2;\n\t\tc+=(l < t);\n\t\tr[3]=l;\n\t\tif (--n <= 0) break;\n\n\t\ta+=4;\n\t\tb+=4;\n\t\tr+=4;\n\t\t}\n\treturn((BN_ULONG)c);\n\t}", "target": 1}
{"idx": 5250, "func": "const char *get_gost_engine_param(int param) \n\t{\n\tchar *tmp;\n\tif (param <0 || param >GOST_PARAM_MAX) return NULL;\n\tif (gost_params[param]!=NULL) \n\t\t{\n\t\treturn gost_params[param];\n\t\t}\n\ttmp = getenv(gost_envnames[param]);\n\tif (tmp) \n\t\t{\n\t\tif (gost_params[param]) OPENSSL_free(gost_params[param]);\n\t\tgost_params[param] = BUF_strdup(tmp);\n\t\treturn gost_params[param];\n\t\t}\t\n\treturn NULL;\n\t}", "target": 0}
{"idx": 5251, "func": "long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)\n\t{\n\tunsigned char *p;\n\tunsigned long l;\n\tlong n;\n\tint i,al;\n\n\tif (s->s3->tmp.reuse_message)\n\t\t{\n\t\ts->s3->tmp.reuse_message=0;\n\t\tif ((mt >= 0) && (s->s3->tmp.message_type != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t*ok=1;\n\t\treturn((int)s->s3->tmp.message_size);\n\t\t}\n\n\tp=(unsigned char *)s->init_buf->data;\n\n\tif (s->state == st1) /* s->init_num < 4 */\n\t\t{\n\t\tint skip_message;\n\n\t\tdo\n\t\t\t{\n\t\t\twhile (s->init_num < 4)\n\t\t\t\t{\n\t\t\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],\n\t\t\t\t\t4 - s->init_num);\n\t\t\t\tif (i <= 0)\n\t\t\t\t\t{\n\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\t*ok = 0;\n\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\ts->init_num+=i;\n\t\t\t\t}\n\t\t\t\n\t\t\tskip_message = 0;\n\t\t\tif (!s->server)\n\t\t\t\tif (p[0] == SSL3_MT_HELLO_REQUEST)\n\t\t\t\t\t/* The server may always send 'Hello Request' messages --\n\t\t\t\t\t * we are doing a handshake anyway now, so ignore them\n\t\t\t\t\t * if their format is correct. Does not count for\n\t\t\t\t\t * 'Finished' MAC. */\n\t\t\t\t\tif (p[1] == 0 && p[2] == 0 &&p[3] == 0)\n\t\t\t\t\t\tskip_message = 1;\n\t\t\t}\n\t\twhile (skip_message);\n\n\t\t/* s->init_num == 4 */\n\n\t\tif ((mt >= 0) && (*p != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) &&\n\t\t\t\t\t(st1 == SSL3_ST_SR_CERT_A) &&\n\t\t\t\t\t(stn == SSL3_ST_SR_CERT_B))\n\t\t\t{\n\t\t\t/* At this point we have got an MS SGC second client\n\t\t\t * hello (maybe we should always allow the client to\n\t\t\t * start a new handshake?). We need to restart the mac.\n\t\t\t */\n\t\t\tssl3_init_finished_mac(s);\n\t\t\t}\n\n\t\tssl3_finish_mac(s, (unsigned char *)s->init_buf->data, 4);\n\t\t\t\n\t\ts->s3->tmp.message_type= *(p++);\n\n\t\tn2l3(p,l);\n\t\tif (l > (unsigned long)max)\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (l && !BUF_MEM_grow(s->init_buf,(int)l))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->s3->tmp.message_size=l;\n\t\ts->state=stn;\n\n\t\ts->init_num=0;\n\t\t}\n\n\t/* next state (stn) */\n\tp=(unsigned char *)s->init_buf->data;\n\tn=s->s3->tmp.message_size;\n\twhile (n > 0)\n\t\t{\n\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n);\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\ts->rwstate=SSL_READING;\n\t\t\t*ok = 0;\n\t\t\treturn i;\n\t\t\t}\n\t\ts->init_num += i;\n\t\tn -= i;\n\t\t}\n\tssl3_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num);\n\t*ok=1;\n\treturn s->init_num;\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\t*ok=0;\n\treturn(-1);\n\t}", "target": 0}
{"idx": 5252, "func": "static int ftp_passive_mode(FTPContext *s)\n{\n    char *res = NULL, *start, *end;\n    int i;\n    const char *command = \"PASV\\r\\n\";\n    const int pasv_codes[] = {227, 0};\n\n    if (!ftp_send_command(s, command, pasv_codes, &res))\n        goto fail;\n\n    start = NULL;\n    for (i = 0; i < strlen(res); ++i) {\n        if (res[i] == '(') {\n            start = res + i + 1;\n        } else if (res[i] == ')') {\n            end = res + i;\n            break;\n        }\n    }\n    if (!start || !end)\n        goto fail;\n\n    *end  = '\\0';\n    /* skip ip */\n    if (!av_strtok(start, \",\", &end)) goto fail;\n    if (!av_strtok(end, \",\", &end)) goto fail;\n    if (!av_strtok(end, \",\", &end)) goto fail;\n    if (!av_strtok(end, \",\", &end)) goto fail;\n\n    /* parse port number */\n    start = av_strtok(end, \",\", &end);\n    if (!start) goto fail;\n    s->server_data_port = atoi(start) * 256;\n    start = av_strtok(end, \",\", &end);\n    if (!start) goto fail;\n    s->server_data_port += atoi(start);\n    av_dlog(s, \"Server data port: %d\\n\", s->server_data_port);\n\n    av_free(res);\n    return 0;\n\n  fail:\n    av_free(res);\n    s->server_data_port = -1;\n    return AVERROR(EIO);\n}", "target": 1}
{"idx": 5253, "func": "static int ea_read_packet(AVFormatContext *s,\n                          AVPacket *pkt)\n{\n    EaDemuxContext *ea = s->priv_data;\n    ByteIOContext *pb = s->pb;\n    int ret = 0;\n    int packet_read = 0;\n    unsigned int chunk_type, chunk_size;\n    int key = 0;\n    int av_uninit(num_samples);\n\n    while (!packet_read) {\n        chunk_type = get_le32(pb);\n        chunk_size = (ea->big_endian ? get_be32(pb) : get_le32(pb)) - 8;\n\n        switch (chunk_type) {\n        /* audio data */\n        case ISNh_TAG:\n            /* header chunk also contains data; skip over the header portion*/\n            url_fskip(pb, 32);\n            chunk_size -= 32;\n        case ISNd_TAG:\n        case SCDl_TAG:\n        case SNDC_TAG:\n        case SDEN_TAG:\n            if (!ea->audio_codec) {\n                url_fskip(pb, chunk_size);\n                break;\n            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||\n                       ea->audio_codec == CODEC_ID_MP3) {\n                num_samples = get_le32(pb);\n                url_fskip(pb, 8);\n                chunk_size -= 12;\n            }\n            ret = av_get_packet(pb, pkt, chunk_size);\n            if (ret < 0)\n                return ret;\n                    pkt->stream_index = ea->audio_stream_index;\n                    pkt->pts = 90000;\n                    pkt->pts *= ea->audio_frame_counter;\n                    pkt->pts /= ea->sample_rate;\n\n                    switch (ea->audio_codec) {\n                    case CODEC_ID_ADPCM_EA:\n                    /* 2 samples/byte, 1 or 2 samples per frame depending\n                     * on stereo; chunk also has 12-byte header */\n                    ea->audio_frame_counter += ((chunk_size - 12) * 2) /\n                        ea->num_channels;\n                        break;\n                    case CODEC_ID_PCM_S16LE_PLANAR:\n                    case CODEC_ID_MP3:\n                        ea->audio_frame_counter += num_samples;\n                        break;\n                    default:\n                        ea->audio_frame_counter += chunk_size /\n                            (ea->bytes * ea->num_channels);\n                    }\n\n            packet_read = 1;\n            break;\n\n        /* ending tag */\n        case 0:\n        case ISNe_TAG:\n        case SCEl_TAG:\n        case SEND_TAG:\n        case SEEN_TAG:\n            ret = AVERROR(EIO);\n            packet_read = 1;\n            break;\n\n        case MVIh_TAG:\n        case kVGT_TAG:\n        case pQGT_TAG:\n        case TGQs_TAG:\n            key = PKT_FLAG_KEY;\n        case MVIf_TAG:\n        case fVGT_TAG:\n            url_fseek(pb, -8, SEEK_CUR);     // include chunk preamble\n            chunk_size += 8;\n            goto get_video_packet;\n\n        case mTCD_TAG:\n            url_fseek(pb, 8, SEEK_CUR);  // skip ea dct header\n            chunk_size -= 8;\n            goto get_video_packet;\n\n        case MV0K_TAG:\n        case MPCh_TAG:\n        case pIQT_TAG:\n            key = PKT_FLAG_KEY;\n        case MV0F_TAG:\nget_video_packet:\n            ret = av_get_packet(pb, pkt, chunk_size);\n            if (ret < 0)\n                return ret;\n                pkt->stream_index = ea->video_stream_index;\n                pkt->flags |= key;\n            packet_read = 1;\n            break;\n\n        default:\n            url_fseek(pb, chunk_size, SEEK_CUR);\n            break;\n        }\n    }\n\n    return ret;\n}", "target": 0}
{"idx": 5254, "func": "static int get_nb_samples(AVCodecContext *avctx, const uint8_t *buf,\n                          int buf_size, int *coded_samples)\n{\n    ADPCMDecodeContext *s = avctx->priv_data;\n    int nb_samples        = 0;\n    int ch                = avctx->channels;\n    int has_coded_samples = 0;\n    int header_size;\n\n    *coded_samples = 0;\n\n    switch (avctx->codec->id) {\n    /* constant, only check buf_size */\n    case CODEC_ID_ADPCM_EA_XAS:\n        if (buf_size < 76 * ch)\n            return 0;\n        nb_samples = 128;\n        break;\n    case CODEC_ID_ADPCM_IMA_QT:\n        if (buf_size < 34 * ch)\n            return 0;\n        nb_samples = 64;\n        break;\n    /* simple 4-bit adpcm */\n    case CODEC_ID_ADPCM_CT:\n    case CODEC_ID_ADPCM_IMA_EA_SEAD:\n    case CODEC_ID_ADPCM_IMA_WS:\n    case CODEC_ID_ADPCM_YAMAHA:\n        nb_samples = buf_size * 2 / ch;\n        break;\n    }\n    if (nb_samples)\n        return nb_samples;\n\n    /* simple 4-bit adpcm, with header */\n    header_size = 0;\n    switch (avctx->codec->id) {\n        case CODEC_ID_ADPCM_4XM:\n        case CODEC_ID_ADPCM_IMA_ISS:     header_size = 4 * ch;      break;\n        case CODEC_ID_ADPCM_IMA_AMV:     header_size = 8;           break;\n        case CODEC_ID_ADPCM_IMA_SMJPEG:  header_size = 4;           break;\n    }\n    if (header_size > 0)\n        return (buf_size - header_size) * 2 / ch;\n\n    /* more complex formats */\n    switch (avctx->codec->id) {\n    case CODEC_ID_ADPCM_EA:\n        has_coded_samples = 1;\n        if (buf_size < 4)\n            return 0;\n        *coded_samples  = AV_RL32(buf);\n        *coded_samples -= *coded_samples % 28;\n        nb_samples      = (buf_size - 12) / 30 * 28;\n        break;\n    case CODEC_ID_ADPCM_IMA_EA_EACS:\n        has_coded_samples = 1;\n        if (buf_size < 4)\n            return 0;\n        *coded_samples = AV_RL32(buf);\n        nb_samples     = (buf_size - (4 + 8 * ch)) * 2 / ch;\n        break;\n    case CODEC_ID_ADPCM_EA_MAXIS_XA:\n        nb_samples = ((buf_size - ch) / (2 * ch)) * 2 * ch;\n        break;\n    case CODEC_ID_ADPCM_EA_R1:\n    case CODEC_ID_ADPCM_EA_R2:\n    case CODEC_ID_ADPCM_EA_R3:\n        /* maximum number of samples */\n        /* has internal offsets and a per-frame switch to signal raw 16-bit */\n        has_coded_samples = 1;\n        if (buf_size < 4)\n            return 0;\n        switch (avctx->codec->id) {\n        case CODEC_ID_ADPCM_EA_R1:\n            header_size    = 4 + 9 * ch;\n            *coded_samples = AV_RL32(buf);\n            break;\n        case CODEC_ID_ADPCM_EA_R2:\n            header_size    = 4 + 5 * ch;\n            *coded_samples = AV_RL32(buf);\n            break;\n        case CODEC_ID_ADPCM_EA_R3:\n            header_size    = 4 + 5 * ch;\n            *coded_samples = AV_RB32(buf);\n            break;\n        }\n        *coded_samples -= *coded_samples % 28;\n        nb_samples      = (buf_size - header_size) * 2 / ch;\n        nb_samples     -= nb_samples % 28;\n        break;\n    case CODEC_ID_ADPCM_IMA_DK3:\n        if (avctx->block_align > 0)\n            buf_size = FFMIN(buf_size, avctx->block_align);\n        nb_samples = ((buf_size - 16) * 8 / 3) / ch;\n        break;\n    case CODEC_ID_ADPCM_IMA_DK4:\n        nb_samples = 1 + (buf_size - 4 * ch) * 2 / ch;\n        break;\n    case CODEC_ID_ADPCM_IMA_WAV:\n        if (avctx->block_align > 0)\n            buf_size = FFMIN(buf_size, avctx->block_align);\n        nb_samples = 1 + (buf_size - 4 * ch) / (4 * ch) * 8;\n        break;\n    case CODEC_ID_ADPCM_MS:\n        if (avctx->block_align > 0)\n            buf_size = FFMIN(buf_size, avctx->block_align);\n        nb_samples = 2 + (buf_size - 7 * ch) * 2 / ch;\n        break;\n    case CODEC_ID_ADPCM_SBPRO_2:\n    case CODEC_ID_ADPCM_SBPRO_3:\n    case CODEC_ID_ADPCM_SBPRO_4:\n    {\n        int samples_per_byte;\n        switch (avctx->codec->id) {\n        case CODEC_ID_ADPCM_SBPRO_2: samples_per_byte = 4; break;\n        case CODEC_ID_ADPCM_SBPRO_3: samples_per_byte = 3; break;\n        case CODEC_ID_ADPCM_SBPRO_4: samples_per_byte = 2; break;\n        }\n        if (!s->status[0].step_index) {\n            nb_samples++;\n            buf_size -= ch;\n        }\n        nb_samples += buf_size * samples_per_byte / ch;\n        break;\n    }\n    case CODEC_ID_ADPCM_SWF:\n    {\n        int buf_bits       = buf_size * 8 - 2;\n        int nbits          = (buf[0] >> 6) + 2;\n        int block_hdr_size = 22 * ch;\n        int block_size     = block_hdr_size + nbits * ch * 4095;\n        int nblocks        = buf_bits / block_size;\n        int bits_left      = buf_bits - nblocks * block_size;\n        nb_samples         = nblocks * 4096;\n        if (bits_left >= block_hdr_size)\n            nb_samples += 1 + (bits_left - block_hdr_size) / (nbits * ch);\n        break;\n    }\n    case CODEC_ID_ADPCM_THP:\n        has_coded_samples = 1;\n        if (buf_size < 8)\n            return 0;\n        *coded_samples  = AV_RB32(&buf[4]);\n        *coded_samples -= *coded_samples % 14;\n        nb_samples      = (buf_size - 80) / (8 * ch) * 14;\n        break;\n    case CODEC_ID_ADPCM_XA:\n        nb_samples = (buf_size / 128) * 224 / ch;\n        break;\n    }\n\n    /* validate coded sample count */\n    if (has_coded_samples && (*coded_samples <= 0 || *coded_samples > nb_samples))\n        return AVERROR_INVALIDDATA;\n\n    return nb_samples;\n}", "target": 1}
{"idx": 5255, "func": "static inline void apply_8x8(MpegEncContext *s,\n                             uint8_t *dest_y,\n                             uint8_t *dest_cb,\n                             uint8_t *dest_cr,\n                             int dir,\n                             uint8_t **ref_picture,\n                             qpel_mc_func (*qpix_op)[16],\n                             op_pixels_func (*pix_op)[4])\n{\n    int dxy, mx, my, src_x, src_y;\n    int i;\n    int mb_x = s->mb_x;\n    int mb_y = s->mb_y;\n    uint8_t *ptr, *dest;\n\n    mx = 0;\n    my = 0;\n    if (s->quarter_sample) {\n        for (i = 0; i < 4; i++) {\n            int motion_x = s->mv[dir][i][0];\n            int motion_y = s->mv[dir][i][1];\n\n            dxy   = ((motion_y & 3) << 2) | (motion_x & 3);\n            src_x = mb_x * 16 + (motion_x >> 2) + (i & 1) * 8;\n            src_y = mb_y * 16 + (motion_y >> 2) + (i >> 1) * 8;\n\n            /* WARNING: do no forget half pels */\n            src_x = av_clip(src_x, -16, s->width);\n            if (src_x == s->width)\n                dxy &= ~3;\n            src_y = av_clip(src_y, -16, s->height);\n            if (src_y == s->height)\n                dxy &= ~12;\n\n            ptr = ref_picture[0] + (src_y * s->linesize) + (src_x);\n            if ((unsigned)src_x >= FFMAX(s->h_edge_pos - (motion_x & 3) - 7, 0) ||\n                (unsigned)src_y >= FFMAX(s->v_edge_pos - (motion_y & 3) - 7, 0)) {\n                s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr,\n                                         s->linesize, s->linesize,\n                                         9, 9,\n                                         src_x, src_y,\n                                         s->h_edge_pos,\n                                         s->v_edge_pos);\n                ptr = s->edge_emu_buffer;\n            }\n            dest = dest_y + ((i & 1) * 8) + (i >> 1) * 8 * s->linesize;\n            qpix_op[1][dxy](dest, ptr, s->linesize);\n\n            mx += s->mv[dir][i][0] / 2;\n            my += s->mv[dir][i][1] / 2;\n        }\n    } else {\n        for (i = 0; i < 4; i++) {\n            hpel_motion(s,\n                        dest_y + ((i & 1) * 8) + (i >> 1) * 8 * s->linesize,\n                        ref_picture[0],\n                        mb_x * 16 + (i & 1) * 8,\n                        mb_y * 16 + (i >> 1) * 8,\n                        pix_op[1],\n                        s->mv[dir][i][0],\n                        s->mv[dir][i][1]);\n\n            mx += s->mv[dir][i][0];\n            my += s->mv[dir][i][1];\n        }\n    }\n\n    if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY))\n        chroma_4mv_motion(s, dest_cb, dest_cr,\n                          ref_picture, pix_op[1], mx, my);\n}", "target": 0}
{"idx": 5256, "func": "static av_cold int cinepak_encode_init(AVCodecContext *avctx)\n{\n    CinepakEncContext *s = avctx->priv_data;\n    int x, mb_count, strip_buf_size, frame_buf_size;\n\n    if (avctx->width & 3 || avctx->height & 3) {\n        av_log(avctx, AV_LOG_ERROR, \"width and height must be multiples of four (got %ix%i)\\n\",\n                avctx->width, avctx->height);\n        return AVERROR(EINVAL);\n    }\n\n    if (!(s->codebook_input = av_malloc(sizeof(int) * (avctx->pix_fmt == AV_PIX_FMT_YUV420P ? 6 : 4) * (avctx->width * avctx->height) >> 2)))\n        return AVERROR(ENOMEM);\n\n    if (!(s->codebook_closest = av_malloc(sizeof(int) * (avctx->width * avctx->height) >> 2)))\n        goto enomem;\n\n    for(x = 0; x < 3; x++)\n        if(!(s->pict_bufs[x] = av_malloc((avctx->pix_fmt == AV_PIX_FMT_YUV420P ? 6 : 4) * (avctx->width * avctx->height) >> 2)))\n            goto enomem;\n\n    mb_count = avctx->width * avctx->height / MB_AREA;\n\n    //the largest possible chunk is 0x31 with all MBs encoded in V4 mode, which is 34 bits per MB\n    strip_buf_size = STRIP_HEADER_SIZE + 3 * CHUNK_HEADER_SIZE + 2 * VECTOR_MAX * CODEBOOK_MAX + 4 * (mb_count + (mb_count + 15) / 16);\n\n    frame_buf_size = CVID_HEADER_SIZE + MAX_STRIPS * strip_buf_size;\n\n    if (!(s->strip_buf = av_malloc(strip_buf_size)))\n        goto enomem;\n\n    if (!(s->frame_buf = av_malloc(frame_buf_size)))\n        goto enomem;\n\n    if (!(s->mb = av_malloc(mb_count*sizeof(mb_info))))\n        goto enomem;\n\n#ifdef CINEPAKENC_DEBUG\n    if (!(s->best_mb = av_malloc(mb_count*sizeof(mb_info))))\n        goto enomem;\n#endif\n\n    av_lfg_init(&s->randctx, 1);\n    s->avctx = avctx;\n    s->w = avctx->width;\n    s->h = avctx->height;\n    s->curframe = 0;\n    s->keyint = avctx->keyint_min;\n    s->pix_fmt = avctx->pix_fmt;\n\n    //set up AVFrames\n    s->last_frame.data[0]        = s->pict_bufs[0];\n    s->last_frame.linesize[0]    = s->w;\n    s->best_frame.data[0]        = s->pict_bufs[1];\n    s->best_frame.linesize[0]    = s->w;\n    s->scratch_frame.data[0]     = s->pict_bufs[2];\n    s->scratch_frame.linesize[0] = s->w;\n\n    if(s->pix_fmt == AV_PIX_FMT_YUV420P) {\n        s->last_frame.data[1]        = s->last_frame.data[0] + s->w * s->h;\n        s->last_frame.data[2]        = s->last_frame.data[1] + ((s->w * s->h) >> 2);\n        s->last_frame.linesize[1]    = s->last_frame.linesize[2] = s->w >> 1;\n\n        s->best_frame.data[1]        = s->best_frame.data[0] + s->w * s->h;\n        s->best_frame.data[2]        = s->best_frame.data[1] + ((s->w * s->h) >> 2);\n        s->best_frame.linesize[1]    = s->best_frame.linesize[2] = s->w >> 1;\n\n        s->scratch_frame.data[1]     = s->scratch_frame.data[0] + s->w * s->h;\n        s->scratch_frame.data[2]     = s->scratch_frame.data[1] + ((s->w * s->h) >> 2);\n        s->scratch_frame.linesize[1] = s->scratch_frame.linesize[2] = s->w >> 1;\n    }\n\n    s->num_v1_mode = s->num_v4_mode = s->num_mc_mode = s->num_v1_encs = s->num_v4_encs = s->num_skips = 0;\n\n    return 0;\n\nenomem:\n    av_free(s->codebook_input);\n    av_free(s->codebook_closest);\n    av_free(s->strip_buf);\n    av_free(s->frame_buf);\n    av_free(s->mb);\n#ifdef CINEPAKENC_DEBUG\n    av_free(s->best_mb);\n#endif\n\n    for(x = 0; x < 3; x++)\n        av_free(s->pict_bufs[x]);\n\n    return AVERROR(ENOMEM);\n}", "target": 1}
{"idx": 5257, "func": "static int synth_superframe(AVCodecContext *ctx,\n                            float *samples, int *data_size)\n{\n    WMAVoiceContext *s = ctx->priv_data;\n    GetBitContext *gb = &s->gb, s_gb;\n    int n, res, out_size, n_samples = 480;\n    double lsps[MAX_FRAMES][MAX_LSPS];\n    const double *mean_lsf = s->lsps == 16 ?\n        wmavoice_mean_lsf16[s->lsp_def_mode] : wmavoice_mean_lsf10[s->lsp_def_mode];\n    float excitation[MAX_SIGNAL_HISTORY + MAX_SFRAMESIZE + 12];\n    float synth[MAX_LSPS + MAX_SFRAMESIZE];\n\n    memcpy(synth,      s->synth_history,\n           s->lsps             * sizeof(*synth));\n    memcpy(excitation, s->excitation_history,\n           s->history_nsamples * sizeof(*excitation));\n\n    if (s->sframe_cache_size > 0) {\n        gb = &s_gb;\n        init_get_bits(gb, s->sframe_cache, s->sframe_cache_size);\n        s->sframe_cache_size = 0;\n    }\n\n    if ((res = check_bits_for_superframe(gb, s)) == 1) {\n        *data_size = 0;\n        return 1;\n    }\n\n    /* First bit is speech/music bit, it differentiates between WMAVoice\n     * speech samples (the actual codec) and WMAVoice music samples, which\n     * are really WMAPro-in-WMAVoice-superframes. I've never seen those in\n     * the wild yet. */\n    if (!get_bits1(gb)) {\n        av_log_missing_feature(ctx, \"WMAPro-in-WMAVoice support\", 1);\n        return -1;\n    }\n\n    /* (optional) nr. of samples in superframe; always <= 480 and >= 0 */\n    if (get_bits1(gb)) {\n        if ((n_samples = get_bits(gb, 12)) > 480) {\n            av_log(ctx, AV_LOG_ERROR,\n                   \"Superframe encodes >480 samples (%d), not allowed\\n\",\n                   n_samples);\n            return -1;\n        }\n    }\n    /* Parse LSPs, if global for the superframe (can also be per-frame). */\n    if (s->has_residual_lsps) {\n        double prev_lsps[MAX_LSPS], a1[MAX_LSPS * 2], a2[MAX_LSPS * 2];\n\n        for (n = 0; n < s->lsps; n++)\n            prev_lsps[n] = s->prev_lsps[n] - mean_lsf[n];\n\n        if (s->lsps == 10) {\n            dequant_lsp10r(gb, lsps[2], prev_lsps, a1, a2, s->lsp_q_mode);\n        } else /* s->lsps == 16 */\n            dequant_lsp16r(gb, lsps[2], prev_lsps, a1, a2, s->lsp_q_mode);\n\n        for (n = 0; n < s->lsps; n++) {\n            lsps[0][n]  = mean_lsf[n] + (a1[n]           - a2[n * 2]);\n            lsps[1][n]  = mean_lsf[n] + (a1[s->lsps + n] - a2[n * 2 + 1]);\n            lsps[2][n] += mean_lsf[n];\n        }\n        for (n = 0; n < 3; n++)\n            stabilize_lsps(lsps[n], s->lsps);\n    }\n\n    out_size = n_samples * av_get_bytes_per_sample(ctx->sample_fmt);\n    if (*data_size < out_size) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"Output buffer too small (%d given - %zu needed)\\n\",\n               *data_size, out_size);\n        return -1;\n    }\n\n    /* Parse frames, optionally preceeded by per-frame (independent) LSPs. */\n    for (n = 0; n < 3; n++) {\n        if (!s->has_residual_lsps) {\n            int m;\n\n            if (s->lsps == 10) {\n                dequant_lsp10i(gb, lsps[n]);\n            } else /* s->lsps == 16 */\n                dequant_lsp16i(gb, lsps[n]);\n\n            for (m = 0; m < s->lsps; m++)\n                lsps[n][m] += mean_lsf[m];\n            stabilize_lsps(lsps[n], s->lsps);\n        }\n\n        if ((res = synth_frame(ctx, gb, n,\n                               &samples[n * MAX_FRAMESIZE],\n                               lsps[n], n == 0 ? s->prev_lsps : lsps[n - 1],\n                               &excitation[s->history_nsamples + n * MAX_FRAMESIZE],\n                               &synth[s->lsps + n * MAX_FRAMESIZE]))) {\n            *data_size = 0;\n            return res;\n        }\n    }\n\n    /* Statistics? FIXME - we don't check for length, a slight overrun\n     * will be caught by internal buffer padding, and anything else\n     * will be skipped, not read. */\n    if (get_bits1(gb)) {\n        res = get_bits(gb, 4);\n        skip_bits(gb, 10 * (res + 1));\n    }\n\n    /* Specify nr. of output samples */\n    *data_size = out_size;\n\n    /* Update history */\n    memcpy(s->prev_lsps,           lsps[2],\n           s->lsps             * sizeof(*s->prev_lsps));\n    memcpy(s->synth_history,      &synth[MAX_SFRAMESIZE],\n           s->lsps             * sizeof(*synth));\n    memcpy(s->excitation_history, &excitation[MAX_SFRAMESIZE],\n           s->history_nsamples * sizeof(*excitation));\n    if (s->do_apf)\n        memmove(s->zero_exc_pf,       &s->zero_exc_pf[MAX_SFRAMESIZE],\n                s->history_nsamples * sizeof(*s->zero_exc_pf));\n\n    return 0;\n}", "target": 0}
{"idx": 5258, "func": "void ff_fill_rectangle(FFDrawContext *draw, FFDrawColor *color,\n                       uint8_t *dst[], int dst_linesize[],\n                       int dst_x, int dst_y, int w, int h)\n{\n    int plane, x, y, wp, hp;\n    uint8_t *p0, *p;\n\n    for (plane = 0; plane < draw->nb_planes; plane++) {\n        p0 = pointer_at(draw, dst, dst_linesize, plane, dst_x, dst_y);\n        wp = (w >> draw->hsub[plane]);\n        hp = (h >> draw->vsub[plane]);\n        if (!hp)\n            return;\n        p = p0;\n        /* copy first line from color */\n        for (x = 0; x < wp; x++) {\n            memcpy(p, color->comp[plane].u8, draw->pixelstep[plane]);\n            p += draw->pixelstep[plane];\n        }\n        wp *= draw->pixelstep[plane];\n        /* copy next lines from first line */\n        p = p0 + dst_linesize[plane];\n        for (y = 1; y < hp; y++) {\n            memcpy(p, p0, wp);\n            p += dst_linesize[plane];\n        }\n    }\n}", "target": 0}
{"idx": 5259, "func": "static ngx_int_t\nngx_http_file_cache_exists(ngx_http_file_cache_t *cache, ngx_http_cache_t *c)\n{\n    ngx_int_t                    rc;\n    ngx_http_file_cache_node_t  *fcn;\n\n    ngx_shmtx_lock(&cache->shpool->mutex);\n\n    fcn = c->node;\n\n    if (fcn == NULL) {\n        fcn = ngx_http_file_cache_lookup(cache, c->key);\n    }\n\n    if (fcn) {\n        ngx_queue_remove(&fcn->queue);\n\n        if (c->node == NULL) {\n            fcn->uses++;\n            fcn->count++;\n        }\n\n        if (fcn->error) {\n\n            if (fcn->valid_sec < ngx_time()) {\n                goto renew;\n            }\n\n            rc = NGX_OK;\n\n            goto done;\n        }\n\n        if (fcn->exists || fcn->uses >= c->min_uses) {\n\n            c->exists = fcn->exists;\n            if (fcn->body_start) {\n                c->body_start = fcn->body_start;\n            }\n\n            rc = NGX_OK;\n\n            goto done;\n        }\n\n        rc = NGX_AGAIN;\n\n        goto done;\n    }\n\n    fcn = ngx_slab_calloc_locked(cache->shpool,\n                                 sizeof(ngx_http_file_cache_node_t));\n    if (fcn == NULL) {\n        ngx_shmtx_unlock(&cache->shpool->mutex);\n\n        (void) ngx_http_file_cache_forced_expire(cache);\n\n        ngx_shmtx_lock(&cache->shpool->mutex);\n\n        fcn = ngx_slab_calloc_locked(cache->shpool,\n                                     sizeof(ngx_http_file_cache_node_t));\n        if (fcn == NULL) {\n            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n                          \"could not allocate node%s\", cache->shpool->log_ctx);\n            rc = NGX_ERROR;\n            goto failed;\n        }\n    }\n\n    ngx_memcpy((u_char *) &fcn->node.key, c->key, sizeof(ngx_rbtree_key_t));\n\n    ngx_memcpy(fcn->key, &c->key[sizeof(ngx_rbtree_key_t)],\n               NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t));\n\n    ngx_rbtree_insert(&cache->sh->rbtree, &fcn->node);\n\n    fcn->uses = 1;\n    fcn->count = 1;\n\nrenew:\n\n    rc = NGX_DECLINED;\n\n    fcn->valid_msec = 0;\n    fcn->error = 0;\n    fcn->exists = 0;\n    fcn->valid_sec = 0;\n    fcn->uniq = 0;\n    fcn->body_start = 0;\n    fcn->fs_size = 0;\n\ndone:\n\n    fcn->expire = ngx_time() + cache->inactive;\n\n    ngx_queue_insert_head(&cache->sh->queue, &fcn->queue);\n\n    c->uniq = fcn->uniq;\n    c->error = fcn->error;\n    c->node = fcn;\n\nfailed:\n\n    ngx_shmtx_unlock(&cache->shpool->mutex);\n\n    return rc;\n}", "target": 1}
{"idx": 5260, "func": "static void compute_chapters_end(AVFormatContext *s)\n{\n    unsigned int i, j;\n    int64_t max_time = 0;\n\n    if (s->duration > 0)\n        max_time = s->duration +\n                       ((s->start_time == AV_NOPTS_VALUE) ? 0 : s->start_time);\n\n    for (i = 0; i < s->nb_chapters; i++)\n        if (s->chapters[i]->end == AV_NOPTS_VALUE) {\n            AVChapter *ch = s->chapters[i];\n            int64_t end = max_time ? av_rescale_q(max_time, AV_TIME_BASE_Q,\n                                                  ch->time_base)\n                                   : INT64_MAX;\n\n            for (j = 0; j < s->nb_chapters; j++) {\n                AVChapter *ch1     = s->chapters[j];\n                int64_t next_start = av_rescale_q(ch1->start, ch1->time_base,\n                                                  ch->time_base);\n                if (j != i && next_start > ch->start && next_start < end)\n                    end = next_start;\n            }\n            ch->end = (end == INT64_MAX) ? ch->start : end;\n        }\n}", "target": 0}
{"idx": 5261, "func": "size_t BUF_MEM_grow(BUF_MEM *str, size_t len)\n{\n    char *ret;\n    size_t n;\n\n    if (str->length >= len) {\n        str->length = len;\n        return (len);\n    }\n    if (str->max >= len) {\n        memset(&str->data[str->length], 0, len - str->length);\n        str->length = len;\n        return (len);\n    }\n    /* This limit is sufficient to ensure (len+3)/3*4 < 2**31 */\n    if (len > LIMIT_BEFORE_EXPANSION) {\n        BUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    n = (len + 3) / 3 * 4;\n    if ((str->flags & BUF_MEM_FLAG_SECURE))\n        ret = sec_alloc_realloc(str, n);\n    else\n        ret = OPENSSL_realloc(str->data, n);\n    if (ret == NULL) {\n        BUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);\n        len = 0;\n    } else {\n        str->data = ret;\n        str->max = n;\n        memset(&str->data[str->length], 0, len - str->length);\n        str->length = len;\n    }\n    return (len);\n}", "target": 1}
{"idx": 5262, "func": "static char *parse_link_name(const char **buf, void *log_ctx)\n{\n    const char *start = *buf;\n    char *name;\n    (*buf)++;\n\n    name = av_get_token(buf, \"]\");\n\n    if (!name[0]) {\n        av_log(log_ctx, AV_LOG_ERROR,\n               \"Bad (empty?) label found in the following: \\\"%s\\\".\\n\", start);\n        goto fail;\n    }\n\n    if (*(*buf)++ != ']') {\n        av_log(log_ctx, AV_LOG_ERROR,\n               \"Mismatched '[' found in the following: \\\"%s\\\".\\n\", start);\n    fail:\n        av_freep(&name);\n    }\n\n    return name;\n}", "target": 1}
{"idx": 5263, "func": "static void evaluate_utility_inc(elbg_data *elbg)\n{\n    int i, inc=0;\n\n    for (i=0; i < elbg->numCB; i++) {\n        if (elbg->numCB*elbg->utility[i] > elbg->error)\n            inc += elbg->utility[i];\n        elbg->utility_inc[i] = inc;\n    }\n}", "target": 1}
{"idx": 5264, "func": "int BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max)\n{\n    int i, j, k = 0;\n    BN_ULONG mask;\n\n    if (BN_is_zero(a))\n        return 0;\n\n    for (i = a->top - 1; i >= 0; i--) {\n        if (!a->d[i])\n            /* skip word if a->d[i] == 0 */\n            continue;\n        mask = BN_TBIT;\n        for (j = BN_BITS2 - 1; j >= 0; j--) {\n            if (a->d[i] & mask) {\n                if (k < max)\n                    p[k] = BN_BITS2 * i + j;\n                k++;\n            }\n            mask >>= 1;\n        }\n    }\n\n    if (k < max) {\n        p[k] = -1;\n        k++;\n    }\n\n    return k;\n}", "target": 1}
{"idx": 5265, "func": "static av_always_inline int encode_line(FFV1Context *s, int w,\n                                        int16_t *sample[3],\n                                        int plane_index, int bits)\n{\n    PlaneContext *const p = &s->plane[plane_index];\n    RangeCoder *const c   = &s->c;\n    int x;\n    int run_index = s->run_index;\n    int run_count = 0;\n    int run_mode  = 0;\n\n    if (s->ac) {\n        if (c->bytestream_end - c->bytestream < w * 35) {\n            av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } else {\n        if (s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb) >> 3) < w * 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    if (s->slice_coding_mode == 1) {\n        for (x = 0; x < w; x++) {\n            int i;\n            int v = sample[0][x];\n            for (i = bits-1; i>=0; i--) {\n                uint8_t state = 128;\n                put_rac(c, &state, (v>>i) & 1);\n            }\n        }\n        return 0;\n    }\n\n    for (x = 0; x < w; x++) {\n        int diff, context;\n\n        context = get_context(p, sample[0] + x, sample[1] + x, sample[2] + x);\n        diff    = sample[0][x] - predict(sample[0] + x, sample[1] + x);\n\n        if (context < 0) {\n            context = -context;\n            diff    = -diff;\n        }\n\n        diff = fold(diff, bits);\n\n        if (s->ac) {\n            if (s->flags & CODEC_FLAG_PASS1) {\n                put_symbol_inline(c, p->state[context], diff, 1, s->rc_stat,\n                                  s->rc_stat2[p->quant_table_index][context]);\n            } else {\n                put_symbol_inline(c, p->state[context], diff, 1, NULL, NULL);\n            }\n        } else {\n            if (context == 0)\n                run_mode = 1;\n\n            if (run_mode) {\n                if (diff) {\n                    while (run_count >= 1 << ff_log2_run[run_index]) {\n                        run_count -= 1 << ff_log2_run[run_index];\n                        run_index++;\n                        put_bits(&s->pb, 1, 1);\n                    }\n\n                    put_bits(&s->pb, 1 + ff_log2_run[run_index], run_count);\n                    if (run_index)\n                        run_index--;\n                    run_count = 0;\n                    run_mode  = 0;\n                    if (diff > 0)\n                        diff--;\n                } else {\n                    run_count++;\n                }\n            }\n\n            av_dlog(s->avctx, \"count:%d index:%d, mode:%d, x:%d pos:%d\\n\",\n                    run_count, run_index, run_mode, x,\n                    (int)put_bits_count(&s->pb));\n\n            if (run_mode == 0)\n                put_vlc_symbol(&s->pb, &p->vlc_state[context], diff, bits);\n        }\n    }\n    if (run_mode) {\n        while (run_count >= 1 << ff_log2_run[run_index]) {\n            run_count -= 1 << ff_log2_run[run_index];\n            run_index++;\n            put_bits(&s->pb, 1, 1);\n        }\n\n        if (run_count)\n            put_bits(&s->pb, 1, 1);\n    }\n    s->run_index = run_index;\n\n    return 0;\n}", "target": 0}
